content,label,problem,from,idx,problem_title,problem_description,input_output_specification,tags
"def numtostr(a):
    var=[]
    while a>0:
 
       if a%26==0:
          var.append(""Z"")
          a=a//26-1
       else:
          var.append(chr(a%26-1+ord(""A"")))
          a=a//26
    var.reverse()
    return """".join(var)
 
def strtonum(b):
    par=len(b)
    result=0
    for i in range(1,par):
        result+=(26**i)
    par=len(b)-1
    for elem in b:
        if par!=0:
             result+=((ord(elem)-ord(""A""))*((26)**par))
        else:
            result += ((ord(elem) - ord(""A""))+1)
 
        if par==0:
            break
        par -= 1
    return result
 
def method1(par1):
    C=par1.index(""C"")
    result=numtostr(int(par1[C+1:]))+str(par1[1:C])
    return result
 
def method2(par2):
    c=0
    for elem in par2:
        try:
            if int(elem):
                break
        except:
            c+=1
    return ""R""+par2[c:]+""C""+str(strtonum(par2[:c]))
 
i=input()
inp=[]
for j in range(int(i)):
     x=input()
     inp.append(x)
for key in range(len(inp)):
    if ""R"" in inp[key] and ""C"" in inp[key]:
        try:
            if int(inp[key][1:inp[key].index(""C"")]) and int(inp[key][inp[key].index(""C"")+1:]):
                print(method1(inp[key]))
        except:
            print(method2(inp[key]))
    else:
        print(method2(inp[key]))",3,0001_B,CODEFORCES,1425,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import re
import string
import math

letter_number_pattern = ""[a-zA-Z]*[0-9]*""

alpha = dict(zip(range(1,28), string.ascii_uppercase))
decimals = dict(zip(string.ascii_uppercase, range(1,27)))


alpha_len = len(alpha)

def letter_to_decimal(n):
    exponents = []
    pow_i = 0
    while True:
        if n // (26**pow_i) > 26:
            exponents.append(1)
            n = n - (26**pow_i)
            pow_i += 1
        else:
            exponents.append(n // (26**pow_i))
            n = n - ((n // (26**pow_i)) * (26**pow_i))
            break
    pow_i = pow_i - 1
    while n != 0:
        t = n // (26**pow_i)
        n = n - (t * (26 ** pow_i))
        exponents[pow_i] = exponents[pow_i] + t
        pow_i = pow_i - 1
    result = ''.join(list(map(lambda x: alpha[x], reversed(exponents))))
    return result


def letters_to_deci(letters):
    total_sum = 0
    pows = list(reversed(range(len(letters))))
    for i in range(len(letters)):
        total_sum += decimals[letters[i]] * (26**pows[i])
    return total_sum

input_cells = []

n_lines = input()
for i in range(int(n_lines)):
    input_cells.append(input())

for cell in input_cells:
    all_matches = re.findall(letter_number_pattern, cell)[:-1]
    if len(all_matches) == 2:
        rows = int(re.search(""[0-9]*$"", all_matches[0]).group())
        cols = int(re.search(""[0-9]*$"", all_matches[1]).group())
        converted_cols = letter_to_decimal(cols)
        print(""%s%s"" % (converted_cols, rows))
    elif len(all_matches) == 1:
        rows = re.match(""[A-Z]*"", all_matches[0]).group()
        cols = re.search(""[0-9]*$"", all_matches[0]).group()
        converted_rows = letters_to_deci(rows)
        print(""R%sC%s"" % (cols, converted_rows))
    else:
        pass",3,0001_B,CODEFORCES,1427,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"for _ in range(int(input())):
    s = input()
    ro=co=0
    for c in s:
        if '0'<= c <= '9': ro = 10*ro+int(c)
        elif ro:
            ro, co = s[1:].split('C'); co=int(co)
            v = ''
            while co:
                co-=1
                r = co%26
                co = co//26
                v += chr(65+r)
            print(v[::-1]+ro)
            break
        else: co = co*26 + ord(c) - 64
    else:
        print(""R{}C{}"".format(ro, co))
    
",3,0001_B,CODEFORCES,1426,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"def solution():
    n = int(input())
    for _ in range(n):
        s = input()
        p = s.find('C')

        # R23C55 -> BC23
        if s[0] == 'R' and s[1].isdigit() and p > 1:
            r = int(s[1:p])
            c = int(s[(p + 1):])

            v = list()
            while c > 0:
                if c % 26 == 0:
                    v.append('Z')
                    c = (c - 1) // 26
                else:
                    v.append(chr(ord('A') + (c % 26 - 1)))
                    c //= 26

            v.reverse()
            print(""%s%d"" % ("""".join(v), r))

        else:
            p = 0
            while p < len(s):
                if s[p].isdigit():
                    break
                p += 1

            sr = s[:p]
            sc = s[p:]

            c = 0
            for x in sr:
                c = c * 26 + (ord(x) - ord('A') + 1)

            print(""R%sC%d"" % (sc, c))


if __name__ == ""__main__"":
    solution()
",3,0001_B,CODEFORCES,1429,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"def decimal_to_26(num):
    num = int(num)
    res = ''
    while num:
        mod = num % 26
        if mod == 0:
            res = 'Z' + res
            num = num // 26 - 1
        else:
            num //= 26
            res = chr(mod+64) + res
    return res

def RXCY_to_Excel(c,r):
    new_row = decimal_to_26(r)
    return new_row + str(c)
# print(RXCY_to_Excel(55,23))

n = int(input())
li = []
for i in range(n):
    li.append(input())
for i in li:
    di_index = []
    al_index = []
    temp = i
    for j in range(len(i)):
        if i[j].isalpha():
            al_index.append(j)
            i = i.replace(i[j],' ')
            # print(i)
        elif i[j].isdigit():
            di_index.append(j)
            i = i.replace(i[j],' ')
            # print(i)
    i = temp
    if min(di_index) < max(al_index): # RxxCxx
        # print(i)
        row = int(i[1:i.index('C')])
        col = int(i[i.index('C')+1:])
        # print(row,col,sep=' ')
        print(RXCY_to_Excel(row,col))
    else: # COL + ROW
        row_num = 0
        for k in range(len(i)):
            if i[k].isdigit():
                num_start = k
                break
        # print(i)
        # print(k)
        length = len(i[0:k])
        # print(length)
        for m in range(num_start):
            row_num += 26 ** (length-1) * (ord(i[m])-64) or (ord(i[m])-64)
            # print(row_num)
            length -= 1
        print('R'+i[num_start:]+'C'+str(row_num))








",3,0001_B,CODEFORCES,1424,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"import re

inputs = int(input())

for x in range(inputs):
    coordinates = input()
    match = re.match(""R(\d+)C(\d+)"", coordinates)
    if match:
        rows = int(match.group(1))
        columns = int(match.group(2))

        output = """"
        i = 0
        while columns > 0:
            alpha_index = (columns // (26 ** i) - 1) % 26
            output = chr(65 + alpha_index) + output
            # print(columns, alpha_index)
            columns -= (alpha_index + 1) * (26 ** i)
            i += 1
        output += str(rows)
        print(output)
    else:
        match = re.match(""(\D+)(\d+)"", coordinates)
        letters = match.group(1)
        rows = match.group(2)
        columns = 0
        for i in range(len(letters), 0, -1):
            columns += (ord(letters[i - 1]) - 64) * (26 ** (len(letters) - i))
        output = f""R{rows}C{columns}""
        print(output)
",3,0001_B,CODEFORCES,1422,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"def parse(line):
	i = 0
	while line[i].isalpha():
		i += 1
	i1 = i
	while i < len(line) and line[i].isdigit():
		i += 1
	return line[:i1], int(line[i1:i]), line[i:]

for _ in range(int(input())):
	a1, n1, rest = parse(input())
	if rest:
		_, n2, _ = parse(rest)
		a2 = ''
		while n2:
			r = (n2 - 1) % 26
			a2 = chr(r + ord('A')) + a2
			n2 = (n2 - r - 1) // 26
		print(a2 + str(n1))
	else:
		n2 = 0
		for c in a1:
			n2 = 26 * n2 + (ord(c) - ord('A') + 1)
		print(f'R{n1}C{n2}')
		

",3,0001_B,CODEFORCES,1428,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"from math import floor
import re

z = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""

# numbers to row
# def convert_num(x):
#     output = """"
#     row, col = [int(x) for x in re.split(""(\d+)"", x) if x.isnumeric()]
#     while col > 0:
#         if col % 26 == 0:
#             col = floor(col / 26)
#             output += ""Z""
#         else:
#             y = col % 26
#             output += z[y - 1]
#             col = floor(col / 26)
#     return f""{output[::-1]}{row}""
def convert_num(x):
    output = """"
    row, col = [int(x) for x in re.split(""(\d+)"", x) if x.isnumeric()]
    while col > 0:
        y = (col - 1) % 26
        output += z[y]
        col = floor((col - 1) / 26)
    return f""{output[::-1]}{row}""


# letters to alpha
def convert_alpha(x):
    output = 0
    word = ("""".join([i for i in x if i.isalpha()]))[::-1]
    for i in range(0, len(word)):
        output += (z.index(word[i]) + 1) * 26 ** i
    ending = x[len(word) :]

    return f""R{ending}C{output}""


# print(convert_alpha(""BC23""))
# print(convert_num(""R23C55""))

i = int(input())
output = """"
for x in range(i):
    hehexd = input()
    if hehexd.startswith(""R"") and hehexd[1].isnumeric() and ""C"" in hehexd:
        output += f""{convert_num(hehexd)}\n""
    else:
        output += f""{convert_alpha(hehexd)}\n""
print(output)",3,0001_B,CODEFORCES,1423,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"def solution():
    v = list()

    n = int(input())
    for _ in range(n):
        s = input()
        p = s.find('C')

        # R23C55 -> BC23
        if s[0] == 'R' and s[1].isdigit() and p > 1:
            r = int(s[1:p])
            c = int(s[(p + 1):])

            v.clear()
            while c > 0:
                if c % 26 == 0:
                    v.append('Z')
                    c = (c - 1) // 26
                else:
                    v.append(chr(ord('A') + (c % 26 - 1)))
                    c //= 26

            v.reverse()
            print(""%s%d"" % ("""".join(v), r))

        else:
            c = 0
            p = 0
            while p < len(s):
                if s[p].isdigit():
                    break
                c = c * 26 + (ord(s[p]) - ord('A') + 1)
                p += 1

            print(""R%sC%d"" % (s[p:], c))


if __name__ == ""__main__"":
    solution()
",3,0001_B,CODEFORCES,1430,Spreadsheets,"In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.
The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 
Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.
Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.
","input
The first line of the input contains integer number n (1 ≤ n ≤ 105), the number of coordinates in the test. Then there follow n lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .
output
Write n lines, each line should contain a cell coordinates in the other numeration system.
","implementation, math"
"n=int(input())
l=list(map(int,input().split(' ')))
l.sort(reverse=True)
#print(l)
coin=0
total_sum=sum(l)
current_sum=0
for i in range(len(l)):
    coin+=1
    current_sum=current_sum+l[i]
    remaining_sum=total_sum-current_sum
    if current_sum>remaining_sum:
        break
print(coin)",4,0160_A,CODEFORCES,2314,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"n = int(input())
coins = list(map(int, input().split()))
coins.sort(reverse=True)
target = (sum(coins)+2)//2

count = 1
total = coins[count-1]
while total < target:
    count += 1
    total += coins[count-1]

print(count)

",4,0160_A,CODEFORCES,2313,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"n=int(input())
a=list(map(int, input().rstrip().split()))
a.sort()
sum1=0
rem=sum(a)
i=len(a)-1
c=0
while(sum1<=rem):
    sum1+=a[i]
    rem=sum(a)-sum1
    i-=1
    c+=1
print(c)",4,0160_A,CODEFORCES,2320,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"def ballbuster5000(arr, rj):
    for i in arr:
        rj += i
    gg = 0
    i = 0
    while gg <= rj:
        gg += arr[i]
        rj -= arr[i]
        i -= -1
    return i


n = int(input())
x = list(map(int, input().strip().split()))
x.sort(reverse=True)
print(ballbuster5000(x, 0))",4,0160_A,CODEFORCES,2311,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"n=int(input())
list1=list(map(int,input().split(' ')))
sum2=0
sum1=0
count=0
list1.sort(reverse=True)
for i in range(len(list1)):
    sum1=sum1+list1[i]

for i in range(len(list1)):
    if(int(sum1/2)>=sum2):
        sum2=sum2+list1[i]
        count=count+1
print(count)",4,0160_A,CODEFORCES,2319,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"s=input()
a=list(map(int,input().split()))
k=sorted(a)
b=0
q=0
m=0
for i in k:
    b=b+i
for i in k[::-1]:
    q=q+i
    m=m+1
    if q>(b/2):
        break
print(m)    ",4,0160_A,CODEFORCES,2318,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"n = int(input())
a = list(map(int, input().split()))
a = sorted(a, reverse=True)
s1 = 0
s2 = sum(a)

for i in range(len(a)):
    s1 += a[i]
    s2 -= a[i]
    if s1 > s2:
        break

print(i + 1)",4,0160_A,CODEFORCES,2312,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"input();a=sorted(map(int,input().split()));s=c=0
while s<=sum(a):s+=a.pop();c+=1
print(c)",4,0160_A,CODEFORCES,2323,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"t=int(input())
l=list(map(int,input().split()))
b_sum=0
l.sort()
for i in l:
  b_sum += i

m_sum=0
c=0
for i in l[::-1]:
  m_sum += i
  c += 1
  if m_sum > (b_sum/2):
    break
print(c)",4,0160_A,CODEFORCES,2328,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"n = int(input())
lst = list(map(int,input().split()))
lst.sort()
lst.reverse()
m = 0
for i in range(n):
  if sum(lst[:i]) > sum(lst[i:]):
    break
  else:
    m+=1
print(m)",4,0160_A,CODEFORCES,2316,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"n=int(input())
a=list(map(int,input().split()))
a.sort()
# print(a)
total_money=sum(a)
i_have=0
reaming=total_money-i_have
cnt=0
for i in range(n-1,-1,-1):
    reaming=total_money-i_have
    if i_have>reaming:
        break
    i_have+=a[i]
    cnt+=1
print(cnt)",4,0160_A,CODEFORCES,2321,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"n = int(input())
a = list(map(int, input().split()))
b = sorted(a,reverse=True)
total = sum(a)
gain = 0
num = 0
for x in range(len(b)):
    gain += b[x]
    num += 1
    if gain>total/2:
        break
print(num)",4,0160_A,CODEFORCES,2325,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"def sum(l):
    s=0
    for i in range(len(l)):
        s+=l[i]
    return s
 
n=int(input())
cns=list(map(int,input().split()))
xs,nm,c=0,0,0
cns.append(0)
while(xs<=nm):
    m=max(cns)
    cns.remove(m)
    xs+=m
    nm=sum(cns)
    c+=1
print(c)
    ",4,0160_A,CODEFORCES,2322,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"s = input()
l = list(map(int,input().split()))
l.sort(reverse = True)
s = sum(l)
x = 0 
c = 0
for i in l:
    if x <= s:
        c+=1
        x+=i
        s-=i
    else:
        break
print(c)",4,0160_A,CODEFORCES,2315,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"n=input()
l = list(map(int,input().split()))
l = sorted(l)
s = 0
c = 0
cnt =0
for i in l:
	s+=i
for i in l[::-1]:
	c+=i
	cnt+=1
	if c >(s/2):
		break
print(cnt) ",4,0160_A,CODEFORCES,2317,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"import sys
coins = []
coinsValueTotal = 0
n = int(sys.stdin.readline())
inputs = sys.stdin.readline().split()
for i in range(len(inputs)):
    coin = int(inputs[i])
    coins.append(coin)
    coinsValueTotal += coin
coins.sort(reverse = True)
minCoins = 0
halfCoinsValueTotal = coinsValueTotal / 2
for i in range(len(coins)):
    minCoins +=  coins[i]
    if(minCoins > halfCoinsValueTotal):
        print(i+1)
        break
",4,0160_A,CODEFORCES,2324,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"n=int(input())
list1=list(map(int,input().split(' ')))
sum2=0
sum1=0
count=0
list1.sort(reverse=True)
for i in range(len(list1)):
    sum1=sum1+list1[i]
 
for i in range(len(list1)):
    if(int(sum1/2)>=sum2):
        sum2=sum2+list1[i]
        count=count+1
print(count)",4,0160_A,CODEFORCES,2326,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"p = int(input())
arr = list(map(int, input().split()))
arr.sort(reverse=True)
d = 0
for x in arr:
    d += x
c = 0
num = 0
while c <= d/2:
    c += arr[num]
    num += 1
print(num)
",4,0160_A,CODEFORCES,2327,Twins,"Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.
Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, n coins of arbitrary values a1, a2, ..., an. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.
As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.
The first line contains integer n (1 ≤ n ≤ 100) — the number of coins. The second line contains a sequence of n integers a1, a2, ..., an (1 ≤ ai ≤ 100) — the coins' values. All numbers are separated with spaces.
In the single line print the single number — the minimum needed number of coins.
","input
In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.
output
In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2. 
","greedy, sortings"
"# minimal by inclusion means that any subset cannot satisfy the same requirements (essentially no duplicates at either end)

n, k = map(int, input().split())
values, single, l, r = [int(i) for i in input().split()], set(), -1, -1
for i in range(n):
    single.add(values[i])
    if len(single) == k:
        l, r = 1, i + 1
        break
single = set()
for i in range(r - 1, max(-1, l - 2), -1):
    single.add(values[i])
    if len(single) == k:
        l = i + 1
        break
        
if len(single) < k:
    print(-1, -1)
else:
    print(l, r)
",3,0224_B,CODEFORCES,1461,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"n,k = map(int,input().split())
a = list(map(int,input().split()))

count = 0
b = {}
for i in range(n):
    if a[i] in b:
        b[a[i]] += 1
    else:
        b[a[i]] =1
    if b[a[i]] == 1:
        count += 1
    if count == k:
        break
#print(""i="", i)
#print(b)


for j in range(n):
  if a[j] in b:
    b[a[j]] -= 1
#    print(""j="", j)
#    print(b)
  if b[a[j]] == 0:
    break 
#  print(""j="",j)
        
if count != k:
    print(""-1 -1"")
else:
  if n == 1:
    print(1,1)
  elif n == 2 and count == 2:
    print(1,2)
  else:
    print(j+1,i+1)  ",3,0224_B,CODEFORCES,1459,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"n,k=map(int,input().split())
a=list(map(int,input().split()))
q={0}
e=0
l=[]
for i in range(n):
    if a[i] not in q:
        e+=1
        q.add(a[i])
    if e==k:
        e=0
        q={0}
        l+=[i]
w=10**5
t=0
for i in l:
    e=0
    q={0}
    for j in range(i,-1,-1):
        if a[j] not in q:
            e+=1
            q.add(a[j])
        if e==k:
            if w>len(q):
                w=j+1
                t=i+1
            break
if len(set(a))>=k:print(w,t)
else:print(-1,-1)
",3,0224_B,CODEFORCES,1465,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"from sys import stdin,stdout
from collections import Counter
nmbr=lambda:int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr()):
    n,k=lst()
    a=lst()
    d={};r=l=-2
    for i in range(n):
        d[a[i]]=d.get(a[i],0)+1
        if len(d)==k:
            r=i
            break
    for i in range(r+1):
        if d[a[i]]==1:
            l=i
            break
        d[a[i]]-=1
    print(l+1,r+1)",3,0224_B,CODEFORCES,1462,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"n, k= map(int, input().split())
A = list(map(int, input().split()))
C = [0] * 100001

l = 0
r = 0
p = 0

while r<n and p < k:
    C[A[r]] += 1
    if C[A[r]] == 1:
        p += 1
    r += 1
if p != k:
    print('-1', '-1')
else:
    while p == k:
        C[A[l]] -= 1
        if C[A[l]] == 0:
            p -= 1
        l +=1
        
    l -= 1
    
    print(l+1,r)",3,0224_B,CODEFORCES,1463,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"n, m = map(int, input().split())
arr = list(map(int, input().split()))
d = {}
i = 1
for x in arr:
	if len(d) == m:
		break
	d[x] = i
	i += 1
if len(d) == m:
	print(min(d.values()), max(d.values()))
else:
	print(-1,-1)
",3,0224_B,CODEFORCES,1466,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"n, k = map(int,input().split())
arr = list(map(int, input().split()))

def find_segment(arr, n, k):
  f = [0]*100001
  L = count = 0
  R = -1
  while R < n-1:
    R += 1
    if f[arr[R]] == 0:
      count += 1
    f[arr[R]] += 1
    while count == k:
      f[arr[L]] -= 1
      if f[arr[L]] == 0:
        print(L+1, R+1)
        return
      L += 1
  print(-1,-1)
find_segment(arr, n, k)",3,0224_B,CODEFORCES,1458,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"n, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

count = [0]*(int(1e5+1))

for i in arr:
    count[i] += 1

s = sum([1 if i>0 else 0 for i in count])
if s < k:
    print('-1 -1')
    exit()

r = n-1
while True:
    if count[arr[r]] == 1:
        s -= 1
        if s < k:
            s += 1
            break
    count[arr[r]] -= 1
    r -= 1

l=0
while True:
    if count[arr[l]] == 1:
        s -= 1
        if s < k:
            s += 1
            break
    count[arr[l]] -= 1
    l += 1

print(l+1, r+1)

",3,0224_B,CODEFORCES,1464,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"n,k=map(int, input().split())
a=list(map(int, input().split()))
i=0
d=0
x=-1
y=-1
s=[0]*(10**5+1)
for j in range (len(a)):
    s[a[j]]+=1
    i+=1
    if s[a[j]]==1:
        d+=1
    if i==1:
        x=j+1
    if d==k:
        y=j+1
        break
while k!=1 and s[a[x-1]]-1!=0:
    s[a[x-1]]-=1
    x+=1
if x==-1 or y==-1:
    x=-1
    y=-1
print(x,y)",3,0224_B,CODEFORCES,1460,Array,"You've got an array a, consisting of n integers: a1, a2, ..., an. Your task is to find a minimal by inclusion segment [l, r] (1 ≤ l ≤ r ≤ n) such, that among numbers al,  al + 1,  ...,  ar there are exactly k distinct numbers.
Segment [l, r] (1 ≤ l ≤ r ≤ n; l, r are integers) of length m = r - l + 1, satisfying the given property, is called minimal by inclusion, if there is no segment [x, y] satisfying the property and less then m in length, such that 1 ≤ l ≤ x ≤ y ≤ r ≤ n. Note that the segment [l, r] doesn't have to be minimal in length among all segments, satisfying the given property.
The first line contains two space-separated integers: n and k (1 ≤ n, k ≤ 105). The second line contains n space-separated integers a1, a2, ..., an — elements of the array a (1 ≤ ai ≤ 105).
Print a space-separated pair of integers l and r (1 ≤ l ≤ r ≤ n) such, that the segment [l, r] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.
In the first sample among numbers a1 and a2 there are exactly two distinct numbers.
","input
In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.
output
In the third sample there is no segment with four distinct numbers.
","bitmasks, implementation, twopointers"
"list1=input()
l=list1.split()
l=[int(item) for item in l]

n,m,k=l

a=input()
a1=map(int,a.split())

a1=list(sorted(a1))

count=0
for i in range(len(a1)):
    if k>=m:
        break
    else:
        k+=a1.pop()-1
        count+=1

if k>=m:    
    print(count)
else:
    print(""-1"")",4,0257_A,CODEFORCES,2378,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"# cook your dish here
a,b,c = map(int,input().split())
arr = list(map(int,input().split()))

arr.sort()
p = 0
a-=1
while(a>=0 and c<b):
    c-=1
    p+=1
    c+=arr[a]
    a-=1
if(c<b):
    print(-1)
else:
    print(p)",4,0257_A,CODEFORCES,2389,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"f, d, s = [int(i) for i in input().split()]
filters = [int(i) for i in input().split()]
filters.sort(reverse=True)

freeSockets = s
usedFilters = 0
for i in range(len(filters)):
    if freeSockets >= d:
        break
    usedFilters += 1
    freeSockets += filters[i]-1

if freeSockets >= d:
    print(usedFilters)
else:
    print(-1)

",4,0257_A,CODEFORCES,2388,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(50001)] 
pp=[]
def SieveOfEratosthenes(n=50000): 
      
    # Create a boolean array ""prime[0..n]"" and initialize 
    #  all entries it as true. A value in prime[i] will 
    # finally be false if i is Not a prime, else true. 
    
    p = 2
    while (p * p <= n): 
          
        # If prime[p] is not changed, then it is a prime 
        if (prime[p] == True): 
              
            # Update all multiples of p 
            for i in range(p * p, n+1, p): 
                prime[i] = False
        p += 1
    for i in range(50001):
        if prime[i]:
            pp.append(i)
#---------------------------------running code------------------------------------------
n,m,k=map(int,input().split())
a=list(map(int,input().split()))
a.sort(reverse=True)
if k>=m:
    print(0)
else:
    curr=k
    count=0
    for i in range (n):
        curr+=a[i]-1
        count+=1
        if curr>=m:
            break
    if curr>=m:
        print(count)
    else:
        print(-1)",4,0257_A,CODEFORCES,2384,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
arr.sort()
arr=arr+[k]
ans=0
s=0
while ans<n+1:
    s+=arr[-ans-1]
    if s>=m:
        break
    ans+=1
    s-=1
if s>=m:
    print(ans)
else:
    print(""-1"")
",4,0257_A,CODEFORCES,2387,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"n_extnson, n_dvics, n_sokts = list(map(int, input().split()))
extensions = list(map(int, input().split()))
extensions.sort(reverse=True)
devices_left = n_dvics - n_sokts
extnson_used = 0
i = 0
while devices_left > 0 and n_extnson > 0:
    devices_left += 1
    extnson_siez = extensions[i]
    devices_left -= extnson_siez
    extnson_used += 1
    n_extnson -= 1
    i += 1

if devices_left > 0:
    print(-1)
else:
    print(extnson_used)


",4,0257_A,CODEFORCES,2395,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"x,y,z=map(int,input().split())
l=list(map(int,input().split()))
l.sort()
c=0
s=z
t=False
while s<y and c<x:
    c+=1
    s=s+l[x-c]-1
if s<y:
    print(-1)
else:
    print(c)
    
    ",4,0257_A,CODEFORCES,2380,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"
n,m,k=map(int,input().split())
list1=list(map(int,input().split()))
list1.sort(reverse=True)
c=0
i=0

while(k<m and i<n):
    k+=list1[i]-1
    i+=1
    c+=1
if(k>=m):
    print(c)
else:
    print(-1)",4,0257_A,CODEFORCES,2379,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"n,m,k = map(int,input().split())
a = list(map(int,input().split()))
a.sort()
a = a[::-1]
if m<=k:
    print(0)
else:
    c=0
    while(c<n):
        k = k+a[c]-1
        c+=1
        if k>=m:
            print(c)
            exit()
    else:
        print(-1)
        ",4,0257_A,CODEFORCES,2392,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"n,m,k = [int(y) for y in input().split()]
a = [int(y) for y in input().split()]
a.sort(reverse=True)
no = 0
while k < m and no < n:
    k += a[no]-1
    no += 1
if k < m:
    print(-1)
else:
    print(no)",4,0257_A,CODEFORCES,2390,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"# Problem Link: XXXX
# Author: Raunak Sett
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

# do magic here

n, m, k = map(int, input().split())

# Sort filters
filters = list(map(int, input().split()))
filters.sort()

supply_filters_needed = 0
if k < m:
    spots = k
    end = n - 1
    while spots < m and end >= 0:
        spots += filters[end] - 1
        supply_filters_needed += 1
        end -= 1

    if spots < m:
        print(-1)
    else:
        print(supply_filters_needed)
else:
    print(0)    ",4,0257_A,CODEFORCES,2381,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"n, m, k = map(int,input().split())
line = [int(x) for x in input().split()]
line.sort(reverse = True)
count = 0
if k >=m:
    print(count)
    exit(0)
for i in range(n):
    k += line[i]-1
    count += 1
    if k >= m:
        print(count)
        exit(0)
print(-1)",4,0257_A,CODEFORCES,2382,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"n,m,k = map(int,input().split())
a = list(map(int,input().split()))
a.sort(reverse = True)
s = 0
count = 0

i = 0
while k<m and i<n:
    k+=a[i]-1
    i+=1
print(i if k>=m else -1)
",4,0257_A,CODEFORCES,2383,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"def socket(n,m,k,arr):
    arr.sort(reverse=True)
    devices=m
    curr_socket=0
    e_socket=k
    i=0
    t_socket=0
    count=0
    while i<n:
        if e_socket>=devices:
            return 0
        if curr_socket==0:
            curr_socket+=arr[i]
            count+=1
            e_socket-=1
            t_socket=curr_socket+e_socket
        else:
            if t_socket>=devices:
                return count
            else:
                curr_socket+=arr[i]-1
                count+=1
                t_socket=curr_socket+e_socket
        i+=1
    if t_socket>=devices:
        return count
    return -1

n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
print(socket(n,m,k,arr))",4,0257_A,CODEFORCES,2394,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"n, m, k = map(int, input().split())
a = sorted(map(int, input().split()))
r = [x for x in range(n + 1) if sum(a[n - x :]) + k >= m + x]
print(min(r) if r else -1)
",4,0257_A,CODEFORCES,2393,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"# XXXX

n, m, k = list(map(int, input().split()))
f = list(map(int, input().split()))
f.sort()

fs = 0
ptr = len(f) - 1
while ptr >= 0:
    if m <= k:
        print(fs)
        exit()
    k -= 1
    k += f[ptr]
    fs += 1
    ptr -= 1

if m <= k:
    print(fs)
else:
    print(-1)",4,0257_A,CODEFORCES,2386,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"n, m, k = map(int, input().split());
a = list(map(int, input().split()));
a.sort(reverse = True);
if sum(a)+k-n < m:
    print(-1);
elif k >= m:
    print(0);
else:
    for i in range (1, n+1):
        if sum(a[:i])+k-i >= m:
            print(i)
            break;

",4,0257_A,CODEFORCES,2385,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"n,m,k=map(int,input().split())
x=list(map(int,input().split()))
x.sort(reverse=True)
i=-1
if k>=m:
    print(0)
else:
    for i in range(n):
        k-=1
        k+=x[i]
        if k>=m:
            break
    if k>=m:
        print(i+1)
    else:print(-1)",4,0257_A,CODEFORCES,2391,Sockets,"Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has ai sockets.
Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity. 
What minimum number of supply-line filters from the given set will Vasya need to plug all the devices he has to electricity? Note that all devices and supply-line filters take one socket for plugging and that he can use one socket to plug either one device or one supply-line filter.
The first line contains three integers n, m, k (1 ≤ n, m, k ≤ 50) — the number of supply-line filters, the number of devices and the number of sockets that he can plug to directly, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 50) — number ai stands for the number of sockets on the i-th supply-line filter.
Print a single number — the minimum number of supply-line filters that is needed to plug all the devices to electricity. If it is impossible to plug all the devices even using all the supply-line filters, print -1.
","input
In the first test case he can plug the first supply-line filter directly to electricity. After he plug it, he get 5 (3 on the supply-line filter and 2 remaining sockets for direct plugging) available sockets to plug. Thus, one filter is enough to plug 5 devices.
output
One of the optimal ways in the second test sample is to plug the second supply-line filter directly and plug the fourth supply-line filter to one of the sockets in the second supply-line filter. Thus, he gets exactly 7 sockets, available to plug: one to plug to the electricity directly, 2 on the second supply-line filter, 4 on the fourth supply-line filter. There's no way he can plug 7 devices if he use one supply-line filter.
","greedy, implementation, sortings"
"n = int(input())
a = list(map(int,input().split()))
mod = 10**9+7
b = [0 for i in range(1<<20)]
for i in range(n):
  b[a[i]] += 1
for i in range(20):
  for j in range(1<<20):
    if j&1<<i == 0:
      b[j] += b[j|1<<i]
ans = 0
for i in range(1<<20):
  cnt = str(bin(i)).count(""1"")
  if cnt%2 == 0:
    ans += pow(2,b[i],mod)-1
  else:
    ans -= pow(2,b[i],mod)-1
  ans %= mod
print(ans)",7,0449_D,CODEFORCES,4295,Jzzhu and Numbers,"Jzzhu have n non-negative integers a1, a2, ..., an. We will call a sequence of indexes i1, i2, ..., ik (1 ≤ i1 < i2 < ... < ik ≤ n) a group of size k. 
Jzzhu wonders, how many groups exists such that ai1 & ai2 & ... & aik = 0 (1 ≤ k ≤ n)? Help him and print this number modulo 1000000007 (109 + 7). Operation x & y denotes bitwise AND operation of two numbers.
","input
The first line contains a single integer n (1 ≤ n ≤ 106). The second line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 106).
output
Output a single integer representing the number of required groups modulo 1000000007 (109 + 7).
","bitmasks, combinatorics, dp"
"import sys
input = lambda : sys.stdin.readline().rstrip()


sys.setrecursionlimit(2*10**5+10)
write = lambda x: sys.stdout.write(x+""\n"")
debug = lambda x: sys.stderr.write(x+""\n"")
writef = lambda x: print(""{:.12f}"".format(x))


# zeta mebius
def zeta_super(val, n):
    # len(val)==2^n
    out = val[:]
    for i in range(n):
        for j in range(1<<n):
            if not j>>i&1:
                out[j] += out[j^(1<<i)]
    return out

n = int(input())
a = list(map(int, input().split()))
m = max(a).bit_length()
M = 10**9+7
v = [0]*(1<<m)
for item in a:
    v[item] += 1
v2 = [1]
for i in range(n+1):
    v2.append(v2[-1]*2%M)
nv = zeta_super(v, m)
ans = 0
for b in range(1<<m):
    ans += (v2[nv[b]]-1)*pow(-1, bin(b).count(""1""))
    ans %= M
print(ans%M)",7,0449_D,CODEFORCES,4296,Jzzhu and Numbers,"Jzzhu have n non-negative integers a1, a2, ..., an. We will call a sequence of indexes i1, i2, ..., ik (1 ≤ i1 < i2 < ... < ik ≤ n) a group of size k. 
Jzzhu wonders, how many groups exists such that ai1 & ai2 & ... & aik = 0 (1 ≤ k ≤ n)? Help him and print this number modulo 1000000007 (109 + 7). Operation x & y denotes bitwise AND operation of two numbers.
","input
The first line contains a single integer n (1 ≤ n ≤ 106). The second line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 106).
output
Output a single integer representing the number of required groups modulo 1000000007 (109 + 7).
","bitmasks, combinatorics, dp"
"import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int,sys.stdin.readline().rstrip().split())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))
def LI2(): return list(map(int,sys.stdin.readline().rstrip()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())
def LS2(): return list(sys.stdin.readline().rstrip())


N = I()
A = LI()
mod = 10**9+7

m = 20
M = 1 << m
F = [0]*M
for a in A:
    F[a] += 1


def zeta_transform(F,n):
    # res[i] = (iを含む集合jに対する F[j] の和)
    N = 1 << n
    res = F[:]
    for i in range(n):
        k = 1 << i
        for j in range(N):
            if not j & k:
                res[j] += res[j^k]
    return res


G = zeta_transform(F,m)
power = [1]
for _ in range(N):
    power.append((power[-1]*2) % mod)


def bit_count(n):
    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)
    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)
    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)
    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)
    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)
    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)
    return c


ans = 0
for i in range(M):
    bc = bit_count(i)
    a = power[G[i]]
    if bc % 2 == 0:
        ans += a
    else:
        ans -= a
    ans %= mod

print(ans)
",7,0449_D,CODEFORCES,4297,Jzzhu and Numbers,"Jzzhu have n non-negative integers a1, a2, ..., an. We will call a sequence of indexes i1, i2, ..., ik (1 ≤ i1 < i2 < ... < ik ≤ n) a group of size k. 
Jzzhu wonders, how many groups exists such that ai1 & ai2 & ... & aik = 0 (1 ≤ k ≤ n)? Help him and print this number modulo 1000000007 (109 + 7). Operation x & y denotes bitwise AND operation of two numbers.
","input
The first line contains a single integer n (1 ≤ n ≤ 106). The second line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 106).
output
Output a single integer representing the number of required groups modulo 1000000007 (109 + 7).
","bitmasks, combinatorics, dp"
"buck = [[0, 0] for i in range(2201)]
m = int(input())
for i in range(m):
    a = int(input())
    ok = True
    br = 0
    for j in range(2200, -1, -1):
        if a & (1 << j):
            if(buck[j][0]):
                a  ^= buck[j][0]
                br ^= buck[j][1]
            else:
                ok = False
                buck[j][0] = a
                buck[j][1] = br | (1 << i)
                break
    if not ok:
        print(""0"")
    else:
        lst = []
        for j in range(2201):
            if br & (1 << j):
                lst.append(j)
        print(len(lst), end = ' ')
        for j in lst:
            print(j, end = ' ')
        print('\n', end='')
",7,0504_D,CODEFORCES,4385,Misha and XOR,"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? 
If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.
Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.
Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.
The first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.
The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes. 
","input
For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.
output
The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.
",bitmasks
"m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for xx,ii in zip(values,idx):
        if (xx^x) < x:
            x^=xx
            ans^=ii
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)!=0:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",7,0504_D,CODEFORCES,4380,Misha and XOR,"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? 
If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.
Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.
Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.
The first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.
The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes. 
","input
For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.
output
The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.
",bitmasks
"m = int(input())

b = []
k = []
for i in range(m):
    x = int(input())
    c = 0
    for j in range(len(b)):
        v = b[j]
        d = k[j]
        if (x ^ v) < x:
            x ^= v
            c ^= d

    if x != 0:
        print(0)
        c ^= 2 ** i
        b.append(x)
        k.append(c)
    else:
        a = []
        for j in range(m):
            if c & 1 == 1:
                a.append(j)
            c >>= 1
        print(len(a), end='')
        for v in a:
            print(' ', v, sep='', end='')
        print()
",7,0504_D,CODEFORCES,4386,Misha and XOR,"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? 
If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.
Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.
Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.
The first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.
The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes. 
","input
For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.
output
The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.
",bitmasks
"n = int(input())
b = []
bb =[]
for i in range(n):
    x=int(input())
    idx = 0
    for j in range(len(b)):
        nxt = b[j] ^ x
        if nxt < x :
            x = nxt
            idx ^= bb[j]
    if x == 0:
        cnt = 0
        v = []
        for k in range(2000):
            if idx & (1 << k) :
                v.append(k)
        print(len(v),end=' ')
        for e in v:
            print(e,end=' ')
        print()
    else :
        print(0)
        idx ^= 1 << i
        b.append(x)
        bb.append(idx)

        
    ",7,0504_D,CODEFORCES,4387,Misha and XOR,"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? 
If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.
Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.
Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.
The first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.
The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes. 
","input
For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.
output
The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.
",bitmasks
"n = int(input())
t = [0 for i in range(2000)]
c = [0 for i in range(2000)]
for i in range(n) :
    x = int(input())
    r = 0
    ok = False
    for j in range(2000) :
        if x >> j & 1 :
            if t[j] != 0 :
                x ^= t[j]
                r ^= c[j]
            else :
                t[j] = x
                c[j] = r ^ (1 << i)
                ok = True
                break
    if ok :
        print(0)
        continue
    a = []
    for j in range(2000) :
        if r >> j & 1 :
            a.append(j)
    print(len(a))
    for y in a :
        print(y)
                ",7,0504_D,CODEFORCES,4382,Misha and XOR,"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? 
If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.
Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.
Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.
The first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.
The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes. 
","input
For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.
output
The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.
",bitmasks
"m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for j,xx in enumerate(values):
        if (xx^x) < x:
            x^=xx
            ans^=idx[j]
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)!=0:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",7,0504_D,CODEFORCES,4381,Misha and XOR,"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? 
If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.
Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.
Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.
The first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.
The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes. 
","input
For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.
output
The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.
",bitmasks
"import sys, os

numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)

base = []
out = []

for i in range(n):
    x = numbs[i]
    how = 0
    
    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep
    
    if x:
        how |= 1 << i

        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))
    
        out.append(0)
    else:
        outind = len(out)
        out.append(-1)
        
        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind

os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))
",7,0504_D,CODEFORCES,4383,Misha and XOR,"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? 
If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.
Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.
Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.
The first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.
The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes. 
","input
For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.
output
The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.
",bitmasks
"m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for xx,ii in zip(values,idx):
        if (xx^x) < x:
            x^=xx
            ans^=ii
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)==1:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",7,0504_D,CODEFORCES,4379,Misha and XOR,"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? 
If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.
Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.
Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.
The first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.
The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes. 
","input
For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.
output
The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.
",bitmasks
"import sys, os
 
numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)
 
base = []
out = []
 
for i in range(n):
    x = numbs[i]
    how = 0
    
    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep
    
    if x:
        how |= 1 << i
 
        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))
    
        out.append(0)
    else:
        outind = len(out)
        out.append(-1)
        
        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind
 
os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))",7,0504_D,CODEFORCES,4384,Misha and XOR,"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? 
If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.
Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.
Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.
The first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.
The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10600 that doesn't contain leading zeroes. 
","input
For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.
output
The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.
",bitmasks
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}

for i in range(n):
    b = a.copy()
    for p in a.items():
        d = gcd(p[0], l[i])
        cost = p[1] + c[i]
        if d not in b: b[d] = cost
        elif b[d] > cost: b[d] = cost
    a = b.copy()

if 1 not in a: a[1] = -1
print(a[1])

                                                                                                                                                                                                                                                     ",7,0512_B,CODEFORCES,4397,Fox And Jumping,"Fox Ciel is playing a game. In this game there is an infinite long tape with cells indexed by integers (positive, negative and zero). At the beginning she is standing at the cell 0.
There are also n cards, each card has 2 attributes: length li and cost ci. If she pays ci dollars then she can apply i-th card. After applying i-th card she becomes able to make jumps of length li, i. e. from cell x to cell (x - li) or cell (x + li).
She wants to be able to jump to any cell on the tape (possibly, visiting some intermediate cells). For achieving this goal, she wants to buy some cards, paying as little money as possible. 
If this is possible, calculate the minimal cost.
The first line contains an integer n (1 ≤ n ≤ 300), number of cards.
The second line contains n numbers li (1 ≤ li ≤ 109), the jump lengths of cards.
The third line contains n numbers ci (1 ≤ ci ≤ 105), the costs of cards.
If it is impossible to buy some cards and become able to jump to any cell, output -1. Otherwise output the minimal cost of buying such set of cards.
","input
In first sample test, buying one card is not enough: for example, if you buy a card with length 100, you can't jump to any cell whose index is not a multiple of 100. The best way is to buy first and second card, that will make you be able to jump to any cell.
output
In the second sample test, even if you buy all cards, you can't jump to any cell whose index is not a multiple of 10, so you should output -1.
","datastructures, dp, math, numbertheory, shortestpaths"
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}

for i in range(n):
    b = a.copy()
    for p in a.items():
        d = gcd(p[0], l[i])
        cost = p[1] + c[i]
        if d not in b: b[d] = cost
        elif b[d] > cost: b[d] = cost
    a = b

if 1 not in a: a[1] = -1
print(a[1])

                                                                                                         ",7,0512_B,CODEFORCES,4398,Fox And Jumping,"Fox Ciel is playing a game. In this game there is an infinite long tape with cells indexed by integers (positive, negative and zero). At the beginning she is standing at the cell 0.
There are also n cards, each card has 2 attributes: length li and cost ci. If she pays ci dollars then she can apply i-th card. After applying i-th card she becomes able to make jumps of length li, i. e. from cell x to cell (x - li) or cell (x + li).
She wants to be able to jump to any cell on the tape (possibly, visiting some intermediate cells). For achieving this goal, she wants to buy some cards, paying as little money as possible. 
If this is possible, calculate the minimal cost.
The first line contains an integer n (1 ≤ n ≤ 300), number of cards.
The second line contains n numbers li (1 ≤ li ≤ 109), the jump lengths of cards.
The third line contains n numbers ci (1 ≤ ci ≤ 105), the costs of cards.
If it is impossible to buy some cards and become able to jump to any cell, output -1. Otherwise output the minimal cost of buying such set of cards.
","input
In first sample test, buying one card is not enough: for example, if you buy a card with length 100, you can't jump to any cell whose index is not a multiple of 100. The best way is to buy first and second card, that will make you be able to jump to any cell.
output
In the second sample test, even if you buy all cards, you can't jump to any cell whose index is not a multiple of 10, so you should output -1.
","datastructures, dp, math, numbertheory, shortestpaths"
"def main():
    input()
    acc = {0: 0}
    for p, c in zip(list(map(int, input().split())),
                    list(map(int, input().split()))):
        adds = []
        for b, u in acc.items():
            a = p
            while b:
                a, b = b, a % b
            adds.append((a, u + c))
        for a, u in adds:
            acc[a] = min(u, acc.get(a, 1000000000))
    print(acc.get(1, -1))


if __name__ == '__main__':
    main()



# Made By Mostafa_Khaled",7,0512_B,CODEFORCES,4396,Fox And Jumping,"Fox Ciel is playing a game. In this game there is an infinite long tape with cells indexed by integers (positive, negative and zero). At the beginning she is standing at the cell 0.
There are also n cards, each card has 2 attributes: length li and cost ci. If she pays ci dollars then she can apply i-th card. After applying i-th card she becomes able to make jumps of length li, i. e. from cell x to cell (x - li) or cell (x + li).
She wants to be able to jump to any cell on the tape (possibly, visiting some intermediate cells). For achieving this goal, she wants to buy some cards, paying as little money as possible. 
If this is possible, calculate the minimal cost.
The first line contains an integer n (1 ≤ n ≤ 300), number of cards.
The second line contains n numbers li (1 ≤ li ≤ 109), the jump lengths of cards.
The third line contains n numbers ci (1 ≤ ci ≤ 105), the costs of cards.
If it is impossible to buy some cards and become able to jump to any cell, output -1. Otherwise output the minimal cost of buying such set of cards.
","input
In first sample test, buying one card is not enough: for example, if you buy a card with length 100, you can't jump to any cell whose index is not a multiple of 100. The best way is to buy first and second card, that will make you be able to jump to any cell.
output
In the second sample test, even if you buy all cards, you can't jump to any cell whose index is not a multiple of 10, so you should output -1.
","datastructures, dp, math, numbertheory, shortestpaths"
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    while b > 0:
        a, b = b, a % b
    return a

a = {0:0}
b = [0]

for i in range(n):
    for p in b:
        d = gcd(p, l[i])
        cost = a[p] + c[i]
        if d not in a:
            a[d] = cost
            b.append(d)
        elif a[d] > cost: a[d] = cost

if 1 not in a: a[1] = -1
print(a[1])

                                                                                                                                                                                                                        ",7,0512_B,CODEFORCES,4400,Fox And Jumping,"Fox Ciel is playing a game. In this game there is an infinite long tape with cells indexed by integers (positive, negative and zero). At the beginning she is standing at the cell 0.
There are also n cards, each card has 2 attributes: length li and cost ci. If she pays ci dollars then she can apply i-th card. After applying i-th card she becomes able to make jumps of length li, i. e. from cell x to cell (x - li) or cell (x + li).
She wants to be able to jump to any cell on the tape (possibly, visiting some intermediate cells). For achieving this goal, she wants to buy some cards, paying as little money as possible. 
If this is possible, calculate the minimal cost.
The first line contains an integer n (1 ≤ n ≤ 300), number of cards.
The second line contains n numbers li (1 ≤ li ≤ 109), the jump lengths of cards.
The third line contains n numbers ci (1 ≤ ci ≤ 105), the costs of cards.
If it is impossible to buy some cards and become able to jump to any cell, output -1. Otherwise output the minimal cost of buying such set of cards.
","input
In first sample test, buying one card is not enough: for example, if you buy a card with length 100, you can't jump to any cell whose index is not a multiple of 100. The best way is to buy first and second card, that will make you be able to jump to any cell.
output
In the second sample test, even if you buy all cards, you can't jump to any cell whose index is not a multiple of 10, so you should output -1.
","datastructures, dp, math, numbertheory, shortestpaths"
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}
b = [0]

for i in range(n):
    for p in b:
        d = gcd(p, l[i])
        cost = a[p] + c[i]
        if d not in a:
            a[d] = cost
            b.append(d)
        elif a[d] > cost: a[d] = cost

if 1 not in a: a[1] = -1
print(a[1])

                                                                                                                                                                                                                                                       ",7,0512_B,CODEFORCES,4399,Fox And Jumping,"Fox Ciel is playing a game. In this game there is an infinite long tape with cells indexed by integers (positive, negative and zero). At the beginning she is standing at the cell 0.
There are also n cards, each card has 2 attributes: length li and cost ci. If she pays ci dollars then she can apply i-th card. After applying i-th card she becomes able to make jumps of length li, i. e. from cell x to cell (x - li) or cell (x + li).
She wants to be able to jump to any cell on the tape (possibly, visiting some intermediate cells). For achieving this goal, she wants to buy some cards, paying as little money as possible. 
If this is possible, calculate the minimal cost.
The first line contains an integer n (1 ≤ n ≤ 300), number of cards.
The second line contains n numbers li (1 ≤ li ≤ 109), the jump lengths of cards.
The third line contains n numbers ci (1 ≤ ci ≤ 105), the costs of cards.
If it is impossible to buy some cards and become able to jump to any cell, output -1. Otherwise output the minimal cost of buying such set of cards.
","input
In first sample test, buying one card is not enough: for example, if you buy a card with length 100, you can't jump to any cell whose index is not a multiple of 100. The best way is to buy first and second card, that will make you be able to jump to any cell.
output
In the second sample test, even if you buy all cards, you can't jump to any cell whose index is not a multiple of 10, so you should output -1.
","datastructures, dp, math, numbertheory, shortestpaths"
"__author__ = 'ruckus'

n = int(input())
s = input()
t = input()
dif = {}
hem = 0
for i in range(n):
    if s[i] != t[i]:
        dif[i] = [s[i], t[i]]
        hem += 1

change = []
probed = []
k = 0
for i in dif.keys():
    if dif[i] in probed:
        continue
    probed.append(dif[i])
    k += 1
    for j in list(dif.keys())[k:]:
        if dif[i] == dif[j][::-1]:
            print(hem - 2)
            print(i + 1, j + 1)
            quit()
        if not change and (dif[i][0] == dif[j][1] or dif[j][0] == dif[i][1]):
            change = [i, j]

if change:
    print(hem - 1)
    print(change[0] + 1, change[1] + 1)
else:
    print(hem)
    print('-1 -1')",3,0527_B,CODEFORCES,1479,Error Correct System,"Ford Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings S and T of equal length to be ""similar"". After a brief search on the Internet, he learned about the Hamming distance between two strings S and T of the same length, which is defined as the number of positions in which S and T have different characters. For example, the Hamming distance between words ""permanent"" and ""pergament"" is two, as these words differ in the fourth and sixth letters.
Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn't know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in string S, so that the Hamming distance between a new string S and string T would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.
Help him do this!
The first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.
The second line contains string S.
The third line contains string T.
Each of the lines only contains lowercase Latin letters.
In the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.
In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print ""-1 -1"", if it is not necessary to swap characters.
","input
If there are multiple possible answers, print any of them.
output
In the second test it is acceptable to print i = 2, j = 3.
",greedy
"from sys import stdin,stdout
from collections import Counter
def ai(): return list(map(int, stdin.readline().split()))
def ei(): return map(int, stdin.readline().split())
def ip(): return  int(stdin.readline().strip())
def op(ans): return stdout.write(str(ans) + '\n') 

n = ip()
s = input()
t = input()
value = {}
li = []
res1 = 0
res2 =res3 = -1
for i in range(n):
	if s[i] != t[i]:
		value[t[i]] = i
		res1 += 1
		li.append(i)
p = sq = False
for i in li:
	if s[i] in value:
		p = True
		res2 = i+1
		f = value[s[i]]
		res3 = f+1
		if s[f] == t[i]:
			sq = True
			break
print(res1-(2 if sq else 1 if p else 0))
print(res2,res3)",3,0527_B,CODEFORCES,1482,Error Correct System,"Ford Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings S and T of equal length to be ""similar"". After a brief search on the Internet, he learned about the Hamming distance between two strings S and T of the same length, which is defined as the number of positions in which S and T have different characters. For example, the Hamming distance between words ""permanent"" and ""pergament"" is two, as these words differ in the fourth and sixth letters.
Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn't know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in string S, so that the Hamming distance between a new string S and string T would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.
Help him do this!
The first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.
The second line contains string S.
The third line contains string T.
Each of the lines only contains lowercase Latin letters.
In the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.
In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print ""-1 -1"", if it is not necessary to swap characters.
","input
If there are multiple possible answers, print any of them.
output
In the second test it is acceptable to print i = 2, j = 3.
",greedy
"n = int(input())
s = input()
t = input()
p = [-1, -1]
a = [[-1] * 26 for i in range(26)]
k = 0
for i in range(n):
    if t[i] != s[i]:
        k += 1
for i in range(n):
    if t[i] != s[i]:
        if a[ord(t[i]) - 97][ord(s[i]) - 97] != -1:
            print(k - 2)
            print(a[ord(t[i]) - 97][ord(s[i]) - 97] + 1, i + 1)
            exit()
        a[ord(s[i]) - 97][ord(t[i]) - 97] = i
for i in range(n):
    if t[i] != s[i]:
        for j in range(26):
            if a[j][ord(s[i]) - 97] != -1:
                print(k - 1)
                print(a[j][ord(s[i]) - 97] + 1, i + 1)
                exit()
        a[ord(s[i]) - 97][ord(t[i]) - 97] = i
print(k)
print(-1, -1)
",3,0527_B,CODEFORCES,1480,Error Correct System,"Ford Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings S and T of equal length to be ""similar"". After a brief search on the Internet, he learned about the Hamming distance between two strings S and T of the same length, which is defined as the number of positions in which S and T have different characters. For example, the Hamming distance between words ""permanent"" and ""pergament"" is two, as these words differ in the fourth and sixth letters.
Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn't know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in string S, so that the Hamming distance between a new string S and string T would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.
Help him do this!
The first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.
The second line contains string S.
The third line contains string T.
Each of the lines only contains lowercase Latin letters.
In the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.
In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print ""-1 -1"", if it is not necessary to swap characters.
","input
If there are multiple possible answers, print any of them.
output
In the second test it is acceptable to print i = 2, j = 3.
",greedy
"n = int(input())
s = input()
t = input()
pair2ind = {}
letters_s = [0] * 26
letters_t = [0] * 26
non_common = set()
cnt = 0
for i in range(n):
    if s[i] != t[i]:
        pair2ind[(s[i], t[i])] = i + 1
        letters_s[ord(s[i]) - ord('a')] = i + 1
        letters_t[ord(t[i]) - ord('a')] = i + 1
        non_common.add(i + 1)
        cnt += 1

sim = -1
for i in range(26):
    if letters_s[i] != 0 and letters_t[i] != 0:
        sim = letters_s[i]
        break
else:
    print(cnt)
    print(-1, -1)
    exit()

for i in range(n):
    if s[i] != t[i]:
        if (t[i], s[i]) in pair2ind:
            print(cnt - 2)
            print(pair2ind[(s[i], t[i])], pair2ind[(t[i], s[i])])
            exit()

non_common.remove(sim)
print(cnt - 1)
print(sim, letters_t[ord(s[sim-1]) - ord('a')])
exit()
",3,0527_B,CODEFORCES,1483,Error Correct System,"Ford Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings S and T of equal length to be ""similar"". After a brief search on the Internet, he learned about the Hamming distance between two strings S and T of the same length, which is defined as the number of positions in which S and T have different characters. For example, the Hamming distance between words ""permanent"" and ""pergament"" is two, as these words differ in the fourth and sixth letters.
Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn't know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in string S, so that the Hamming distance between a new string S and string T would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.
Help him do this!
The first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.
The second line contains string S.
The third line contains string T.
Each of the lines only contains lowercase Latin letters.
In the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.
In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print ""-1 -1"", if it is not necessary to swap characters.
","input
If there are multiple possible answers, print any of them.
output
In the second test it is acceptable to print i = 2, j = 3.
",greedy
"
import string

n, s, t = int(input()), input(), input()
x, i, j = 0, -1, -1
sc_dict = {c: set() for c in string.ascii_lowercase}
tc_dict = {c: set() for c in string.ascii_lowercase}
sti_dict, tsi_dict = dict(), dict()

for ci, sc, tc in zip(range(n), s, t):
    if sc == tc:
        continue
    sc_dict[sc].add(tc)
    tc_dict[tc].add(sc)
    sti_dict[sc + tc] = ci
    tsi_dict[tc + sc] = ci
    x += 1

for c in string.ascii_lowercase:
    cs = sc_dict[c] & tc_dict[c]
    if not cs:
        continue
    c2 = cs.pop()
    x -= 2
    i = sti_dict[c + c2] + 1
    j = tsi_dict[c + c2] + 1
    break
else:
    for c in string.ascii_lowercase:
        if not sc_dict[c] or not tc_dict[c]:
            continue
        x -= 1
        i = sti_dict[c + sc_dict[c].pop()] + 1
        j = tsi_dict[c + tc_dict[c].pop()] + 1
        break

print(x)
print(i, j)",3,0527_B,CODEFORCES,1476,Error Correct System,"Ford Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings S and T of equal length to be ""similar"". After a brief search on the Internet, he learned about the Hamming distance between two strings S and T of the same length, which is defined as the number of positions in which S and T have different characters. For example, the Hamming distance between words ""permanent"" and ""pergament"" is two, as these words differ in the fourth and sixth letters.
Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn't know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in string S, so that the Hamming distance between a new string S and string T would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.
Help him do this!
The first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.
The second line contains string S.
The third line contains string T.
Each of the lines only contains lowercase Latin letters.
In the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.
In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print ""-1 -1"", if it is not necessary to swap characters.
","input
If there are multiple possible answers, print any of them.
output
In the second test it is acceptable to print i = 2, j = 3.
",greedy
"num=int(input())

a=input()

b=input()

dic={}

lis=[]

ham=0

swap1=-1

swap2=-1

p=False

q=False

for i in range(num):

    if a[i]!=b[i]:

        ham+=1

        lis.append(i)

        dic[b[i]]=i

for i in lis:

    if a[i] in dic:

        p=True

        swap1=i+1

        f=dic[a[i]]

        swap2=f+1

        if a[f]==b[i]:

            q=True

            break

print(ham-(2 if q else 1 if p else 0))

print(swap1,swap2)



# Made By Mostafa_Khaled",3,0527_B,CODEFORCES,1477,Error Correct System,"Ford Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings S and T of equal length to be ""similar"". After a brief search on the Internet, he learned about the Hamming distance between two strings S and T of the same length, which is defined as the number of positions in which S and T have different characters. For example, the Hamming distance between words ""permanent"" and ""pergament"" is two, as these words differ in the fourth and sixth letters.
Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn't know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in string S, so that the Hamming distance between a new string S and string T would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.
Help him do this!
The first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.
The second line contains string S.
The third line contains string T.
Each of the lines only contains lowercase Latin letters.
In the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.
In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print ""-1 -1"", if it is not necessary to swap characters.
","input
If there are multiple possible answers, print any of them.
output
In the second test it is acceptable to print i = 2, j = 3.
",greedy
"
n=int(input())
s=list(input())
t=list(input())
d={}
ans=0
x,y=-1,-1
for i in range(n):
	if s[i]!=t[i]:
		d[(s[i],t[i])]=i
		ans+=1
l=[chr(i+97) for i in range(26)]
for i in l:
	for j in l:
		if (i,j) in d and (j,i) in d:
			ans-=2
			x=d[(i,j)]+1
			y=d[(j,i)]+1
			break
	if x!=-1:
		break
if x==y==-1:
	for i in l:
		for j in l:
			for k in l:
				if (i,j) in d and (j,k) in d:
					ans-=1
					x=d[(i,j)]+1
					y=d[(j,k)]+1
					break
		if x!=-1:
			break
print(ans)
print(x,y)",3,0527_B,CODEFORCES,1481,Error Correct System,"Ford Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings S and T of equal length to be ""similar"". After a brief search on the Internet, he learned about the Hamming distance between two strings S and T of the same length, which is defined as the number of positions in which S and T have different characters. For example, the Hamming distance between words ""permanent"" and ""pergament"" is two, as these words differ in the fourth and sixth letters.
Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn't know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in string S, so that the Hamming distance between a new string S and string T would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.
Help him do this!
The first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.
The second line contains string S.
The third line contains string T.
Each of the lines only contains lowercase Latin letters.
In the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.
In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print ""-1 -1"", if it is not necessary to swap characters.
","input
If there are multiple possible answers, print any of them.
output
In the second test it is acceptable to print i = 2, j = 3.
",greedy
"n = int(input())
s = input()
t = input()
dic, diff = {}, []
res, res1, res2 = 0, -1, -1
for i in range(n) :
    if s[i] != t[i] :
        res += 1
        diff.append(i)
        dic[t[i]] = i
swap1, swap2 = False, False
for i in diff :
    if s[i] in dic:
        swap1 = True
        res1 = i+1
        j = dic[s[i]]
        res2 = j+1
        if s[j] == t[i] :
            swap2 = True
            break
print(res - (2 if swap2 else 1 if swap1 else 0))
print(res1, res2)
",3,0527_B,CODEFORCES,1478,Error Correct System,"Ford Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings S and T of equal length to be ""similar"". After a brief search on the Internet, he learned about the Hamming distance between two strings S and T of the same length, which is defined as the number of positions in which S and T have different characters. For example, the Hamming distance between words ""permanent"" and ""pergament"" is two, as these words differ in the fourth and sixth letters.
Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn't know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in string S, so that the Hamming distance between a new string S and string T would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.
Help him do this!
The first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.
The second line contains string S.
The third line contains string T.
Each of the lines only contains lowercase Latin letters.
In the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.
In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print ""-1 -1"", if it is not necessary to swap characters.
","input
If there are multiple possible answers, print any of them.
output
In the second test it is acceptable to print i = 2, j = 3.
",greedy
"n , s = map(int , input().split())
lst = []
for i in range(n):
    lst.append(list(map(int , input().split())))
lst = sorted(lst , key =lambda x : x[0] , reverse = True)
prev , ans = s , 0
for i in range(n):
    ans += prev -lst[i][0]
    if ans < lst[i][1]:
        ans += (lst[i][1]- ans)
    
    prev = lst[i][0]
print(ans+prev)",3,0608_A,CODEFORCES,1489,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"def solve(n, p, s):
    p.append((0, 0))
    p.sort()
    t = 0
    while p:
        x = p.pop()
        s, t = x[0], max(x[1], t + abs(s - x[0]))
    return t


n, s = [int(x) for x in input().split(' ')]
p = [tuple([int(x) for x in input().split(' ')]) for r in range(n)]

print(solve(n, p, s))",3,0608_A,CODEFORCES,1485,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"n, s = map(int, input().split())
ans = s
for i in range(n):
    f, t = map(int, input().split())
    if(t>(s-f)):
        ans +=  t - (s-f)
        s += t - (s-f)

print(ans)",3,0608_A,CODEFORCES,1488,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"n,s=map(int,input().split())
arr=[]
for i in range(n):
    arr.append([])
    arr[i]=[int(i) for i in input().split()]
arr=sorted(arr,reverse=True,key=lambda x:x[0])
ans,c=0,0
for i in range(n):
    if i!=0:
       c=arr[i-1][0]
    if i==0:
       ans=ans+s-arr[i][0]
    else:
       ans=ans+c-arr[i][0]
    if arr[i][1]>=ans:
        ans=ans+(arr[i][1]-ans)
ans=ans+arr[n-1][0]
print(ans)
    ",3,0608_A,CODEFORCES,1491,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"n, s = map(int, input().split())
ans = s
for i in range(n):
    f, t = map(int, input().split())
    ans = max(ans, t+f)
print(ans)",3,0608_A,CODEFORCES,1487,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"import sys
from math import sqrt, log, log2, ceil, log10, gcd, floor, pow, sin, cos, tan, pi, inf, factorial
from copy import copy, deepcopy
from sys import exit, stdin, stdout
from collections import Counter, defaultdict, deque
from itertools import permutations
import heapq
from bisect import bisect_left 
from bisect import bisect_right
# sys.setrecursionlimit(100000000)
mod = 1000000007
iinp = lambda: int(sys.stdin.readline())
inp = lambda: sys.stdin.readline().strip()
strl = lambda: list(inp().strip().split("" ""))
intl = lambda: list(map(int, inp().split("" "")))
mint = lambda: map(int, inp().split())
flol = lambda: list(map(float, inp().split("" "")))
flush = lambda: stdout.flush()
# ========================================================Functions====================================================
def solve():
 
    n,s=mint()
    cm=0
    for i in range(n):
        fi,ti=mint()
        if i==0:
            cm=fi+ti
        if i!=0:
            if fi+ti>cm:
                cm=fi+ti
    if cm>s:
        print(cm)
    else:
        print(s)
 
 
# ========================================================Main Code=====================================================
# t=iinp()
t=1
for _ in range(t):
        solve()",3,0608_A,CODEFORCES,1490,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"n, s = map(int, input().split())
ans = s
f = []
t = []
for i in range(n):
    f, t = map(int, input().split())
    if(t>(s-f)):
        ans +=  t - (s-f)
        s += t - (s-f)

print(ans)",3,0608_A,CODEFORCES,1486,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"n,s=map(int,input().split())
mins=s
my_dict={}
mylist=[]
while(n):
	person,floor=map(int,input().split())
	mylist.append(person+floor)
	n-=1
val=max(mylist)
if(val<mins):
	print(mins)
else:
	print(val)",3,0608_A,CODEFORCES,1492,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split()) 
def get_list(): return list(map(int, sys.stdin.readline().strip().split())) 


n,s=rinput()
maxi=s
for i in range(n):
    f,t=rinput()
    maxi=max(maxi,f+t)

print(maxi)",3,0608_A,CODEFORCES,1484,Saitama Destroys Hotel,"Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.
The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.
The first line of input contains two integers n and s (1 ≤ n ≤ 100, 1 ≤ s ≤ 1000) — the number of passengers and the number of the top floor respectively.
The next n lines each contain two space-separated integers fi and ti (1 ≤ fi ≤ s, 1 ≤ ti ≤ 1000) — the floor and the time of arrival in seconds for the passenger number i.
Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.
In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:
1. Move to floor 5: takes 2 seconds.
2. Pick up passenger 3.
3. Move to floor 3: takes 2 seconds.
4. Wait for passenger 2 to arrive: takes 4 seconds.
5. Pick up passenger 2.
6. Go to floor 2: takes 1 second.
7. Pick up passenger 1.
","input
8. Go to floor 0: takes 2 seconds.
output
This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.
","implementation, math"
"import math
import sys
from collections import deque,defaultdict
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,readline().split())
S=[readline().rstrip() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",5,0908_E,CODEFORCES,3062,New Year and Entity Enumeration,"You are given an integer m.
Let M = 2m - 1.
You are also given a set of n integers denoted as the set T. The integers will be provided in base 2 as n binary strings of length m.
A set of integers S is called ""good"" if the following hold. 
Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.
Count the number of good sets S, modulo 109 + 7.
The first line will contain two integers m and n (1 ≤ m ≤ 1 000, 1 ≤ n ≤ min(2m, 50)).
The next n lines will contain the elements of T. Each line will contain exactly m zeros and ones. Elements of T will be distinct.
","input
Print a single integer, the number of good sets modulo 109 + 7. 
output
An example of a valid set S is {00000, 00101, 00010, 00111, 11000, 11010, 11101, 11111}.
","bitmasks, combinatorics, dp, math"
"import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap,0,len(heap)-1)
from math import gcd as Gcd
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,readline().split())
S=[readline().rstrip() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",5,0908_E,CODEFORCES,3061,New Year and Entity Enumeration,"You are given an integer m.
Let M = 2m - 1.
You are also given a set of n integers denoted as the set T. The integers will be provided in base 2 as n binary strings of length m.
A set of integers S is called ""good"" if the following hold. 
Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.
Count the number of good sets S, modulo 109 + 7.
The first line will contain two integers m and n (1 ≤ m ≤ 1 000, 1 ≤ n ≤ min(2m, 50)).
The next n lines will contain the elements of T. Each line will contain exactly m zeros and ones. Elements of T will be distinct.
","input
Print a single integer, the number of good sets modulo 109 + 7. 
output
An example of a valid set S is {00000, 00101, 00010, 00111, 11000, 11010, 11101, 11111}.
","bitmasks, combinatorics, dp, math"
"import math
from collections import defaultdict

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,input().split())
S=[input() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",5,0908_E,CODEFORCES,3063,New Year and Entity Enumeration,"You are given an integer m.
Let M = 2m - 1.
You are also given a set of n integers denoted as the set T. The integers will be provided in base 2 as n binary strings of length m.
A set of integers S is called ""good"" if the following hold. 
Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.
Count the number of good sets S, modulo 109 + 7.
The first line will contain two integers m and n (1 ≤ m ≤ 1 000, 1 ≤ n ≤ min(2m, 50)).
The next n lines will contain the elements of T. Each line will contain exactly m zeros and ones. Elements of T will be distinct.
","input
Print a single integer, the number of good sets modulo 109 + 7. 
output
An example of a valid set S is {00000, 00101, 00010, 00111, 11000, 11010, 11101, 11111}.
","bitmasks, combinatorics, dp, math"
"from collections import defaultdict

def E1():

    mod = 10 ** 9 + 7

    comb = [[1]]
    for i in range(1, 1010):
        x = [1]
        for j in range(1, i):
            x.append((comb[i - 1][j - 1] + comb[i - 1][j]) % mod)
        x.append(1)
        comb.append(x)

    dp = [1]
    for i in range(1, 1010):
        r = 0
        for k in range(i):
            r += dp[k] * comb[i - 1][k]
            r %= mod
        dp.append(r)

    m, n = map(int, input().split())

    ns = [0 for __ in range(m)]
    for j in range(n):
        temp = input()
        s = [int(i) for i in temp]
        for i in range(m):
            ns[i] |= s[i] << j

    dd = defaultdict(int)
    for e in ns:
        dd[e] += 1

    ans = 1
    for b in dd.values():
        ans = ans * dp[b] % mod

    print(ans)

if __name__=='__main__':
    E1()
	 	 	   	   			  				  	 	 	 	",5,0908_E,CODEFORCES,3059,New Year and Entity Enumeration,"You are given an integer m.
Let M = 2m - 1.
You are also given a set of n integers denoted as the set T. The integers will be provided in base 2 as n binary strings of length m.
A set of integers S is called ""good"" if the following hold. 
Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.
Count the number of good sets S, modulo 109 + 7.
The first line will contain two integers m and n (1 ≤ m ≤ 1 000, 1 ≤ n ≤ min(2m, 50)).
The next n lines will contain the elements of T. Each line will contain exactly m zeros and ones. Elements of T will be distinct.
","input
Print a single integer, the number of good sets modulo 109 + 7. 
output
An example of a valid set S is {00000, 00101, 00010, 00111, 11000, 11010, 11101, 11111}.
","bitmasks, combinatorics, dp, math"
"#Problem Set E: Collaborated with no one
from collections import defaultdict

mod_v = 1000000007

temp_arr = [[1]]
for i in range(1,1010):
    a = [1]
    for k in range(1,i):
        a.append((temp_arr[i-1][k-1]+temp_arr[i-1][k]) % mod_v)
    a.append(1)
    temp_arr.append(a)


ans_arr = [1]
for i in range(1,1010):
    res = 0
    for j in range(i):
        res += ans_arr[j] * temp_arr[i-1][j]
        res %= mod_v
    ans_arr.append(res)


n_list=list(map(int, input().split()))

n = n_list[0]
lines = n_list[1]

new_list = [0 for __ in range(n)]

for i in range(lines):
    input1 = list(map(int, input()))
    for k in range(n):
        new_list[k] |= input1[k] << i

default_d = defaultdict(int)
for k in new_list:
    default_d[k] += 1

answer = 1
for n in default_d.values():
    answer = answer * ans_arr[n] % mod_v

print(answer)
  		 	 	  	    	 	 		   		 	  	",5,0908_E,CODEFORCES,3060,New Year and Entity Enumeration,"You are given an integer m.
Let M = 2m - 1.
You are also given a set of n integers denoted as the set T. The integers will be provided in base 2 as n binary strings of length m.
A set of integers S is called ""good"" if the following hold. 
Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.
Count the number of good sets S, modulo 109 + 7.
The first line will contain two integers m and n (1 ≤ m ≤ 1 000, 1 ≤ n ≤ min(2m, 50)).
The next n lines will contain the elements of T. Each line will contain exactly m zeros and ones. Elements of T will be distinct.
","input
Print a single integer, the number of good sets modulo 109 + 7. 
output
An example of a valid set S is {00000, 00101, 00010, 00111, 11000, 11010, 11101, 11111}.
","bitmasks, combinatorics, dp, math"
"import sys
import math
input = sys.stdin.readline
from functools import cmp_to_key;

def pi():
    return(int(input()))
def pl():
    return(int(input(), 16))
def ti():
    return(list(map(int,input().split())))
def ts():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
mod = 1000000007;
f = [];
def fact(n,m):
    global f;
    f = [1 for i in range(n+1)];
    f[0] = 1;
    for i in range(1,n+1):
        f[i] = (f[i-1]*i)%m;

def fast_mod_exp(a,b,m):
    res = 1;
    while b > 0:
        if b & 1:
            res = (res*a)%m;
        a = (a*a)%m;
        b = b >> 1;
    return res;

def inverseMod(n,m):
    return fast_mod_exp(n,m-2,m);

def ncr(n,r,m):
    if n < 0 or r < 0 or r > n: return 0;
    if r == 0: return 1;
    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;

def main():
    C();

def D():
    [n,m,k] = ti();
    w = [[] for i in range(n)];
    for i in range(n):
        w[i] = ts();

    mn = [[0 for j in range(k+1)] for i in range(n+1)];
    for i in range(1,n+1):
        for j in range(k+1):
            c = 0;
            st,en = -1,-1;
            for x in range(m):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            mn[i][j] = en-st+1 if st != -1 and en != -1 else 0;
            st,en = -1,-1;
            c = 0;
            for x in range(m-1,-1,-1):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            if st != -1 and en != -1 >= 0:
                mn[i][j] = min(mn[i][j], st-en+1);

    dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)];
    for i in range(k+1):
        dp[0][i] = 0;
    for i in range(1,n+1):
        for j in range(k+1):
            for x in range(k+1):
                if j-x >= 0:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]);

    print(dp[n][k]);

def getCount(n):
    x = 1;
    count = 0;
    while n > 0:
        if n & 1 == 1:
            count += 1;
        n = n >> 1;
    return count;

def C():
    try:
        n = ts();
        k = pi();
        if k == 0:
            print(1);
            return;
        dp = [0 for i in range(1010)];
        for i in range(1010):
            if i == 0 or i == 1:
                continue;
            dp[i] = dp[getCount(i)]+1;
        fact(1010,mod);

        ans = 0;    
        s = n;
        count = 0;
        for i in range(len(s)):
            if s[i] == '0': continue;
            for j in range(max(count,1),1010):
                if dp[j] == k-1:
                    ans = (ans+ncr(len(s)-i-1,j-count,mod))%mod;
                    if i == 0 and k == 1: ans = (ans+mod-1)%mod;
            count += 1;
        count = 0;
        for i in range(len(s)):
            if s[i] == '1': count += 1;
        if dp[count] == k-1: ans = (ans+1)%mod;

        print(ans);
    except: print(sys.exc_info()[0]);


main();",3,0914_C,CODEFORCES,1551,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def bit_count(x):
    ans = 0
    while x:
        x &= x-1
        ans += 1
    return ans

def main():
    n = input().strip()
    x = len(n)
    k = int(input())
    if n == '1':
        print(int(k==0))
        exit()
    if not k:
        print(1)
        exit()
    mod = 10**9+7
    dp = [0]*(x+1)
    dp[1] = 1
    for i in range(2,x+1):
        dp[i] = dp[bit_count(i)]+1
    dp1 = [[0]*(x+1) for _ in range(x+1)]
    # length ; set bits
    for i in range(x+1):
        dp1[i][0] = 1
    for i in range(1,x+1):
        for j in range(1,i+1):
            dp1[i][j] = (dp1[i-1][j-1]+dp1[i-1][j])%mod
    ans = 0
    cou = n.count('1')
    for i in range(1,x+1):
        if dp[i] != k:
            continue
        se = i
        for j in range(x):
            if n[j] == '0':
                continue
            ans = (ans+dp1[x-1-j][se]-(se==1 and k==1))%mod
            se -= 1
            if se < 0:
                break
        if cou == i:
            ans = (ans+1)%mod
    print(ans)

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",3,0914_C,CODEFORCES,1554,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"N = 1030
MOD = int(1e9+7)
c = [[0] * N for i in range(N)]
for i in range(N):
    c[i][0] = 1
for i in range(1, N):
    for j in range(1, N):
        c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD

arr = list(map(int, list(input())))
cnt = int(input())
if cnt == 0:
    print(1)
    exit()

dp = [0] * N
for i in range(2, N):
    dp[i] = dp[bin(i).count('1')] + 1
res = 0
for i in range(1, N):
    if dp[i] != cnt - 1:
        continue
    n, k = len(arr)-1, i
    for pos in range(len(arr)):
        if arr[pos] == 1:
            res = (res + c[n][k]) % MOD
            k -= 1
        n -= 1
    if n == -1 and k == 0:
        res += 1
if cnt == 1: 
    res -= 1
print(res)",3,0914_C,CODEFORCES,1550,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"'''
jitne bhi binary mai 2 ki power ones hai unhe lagega 2 ;
now i fill a dp table
'''


def make_nCr_mod(max_n=2 * 10 ** 5, mod=10 ** 9 + 7):
	max_n = min(max_n, mod - 1)

	fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
	fact[0] = 1
	for i in range(max_n):
		fact[i + 1] = fact[i] * (i + 1) % mod

	inv_fact[-1] = pow(fact[-1], mod - 2, mod)
	for i in reversed(range(max_n)):
		inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

	def nCr_mod(n, r):
		res = 1
		while n or r:
			a, b = n % mod, r % mod
			if a < b:
				return 0
			res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
			n //= mod
			r //= mod
		return res

	return nCr_mod


def f():
	dp = [0] * (1000 + 100)
	dp[1] = 1

	for i in range(2, len(dp)):
		o = bin(i).count(""1"")
		if o == 1:
			dp[i] = 2
		else:
			dp[i] += dp[o] + 1
	return dp


def bit(s, k):
	dp = f()
	l = []
	comb=make_nCr_mod()
	ans = 0
	ll = len(s)
	ans = 0
	ones = 0
	if k == 0:
		return 1
	for i in range(ll):
		if s[i] == ""0"":
			continue
		else:
			for j in range(max(ones, 1), 1000):
				if dp[j] == k:
					ans = (ans + comb(ll - i - 1, j - ones)) % (10 ** 9 + 7)
					if i == 0 and k == 1:
						ans -= 1
		ones += 1
	if dp[ones] == k:
		ans += 1
	return (ans) % (10 ** 9 + 7)


s = input().strip()
k = int(input())
print(bit(s, k))
",3,0914_C,CODEFORCES,1557,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"s0=input()
k=int(input())
s1=s0[::-1]
lens1=len(s1)
maxnum=1005
mod=1000000007
dp=[[0]*maxnum for tmpi in range(maxnum)]
f=[0]*maxnum
c=[[0]*maxnum for tmpi in range(maxnum)]

def cntone(num):
    tmps=bin(num)[2:]
    cnt=0
    for i in range(len(tmps)):
        if(tmps[i]=='1'):
            cnt+=1
    return cnt

for i in range(1,maxnum):
    if(i==1):
        f[i]=0
    else:
        f[i]=f[cntone(i)]+1

for i in range(maxnum):
    if(i==0):
        c[i][0]=1
        continue
    for j in range(i+1):
        if(j==0):
            c[i][j]=1
        else:
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod

for i in range(lens1):
    if(i==0):
        dp[i][0] = 1
        if(s1[i]=='1'):
            dp[i][1]=1
        else:
            dp[i][1]=0
        continue
    else:
        for j in range(0,i+2):
            if(j==0):
                dp[i][j]=1
                continue
            if(s1[i]=='1'):
                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod
            else:
                dp[i][j]=dp[i-1][j]%mod

ans=0

for i in range(1,lens1+1):
    if(f[i]==k-1):
        ans=(ans+dp[lens1-1][i])%mod

if(k==0):
    ans=1
elif(k==1):
    ans-=1
else:
    ans=ans
print(ans)
  	 	   	 	 			 	 	  	 	 	 	 		",3,0914_C,CODEFORCES,1553,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"s0=input()
k=int(input())
s1=s0[::-1]
lens1=len(s1)
maxnum=1005
mod=1000000007
dp=[[0]*maxnum for tmpi in range(maxnum)]
f=[0]*maxnum
c=[[0]*maxnum for tmpi in range(maxnum)]

def cntone(num):
    tmps=bin(num)[2:]
    cnt=0
    for i in range(len(tmps)):
        if(tmps[i]=='1'):
            cnt+=1
    return cnt

for i in range(1,maxnum):
    if(i==1):
        f[i]=0
    else:
        f[i]=f[cntone(i)]+1

for i in range(maxnum):
    if(i==0):
        c[i][0]=1
        continue
    for j in range(i+1):
        if(j==0):
            c[i][j]=1
        else:
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod

for i in range(lens1):
    if(i==0):
        dp[i][0] = 1
        if(s1[i]=='1'):
            dp[i][1]=1
        else:
            dp[i][1]=0
        continue
    else:
        for j in range(0,i+2):
            if(j==0):
                dp[i][j]=1
                continue
            if(s1[i]=='1'):
                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod
            else:
                dp[i][j]=dp[i-1][j]%mod

ans=0

for i in range(1,lens1+1):
    if(f[i]==k-1):
        ans=(ans+dp[lens1-1][i])%mod

if(k==0):
    ans=1
elif(k==1):
    ans-=1
else:
    ans=ans
print(ans)",3,0914_C,CODEFORCES,1552,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"'''
jitne bhi binary mai 2 ki power ones hai unhe lagega 2 ;
now i fill a dp table
'''
global fact,inv_fact
def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
	global fact, inv_fact


	max_n = min(max_n, mod - 1)

	fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
	fact[0] = 1
	for i in range(max_n):
		fact[i + 1] = fact[i] * (i + 1) % mod

	inv_fact[-1] = pow(fact[-1], mod - 2, mod)
	for i in reversed(range(max_n)):
		inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod


make_nCr_mod()
def comb(n, r):
	mod=10**9+7
	global fact,inv_fact
	res = 1
	while n or r:
		a, b = n % mod, r % mod
		if a < b:
			return 0
		res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
		n //= mod
		r //= mod
	return res
def f():
	dp=[0]*(1000+100)
	dp[1]=1

	for i in range(2,len(dp)):
		o=bin(i).count(""1"")
		if o==1:
			dp[i]=2
		else:
			dp[i]+=dp[o]+1
	return dp

def bit(s,k):
	dp=f()
	l=[]
	ans=0
	ll=len(s)
	ans=0
	ones=0
	if k==0:
		return 1
	for i  in range(ll):
		if s[i]==""0"":
			continue
		else:
			for j in range(max(ones,1),1000):
				if dp[j]==k:
					ans=(ans+comb(ll-i-1,j-ones))%(10**9+7)
					if i==0 and k==1:
						ans-=1
		ones+=1
	if dp[ones]==k:
		ans+=1
	return (ans)%(10**9+7)



s=input().strip()
k=int(input())
print(bit(s,k))",3,0914_C,CODEFORCES,1556,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"class Combi():

    def __init__(self, N, mod=10**9 + 7):
        self.power = [1 for _ in range(N+1)]
        self.rev = [1 for _ in range(N+1)]
        self.mod = mod
        for i in range(2, N+1):
            self.power[i] = (self.power[i-1]*i) % self.mod
        self.rev[N] = pow(self.power[N], self.mod-2, self.mod)
        for j in range(N, 0, -1):
            self.rev[j-1] = (self.rev[j]*j) % self.mod

    def com(self, K, R):
        if not (0 <= R <= K):
            return 0
        else:
            return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod

    def perm(self, K, R):
        if not (0 <= R <= K):
            return 0
        else:
            return (self.power[K])*(self.rev[K-R]) % self.mod


def bitcnt(X):
    res = 0
    v = X
    while v:
        res += v & 1
        v >>= 1
    return res


c = Combi(10000)
NL = list(map(int, list(input())))[::-1]
N = len(NL)
K = int(input())
MOD = 10**9 + 7

dp = [[0]*(1020) for i in range(1020)]

dp[0][0] = 1
for pos, bit in enumerate(NL):
    if bit == 1:
        for bit in range(1010):
            dp[pos + 1][bit] = (dp[pos][bit - 1] + c.com(pos, bit)) % MOD
        continue
    else:
        for bit in range(1010):
            dp[pos + 1][bit] = dp[pos][bit]
        continue

INF = 1 << 60
cnt = [INF]*(1010)

cnt[1] = 0
MOD = 10**9 + 7

for i in range(2, 1010):
    cnt[i] = 1 + cnt[bitcnt(i)]

if K == 0:
    print(dp[N][0])
    exit()
else:
    ans = 0
    for bitcnt in range(1010):
        if cnt[bitcnt] == K - 1:
            ans += dp[N][bitcnt]
    if K == 1:
        ans -= 1
    print(ans % MOD)
    exit()
",3,0914_C,CODEFORCES,1549,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"import os, sys
from io import BytesIO, IOBase


def bit_count(x):
    ans = 0
    while x:
        x &= x - 1
        ans += 1
    return ans


def main():
    n = input().strip()
    x = len(n)
    k = int(input())
    if n == '1':
        print(int(k == 0))
        exit()
    if not k:
        print(1)
        exit()
    mod = 10 ** 9 + 7
    dp = [0] * (x + 1)
    dp[1] = 1
    for i in range(2, x + 1):
        dp[i] = dp[bit_count(i)] + 1
    dp1 = [[0] * (x + 1) for _ in range(x + 1)]
    # length ; set bits
    for i in range(x + 1):
        dp1[i][0] = 1
    for i in range(1, x + 1):
        for j in range(1, i + 1):
            dp1[i][j] = (dp1[i - 1][j - 1] + dp1[i - 1][j]) % mod
    ans = 0
    cou = n.count('1')
    for i in range(1, x + 1):
        if dp[i] != k:
            continue
        se = i
        for j in range(x):
            if n[j] == '0':
                continue
            ans = (ans + dp1[x - 1 - j][se] - (se == 1 and k == 1)) % mod
            se -= 1
            if se < 0:
                break
        if cou == i:
            ans = (ans + 1) % mod
    print(ans)
main()",3,0914_C,CODEFORCES,1555,Travelling Salesman and Special Numbers,"The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer x and reduce it to the number of bits set to 1 in the binary representation of x. For example for number 13 it's true that 1310 = 11012, so it has 3 bits set and 13 will be reduced to 3 in one operation.
He calls a number special if the minimum number of operations to reduce it to 1 is k.
He wants to find out how many special numbers exist which are not greater than n. Please help the Travelling Salesman, as he is about to reach his destination!
Since the answer can be large, output it modulo 109 + 7.
The first line contains integer n (1 ≤ n < 21000).
The second line contains integer k (0 ≤ k ≤ 1000).
Note that n is given in its binary representation without any leading zeros.
","input
Output a single integer — the number of special numbers not greater than n, modulo 109 + 7.
output
In the first sample, the three special numbers are 3, 5 and 6. They get reduced to 2 in one operation (since there are two set bits in each of 3, 5 and 6) and then to 1 in one more operation (since there is only one set bit in 2).
","bruteforce, combinatorics, dp"
"n,U=list(map(int, input().split(' ')))
a=list(map(int, input().split(' ')))

import bisect
def max_eligible(a,x):
    ind=bisect.bisect_right(a,x)
    if ind <= len(a):
        return a[ind-1]
    else:
        return -1

max_val=-1
for i in range(n-2):
    x = a[i]+U
    val1 = max_eligible(a,x)

    if val1!=-1 and val1!=a[i+1] and val1!=a[i]:
        # print('hi')
        val = (val1-a[i+1]) / (val1-a[i])
        # print(val)
        max_val=max(max_val,val)
    # print(a[i],a[i+1],val1,max_val)
print(max_val)
",4,0957_C,CODEFORCES,2468,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"n,u=map(int,input().split())
arr=list(map(int,input().split()))
# arr.sort()
j,i=1,0
maxi=-1
flag=0
for i in range(n-1):
	if arr[i+1]-arr[i]<=u:
		flag=1
if flag==0:
	print(""-1"")
	exit()
i=0
while(i<n-2):
	while(1):
		if j>=n:
			j=n-1
			break
		if arr[j]-arr[i]>u:
			j-=1
			break
		j+=1
	if i==j:
		j+=1
	elif arr[j]==arr[i]:
		pass
	elif arr[j]-arr[i]<=u:
		# print(i,j)
		maxi=max(maxi,(arr[j]-arr[i+1])/(arr[j]-arr[i]))
	i+=1
if maxi==0:
	print(""-1"")
else:
	print(maxi)",4,0957_C,CODEFORCES,2473,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"def sss(l,r,tt):
    f = -1
    while(l<=r):
        mid = (l + r) >> 1
        if(a[mid]-a[tt] <= m):
           f = mid
           l = mid + 1
        else :
           r = mid - 1
    return f

n , m =  map(int, input().split())
a = [int(x) for x in input().split()]
f = 0
l  = len(a)
#print(""l=="" + str(l))
Maxx = -1
for i in range(0,l-2):
    if(a[i+2] - a[i]<= m):
         k = sss(i+2,l-1,i)
         if(k != -1):
             Maxx = max(Maxx,(a[k] - a[i+1])/(a[k]-a[i]))
if(Maxx == -1):
    print(-1)
else: print(""%.15f\n"" % Maxx)",4,0957_C,CODEFORCES,2471,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"from __future__ import division
from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
n, m = rints()
a, cur, ans = rints()[::-1], 2, -1

for i in range(n - 2):
    cur = max(cur, i + 2)
    for j in range(cur, n):
        if a[i] - a[j] < 1:
            cur += 1
            continue

        if a[i] - a[j] > m:
            break

        cur += 1
        # print(cur, a[i])
        v = (a[i] - a[j - 1]) / (a[i] - a[j])
        ans = max(ans, v)

print(ans)
",4,0957_C,CODEFORCES,2478,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"n, U = list(map(int, input().split()))
E = list(map(int, input().split()))

ind_i = 0
prev_ind_k = ind_i + 2

maxi_efficiency = -1
turn = 0
for ind_i in range(0, n - 2):
    ind_j = ind_i + 1
    prev_ind_k = max(prev_ind_k, ind_i + 2)
    Ei = E[ind_i]
    Ej = E[ind_j]
    for ind_k in range(prev_ind_k, n + 1):
        # print(""ind_i, ind_k"", ind_i, ind_k)
        if ind_k == n:
            prev_ind_k = n - 1
            break
        Ek = E[ind_k]
        if (Ek - Ei) > U:
            prev_ind_k = ind_k - 1
            break

        efficiency = (Ek - Ej) / (Ek - Ei)
        # print(""efficiency : "", efficiency)
        if efficiency > maxi_efficiency:
            # print(ind_i, ind_k)
            maxi_efficiency = efficiency

print(maxi_efficiency)

# if (ind_i == n-3 and ind_j == n-2 and ind_k == n-1):
#     break


# n, U = list(map(int, input().split()))
# E = list(map(int, input().split()))

# ind_i = 0
# ind_k = 2

# maxi_efficiency = -1
# turn = 0
# while ind_i < n - 2 and ind_k < n:
#     # print(""ind_i, ind_j : "", ind_i, ind_k)
#     ind_j = ind_i + 1
#     Ei = E[ind_i]
#     Ej = E[ind_j]
#     Ek = E[ind_k]
#     if (Ek - Ei) > U:
#         # print(""too much"")
#         ind_i += 1
#         ind_k = max(ind_k, ind_i + 2)
#         continue
#     else:
#         efficiency = (Ek - Ej) / (Ek - Ei)
#         # print(""efficiency : "", efficiency)
#         if efficiency > maxi_efficiency:
#             print(ind_i, ind_k)
#             maxi_efficiency = efficiency
#         ind_k += 1

# print(maxi_efficiency)

# if (ind_i == n-3 and ind_j == n-2 and ind_k == n-1):
#     break


# n, U = list(map(int, input().split()))
# E = list(map(int, input().split()))

# ind_i = 0

# maxi_efficiency = -1
# turn = 0
# while ind_i < n - 3:
#     ind_j = ind_i + 1
#     Ei = E[ind_i]
#     Ej = E[ind_j]
#     for ind_k in range(ind_j + 1, n):
#         Ek = E[ind_k]
#         if (Ek - Ei) > U:
#             break

#         efficiency = (Ek - Ej) / (Ek - Ei)
#         # print(""efficiency : "", efficiency)
#         if efficiency > maxi_efficiency:
#             maxi_efficiency = efficiency

#     ind_i += 1

# print(maxi_efficiency)

# # if (ind_i == n-3 and ind_j == n-2 and ind_k == n-1):
# #     break
",4,0957_C,CODEFORCES,2476,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"n, u = map(int, input().split())
e = list(map(int, input().split()))
ans = -1
k = 2
for i in range(n-2):
    while k<n-1 and e[k+1] - e[i] <= u:
        k+=1
    if i < k-1 and e[k] - e[i] <= u:
        ans = max(ans,(e[k]-e[i+1]) / (e[k]-e[i]))
print(ans)",4,0957_C,CODEFORCES,2470,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"N,U = map(int,input().strip().split())

E = list(map(int,input().strip().split()))
maxu = -1
j = 2
if N < 3:
    print(-1)
for i in range(N-2):
    j = max(i+2,j)
    if E[j] -E[i] > U:
        continue
    while j < N and E[j] - E[i] <= U:
        j += 1
    j -= 1
    maxu = max(maxu, (E[j] - E[i+1]) / (E[j] - E[i]))
print(maxu)",4,0957_C,CODEFORCES,2475,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"n, U = list(map(int, input().strip().split()))
E = list(map(int, input().strip().split()))
#print(n, U)
#print(E)
mmax = -1
for i in range(0, n-2):
    j = i + 1
    l = j + 1
    r = n - 1
    while l < r:
        mid = (l + r) // 2
        if E[mid] - E[i] <= U:
            l = mid + 1
        else:
            r = mid - 1
    if E[l] - E[i] <= U:
        cur = (E[l] - E[j]) / (E[l] - E[i])
        mmax = max(mmax, cur)
    else:
        if l - 1 > j and E[l-1] - E[i] <= U:
            cur = (E[l-1] - E[j]) / (E[l-1] - E[i])
            mmax = max(mmax, cur)
print(mmax)
 				 		  		 		  			 		  		  		",4,0957_C,CODEFORCES,2474,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
#sys.setrecursionlimit(200000000)
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
#MOD = 1000000000 + 7
def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])
    


n,U = ilele()
A = alele()
Ans = -1
for i in range(n-2):
    x = A[i]
    y = x  + U
    z = bisect.bisect_left(A,y,lo = i+2,hi = n)
    #print(z)
    if z == n:
        z-=1
    if A[z] <= x +U:
        a = A[z]
    elif A[z-1] <= x +U and z-1 != i+1:
        a = A[z-1]
    else:
        continue
    b = (a - A[i+1])/(a - A[i])
    #rint(b)
    Ans = max(Ans,b)
print(Ans)        
    
        
        
    
",4,0957_C,CODEFORCES,2477,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"n,m=map(int,input().split())
a=list(map(int,input().split()))
k=0
ans=-1
for i in range(n-1):
    while k<n-1 and a[k+1] - a[i]<=m:
        k+=1
    if i<k-1:
        ans=max(ans,(a[k]-a[i+1]) / (a[k]-a[i]))
print(ans)",4,0957_C,CODEFORCES,2469,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"n,U=map(int,input().split())
Ar=list(map(int,input().split()))
R = 0;
ans = -1;
for i in range(n):
    while R + 1 < n and Ar[R + 1] - Ar[i] <= U:
        R+=1
    if i+1 < R:
        ans = max((Ar[R] - Ar[i + 1]) / (Ar[R] - Ar[i]),ans);
print(ans)
",4,0957_C,CODEFORCES,2472,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"from __future__ import division
from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
n, m = rints()
a, cur, ans = rints()[::-1], 2, -1

for i in range(n - 2):
    cur = max(cur, i + 2)
    for j in range(cur, n):
        if a[i] - a[j] > m:
            break

        cur += 1
        v = (a[i] - a[j - 1]) / (a[i] - a[j])
        ans = max(ans, v)

print(ans)
",4,0957_C,CODEFORCES,2479,Three-level Laser,"An atom of element X can exist in n distinct states with energies E1 < E2 < ... < En. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 
Three distinct states i, j and k are selected, where i < j < k. After that the following process happens: 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.
Due to some limitations, Arkady can only choose such three states that Ek - Ei ≤ U.
Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.
The first line contains two integers n and U (3 ≤ n ≤ 105, 1 ≤ U ≤ 109) — the number of states and the maximum possible difference between Ek and Ei.
The second line contains a sequence of integers E1, E2, ..., En (1 ≤ E1 < E2... < En ≤ 109). It is guaranteed that all Ei are given in increasing order.
If it is not possible to choose three states that satisfy all constraints, print -1.
Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10 - 9.
Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .
","input
In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to .
output
In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to .
","binarysearch, greedy, math, twopointers"
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):
    n=nmbr()
    l=sorted(zip(lst(),range(n)))
    p=0;ans=[0]*(2*n)
    st=[0]*n;ln=0
    s=input()
    for i in range(2*n):
        ch=s[i]
        if ch=='0':
            st[ln]=p
            ans[i]=l[p][1]+1
            ln+=1
            p+=1
        else:
            ans[i]=l[st[ln-1]][1]+1
            ln-=1
    print(*ans)
",4,0982_B,CODEFORCES,2550,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"n=int(input())
w = [(int(x), c+1) for c, x in enumerate(input().split())]
b=sorted(w,reverse=True)    
f=[]
p=[]
k=input()
for i in k:
    if i==""0"":
        x=b.pop()
        f.append(x)
        p.append(x[1])
    else:
        y=f.pop()
        p.append(y[1])
print(*p) 
  	 	 	 					   	 		 		 			 			",4,0982_B,CODEFORCES,2552,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"import sys
import heapq
input = sys.stdin.readline
n = int(input())
w = [int(z) for z in input().split()]; s = input()

idx = []
for i in range(n):
    idx.append((w[i], i+1))

idx.sort()
heapq.heapify(idx)
ones = []
heapq.heapify(ones)
res = []
for i in range(2*n):
    if s[i] == '0':
        l = idx[0]
        heapq.heappop(idx)
        res.append(l[1])
        heapq.heappush(ones, [-l[0], l[1]])
    else:
        l = ones[0]
        heapq.heappop(ones)
        res.append(l[1])
res = ' '.join([str(i) for i in res])
sys.stdout.write(res)",4,0982_B,CODEFORCES,2555,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr()):
    n=nmbr()
    l=sorted(zip(lst(),range(n)))
    p=0;ans=[0]*(2*n)
    st=[0]*n;ln=0
    s=input()
    for i in range(2*n):
        # print(st)
        ch=s[i]
        if ch=='0':
            st[ln]=p
            ans[i]=l[p][1]+1
            ln+=1
            p+=1
        else:
            ans[i]=l[st[ln-1]][1]+1
            ln-=1
    print(*ans)",4,0982_B,CODEFORCES,2547,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"n=int(input())
i=iter(sorted(zip(map(int,input().split()),range(1,n+1))))
s,o=[],[]
for c in input():
 if c=='0':
  x=next(i)[1];o+=[x];s+=[x]
 else:o.append(s.pop())
print(*o)
	  	 		    				 	 	 				 	   	",4,0982_B,CODEFORCES,2562,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"n = int(input())
w = list(map(int, input().split()))
ent = input()
mp = {w[i]: i+1 for i in range(n)}
sorted(mp)
w.sort()
ptr = 0
stk = []
for i in range(2 * n):
    if ent[i] == ""0"":
        print(mp[w[ptr]], end="" "")
        stk.append(mp[w[ptr]])
        ptr += 1
    else:
        print(stk.pop(), end="" "")
    # print(pr.queue)
print()
",4,0982_B,CODEFORCES,2559,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"n = int(input())
w = list(map(int, input().split()))
intro = [[v, i] for i, v in enumerate(w, 1)]
intro.sort(key=lambda x: x[0])
s = input()
i = -1
li = []
ans = []
for j in s:
    if j == ""0"":
        i += 1
        ans.append(intro[i][1])
        li.append(intro[i][1])
    else:
        ans.append(li.pop(-1))
print("" "".join(map(str, ans)))

		       	   	       		 			  	",4,0982_B,CODEFORCES,2554,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"
# Problem: B. Bus of Characters
# Contest: Codeforces - Codeforces Round #484 (Div. 2)
# URL: XXXX
# Memory Limit: 256 MB
# Time Limit: 2000 ms
# Powered by CP Editor (XXXX)

from sys import stdin
def get_ints(): return list(map(int, stdin.readline().strip().split()))

n = int(input())
ar = get_ints()

bus = sorted([ (ar[i], i+1) for i in range(n) ])
pa = [int(x) for x in input()]
seq = []
# print(bus)
tail = 0
for p in pa:
	if p == 0:
		print(bus[tail][1], end="" "")
		seq.append(tail)
		tail+=1
	else:
		v = seq.pop()
		print(bus[v][1],end="" "")
",4,0982_B,CODEFORCES,2561,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"z,zz=input,lambda:list(map(int,z().split()))
fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from string import *
from re import *
from collections import *
from queue import *
from sys import *
from collections import *
from math import *
from heapq import *
from itertools import *
from bisect import *
from collections import Counter as cc
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
    return 1
def dfs(u,visit,graph):
    visit[u]=1
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)
def output(answer):
    stdout.write(str(answer))
###########################---Test-Case---#################################
""""""

  If you Know me , Then you probably don't know me !


""""""
###########################---START-CODING---##############################

num=int(z())

arr=zzz()

new_arr=[(i,j+1) for j,i in enumerate(arr)]
new_arr=sorted(new_arr)

passenger=fast()

que=deque()

ans=[0]*2*num


left=0
right=num-1
le=0

for i in range(2*num):
    if passenger[i]=='0':
        ans[i]=new_arr[left][1]
        que.append(new_arr[left][1])
        left+=1
        le+=1
        
    else:
        if le>=1:
            ans[i]=que[-1]
            que.pop()
            le-=1
        else:
            ans[i]=new_arr[right][1]
            que.append(new_arr[right][1])
            right-=1
            le+=1
print(*ans)
        
        
    
        
        
    

    
            





























        
        
       
",4,0982_B,CODEFORCES,2548,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"n = int(input())
 
one_seat = []
 
two_seats = []
 
j = 1
 
for item in input().split():
    two_seats.append((int(item), j))
    j += 1
 
two_seats.sort(key=lambda x: -x[0])
 
for person in input():
    if person == '0':
        q = two_seats.pop()
        print(q[1], end=' ')
        one_seat.append(q)
    else:
        print(one_seat.pop()[1], end=' ')
 	 	 	 	  		    					  			   	",4,0982_B,CODEFORCES,2553,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"from _collections import deque
n = int(input())
m = list(map(int, input().split()))
a = []
b = deque()
 
i = 1
for x in m:
    a.append((x, i))
    i += 1
a.sort(key=lambda p: -p[0])
 
s = input()
ans = []
 
for x in s:
    if x == ""1"":
        v = b.pop()
        ans.append(v[1])
    else:
        v = a.pop()
        ans.append(v[1])
        b.append(v)
print(*ans)",4,0982_B,CODEFORCES,2549,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"n = int(input())
w = list(map(int, input().split()))
ent = input()
mp = {w[i]: i+1 for i in range(n)}
sorted(mp)
w.sort()
ptr = 0
a = 0
stk = []
for i in range(2 * n):
    if ent[i] == ""0"":
        print(mp[w[ptr]], end="" "")
        stk.append(mp[w[ptr]])
        ptr += 1
    else:
        print(stk.pop(), end="" "")
    # print(pr.queue)
print()
",4,0982_B,CODEFORCES,2560,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"from collections import deque
n=int(input())
orderedli=list(map(int,input().split("" "")))


indexof={}
for i,x in enumerate(orderedli):
    indexof[x]=i+1

sortedli=list(sorted(orderedli))
i=0

s=input()

st=deque()

for x in s:
    if x==""0"":
        st.append(sortedli[i])
        print(indexof[sortedli[i]],end="" "")
        i += 1
    else:#x==1
        temp=st.pop()
        print(indexof[temp],end="" "")
",4,0982_B,CODEFORCES,2551,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"n = input()
seat_rows = [int(x) for x in input().strip().split()]
aliens = input().strip()

eldian = ""0""
marleyan = ""1""

empty = sorted(enumerate(seat_rows), key=lambda x: x[1], reverse=True)
non_empty = []

result = []
for alien in aliens:
    if alien == eldian:
        row = empty.pop()
        non_empty.append(row)
    else:
        row = non_empty.pop()

    result.append(row[0] + 1)

print(' '.join(map(str, result)))",4,0982_B,CODEFORCES,2563,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"z,zz=input,lambda:list(map(int,z().split()))
fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from string import *
from re import *
from collections import *
from queue import *
from sys import *
from collections import *
from math import *
from heapq import *
from itertools import *
from bisect import *
from collections import Counter as cc
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
    return 1
def dfs(u,visit,graph):
    visit[u]=1
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)

###########################---Test-Case---#################################
""""""

  If you Know me , Then you probably don't know me !


""""""
###########################---START-CODING---##############################

n=int(z())

arr=zzz()

new_arr=sorted([ (i,j) for j,i in enumerate(arr) ])

lst=fast()

stack=[]
ans=[]

size=0
left=0
right=n-1

for i,j in enumerate(lst):
    if j=='0':
        ans.append(new_arr[left][1]+1)
        stack.append(new_arr[left][1]+1)
        size+=1
        left+=1
        
        
    if j=='1':
        if size==0:
            ans.append(new_arr[right][1]+1)
            stack.append(new_arr[right][1]+1)
            right-=1
        if size>0:
            ans.append(stack[-1])
            stack.pop()
            size-=1
            
  
            
print(*ans)
            
    
    

























    
",4,0982_B,CODEFORCES,2546,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"import sys
from math import gcd, sqrt
from typing import Deque

sys.setrecursionlimit(10 ** 5)


inf = float(""inf"")
en = lambda x: list(enumerate(x))

ii = lambda: int(input())
r = lambda: map(int, input().split())
rr = lambda: list(r())


n = ii()
arr = rr()
arr = en(arr)

arr.sort(key=lambda x: x[1])

i = 0
brr = []

for j in input():
    if j == ""0"":
        brr.append(arr[i])
        print(arr[i][0] + 1, end="" "")
        i += 1
    else:
        x = brr.pop()
        print(x[0] + 1, end="" "")
",4,0982_B,CODEFORCES,2557,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"import sys
import heapq
input = sys.stdin.readline
n = int(input())
w = [int(z) for z in input().split()]; s = input(); idx = []
for i in range(n):
    idx.append((w[i], i+1))

idx.sort()
heapq.heapify(idx)
ones = []
heapq.heapify(ones)
res = []
for i in range(2*n):
    if s[i] == '0':
        l = idx[0]
        heapq.heappop(idx)
        res.append(l[1])
        heapq.heappush(ones, [-l[0], l[1]])
    else:
        l = ones[0]
        heapq.heappop(ones)
        res.append(l[1])
res = ' '.join([str(i) for i in res])
sys.stdout.write(res)",4,0982_B,CODEFORCES,2556,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"import math
n=int(input())
lst = list(map(int, input().strip().split(' ')))
s=input()
for j in range(n):
    lst[j]=[lst[j],j+1]
lst.sort()
stk=[]
i=0
for j in range(2*n):
    if s[j]=='0':
        stk.append(lst[i][1])
        print(lst[i][1],end="" "")
        i+=1
    
    else:
        print(stk[-1],end="" "")
        stk.pop()
        ",4,0982_B,CODEFORCES,2558,Bus of Characters,"In the Bus of Characters there are $$$n$$$ rows of seat, each having $$$2$$$ seats. The width of both seats in the $$$i$$$-th row is $$$w_i$$$ centimeters. All integers $$$w_i$$$ are distinct.
Initially the bus is empty. On each of $$$2n$$$ stops one passenger enters the bus. There are two types of passengers: 
You are given the seats width in each row and the order the passengers enter the bus. Determine which row each passenger will take.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 200\,000$$$) — the number of rows in the bus.
The second line contains the sequence of integers $$$w_1, w_2, \dots, w_n$$$ ($$$1 \le w_i \le 10^{9}$$$), where $$$w_i$$$ is the width of each of the seats in the $$$i$$$-th row. It is guaranteed that all $$$w_i$$$ are distinct.
The third line contains a string of length $$$2n$$$, consisting of digits '0' and '1' — the description of the order the passengers enter the bus. If the $$$j$$$-th character is '0', then the passenger that enters the bus on the $$$j$$$-th stop is an introvert. If the $$$j$$$-th character is '1', the the passenger that enters the bus on the $$$j$$$-th stop is an extrovert. It is guaranteed that the number of extroverts equals the number of introverts (i. e. both numbers equal $$$n$$$), and for each extrovert there always is a suitable row.
","input
Print $$$2n$$$ integers — the rows the passengers will take. The order of passengers should be the same as in input.
output
In the first example the first passenger (introvert) chooses the row $$$2$$$, because it has the seats with smallest width. The second passenger (introvert) chooses the row $$$1$$$, because it is the only empty row now. The third passenger (extrovert) chooses the row $$$1$$$, because it has exactly one occupied seat and the seat width is the largest among such rows. The fourth passenger (extrovert) chooses the row $$$2$$$, because it is the only row with an empty place.
","datastructures, greedy, implementation"
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

####################################---fast-input-output----#########################################


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]


z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())


def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)


dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]


#################################################---Some Rule For Me To Follow---#################################
""""""
    --instants of Reading problem continuously try to understand them.

    --If you Know some-one , Then you probably don't know him !

    --Try & again try

""""""
##################################################---START-CODING---###############################################




n = int(z())
arr = set(zz())

def solve():
    for i in arr:
        for k in range(31):
            if i - (1 << k) in arr and i + (1 << k) in arr:
                return [i - (1 << k), i, i + (1 << k)]
    for i in arr:
        for k in range(31):
            if i + (1 << k) in arr:
                return [i, i + (1 << k)]
    
    for i in arr:
        return [i]

lst = solve()
# print(lst)
print(len(lst))
for i in lst:
    output(i,' ')",4,0988_D,CODEFORCES,2610,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"n = int(input())
a = [int(i) for i in input().split()]

d = {}
power = [2**i for i in range(31)]
ans = []
for i in a:
    d[i] = 0

for num in d.keys():
    for p in power:
        if num+p in d:
            ans = [num, num+p]
            if num+p+p in d:
                print(3)
                ans.append(num+p+p)
                print(*ans)
                exit()
if ans:
    print(2)
    print(*ans)
else:
    print(1)
    print(a[0])
",4,0988_D,CODEFORCES,2600,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"from collections import defaultdict, Counter
from bisect import bisect, bisect_left
from math import sqrt, gcd
 
def read(): return list(map(int, input().strip().split()))
 
ans_ = []

 
# for _ in range(int(input())):
t_p = [2**i for i in range(31)]
n = int(input()); 
arr = Counter(read())
d = defaultdict(int)
m = 1; ans_lis = [[list(arr.keys())[0], 1]]

for i in arr:
    for j in t_p:
        a, b, c = i, i+j, i+2*j
        s = arr[a] + arr[b] + arr[c]
        if s > m:
            m = s
            ans_lis = [[x, arr[x]] for x in [a, b, c]]


ans_.append(m)
t = """"
for i in ans_lis:t += (str(i[0])+"" "")*i[1]
ans_.append(t)





 
 
# print(ans_)
for i in ans_:
    print(i)
 
 
""""""
0 2 4 
3 5 7


0 8 16


""""""",4,0988_D,CODEFORCES,2605,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce
from itertools import permutations
import heapq

#sys.setrecursionlimit(10**6) 
#OneDrive\Documents\codeforces

I=sys.stdin.readline

alpha=""abcdefghijklmnopqrstuvwxyz""

""""""
x_move=[-1,0,1,0,-1,1,1,-1]
y_move=[0,1,0,-1,1,1,-1,-1]
""""""
def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())


def ncr(n, r):
    r = min(r, n-r)
    numer = reduce(op.mul, range(n, n-r, -1), 1)
    denom = reduce(op.mul, range(1, r+1), 1)
    return numer // denom 
 

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:
		
		for i in range(2,int(n**.5)+1):
			if n%i==0:
				return False
		return True


#print(""Case #""+str(_+1)+"":"",abs(cnt-k))








def main():
	
	n=ii()
	arr=li()


	sett=set(arr)

	power=[2**i for i in range(32)]

	ans=[]
	
	
	for i in power:
		for j in arr:
			tmp=[j]
			for k in range(2):
				if tmp[-1]+i in sett:
					tmp.append(tmp[-1]+i)

			if len(tmp)>len(ans):
				# print(i,tmp,ans)
				ans=[x for x in tmp]

			if len(ans)==3:
				break

		if len(ans)==3:
			break

	print(len(ans))
	print(*ans)
















	








	




		
	

					

if __name__ == '__main__':
	main()",4,0988_D,CODEFORCES,2607,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @oj: codeforces
# @id: hitwanyang
# @email: 296866643@qq.com
# @date: 2021/4/20 23:57
# @url: XXXX
import sys, os
from io import BytesIO, IOBase
import collections, itertools, bisect, heapq, math, string
from decimal import *
from collections import deque

# region fastio

BUFSIZE = 8192

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# ------------------------------
## 注意嵌套括号!!!!!!
## 先有思路,再写代码,别着急!!!
## 先有朴素解法,不要有思维定式,试着换思路解决
## 精度 print(""%.10f"" % ans)
## sqrt:int(math.sqrt(n))+1
## 字符串拼接不要用+操作，会超时
## 二进制转换:bin(1)[2:].rjust(32,'0')
## array copy:cur=array[::]
## oeis(CROSSREFS):example 1, 3, _, 1260, _, _, _, _, _, 12164510040883200
## sqrt:Decimal(x).sqrt()避免精度误差
## 无穷大表示:float('inf')
## py 10**6 排序+双指针 3秒可能TLE
## 按区间右端点排序,current.left>pre.right,贪心求不相交区间的最大个数
## 加法>位运算
def main():
    n = int(input())
    a = list(map(int, input().split()))
    s = set(a)
    a.sort()
    ans = []
    for i in range(n):
        for j in range(31):
            tmp = [a[i]]
            x = a[i] + 2 ** j
            y = a[i] + 2 ** (j + 1)
            if x in s:
                tmp.append(x)
            if y in s:
                tmp.append(y)
            if len(tmp) > 1:
                if len(ans) == 0:
                    ans.append(tmp)
                else:
                    if len(tmp) > len(ans[0]):
                        ans[0] = tmp
    if len(ans) == 0:
        print(1)
        print(a[0])
        return
    if len(ans[0]) == 2:
        print(2)
        print(ans[0][0], ans[0][1])
        return
    if len(ans[0]) == 3:
        print(3)
        print(ans[0][0], ans[0][1], ans[0][2])
        return


if __name__ == ""__main__"":
    main()
",4,0988_D,CODEFORCES,2603,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce
from itertools import permutations

#sys.setrecursionlimit(10**4) 
#C:\Users\bittu\OneDrive\Documents\codeforces
I=sys.stdin.readline

#alpha=""abcdefghijklmnopqrstuvwxyz""

""""""
x_move=[-1,0,1,0,-1,1,1,-1]
y_move=[0,1,0,-1,1,1,-1,-1]
""""""
def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())


def ncr(n, r):
    r = min(r, n-r)
    numer = reduce(op.mul, range(n, n-r, -1), 1)
    denom = reduce(op.mul, range(1, r+1), 1)
    return numer // denom 
 

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:
		
		for i in range(2,int(n**.5)+1):
			if n%i==0:
				return False
		return True

#print(""Case #""+str(_+1)+"":"",abs(cnt-k))




def main():
	n=ii()
	arr=li()
	sett=set(arr)
	ans=[arr[0]]
	flag=0
	for x in range(31):
		for i in arr:
			if (i-2**x) in sett and (i+2**x) in sett:
				ans=[i-2**x,i,i+2**x]
				flag=1
				break
			elif i-2**x in sett:
				ans=[i-2**x,i]
			elif i+2**x in sett:
				ans=[i,i+2**x]
			


		if flag:
			break
	print(len(ans))
	print(*ans)


		



	

	

	

	




			

	





	








							





		

	

	

		
				
					

		




		










	






		

	



	








		
			





		






	

if __name__ == '__main__':
	main()",4,0988_D,CODEFORCES,2602,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"n = int(input())
arr = set(map(int,input().split()))

def solve():
    for i in arr:
        for k in range(31):
            if i - (1 << k) in arr and i + (1 << k) in arr:
                return [i - (1 << k), i, i + (1 << k)]
    for i in arr:
        for k in range(31):
            if i + (1 << k) in arr:
                return [i, i + (1 << k)]
    
    for i in arr:
        return [i]

lst = solve()
# print(lst)
print(len(lst))
print(*lst)
",4,0988_D,CODEFORCES,2609,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"import sys
input = sys.stdin.readline

n = int(input())
x = list(map(int, input().split()))
x.sort()
s = set(x)
m, ans = 1, [x[0]]
pow2 = [1]
for _ in range(35):
    pow2.append(2 * pow2[-1])
for i in x:
    for j in pow2:
        if (i - j) in s and (i + j) in s:
            m = 3
            ans = [i - j, i, i + j]
            break
        elif (i - j) in s and m < 2:
            m = 2
            ans = [i, i - j]
        elif (i + j) in s and m < 2:
            m = 2
            ans = [i, i + j]
    if m == 3:
        break
print(m)
print(*ans)",4,0988_D,CODEFORCES,2614,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"from collections import defaultdict, Counter
from bisect import bisect, bisect_left
from math import sqrt, gcd
 
def read(): return list(map(int, input().strip().split()))
 
ans_ = []

 
# for _ in range(int(input())):
t_p = [2**i for i in range(31)]
n = int(input()); 
arr = Counter(read())
d = defaultdict(int)
m = 1; ans_lis = [list(arr.keys())[0]]

for i in arr:
    for j in t_p:
        a, b, c = i, i+j, i+2*j
        s = (arr[a] > 0) + (arr[b] > 0) + (arr[c] > 0)
        if s > m:
            m = s
            ans_lis = [x for x in [a, b, c] if arr[x]]


ans_.append(m)
t = """"
for i in ans_lis:t += (str(i)+"" "")
ans_.append(t)





 
 
# print(ans_)
for i in ans_:
    print(i)
 
 
""""""
0 2 4 
3 5 7


0 8 16


""""""",4,0988_D,CODEFORCES,2606,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"import math
import sys
import collections
import bisect
import time
import random
from itertools import permutations
def get_ints():return map(int, sys.stdin.readline().strip().split())
def get_list():return list(map(int, sys.stdin.readline().strip().split()))
def get_string():return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    arr=get_list()
    unique=set(arr)
    poss=False
    for i in arr:
        for j in range(32):
            if i+(2**j) in unique and i-(2**j) in unique:
                print(3)
                print(i,i+2**j,i-2**j)
                poss=True
                break
        if poss:
            break
    if poss:
        break
    for i in arr:
        for j in range(32):
            if i+(2**j) in unique:
                print(2)
                print(i,i+2**j)
                poss=True
                break
        if poss:
            break
    if poss:
        break
    print(1)
    print(arr[0])",4,0988_D,CODEFORCES,2604,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

####################################---fast-input-output----#########################################


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]


z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())


def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)


dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]


#################################################---Some Rule For Me To Follow---#################################
""""""
    --instants of Reading problem continuously try to understand them.

    --If you Know some-one , Then you probably don't know him !

    --Try & again try

""""""
##################################################---START-CODING---###############################################





    
n = int(z())
a = zzz()

d = {}
power = [2**i for i in range(31)]
ans = []
for i in a:
    d[i] = 0

for num in d.keys():
    for p in power:
        if num+p in d:
            ans = [num, num+p]
            if num+p+p in d:
                print(3)
                ans.append(num+p+p)
                print(*ans)
                exit()
if ans:
    print(2)
    print(*ans)
else:
    print(1)
    print(a[0])

",4,0988_D,CODEFORCES,2611,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"from sys import stdin
input = stdin.buffer.readline
    
n=int(input())
arr=[int(x) for x in input().split()]

arr.sort()
s=set(arr)
flag=False
for ele in arr:
    for i in range(31):
        if ((ele-2**i) in s) and ((ele+2**i) in s):
            ans=[ele,ele-2**i,ele+2**i]
            flag=True
            break
    if flag:
        break
if flag:
    print(3) 
    print(*ans)    
    exit()
for ele in arr:
    for i in range(31):
        if (ele+2**i) in s:
            ans=[ele,ele+2**i]
            flag=True
            break
    if flag:
        break
if flag:
    print(2)
    print(*ans)
else:
    print(1)
    print(arr[0])",4,0988_D,CODEFORCES,2599,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"from sys import stdin
input = stdin.readline

def solve():
    n = int(input())
    x = [int(x) for x in input().split()]
    s = set(x)
    ans = [x[0]]
    for i in range(n):
        for j in range(0, 32):
            if x[i] + 2**j in s:
                ans = [x[i], x[i] + 2**j]
                if x[i] + (2**j * 2) in s:
                    ans.append(x[i] + (2**j * 2))
                    return ans
    return ans

ans = solve()
print(len(ans))
print(*ans)",4,0988_D,CODEFORCES,2608,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"from collections import defaultdict

n, a = int(input()), [int(x) for x in input().split()]
pow2 = [1 << i for i in range(32)]
mp = defaultdict()
for x in a:
    mp[x] = 1
mxSiz = 1
ans = [a[0]]
for x in a:
    for y in pow2:
        if x-y in mp and x+y in mp:
            mxSiz = 3
            ans = [x-y, x, x+y]
        if x-y in mp and 2 > mxSiz:
            mxSiz = 2
            ans = [x-y, x]

print(mxSiz)
print(*ans)
",4,0988_D,CODEFORCES,2601,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"from math import sqrt,gcd,ceil,floor,log,factorial
from itertools import permutations,combinations
from collections import Counter, defaultdict

def dist(x1,x2):
    return abs(x1-x2)
    
def power2(n):
    return ceil(log(n,2)) == floor(log(n,2))

n=int(input())
x = list(map(int,input().split()))

flag1,flag2,flag3=0,0,0
d=Counter(x)

for i in x:
    for po in range(0,31):
        if d[i-pow(2,po)]>0 and d[i+pow(2,po)]>0:
            print(3)
            print(i,i-pow(2,po),i+pow(2,po))
            flag1=1
            break
        
    if flag1==1:
        break
   
if flag1==0:
    for i in x:
        for po in range(0,31):
            if d[i-pow(2,po)]>0:
                print(2)
                print(i,i-pow(2,po))
                flag2=1
                break
            
            elif d[i+pow(2,po)]>0:
                print(2)
                print(i,i+pow(2,po))
                flag2=1
                break
            
        if flag2==1:
            break
        
    if flag2==0:
        print(1)
        print(max(x))
        
    
",4,0988_D,CODEFORCES,2613,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter
import math as mt

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)


def lcm(a, b):
    return (a * b) / gcd(a, b)


mod = int(1e9) + 7


def power(k, n):
    if n == 0:
        return 1
    if n % 2:
        return (power(k, n - 1) * k) % mod
    t = power(k, n // 2)
    return (t * t) % mod


def totalPrimeFactors(n):
    count = 0
    if (n % 2) == 0:
        count += 1
        while (n % 2) == 0:
            n //= 2

    i = 3
    while i * i <= n:
        if (n % i) == 0:
            count += 1
            while (n % i) == 0:
                n //= i
        i += 2
    if n > 2:
        count += 1
    return count


# #MAXN = int(1e7 + 1)
# # spf = [0 for i in range(MAXN)]
#
#
# def sieve():
#     spf[1] = 1
#     for i in range(2, MAXN):
#         spf[i] = i
#     for i in range(4, MAXN, 2):
#         spf[i] = 2
#
#     for i in range(3, mt.ceil(mt.sqrt(MAXN))):
#         if (spf[i] == i):
#             for j in range(i * i, MAXN, i):
#                 if (spf[j] == j):
#                     spf[j] = i
#
#
# def getFactorization(x):
#     ret = 0
#     while (x != 1):
#         k = spf[x]
#         ret += 1
#         # ret.add(spf[x])
#         while x % k == 0:
#             x //= k
#
#     return ret


# Driver code

# precalculating Smallest Prime Factor
# sieve()

def main():
    n = int(input())
    a = list(map(int, input().split()))
    d = {}
    for i in range(n):
        d[a[i]] = i
    found=[-1, -1, -1]
    found2=[-1, -1]
    for i in range(n):
        c=1
        while c<(1<<31):
            if a[i]- c in d.keys() and a[i]+c in d.keys():
                found[0]=a[i]-c
                found[1]=a[i]
                found[2]=a[i]+c
            if a[i]- c in d.keys() :
                found2=[a[i], a[i]-c]
            if a[i]+ c in d.keys() :
                found2=[a[i], a[i]+c]
            c*=2
    if found[0]==found[1]:
        if found2[0]==found2[1]:
            print(1)
            print(a[0])
        else:
            print(2)
            print(*found2)
    else:
        print(3)
        print(*found)










    return


if __name__ == ""__main__"":
    main()
",4,0988_D,CODEFORCES,2612,Points and Powers of Two,"There are $$$n$$$ distinct points on a coordinate line, the coordinate of $$$i$$$-th point equals to $$$x_i$$$. Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two. It is necessary to consider each pair of points, not only adjacent. Note that any subset containing one element satisfies the condition above. Among all these subsets, choose a subset with maximum possible size.
In other words, you have to choose the maximum possible number of points $$$x_{i_1}, x_{i_2}, \dots, x_{i_m}$$$ such that for each pair $$$x_{i_j}$$$, $$$x_{i_k}$$$ it is true that $$$|x_{i_j} - x_{i_k}| = 2^d$$$ where $$$d$$$ is some non-negative integer number (not necessarily the same for each pair of points).
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of points.
The second line contains $$$n$$$ pairwise distinct integers $$$x_1, x_2, \dots, x_n$$$ ($$$-10^9 \le x_i \le 10^9$$$) — the coordinates of points.
In the first line print $$$m$$$ — the maximum possible number of points in a subset that satisfies the conditions described above.
In the second line print $$$m$$$ integers — the coordinates of points in the subset you have chosen.
","input
If there are multiple answers, print any of them.
output
In the first example the answer is $$$[7, 3, 5]$$$. Note, that $$$|7-3|=4=2^2$$$, $$$|7-5|=2=2^1$$$ and $$$|3-5|=2=2^1$$$. You can't find a subset having more points satisfying the required property.
","bruteforce, math"
"from sys import stdin,stdout
import heapq
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr()):
    n,k=lst()
    l=sorted(zip(lst(),lst(),range(n)))
    h=[];sm=0
    ans={}
    for i in range(n):
        pwr,cns,ind=l[i]
        sm+=cns
        if len(h)>k:
            p=0
            for i in range(len(h)):
                if h[p]>h[i]:
                    p=i
            sm-=h.pop(p)
        ans[ind]=sm
        h+=[cns]
    for i in range(n):
        stdout.write(str(ans[i])+' ')
    print()",4,0994_B,CODEFORCES,2634,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"n, k = [int(a) for a in input().split()]
power = [int(a) for a in input().split()]
coins = [int(a) for a in input().split()]

dp = [0 for i in range(n)]


def takeSecond(elem):
    return elem[1]


def takeFirst(elem):
    return elem[0]


people = [(power[i], coins[i], i) for i in range(n)]

people.sort(key=takeFirst)

dp[0] = []

for i, p in enumerate(people):
    if i == 0:
        continue
    kills = [i for i in dp[i - 1]]
    kills.append(people[i - 1][1])
    x = []

    if len(kills) > k:
        kills.remove(min(kills))

    dp[i] = kills

x = [(people[i][2], str(sum(dp[i]) + people[i][1])) for i in range(n)]

x.sort(key=takeFirst)

print("" "".join([z[1] for z in x]))
",4,0994_B,CODEFORCES,2646,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"from sys import stdin,stdout
import heapq
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr()):
    n,k=lst()
    l=sorted(zip(lst(),lst(),range(n)))
    h=[];sm=0
    ans={}
    for i in range(n):
        pwr,cns,ind=l[i]
        sm+=cns
        if len(h)>k:
            sm-=heapq.heappop(h)
        ans[ind]=sm
        heapq.heappush(h,cns)
    for i in range(n):
        stdout.write(str(ans[i])+' ')
    print()",4,0994_B,CODEFORCES,2633,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"import heapq
n, k = map(int, input().split())
p = list(map(int, input().split()))
c = list(map(int, input().split()))
indexes = sorted(list(range(n)), key=p.__getitem__)
most_vyg_odn_yye = []
res = [1]*n
cur_res = 0
for ind in indexes:
	this_cost = c[ind]
	heapq.heappush(most_vyg_odn_yye, this_cost)
	cur_res += this_cost
	res[ind] = cur_res
	if len(most_vyg_odn_yye) > k:
		cur_res -= heapq.heappop(most_vyg_odn_yye)
print(*res)
",4,0994_B,CODEFORCES,2649,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"n, k = list( map( int, input().split()))
p = list( map( int, input().split()))
c = list( map( int, input().split()))

m = {}
for i in range( n ):
    if p[ i ] not in m:
        m[ p[ i ] ] = list()
    m[ p[ i ] ].append( c[ i ] )

a = {}
t = []
for key, val in sorted( m.items() ):
    a[ key ] = sum( t )
    t += val
    t.sort()
    t = t[ max( 0, len( t ) - k ) : len( t ) ]

print( "" "".join( [ str( a[ p[ i ] ] + c[ i ] ) for i in range( n )]))
",4,0994_B,CODEFORCES,2647,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"# Author Name: Ajay Meena
# Codeforce : XXXX
import sys
import math
import bisect
import heapq
from bisect import bisect_right
from sys import stdin, stdout

# -------------- INPUT FUNCTIONS ------------------


def get_ints_in_variables(): return map(
    int, sys.stdin.readline().strip().split())


def get_int(): return int(sys.stdin.readline())


def get_ints_in_list(): return list(
    map(int, sys.stdin.readline().strip().split()))
def get_list_of_list(n): return [list(
    map(int, sys.stdin.readline().strip().split())) for _ in range(n)]


def get_string(): return sys.stdin.readline().strip()

# -------- SOME CUSTOMIZED FUNCTIONS-----------


def myceil(x, y): return (x + y - 1) // y

# -------------- SOLUTION FUNCTION ------------------


def Solution(td, n, k):
    # Write Your Code Here
    mxHeap = []
    td = sorted(td, key=lambda x: x[0])
    prefix = []
    tmp = 0
    for v in td:
        b = v[1]
        tmpAns = tmp+b
        if len(mxHeap) == k:
            if len(mxHeap) and b > mxHeap[0]:
                t = heapq.heappop(mxHeap)
                heapq.heappush(mxHeap, b)
                tmp -= t
                tmp += b
        elif len(mxHeap) < k:
            tmp += b
            heapq.heappush(mxHeap, b)
        prefix.append([tmpAns, v[2]])

    ans = [0 for _ in range(n)]
    for v in prefix:
        ans[v[1]] = v[0]
    print(*ans)


def main():
    # Take input Here and Call solution function
    n, k = get_ints_in_variables()
    a = get_ints_in_list()
    b = get_ints_in_list()
    td = [[a[i], b[i], i] for i in range(n)]
    Solution(td, n, k)


# calling main Function
if __name__ == '__main__':
    main()
",4,0994_B,CODEFORCES,2640,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"from heapq import *

n,k=map(int,input().split())
p=[int(X) for X in input().split()]
c=[int(x) for x in input().split()]
p=[[p[i],c[i],i] for i in range(n)]
p.sort()
j=0
an=[0]*n
an[p[0][2]]=p[0][1]
z=[]
heapify(z)
#print(p)
for i in range(1,n):

     s=p[i][1]
     if p[i][0]!=p[i-1][0]:
         while (j<i):

             heappush(z,(-1)*p[j][1])
             j+=1

     tt=[]
     for __ in range(k):

         tt.append(heappop(z))
         if not z:
             break
     #print(tt,i,j)
     for v in tt:
         s+=abs(v)
         heappush(z, v )
     #print(s)
     an[p[i][2]]=s

print(*an)

",4,0994_B,CODEFORCES,2638,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"import sys
import heapq

n, k = list(map(int,sys.stdin.readline().strip().split(' ')))
p = list(map(int,sys.stdin.readline().strip().split(' ')))
c = list(map(int,sys.stdin.readline().strip().split(' ')))

sortedp = sorted([(pi,i) for (i,pi) in enumerate(p)])

ans = [0 for i in range(n)]
acc_coins = 0
acc = []

if k == 0:
	print(' '.join(map(str,c)))
else:
	for i in range(n):
		coins = c[sortedp[i][1]]
		ans[sortedp[i][1]] += acc_coins + coins
		if len(acc) < k:
			acc_coins += coins
			heapq.heappush(acc,coins)
		else:
			smallest_coin = heapq.nsmallest(1,acc)[0]
			if smallest_coin < coins:
				acc_coins -= smallest_coin
				heapq.heappop(acc)
				heapq.heappush(acc,coins)
				acc_coins += coins
	print(' '.join(map(str,ans)))
",4,0994_B,CODEFORCES,2643,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"import heapq


n, k = list(map(int, input().strip().split()))

p = list(map(int, input().strip().split()))
c = list(map(int, input().strip().split()))

p = sorted([(x, i) for i, x in enumerate(p)], key=lambda x: x[0])

ans = []
top_k = []

cur_gold = 0
for i, t in enumerate(p):
    if k == 0:
        ans.append((c[t[1]], t[1]))
    else:
        if i < k:
            cur_gold += c[t[1]]
            ans.append((cur_gold, t[1]))
            heapq.heappush(top_k, c[t[1]])
        else:
            smallest = heapq.nsmallest(1, top_k)[0]
            if smallest < c[t[1]]:
                cur_gold += c[t[1]]
                ans.append((cur_gold, t[1]))
                heapq.heappop(top_k)
                heapq.heappush(top_k, c[t[1]])
                cur_gold -= smallest
            else:
                ans.append((cur_gold + c[t[1]], t[1]))

ans = sorted(ans, key=lambda x: x[1])
print("" "".join(map(lambda x: str(x[0]), ans)))",4,0994_B,CODEFORCES,2648,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"_, k = [int(x) for x in input().split()]
a = [int(x) for x in input().split()]
b = [int(x) for x in input().split()]
c = list(sorted(zip(a, b, range(len(b)))))
d = [0] * len(b)

if k == 0:
    print(' '.join(map(str, b)))
else:
    best = [0] * k
    for pwr, cnt, index in c:
        d[index] = sum(best) + cnt

        if cnt > best[0]:
            for i in range(len(best)):
                if cnt <= best[i]:
                    best.insert(i, cnt)
                    best = best[1:]
                    break
            else:
                best = best[1:] + [cnt]


    print(' '.join(map(str, d)))
",4,0994_B,CODEFORCES,2644,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"from heapq import heappush, heappop
n,k = map(int, input().split())
powers = list(map(int, input().split()))
coins = list(map(int, input().split()))

A = []
ans = [0] * n
for i in range(n):
    A.append((powers[i], coins[i], i))
A.sort()
h = []
total = 0
for i in range(n):
    _,c,idx = A[i]
    ans[idx] = total + c
    if len(h) < k:
        heappush(h, c)
        total += c
    elif h and h[0] < c:
        total -= heappop(h)
        heappush(h, c)
        total += c

for x in ans:
    print(x, end="" "")
print()
",4,0994_B,CODEFORCES,2639,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"n,k = map(int, input().split())
P = list(map(int, input().split()))
C = list(map(int, input().split()))
Q = []
for i, p in enumerate(P):
    Q.append((p, i))
Q.sort()
q = []
import heapq
heapq.heapify([])
s = 0
ans = [0]*n
if k > 0:
    for p, i in Q:
        ans[i] = s+C[i]
        if len(q) == k:
            if q[0] <= C[i]:
                v = heapq.heappop(q)
                heapq.heappush(q, C[i])
                s -= v
                s += C[i]
        else:
            heapq.heappush(q, C[i])
            s += C[i]
    print(*ans)
else:
    for p, i in Q:
        ans[i] = C[i]
    print(*ans)
",4,0994_B,CODEFORCES,2636,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"import heapq
n,k = map(int,input().split())
P = list(map(int,input().split()))
C = list(map(int,input().split()))
X = []
for i in range(n):
    X.append([P[i],C[i],i])
X.sort(key = lambda x : x[0])
coins = []
heapq.heapify(coins)
curr = 0
res = [0 for i in range(n)]
for i in range(k):
    heapq.heappush(coins,X[i][1])
    curr += X[i][1]
    res[X[i][2]] = curr
for j in range(k,n):
    
    res[X[j][2]] = X[j][1] + sum(coins)
    if len(coins)>0:
        x = heapq.heappop(coins)
        if x < X[j][1]:
            heapq.heappush(coins,X[j][1])
        else:
            heapq.heappush(coins,x)
        
    
         
    
    
print(*res)",4,0994_B,CODEFORCES,2632,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"a=input()
b=input()
c=input()
info=a.split()
info=list(map(int, info))
y=b.split()
powers=list(map(int, y))
z=c.split()
coins=list(map(int, z))
l=sorted(zip(powers,coins,range(info[0])))
final=[0]*info[0]
s=0
w=[]
for _, c, i in l:
    s+=c
    final[i]=s
    w=sorted(w+[c])
    if len(w)>info[1]:
        s-=w[0]
        del w[0]
print(*final)",4,0994_B,CODEFORCES,2641,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"import os
import sys
from io import BytesIO, IOBase
import heapq as h 
from bisect import bisect_left, bisect_right
import time
 
from types import GeneratorType
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
from collections import defaultdict as dd, deque as dq, Counter as dc
import math, string
 
start_time = time.time()
 
def getInts():
    return [int(s) for s in input().split()]
 
def getInt():
    return int(input())
 
def getStrs():
    return [s for s in input().split()]
 
def getStr():
    return input()
 
def listStr():
    return list(input())
def getMat(n):
    return [getInts() for _ in range(n)]
def get_ints():return map(int, sys.stdin.readline().split())

n,k=map(int,input().split())
knight=list(map(int,input().split()))
coins=list(map(int,input().split()))
d={};ans=[0]*n
for i in range(n):
  knight[i]=[knight[i],i]
for i in coins:
  d[i]=d.get(i,0)+1
c=coins[:]
#heapq.heapify(c)
knight=sorted(knight,key=lambda x:x[0])
#print(knight)
ans2=[];ans=coins[:]
if k==0:print(*ans)
else:
 for i in range(n):
  ans1=0
  if len(ans2)<k:ans1=sum(ans2)
  else:ans2=sorted(ans2)[-k:];ans1+=sum(ans2)
  #print(ans1)
  ans[knight[i][1]]+=ans1
  ans2.append(coins[knight[i][1]])
 print(*ans)
",4,0994_B,CODEFORCES,2637,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"from math import ceil, log
from heapq import heappop, heappush, heapify
t = 1
for test in range(t):
    n,k = map(int, input().split())
    p = list(map(int, input().split()))
    c = list(map(int, input().split()))
    arr = [i for i in sorted(enumerate(p), key=lambda x:x[1])]
    maxcoins = [0 for i in range(k)]
    heapify(maxcoins)
    ans = list(p)
    tmpSum = 0
    tmpSum2 = 0
    prev = arr[0][1]
    for ind, power in arr:
        if power>prev:
            ans[ind] = tmpSum+c[ind]
            tmpSum2 = tmpSum
        else:
            ans[ind] = tmpSum2+c[ind]
        heappush(maxcoins, c[ind])
        tmpSum+=c[ind]
        tmpSum-=heappop(maxcoins)
    print(*ans)




    

",4,0994_B,CODEFORCES,2645,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"import sys
input = sys.stdin.readline

'''

'''

from heapq import heapify, heappush, heappop

n, k = map(int, input().split())
plst = list(map(int, input().split()))
clst = list(map(int, input().split()))

if k == 0:
    print(*clst)
    sys.exit()

pc = sorted(((p, c, i) for i, (p, c) in enumerate(zip(plst, clst))), key=lambda t: (t[0], t[2]))
res = [0] * n
pq = []
pq_sum = 0
pq_size = 0

for p, c, i in pc:
    if i > 0 and plst[i] == plst[i-1]:
        res[i] = res[i-1]
    else:
        res[i] = pq_sum + c

    # Update pq
    if pq_size < k:
        heappush(pq, c)
        pq_sum += c
        pq_size += 1
    else:
        alt = heappop(pq)
        if alt < c:
            heappush(pq, c)
            pq_sum += c - alt
        else:
            heappush(pq, alt)

print(*res)
",4,0994_B,CODEFORCES,2635,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"n,m = map(int, input().split())

class Knight:
	def __init__(self, andis, p, c):
		self.p = int(p)
		self.c = int(c)
		self.andis = int(andis)
		self.ans = self.c

p = list(map(int, input().split()))
c = list(map(int, input().split()))
x = []
for i in range(n):
	x.append(Knight(i, p[i], c[i]))

x.sort(key=lambda x: x.p)
coins = []
for i in range(n-1):
	if len(coins) < m:
		coins.append(x[i].c)
		coins.sort()
	elif len(coins) > 0:
		if coins[0] < x[i].c:
			coins[0] = x[i].c
			coins.sort()
	x[i+1].ans += sum(coins)

x.sort(key=lambda x:x.andis)
for k in x:
	print(k.ans, end=' ')
	



",4,0994_B,CODEFORCES,2642,Knights of a Polygonal Table,"Unlike Knights of a Round Table, Knights of a Polygonal Table deprived of nobility and happy to kill each other. But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim. However, even such a knight will torment his conscience, so he can kill no more than $$$k$$$ other knights. Also, each knight has some number of coins. After a kill, a knight can pick up all victim's coins.
Now each knight ponders: how many coins he can have if only he kills other knights?
You should answer this question for each knight.
The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \le n \le 10^5, 0 \le k \le \min(n-1,10))$$$ — the number of knights and the number $$$k$$$ from the statement.
The second line contains $$$n$$$ integers $$$p_1, p_2 ,\ldots,p_n$$$ $$$(1 \le p_i \le 10^9)$$$ — powers of the knights. All $$$p_i$$$ are distinct.
The third line contains $$$n$$$ integers $$$c_1, c_2 ,\ldots,c_n$$$ $$$(0 \le c_i \le 10^9)$$$ — the number of coins each knight has.
Print $$$n$$$ integers — the maximum number of coins each knight can have it only he kills other knights.
Consider the first example. 
","input
In the second example the first knight can't kill anyone, while all the others should kill the one with the index less by one than their own.
output
In the third example there is only one knight, so he can't kill anyone.
","greedy, implementation, sortings"
"#winners never quit, quiters never win
from collections import deque as de
import math
from collections import Counter as cnt
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    
# A optimized school method based 
# Python3 program to check 
# if a number is prime 


def isPrime(n) : 

	# Corner cases 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	# This is checked so that we can skip 
	# middle five numbers in below loop 
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    # create an empty list and later I will
    # run a for loop with range() function using the append() method to add elements to the list.
    prime_factors = []

    # First get the number of two's that divide number
    # i.e the number of 2's that are in the factors
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2

    # After the above while loop, when number has been
    # divided by all the 2's - so the number must be odd at this point
    # Otherwise it would be perfectly divisible by 2 another time
    # so now that its odd I can skip 2 ( i = i + 2) for each increment
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i


    # Here is the crucial part.
    # First quick refreshment on the two key mathematical conjectures of Prime factorization of any non-Prime number
    # Which is - 1. If n is not a prime number AT-LEAST one Prime factor would be less than sqrt(n)
    # And - 2. If n is not a prime number - There can be AT-MOST 1 prime factor of n greater than sqrt(n).
    # Like 7 is a prime-factor for 14 which is greater than sqrt(14)
    # But if the above loop DOES NOT go beyond square root of the initial n.
    # Then how does that greater than sqrt(n) prime-factor
    # will be captured in my prime factorization function.
    # ANS to that is - in my first for-loop I am dividing n with the prime number if that prime is a factor of n.
    # Meaning, after this first for-loop gets executed completely, the adjusted initial n should become
    # either 1 or greater than 1
    # And if n has NOT become 1 after the previous for-loop, that means that
    # The remaining n is that prime factor which is greater that the square root of initial n.
    # And that's why in the next part of my algorithm, I need to check whether n becomes 1 or not,
    #This code is taken by rohan paul's github
    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
#here we go......................
#winners never quit, quitters never win
n=int(input())
pp=n
nn=n

pl=[]
nl=[]
while pp:
    pp-=1
    pl.append(input())
while nn:
    nn-=1
    nl.append(input())
ans=0
pmc=pl.count(""M"")
mc=nl.count(""M"")
if pmc < mc:
    ans+=mc -pmc
psc=pl.count(""S"")
sc=nl.count(""S"")
if psc < sc:
    ans+=sc -psc

plc=pl.count(""L"")
lc=nl.count(""L"")
if plc < lc:
    ans+=lc -plc

pxlc=pl.count(""XL"")
xlc=nl.count(""XL"")
if pxlc < xlc:
    ans+=xlc -pxlc

pxxlc=pl.count(""XXL"")
xxlc=nl.count(""XXL"")
if pxxlc < xxlc:
    ans+=xxlc -pxxlc

pxxxlc=pl.count(""XXXL"")
xxxlc=nl.count(""XXXL"")
if pxxxlc < xxxlc:
    ans+=xxxlc -pxxxlc

pxsc=pl.count(""XS"")
xsc=nl.count(""XS"")
if pxsc < xsc:
    ans+=xsc -pxsc

pxxsc=pl.count(""XXS"")
xxsc=nl.count(""XXS"")
if pxxsc < xxsc:
    ans+=xxsc -pxxsc

pxxxsc=pl.count(""XXXS"")
xxxsc=nl.count(""XXXS"")
if pxxxsc < xxxsc:
    ans+=xxxsc -pxxxsc
print(ans)

",3,1000_A,CODEFORCES,1739,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation"
"import sys, os.path
if(os.path.exists('input.txt')):
	sys.stdin = open(""input.txt"",""r"")
	

t = int(input())
last = []
current = []

for i in range(t):
	last.append(str(input()))
for i in range(t):
	current.append(str(input()))

for i in range(len(last)):
	if last[i] in current:
		current[current.index(last[i])] = ""*""
		last[i] = ""*""

last.sort()
current.sort()

total = 0
for i in range(len(last)):
	if last[i] == current[i]:
		continue
	else:
		total+=1
	
print(total)


",3,1000_A,CODEFORCES,1738,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation"
"n=int(input())
a=b=[]
k=0
for _ in range(n): 
	a.append(input())
for i in range(n):
	t=input()
	if t in a:
		a.remove(t)
print(len(a))",3,1000_A,CODEFORCES,1732,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation"
"x = int(input())
list1 = []
for i in range(x):
    value = input()
    list1.append(value)

for i in range(x):
    value = input()
    if value in list1:
        list1.remove(value)

print(len(list1))

",3,1000_A,CODEFORCES,1736,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation"
"import sys, heapq

n = int(sys.stdin.readline())
key = []
for i in ['S', 'M', 'L']:
    for j in range(4):
        key.append(j * 'X' + i)
prev = dict().fromkeys(key, 0)
now = dict().fromkeys(key, 0)
for _ in range(n):
    prev[sys.stdin.readline().rstrip()] += 1
for _ in range(n):
    now[sys.stdin.readline().rstrip()] += 1
for i in key:
    temp = min(prev[i], now[i])
    prev[i] -= temp
    now[i] -= temp
ans = 0
for i in key:
    ans += now[i]
print(ans)

",3,1000_A,CODEFORCES,1731,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation"
"def solve():
    n = int(input())
    a_dicts = [{}, {}]
    for j in range(2):
        for i in range(n):
            x = input()
            if x in a_dicts[j]:
                a_dicts[j][x] += 1
            else:
                a_dicts[j][x] = 1
            if x not in a_dicts[1 - j]:
                a_dicts[1 - j][x] = 0
    c = 0
    for k in a_dicts[0]:
        c += abs(a_dicts[0][k] - a_dicts[1][k])
    return c // 2

print(solve())",3,1000_A,CODEFORCES,1735,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation"
"from collections import Counter

n = int(input())
a = Counter()
b = Counter()
for _ in range(n):    
    a[input().strip()] += 1
for _ in range(n):
    b[input().strip()] += 1
ans = 0
for key in b:
    ans += max(b[key] - a[key], 0)
# print(a)
# print(b)
print(ans)",3,1000_A,CODEFORCES,1737,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation"
"n = int(input())
 
a = [input() for _ in range(n)]
b = [input() for _ in range(n)]
 
cost = 0
for s in [""M"", ""S"", ""XS"", ""XXS"", ""XXXS"", ""L"", ""XL"", ""XXL"", ""XXXL""]:
    ca = a.count(s)
    cb = b.count(s)
    cost += ca - min(ca, cb)
    
print(cost)",3,1000_A,CODEFORCES,1734,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation"
"n=int(input())
l1=[]
l2=[]
for _ in range(n):
    l1.append(input())
for _ in range(n):
    l2.append(input())
c=0
for i in range(n):
    if(l1[i]  in l2):
        l2.remove(l1[i])
    else:
        c+=1
#print(l1,l2)
print(c)
        
        

    ",3,1000_A,CODEFORCES,1733,Codehorses T-shirts,"Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.
The valid sizes of T-shirts are either ""M"" or from $$$0$$$ to $$$3$$$ ""X"" followed by ""S"" or ""L"". For example, sizes ""M"", ""XXS"", ""L"", ""XXXL"" are valid and ""XM"", ""Z"", ""XXXXL"" are not.
There are $$$n$$$ winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. 
Organizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.
What is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?
The lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.
The first line contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the number of T-shirts.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$a_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the previous year.
The $$$i$$$-th of the next $$$n$$$ lines contains $$$b_i$$$ — the size of the $$$i$$$-th T-shirt of the list for the current year.
It is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list $$$b$$$ from the list $$$a$$$.
Print the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.
In the first example Ksenia can replace ""M"" with ""S"" and ""S"" in one of the occurrences of ""XS"" with ""L"".
","input
In the second example Ksenia should replace ""L"" in ""XXXL"" with ""S"".
output
In the third example lists are equal.
","greedy, implementation"
"#=============================================================================
# @abhi_admin    FB UserId: abhiavisekkr     Email Id: abhiavisekkr@gmail.com
#=============================================================================
#------------------------------Dependencies-----------------------------------
#import sys
#import math
#import cmath
#import array
#import string
#import functools #for .reduce()
#import itertools 


#def get_s(): return sys.stdin.readline().strip() 
#def get_i(): return map(int, sys.stdin.readline().strip().split())


#=============================================================================
#----------------------------Keep-Calm-and-Code-------------------------------
#=============================================================================




n, k = map(int, input().split())
arr = list(map(int, input().split()))

rsum = [0]
maxx = 0.0

for i in range(n): rsum.append(rsum[-1] + arr[i])
#print(rsum)

for ki in range(k, n+1):
    for i in range(n-ki+1):
        tot = 0
        #print(i+ki, i)
        avg = (rsum[i+ki] - rsum[i])/ki
        #print(avg)
        maxx = max(maxx, avg)
print(maxx)



#=============================================================================
#-----------------------------ADMIN-ABHI-SHAKE--------------------------------
#=============================================================================",5,1003_C,CODEFORCES,3352,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"def mp():return map(int,input().split())
def it():return int(input())

n,k=mp()
l=list(mp())
ans=0
for i in range(n):
	avg,count=0,0
	for j in range(i,n):
		count+=l[j]
		if j-i+1>=k:
			avg=count/(j-i+1)
		ans=max(avg,ans)
print(ans)
",5,1003_C,CODEFORCES,3340,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"import sys
input = sys.stdin.buffer.readline
 
n,k=map(int,input().split())
arr=[int(x) for x in input().split()]
 
x=0
dp=[]
for i in range(n):
    x=x+arr[i]
    dp.append(x)
 
ans=0
for i in range(n):
    for j in range(i+k-1,n):
        ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1))
print(ans) ",5,1003_C,CODEFORCES,3351,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"import sys, heapq

n, k = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
pf = [0] * (n + 1)
pf[0] = arr[0]
for i in range(1, n):
    pf[i] = pf[i - 1] + arr[i]
ans = 0
for i in range(n):
    for j in range(n):
        left = i
        right = j
        if right - left + 1 >= k:
            temp = pf[right] - pf[left - 1]
            ans = max(ans, temp / (right - left + 1))
print(ans)",5,1003_C,CODEFORCES,3346,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"n,m=map(int,input().split())
lst=list(map(int,input().split()))
maxx=0
arr=[0]*(n+1)
for i in range(n):
    summ=0
    for j in range(i,n):
        summ+=lst[j]
        arr[j-i]=max(arr[j-i], summ/(j-i+1))
print(max(arr[m-1:]))",5,1003_C,CODEFORCES,3353,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"#------------------------template--------------------------#
import os
import sys
# from math import *
from collections import *
# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M= 998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()




n,k = value()
a = array()

ans = 0

for i in range(n-k+1):

    num = sum(a[i:i+k])
    den = k
    ans = max(ans , num/den)

    for j in range(i+k,n):

        num += a[j]
        den += 1
        ans = max(ans , num/den)

print(ans)
































",5,1003_C,CODEFORCES,3347,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"import math
for _ in range(1):
    n,k=map(int,input().split())
    l=list(map(int,input().split()))
    ans=0
    for i in range(n):
	    c=0
	    sum1=0
	    for j in range(i, n):
		    sum1 += l[j]
		    c+=1
		    if c >= k:
			    ans=max(ans,sum1/c)
print(ans)    
                
            
        ",5,1003_C,CODEFORCES,3344,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"from sys import *

n, k = map(int, stdin.readline().split())
arr = list(map(int, stdin.readline().split()))
avg = 0
for i in range(n):
	cnt = 0
	sum = 0
	for j in range(i, n):
		sum += arr[j]
		cnt += 1
		if cnt >= k:
			avg = max(avg, sum / cnt)
print(avg)",5,1003_C,CODEFORCES,3350,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"def helper(n,k,l):
	
	res = 0
	for i in range(n-k+1):
		base_seg = l[i:i+k]
		sm_bseg = sum(base_seg)
		ln_bseg = len(base_seg)
		ans = sm_bseg/ln_bseg

		for j in range(i+k,n):
			sm_bseg+=l[j]
			ln_bseg+=1
			ans=max(ans,sm_bseg/ln_bseg)


		res = max(res,ans)

	return res

n,k = map(int,input().split())
l = list(map(int,input().split()))

print(helper(n,k,l))",5,1003_C,CODEFORCES,3341,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"n, k = map(int, input().split())
li = [int(num) for num in input().split("" "", n - 1)]
ans = []
for i in range(0, n):
    su = 0
    for j in range(i, n):
        su += li[j]
        if (j - i + 1 >= k):
            ans.append(su / (j - i + 1))
print(max(ans))",5,1003_C,CODEFORCES,3349,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"from collections import Counter
import string
import math
import sys
# sys.setrecursionlimit(10**6) 
from fractions import Fraction
def array_int():
    return [int(i) for i in sys.stdin.readline().split()]
def vary(arrber_of_variables):
    if arrber_of_variables==1:
        return int(sys.stdin.readline())
    if arrber_of_variables>=2:
        return map(int,sys.stdin.readline().split()) 
def makedict(var):
    return dict(Counter(var))
testcases=1
for _ in range(testcases):
    n,k=vary(2)
    num=array_int()
    maxi=0.0
    for i in range(n):
        count=1
        sumt=num[i]
        # print(sumt)
        for j in range(i+1,n):
            sumt+=num[j]
            count+=1
            if count>=k:
                # print(sumt,sumt/count)
                maxi=max(maxi,sumt/count)
        # print(maxi)
    if k==1:
        print(max(maxi,max(num)))
    else:
        print(maxi)
    



",5,1003_C,CODEFORCES,3345,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"
import sys
input = sys.stdin.buffer.readline

n,k=map(int,input().split())
arr=[int(x) for x in input().split()]

x=0
dp=[]
for i in range(n):
    x=x+arr[i]
    dp.append(x)

ans=0
for i in range(n):
    for j in range(i+k-1,n):
        ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1))
print(ans) ",5,1003_C,CODEFORCES,3348,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"def main():
    n,k=map(int,input().split( ))
    a=list(map(int,input().split( )))
    ans=-1*10**9+7
    for i in range(n):
        s=0
        for j in range(i,n):
            s+=a[j]
            if j-i+1>=k:

                ans=max(ans,s/(j-i+1))
    print(ans)

    
main()",5,1003_C,CODEFORCES,3343,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"
rd = lambda: list(map(int, input().split()))
n, k = rd()
a = rd()
r = 0
s = [0]
for x in a:
    s.append(s[-1] + x)
for i in range(n - k + 1):
    for j in range(i + k, min(n + 1, i + 2 * k)):
        r = max(r, (s[j] - s[i]) / (j - i))
print(r)
",5,1003_C,CODEFORCES,3354,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"import sys
import math
import collections
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n,k=get_ints()
    arr=get_list()
    ans=0
    for i in range(n):
        val=arr[i]
        c=1
        sol=0
        if c >= k:
            sol = max(sol, val / c)
        for j in range(i+1,n):
            val+=arr[j]
            c+=1
            if c>=k:
                sol=max(sol,val/c)
        ans=max(sol,ans)
    print(ans)",5,1003_C,CODEFORCES,3342,Intense Heat,"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.
Mathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:
Suppose we want to analyze the segment of $$$n$$$ consecutive days. We have measured the temperatures during these $$$n$$$ days; the temperature during $$$i$$$-th day equals $$$a_i$$$.
We denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $$$x$$$ to day $$$y$$$, we calculate it as $$$\frac{\sum \limits_{i = x}^{y} a_i}{y - x + 1}$$$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days. For example, if analyzing the measures $$$[3, 4, 1, 2]$$$ and $$$k = 3$$$, we are interested in segments $$$[3, 4, 1]$$$, $$$[4, 1, 2]$$$ and $$$[3, 4, 1, 2]$$$ (we want to find the maximum value of average temperature over these segments).
You have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 5000$$$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.
The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_i \le 5000$$$) — the temperature measures during given $$$n$$$ days.
","input
Print one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $$$k$$$ consecutive days.
output
Your answer will be considered correct if the following condition holds: $$$|res - res_0| < 10^{-6}$$$, where $$$res$$$ is your answer, and $$$res_0$$$ is the answer given by the jury's solution.
","bruteforce, implementation, math"
"#------------------------template--------------------------#
import os
import sys
# from math import *
from collections import *
# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()


n=Int()
a=array()

series = [1]
fact = 1
for i in range(n+1):
    series.append(((series[-1]*2)%M + fact)%M)
    fact = (fact*2)%M


ind = n-1
ans=0

for i in range(n):
    ans = (ans + (a[i]*series[ind])%M )%M
    ind-=1

print(ans)





















",3,1009_E,CODEFORCES,1803,Intercity Travelling,"Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.
The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $$$n$$$ km. Let's say that Moscow is situated at the point with coordinate $$$0$$$ km, and Saratov — at coordinate $$$n$$$ km.
Driving for a long time may be really difficult. Formally, if Leha has already covered $$$i$$$ kilometers since he stopped to have a rest, he considers the difficulty of covering $$$(i + 1)$$$-th kilometer as $$$a_{i + 1}$$$. It is guaranteed that for every $$$i \in [1, n - 1]$$$ $$$a_i \le a_{i + 1}$$$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.
Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $$$1$$$ to $$$n - 1$$$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $$$a_1$$$, the kilometer after it — difficulty $$$a_2$$$, and so on.
For example, if $$$n = 5$$$ and there is a rest site in coordinate $$$2$$$, the difficulty of journey will be $$$2a_1 + 2a_2 + a_3$$$: the first kilometer will have difficulty $$$a_1$$$, the second one — $$$a_2$$$, then Leha will have a rest, and the third kilometer will have difficulty $$$a_1$$$, the fourth — $$$a_2$$$, and the last one — $$$a_3$$$. Another example: if $$$n = 7$$$ and there are rest sites in coordinates $$$1$$$ and $$$5$$$, the difficulty of Leha's journey is $$$3a_1 + 2a_2 + a_3 + a_4$$$.
Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $$$2^{n - 1}$$$ different distributions of rest sites (two distributions are different if there exists some point $$$x$$$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $$$p$$$ — the expected value of difficulty of his journey.
Obviously, $$$p \cdot 2^{n - 1}$$$ is an integer number. You have to calculate it modulo $$$998244353$$$.
The first line contains one number $$$n$$$ ($$$1 \le n \le 10^6$$$) — the distance from Moscow to Saratov.
","input
The second line contains $$$n$$$ integer numbers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$$$), where $$$a_i$$$ is the difficulty of $$$i$$$-th kilometer after Leha has rested.
output
Print one number — $$$p \cdot 2^{n - 1}$$$, taken modulo $$$998244353$$$.
","combinatorics, math, probabilities"
"M = 0x3b800001
wa = 0;
n = int(input())
a = list(map(int, input().split()))
now = 1
wa += a[-1]
for i in range(n - 1)[::-1]:
    wa += (now * (n - i - 1) + now * 2) * a[i]
    wa %= M
    now *= 2
    now %= M
print(wa % M)
",3,1009_E,CODEFORCES,1808,Intercity Travelling,"Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.
The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $$$n$$$ km. Let's say that Moscow is situated at the point with coordinate $$$0$$$ km, and Saratov — at coordinate $$$n$$$ km.
Driving for a long time may be really difficult. Formally, if Leha has already covered $$$i$$$ kilometers since he stopped to have a rest, he considers the difficulty of covering $$$(i + 1)$$$-th kilometer as $$$a_{i + 1}$$$. It is guaranteed that for every $$$i \in [1, n - 1]$$$ $$$a_i \le a_{i + 1}$$$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.
Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $$$1$$$ to $$$n - 1$$$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $$$a_1$$$, the kilometer after it — difficulty $$$a_2$$$, and so on.
For example, if $$$n = 5$$$ and there is a rest site in coordinate $$$2$$$, the difficulty of journey will be $$$2a_1 + 2a_2 + a_3$$$: the first kilometer will have difficulty $$$a_1$$$, the second one — $$$a_2$$$, then Leha will have a rest, and the third kilometer will have difficulty $$$a_1$$$, the fourth — $$$a_2$$$, and the last one — $$$a_3$$$. Another example: if $$$n = 7$$$ and there are rest sites in coordinates $$$1$$$ and $$$5$$$, the difficulty of Leha's journey is $$$3a_1 + 2a_2 + a_3 + a_4$$$.
Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $$$2^{n - 1}$$$ different distributions of rest sites (two distributions are different if there exists some point $$$x$$$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $$$p$$$ — the expected value of difficulty of his journey.
Obviously, $$$p \cdot 2^{n - 1}$$$ is an integer number. You have to calculate it modulo $$$998244353$$$.
The first line contains one number $$$n$$$ ($$$1 \le n \le 10^6$$$) — the distance from Moscow to Saratov.
","input
The second line contains $$$n$$$ integer numbers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$$$), where $$$a_i$$$ is the difficulty of $$$i$$$-th kilometer after Leha has rested.
output
Print one number — $$$p \cdot 2^{n - 1}$$$, taken modulo $$$998244353$$$.
","combinatorics, math, probabilities"
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
import io
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#---------------------------------Lazy Segment Tree--------------------------------------
# XXXX
class LazySegTree:
    def __init__(self, _op, _e, _mapping, _composition, _id, v):
        def set(p, x):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            _d[p] = x
            for i in range(1, _log + 1):
                _update(p >> i)
 
        def get(p):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            return _d[p]
 
        def prod(l, r):
            assert 0 <= l <= r <= _n
 
            if l == r:
                return _e
 
            l += _size
            r += _size
 
            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push(r >> i)
 
            sml = _e
            smr = _e
            while l < r:
                if l & 1:
                    sml = _op(sml, _d[l])
                    l += 1
                if r & 1:
                    r -= 1
                    smr = _op(_d[r], smr)
                l >>= 1
                r >>= 1
 
            return _op(sml, smr)
 
        def apply(l, r, f):
            assert 0 <= l <= r <= _n
            if l == r:
                return
 
            l += _size
            r += _size
 
            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push((r - 1) >> i)
 
            l2 = l
            r2 = r
            while l < r:
                if l & 1:
                    _all_apply(l, f)
                    l += 1
                if r & 1:
                    r -= 1
                    _all_apply(r, f)
                l >>= 1
                r >>= 1
            l = l2
            r = r2
 
            for i in range(1, _log + 1):
                if ((l >> i) << i) != l:
                    _update(l >> i)
                if ((r >> i) << i) != r:
                    _update((r - 1) >> i)
 
        def _update(k):
            _d[k] = _op(_d[2 * k], _d[2 * k + 1])
 
        def _all_apply(k, f):
            _d[k] = _mapping(f, _d[k])
            if k < _size:
                _lz[k] = _composition(f, _lz[k])
 
        def _push(k):
            _all_apply(2 * k, _lz[k])
            _all_apply(2 * k + 1, _lz[k])
            _lz[k] = _id
 
        _n = len(v)
        _log = _n.bit_length()
        _size = 1 << _log
        _d = [_e] * (2 * _size)
        _lz = [_id] * _size
        for i in range(_n):
            _d[_size + i] = v[i]
        for i in range(_size - 1, 0, -1):
            _update(i)
 
        self.set = set
        self.get = get
        self.prod = prod
        self.apply = apply
 
 
MIL = 1 << 20
 
 
def makeNode(total, count):
    # Pack a pair into a float
    return (total * MIL) + count
 
 
def getTotal(node):
    return math.floor(node / MIL)
 
 
def getCount(node):
    return node - getTotal(node) * MIL
 
 
nodeIdentity = makeNode(0.0, 0.0)
 
 
def nodeOp(node1, node2):
    return node1 + node2
    # Equivalent to the following:
    return makeNode(
        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)
    )
 
 
identityMapping = -1
 
 
def mapping(tag, node):
    if tag == identityMapping:
        return node
    # If assigned, new total is the number assigned times count
    count = getCount(node)
    return makeNode(tag * count, count)
 
 
def composition(mapping1, mapping2):
    # If assigned multiple times, take first non-identity assignment
    return mapping1 if mapping1 != identityMapping else mapping2
#-------------------------------------------------------------------------
prime = [True for i in range(10)] 
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n): 
          
        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p): 
                pp[i]+=1
                prime[i] = False
        p += 1
#---------------------------------Binary Search------------------------------------------
def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res
#---------------------------------running code------------------------------------------

n = int(input())
a = list(map(int, input().split()))
difficulty = a[0]
expectation = a[0] % 998244353
for i in range(1, n):
    expectation = expectation * 2 + difficulty + a[i]
    difficulty = difficulty * 2 + a[i]
    expectation %= 998244353
    difficulty %= 998244353
print(expectation)",3,1009_E,CODEFORCES,1807,Intercity Travelling,"Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.
The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $$$n$$$ km. Let's say that Moscow is situated at the point with coordinate $$$0$$$ km, and Saratov — at coordinate $$$n$$$ km.
Driving for a long time may be really difficult. Formally, if Leha has already covered $$$i$$$ kilometers since he stopped to have a rest, he considers the difficulty of covering $$$(i + 1)$$$-th kilometer as $$$a_{i + 1}$$$. It is guaranteed that for every $$$i \in [1, n - 1]$$$ $$$a_i \le a_{i + 1}$$$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.
Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $$$1$$$ to $$$n - 1$$$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $$$a_1$$$, the kilometer after it — difficulty $$$a_2$$$, and so on.
For example, if $$$n = 5$$$ and there is a rest site in coordinate $$$2$$$, the difficulty of journey will be $$$2a_1 + 2a_2 + a_3$$$: the first kilometer will have difficulty $$$a_1$$$, the second one — $$$a_2$$$, then Leha will have a rest, and the third kilometer will have difficulty $$$a_1$$$, the fourth — $$$a_2$$$, and the last one — $$$a_3$$$. Another example: if $$$n = 7$$$ and there are rest sites in coordinates $$$1$$$ and $$$5$$$, the difficulty of Leha's journey is $$$3a_1 + 2a_2 + a_3 + a_4$$$.
Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $$$2^{n - 1}$$$ different distributions of rest sites (two distributions are different if there exists some point $$$x$$$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $$$p$$$ — the expected value of difficulty of his journey.
Obviously, $$$p \cdot 2^{n - 1}$$$ is an integer number. You have to calculate it modulo $$$998244353$$$.
The first line contains one number $$$n$$$ ($$$1 \le n \le 10^6$$$) — the distance from Moscow to Saratov.
","input
The second line contains $$$n$$$ integer numbers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$$$), where $$$a_i$$$ is the difficulty of $$$i$$$-th kilometer after Leha has rested.
output
Print one number — $$$p \cdot 2^{n - 1}$$$, taken modulo $$$998244353$$$.
","combinatorics, math, probabilities"
"# by the authority of GOD     author: manhar singh sachdev #

def some_random_function():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function5():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

import os,sys
from io import BytesIO,IOBase

def main():
    mod = 998244353
    powe = [1]
    for _ in range(10**6):
        powe.append((powe[-1]*2)%mod)
    n = int(input())
    a = list(map(int,input().split()))
    ans,dp,dp1 = (a[0]*powe[n-1])%mod,a[0],0
    for i in range(1,n):
        if i == 1:
            dp = (dp+a[i])%mod
        else:
            dp = (dp*2+a[i]-dp1)%mod
        ans = (ans+powe[n-i-1]*dp)%mod
        dp1 = a[i]
    print(ans)

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def some_random_function1():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function2():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function3():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function4():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function6():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function7():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function8():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

if __name__ == '__main__':
    main()",3,1009_E,CODEFORCES,1805,Intercity Travelling,"Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.
The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $$$n$$$ km. Let's say that Moscow is situated at the point with coordinate $$$0$$$ km, and Saratov — at coordinate $$$n$$$ km.
Driving for a long time may be really difficult. Formally, if Leha has already covered $$$i$$$ kilometers since he stopped to have a rest, he considers the difficulty of covering $$$(i + 1)$$$-th kilometer as $$$a_{i + 1}$$$. It is guaranteed that for every $$$i \in [1, n - 1]$$$ $$$a_i \le a_{i + 1}$$$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.
Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $$$1$$$ to $$$n - 1$$$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $$$a_1$$$, the kilometer after it — difficulty $$$a_2$$$, and so on.
For example, if $$$n = 5$$$ and there is a rest site in coordinate $$$2$$$, the difficulty of journey will be $$$2a_1 + 2a_2 + a_3$$$: the first kilometer will have difficulty $$$a_1$$$, the second one — $$$a_2$$$, then Leha will have a rest, and the third kilometer will have difficulty $$$a_1$$$, the fourth — $$$a_2$$$, and the last one — $$$a_3$$$. Another example: if $$$n = 7$$$ and there are rest sites in coordinates $$$1$$$ and $$$5$$$, the difficulty of Leha's journey is $$$3a_1 + 2a_2 + a_3 + a_4$$$.
Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $$$2^{n - 1}$$$ different distributions of rest sites (two distributions are different if there exists some point $$$x$$$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $$$p$$$ — the expected value of difficulty of his journey.
Obviously, $$$p \cdot 2^{n - 1}$$$ is an integer number. You have to calculate it modulo $$$998244353$$$.
The first line contains one number $$$n$$$ ($$$1 \le n \le 10^6$$$) — the distance from Moscow to Saratov.
","input
The second line contains $$$n$$$ integer numbers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$$$), where $$$a_i$$$ is the difficulty of $$$i$$$-th kilometer after Leha has rested.
output
Print one number — $$$p \cdot 2^{n - 1}$$$, taken modulo $$$998244353$$$.
","combinatorics, math, probabilities"
"n = int(input())
a = list(map(int, input().split()))


s = a[0] % 998244353
y = a[0]
for x in a[1:]:

	s = s * 2 + y + x
	y = y * 2 + x

	s %= 998244353
	y %= 998244353


	# print(s)

# print(a)
# print(c)

print(s)
",3,1009_E,CODEFORCES,1811,Intercity Travelling,"Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.
The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $$$n$$$ km. Let's say that Moscow is situated at the point with coordinate $$$0$$$ km, and Saratov — at coordinate $$$n$$$ km.
Driving for a long time may be really difficult. Formally, if Leha has already covered $$$i$$$ kilometers since he stopped to have a rest, he considers the difficulty of covering $$$(i + 1)$$$-th kilometer as $$$a_{i + 1}$$$. It is guaranteed that for every $$$i \in [1, n - 1]$$$ $$$a_i \le a_{i + 1}$$$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.
Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $$$1$$$ to $$$n - 1$$$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $$$a_1$$$, the kilometer after it — difficulty $$$a_2$$$, and so on.
For example, if $$$n = 5$$$ and there is a rest site in coordinate $$$2$$$, the difficulty of journey will be $$$2a_1 + 2a_2 + a_3$$$: the first kilometer will have difficulty $$$a_1$$$, the second one — $$$a_2$$$, then Leha will have a rest, and the third kilometer will have difficulty $$$a_1$$$, the fourth — $$$a_2$$$, and the last one — $$$a_3$$$. Another example: if $$$n = 7$$$ and there are rest sites in coordinates $$$1$$$ and $$$5$$$, the difficulty of Leha's journey is $$$3a_1 + 2a_2 + a_3 + a_4$$$.
Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $$$2^{n - 1}$$$ different distributions of rest sites (two distributions are different if there exists some point $$$x$$$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $$$p$$$ — the expected value of difficulty of his journey.
Obviously, $$$p \cdot 2^{n - 1}$$$ is an integer number. You have to calculate it modulo $$$998244353$$$.
The first line contains one number $$$n$$$ ($$$1 \le n \le 10^6$$$) — the distance from Moscow to Saratov.
","input
The second line contains $$$n$$$ integer numbers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$$$), where $$$a_i$$$ is the difficulty of $$$i$$$-th kilometer after Leha has rested.
output
Print one number — $$$p \cdot 2^{n - 1}$$$, taken modulo $$$998244353$$$.
","combinatorics, math, probabilities"
"MOD = 998244353

def main():
    n = int(input())
    a = [int(x) for x in input().split(' ')]
    
    p, sp, s, ss = 0, 0, 0, 0
    for x in a:
        ss = (2 * ss + s) % MOD
        s = (s + x) % MOD
        p = (ss + sp + s) % MOD
        sp = (sp + p) % MOD
    print(p)

if __name__ == '__main__':
    main()
",3,1009_E,CODEFORCES,1809,Intercity Travelling,"Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.
The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $$$n$$$ km. Let's say that Moscow is situated at the point with coordinate $$$0$$$ km, and Saratov — at coordinate $$$n$$$ km.
Driving for a long time may be really difficult. Formally, if Leha has already covered $$$i$$$ kilometers since he stopped to have a rest, he considers the difficulty of covering $$$(i + 1)$$$-th kilometer as $$$a_{i + 1}$$$. It is guaranteed that for every $$$i \in [1, n - 1]$$$ $$$a_i \le a_{i + 1}$$$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.
Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $$$1$$$ to $$$n - 1$$$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $$$a_1$$$, the kilometer after it — difficulty $$$a_2$$$, and so on.
For example, if $$$n = 5$$$ and there is a rest site in coordinate $$$2$$$, the difficulty of journey will be $$$2a_1 + 2a_2 + a_3$$$: the first kilometer will have difficulty $$$a_1$$$, the second one — $$$a_2$$$, then Leha will have a rest, and the third kilometer will have difficulty $$$a_1$$$, the fourth — $$$a_2$$$, and the last one — $$$a_3$$$. Another example: if $$$n = 7$$$ and there are rest sites in coordinates $$$1$$$ and $$$5$$$, the difficulty of Leha's journey is $$$3a_1 + 2a_2 + a_3 + a_4$$$.
Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $$$2^{n - 1}$$$ different distributions of rest sites (two distributions are different if there exists some point $$$x$$$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $$$p$$$ — the expected value of difficulty of his journey.
Obviously, $$$p \cdot 2^{n - 1}$$$ is an integer number. You have to calculate it modulo $$$998244353$$$.
The first line contains one number $$$n$$$ ($$$1 \le n \le 10^6$$$) — the distance from Moscow to Saratov.
","input
The second line contains $$$n$$$ integer numbers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$$$), where $$$a_i$$$ is the difficulty of $$$i$$$-th kilometer after Leha has rested.
output
Print one number — $$$p \cdot 2^{n - 1}$$$, taken modulo $$$998244353$$$.
","combinatorics, math, probabilities"
"from sys import stdin, stdout


def main():
    p = 998244353  # Constante brindada por el problema
    n = int(stdin.readline())
    a = list(readline())
    answer = a[-1]
    pow_ = 1  # Potencia de 2
    for i in range(n - 1, 0, -1):  # Se analizan todas las dificultades
        answer = (answer + a[i - 1] * (2 + n - i) * pow_ % p) % p  # Se calcula la expresion
        pow_ = pow_ * 2 % p  # Se aumenta la potencia de 2
    return answer


def readline():  # Metodo para leer una linea completa, dividirla en elementos y convertirlos en numeros enteros
    return map(int, stdin.readline().strip().split())


if __name__ == '__main__':
    stdout.write(str(main()) + '\n')
",3,1009_E,CODEFORCES,1804,Intercity Travelling,"Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.
The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $$$n$$$ km. Let's say that Moscow is situated at the point with coordinate $$$0$$$ km, and Saratov — at coordinate $$$n$$$ km.
Driving for a long time may be really difficult. Formally, if Leha has already covered $$$i$$$ kilometers since he stopped to have a rest, he considers the difficulty of covering $$$(i + 1)$$$-th kilometer as $$$a_{i + 1}$$$. It is guaranteed that for every $$$i \in [1, n - 1]$$$ $$$a_i \le a_{i + 1}$$$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.
Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $$$1$$$ to $$$n - 1$$$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $$$a_1$$$, the kilometer after it — difficulty $$$a_2$$$, and so on.
For example, if $$$n = 5$$$ and there is a rest site in coordinate $$$2$$$, the difficulty of journey will be $$$2a_1 + 2a_2 + a_3$$$: the first kilometer will have difficulty $$$a_1$$$, the second one — $$$a_2$$$, then Leha will have a rest, and the third kilometer will have difficulty $$$a_1$$$, the fourth — $$$a_2$$$, and the last one — $$$a_3$$$. Another example: if $$$n = 7$$$ and there are rest sites in coordinates $$$1$$$ and $$$5$$$, the difficulty of Leha's journey is $$$3a_1 + 2a_2 + a_3 + a_4$$$.
Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $$$2^{n - 1}$$$ different distributions of rest sites (two distributions are different if there exists some point $$$x$$$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $$$p$$$ — the expected value of difficulty of his journey.
Obviously, $$$p \cdot 2^{n - 1}$$$ is an integer number. You have to calculate it modulo $$$998244353$$$.
The first line contains one number $$$n$$$ ($$$1 \le n \le 10^6$$$) — the distance from Moscow to Saratov.
","input
The second line contains $$$n$$$ integer numbers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$$$), where $$$a_i$$$ is the difficulty of $$$i$$$-th kilometer after Leha has rested.
output
Print one number — $$$p \cdot 2^{n - 1}$$$, taken modulo $$$998244353$$$.
","combinatorics, math, probabilities"
"n = int(input())
ans = 0
mod = 998244353
a = list(map(int, input().split()))
p = 1 / 2

for i in range(n):
    ans = (ans + (i + 2) * (p * a[n - i - 1] % mod) % mod) % mod
    p = (2 * p) % mod

print(int(ans) % mod)",3,1009_E,CODEFORCES,1810,Intercity Travelling,"Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.
The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $$$n$$$ km. Let's say that Moscow is situated at the point with coordinate $$$0$$$ km, and Saratov — at coordinate $$$n$$$ km.
Driving for a long time may be really difficult. Formally, if Leha has already covered $$$i$$$ kilometers since he stopped to have a rest, he considers the difficulty of covering $$$(i + 1)$$$-th kilometer as $$$a_{i + 1}$$$. It is guaranteed that for every $$$i \in [1, n - 1]$$$ $$$a_i \le a_{i + 1}$$$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.
Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $$$1$$$ to $$$n - 1$$$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $$$a_1$$$, the kilometer after it — difficulty $$$a_2$$$, and so on.
For example, if $$$n = 5$$$ and there is a rest site in coordinate $$$2$$$, the difficulty of journey will be $$$2a_1 + 2a_2 + a_3$$$: the first kilometer will have difficulty $$$a_1$$$, the second one — $$$a_2$$$, then Leha will have a rest, and the third kilometer will have difficulty $$$a_1$$$, the fourth — $$$a_2$$$, and the last one — $$$a_3$$$. Another example: if $$$n = 7$$$ and there are rest sites in coordinates $$$1$$$ and $$$5$$$, the difficulty of Leha's journey is $$$3a_1 + 2a_2 + a_3 + a_4$$$.
Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $$$2^{n - 1}$$$ different distributions of rest sites (two distributions are different if there exists some point $$$x$$$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $$$p$$$ — the expected value of difficulty of his journey.
Obviously, $$$p \cdot 2^{n - 1}$$$ is an integer number. You have to calculate it modulo $$$998244353$$$.
The first line contains one number $$$n$$$ ($$$1 \le n \le 10^6$$$) — the distance from Moscow to Saratov.
","input
The second line contains $$$n$$$ integer numbers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$$$), where $$$a_i$$$ is the difficulty of $$$i$$$-th kilometer after Leha has rested.
output
Print one number — $$$p \cdot 2^{n - 1}$$$, taken modulo $$$998244353$$$.
","combinatorics, math, probabilities"
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:
    # @timer
    def __init__(self):
        pass

    def __call__(self):
        MOD = 998244353
        N = 1000007
        pow2 = [0] * N        

        n = int(input())
        a = list(map(int, input().strip().split()))

        pow2[0] = 1
        for i in range(n):
            pow2[i + 1] = (2 * pow2[i]) % MOD

        res = 0
        for i in range(1, n):
            tmp = (a[i - 1] * (n + 2 - i)) % MOD
            res += (pow2[n - 1 - i] * tmp) % MOD
            res %= MOD
        res += a[n - 1]
        res %= MOD            
        print(res)        

solver()()",3,1009_E,CODEFORCES,1806,Intercity Travelling,"Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.
The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $$$n$$$ km. Let's say that Moscow is situated at the point with coordinate $$$0$$$ km, and Saratov — at coordinate $$$n$$$ km.
Driving for a long time may be really difficult. Formally, if Leha has already covered $$$i$$$ kilometers since he stopped to have a rest, he considers the difficulty of covering $$$(i + 1)$$$-th kilometer as $$$a_{i + 1}$$$. It is guaranteed that for every $$$i \in [1, n - 1]$$$ $$$a_i \le a_{i + 1}$$$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.
Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $$$1$$$ to $$$n - 1$$$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $$$a_1$$$, the kilometer after it — difficulty $$$a_2$$$, and so on.
For example, if $$$n = 5$$$ and there is a rest site in coordinate $$$2$$$, the difficulty of journey will be $$$2a_1 + 2a_2 + a_3$$$: the first kilometer will have difficulty $$$a_1$$$, the second one — $$$a_2$$$, then Leha will have a rest, and the third kilometer will have difficulty $$$a_1$$$, the fourth — $$$a_2$$$, and the last one — $$$a_3$$$. Another example: if $$$n = 7$$$ and there are rest sites in coordinates $$$1$$$ and $$$5$$$, the difficulty of Leha's journey is $$$3a_1 + 2a_2 + a_3 + a_4$$$.
Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $$$2^{n - 1}$$$ different distributions of rest sites (two distributions are different if there exists some point $$$x$$$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $$$p$$$ — the expected value of difficulty of his journey.
Obviously, $$$p \cdot 2^{n - 1}$$$ is an integer number. You have to calculate it modulo $$$998244353$$$.
The first line contains one number $$$n$$$ ($$$1 \le n \le 10^6$$$) — the distance from Moscow to Saratov.
","input
The second line contains $$$n$$$ integer numbers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$$$), where $$$a_i$$$ is the difficulty of $$$i$$$-th kilometer after Leha has rested.
output
Print one number — $$$p \cdot 2^{n - 1}$$$, taken modulo $$$998244353$$$.
","combinatorics, math, probabilities"
"n, m, k, l = map(int, input().split())
need = k + l
if need % m == 0 and need <= n:
    print(need // m)
else:
    x = need // m + 1
    if x * m > n:
        print(-1)
    else:
        print(x)",1,1068_A,CODEFORCES,534,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"n, m, k, l = map(int, input().split())
cnt = (k + l + m - 1) // m
if cnt * m > n:
    print(-1)
else:
    print(cnt)",1,1068_A,CODEFORCES,533,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"n, m, k, l = map(int, input().split())
k += l
x = (k + m - 1) // (m);
if m * x > n:
    print(-1)
else:
    print(x)",1,1068_A,CODEFORCES,538,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"n, m, k, l = [int(x) for x in input().split()]
if (l + k) % m == 0:
    c = (l + k)//m
else:
    c = (l + k)//m + 1
if m * c > n:
    print(-1)
else:
    print(c)",1,1068_A,CODEFORCES,544,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"from sys import stdin, stdout
from math import sin, tan, cos

n, m, k, l = map(int, stdin.readline().split())

lb, rb = 0, n // m + 1
while rb - lb > 1:
    mid = (lb + rb) >> 1
    
    if mid * m - k >= l:
        rb = mid
    else:
        lb = mid

if lb != n // m:
    stdout.write(str(rb))
else:
    stdout.write('-1')",2,1068_A,CODEFORCES,1162,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"n, m, k, l = map(int, input().split())
if (k+l+m-1)//m*m > n:
    print(-1)
else:
    print((k+l+m-1)//m)
",1,1068_A,CODEFORCES,535,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"N, M, K, L = list(map(int, input().split()))

each = (K + L) // M

if (K + L) % M != 0:
    each += 1

if each * M > N:
    print(-1)
else:
    print(each)
",1,1068_A,CODEFORCES,551,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"N, M, K, L = map(int, input().split())
if N < M or K + L > N:
    print(-1)
else:
    print((L + K - 1) // M + 1 if ((L + K - 1) // M + 1) * M <= N else -1)",1,1068_A,CODEFORCES,540,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"import sys


N, M, K, L = map(int, sys.stdin.readline().split())

if M * (N / M) - K < L:
  print(""-1"")
  sys.exit(0)

def solve(curr):
  return curr * M - K >= L

l = 0
r = N / M
while r - l > 1:
  mid = (r + l) / 2
  if solve(mid):
    r = mid
  else:
    l = mid

print(r)
",2,1068_A,CODEFORCES,1163,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"#!/usr/bin/env python3
n,m,k,l=map(int,input().split())
q=(l+k-1)//m+1
if q*m>n:print(-1)
else:print(q)
",1,1068_A,CODEFORCES,549,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"def main():
    n, m, k, l = map(int, input().split())
    d = (l + k) // m
    if (l + k) % m:
        d += 1
    if m * d > n or n - k < l:
        print(-1)
    else:
        print(d)


main()",1,1068_A,CODEFORCES,550,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"import math

def main():
    n,m,k,l = map(int, input().strip().split())

    t = int(k + l + m - 1) // m

    if k + l > n:
        print(-1)
        return
    
    if m * t > n:
        print(-1)
        return
    
    print(t)

if __name__ == '__main__':
    main()",1,1068_A,CODEFORCES,543,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"import math, sys

def mp():
    return list(map(int, input().split()))

def main():
    n, m, k, l = mp()
    ost = n - k
    need = (l + k)
    if ost < l or need > n:
        print(-1)
        return
    ans = (l + k - 1) // m + 1
    if ans * m - k >= l and ans * m <= n:
        print(ans)
    else:
        print(-1)
    
    
    

deb = 0
if deb:
    file = open(""input.txt"", ""r"")
    input = file.readline
else:
    input = sys.stdin.readline

main()

if deb:
    file.close()
",1,1068_A,CODEFORCES,547,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"n, m, k, l = map(int, input().split())
if m > n or (l + k + m - 1) // m * m > n:
    print(-1)
else:
    x = (l + k + m - 1) // m
    print(x)",1,1068_A,CODEFORCES,546,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"n, m, k, l = map(int, input().split())
required = k + l
per_friend = (required + m - 1) // m
if (m * per_friend > n):
    print(-1)
else:
    print(per_friend)   
",1,1068_A,CODEFORCES,541,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"import math

if __name__ == '__main__':
    n, m, k, l = map(int, input().split())
    one_friend = (k + l) // m + int((k + l) % m != 0)
    if one_friend * m > n:
        print(-1)
    else:
        print(one_friend)
",1,1068_A,CODEFORCES,542,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"import math

n, m, k, l = map(int, input().split())

x = (l + k) // m
if x * m < l + k:
    x += 1
assert x * m >= l + k

if m * x > n:
    print(-1)
else:
    print(x)",1,1068_A,CODEFORCES,548,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"n, m, k, l = map(int, input().split())
if m > n:
    print(-1)
elif l + k > n:
    print(-1)
else:
    s = (l + k) // m + bool((l + k) % m)
    if s * m > n:
        print(-1)
    else:
        print(s)
",1,1068_A,CODEFORCES,545,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"n, m, k, l = map(int, input().split())
if k + l > n:
    print(-1)
else:
    x = (k + l) // m + (1 if (k + l) % m != 0 else 0)
    if x * m > n:
        print(-1)
    else:
        print(x)
",1,1068_A,CODEFORCES,536,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"n, m, k, l = list(map(int, input().split()))
if (l > n - k):
    print(-1)
else:
    am = ((l + k) // m + bool((l + k) % m))
    if am * m > n:
        print(-1)
    else:
        print(am)",1,1068_A,CODEFORCES,539,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"n,m,k,l=map(int,input().split())
c=(k+l)//m
if (k+l)%m!=0:
    c+=1
if n>=m*c:
    print(c)
else :
    print(-1)",1,1068_A,CODEFORCES,537,Birthday,"Ivan is collecting coins. There are only $$$N$$$ different collectible coins, Ivan has $$$K$$$ of them. He will be celebrating his birthday soon, so all his $$$M$$$ freinds decided to gift him coins. They all agreed to three terms: 
But his friends don't know which coins have Ivan already got in his collection. They don't want to spend money so they want to buy minimum quantity of coins, that satisfy all terms, irrespective of the Ivan's collection. Help them to find this minimum number of coins or define it's not possible to meet all the terms.
The only line of input contains 4 integers $$$N$$$, $$$M$$$, $$$K$$$, $$$L$$$ ($$$1 \le K \le N \le 10^{18}$$$; $$$1 \le M, \,\, L \le 10^{18}$$$) — quantity of different coins, number of Ivan's friends, size of Ivan's collection and quantity of coins, that must be new in Ivan's collection.
Print one number — minimal number of coins one friend can gift to satisfy all the conditions. If it is impossible to satisfy all three conditions print ""-1"" (without quotes).
","input
In the first test, one coin from each friend is enough, as he will be presented with 15 different coins and 13 of them will definitely be new.
output
In the second test, Ivan has 11 friends, but there are only 10 different coins. So all friends can't present him different coins.
",math
"
MOD = 998244353


def pop_count(x) :
    ans = 0
    while (x > 0) :
        ans = ans + x % 2
        x = x // 2
    return ans

def check(x, k) :
    mask = 0
    nx = int(x)
    while (nx > 0) :
        mask = mask | (1 << (nx % 10))
        nx = nx // 10
    if (pop_count(mask) <= k) :
        return x
    return 0

pop = []
p10 = []
f = [[0 for j in range(1 << 10)] for i in range(20)]
w = [[0 for j in range(1 << 10)] for i in range(20)]
def prepare() : 
    p10.append(1)
    for i in range(20) :
        p10.append(p10[i] * 10 % MOD)
    for i in range(1 << 10) :
        pop.append(pop_count(i))
    w[0][0] = 1
    for i in range(1, 20) :
        for j in range(1 << 10) :
            for use in range(10) : 
                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD
                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD

def solve(x, k) :
    sx = [int(d) for d in str(x)] 
    n = len(sx) 
    ans = 0
    for i in range(1, n) :
        for use in range(1, 10) :
            for mask in range(1 << 10) : 
                if (pop[(1 << use) | mask] <= k) :
                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD
    cmask = 0
    csum = 0
    for i in range(n) :
        cdig = sx[i]
        for use in range(cdig) : 
            if (i == 0 and use == 0) :
                continue
            nmask = cmask | (1 << use)
            for mask in range(1 << 10) : 
                if (pop[nmask | mask] <= k) :
                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD
        cmask |= 1 << cdig
        csum = (10 * csum + cdig) % MOD
    return ans

prepare()
l, r, k = map(int, input().split())
ans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD
print(ans)
    
",6,1073_E,CODEFORCES,3784,Segment Sum,"You are given two integers $$$l$$$ and $$$r$$$ ($$$l \le r$$$). Your task is to calculate the sum of numbers from $$$l$$$ to $$$r$$$ (including $$$l$$$ and $$$r$$$) such that each number contains at most $$$k$$$ different digits, and print this sum modulo $$$998244353$$$.
For example, if $$$k = 1$$$ then you have to calculate all numbers from $$$l$$$ to $$$r$$$ such that each number is formed using only one digit. For $$$l = 10, r = 50$$$ the answer is $$$11 + 22 + 33 + 44 = 110$$$.
The only line of the input contains three integers $$$l$$$, $$$r$$$ and $$$k$$$ ($$$1 \le l \le r < 10^{18}, 1 \le k \le 10$$$) — the borders of the segment and the maximum number of different digits.
Print one integer — the sum of numbers from $$$l$$$ to $$$r$$$ such that each number contains at most $$$k$$$ different digits, modulo $$$998244353$$$.
For the first example the answer is just the sum of numbers from $$$l$$$ to $$$r$$$ which equals to $$$\frac{50 \cdot 51}{2} - \frac{9 \cdot 10}{2} = 1230$$$. This example also explained in the problem statement but for $$$k = 1$$$.
","input
For the second example the answer is just the sum of numbers from $$$l$$$ to $$$r$$$ which equals to $$$\frac{2345 \cdot 2346}{2} = 2750685$$$.
output
For the third example the answer is $$$101 + 110 + 111 + 112 + 113 + 114 + 115 + 116 + 117 + 118 + 119 + 121 + 122 + 131 + 133 + 141 + 144 + 151 = 2189$$$.
","bitmasks, combinatorics, dp, math"
"


l, r, k =map(int,input().split())

d = {i:2**i for i in range(10)}

cache = {}

def can(i, m):
    return d[i] & m

def calc(m):
    b = 1
    c = 0
    for i in range(10):
        if b & m:
            c += 1
        b *= 2

    return c

def sm(ln, k, m, s='', first=False):
    if ln < 1:
        return 0, 1

    if (ln, k, m, s, first) in cache:
        return cache[(ln, k, m, s, first)]

    ans = 0
    count = 0
    base = 10 ** (ln-1)

    use_new = calc(m) < k

    if s:
        finish = int(s[0])+1
    else:
        finish = 10

    for i in range(finish):
        if use_new or can(i, m):
            ss = s[1:]
            if i != finish-1:
                ss = ''
            nm = m | d[i]
            nfirst = False
            if i == 0 and first:
                nm = m
                nfirst = True
            nexta, nextc = sm(ln-1, k, nm, ss, nfirst)
            ans += base * i * nextc + nexta
            count += nextc

#    print(ln, k, m, s, first, ans, count)
    cache[(ln, k, m, s, first)] = (ans, count)

    return ans, count

def call(a, k):
    s = str(a)
    return sm(len(s), k, 0, s, True)[0]


#print((call(r, k) - call(l-1, k)))
print((call(r, k) - call(l-1, k)) % 998244353)
",6,1073_E,CODEFORCES,3783,Segment Sum,"You are given two integers $$$l$$$ and $$$r$$$ ($$$l \le r$$$). Your task is to calculate the sum of numbers from $$$l$$$ to $$$r$$$ (including $$$l$$$ and $$$r$$$) such that each number contains at most $$$k$$$ different digits, and print this sum modulo $$$998244353$$$.
For example, if $$$k = 1$$$ then you have to calculate all numbers from $$$l$$$ to $$$r$$$ such that each number is formed using only one digit. For $$$l = 10, r = 50$$$ the answer is $$$11 + 22 + 33 + 44 = 110$$$.
The only line of the input contains three integers $$$l$$$, $$$r$$$ and $$$k$$$ ($$$1 \le l \le r < 10^{18}, 1 \le k \le 10$$$) — the borders of the segment and the maximum number of different digits.
Print one integer — the sum of numbers from $$$l$$$ to $$$r$$$ such that each number contains at most $$$k$$$ different digits, modulo $$$998244353$$$.
For the first example the answer is just the sum of numbers from $$$l$$$ to $$$r$$$ which equals to $$$\frac{50 \cdot 51}{2} - \frac{9 \cdot 10}{2} = 1230$$$. This example also explained in the problem statement but for $$$k = 1$$$.
","input
For the second example the answer is just the sum of numbers from $$$l$$$ to $$$r$$$ which equals to $$$\frac{2345 \cdot 2346}{2} = 2750685$$$.
output
For the third example the answer is $$$101 + 110 + 111 + 112 + 113 + 114 + 115 + 116 + 117 + 118 + 119 + 121 + 122 + 131 + 133 + 141 + 144 + 151 = 2189$$$.
","bitmasks, combinatorics, dp, math"
"import sys
from array import array  # noqa: F401
import typing as Tp  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def main():
    l, r, k = map(int, input().split())

    valid_bits, is_valid_bits = [], [0] * 1024

    for bit in range(1024):
        if bin(bit).count('1') <= k:
            valid_bits.append(bit)
            is_valid_bits[bit] = 1

    mod = 998244353

    def solve(ub):
        dp = array('i', [0]) * 1024
        dp_cnt = array('i', [0]) * 1024
        next_dp = array('i', [0]) * 1024
        next_dp_cnt = array('i', [0]) * 1024
        boundary_dp, b_bit = 0, 0

        for e, digit in zip(range(len(str(ub)) - 1, -1, -1), map(int, str(ub))):
            base = pow(10, e, mod)

            for bit in valid_bits:
                for d in range(10):
                    nextbit = bit | (1 << d)
                    if is_valid_bits[nextbit]:
                        next_dp[nextbit] = (
                            next_dp[nextbit] + dp[bit]
                            + base * d * dp_cnt[bit]
                        ) % mod

                        next_dp_cnt[nextbit] += dp_cnt[bit]
                        if next_dp_cnt[nextbit] >= mod:
                            next_dp_cnt[nextbit] -= mod

            for d in range(digit):
                nextbit = b_bit | (1 << d)
                if is_valid_bits[nextbit]:
                    next_dp[nextbit] = (
                        next_dp[nextbit] + boundary_dp + base * d
                    ) % mod
                    next_dp_cnt[nextbit] += 1

            b_bit |= (1 << digit)
            boundary_dp = (boundary_dp + base * digit) % mod

            for i in valid_bits:
                dp[i] = next_dp[i]
                dp_cnt[i] = next_dp_cnt[i]
                next_dp[i] = next_dp_cnt[i] = 0

            dp[0], dp_cnt[0] = 0, 1
            dp[1] = dp_cnt[1] = 0

        return (sum(dp) + (boundary_dp if is_valid_bits[b_bit] else 0)) % mod

    # print(solve(r), solve(l - 1))
    print((solve(r) - solve(l - 1)) % mod)


if __name__ == '__main__':
    main()
",6,1073_E,CODEFORCES,3782,Segment Sum,"You are given two integers $$$l$$$ and $$$r$$$ ($$$l \le r$$$). Your task is to calculate the sum of numbers from $$$l$$$ to $$$r$$$ (including $$$l$$$ and $$$r$$$) such that each number contains at most $$$k$$$ different digits, and print this sum modulo $$$998244353$$$.
For example, if $$$k = 1$$$ then you have to calculate all numbers from $$$l$$$ to $$$r$$$ such that each number is formed using only one digit. For $$$l = 10, r = 50$$$ the answer is $$$11 + 22 + 33 + 44 = 110$$$.
The only line of the input contains three integers $$$l$$$, $$$r$$$ and $$$k$$$ ($$$1 \le l \le r < 10^{18}, 1 \le k \le 10$$$) — the borders of the segment and the maximum number of different digits.
Print one integer — the sum of numbers from $$$l$$$ to $$$r$$$ such that each number contains at most $$$k$$$ different digits, modulo $$$998244353$$$.
For the first example the answer is just the sum of numbers from $$$l$$$ to $$$r$$$ which equals to $$$\frac{50 \cdot 51}{2} - \frac{9 \cdot 10}{2} = 1230$$$. This example also explained in the problem statement but for $$$k = 1$$$.
","input
For the second example the answer is just the sum of numbers from $$$l$$$ to $$$r$$$ which equals to $$$\frac{2345 \cdot 2346}{2} = 2750685$$$.
output
For the third example the answer is $$$101 + 110 + 111 + 112 + 113 + 114 + 115 + 116 + 117 + 118 + 119 + 121 + 122 + 131 + 133 + 141 + 144 + 151 = 2189$$$.
","bitmasks, combinatorics, dp, math"
"import sys

mod = 998244353
MAX_LENGTH = 20
bound = [0] * MAX_LENGTH

def mul(a, b): return (a * b) % mod
def add(a, b):
    a += b
    if a < 0: a += mod
    if a >= mod: a -= mod
    return a

def digitize(num):
    for i in range(MAX_LENGTH):
        bound[i] = num % 10
        num //= 10

def rec(smaller, start, pos, mask):
    global k
    if bit_count[mask] > k:
        return [0, 0]
    if pos == -1:
        return [0, 1]

    # if the two following lines are removed, the code reutrns correct results
    if dp[smaller][start][pos][mask][0] != -1:
        return dp[smaller][start][pos][mask]

    res_sum = res_ways = 0
    for digit in range(0, 10):
        if smaller == 0 and digit > bound[pos]:
            continue
        new_smaller = smaller | (digit < bound[pos])
        new_start = start | (digit > 0) | (pos == 0)
        new_mask = (mask | (1 << digit)) if new_start == 1 else 0

        cur_sum, cur_ways = rec(new_smaller, new_start, pos - 1, new_mask)
        res_sum = add(res_sum, add(mul(mul(digit, ten_pow[pos]), cur_ways), cur_sum))
        res_ways = add(res_ways, cur_ways)

    dp[smaller][start][pos][mask][0], dp[smaller][start][pos][mask][1] = res_sum, res_ways
    return dp[smaller][start][pos][mask]

def solve(upper_bound):
    global dp
    dp = [[[[[-1, -1] for _ in range(1 << 10)] for _ in range(MAX_LENGTH)] for _ in range(2)] for _ in range(2)]
    digitize(upper_bound)
    ans = rec(0, 0, MAX_LENGTH - 1, 0)
    return ans[0]

inp = [int(x) for x in sys.stdin.read().split()]
l, r, k = inp[0], inp[1], inp[2]

bit_count = [0] * (1 << 10)
for i in range(1, 1 << 10): bit_count[i] = bit_count[i & (i - 1)] + 1
ten_pow = [1]
for i in range(MAX_LENGTH): ten_pow.append(mul(ten_pow[-1], 10))

print(add(solve(r), -solve(l - 1)))
",6,1073_E,CODEFORCES,3785,Segment Sum,"You are given two integers $$$l$$$ and $$$r$$$ ($$$l \le r$$$). Your task is to calculate the sum of numbers from $$$l$$$ to $$$r$$$ (including $$$l$$$ and $$$r$$$) such that each number contains at most $$$k$$$ different digits, and print this sum modulo $$$998244353$$$.
For example, if $$$k = 1$$$ then you have to calculate all numbers from $$$l$$$ to $$$r$$$ such that each number is formed using only one digit. For $$$l = 10, r = 50$$$ the answer is $$$11 + 22 + 33 + 44 = 110$$$.
The only line of the input contains three integers $$$l$$$, $$$r$$$ and $$$k$$$ ($$$1 \le l \le r < 10^{18}, 1 \le k \le 10$$$) — the borders of the segment and the maximum number of different digits.
Print one integer — the sum of numbers from $$$l$$$ to $$$r$$$ such that each number contains at most $$$k$$$ different digits, modulo $$$998244353$$$.
For the first example the answer is just the sum of numbers from $$$l$$$ to $$$r$$$ which equals to $$$\frac{50 \cdot 51}{2} - \frac{9 \cdot 10}{2} = 1230$$$. This example also explained in the problem statement but for $$$k = 1$$$.
","input
For the second example the answer is just the sum of numbers from $$$l$$$ to $$$r$$$ which equals to $$$\frac{2345 \cdot 2346}{2} = 2750685$$$.
output
For the third example the answer is $$$101 + 110 + 111 + 112 + 113 + 114 + 115 + 116 + 117 + 118 + 119 + 121 + 122 + 131 + 133 + 141 + 144 + 151 = 2189$$$.
","bitmasks, combinatorics, dp, math"
"from collections import deque

def addedge(u, v, value):
	global e
	a = [v, value, None]
	b = [u, 0, a]
	a[2] = b
	e[u].append(a)
	e[v].append(b)
	

inf = 2 * (10 ** 12)
ans = 0
n, m = map(int, input().split())
e = [[] for i in range(n + m + 2)]
a = tuple(map(int, input().split()))
S, T = 0, m + n + 1
for i in range(1, m + 1):
	u, v, w = map(int, input().split())
	ans += w
	addedge(i, u + m, inf)
	addedge(i, v + m, inf)
	addedge(S, i, w)
for i in range(m + 1, T):
	addedge(i, T, a[i - m - 1])
# for i in range(n + m + 2):
# 	for edge in e[i]:
# 		print('%d to %d w %d' % (i, edge[0] if edge[0] <= m else edge[0] - m, edge[1]))

lvl = None
def bfs():
	global e, lvl
	lvl = [0] * (n + m + 2)
	q = deque([0])
	while q:
		node = q.popleft()
		# print('node = %d' % node)
		for edge in e[node]:
			if edge[0] != 0 and lvl[edge[0]] == 0 and edge[1]:
				lvl[edge[0]] = lvl[node] + 1
				q.append(edge[0])
	# print(lvl)


def dfs(node, maxdelta):
	global e, lvl
	if node == T:
		return maxdelta
	delta = 0
	for edge in e[node]:
		if lvl[edge[0]] == lvl[node] + 1 and edge[1]:
			tmp = dfs(edge[0], min(maxdelta, edge[1]))
			if tmp > 0:
				edge[1] -= tmp
				edge[2][1] += tmp
				maxdelta -= tmp
				delta += tmp
			if maxdelta == 0:
				break
	return delta

flow = 0
while 1:
	bfs()
	tmp = dfs(0, inf)
	if tmp == 0:
		break
	flow += tmp
ans -= flow
print(ans)





",6,1082_G,CODEFORCES,3789,Petya and Graph,"Petya has a simple graph (that is, a graph without loops or multiple edges) consisting of $$$n$$$ vertices and $$$m$$$ edges.
The weight of the $$$i$$$-th vertex is $$$a_i$$$.
The weight of the $$$i$$$-th edge is $$$w_i$$$.
A subgraph of a graph is some set of the graph vertices and some set of the graph edges. The set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices. 
The weight of a subgraph is the sum of the weights of its edges, minus the sum of the weights of its vertices. You need to find the maximum weight of subgraph of given graph. The given graph does not contain loops and multiple edges.
The first line contains two numbers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^3, 0 \le m \le 10^3$$$) - the number of vertices and edges in the graph, respectively.
The next line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) - the weights of the vertices of the graph.
The following $$$m$$$ lines contain edges: the $$$i$$$-e edge is defined by a triple of integers $$$v_i, u_i, w_i$$$ ($$$1 \le v_i, u_i \le n, 1 \le w_i \le 10^9, v_i \neq u_i$$$). This triple means that between the vertices $$$v_i$$$ and $$$u_i$$$ there is an edge of weight $$$w_i$$$. It is guaranteed that the graph does not contain loops and multiple edges.
","input
Print one integer — the maximum weight of the subgraph of the given graph.
output
In the first test example, the optimal subgraph consists of the vertices $$${1, 3, 4}$$$ and has weight $$$4 + 4 + 5 - (1 + 2 + 2) = 8$$$. In the second test case, the optimal subgraph is empty.
","flows, graphs"
"class edge(object):
	def __init__(self,ne,to,fl):
		self.ne=ne
		self.to=to
		self.fl=fl

def add(x,y,z):
	global tot
	tot+=1
	e.append(edge(he[x],y,z))
	he[x]=tot

def addedge(x,y,z):
	add(x,y,z)
	add(y,x,0)

def bfs():
	global deep
	deep=[0 for i in range(T+1)]
	q=[]
	q.append(S)
	deep[S]=1
	lp=0
	while (len(q)>lp):
		x=q[lp]
		lp+=1
		i=he[x]
		while (i):
			y=e[i].to
			if ((deep[y]==0)and(e[i].fl!=0)):
				deep[y]=deep[x]+1
				q.append(y)
			i=e[i].ne
	return deep[T]!=0

def dfs(x,flow):
	global deep
	if ((x==T)or(flow==0)):
		return flow
	used=0
	i=he[x]
	while (i):
		y=e[i].to
		if ((deep[y]==deep[x]+1)and(e[i].fl!=0)):
			now=dfs(y,min(flow-used,e[i].fl))
			used+=now
			e[i].fl-=now
			e[i^1].fl+=now
			if (flow==used):
				break;
		i=e[i].ne
	if (used==0):
		deep[x]=-1
	return used

def dinic():
	res=0
	while (bfs()):
		res+=dfs(S,INF)
	return res

n,m=map(int,input().split())
ans=0
weight=[0]+list(map(int,input().split()))

e=[0,0]
tot=1
S=n+m+1
T=S+1
he=[0 for i in range(T+1)]
INF=1000000007#只要>10^9就足够了

for i in range(1,n+1):
	addedge(S,i,weight[i]);
for i in range(1,m+1):
	x,y,w=map(int,input().split())
	addedge(n+i,T,w)
	addedge(x,n+i,INF)
	addedge(y,n+i,INF)
	ans+=w
ans-=dinic()
print(ans)",6,1082_G,CODEFORCES,3788,Petya and Graph,"Petya has a simple graph (that is, a graph without loops or multiple edges) consisting of $$$n$$$ vertices and $$$m$$$ edges.
The weight of the $$$i$$$-th vertex is $$$a_i$$$.
The weight of the $$$i$$$-th edge is $$$w_i$$$.
A subgraph of a graph is some set of the graph vertices and some set of the graph edges. The set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices. 
The weight of a subgraph is the sum of the weights of its edges, minus the sum of the weights of its vertices. You need to find the maximum weight of subgraph of given graph. The given graph does not contain loops and multiple edges.
The first line contains two numbers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^3, 0 \le m \le 10^3$$$) - the number of vertices and edges in the graph, respectively.
The next line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) - the weights of the vertices of the graph.
The following $$$m$$$ lines contain edges: the $$$i$$$-e edge is defined by a triple of integers $$$v_i, u_i, w_i$$$ ($$$1 \le v_i, u_i \le n, 1 \le w_i \le 10^9, v_i \neq u_i$$$). This triple means that between the vertices $$$v_i$$$ and $$$u_i$$$ there is an edge of weight $$$w_i$$$. It is guaranteed that the graph does not contain loops and multiple edges.
","input
Print one integer — the maximum weight of the subgraph of the given graph.
output
In the first test example, the optimal subgraph consists of the vertices $$${1, 3, 4}$$$ and has weight $$$4 + 4 + 5 - (1 + 2 + 2) = 8$$$. In the second test case, the optimal subgraph is empty.
","flows, graphs"
"import sys
class Graph:
    verticies = {}
    nodesCount = 0

    class Vertex:
        def __init__(self, label, endPoint=None):
            self.label = label
            self.edges = []
            self.visitedToken = 0
            self.endPoint = endPoint

    class Edge:
        residual = None

        def __init__(self, from_, to_, isResidual, maxCapacity):
            self.from_ = from_
            self.to_ = to_
            self.isResidual = isResidual
            self.capacity = maxCapacity
            self.flow = 0

        def augment(self, bootleneck):
            self.flow += bootleneck
            self.residual.flow -= bootleneck

        def remainingCapacity(self):
            return self.capacity - self.flow

    def addEdge(self, from_, to_, capacity):
        from_ = self.verticies[from_]
        to_ = self.verticies[to_]
        if from_.endPoint and from_.endPoint != to_:
            from_ = from_.endPoint

        main = self.Edge(from_, to_, False, capacity)
        residual = self.Edge(to_, from_, True, 0)

        main.residual = residual
        residual.residual = main

        from_.edges.append(main)
        to_.edges.append(residual)

    def addVertex(self, label, *args):
        self.nodesCount += 1
        self.verticies[label] = self.Vertex(label)

    def maxFlow(self, f, t):
        f = self.verticies[f]
        t = self.verticies[t]
        visitedToken = 1
        flow = 0

        def dfs(node, bootleneck=sys.maxsize):
            node.visitedToken = visitedToken
            bootleneck_backup = bootleneck

            if node == t:
                return bootleneck

            for edge in node.edges:
                if edge.remainingCapacity() == 0 or edge.to_.visitedToken == visitedToken:
                    continue

                bootleneck = dfs(edge.to_, min(
                    bootleneck, edge.remainingCapacity()))
                if bootleneck:
                    edge.augment(bootleneck)
                    return bootleneck
                else:
                    bootleneck = bootleneck_backup

            return 0

        while True:
            bootleneck = dfs(f)
            # print(bootleneck)
            if not bootleneck:
                break

            flow += bootleneck
            visitedToken += 1

        return flow


g = Graph()

n, m = map(int, input().split())
vv = list(map(int, input().split()))


for i in range(n+m+2):
    g.addVertex(i)

for i, v in enumerate(vv):
    g.addEdge(m+i+1, n+m+1, v)


s = 0

for i in range(1, m+1):
    a, b, c = map(int, input().split())
    s += c

    g.addEdge(0, i, c)
    g.addEdge(i, a+m, c)
    g.addEdge(i, b+m, c)


print(s-g.maxFlow(0, n+m+1))
",6,1082_G,CODEFORCES,3786,Petya and Graph,"Petya has a simple graph (that is, a graph without loops or multiple edges) consisting of $$$n$$$ vertices and $$$m$$$ edges.
The weight of the $$$i$$$-th vertex is $$$a_i$$$.
The weight of the $$$i$$$-th edge is $$$w_i$$$.
A subgraph of a graph is some set of the graph vertices and some set of the graph edges. The set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices. 
The weight of a subgraph is the sum of the weights of its edges, minus the sum of the weights of its vertices. You need to find the maximum weight of subgraph of given graph. The given graph does not contain loops and multiple edges.
The first line contains two numbers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^3, 0 \le m \le 10^3$$$) - the number of vertices and edges in the graph, respectively.
The next line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) - the weights of the vertices of the graph.
The following $$$m$$$ lines contain edges: the $$$i$$$-e edge is defined by a triple of integers $$$v_i, u_i, w_i$$$ ($$$1 \le v_i, u_i \le n, 1 \le w_i \le 10^9, v_i \neq u_i$$$). This triple means that between the vertices $$$v_i$$$ and $$$u_i$$$ there is an edge of weight $$$w_i$$$. It is guaranteed that the graph does not contain loops and multiple edges.
","input
Print one integer — the maximum weight of the subgraph of the given graph.
output
In the first test example, the optimal subgraph consists of the vertices $$${1, 3, 4}$$$ and has weight $$$4 + 4 + 5 - (1 + 2 + 2) = 8$$$. In the second test case, the optimal subgraph is empty.
","flows, graphs"
"class edge(object):
	def __init__(self,ne,to,fl):
		self.ne=ne
		self.to=to
		self.fl=fl

def add(x,y,z):
	global tot
	tot+=1
	e.append(edge(he[x],y,z))
	he[x]=tot

def addedge(x,y,z):
	add(x,y,z)
	add(y,x,0)

def bfs():
	global deep
	deep=[0 for i in range(T+1)]
	q=[]
	q.append(S)
	deep[S]=1
	while (len(q)>0):
		x=q[0]
		del(q[0])
		i=he[x]
		while (i):
			y=e[i].to
			if ((deep[y]==0)and(e[i].fl!=0)):
				deep[y]=deep[x]+1
				q.append(y)
			i=e[i].ne
	return deep[T]!=0

def dfs(x,flow):
	global deep
	if ((x==T)or(flow==0)):
		return flow
	used=0
	i=he[x]
	while (i):
		y=e[i].to
		if ((deep[y]==deep[x]+1)and(e[i].fl!=0)):
			now=dfs(y,min(flow-used,e[i].fl))
			used+=now
			e[i].fl-=now
			e[i^1].fl+=now
			if (flow==used):
				break;
		i=e[i].ne
	if (used==0):
		deep[x]=-1
	return used

def dinic():
	res=0
	while (bfs()):
		res+=dfs(S,INF)
	return res

n,m=map(int,input().split())
ans=0
weight=[0]+list(map(int,input().split()))

e=[0,0]
tot=1
S=n+m+1
T=S+1
he=[0 for i in range(T+1)]
INF=1000000007

for i in range(1,n+1):
	addedge(S,i,weight[i]);
for i in range(1,m+1):
	x,y,w=map(int,input().split())
	addedge(n+i,T,w)
	addedge(x,n+i,INF)
	addedge(y,n+i,INF)
	ans+=w
ans-=dinic()
print(ans)",6,1082_G,CODEFORCES,3787,Petya and Graph,"Petya has a simple graph (that is, a graph without loops or multiple edges) consisting of $$$n$$$ vertices and $$$m$$$ edges.
The weight of the $$$i$$$-th vertex is $$$a_i$$$.
The weight of the $$$i$$$-th edge is $$$w_i$$$.
A subgraph of a graph is some set of the graph vertices and some set of the graph edges. The set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices. 
The weight of a subgraph is the sum of the weights of its edges, minus the sum of the weights of its vertices. You need to find the maximum weight of subgraph of given graph. The given graph does not contain loops and multiple edges.
The first line contains two numbers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 10^3, 0 \le m \le 10^3$$$) - the number of vertices and edges in the graph, respectively.
The next line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) - the weights of the vertices of the graph.
The following $$$m$$$ lines contain edges: the $$$i$$$-e edge is defined by a triple of integers $$$v_i, u_i, w_i$$$ ($$$1 \le v_i, u_i \le n, 1 \le w_i \le 10^9, v_i \neq u_i$$$). This triple means that between the vertices $$$v_i$$$ and $$$u_i$$$ there is an edge of weight $$$w_i$$$. It is guaranteed that the graph does not contain loops and multiple edges.
","input
Print one integer — the maximum weight of the subgraph of the given graph.
output
In the first test example, the optimal subgraph consists of the vertices $$${1, 3, 4}$$$ and has weight $$$4 + 4 + 5 - (1 + 2 + 2) = 8$$$. In the second test case, the optimal subgraph is empty.
","flows, graphs"
"def get_path_hv(A, B):
	x, y = A

	path = [(x, y)]

	while x < B[0]:
		x += 1
		path.append((x, y))

	while x > B[0]:
		x -= 1
		path.append((x, y))

	while y < B[1]:
		y += 1
		path.append((x, y))

	while y > B[1]:
		y -= 1
		path.append((x, y))

	return path

def get_path_vh(A, B):
	x, y = A

	path = [(x, y)]

	while y < B[1]:
		y += 1
		path.append((x, y))

	while y > B[1]:
		y -= 1
		path.append((x, y))

	while x < B[0]:
		x += 1
		path.append((x, y))

	while x > B[0]:
		x -= 1
		path.append((x, y))

	return path

A = tuple(map(int, input().split()))
B = tuple(map(int, input().split()))
C = tuple(map(int, input().split()))

paths = []
paths.append([get_path_vh(A, B), get_path_hv(A, B)])
paths.append([get_path_vh(C, B), get_path_hv(C, B)])
paths.append([get_path_vh(A, C), get_path_hv(A, C)])

ans = 10 ** 8
ans_path = []

for i in range(3):
	for j in range(3):
		if i != j:
			for a in paths[i]:
				for b in paths[j]:
					X = list(set([*a, *b]))

					if len(X) < ans:
						ans = len(X)
						ans_path = X

print(ans)
for p in ans_path:
	print(*p)
",1,1086_A,CODEFORCES,633,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
x3, y3 = map(int, input().split())

points = [(x1, y1), (x2, y2), (y3, x3)]

def gen_points(A, B):
	'''
	+--.
	|
	|
	.
	'''

	return [(A[0], B[1]), (B[0], A[1])]

points += gen_points([x1, y1], [x2, y2])
points += gen_points([x2, y2], [x3, y3])
points += gen_points([x1, y1], [x3, y3])

points = list(set(points))

ans = 1e9
ans_l = []

def mark_points(A, B):
	A = list(A)
	B = list(B)
	d = set()
	x_s = 1 if A[0] < B[0] else -1
	y_s = 1 if A[1] < B[1] else -1
	d.add((A[0], A[1]))
	while A[0] != B[0]:
		A[0] += x_s
		d.add((A[0], A[1]))
	while A[1] != B[1]:
		A[1] += y_s
		d.add((A[0], A[1]))
	return d

for el in points:
	d = mark_points([x1, y1], el).union(mark_points([x2, y2], el))
	d = d.union(mark_points([x3, y3], el))
	if len(d) < ans:
		ans = len(d)
		ans_l = d

print(ans)
for el in ans_l:
	print(*el)",5,1086_A,CODEFORCES,3574,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"l = []
a, b = map(int, input().split())
l.append((a,b))
a, b = map(int, input().split())
l.append((a,b))
a, b = map(int, input().split())
l.append((a,b))
l.sort()
path = []
path.append(l[0])
x = l[0][0]
while(x<l[1][0]):
	path.append((x, l[0][1]))
	x = x + 1
up = False
if(l[0][1]<l[1][1]):
	#print(""why"")
	up = True
if(up):
	y = l[0][1]
	while(y<=l[1][1]):
		path.append((l[1][0], y))
		y = y+1
else:
	y = l[0][1]
	while(y>=l[1][1]):
		path.append((l[1][0], y))
		y = y-1
up = False
if(l[1][1]<l[2][1]):
	up = True
if(up):
	y = l[1][1]
	while(y<=l[2][1]):
		path.append((l[1][0], y))
		y = y+1
else:
	y = l[1][1]
	while(y>=l[2][1]):
		path.append((l[1][0], y))
		y = y-1
x = l[1][0]
while(x<l[2][0]):
	path.append((x, l[2][1]))
	x = x + 1
path.append(l[2])
path = list(set(path))
print(len(path))
for i in range(len(path)):
	print(str(path[i][0])+"" ""+str(path[i][1]))

",1,1086_A,CODEFORCES,639,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())
if ax > bx:
    ax, bx = bx, ax
    ay, by = by, ay
if ax > cx:
    ax, cx = cx, ax
    ay, cy = cy, ay
if bx > cx:
    bx, cx = cx, bx
    by, cy = cy, by
ans = []
for i in range(min(ay, by, cy), max(ay, by, cy) + 1):
    ans.append([bx, i])
for i in range(ax, bx):
    ans.append([i, ay])
for i in range(bx + 1, cx + 1):
    ans.append([i, cy])
print(len(ans))
for x in ans:
    print(x[0], x[1])

	 	 		    		 	    	 					 	",1,1086_A,CODEFORCES,640,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"def path(x1,y1,x2,y2,hor):
    out=[]
    if hor:
        for i in range(x2-x1):
            out.append((x1+i,y1))
        if y2>y1:
            for i in range(y2-y1):
                out.append((x2,y1+i))
        else:
            for i in range(y1-y2):
                out.append((x2,y1-i))
    else:
        for i in range(x2-x1):
            out.append((x2-i,y2))
        if y2>y1:
            for i in range(y2-y1):
                out.append((x1,y2-i))
        else:
            for i in range(y1-y2):
                out.append((x1,y2+i))
    return out[1:]
a,b=map(int,input().split())
c,d=map(int,input().split())
e,f=map(int,input().split())
if a>c:
    a,b,c,d=c,d,a,b
if c>e:
    c,d,e,f=e,f,c,d
if a>c:
    a,b,c,d=c,d,a,b
if c==e and abs(f-b)<abs(d-b):
    c,d,e,f=e,f,c,d
g1=path(a,b,c,d,True)
if d>b:
    if f<b:
        g2=path(c,b,e,f,True)
    elif f<d:
        g2=path(c,f,e,f,True)
    else:
        g2=path(c,d,e,f,True)
else:
    if f<d:
        g2=path(c,d,e,f,True)
    elif f<b:
        g2=path(c,f,e,f,True)
    else:
        g2=path(c,b,e,f,True)
print(len(g1)+len(g2)+3)
print(a,b)
print(c,d)
print(e,f)
for x,y in g1:
    print(x,y)
for x,y in g2:
    print(x,y)",1,1086_A,CODEFORCES,637,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"a = list(map(int,input().split()))
b = list(map(int,input().split()))
c = list(map(int,input().split()))
a,b,c= sorted([a,b,c])

path = []
for i in range(min(a[1],b[1],c[1]) , max(a[1],b[1],c[1]) + 1):
    path.append((b[0],i))
for i in range(a[0],b[0]+1):
    path.append((i,a[1]))
for i in range(b[0],c[0]+1):
    path.append((i,c[1]))

print(len(set(path)))
for i in set(path):
    print(*i)
",1,1086_A,CODEFORCES,632,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"xa, ya = map(int, input().split())
xb, yb = map(int, input().split())
xc, yc = map(int, input().split())
if (xb, yb) < (xa, ya):
    xa, ya, xb, yb = xb, yb, xa, ya
if (xc, yc) < (xa, ya):
    xa, ya, xc, yc = xc, yc, xa, ya
if xb > xc:
    xb, yb, xc, yc = xc, yc, xb, yb
d = 1 if ya <= yc else -1
if ya <= yb <= yc or ya >= yb >= yc:
    print(xc - xa + abs(yc - ya) + 1)
    for x in range(xa, xb):
        print(x, ya)
    for y in range(ya, yc, d):
        print(xb, y)
    for x in range(xb, xc + 1):
        print(x, yc)
elif yb < min(ya, yc):
    print(xc - xa + max(ya, yc) - yb + 1)
    for x in range(xa, xc + 1):
        print(x, min(ya, yc))
    for y in range(yb, min(ya, yc)):
        print(xb, y)
    if ya < yc:
        for y in range(ya + 1, yc + 1):
            print(xc, y)
    else:
        for y in range(yc + 1, ya + 1):
            print(xa, y)
else:
    print(xc - xa + yb - min(ya, yc) + 1)
    for x in range(xa, xc + 1):
        print(x, max(ya, yc))
    for y in range(max(ya, yc) + 1, yb + 1):
        print(xb, y)
    if ya < yc:
        for y in range(ya, yc):
            print(xa, y)
    else:
        for y in range(yc, ya):
            print(xc, y)
",1,1086_A,CODEFORCES,636,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
p0 = getIntList()
p1 = getIntList()
p2 = getIntList()
#print(N)

zp = [p0, p1, p2]



def getpath( p0, p1):
    if p0[0] < p1[0]:
        sp = 1
    elif p0[0] > p1[0]:
        sp = -1
    else:
        sp =0
    zz = [tuple(p0), tuple(p1)]
    if sp!=0:
        for x in range(p0[0], p1[0]+ sp, sp):
            tp = (x, p0[1])
            zz.append(tp)
    if p0[1] < p1[1]:
        sp = 1
    elif p0[1] > p1[1]:
        sp = -1
    else:
        sp = 0
    if sp!=0:
        for y in range(p0[1], p1[1] + sp, sp):
            tp = (p1[0], y)
            zz.append(tp)
    return zz

nr = 1000000;
zr = set()
for i in range(3):
    for j in range(3):
        cx = zp[i][0]
        cy = zp[j][1]
        cp = (cx, cy)
        z1 = getpath(cp, zp[0])
        z2 =getpath(cp, zp[1])
        z3 =getpath(cp, zp[2])
        
        z0 = z1+z2+z3
        s1 = set(z0)
        dprint(cp,s1)
        if len(s1) < nr:
            nr = len(s1)
            zr = s1
        
print(len(zr))
for x in zr:
    print(x[0], x[1])



",1,1086_A,CODEFORCES,634,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"
from itertools import permutations, chain

def get_plots(a,b):

  ax,ay = a
  bx,by = b

  for x in range(ax,bx,1 if ax < bx else -1):
    yield (x,ay)
  for y in range(ay,by,1 if ay < by else -1):
    yield (bx,y)

def solve(points):

  for a,b,c in permutations(points):
    ax,ay = a
    bx,by = b
    cx,cy = c
    if min(ax,bx) <= cx <= max(ax,bx) and min(ay,by) <= cy <= max(ay,by):
      return list(chain(get_plots(a,c), get_plots(c,b), [b]))

  def it():
    for a,b,c in permutations(points):
      ax,ay = a
      bx,by = b
      m = (ax,by)
      L = list(chain(get_plots(a,m),get_plots(b,m), get_plots(c,m), [m]))
      yield (len(L),L)

  return min(it())[1]



points = [tuple(map(int,input().split())) for _ in range(3)]

res = solve(points)
print(len(res))
for x,y in res:
  print(x,y)
",3,1086_A,CODEFORCES,2060,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"import sys
from math import floor, ceil
#sys.stdin = open('input.txt', 'r')
r = lambda: sys.stdin.readline().strip()

a = [[0] * 2 for i in range(3)]


def abs(x):
    if x < 0:
        x = -x
    return x


def calcLen(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2) + 1


def main():
    a[0][0], a[0][1] = map(int, r().split())
    a[1][0], a[1][1] = map(int, r().split())
    a[2][0], a[2][1] = map(int, r().split())
    xMax = max(a[0][0], a[1][0], a[2][0])
    xMin = min(a[0][0], a[1][0], a[2][0])
    yMax = max(a[0][1], a[1][1], a[2][1])
    yMin = min(a[0][1], a[1][1], a[2][1])

    pathLen = xMax - xMin + yMax - yMin + 1
    for i in range(3):
        for j in range(3):
            px = a[i][0]
            py = a[j][1]
            sum = 0
            for k in range(3):
                sum += (calcLen(a[k][0], a[k][1], px, py))
            sum -= 2
            if sum == pathLen:
                break
        if sum == pathLen:
            break
    sq = [[0]*(yMax+1) for i in range(xMax+1)]
    for i in range(3):
        if px == a[i][0]:
            c = -1
            if py > a[i][1]:
                c = 1
            for j in range(a[i][1], py, c):
                sq[px][j]=1
        elif py== a[i][1]:
            c = -1
            if px > a[i][0]:
                c= 1
            for j in range(a[i][0], px, c):
                sq[j][py] = 1
        else:
            c = -1
            if py > a[i][1]:
                c = 1
            for j in range(a[i][1], py + c, c):
                sq[a[i][0]][j] = 1
                
            c = -1
            if px > a[i][0]:
                c= 1
            for j in range(a[i][0], px, c):
                sq[j][py] = 1
    sq[px][py] = 1
    ans = []
    for i in range(xMax + 1):
        for j in range(yMax + 1):
            if sq[i][j] == 1:
                ans.append((i, j))
    print(len(ans))
    for i in ans:
        print(i[0], i[1])

main()
",1,1086_A,CODEFORCES,638,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

# A. Connect Three

a = [tuple(mi()) for i in range(3)]
a.sort()

up1 = a[1][1] >= a[0][1]
up2 = a[2][1] >= a[0][1]
ans = {a[0]}
x, y = a[0]
if up1 and up2:
    while y < min(a[1][1], a[2][1]):
        y += 1
        ans.add((x, y))
    while x < a[2][0]:
        x += 1
        ans.add((x, y))
    hx, hy = a[2] if a[2][1] > a[1][1] else a[1]
    while hy > y:
        ans.add((hx, hy))
        hy -= 1
else:
    dn1 = a[1][1] <= a[0][1]
    dn2 = a[2][1] <= a[0][1]
    ans = {a[0]}
    x, y = a[0]
    if dn1 and dn2:
        while y > max(a[1][1], a[2][1]):
            y -= 1
            ans.add((x, y))
        while x < a[2][0]:
            x += 1
            ans.add((x, y))
        lx, ly = a[2] if a[2][1] < a[1][1] else a[1]
        while ly < y:
            ans.add((lx, ly))
            ly += 1
    else:
        x, y = a[0]
        ans = {a[0]}
        while x < a[2][0]:
            x += 1
            ans.add((x, y))
        dy = 1 if a[1][1] <= a[0][1] else -1
        xx, yy = a[1]
        while yy != a[0][1]:
            ans.add((xx, yy))
            yy += dy
        dy = 1 if a[2][1] <= a[0][1] else -1
        xx, yy = a[2]
        while yy != a[0][1]:
            ans.add((xx, yy))
            yy += dy

ans = sorted(ans)
print(len(ans))
print('\n'.join('%d %d' % (x, y) for x, y in ans))",1,1086_A,CODEFORCES,635,Connect Three,"The Squareland national forest is divided into equal $$$1 \times 1$$$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $$$(x, y)$$$ of its south-west corner.
Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $$$A, B, C$$$ in the forest. Initially, all plots in the forest (including the plots $$$A, B, C$$$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $$$A, B, C$$$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.
Of course, the friends don't want to strain too much. Help them find out the smallest number of plots they need to clean from trees.
The first line contains two integers $$$x_A$$$ and $$$y_A$$$ — coordinates of the plot $$$A$$$ ($$$0 \leq x_A, y_A \leq 1000$$$). The following two lines describe coordinates $$$(x_B, y_B)$$$ and $$$(x_C, y_C)$$$ of plots $$$B$$$ and $$$C$$$ respectively in the same format ($$$0 \leq x_B, y_B, x_C, y_C \leq 1000$$$). It is guaranteed that all three plots are distinct.
On the first line print a single integer $$$k$$$ — the smallest number of plots needed to be cleaned from trees. The following $$$k$$$ lines should contain coordinates of all plots needed to be cleaned. All $$$k$$$ plots should be distinct. You can output the plots in any order.
If there are multiple solutions, print any of them.
","input
The first example is shown on the picture in the legend.
output
The second example is illustrated with the following image:
","greedy, implementation"
"n, m=[int(k) for k in input().split()]
res=[]
for j in range(n//2):
    for k in range(m):
        res.append(str(j+1)+"" ""+str(k+1))
        res.append(str(n-j)+"" ""+str(m-k))
if n%2:
    for j in range(m//2):
        res.append(f""{n//2+1} {j+1}"")
        res.append(f""{n//2+1} {m-j}"")
    if m%2:
        res.append(f""{n//2+1} {m//2+1}"")
print(""\n"".join(res))",5,1179_B,CODEFORCES,3586,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import math

inp = input().split(' ')
m = int(inp[0])
n = int(inp[1])

result = []

for column in range(1, math.ceil(m/2) + 1):

    rowRange = range(1, n + 1)
    if column == math.ceil(m / 2) and m % 2 == 1:
        rowRange = range(1, math.ceil(n/2) + 1)

    for row in rowRange:
        result.append(str(column) + ' ' + str(row))
        if row == math.ceil(n/2) and n % 2 == 1 and column == math.ceil(m / 2) and m % 2 == 1:
            continue
        result.append(str(m + 1 - column) + ' ' + str(n + 1 - row))

print('\n'.join(result))
",5,1179_B,CODEFORCES,3595,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
ANS=[]

for i in range(1,n//2+1):
    for j in range(1,m+1):
        sys.stdout.write((str(i)+"" ""+str(j)+""\n""))
        sys.stdout.write((str(n-i+1)+"" ""+str(m-j+1)+""\n""))


if n%2==1:
    for j in range(1,m//2+1):
        sys.stdout.write((str(n//2+1)+"" ""+str(j)+""\n""))
        sys.stdout.write((str(n//2+1)+"" ""+str(m-j+1)+""\n""))

    if m%2==1:
        sys.stdout.write((str(n//2+1)+"" ""+str(m//2+1)+""\n""))

",5,1179_B,CODEFORCES,3589,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import sys
import math
from collections import defaultdict
n,m=map(int,sys.stdin.readline().split())
#cur=[1,1]
#ans=[-1 for _ in range(2*n*m)]
up,down=1,n
count=0
while up<=down:
    left,right=1,m
    #ans.append(cur)
    while left<=m and count<n*m:
        #ans.append([up,left])
        #ans[count]=[up,left]
        if count<n*m:
            sys.stdout.write((str(up)+"" ""+str(left)+""\n""))
        count+=1
        left+=1
        #ans[count]=[down,right]
        if count<n*m:
            sys.stdout.write((str(down)+"" ""+str(right)+""\n""))
        count+=1
            #ans.append([down,right])
        right-=1
    up+=1
    down-=1
'''if n==1:
    a=len(ans)
    #print(a,'a')
    for i in range(a//2):
        print(ans[i][0],ans[i][1])
else:
    a=len(ans)
    for i in range(a//2):
        print(ans[i][0],ans[i][1])
    #print(ans)'''
        
",5,1179_B,CODEFORCES,3599,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import sys
input=sys.stdin.buffer.readline
n,m=map(int,input().split())
for i in range(n//2+n%2):
    x1=i+1
    x2=n-i
    if(x1==x2):
        for j in range(m//2+m%2):
            if(j+1==m-j):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
            else:
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
    else:
        if(i%2==0):
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
        else:
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(m-j)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(j+1)+""\n""))",5,1179_B,CODEFORCES,3603,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"def main():
    n, m = map(int, input().split())

    r = []
    rappend = r.append
    for i in range(1, (n >> 1) + 1):
        for j in range(1, m + 1):
            rappend(str(i) + ' ' + str(j))
            rappend(str(n + 1 - i) + ' ' + str(m + 1 - j))

    if n & 1:
        for i in range(1, (m >> 1) + 1):
            rappend(str((n + 1) >> 1) + ' ' + str(i))
            rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i))
        if m & 1:
            rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1))

    print('\n'.join(r))


main()
",5,1179_B,CODEFORCES,3590,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import sys
N, M = map(int, input().split())

Ans = [(0, 0) for  _ in range(N*M)]
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = ' '.join((str(a+1), str(b+1)))

for a in Ans:
    sys.stdout.write(f'{a}\n') 
",5,1179_B,CODEFORCES,3591,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import sys
N, M = map(int, input().split())

Ans = [(0, 0) for  _ in range(N*M)]
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = (a+1, b+1)
for a in Ans:
    sys.stdout.write('{} {}\n'.format(*a))",5,1179_B,CODEFORCES,3592,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"n, m = map(int, input().split())

np1 = n + 1
mp1 = m + 1

for i in range(1, 1 + n // 2):
  for j in range(1, mp1):
    # print(i, j)
    # print(np1 - i, mp1 - j)
    print('%d %d\n%d %d' % (i,j,np1-i,mp1-j))

if n & 1:
  i = 1 + n // 2
  for j in range(1, 1 + m // 2):
    # print(i, j)
    # print(i, mp1 - j)
    print('%d %d\n%d %d' % (i,j,i,mp1-j))

  if m & 1:
    print(i, 1 + m // 2)
",5,1179_B,CODEFORCES,3598,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"from sys import stdin, stdout

n,m = [int(x) for x in stdin.readline().split()]

if n == 2:
    c = 1
    way = []
    mult = 1
    for x in range(m-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(1, x)
    for x in way[::-1]:
        print(2,x)
        
elif n == 1:
    c = 1
    way = []
    mult = 1
    for x in range(m-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(1, x)

elif m == 2:
    c = 1
    way = []
    mult = 1
    for x in range(n-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(x,1)
    for x in way[:-1:-1]:
        print(x,2)

elif m == 1:
    c = 1
    way = []
    mult = 1
    for x in range(n-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(x,1)
else:
    outStr = ''
    for x in range(n//2):
        for y in range(1,m+1):
            stdout.write(str(x+1) + ' ' + str(y)+'\n')
            stdout.write(str(n-x) + ' ' + str(m+1-y)+'\n')
    if n%2 == 1:
        c = 1
        way = []
        mult = 1
        for x in range(m-1,-1,-1):
            way.append(c)
            c += x*mult
            mult *= -1
        for x in way:
            stdout.write(str(n//2+1)+' ' + str(x)+'\n')




        
",5,1179_B,CODEFORCES,3601,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
ANS=[]

for i in range(1,n//2+1):
    for j in range(1,m+1):
        sys.stdout.write("""".join((str(i),"" "",str(j),""\n"")))
        sys.stdout.write("""".join((str(n-i+1),"" "",str(m-j+1),""\n"")))



if n%2==1:
    for j in range(1,m//2+1):
        sys.stdout.write("""".join((str(n//2+1),"" "",str(j),""\n"")))
        sys.stdout.write("""".join((str(n//2+1),"" "",str(m-j+1),""\n"")))

    if m%2==1:
        sys.stdout.write("""".join((str(n//2+1),"" "",str(m//2+1),""\n"")))

",5,1179_B,CODEFORCES,3588,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import sys,atexit
from io import BytesIO
inp = BytesIO(sys.stdin.buffer.read())
input = lambda:inp.readline().decode('ascii')
buf = BytesIO()
sys.stdout.write = lambda s: buf.write(s.encode('ascii'))
atexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))

n,m = map(int,input().split())
if m%2 == 0:
    steps = []
    for j in range(m//2):
        for i in range(n):
            steps.append((j,i))
            steps.append((m-j-1,n-i-1))
else:
    steps = []
    for j in range(m//2):
        for i in range(n):
            steps.append((j,i))
            steps.append((m-j-1,n-i-1))
    l = 0
    r = n-1
    mid = m//2
    while l<=r:
        steps.append((mid,l))
        if l != r:
            steps.append((mid,r))
        l += 1
        r -= 1

for x,y in steps:
    print(y+1,x+1)

#vis = set()
#for i in range(1,len(steps)):
#    dx,dy = steps[i][0]-steps[i-1][0],steps[i][1]-steps[i-1][1]
#    assert((dx,dy) not in vis)
#    vis.add((dx,dy))

#print(steps)
#C = [list('.'*m) for _ in range(n)]
#for i,e in enumerate(steps):
#    x,y = e
#    C[y][x] = chr(65+i)
#for c in C:
#    print(''.join(c))
",5,1179_B,CODEFORCES,3587,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase

def main():
    n,m=map(int,input().split())
    s,e,ans=[1,1],[n,m],[]
    for i in range(n*m//2):
        ans.append(s[:])
        ans.append(e[:])
        s[1],e[1]=s[1]+1,e[1]-1
        if s[1]==m+1:
            s=[s[0]+1,1]
        if not e[1]:
            e=[e[0]-1,m]
    if (n*m)&1:
        ans.append([s[0],s[1]])
    for i in ans:
        print(*i)

     


# FASTIO REGION

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",5,1179_B,CODEFORCES,3585,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import sys
n,m=map(int,input().split())
for i in range(n//2):
    for j in range(m):
        sys.stdout.write('{} {}\n'.format(*[i+1,j+1]))
        sys.stdout.write('{} {}\n'.format(*[n-i,m-j]))
if n%2:
    for j in range(m//2):
        sys.stdout.write('{} {}\n'.format(*[n//2+1,j+1]))
        sys.stdout.write('{} {}\n'.format(*[n//2+1,m-j]))
    if m%2:
        sys.stdout.write('{} {}\n'.format(*[n//2+1,m//2+1]))",5,1179_B,CODEFORCES,3583,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"from sys import stdout
N,M=map(int,input().split())
if M%2==0 and N%2==0:
    for m in range (1,M//2+1): 
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
elif M%2==0 and N%2==1:
    for m in range (1,M//2+1): 
        for i in range (1,N+1):
            stdout.write(str(i)+' '+str(m)+'\n')
            stdout.write(str(N+1-i)+' '+str(M+1-m)+'\n')
else:
    for m in range (1,(M+1)//2): 
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
    if N%2==0:
        for i in range (1,N//2+1):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
    else:
        for i in range (1,(N+1)//2):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
        stdout.write(str((N+1)//2)+' '+str((M+1)//2)+'\n')",5,1179_B,CODEFORCES,3594,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"#------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
#-------------------game starts now----------------------------------------------------
n,m=map(int,input().split())
s=0
e=n-1
for i in range(n//2):
    for j in range(m):
        print(s+1,j+1)
        print(e+1,m-j)
    s+=1
    e-=1
if n%2==1:
    s=n//2
    for j in range(m//2):
            print(s+1,j+1)
            print(s+1,m-j)
    if m%2==1:
            print(s+1,m//2+1)",5,1179_B,CODEFORCES,3600,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import sys
N, M = map(int, input().split())

Ans = [None]*(N*M)
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = (a+1, b+1)
for a in Ans:
    sys.stdout.write('{} {}\n'.format(*a))",5,1179_B,CODEFORCES,3593,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"def main():
    n, m = map(int,raw_input().split())
    r = []
    rappend = r.append
    for i in range(1, (n >> 1) + 1):
        for j in range(1, m + 1):
            rappend(str(i) + ' ' + str(j))
            rappend(str(n + 1 - i) + ' ' + str(m + 1 - j))
    if n & 1:
        for i in range(1, (m >> 1) + 1):
            rappend(str((n + 1) >> 1) + ' ' + str(i))
            rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i))
        if m & 1:
            rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1))
    print('\n'.join(r))
main()",5,1179_B,CODEFORCES,3597,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"
n, m = map(int, input().split())
buf = []
for i in range(n//2):
    for j in range(m):
        buf.append(f'{i + 1} {j + 1}\n')
        buf.append(f'{n - i} {m - j}\n')

if n % 2 == 1:
    for j in range(m // 2):
        buf.append(f'{n // 2 + 1} {j + 1}\n')
        buf.append(f'{n // 2 + 1} {m - j}\n')
    if m % 2 == 1:
        buf.append(f'{n//2 + 1} {m//2 + 1}\n')
print(*buf, sep='')",5,1179_B,CODEFORCES,3596,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"(x, y) = list(map(int, input().split(' ')))

a = 0
b = x * y
pos = True

for t in reversed(range(b)):
    b -= 1
    print(str(int(a / y + 1)) + ' '+ str(int(a % y + 1)))
    a += b * (1 if pos else -1)
    pos = not pos  

   			 								 		 			  	    	",5,1179_B,CODEFORCES,3584,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import sys
input=sys.stdin.readline
n,m=map(int,input().split())
for i in range(n//2+n%2):
    x1=i+1
    x2=n-i
    if(x1==x2):
        for j in range(m//2+m%2):
            if(j+1==m-j):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
            else:
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
    else:
        if(i%2==0):
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
        else:
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(m-j)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(j+1)+""\n""))",5,1179_B,CODEFORCES,3602,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"# ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# ------------------- fast io --------------------
def main():
    n,m=map(int,input().split())
    ans=[];moves=n*m;
    c1=[1,1];c2=[n,m];p=0
    while moves>0:
        if p%2==0:
            ans.append(tuple(c1))
            c1[1]+=1
            if c1[1]>m:
                c1[0]+=1;c1[1]=1
        else:
            ans.append(tuple(c2))
            c2[1]-=1
            if c2[1]<1:
                c2[0]-=1;c2[1]=m
        moves-=1;p+=1
    for i in ans:
        print(*i)
main()",5,1179_B,CODEFORCES,3582,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"import os
import sys
from io import BytesIO, IOBase
import math
from collections import defaultdict, deque
import random

# to output - sys.stdout.write('{} {}\n'.format(*a))
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# n, k = map(int, input().split("" ""))
# l = list(map(int, input().split("" "")))

n, k = map(int, input().split("" ""))
ans = []
for i in range(1, n*k + 1):
    if i%2:
        x,y = divmod(i//2, k)
        ans.append([x+1, y+1])
    else:
        x,y = divmod(n*k-i//2, k)
        ans.append([x + 1, y + 1])
for i in ans:
    sys.stdout.write('{} {}\n'.format(*i))",5,1179_B,CODEFORCES,3581,Tolik and His Uncle,"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a ""Discuss tasks"" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.
After a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.
In this task you are given a cell field $$$n \cdot m$$$, consisting of $$$n$$$ rows and $$$m$$$ columns, where point's coordinates $$$(x, y)$$$ mean it is situated in the $$$x$$$-th row and $$$y$$$-th column, considering numeration from one ($$$1 \leq x \leq n, 1 \leq y \leq m$$$). Initially, you stand in the cell $$$(1, 1)$$$. Every move you can jump from cell $$$(x, y)$$$, which you stand in, by any non-zero vector $$$(dx, dy)$$$, thus you will stand in the $$$(x+dx, y+dy)$$$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).
Tolik's uncle is a very respectful person. Help him to solve this task!
The first and only line contains two positive integers $$$n, m$$$ ($$$1 \leq n \cdot m \leq 10^{6}$$$) — the number of rows and columns of the field respectively.
Print ""-1"" (without quotes) if it is impossible to visit every cell exactly once.
Else print $$$n \cdot m$$$ pairs of integers, $$$i$$$-th from them should contain two integers $$$x_i, y_i$$$ ($$$1 \leq x_i \leq n, 1 \leq y_i \leq m$$$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.
","input
Notice that the first cell should have $$$(1, 1)$$$ coordinates, according to the statement.
output
The vectors from the first example in the order of making jumps are $$$(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$$$.
",constructivealgorithms
"n=int(input())
arr=list(map(int,input().split()))
arr.sort()
ans=0
mark=0
for i in range(len(arr)-2):
	if(arr[i]==arr[i+1]==arr[i+2]):
		print('cslnb')
		exit(0)
	elif(arr[i+1]==arr[i+2] and arr[i]+1==arr[i+1]):
		print('cslnb')
		exit(0)

countcopy=0
for i in range(len(arr)-1):
	if(arr[i]==arr[i+1] and arr[i]==0):
		print('cslnb')
		exit(0)
	if(arr[i]==arr[i+1]):
		countcopy+=1
if(countcopy>1):
	print('cslnb')
	exit(0)

for i in range(len(arr)):
	if(arr[i]>=mark):
		ans+=(arr[i]-mark)
		mark+=1

#print(ans)
if(ans%2==0):
	print('cslnb')
else:
	print('sjfnb')

",4,1191_D,CODEFORCES,2988,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"def solve(n, a):
    a = sorted(a)
    if n == 1:
        return a[0] > 0 and a[0] % 2 == 1
    same_count = 0
    for i in range(n - 1):
        if a[i] == a[i + 1] == 0:
            return False
        if i < n - 2 and a[i] + 1 == a[i + 1] == a[i + 2]:
            return False
        if a[i] == a[i + 1]:
            same_count += 1
    if same_count > 1:
        return False
    return (sum(a) - n * (n - 1) // 2) % 2 == 1



assert not solve(1, [0])
assert not solve(2, [1, 0])
assert solve(2, [2, 2])
assert solve(3, [2, 3, 1])
assert not solve(4, [1, 1, 2, 2])
assert solve(4, [1, 1, 2, 3])
assert not solve(4, [1, 2, 3, 4])
assert solve(4, [0, 1, 2, 4])
assert solve(5, [0, 1, 2, 3, 5])

n = int(input())
a = map(int, input().split())

r = solve(n, a)
if r:

    print('sjfnb')
else:
    print('cslnb')
",4,1191_D,CODEFORCES,2997,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"import sys
n = int(input())
a = [int(i) for i in input().split()]
a.sort()
t = 0
for i in range(1,n):
	t += a[i]==a[i-1]
if t >= 2:
	print(""cslnb"")
	sys.exit(0)
if t:
	for i in range(n):
		if a[i]==a[i+1]:
			if a[i] and a[i]!=a[i-1]+1:
				a[i] -= 1
				break
			else:
				print(""cslnb"")
				sys.exit(0)
print([""cslnb"",""sjfnb""][(sum(a)-t-n*(n-1)//2)&1])
	 	     		  	 	  			 	  		  			",4,1191_D,CODEFORCES,2998,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"N = int(input())
A = [int(i) for i in input().split()]
A.sort()
duplicates = 0
i=1
temp = 1
ind = -1
while i<N:
    temp = 1
    while i<N and A[i] == A[i-1]:
        ind = i-1
        temp +=1
        i+=1
    i+=1

    if temp != 1: duplicates +=1
    if temp > 2 :
        break

turns =  sum(A) - N*(N-1)//2

if temp>2 or duplicates>1: print('cslnb')

else:
    output = 'cslnb'
    if duplicates == 0:
        if turns%2 == 1: output = 'sjfnb'
    else:
        if ind-1 >= 0:
            if A[ind-1] == A[ind]-1:
                output = 'cslnb'
            else:
                if turns%2 == 1: output = 'sjfnb'
        else:
            if A[ind] == 0:
                output = 'cslnb'
            else:
                if turns%2 == 1: output = 'sjfnb'
    print(output)
            



    

    
",4,1191_D,CODEFORCES,2989,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"from sys import exit
n = int(input())
arr = [int(x) for x in input().split()]
tmp = 0
for i in range(len(arr)):
    tmp += (arr[i] - i)
arr.sort()
c = 0
for i in range(1, n):
    if arr[i] == arr[i - 1]:
        c += 1
    if i != 1 and arr[i] == arr[i - 1] and arr[i - 1] == arr[i - 2] + 1:
        print(""cslnb"")
        exit()
if c > 1 or (len(arr) >= 2 and arr[0] == arr[1] == 0):
    print(""cslnb"")
    exit()
print(""cslnb"" if tmp % 2 == 0 else ""sjfnb"")",4,1191_D,CODEFORCES,2991,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"def gns():
    return  list(map(int,input().split()))
n=int(input())
ns=gns()
a='cslnb'
b='sjfnb'
ns.sort()
ans=[]
for i in range(1,n):
    if ns[i]==ns[i-1]:
        ans.append(i)
if len(ans)>=2 or sum(ns)==0:
    print(a)
    quit()
if len(ans)==1:
    i=ans[0]
    if ns[i]==0 or ns[i]-1 in ns:
        print(a)
        quit()
    r=sum(ns)-n*(n-1)//2
    if r%2==0:
        print(a)
        quit()
    else:
        print(b)
        quit()
else:
    r=sum(ns)-n*(n-1)//2
    if r%2==0:
        print(a)
        quit()
    else:
        print(b)

",4,1191_D,CODEFORCES,2985,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n=int(input())
a=[int(x) for x in input().split()]
pro=n*(n-1)//2
dic={}
for item in a:
    if item not in dic:
        dic[item]=1
    else:
        dic[item]+=1
counter=0
for item in dic:
    if 0 in dic and dic[0]>=2:
        print('cslnb')
        break
    if dic[item]>2:
        print('cslnb')
        break
    elif dic[item]==2:
        if counter==1 or item-1 in dic:
            print('cslnb')
            break
        else:
            counter=1
else:
    if (sum(a)-pro)%2==1:
        print('sjfnb')
    else:
        print('cslnb')
",3,1191_D,CODEFORCES,2215,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"from sys import stdin, stdout, exit

n = int(input())
a = list(map(int, stdin.readline().split()))

def z(winner):
    return 'sjfnb' if winner == 0 else 'cslnb'

a.sort()
dups = set(a)
if len(dups) < len(a) - 1:
    print(z(1))
    exit()

winner = 0
for i in range(n-1):
    if a[i] == a[i+1]:
        if a[i] == 0 or a[i]-1 in a:
            print(z(1))
            exit()
        winner = 1
        a[i] = a[i] - 1

s = sum(a)
final = n*(n-1) // 2
winner += (s - final) + 1
winner %= 2
print(z(winner))
",4,1191_D,CODEFORCES,2984,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"from sys import stdin, stdout
import math
N = int(input())

#N,M,K = [int(x) for x in stdin.readline().split()]

arr = [int(x) for x in stdin.readline().split()]

if sum(arr)==0:
    print('cslnb')
    quit()
    
arr.sort()
zeros = 0
freq = {}
dup = 0
res = 0

for i in range(N):
    num = arr[i]
    if num==0:
        zeros += 1
        if zeros==2:
            print('cslnb')
            quit()
            
    if num not in freq:
        freq[num] = 1
    else:
        dup += 1
        freq[num] += 1

    if dup==2:
        print('cslnb')
        quit()
    


for i in range(N):
    num = arr[i]
    if freq[num]==2:
        if (num-1) not in freq:
            freq[num-1] = 1
            freq[num] = 1
            arr[i] = arr[i] - 1
            res += 1
            break
        else:
            print('cslnb')
            quit()


#print(arr)
minus = [0]*N

level = 0
for i in range(N):
    minus[i] = min(arr[i],level)
    if arr[i]>=level:
        level += 1
        
for i in range(N):
    res += arr[i] - minus[i]
 
if res%2==0:
    print('cslnb')
else:
    print('sjfnb')





        
    
        ",4,1191_D,CODEFORCES,2986,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())
a = [int(i) for i in input().split()]
a.sort()
flag = 0
for i in range(n-1):
	if(a[i] == a[i+1]):
		if(flag == 1):
			flag = 2
			break
		flag = 1
		index = i
		if(i+2<n and a[i+1] == a[i+2]):
			flag = 2
			break
		elif(i>0 and a[i-1] == a[i]-1):
			flag = 2
			break
if(flag == 2):
	print(""cslnb"")
elif(flag ==1 and a[index] ==0):
	print(""cslnb"")
else:
	moves=0
	for i in range(n):
		if(a[i] == i):
			continue
		elif(a[i]<i):
			continue
		else:
			moves += (a[i] - i)
	if(moves%2 == 0):
		print(""cslnb"")
	else:
		print(""sjfnb"")",4,1191_D,CODEFORCES,2990,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n=int(input())
arr=list(map(int,input().split()))
dic={}
for val in arr:
  if val not in dic:
    dic[val]=1
  else:
    dic[val]+=1
flag1=True
if 0 in dic:
  if dic[0]>=2:
    flag1=False
cnt=0
for val in dic.keys():
  if dic[val]>=3:
    flag1=False
    break
  if dic[val]==2:
    cnt+=1
    if val-1 in dic:
      flag1=False
      break
if cnt>=2:
  flag1=False
if flag1==False:
  print('cslnb')
else:
  flag2=(n*(n-1)//2+sum(arr))%2
  if flag2==1:
    print('sjfnb')
  else:
    print('cslnb')",3,1191_D,CODEFORCES,2217,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"def solve(n, arr):
	s = sum(arr)
	if s == 0:
		return ""cslnb""

	n_num = {}

	for item in arr:
		if item in n_num:
			n_num[item] += 1
		else:
			n_num[item] = 1

	if 0 in n_num and n_num[0] >= 2:
		return 'cslnb'

	for key in n_num.keys():
		if n_num[key] >= 3:
			return ""cslnb""

	ind_pairs = []
	for key in n_num.keys():
		if n_num[key] == 2:
			ind_pairs.append(key)

	if len(ind_pairs) >= 2:
		return ""cslnb""
	elif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num:
		return ""cslnb""
	else:
		# print('s', s)
		sum_targ = n*(n-1) // 2
		# print('sum_targ', sum_targ)
		dif_sum = s - sum_targ
		# print(""dif_sum"", dif_sum)
		if dif_sum % 2 == 0:
			return ""cslnb""
		else:
			return ""sjfnb""


n = int(input())

arr = list(map(int, input().split()))
print(solve(n, arr))

",3,1191_D,CODEFORCES,2221,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())
lst = [int(i) for i in input().split()]
st = set()
flag = False
count = 0
for i in lst:
    if i not in st:
        st.add(i)
    else:
        flag = True
        count+=1
        lol = i
sum1 = n*(n-1)//2
if count>1:
    print('cslnb')
    quit()
if not flag:    
    if (sum(lst)- sum1)% 2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
else:
    if (lol-1) in lst or lol == 0:
        print('cslnb')
    else:
        if (sum(lst)- sum1)% 2 == 0:
            print('cslnb')
        else:
            print('sjfnb')
",3,1191_D,CODEFORCES,2218,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())
ai = list(map(int,input().split()))
ai.sort()
num = 0
num2 = 0
for i in range(1,n):
    if ai[i-1] == ai[i]:
        num += 1
        num2 = i
if num == 0:
    num3 = sum(ai)
    num4 = n * (n-1) // 2
    ans = (num3 - num4) % 2
    if ans == 1:
        print(""sjfnb"")
    else:
        print(""cslnb"")
elif num == 1:
    if (num2 > 1 and ai[num2-2] == ai[num2] - 1) or ai[num2] == 0:
        print(""cslnb"")
    else:
        num3 = sum(ai)
        num4 = n * (n-1) // 2
        ans = (num3 - num4) % 2
        if ans == 1:
            print(""sjfnb"")
        else:
            print(""cslnb"")
else:
    print(""cslnb"")
",4,1191_D,CODEFORCES,2980,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())
a = list(map(int, input().split()))
d = {}
for ai in a:
	if ai in d:
		d[ai] += 1
	else:
		d[ai] = 1
if max(d.values()) >= 3 or 0 in d and d[0] >= 2 or list(d.values()).count(2) >= 2:
	print('cslnb')
	exit()
for i in d:
	if d[i] == 2 and i - 1 in d:
		print('cslnb')
		exit()
s = sum(a)
if s >= n * (n - 1) // 2:
	if (s - n * (n - 1) // 2) % 2 == 0:
		print('cslnb')
	else:
		print('sjfnb')
else:
	pass

",3,1191_D,CODEFORCES,2216,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())

a = list(map(lambda i: int(i), input().split(sep=' ')))
a.sort()
a_count = len(a)

b = list(filter(lambda i: i > 0, a))
b_count = len(b)

def resh():
    idx = 1
    while idx < a_count:
        if a[idx] == a[idx - 1] and (a[idx] - 1) in a:
            return 'cslnb'
        idx += 1

    b_sum = sum(b)
    v_sum = sum(range(1, b_count if a_count == b_count else b_count + 1))
    t = max(b_sum - v_sum, 0)
    return 'cslnb' if t % 2 == 0 else 'sjfnb'


if b_count == 0 or  b_count - len(set(b)) > 1 or a_count - b_count > 1:
    print('cslnb')
else:
    print(resh())



",4,1191_D,CODEFORCES,2992,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"def main():
    n = int(input())
    piles = list(map(int,input().split()))
    piles.sort()
    num = piles[0]
    count = 1
    two = 0
    two_num = 0
    for i in range(1,n):
        if piles[i] == num:
            count += 1
        else:
            #print(count,'hhere')
            if count > 2:
                print('cslnb')
                return
            elif count == 2:
                two_num = num
                two += 1
            num = piles[i]
            count = 1

    if count == 2:
        two_num = num
        two += 1
    if count > 2:
        print('cslnb')
        return
    if two > 1:
        print('cslnb')
        return
    
    #print(two)
    if two == 1:
        if (two_num-1) in piles:
            print('cslnb')
            return

    if n >= 2:
        if piles[0] == piles[1] and piles[0] == 0:
            print('cslnb')
            return
    moves = 0
    curr = 0
    for i in range(n):
        if piles[i] >= curr:
            moves += piles[i]-curr
            piles[i] = curr
            curr += 1

    for i in piles:
        if i > 0:
            moves += 1
            break

    #print(moves)
    if n == 1:
        moves += 1
    if moves%2 != 0:
        print('cslnb')
    else:
        print('sjfnb')
        

main()
",4,1191_D,CODEFORCES,2994,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())
a = sorted(list(map(int,input().split())))
bal = 0
if a.count(0)>1:
    print('cslnb')
    exit()
if n-len(set(a))>1:
    print('cslnb')
    exit()
if n-len(set(a))==1:
    for i in range(1,n):
        if a[i]==a[i-1]:
            if a[i]-1 in a:
                print('cslnb')
                exit()
            break
if n==1:
    print('cslnb' if not a[0] % 2 else 'sjfnb')
    exit()

for i in range(n):
    bal+=a[i]-i
print('sjfnb'if bal%2 else 'cslnb')",4,1191_D,CODEFORCES,2996,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())
l = list(map(int, input().split()))
ansl = ['sjfnb', 'cslnb']
ans = -1
d = dict()
val = 0
if n == 1:
    ans = (l[0] + 1) % 2
else:
    l.sort()
    for elem in l:
        d[elem] = d.get(elem, 0) + 1
    hm = 0
    which = -1
    i = 0
    for elem in d.values():
        if elem >= 2:
            hm += 1
            which = i
        i += 1
    which = list(d.keys())[which]
    if max(d.values()) >= 3 or d.get(0, 0) >= 2 or hm > 1:
        ans = 1
    elif hm == 1 and d.get(which - 1, 0) > 0:
        ans = 1
    else:
        for i in range(n):
            val += l[i] - i
        ans = (val + 1) % 2
print(ansl[ans])",4,1191_D,CODEFORCES,2983,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())

a = sorted(map(int, input().split()))

if not any(a):
    print('cslnb')
elif n > 2 and a[0] == a[1] == 0:
    print('cslnb')
else:
    seq_cnt = 0
    seq_sz = 1
    max_seq_sz = 1
    for i in range(n-1):
        if a[i] == a[i+1]:
            seq_sz += 1
        elif a[i] + 1 == a[i+1] and i + 2 < n and a[i+1] == a[i+2]:
            max_seq_sz = 3
            break
        else:
            max_seq_sz = max(seq_sz, max_seq_sz)
            seq_cnt += seq_sz > 1
            seq_sz = 1

    max_seq_sz = max(seq_sz, max_seq_sz)
    seq_cnt += seq_sz > 1

    if max_seq_sz > 2 or seq_cnt > 1:
        print('cslnb')
    else:
        last = to_play = 0
        for i in range(n):
            to_play += a[i] - last
            last += 1

        if to_play % 2 == 0:
            print('cslnb')
        else:
            print('sjfnb')
",4,1191_D,CODEFORCES,2981,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())
a = list(map(int, input().split()))
summ=0
a.sort()
if len(a)==1:
    if a[0]%2==1:
        print('sjfnb')
    else:
        print('cslnb')
elif a[0] == a[1]==0:
    print('cslnb')
else:
    x = False
    for i in range(2, n):
        if a[i]==a[i-1] and a[i-1]==a[i-2]:
            x=True
    if x:
        print('cslnb')    
    else:
        x = False
        for i in range(2, n):
            if a[i]==a[i-1] and a[i]-1==a[i-2]:
                x=True
        if x:
            print('cslnb')
        else:
            summ=0
            for i in range(1, n):
                if a[i]==a[i-1]:
                    summ+=1
            if summ>1:
                print('cslnb')
            else:
                summ=0
                for i in range(n):
                    summ+=a[i]-i
                if summ%2==0:
                    print('cslnb')
                else:
                    print('sjfnb')
        ",4,1191_D,CODEFORCES,2987,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())
arr = list(map(int,input().split()))
arr.sort()
if n>=2 and  arr[0]==arr[1]==0:
	print(""cslnb"")
else:
	flag=0
	for i in range(n-2):
		if arr[i]==arr[i+1]==arr[i+2]:
			flag=1
			break
	if flag==1:
		print(""cslnb"")
	else:
		flag=0
		ind=0
		for i in range(n-1):
			if arr[i]==arr[i+1]:
				ind = i
				flag+=1
		if flag==1 and ind>0 and arr[ind-1]==arr[ind]-1:
			print(""cslnb"")

		elif flag>=2:
			print(""cslnb"")
		else:
			safe = 0
			for i in range(n):
				#print(safe)
				if arr[i]-i>=0:
					safe+=arr[i]-i
			#print(safe)
			if safe%2==0:
				print(""cslnb"")
			else:
				print(""sjfnb"")",4,1191_D,CODEFORCES,2995,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())

arr = list(map(int, input().split()))

solved = False
s = sum(arr)
if s == 0:
	print(""cslnb"")
	solved = True

if not solved:
	n_num = {}

	for item in arr:
		if item in n_num:
			n_num[item] += 1
		else:
			n_num[item] = 1

	if 0 in n_num and n_num[0] >= 2:
		print('cslnb')
		solved = True

	if not solved:
		for key in n_num.keys():
			if n_num[key] >= 3:
				print(""cslnb"")
				solved = True

		ind_pairs = []
		if not solved:
			for key in n_num.keys():
				if n_num[key] == 2:
					ind_pairs.append(key)

			if len(ind_pairs) >= 2:
				print(""cslnb"")
				solved = True
			elif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num:
				print(""cslnb"")
				solved = True
			else:
				# print('s', s)
				sum_targ = n*(n-1) // 2
				# print('sum_targ', sum_targ)
				dif_sum = s - sum_targ
				# print(""dif_sum"", dif_sum)
				if dif_sum % 2 == 0:
					print(""cslnb"")
				else:
					print(""sjfnb"")",3,1191_D,CODEFORCES,2219,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"n = int(input())
a = [int(i) for i in input().split()]

total = sum(a)
final = n * (n-1) // 2
repeated = []
count = {}

for i in a:
    try:
        count[i] += 1
        repeated.append(i)
    except KeyError:
        count[i] = 1


# for i, num in enumerate(a):
#     if i in a[:i]:
#         repeated.append(i)

moves = total - final

if len(repeated) > 1:
    print('cslnb')

elif 0 in repeated:
    print('cslnb')

elif len(repeated) == 1 and repeated[0] - 1 in a:
    print('cslnb')

else:
    if moves % 2 == 0 or moves <= 0:
        print('cslnb')
    else:
        print('sjfnb')
",3,1191_D,CODEFORCES,2220,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"from sys import stdin
n=int(stdin.readline().strip())
s=list(map(int,stdin.readline().strip().split()))
s.sort()
f=False
z=s.count(0)
p=0
for i in range(2,n):
    if s[i]==s[i-1] and s[i-1]==s[i-2]:
        f=True
for i in range(1,n):
    if s[i]==s[i-1]:
        p+=1
        if i-2>=0 and s[i-2]==s[i-1]-1:
            f=True
y=sum(s)
t=(n)*(n-1)//2
r=y-t
if r%2==0 or f or y==0 or z>=2 or p>=2:
    print(""cslnb"")
else:
    print(""sjfnb"")
",4,1191_D,CODEFORCES,2993,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)

def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))
import math


def main():
    # something
    n = getN()
    nums = getList()
    nums.sort()
    margins = [num - i for i, num in enumerate(nums)]
    for m in margins:
        if m < 0:
            print(""cslnb"")
            return
    flag = False
    if len(nums) > 1:
        if nums[0] == nums[1]:
                flag = True
    for a, b, c in zip(nums, nums[1:], nums[2:]):
        if b == c:
            if a == b or b - a == 1:
                print(""cslnb"")
                return
            if flag:
                print(""cslnb"")
                return
            flag = True


    # if nums[0] == 0 and nums[1] == 0:
    #     print(""cslnb"")
    #     return
    # print(""duel"")
    margin = sum(margins)
    # print(margin)
    # print(nums)
    if margin % 2 == 1:
        print(""sjfnb"")
    else:
        print(""cslnb"")


if __name__ == ""__main__"":
    main()

",4,1191_D,CODEFORCES,2982,"Tokitsukaze, CSL and Stone Game","Tokitsukaze and CSL are playing a little game of stones.
In the beginning, there are $$$n$$$ piles of stones, the $$$i$$$-th pile of which has $$$a_i$$$ stones. The two players take turns making moves. Tokitsukaze moves first. On each turn the player chooses a nonempty pile and removes exactly one stone from the pile. A player loses if all of the piles are empty before his turn, or if after removing the stone, two piles (possibly empty) contain the same number of stones. Supposing that both players play optimally, who will win the game?
Consider an example: $$$n=3$$$ and sizes of piles are $$$a_1=2$$$, $$$a_2=3$$$, $$$a_3=0$$$. It is impossible to choose the empty pile, so Tokitsukaze has two choices: the first and the second piles. If she chooses the first pile then the state will be $$$[1, 3, 0]$$$ and it is a good move. But if she chooses the second pile then the state will be $$$[2, 2, 0]$$$ and she immediately loses. So the only good move for her is to choose the first pile. 
Supposing that both players always take their best moves and never make mistakes, who will win the game?
Note that even if there are two piles with the same number of stones at the beginning, Tokitsukaze may still be able to make a valid first move. It is only necessary that there are no two piles with the same number of stones after she moves.
The first line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of piles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \le a_1, a_2, \ldots, a_n \le 10^9$$$), which mean the $$$i$$$-th pile has $$$a_i$$$ stones.
Print ""sjfnb"" (without quotes) if Tokitsukaze will win, or ""cslnb"" (without quotes) if CSL will win. Note the output characters are case-sensitive.
In the first example, Tokitsukaze cannot take any stone, so CSL will win.
In the second example, Tokitsukaze can only take a stone from the first pile, and then, even though they have no stone, these two piles will have the same number of stones, which implies CSL will win.
","input
In the third example, Tokitsukaze will win. Here is one of the optimal ways:
output
In the fourth example, they only have one good choice at any time, so Tokitsukaze can make the game lasting as long as possible and finally win.
","games, greedy"
"from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

n,m = map(int,input().split())

G = MinCostFlow(n+2)
coef = [0 for i in range(n)]
edge = []
for _ in range(m):
    x,y,b = map(int,input().split())
    G.add_edge(y,x,10**18,-1)
    coef[x-1] += b
    coef[y-1] -= b
    edge.append((x,y))

s = 0
for i in range(n):
    if coef[i]<0:
        G.add_edge(0,i+1,-coef[i],0)
        s -= coef[i]
    elif coef[i]>0:
        G.add_edge(i+1,n+1,coef[i],0)

#G.add_edge(0,n+1,10**18,0)

f = G.flow(0,n+1,s)
#print(-f)

Edge = [[] for i in range(n)]
use = [False]*m
uf = UnionFindVerSize(n)
for i in range(m):
    u,v = edge[i]
    for e in G.G[u]:
        to = e[0]
        if to==v and e[1]:
            Edge[v-1].append((u-1,1))
            Edge[u-1].append((v-1,-1))
            use[i] = True
            uf.unite(u-1,v-1)


edge = [(edge[i][0],edge[i][1]) for i in range(m) if not use[i]]
for u,v in edge:
    if not uf.is_same_group(u-1,v-1):
        Edge[v-1].append((u-1,1))
        Edge[u-1].append((v-1,-1))
        uf.unite(u-1,v-1)

used_1 = [False]*n
used_2 = [False]*n
lazy = [0 for i in range(n)]
a = [0 for i in range(n)]
def dfs(v,pv):
    lazy[v] = min(lazy[v],a[v])
    for nv,c in Edge[v]:
        if not used_1[nv]:
            used_1[nv] = True
            a[nv] = a[v] + c
            dfs(nv,v)
            lazy[v] = min(lazy[v],lazy[nv])

def add(v,pv,ff):
    a[v] += ff
    for nv,c in Edge[v]:
        if not used_2[nv]:
            used_2[nv] = True
            add(nv,v,ff)

for i in range(n):
    if not used_1[i]:
        used_1[i] = True
        dfs(i,-1)
        used_2[i] = True
        add(i,-1,-lazy[i]+1)
        #print(used_1)
        #print(lazy)

print(*a)
",7,1430_G,CODEFORCES,4701,Yet Another DAG Problem,"You are given a directed acyclic graph (a directed graph that does not contain cycles) of $$$n$$$ vertices and $$$m$$$ arcs. The $$$i$$$-th arc leads from the vertex $$$x_i$$$ to the vertex $$$y_i$$$ and has the weight $$$w_i$$$.
Your task is to select an integer $$$a_v$$$ for each vertex $$$v$$$, and then write a number $$$b_i$$$ on each arcs $$$i$$$ such that $$$b_i = a_{x_i} - a_{y_i}$$$. You must select the numbers so that:
It can be shown that for any directed acyclic graph with non-negative $$$w_i$$$, such a way to choose numbers exists.
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \le n \le 18$$$; $$$0 \le m \le \dfrac{n(n - 1)}{2}$$$).
Then $$$m$$$ lines follow, the $$$i$$$-th of them contains three integers $$$x_i$$$, $$$y_i$$$ and $$$w_i$$$ ($$$1 \le x_i, y_i \le n$$$, $$$1 \le w_i \le 10^5$$$, $$$x_i \ne y_i$$$) — the description of the $$$i$$$-th arc.
","input
It is guaranteed that the lines describe $$$m$$$ arcs of a directed acyclic graph without multiple arcs between the same pair of vertices.
output
Print $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$0 \le a_v \le 10^9$$$), which must be written on the vertices so that all $$$b_i$$$ are positive, and the value of the expression $$$\sum \limits_{i = 1}^{m} w_i b_i$$$ is the lowest possible. If there are several answers, print any of them. It can be shown that the answer always exists, and at least one of the optimal answers satisfies the constraints $$$0 \le a_v \le 10^9$$$.
","bitmasks, dfsandsimilar, dp, flows, graphs, math"
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)
order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])
if len(order) == 0:    print(0); exit()
if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1;    need = -1;    last = []    
    for v in l:
        if v in powers:            continue        
        v2 = v;        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):  extra = v;     last = primesn;    need = len(last);   assert need >= 2    
    if need == -1 or 2 * need + 1 > k:  print(0);   exit()    
    other = [];    out = [extra]    
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:   works = True;           break
        if works:       out.append(a);   out.append(b)
        else:       other.append(a);      other.append(b)
    assert len(out) == 2 * need + 1;    assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)];    assert len(ret) == k; print(' '.join(map(str,ret)));    exit()
out = [];need = k
for i in range(len(order)):
    assert need != 1;lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1): out += lis; need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2: out += lis[:-1];  need -= (len(lis) - 1);   assert need == 2
    else: out += lis[:need]; need = 0        
assert need + len(out) == k;assert need >= 0;assert need == 0 or len(out) == count
for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1        
if need == 0:    print(' '.join(map(str,out)));    exit()
else:    print(0)",7,1468_L,CODEFORCES,4721,Prime Divisors Selection,"Suppose you have a sequence of $$$k$$$ integers $$$A = [a_1, a_2, \dots , a_k]$$$ where each $$$a_i \geq 2$$$. A sequence of prime integers $$$P = [p_1, p_2, \dots, p_k]$$$ is called suitable for the sequence $$$A$$$ if $$$a_1$$$ is divisible by $$$p_1$$$, $$$a_2$$$ is divisible by $$$p_2$$$ and so on. 
A sequence of prime integers $$$P$$$ is called friendly if there are no unique integers in this sequence. 
A sequence $$$A$$$ is called ideal, if each sequence $$$P$$$ that is suitable for $$$A$$$ is friendly as well (i. e. there is no sequence $$$P$$$ that is suitable for $$$A$$$, but not friendly). For example, the sequence $$$[2, 4, 16]$$$ is ideal, while the sequence $$$[2, 4, 6]$$$ is not ideal (there exists a sequence $$$P = [2, 2, 3]$$$ which is suitable for $$$A$$$, but not friendly).
You are given $$$n$$$ different integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$. You have to choose exactly $$$k$$$ of them in such a way that they form an ideal sequence, or report that it is impossible. Note that no integer can be chosen more than once.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq k \leq n \leq 1000$$$). 
The second line contains $$$n$$$ pairwise distinct integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ ($$$2 \leq x_i \leq 10^{18}$$$).
","input
If it is impossible to choose exactly $$$k$$$ integers from $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ in such a way that the chosen integers form an ideal sequence, print $$$0$$$.
output
Otherwise, print $$$k$$$ pairwise distinct integers — the elements of the chosen ideal sequence. If there are multiple answers, print any of them.
","binarysearch, greedy, math, numbertheory"
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)
        
n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []
    
    for v in l:
        if v in powers:
            continue
        
        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2
    
    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()
    
    other = []
    out = [extra]
    
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k
    
    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1
    
    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0
        
assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1
    
    

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",7,1468_L,CODEFORCES,4718,Prime Divisors Selection,"Suppose you have a sequence of $$$k$$$ integers $$$A = [a_1, a_2, \dots , a_k]$$$ where each $$$a_i \geq 2$$$. A sequence of prime integers $$$P = [p_1, p_2, \dots, p_k]$$$ is called suitable for the sequence $$$A$$$ if $$$a_1$$$ is divisible by $$$p_1$$$, $$$a_2$$$ is divisible by $$$p_2$$$ and so on. 
A sequence of prime integers $$$P$$$ is called friendly if there are no unique integers in this sequence. 
A sequence $$$A$$$ is called ideal, if each sequence $$$P$$$ that is suitable for $$$A$$$ is friendly as well (i. e. there is no sequence $$$P$$$ that is suitable for $$$A$$$, but not friendly). For example, the sequence $$$[2, 4, 16]$$$ is ideal, while the sequence $$$[2, 4, 6]$$$ is not ideal (there exists a sequence $$$P = [2, 2, 3]$$$ which is suitable for $$$A$$$, but not friendly).
You are given $$$n$$$ different integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$. You have to choose exactly $$$k$$$ of them in such a way that they form an ideal sequence, or report that it is impossible. Note that no integer can be chosen more than once.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq k \leq n \leq 1000$$$). 
The second line contains $$$n$$$ pairwise distinct integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ ($$$2 \leq x_i \leq 10^{18}$$$).
","input
If it is impossible to choose exactly $$$k$$$ integers from $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ in such a way that the chosen integers form an ideal sequence, print $$$0$$$.
output
Otherwise, print $$$k$$$ pairwise distinct integers — the elements of the chosen ideal sequence. If there are multiple answers, print any of them.
","binarysearch, greedy, math, numbertheory"
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)
order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])
if len(order) == 0:    print(0); exit()
if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1;    need = -1;    last = []    
    for v in l:
        if v in powers:            continue        
        v2 = v;        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):  extra = v;     last = primesn;    need = len(last);   assert need >= 2    
    if need == -1 or 2 * need + 1 > k:  print(0);   exit()    
    other = [];    out = [extra]    
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:   works = True;           break
        if works:       out.append(a);   out.append(b)
        else:       other.append(a);      other.append(b)
    assert len(out) == 2 * need + 1;    assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)];    assert len(ret) == k; print(' '.join(map(str,ret)));    exit()
out = [];need = k
for i in range(len(order)):
    assert need != 1
    
    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0
        
assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1
    
    

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",7,1468_L,CODEFORCES,4720,Prime Divisors Selection,"Suppose you have a sequence of $$$k$$$ integers $$$A = [a_1, a_2, \dots , a_k]$$$ where each $$$a_i \geq 2$$$. A sequence of prime integers $$$P = [p_1, p_2, \dots, p_k]$$$ is called suitable for the sequence $$$A$$$ if $$$a_1$$$ is divisible by $$$p_1$$$, $$$a_2$$$ is divisible by $$$p_2$$$ and so on. 
A sequence of prime integers $$$P$$$ is called friendly if there are no unique integers in this sequence. 
A sequence $$$A$$$ is called ideal, if each sequence $$$P$$$ that is suitable for $$$A$$$ is friendly as well (i. e. there is no sequence $$$P$$$ that is suitable for $$$A$$$, but not friendly). For example, the sequence $$$[2, 4, 16]$$$ is ideal, while the sequence $$$[2, 4, 6]$$$ is not ideal (there exists a sequence $$$P = [2, 2, 3]$$$ which is suitable for $$$A$$$, but not friendly).
You are given $$$n$$$ different integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$. You have to choose exactly $$$k$$$ of them in such a way that they form an ideal sequence, or report that it is impossible. Note that no integer can be chosen more than once.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq k \leq n \leq 1000$$$). 
The second line contains $$$n$$$ pairwise distinct integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ ($$$2 \leq x_i \leq 10^{18}$$$).
","input
If it is impossible to choose exactly $$$k$$$ integers from $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ in such a way that the chosen integers form an ideal sequence, print $$$0$$$.
output
Otherwise, print $$$k$$$ pairwise distinct integers — the elements of the chosen ideal sequence. If there are multiple answers, print any of them.
","binarysearch, greedy, math, numbertheory"
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)

order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])

if len(order) == 0:    print(0); exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []
    
    for v in l:
        if v in powers:
            continue
        
        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2
    
    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()
    
    other = []
    out = [extra]
    
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k
    
    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1
    
    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0
        
assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1
    
    

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",7,1468_L,CODEFORCES,4719,Prime Divisors Selection,"Suppose you have a sequence of $$$k$$$ integers $$$A = [a_1, a_2, \dots , a_k]$$$ where each $$$a_i \geq 2$$$. A sequence of prime integers $$$P = [p_1, p_2, \dots, p_k]$$$ is called suitable for the sequence $$$A$$$ if $$$a_1$$$ is divisible by $$$p_1$$$, $$$a_2$$$ is divisible by $$$p_2$$$ and so on. 
A sequence of prime integers $$$P$$$ is called friendly if there are no unique integers in this sequence. 
A sequence $$$A$$$ is called ideal, if each sequence $$$P$$$ that is suitable for $$$A$$$ is friendly as well (i. e. there is no sequence $$$P$$$ that is suitable for $$$A$$$, but not friendly). For example, the sequence $$$[2, 4, 16]$$$ is ideal, while the sequence $$$[2, 4, 6]$$$ is not ideal (there exists a sequence $$$P = [2, 2, 3]$$$ which is suitable for $$$A$$$, but not friendly).
You are given $$$n$$$ different integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$. You have to choose exactly $$$k$$$ of them in such a way that they form an ideal sequence, or report that it is impossible. Note that no integer can be chosen more than once.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq k \leq n \leq 1000$$$). 
The second line contains $$$n$$$ pairwise distinct integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ ($$$2 \leq x_i \leq 10^{18}$$$).
","input
If it is impossible to choose exactly $$$k$$$ integers from $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ in such a way that the chosen integers form an ideal sequence, print $$$0$$$.
output
Otherwise, print $$$k$$$ pairwise distinct integers — the elements of the chosen ideal sequence. If there are multiple answers, print any of them.
","binarysearch, greedy, math, numbertheory"
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)
        
n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []
    
    for v in l:
        if v in powers:
            continue
        
        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2
    
    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()
    
    other = []
    out = [extra]
    
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k
    
    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1
    
    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0
        
assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:
        break

    
    if v in powers:
        continue
    
    v2 = v
    for p in pgood:
        while v2 % p == 0:
            v2 //= p
    if v2 == 1:
        out.append(v)
        need -= 1
    
    

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)
",7,1468_L,CODEFORCES,4717,Prime Divisors Selection,"Suppose you have a sequence of $$$k$$$ integers $$$A = [a_1, a_2, \dots , a_k]$$$ where each $$$a_i \geq 2$$$. A sequence of prime integers $$$P = [p_1, p_2, \dots, p_k]$$$ is called suitable for the sequence $$$A$$$ if $$$a_1$$$ is divisible by $$$p_1$$$, $$$a_2$$$ is divisible by $$$p_2$$$ and so on. 
A sequence of prime integers $$$P$$$ is called friendly if there are no unique integers in this sequence. 
A sequence $$$A$$$ is called ideal, if each sequence $$$P$$$ that is suitable for $$$A$$$ is friendly as well (i. e. there is no sequence $$$P$$$ that is suitable for $$$A$$$, but not friendly). For example, the sequence $$$[2, 4, 16]$$$ is ideal, while the sequence $$$[2, 4, 6]$$$ is not ideal (there exists a sequence $$$P = [2, 2, 3]$$$ which is suitable for $$$A$$$, but not friendly).
You are given $$$n$$$ different integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$. You have to choose exactly $$$k$$$ of them in such a way that they form an ideal sequence, or report that it is impossible. Note that no integer can be chosen more than once.
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \leq k \leq n \leq 1000$$$). 
The second line contains $$$n$$$ pairwise distinct integers $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ ($$$2 \leq x_i \leq 10^{18}$$$).
","input
If it is impossible to choose exactly $$$k$$$ integers from $$$x_1$$$, $$$x_2$$$, ..., $$$x_n$$$ in such a way that the chosen integers form an ideal sequence, print $$$0$$$.
output
Otherwise, print $$$k$$$ pairwise distinct integers — the elements of the chosen ideal sequence. If there are multiple answers, print any of them.
","binarysearch, greedy, math, numbertheory"
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
#            effect[j][i] = min(effect[j][i],inf*inf+inf*inf)


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",7,1550_E,CODEFORCES,4765,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"import sys;input = sys.stdin.readline;n, k = map(int, input().split());s = input()[:-1];left, right = 0, n
while left < right:
    mid = right - (right - left) // 2;A = [[0] * (n + 2) for _ in range(k)]
    for c in range(k):
        A[c][n] = A[c][n + 1] = n + 1;L = 0
        for i in range(n - 1, -1, -1):L = (L + 1 if s[i] == '?' or ord(s[i]) - ord('a') == c else 0);A[c][i] = i + mid if L >= mid else A[c][i + 1]
    dp = [n + 1] * (1 << k);dp[0] = 0
    for mask in range(1 << k):
        for i in range(k):
            if mask >> k & 1: continue
            t = mask | 1 << i;dp[t] = min(dp[t], A[i][dp[mask]])
    if dp[-1] <= n: left = mid
    else: right = mid - 1
print(left)",7,1550_E,CODEFORCES,4766,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"N, K = list(map(int, input().split()))
S = input().strip()
S = [-1 if _ == '?' else ord(_) - ord('a') for _ in S]

def check(x):
    p = [[N for i in range(N+1)] for k in range(K)]

    for k in range(K):
        keep = 0
        for i in range(N-1, -1, -1):
            keep += 1
            if S[i] != -1 and S[i] != k:
                keep = 0
            p[k][i] = p[k][i+1]
            if keep >= x:
                p[k][i] = i + x - 1

    d = [N for s in range(1<<K)]
    d [0] = -1
    for s in range(1, 1<<K):
        for k in range(K):
            if (s&(1<<k)) and (d[s^(1<<k)]<N):
                d[s] = min(d[s], p[k][d[s^(1<<k)]+1])
                # print('d[%d%d]=%d'%(s//2, s%2, d[s]))
    return d[(1<<K)-1] < N
    
l, r = 0, N//K

while l < r:
    mid = (l + r + 1) // 2
    if check(mid):
        l = mid
    else:
        r = mid - 1
print(l)
",7,1550_E,CODEFORCES,4768,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf)


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",7,1550_E,CODEFORCES,4762,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"import sys
input = lambda: sys.stdin.readline().rstrip()

N, K = map(int, input().split())
S = [-1 if a == ""?"" else ord(a) - 97 for a in input()]
II = {1 << i: i for i in range(20)}
def calc(mmm):
    inf = 300000
    X = [[0] * N for _ in range(K)]
    for k in range(K):
        Xk = X[k]
        mi = inf
        r = 0
        for i in range(N)[::-1]:
            if S[i] < 0 or S[i] == k:
                r += 1
            else:
                r = 0
            if r >= mmm:
                mi = min(mi, i + mmm)
            Xk[i] = mi

    Y = [0] * (1 << K)
    for i in range(1, 1 << K):
        mi = inf
        for j in range(K):
            if i >> j & 1:
                ii = i ^ (1 << j)
                if Y[ii] < N:
                    mi = min(mi, X[j][Y[ii]])
        Y[i] = mi
    return 1 if Y[-1] < inf else 0
    
l, r = 0, N // K + 1
while r - l > 1:
    m = l + r >> 1
    if calc(m):
        l = m
    else:
        r = m
print(l)

",7,1550_E,CODEFORCES,4757,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
maxconseq = [[0 for j in range(k)] for i in range(n+1)]
for i in range(n):
    if s[i]==ord('?'):
        for j in range(k):
            maxconseq[i][j] = maxconseq[i-1][j] + 1
    else:
        j = s[i]-97
        maxconseq[i][j] = maxconseq[i-1][j] + 1
 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 
    
    for j in range(k):
        for i in range(n)[::-1]:
            if maxconseq[i][j]>=needed:
                effect[j][i-needed+1] = i+1
            effect[j][i] = min(effect[j][i], effect[j][i+1])


   
                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",7,1550_E,CODEFORCES,4759,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"import sys

# sys.setrecursionlimit(200005)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def LI1(): return list(map(int1, sys.stdin.readline().split()))
def LLI1(rows_number): return [LI1() for _ in range(rows_number)]
def SI(): return sys.stdin.readline().rstrip()
inf = 10**16
md = 10**9+7
# md = 998244353

n, k = LI()
s = [-1 if c == ""?"" else ord(c)-97 for c in SI()]

def ok(m):
    nxt = [[n]*(n+1) for _ in range(k)]
    for j in range(k):
        cnt = 0
        ni = n
        nxtj = nxt[j]
        for i in range(n)[::-1]:
            if s[i] == -1 or s[i] == j: cnt += 1
            else: cnt = 0
            if cnt >= m: ni = i
            nxtj[i] = ni
    dp = [n+1]*(1 << k)
    dp[0] = 0
    for bit in range(1 << k):
        l = dp[bit]
        if l+m > n: continue
        for j in range(k):
            if bit >> j & 1: continue
            i = nxt[j][l]
            if i+m <= n:
                nbit = bit | 1 << j
                dp[nbit] = min(dp[nbit], i+m)
    return dp[-1] <= n

l, r = 0, n//k+1
while l+1 < r:
    m = (l+r)//2
    if ok(m): l = m
    else: r = m

print(l)
",7,1550_E,CODEFORCES,4767,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"import sys
input = sys.stdin.readline

n, k = map(int, input().split())
s = input()[:-1]
left, right = 0, n
while left < right:
    mid = right - (right - left) // 2
    A = [[0] * (n + 2) for _ in range(k)]

    for c in range(k):
        A[c][n] = A[c][n + 1] = n + 1
        L = 0
        for i in range(n - 1, -1, -1):
            if s[i] == '?' or ord(s[i]) - ord('a') == c: L += 1
            else: L = 0
            A[c][i] = i + mid if L >= mid else A[c][i + 1]

    dp = [n + 1] * (1 << k)
    dp[0] = 0
    for mask in range(1 << k):
        for i in range(k):
            if mask >> k & 1: continue
            t = mask | 1 << i
            dp[t] = min(dp[t], A[i][dp[mask]])
    if dp[-1] <= n: left = mid
    else: right = mid - 1
print(left)",7,1550_E,CODEFORCES,4758,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"
def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        self.size = n
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        if r==self.size:
            r = self.num

        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

N,K = mi()
S = input()
S = [ord(S[i])-ord(""a"") for i in range(N)]

pow_2 = [pow(2,i) for i in range(K)]
k = K


def cond(n):
    cnt = [0 for i in range(k)]
    v = 0
    for i in range(n):
        if not  0<= S[i] < k:
            continue
        if cnt[S[i]]==0:
            v += 1
        cnt[S[i]] += 1

    str_range = [[N for j in range(N)] for i in range(k)]
    if v==1:
        for i in range(k):
            if cnt[i]:
                str_range[i][0] = 0
    elif v==0:
        for i in range(k):
            str_range[i][0] = 0

    for i in range(n,N):
        if 0 <= S[i-n] < k:
            cnt[S[i-n]] -= 1
            if cnt[S[i-n]] == 0:
                v -= 1
        if 0 <= S[i] < k:
            cnt[S[i]] += 1
            if cnt[S[i]] == 1:
                v += 1

        if v==1:
            for j in range(k):
                if cnt[j]:
                    for l in range(i-n+1,-1,-1):
                        if str_range[j][l] == N:
                            str_range[j][l] = i - n + 1
                        else:
                            break
                    break
        elif v==0:
            for j in range(k):
                for l in range(i-n+1,-1,-1):
                    if str_range[j][l] == N:
                        str_range[j][l] = i - n + 1
                    else:
                        break

    INF = N + 1
    dp = [INF for bit in range(1<<k)]
    dp[0] = 0

    for bit in range(1<<k):
        if dp[bit]>=N:
            continue
        idx = dp[bit]
        for i in range(k):
            if not bit >> i & 1:
                nv = bit|pow_2[i]
                tmp = str_range[i][idx] + n
                dp[nv] = min(dp[nv],tmp)

    return dp[-1]!=INF

ok = 0
ng = N+1
while ng-ok>1:
    mid = (ok+ng)//2
    if cond(mid):
        ok = mid
    else:
        ng = mid

print(ok)
",7,1550_E,CODEFORCES,4756,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
#            print(j,i,accu)            
            effect[j][i] = index


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",7,1550_E,CODEFORCES,4760,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i],inf)


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",7,1550_E,CODEFORCES,4764,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf*inf)


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",7,1550_E,CODEFORCES,4763,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = effect[j][i+4-4]


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",7,1550_E,CODEFORCES,4761,Stringforces,"You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.
Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.
The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.
What is the maximum value the string can have?
The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le k \le 17$$$) — the length of the string and the number of first Latin letters used.
The second line contains a string $$$s$$$, consisting of $$$n$$$ characters. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.
Print a single integer — the maximum value of the string after every question mark is replaced with one of the first $$$k$$$ lowercase Latin letters.
In the first example the question marks can be replaced in the following way: ""aaaababbbb"". $$$f_1 = 4$$$, $$$f_2 = 4$$$, thus the answer is $$$4$$$. Replacing it like this is also possible: ""aaaabbbbbb"". That way $$$f_1 = 4$$$, $$$f_2 = 6$$$, however, the minimum of them is still $$$4$$$.
","input
In the second example one of the possible strings is ""aabbccdda"".
output
In the third example at least one letter won't appear in the string, thus, the minimum of values $$$f_i$$$ is always $$$0$$$.
","binarysearch, bitmasks, bruteforce, dp, strings, twopointers"
