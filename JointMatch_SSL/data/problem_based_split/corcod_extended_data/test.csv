content,label,from,problem,index
"import java.io.*;
import java.util.*;

public class CF1082D {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		int[] aa = new int[n];
		int[] i1 = new int[n];
		int[] i2 = new int[n];
		int n1 = 0, n2 = 0, m2 = 0;
		for (int i = 0; i < n; i++) {
			int a = Integer.parseInt(st.nextToken());
			aa[i] = a;
			if (a == 1)
				i1[n1++] = i;
			else {
				i2[n2++] = i;
				m2 += a;
			}
		}
		if (m2 < (n2 - 1) * 2 + n1) {
			System.out.println(""NO"");
			return;
		}
		int m = n2 - 1 + n1;
		int d = n2 - 1 + Math.min(n1, 2);
		PrintWriter pw = new PrintWriter(System.out);
		pw.println(""YES "" + d);
		pw.println(m);
		for (int i = 0; i + 1 < n2; i++) {
			pw.println((i2[i] + 1) + "" "" + (i2[i + 1] + 1));
			aa[i2[i]]--; aa[i2[i + 1]]--;
		}
		if (n1 > 0) {
			while (n2 > 0 && aa[i2[n2 - 1]] == 0)
				n2--;
			pw.println((i2[n2 - 1] + 1) + "" "" + (i1[n1 - 1] + 1));
			aa[i2[n2 - 1]]--;
			n1--;
		}
		for (int i = 0, j = 0; j < n1; j++) {
			while (aa[i2[i]] == 0)
				i++;
			pw.println((i2[i] + 1) + "" "" + (i1[j] + 1));
			aa[i2[i]]--;
		}
		pw.close();
	}
}
",,CorCod,11,11
"
// Java program to find smallest and second smallest elements 
import
java.io.*; 

class
SecondSmallest 
{ 

/* Function to print first smallest and second smallest 

elements */

static
void
print2Smallest(
int
arr[]) 

{ 

int
first, second, arr_size = arr.length; 


/* There should be atleast two elements */

if
(arr_size < 
2
) 

{ 

System.out.println(
"" Invalid Input ""
); 

return
; 

} 


first = second = Integer.MAX_VALUE; 

for
(
int
i = 
0
; i < arr_size ; i ++) 

{ 

/* If current element is smaller than first 

then update both first and second */

if
(arr[i] < first) 

{ 

second = first; 

first = arr[i]; 

} 


/* If arr[i] is in between first and second 

then update second */

else
if
(arr[i] < second && arr[i] != first) 

second = arr[i]; 

} 

if
(second == Integer.MAX_VALUE) 

System.out.println(
""There is no second""
+ 

""smallest element""
); 

else

System.out.println(
""The smallest element is ""
+ 

first + 
"" and second Smallest""
+ 

"" element is ""
+ second); 

} 


/* Driver program to test above functions */

public
static
void
main (String[] args) 

{ 

int
arr[] = {
12
, 
13
, 
1
, 
10
, 
34
, 
1
}; 

print2Smallest(arr); 

} 
} 
/*This code is contributed by Devesh Agrawal*/",,CorCod,16,16
"import java.util.*;
 
public class Main{
    private static final int MAX_SIZE = 100005;
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int a = sc.nextInt();
        int b = sc.nextInt();
        if(((m + 1) / 60 < a) || ((m + 1) / 60 == a && (m + 1) % 60 <= b)) {
            out(0, 0);
            System.exit(0);
        }
        for(int i = 2; i <= n; i++) {
            int x = sc.nextInt();
            int y = sc.nextInt();

            int bb = b + 2 * m + 2;
            int aa = a + bb / 60;
            bb %= 60;

            if((aa < x) || (aa == x && bb <= y)) {
                b = b + m + 1;
                a = a + b / 60;
                b %= 60;
                out(a, b);
                System.exit(0);
            }
            a = x;
            b = y;
        }
        b = b + m + 1;
        a = a + b / 60;
        b = b % 60;        
        out(a, b);
    }

    private static void out(int a, int b) {
        cout(a);
        cout("" "");
        cout(b);
    }

    private static void cout(Object a) {
        System.out.print(a);
    }
}",,CorCod,17,17
"
// Java program to create complete Binary Tree from its Linked List 
// representation 

// importing necessary classes 
import
java.util.*; 

// A linked list node 
class
ListNode 
{ 

int
data; 

ListNode next; 

ListNode(
int
d) 

{ 

data = d; 

next = 
null
; 

} 
} 

// A binary tree node 
class
BinaryTreeNode 
{ 

int
data; 

BinaryTreeNode left, right = 
null
; 

BinaryTreeNode(
int
data) 

{ 

this
.data = data; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

ListNode head; 

BinaryTreeNode root; 


// Function to insert a node at the beginning of 

// the Linked List 

void
push(
int
new_data) 

{ 

// allocate node and assign data 

ListNode new_node = 
new
ListNode(new_data); 


// link the old list off the new node 

new_node.next = head; 


// move the head to point to the new node 

head = new_node; 

} 


// converts a given linked list representing a 

// complete binary tree into the linked 

// representation of binary tree. 

BinaryTreeNode convertList2Binary(BinaryTreeNode node) 

{ 

// queue to store the parent nodes 

Queue<BinaryTreeNode> q = 

new
LinkedList<BinaryTreeNode>(); 


// Base Case 

if
(head == 
null
) 

{ 

node = 
null
; 

return
null
; 

} 


// 1.) The first node is always the root node, and 

// add it to the queue 

node = 
new
BinaryTreeNode(head.data); 

q.add(node); 


// advance the pointer to the next node 

head = head.next; 


// until the end of linked list is reached, do the 

// following steps 

while
(head != 
null
) 

{ 

// 2.a) take the parent node from the q and 

// remove it from q 

BinaryTreeNode parent = q.peek(); 

BinaryTreeNode pp = q.poll(); 


// 2.c) take next two nodes from the linked list. 

// We will add them as children of the current 

// parent node in step 2.b. Push them into the 

// queue so that they will be parents to the 

// future nodes 

BinaryTreeNode leftChild = 
null
, rightChild = 
null
; 

leftChild = 
new
BinaryTreeNode(head.data); 

q.add(leftChild); 

head = head.next; 

if
(head != 
null
) 

{ 

rightChild = 
new
BinaryTreeNode(head.data); 

q.add(rightChild); 

head = head.next; 

} 


// 2.b) assign the left and right children of 

// parent 

parent.left = leftChild; 

parent.right = rightChild; 

} 


return
node; 

} 


// Utility function to traverse the binary tree 

// after conversion 

void
inorderTraversal(BinaryTreeNode node) 

{ 

if
(node != 
null
) 

{ 

inorderTraversal(node.left); 

System.out.print(node.data + 
"" ""
); 

inorderTraversal(node.right); 

} 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.push(
36
); 
/* Last node of Linked List */

tree.push(
30
); 

tree.push(
25
); 

tree.push(
15
); 

tree.push(
12
); 

tree.push(
10
); 
/* First node of Linked List */

BinaryTreeNode node = tree.convertList2Binary(tree.root); 


System.out.println(
""Inorder Traversal of the""
+ 

"" constructed Binary Tree is:""
); 

tree.inorderTraversal(node); 

} 
} 
// This code has been contributed by Mayank Jaiswal ",,CorCod,36,36
"import java.util.*;
public class Main{
	public static void main(String args[]){
		Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int k=sc.nextInt();
        if(n==k){
            String s=new String();
            for(int i=0;i<k;i++){
                s=s+""1"";
            }
            System.out.println(s);
        }
        else{
            int a=(n-k)/2;
            String s=new String();
            while(s.length()<n){
                for(int i=0;i<a && s.length()<n;i++){
                    s=s+""1"";
                }
                if(s.length()<n){
                    s=s+""0"";
                }
            }
            System.out.println(s);
        }
	}
}",,CorCod,48,48
"import java.io.*;
import java.util.*;

public class CF1009E {
	static final int MD = 998244353;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		int[] aa = new int[1 + n];
		for (int i = 1, a = 0; i <= n; i++)
			aa[i] = a = (a + Integer.parseInt(st.nextToken())) % MD;
		int[] pp = new int[n];
		pp[0] = 1;
		for (int i = 1, p = 1; i < n; i++) {
			pp[i] = p;
			p = p * 2 % MD;
		}
		int d = 0;
		long ans = 0;
		for (int i = n - 1; i >= 0; i--) {	// rest at i
			d = (d * 2 % MD + aa[n - 1 - i]) % MD;	// rest again before n
			ans = (ans + (long) (d + aa[n - i]) * pp[i]) % MD;
		}
		System.out.println(ans);
	}
}
",,CorCod,55,55
"
// Java Program to find all the common characters 
// in n strings 
import
java.util.*; 
import
java.lang.*; 

class
GFG { 


static
int
MAX_CHAR = 
26
; 


public
static
void
commonCharacters(String str[], 

int
n) 

{ 


// primary array for common characters 

// we assume all characters are seen before. 

Boolean[] prim = 
new
Boolean[MAX_CHAR]; 

Arrays.fill(prim, 
new
Boolean(
true
)); 


// for each string 

for
(
int
i = 
0
; i < n; i++) { 


// secondary array for common characters 

// Initially marked false 

Boolean[] sec = 
new
Boolean[MAX_CHAR]; 

Arrays.fill(sec, 
new
Boolean(
false
)); 


// for every character of ith string 

for
(
int
j = 
0
; j < str[i].length(); j++) 

{ 


// if character is present in all 

// strings before, mark it. 

if
(prim[str[i].charAt(j) - 
'a'
]) 

sec[str[i].charAt(j) - 
'a'
] = 
true
; 

} 


// copy whole secondary array into primary 

System.arraycopy(sec, 
0
, prim, 
0
, MAX_CHAR); 

} 


// displaying common characters 

for
(
int
i = 
0
; i < 
26
; i++) 

if
(prim[i]){ 

System.out.print(Character.toChars(i 

+ 
97
)); 

System.out.print(
"" ""
); 

} 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

String str[] = { 
""geeksforgeeks""
, 

""gemkstones""
, 

""acknowledges""
, 

""aguelikes""
}; 


int
n = str.length; 

commonCharacters(str, n); 

} 
} 

// This code is contributed by Prasad Kshirsagar ",,CorCod,68,68
"
// Java program to find nth ugly number 
import
java.lang.Math; 

class
UglyNumber 
{ 

/* Function to get the nth ugly number*/

int
getNthUglyNo(
int
n) 

{ 

int
ugly[] = 
new
int
[n]; 
// To store ugly numbers 

int
i2 = 
0
, i3 = 
0
, i5 = 
0
; 

int
next_multiple_of_2 = 
2
; 

int
next_multiple_of_3 = 
3
; 

int
next_multiple_of_5 = 
5
; 

int
next_ugly_no = 
1
; 


ugly[
0
] = 
1
; 


for
(
int
i = 
1
; i < n; i++) 

{ 

next_ugly_no = Math.min(next_multiple_of_2, 

Math.min(next_multiple_of_3, 

next_multiple_of_5)); 


ugly[i] = next_ugly_no; 

if
(next_ugly_no == next_multiple_of_2) 

{ 

i2 = i2+
1
; 

next_multiple_of_2 = ugly[i2]*
2
; 

} 

if
(next_ugly_no == next_multiple_of_3) 

{ 

i3 = i3+
1
; 

next_multiple_of_3 = ugly[i3]*
3
; 

} 

if
(next_ugly_no == next_multiple_of_5) 

{ 

i5 = i5+
1
; 

next_multiple_of_5 = ugly[i5]*
5
; 

} 

} 
/*End of for loop (i=1; i<n; i++) */

return
next_ugly_no; 

} 


/* Driver program to test above functions */

public
static
void
main(String args[]) 

{ 

int
n = 
150
; 

UglyNumber obj = 
new
UglyNumber(); 

System.out.println(obj.getNthUglyNo(n)); 

} 
} 

// This code has been contributed by Amit Khandelwal (Amit Khandelwal 1) ",,CorCod,69,69
"
// Java program to make GCD 
// of array a mutiple of k. 
import
java.io.*; 

class
GFG 
{ 
static
int
MinOperation(
int
a[], 

int
n, 
int
k) 
{ 


int
result = 
0
; 


for
(
int
i = 
0
; i < n; ++i) 

{ 


// If array value is not 1 

// and it is greater than k 

// then we can increase the 

// or decrease the remainder 

// obtained by dividing k 

// from the ith value of array 

// so that we get the number 

// which is either closer to k 

// or its multiple 

if
(a[i] != 
1
&& a[i] > k) 

{ 

result = result + 

Math.min(a[i] % k, 

k - a[i] % k); 

} 

else

{ 


// Else we only have one 

// choice which is to 

// increment the value 

// to make equal to k 

result = result + k - a[i]; 

} 

} 


return
result; 
} 

// Driver code 
public
static
void
main (String[] args) 
{ 

int
arr[] = {
4
, 
5
, 
6
}; 

int
n = arr.length; 

int
k = 
5
; 

System.out.println(MinOperation(arr, n, k)); 
} 
} 

// This code is contributed 
// by akt_mit ",,CorCod,79,79
"import java.util.*;
import java.io.*;

public class _1036_B_DiagonalWalkingV2 {

	public static void main(String[] args) throws IOException {
		int Q = readInt();
		while(Q-- > 0) {
			long n = readLong(), m = readLong(), k = readLong();
			if(Math.max(n, m) > k) println(-1);
			else {
				long ans = k;
				if(n%2 != k%2) ans--;
				if(m%2 != k%2) ans--;
				println(ans);
			}
		}
		exit();
	}

	final private static int BUFFER_SIZE = 1 << 16;
	private static DataInputStream din = new DataInputStream(System.in);
	private static byte[] buffer = new byte[BUFFER_SIZE];
	private static int bufferPointer = 0, bytesRead = 0;
	static PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

	public static String readLine() throws IOException {
		byte[] buf = new byte[64]; // line length
		int cnt = 0, c;
		while ((c = Read()) != -1) {
			if (c == '\n')
				break;
			buf[cnt++] = (byte) c;
		}
		return new String(buf, 0, cnt);
	}

	public static String read() throws IOException {
		byte[] ret = new byte[1024];
		int idx = 0;
		byte c = Read();
		while (c <= ' ') {
			c = Read();
		}
		do {
			ret[idx++] = c;
			c = Read();
		} while (c != -1 && c != ' ' && c != '\n' && c != '\r');
		return new String(ret, 0, idx);
	}

	public static int readInt() throws IOException {
		int ret = 0;
		byte c = Read();
		while (c <= ' ')
			c = Read();
		boolean neg = (c == '-');
		if (neg)
			c = Read();
		do {
			ret = ret * 10 + c - '0';
		} while ((c = Read()) >= '0' && c <= '9');

		if (neg)
			return -ret;
		return ret;
	}

	public static long readLong() throws IOException {
		long ret = 0;
		byte c = Read();
		while (c <= ' ')
			c = Read();
		boolean neg = (c == '-');
		if (neg)
			c = Read();
		do {
			ret = ret * 10 + c - '0';
		} while ((c = Read()) >= '0' && c <= '9');
		if (neg)
			return -ret;
		return ret;
	}

	public static double readDouble() throws IOException {
		double ret = 0, div = 1;
		byte c = Read();
		while (c <= ' ')
			c = Read();
		boolean neg = (c == '-');
		if (neg)
			c = Read();

		do {
			ret = ret * 10 + c - '0';
		} while ((c = Read()) >= '0' && c <= '9');

		if (c == '.') {
			while ((c = Read()) >= '0' && c <= '9') {
				ret += (c - '0') / (div *= 10);
			}
		}

		if (neg)
			return -ret;
		return ret;
	}

	private static void fillBuffer() throws IOException {
		bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
		if (bytesRead == -1)
			buffer[0] = -1;
	}

	private static byte Read() throws IOException {
		if (bufferPointer == bytesRead)
			fillBuffer();
		return buffer[bufferPointer++];
	}

	static void print(Object o) {
		pr.print(o);
	}

	static void println(Object o) {
		pr.println(o);
	}

	static void flush() {
		pr.flush();
	}

	static void println() {
		pr.println();
	}

	static void exit() throws IOException {
		din.close();
		pr.close();
		System.exit(0);
	}
}
",,CorCod,94,94
"
import java.io.*;
import java.util.Scanner;
public class abc{
    public static int check(StringBuilder s)
    {
    	int countRemove=0;
    	if(!s.toString().contains(""xxx"")) return countRemove;
    	else{
    		
    		for(int i=1;i<s.length()-1;i++)
    		{
    			if(s.charAt(i-1)=='x' && s.charAt(i)=='x' && s.charAt(i+1)=='x')
    			{
    			
    				countRemove++;
    			}
    		}
    		return countRemove;
    	}
    }
   
	public static void main (String[] args) {
	
	Scanner sc = new Scanner(System.in);
	int n = sc.nextInt();
	//sc= new Scanner(System.in);
	String s = sc.next();
	StringBuilder sb = new StringBuilder("""");
	sb.append(s);
	
    System.out.println(check(sb));
	
	
	
	}
}",,CorCod,131,131
"import javax.print.DocFlavor;
import javax.swing.plaf.basic.BasicInternalFrameTitlePane;
import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.net.CookieHandler;
import java.nio.Buffer;
import java.nio.charset.IllegalCharsetNameException;
import java.sql.BatchUpdateException;
import java.util.*;
import java.util.stream.Stream;
import java.util.Vector;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import static java.lang.Math.*;
import java.util.*;
import java.nio.file.StandardOpenOption;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Iterator;
import java.util.PriorityQueue;

public class icpc
{
    public static void main(String[] args)throws IOException
    {
//        Reader in = new Reader();
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

        String s1[] = in.readLine().split("" "");
        int  n = Integer.parseInt(s1[0]);
        int p = Integer.parseInt(s1[1]);
        String s = in.readLine();
        StringBuilder stringBuilder = new StringBuilder(s);
        boolean flag = false;
        for(int i=0;i<n;i++)
        {
            if(i + p < n)
            {
                if(s.charAt(i) != '.' && s.charAt(i + p) != '.' && s.charAt(i) != s.charAt(i + p))
                {
                    flag = true;
                    break;
                }
                else if(s.charAt(i) == '.' && s.charAt(i + p) != '.')
                {
                    int x = s.charAt(i + p) - '0';
                    char ch = (char)((x + 1) % 2 + 48);
                    stringBuilder.setCharAt(i, ch);
                    flag = true;
                    break;
                }
                else if(s.charAt(i) != '.' && s.charAt(i + p) == '.')
                {
                    int x = s.charAt(i) - '0';
                    char ch = (char)((x + 1) % 2 + 48);
                    stringBuilder.setCharAt(i + p, ch);
                    flag = true;
                    break;
                }
                else if(s.charAt(i) == '.' && s.charAt(i + p) == '.')
                {
                    stringBuilder.setCharAt(i, '1');
                    stringBuilder.setCharAt(i + p, '0');
                    flag = true;
                    break;
                }
            }
        }
        if(flag)
        {
            for(int i=0;i<stringBuilder.length();i++)
            {
                if(stringBuilder.charAt(i) == '.')
                {
                    stringBuilder.setCharAt(i, '0');
                }
            }
            System.out.println(stringBuilder);
        }
        else
            System.out.println(""No"");


    }
}
class StringAlgorithms
{
    public int[] calculateZ(char input[]) {
        int Z[] = new int[input.length];
        int left = 0;
        int right = 0;
        for(int k = 1; k < input.length; k++) {
            if(k > right) {
                left = right = k;
                while(right < input.length && input[right] == input[right - left]) {
                    right++;
                }
                Z[k] = right - left;
                right--;
            } else {
                //we are operating inside box
                int k1 = k - left;
                //if value does not stretches till right bound then just copy it.
                if(Z[k1] < right - k + 1) {
                    Z[k] = Z[k1];
                } else { //otherwise try to see if there are more matches.
                    left = k;
                    while(right < input.length && input[right] == input[right - left]) {
                        right++;
                    }
                    Z[k] = right - left;
                    right--;
                }
            }
        }
        return Z;
    }
    public ArrayList<Integer> matchPattern(char text[], char pattern[]) {
        char newString[] = new char[text.length + pattern.length + 1];
        int i = 0;
        for(char ch : pattern) {
            newString[i] = ch;
            i++;
        }
        newString[i] = '$';
        i++;
        for(char ch : text) {
            newString[i] = ch;
            i++;
        }
        ArrayList<Integer> result = new ArrayList<>();
        int Z[] = calculateZ(newString);

        for(i = 0; i < Z.length ; i++) {
            if(Z[i] == pattern.length) {
                result.add(i - pattern.length - 1);
            }
        }
        return result;
    }
}
class BasicFunctions
{
    public long min(long[] A)
    {
        long min = Long.MAX_VALUE;
        for(int i=0;i<A.length;i++)
        {
            min = Math.min(min, A[i]);
        }
        return min;
    }
    public long max(long[] A)
    {
        long max = Long.MAX_VALUE;
        for(int i=0;i<A.length;i++)
        {
            max = Math.max(max, A[i]);
        }
        return max;
    }
}
class Name implements Comparable<Name>
{
    int x;
    int y;

    public Name(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
    @Override
    public int compareTo(Name ob)
    {
        if(this.x < ob.x)
            return -1;
        else if(this.x > ob.x)
            return 1;
        return 0;
    }
}
class Matrix
{
    long a;
    long b;
    long c;
    long d;

    public Matrix(long a, long b, long c, long d)
    {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }
}
class Game implements Comparable<Game>
{
    long x;
    long y;

    public Game(long x, long y)
    {
        this.x = x;
        this.y = y;
    }

    @Override
    public int compareTo(Game ob)
    {
        if(this.x < ob.x)
            return -1;
        else if(this.x > ob.x)
            return 1;
        else
        {
            if(this.y < ob.y)
                return -1;
            else if(this.y > ob.y)
                return 1;
            else
                return 0;
        }
    }
}
class MergeSortInt
{
    // Merges two subarrays of arr[].
    // First subarray is arr[l..m]
    // Second subarray is arr[m+1..r]
    void merge(int arr[], int l, int m, int r) {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        /* Create temp arrays */
        int L[] = new int[n1];
        int R[] = new int[n2];

        /*Copy data to temp arrays*/
        for (int i = 0; i < n1; ++i)
            L[i] = arr[l + i];
        for (int j = 0; j < n2; ++j)
            R[j] = arr[m + 1 + j];


        /* Merge the temp arrays */

        // Initial indexes of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        /* Copy remaining elements of L[] if any */
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        /* Copy remaining elements of R[] if any */
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Main function that sorts arr[l..r] using
    // merge()
    void sort(int arr[], int l, int r) {
        if (l < r) {
            // Find the middle point
            int m = (l + r) / 2;

            // Sort first and second halves
            sort(arr, l, m);
            sort(arr, m + 1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

}
class MergeSortLong
{
    // Merges two subarrays of arr[].
    // First subarray is arr[l..m]
    // Second subarray is arr[m+1..r]
    void merge(long arr[], int l, int m, int r) {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        /* Create temp arrays */
        long L[] = new long[n1];
        long R[] = new long[n2];

        /*Copy data to temp arrays*/
        for (int i = 0; i < n1; ++i)
            L[i] = arr[l + i];
        for (int j = 0; j < n2; ++j)
            R[j] = arr[m + 1 + j];


        /* Merge the temp arrays */

        // Initial indexes of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarry array
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        /* Copy remaining elements of L[] if any */
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        /* Copy remaining elements of R[] if any */
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Main function that sorts arr[l..r] using
    // merge()
    void sort(long arr[], int l, int r) {
        if (l < r) {
            // Find the middle point
            int m = (l + r) / 2;

            // Sort first and second halves
            sort(arr, l, m);
            sort(arr, m + 1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }
}
class Node
{
    String a;
    String b;
    Node(String s1,String s2)
    {
        this.a = s1;
        this.b = s2;
    }
    @Override
    public boolean equals(Object ob)
    {
        if(ob == null)
            return false;
        if(!(ob instanceof Node))
            return false;
        if(ob == this)
            return true;
        Node obj = (Node)ob;
        if(this.a.equals(obj.a) && this.b.equals(obj.b))
            return true;
        return false;
    }

    @Override
    public int hashCode()
    {
        return (int)this.a.length();
    }
}
class Reader
{
    final private int BUFFER_SIZE = 1 << 16;
    private DataInputStream din;
    private byte[] buffer;
    private int bufferPointer, bytesRead;

    public Reader()
    {
        din = new DataInputStream(System.in);
        buffer = new byte[BUFFER_SIZE];
        bufferPointer = bytesRead = 0;
    }

    public Reader(String file_name) throws IOException
    {
        din = new DataInputStream(new FileInputStream(file_name));
        buffer = new byte[BUFFER_SIZE];
        bufferPointer = bytesRead = 0;
    }

    public String readLine() throws IOException
    {
        byte[] buf = new byte[64]; // line length
        int cnt = 0, c;
        while ((c = read()) != -1)
        {
            if (c == '\n')
                break;
            buf[cnt++] = (byte) c;
        }
        return new String(buf, 0, cnt);
    }

    public int nextInt() throws IOException
    {
        int ret = 0;
        byte c = read();
        while (c <= ' ')
            c = read();
        boolean neg = (c == '-');
        if (neg)
            c = read();
        do
        {
            ret = ret * 10 + c - '0';
        }  while ((c = read()) >= '0' && c <= '9');

        if (neg)
            return -ret;
        return ret;
    }

    public long nextLong() throws IOException
    {
        long ret = 0;
        byte c = read();
        while (c <= ' ')
            c = read();
        boolean neg = (c == '-');
        if (neg)
            c = read();
        do {
            ret = ret * 10 + c - '0';
        }
        while ((c = read()) >= '0' && c <= '9');
        if (neg)
            return -ret;
        return ret;
    }

    public double nextDouble() throws IOException
    {
        double ret = 0, div = 1;
        byte c = read();
        while (c <= ' ')
            c = read();
        boolean neg = (c == '-');
        if (neg)
            c = read();

        do {
            ret = ret * 10 + c - '0';
        }
        while ((c = read()) >= '0' && c <= '9');

        if (c == '.')
        {
            while ((c = read()) >= '0' && c <= '9')
            {
                ret += (c - '0') / (div *= 10);
            }
        }

        if (neg)
            return -ret;
        return ret;
    }

    private void fillBuffer() throws IOException
    {
        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
        if (bytesRead == -1)
            buffer[0] = -1;
    }

    private byte read() throws IOException
    {
        if (bufferPointer == bytesRead)
            fillBuffer();
        return buffer[bufferPointer++];
    }

    public void close() throws IOException
    {
        if (din == null)
            return;
        din.close();
    }
}
class FenwickTree
{
    public void update(long[] fenwickTree,long delta,int index)
    {
        index += 1;
        while(index < fenwickTree.length)
        {
            fenwickTree[index] += delta;
            index = index + (index & (-index));
        }
    }
    public long prefixSum(long[] fenwickTree,int index)
    {
        long sum = 0L;
        index += 1;
        while(index > 0)
        {
            sum += fenwickTree[index];
            index -= (index & (-index));
        }
        return sum;
    }
}
class SegmentTree
{
    public int nextPowerOfTwo(int num)
    {
        if(num == 0)
            return 1;
        if(num > 0 && (num & (num - 1)) == 0)
            return num;
        while((num &(num - 1)) > 0)
        {
            num = num & (num - 1);
        }
        return num << 1;
    }
    public int[] createSegmentTree(int[] input)
    {
        int np2 = nextPowerOfTwo(input.length);
        int[] segmentTree = new int[np2 * 2 - 1];

        for(int i=0;i<segmentTree.length;i++)
            segmentTree[i] = Integer.MIN_VALUE;

        constructSegmentTree(segmentTree,input,0,input.length-1,0);
        return segmentTree;

    }
    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)
    {
        if(low == high)
        {
            segmentTree[pos] = input[low];
            return;
        }
        int mid = (low + high)/ 2;
        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);
        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);
        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);
    }
    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)
    {
        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);
    }
    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)
    {
        if(qlow <= low && qhigh >= high){
            return segmentTree[pos];
        }
        if(qlow > high || qhigh < low){
            return Integer.MIN_VALUE;
        }
        int mid = (low+high)/2;
        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),
                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));
    }
}",,CorCod,142,142
"
// Java program to count subsequences of the 
// form a^i b^j c^k 
public
class
No_of_subsequence { 


// Returns count of subsequences of the form 

// a^i b^j c^k 

static
int
countSubsequences(String s) 

{ 

// Initialize counts of different subsequences 

// caused by different combination of 'a' 

int
aCount = 
0
; 


// Initialize counts of different subsequences 

// caused by different combination of 'a' and 

// different combination of 'b' 

int
bCount = 
0
; 


// Initialize counts of different subsequences 

// caused by different combination of 'a', 'b' 

// and 'c'. 

int
cCount = 
0
; 


// Traverse all characters of given string 

for
(
int
i=
0
; i< s.length(); i++) 

{ 

/* If current character is 'a', then 

there are following possibilities : 

a) Current character begins a new 

subsequence. 

b) Current character is part of aCount 

subsequences. 

c) Current character is not part of 

aCount subsequences. */

if
(s.charAt(i) == 
'a'
) 

aCount = (
1
+ 
2
* aCount); 


/* If current character is 'b', then 

there are following possibilities : 

a) Current character begins a new 

subsequence of b's with aCount 

subsequences. 

b) Current character is part of bCount 

subsequences. 

c) Current character is not part of 

bCount subsequences. */

else
if
(s.charAt(i) == 
'b'
) 

bCount = (aCount + 
2
* bCount); 


/* If current character is 'c', then 

there are following possibilities : 

a) Current character begins a new 

subsequence of c's with bCount 

subsequences. 

b) Current character is part of cCount 

subsequences. 

c) Current character is not part of 

cCount subsequences. */

else
if
(s.charAt(i) == 
'c'
) 

cCount = (bCount + 
2
* cCount); 

} 


return
cCount; 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

String s = 
""abbc""
; 

System.out.println(countSubsequences(s)); 

} 
} 
// This code is contributed by Sumit Ghosh ",,CorCod,147,147
"
// Java program to find maximum product of 
// a subset. 
class
GFG { 


static
int
minProductSubset(
int
a[], 
int
n) 

{ 

if
(n == 
1
) 

return
a[
0
]; 


// Find count of negative numbers, 

// count of zeros, maximum valued 

// negative number, minimum valued 

// positive number and product of 

// non-zero numbers 

int
negmax = Integer.MIN_VALUE; 

int
posmin = Integer.MAX_VALUE; 

int
count_neg = 
0
, count_zero = 
0
; 

int
product = 
1
; 


for
(
int
i = 
0
; i < n; i++) 

{ 


// if number is zero,count it 

// but dont multiply 

if
(a[i] == 
0
){ 

count_zero++; 

continue
; 

} 


// count the negetive numbers 

// and find the max negetive number 

if
(a[i] < 
0
) 

{ 

count_neg++; 

negmax = Math.max(negmax, a[i]); 

} 


// find the minimum positive number 

if
(a[i] > 
0
&& a[i] < posmin) 

posmin = a[i]; 


product *= a[i]; 

} 


// if there are all zeroes 

// or zero is present but no 

// negetive number is present 

if
(count_zero == n || 

(count_neg == 
0
&& count_zero > 
0
)) 

return
0
; 


// If there are all positive 

if
(count_neg == 
0
) 

return
posmin; 


// If there are even number except 

// zero of negative numbers 

if
(count_neg % 
2
== 
0
&& count_neg != 
0
) 

{ 


// Otherwise result is product of 

// all non-zeros divided by maximum 

// valued negative. 

product = product / negmax; 

} 


return
product; 

} 


// main function 

public
static
void
main(String[] args) 

{ 


int
a[] = { -
1
, -
1
, -
2
, 
4
, 
3
}; 

int
n = 
5
; 


System.out.println(minProductSubset(a, n)); 

} 
} 

// This code is contributed by Arnab Kundu. ",,CorCod,168,168
"
// Java program to check if binary tree 
// is subtree of another binary tree 
class
Node { 


char
data; 

Node left, right; 


Node(
char
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
Passing { 


int
i; 

int
m = 
0
; 

int
n = 
0
; 
} 

class
BinaryTree { 


static
Node root; 

Passing p = 
new
Passing(); 


String strstr(String haystack, String needle) 

{ 

if
(haystack == 
null
|| needle == 
null
) { 

return
null
; 

} 

int
hLength = haystack.length(); 

int
nLength = needle.length(); 

if
(hLength < nLength) { 

return
null
; 

} 

if
(nLength == 
0
) { 

return
haystack; 

} 

for
(
int
i = 
0
; i <= hLength - nLength; i++) { 

if
(haystack.charAt(i) == needle.charAt(
0
)) { 

int
j = 
0
; 

for
(; j < nLength; j++) { 

if
(haystack.charAt(i + j) != needle.charAt(j)) { 

break
; 

} 

} 

if
(j == nLength) { 

return
haystack.substring(i); 

} 

} 

} 

return
null
; 

} 


// A utility function to store inorder traversal of tree rooted 

// with root in an array arr[]. Note that i is passed as reference 

void
storeInorder(Node node, 
char
arr[], Passing i) 

{ 

if
(node == 
null
) { 

arr[i.i++] = 
'$'
; 

return
; 

} 

storeInorder(node.left, arr, i); 

arr[i.i++] = node.data; 

storeInorder(node.right, arr, i); 

} 


// A utility function to store preorder traversal of tree rooted 

// with root in an array arr[]. Note that i is passed as reference 

void
storePreOrder(Node node, 
char
arr[], Passing i) 

{ 

if
(node == 
null
) { 

arr[i.i++] = 
'$'
; 

return
; 

} 

arr[i.i++] = node.data; 

storePreOrder(node.left, arr, i); 

storePreOrder(node.right, arr, i); 

} 


/* This function returns true if S is a subtree of T, otherwise false */

boolean
isSubtree(Node T, Node S) 

{ 

/* base cases */

if
(S == 
null
) { 

return
true
; 

} 

if
(T == 
null
) { 

return
false
; 

} 


// Store Inorder traversals of T and S in inT[0..m-1] 

// and inS[0..n-1] respectively 

char
inT[] = 
new
char
[
100
]; 

String op1 = String.valueOf(inT); 

char
inS[] = 
new
char
[
100
]; 

String op2 = String.valueOf(inS); 

storeInorder(T, inT, p); 

storeInorder(S, inS, p); 

inT[p.m] = 
'\0'
; 

inS[p.m] = 
'\0'
; 


// If inS[] is not a substring of preS[], return false 

if
(strstr(op1, op2) != 
null
) { 

return
false
; 

} 


// Store Preorder traversals of T and S in inT[0..m-1] 

// and inS[0..n-1] respectively 

p.m = 
0
; 

p.n = 
0
; 

char
preT[] = 
new
char
[
100
]; 

char
preS[] = 
new
char
[
100
]; 

String op3 = String.valueOf(preT); 

String op4 = String.valueOf(preS); 

storePreOrder(T, preT, p); 

storePreOrder(S, preS, p); 

preT[p.m] = 
'\0'
; 

preS[p.n] = 
'\0'
; 


// If inS[] is not a substring of preS[], return false 

// Else return true 

return
(strstr(op3, op4) != 
null
); 

} 


// Driver program to test above functions 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

Node T = 
new
Node(
'a'
); 

T.left = 
new
Node(
'b'
); 

T.right = 
new
Node(
'd'
); 

T.left.left = 
new
Node(
'c'
); 

T.right.right = 
new
Node(
'e'
); 


Node S = 
new
Node(
'a'
); 

S.left = 
new
Node(
'b'
); 

S.right = 
new
Node(
'd'
); 

S.left.left = 
new
Node(
'c'
); 


if
(tree.isSubtree(T, S)) { 

System.out.println(
""Yes, S is a subtree of T""
); 

} 

else
{ 

System.out.println(
""No, S is not a subtree of T""
); 

} 

} 
} 

// This code is contributed by Mayank Jaiswal ",,CorCod,177,177
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class CodeForces
{
	public static void main(String[] args)
	{
		Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

		int n = input.nextInt();
		String s = input.next();
		boolean done = false;
		for (int i = 0; i < s.length() - 1; i++)
		{
			if (s.charAt(i) != s.charAt(i + 1))
			{
				System.out.println(""YES"");
				System.out.println(s.charAt(i) + """" + s.charAt(i + 1));
				done = true;
				break;
			}
		}
		if (!done)
		{
			System.out.println(""NO"");
		}
	}
}",,CorCod,187,187
"import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;

public class A1180 {

    public static void main(String[] args) throws FileNotFoundException 
    { 
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		int layers = n-1;
		int counter =0;
		for(int i =1 ;i < layers + 1 ; i ++) {
			counter += i ;
		}
		//System.out.println(counter);
		System.out.println(1 + counter*4);
    } 
}
",,CorCod,193,193
"
// Java Program to find the ""GFG"" subsequence 
// in the given string 

public
class
GFG { 


static
int
max = 
100
; 


// Print the count of ""GFG"" subsequence 

// in the string 

static
void
countSubsequence(String s, 
int
n) 

{ 

int
cntG = 
0
, cntF = 
0
, result = 
0
, C=
0
; 


// Traversing the given string 

for
(
int
i = 
0
; i < n; i++) { 

switch
(s.charAt(i)) { 


// If the character is 'G', 

// increment the count of 'G', 

// increase the result and 

// update the array. 

case
'G'
: 

cntG++; 

result+=C; 

break
; 


// If the character is 'F', 

// increment the count of 'F' 

// and update the array. 

case
'F'
: 

cntF++; 

C+=cntG; 

break
; 


// Ignore other character. 

default
: 

continue
; 

} 

} 


System.out.println(result); 

} 


// Driver code 

public
static
void
main(String args[]) { 

String s= 
""GFGFG""
; 

int
n = s.length(); 

countSubsequence(s, n); 

} 
} 

// This code is contributed by Sam007 ",,CorCod,221,221
"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int num=sc.nextInt();
		long sum1=0,sum2=0;
		for(int i=0;i<num*2;i++){
			sum1+=sc.nextInt();
			sum2+=sc.nextInt();
		}
		System.out.println(sum1/num+"" ""+sum2/num);
	}
}
				  			 		  	 			 				 	",,CorCod,223,223
"import java.io.*;
import java.util.*;


public class Main {

    static StringBuilder data = new StringBuilder();
    final static FastReader in = new FastReader();


    public static void main(String[] args) {
        int n = in.nextInt(), m = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }
        int h=0,t=n-1,answ=0;
        while (h<n&&t>=0){
            if(a[h]<=m){
                answ++;
                h++;
            }else if(a[t]<=m){
                t--;
                answ++;
            }else{
                break;
            }
        }
        System.out.println(answ);
    }


    static void fileOut(String s) {
        File out = new File(""output.txt"");
        try {
            FileWriter fw = new FileWriter(out);
            fw.write(s);
            fw.flush();
            fw.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        public FastReader(String path) {
            try {
                br = new BufferedReader(new
                        InputStreamReader(new FileInputStream(path)));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        float nextFloat() {
            return Float.parseFloat(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }


        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

}",,CorCod,232,232
"import java.io.*;

public class GennadyAndACardGame {
	public static void main(String[] args) throws IOException {
		BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));
		String line =null;
		String[] n={};
		String s=""NO"";
		while((line=bufr.readLine())!=null)    {
			if(""over"".equals(line))
				break;
			n=bufr.readLine().split("" "");
			for(int i=0;i<n.length;i++){
				if(n[i].contains(line.substring(0,1)) || n[i].contains(line.substring(1))){
					s=""YES"";
				}
			}
			System.out.println(s);
			s=""NO"";
			bufw.flush();
		}
		bufw.close();                          //关闭
	}
}
",,CorCod,254,254
"
// Java program to find k'th largest element in BST 
import
java.util.*; 
class
GfG { 

// A BST node 
static
class
Node 
{ 

int
key; 

Node left, right; 
} 

// A function to find 
static
int
KSmallestUsingMorris(Node root, 
int
k) 
{ 

// Count to iterate over elements till we 

// get the kth smallest number 

int
count = 
0
; 


int
ksmall = Integer.MIN_VALUE; 
// store the Kth smallest 

Node curr = root; 
// to store the current node 


while
(curr != 
null
) 

{ 

// Like Morris traversal if current does 

// not have left child rather than printing 

// as we did in inorder, we will just 

// increment the count as the number will 

// be in an increasing order 

if
(curr.left == 
null
) 

{ 

count++; 


// if count is equal to K then we found the 

// kth smallest, so store it in ksmall 

if
(count==k) 

ksmall = curr.key; 


// go to current's right child 

curr = curr.right; 

} 

else

{ 

// we create links to Inorder Successor and 

// count using these links 

Node pre = curr.left; 

while
(pre.right != 
null
&& pre.right != curr) 

pre = pre.right; 


// building links 

if
(pre.right== 
null
) 

{ 

//link made to Inorder Successor 

pre.right = curr; 

curr = curr.left; 

} 


// While breaking the links in so made temporary 

// threaded tree we will check for the K smallest 

// condition 

else

{ 

// Revert the changes made in if part (break link 

// from the Inorder Successor) 

pre.right = 
null
; 


count++; 


// If count is equal to K then we found 

// the kth smallest and so store it in ksmall 

if
(count==k) 

ksmall = curr.key; 


curr = curr.right; 

} 

} 

} 

return
ksmall; 
//return the found value 
} 

// A utility function to create a new BST node 
static
Node newNode(
int
item) 
{ 

Node temp = 
new
Node(); 

temp.key = item; 

temp.left = 
null
; 

temp.right = 
null
; 

return
temp; 
} 

/* A utility function to insert a new node with given key in BST */
static
Node insert(Node node, 
int
key) 
{ 

/* If the tree is empty, return a new node */

if
(node == 
null
) 
return
newNode(key); 


/* Otherwise, recur down the tree */

if
(key < node.key) 

node.left = insert(node.left, key); 

else
if
(key > node.key) 

node.right = insert(node.right, key); 


/* return the (unchanged) node pointer */

return
node; 
} 

// Driver Program to test above functions 
public
static
void
main(String[] args) 
{ 

/* Let us create following BST 

50 

/ \ 

30 70 

/ \ / \ 

20 40 60 80 */

Node root = 
null
; 

root = insert(root, 
50
); 

insert(root, 
30
); 

insert(root, 
20
); 

insert(root, 
40
); 

insert(root, 
70
); 

insert(root, 
60
); 

insert(root, 
80
); 


for
(
int
k=
1
; k<=
7
; k++) 

System.out.print(KSmallestUsingMorris(root, k) + 
"" ""
); 

} 
} ",,CorCod,259,259
"
// Java program to convert a given Binary Tree to 
// Doubly Linked List 

/* Structure for tree and Linked List */
class
Node 
{ 

int
data; 

Node left, right; 


public
Node(
int
data) 

{ 

this
.data = data; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

// 'root' - root of binary tree 

Node root; 


// 'head' - reference to head node of created 

//double linked list 

Node head; 


// A simple recursive function to convert a given 

// Binary tree to Doubly Linked List 

void
BToDLL(Node root) 

{ 

// Base cases 

if
(root == 
null
) 

return
; 


// Recursively convert right subtree 

BToDLL(root.right); 


// insert root into DLL 

root.right = head; 


// Change left pointer of previous head 

if
(head != 
null
) 

(head).left = root; 


// Change head of Doubly linked list 

head = root; 


// Recursively convert left subtree 

BToDLL(root.left); 

} 


// Utility function for printing double linked list. 

void
printList(Node head) 

{ 

System.out.println(
""Extracted Double Linked List is : ""
); 

while
(head != 
null
) 

{ 

System.out.print(head.data + 
"" ""
); 

head = head.right; 

} 

} 


// Driver program to test the above functions 

public
static
void
main(String[] args) 

{ 

/* Constructing below tree 

5 

/ \ 

3 6 

/ \ \ 

1 4 8 

/ \ / \ 

0 2 7 9 */


BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
5
); 

tree.root.left = 
new
Node(
3
); 

tree.root.right = 
new
Node(
6
); 

tree.root.left.right = 
new
Node(
4
); 

tree.root.left.left = 
new
Node(
1
); 

tree.root.right.right = 
new
Node(
8
); 

tree.root.left.left.right = 
new
Node(
2
); 

tree.root.left.left.left = 
new
Node(
0
); 

tree.root.right.right.left = 
new
Node(
7
); 

tree.root.right.right.right = 
new
Node(
9
); 


tree.BToDLL(tree.root); 

tree.printList(tree.head); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",,CorCod,264,264
"
// Java program to reverse alternate levels of perfect binary tree 
// A binary tree node 
class
Node { 


char
data; 

Node left, right; 


Node(
char
item) { 

data = item; 

left = right = 
null
; 

} 
} 

// class to access index value by reference 
class
Index { 


int
index; 
} 

class
BinaryTree { 


Node root; 

Index index_obj = 
new
Index(); 


// function to store alternate levels in a tree 

void
storeAlternate(Node node, 
char
arr[], Index index, 
int
l) { 

// base case 

if
(node == 
null
) { 

return
; 

} 

// store elements of left subtree 

storeAlternate(node.left, arr, index, l + 
1
); 


// store this node only if level is odd 

if
(l % 
2
!= 
0
) { 

arr[index.index] = node.data; 

index.index++; 

} 


storeAlternate(node.right, arr, index, l + 
1
); 

} 


// Function to modify Binary Tree (All odd level nodes are 

// updated by taking elements from array in inorder fashion) 

void
modifyTree(Node node, 
char
arr[], Index index, 
int
l) { 


// Base case 

if
(node == 
null
) { 

return
; 

} 


// Update nodes in left subtree 

modifyTree(node.left, arr, index, l + 
1
); 


// Update this node only if this is an odd level node 

if
(l % 
2
!= 
0
) { 

node.data = arr[index.index]; 

(index.index)++; 

} 


// Update nodes in right subtree 

modifyTree(node.right, arr, index, l + 
1
); 

} 


// A utility function to reverse an array from index 

// 0 to n-1 

void
reverse(
char
arr[], 
int
n) { 

int
l = 
0
, r = n - 
1
; 

while
(l < r) { 

char
temp = arr[l]; 

arr[l] = arr[r]; 

arr[r] = temp; 

l++; 

r--; 

} 

} 


void
reverseAlternate() { 

reverseAlternate(root); 

} 


// The main function to reverse alternate nodes of a binary tree 

void
reverseAlternate(Node node) { 


// Create an auxiliary array to store nodes of alternate levels 

char
[] arr = 
new
char
[
100
]; 


// First store nodes of alternate levels 

storeAlternate(node, arr, index_obj, 
0
); 


//index_obj.index = 0; 


// Reverse the array 

reverse(arr, index_obj.index); 


// Update tree by taking elements from array 

index_obj.index = 
0
; 

modifyTree(node, arr, index_obj, 
0
); 

} 


void
printInorder() { 

printInorder(root); 

} 


// A utility function to print indorder traversal of a 

// binary tree 

void
printInorder(Node node) { 

if
(node == 
null
) { 

return
; 

} 

printInorder(node.left); 

System.out.print(node.data + 
"" ""
); 

printInorder(node.right); 

} 


// Driver program to test the above functions 

public
static
void
main(String args[]) { 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
'a'
); 

tree.root.left = 
new
Node(
'b'
); 

tree.root.right = 
new
Node(
'c'
); 

tree.root.left.left = 
new
Node(
'd'
); 

tree.root.left.right = 
new
Node(
'e'
); 

tree.root.right.left = 
new
Node(
'f'
); 

tree.root.right.right = 
new
Node(
'g'
); 

tree.root.left.left.left = 
new
Node(
'h'
); 

tree.root.left.left.right = 
new
Node(
'i'
); 

tree.root.left.right.left = 
new
Node(
'j'
); 

tree.root.left.right.right = 
new
Node(
'k'
); 

tree.root.right.left.left = 
new
Node(
'l'
); 

tree.root.right.left.right = 
new
Node(
'm'
); 

tree.root.right.right.left = 
new
Node(
'n'
); 

tree.root.right.right.right = 
new
Node(
'o'
); 

System.out.println(
""Inorder Traversal of given tree""
); 

tree.printInorder(); 


tree.reverseAlternate(); 

System.out.println(
""""
); 

System.out.println(
""""
); 

System.out.println(
""Inorder Traversal of modified tree""
); 

tree.printInorder(); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",,CorCod,266,266
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 * @author Ahmed
 */




public class Watermelon {

   static class Passengers {
  
     public int floor ;
     public int time;
     
     
     public Passengers( int floor  , int time){
         this.floor =floor;
         this.time =time;
     }
     
}

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        
        Scanner in = new Scanner(System.in);
        
        int x = in.nextInt() , y = in.nextInt();
        
        ArrayList<Passengers> list = new ArrayList<>();
        
        for(int i = 1 ; i <= x ; ++i){
            list.add(new Passengers(in.nextInt(), in.nextInt()));
        }
        
        int sum = 0 ;
       for(int i = list.size() - 1 ; i >= 0 ; --i)
       {
          int s = y -  list.get(i).floor;
          sum = sum + s ; 
          
          if(sum < list.get(i).time)
          {
              sum = sum + ( list.get(i).time - sum);
          }
          
          y = list.get(i).floor;
       } 
        
        
       if( list.get(list.size() - 1).floor != 0){
           sum = sum  + (list.get(0).floor);
       }
        System.out.println(sum);
    }
    
}
",,CorCod,274,274
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class DeathNote {
	public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
	public static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		int n = nextInt();
		int m = nextInt();
		int[] a = intArray(n);
		
		StringBuffer sb = new StringBuffer();
		int x = 0;
		for (int i = 0; i < n; i++) {
			x += a[i];
			sb.append("" "" + (x/m));
			x %= m;
		}
		
		System.out.println(sb.toString().substring(1));
	}
	
	public static String nextLine() throws IOException {
		return in.readLine();
	}

	public static String nextString() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(nextString());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(nextString());
	}

	public static int[] intArray(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public static int[][] intArray(int n, int m) throws IOException {
		int[][] a = new int[n][m];
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				a[i][j] = nextInt();
		return a;
	}

	public static long[] longArray(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nextLong();
		return a;
	}
}",,CorCod,304,304
"
// Java program to find intersection of 
// two sorted arrays 

class
FindIntersection 
{ 

/* Function prints Intersection of arr1[] and arr2[] 

m is the number of elements in arr1[] 

n is the number of elements in arr2[] */

static
void
printIntersection(
int
arr1[], 
int
arr2[], 
int
m, 
int
n) 

{ 

int
i = 
0
, j = 
0
; 

while
(i < m && j < n) 

{ 

if
(arr1[i] < arr2[j]) 

i++; 

else
if
(arr2[j] < arr1[i]) 

j++; 

else

{ 

System.out.print(arr2[j++]+
"" ""
); 

i++; 

} 

} 

} 


public
static
void
main(String args[]) 

{ 

int
arr1[] = {
1
, 
2
, 
4
, 
5
, 
6
}; 

int
arr2[] = {
2
, 
3
, 
5
, 
7
}; 

int
m = arr1.length; 

int
n = arr2.length; 

printIntersection(arr1, arr2, m, n); 

} 
} ",,CorCod,305,305
"import java.util.Scanner;

/**
 *
 * @author User
 */
public class Code {

   static int [] reverse(int a[]) 
    { 
        int[] b = new int[a.length]; 
       int j = 0  ;
        for (int i = a.length-1; i >= 0; i--) {
            b[i] = a[j] ; 
            j++;
        }
        return b ;
    }
    public static void main(String[] args) {
        int pas ; 
        int top ; 
        Scanner in = new Scanner(System.in) ; 
        pas= in.nextInt(); 
        top=in.nextInt() ; 
        int a [] = new int[pas] ; 
        int b [] = new int[pas] ; 
        
        for (int i = 0; i < pas; i++) {
            a[i] = in.nextInt() ; 
            b[i] = in.nextInt() ; 
           
         }
       a =  reverse(a) ;
        b = reverse(b) ;
        int ftime =0 ; 
        int t;
        int po = top ; 
        for (int i = 0; i < pas; i++) {
             ftime+=(po-a[i]) ; 
            t = Math.max(b[i]-ftime, 0) ; 
            ftime+=t ; 
            po = a[i] ; 
           
        }
        if(po!=0) ftime+=po ;
        System.out.println(ftime);
        
    }
    
}
",,CorCod,306,306
"
// Java implementation to count number 
// of ways to tile a floor of size 
// n x m using 1 x m tiles 
import
java.io.*; 

class
GFG { 

// function to count the total number of ways 

static
int
countWays(
int
n, 
int
m) 

{ 

// table to store values 

// of subproblems 

int
count[] = 
new
int
[n + 
1
]; 

count[
0
] = 
0
; 


// Fill the table upto value n 

int
i; 

for
(i = 
1
; i <= n; i++) { 

// recurrence relation 

if
(i > m) 

count[i] = count[i - 
1
] + count[i - m]; 


// base cases 

else
if
(i < m) 

count[i] = 
1
; 


// i = = m 

else

count[i] = 
2
; 

} 


// required number of ways 

return
count[n]; 

} 


// Driver program 

public
static
void
main(String[] args) 

{ 

int
n = 
7
; 

int
m = 
4
; 

System.out.println(
""Number of ways = ""

+ countWays(n, m)); 

} 
} 

// This code is contributed by vt_m. ",,CorCod,311,311
"
import java.io.*;
import java.util.*;
import java.lang.*;
import static java.lang.Math.*;

// _ h _ r _ t r _
// _ t _ t _ s t _




public class TaskA implements Runnable {
    long m = (int)1e9+7;
    PrintWriter w;
    InputReader c;
    final int MAXN = (int)1e6 + 100;
    public void run() {
        c = new InputReader(System.in);
        w = new PrintWriter(System.out);

        int n = c.nextInt(), hamming_distance = 0;
        char[] s = c.next().toCharArray(), t = c.next().toCharArray();
        HashMap<Character, HashSet<Character>> replace = new HashMap<>();
        HashMap<Character, Integer> map = new HashMap<>();

        for(int i=0;i<n;++i) if(s[i] != t[i]) {
            HashSet<Character> temp;
            if(replace.containsKey(s[i])){
                temp = replace.get(s[i]);
                temp.add(t[i]);
            } else {
                temp = new HashSet<>();
                temp.add(t[i]);
            }
            map.put(s[i],i);
            replace.put(s[i], temp);
            hamming_distance++;
        }

        int l = -1, r = -1;
        boolean global_check = false;
        for(int i=0;i<n;i++) if(s[i] != t[i]) {
            if(replace.containsKey(t[i])) {
                HashSet<Character> indices = replace.get(t[i]);
                int ind = map.get(t[i]);
                l = i + 1;
                r = ind + 1;
                if (indices.contains(s[i])) {
                    hamming_distance -= 2;
                    global_check = true;
                    break;
                }
            }
            if(global_check) break;
        }

        if(!global_check && l!=-1) hamming_distance--;
        else if(global_check){
            for(int i=0;i<n;i++) {
                if(t[i] == s[l-1] && s[i] == t[l-1]){
                    r = i + 1;
                    break;
                }
            }
        }
        w.println(hamming_distance);
        w.println(l+"" ""+r);

        w.close();
    }
    static long gcd(long a, long b) {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }
    public static void sortbyColumn(int arr[][], int col){
        Arrays.sort(arr, new Comparator<int[]>()
        {
            public int compare(int[] o1, int[] o2){
                return(Integer.valueOf(o1[col]).compareTo(o2[col]));
            }
        });

    }
    public static class DJSet {
        public int[] upper;

        public DJSet(int n) {
            upper = new int[n];
            Arrays.fill(upper, -1);
        }

        public int root(int x) {
            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
        }

        public boolean equiv(int x, int y) {
            return root(x) == root(y);
        }

        public boolean union(int x, int y) {
            x = root(x);
            y = root(y);
            if (x != y) {
                if (upper[y] < upper[x]) {
                    int d = x;
                    x = y;
                    y = d;
                }
                upper[x] += upper[y];
                upper[y] = x;
            }
            return x == y;
        }
    }
    public static int[] radixSort(int[] f)    {
        int[] to = new int[f.length];
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        {
            int[] b = new int[65537];
            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;
            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];
            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];
            int[] d = f; f = to;to = d;
        }
        return f;
    }
    public void printArray(int[] a){
        for(int i=0;i<a.length;i++)
            w.print(a[i]+"" "");
        w.println();
    }
    public int[] scanArrayI(int n){
        int a[] = new int[n];
        for(int i=0;i<n;i++)
            a[i] = c.nextInt();
        return a;
    }
    public long[] scanArrayL(int n){
        long a[] = new long[n];
        for(int i=0;i<n;i++)
            a[i] = c.nextLong();
        return a;
    }
    public void printArray(long[] a){
        for(int i=0;i<a.length;i++)
            w.print(a[i]+"" "");
        w.println();
    }
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars==-1)
                throw new InputMismatchException();

            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                }
                catch (IOException e) {
                    throw new InputMismatchException();
                }

                if(numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            int c = read();

            while(isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;
            do {
                if(c<'0'||c>'9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
            return res * sgn;
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            return readString();
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
    public static void main(String args[]) throws Exception {
        new Thread(null, new TaskA(),""TaskA"",1<<26).start();
    }
}",,CorCod,324,324
"
// Java program to find efficient 
// solution for the network 
import
java.util.*; 

class
GFG { 


// number of houses and number 

// of pipes 

static
int
n, p; 


// Array rd stores the 

// ending vertex of pipe 

static
int
rd[] = 
new
int
[
1100
]; 


// Array wd stores the value 

// of diameters between two pipes 

static
int
wt[] = 
new
int
[
1100
]; 


// Array cd stores the 

// starting end of pipe 

static
int
cd[] = 
new
int
[
1100
]; 


// arraylist a, b, c are used 

// to store the final output 

static
List <Integer> a = 

new
ArrayList<Integer>(); 


static
List <Integer> b = 

new
ArrayList<Integer>(); 


static
List <Integer> c = 

new
ArrayList<Integer>(); 


static
int
ans; 


static
int
dfs(
int
w) 

{ 

if
(cd[w] == 
0
) 

return
w; 

if
(wt[w] < ans) 

ans = wt[w]; 


return
dfs(cd[w]); 

} 


// Function to perform calculations. 

static
void
solve(
int
arr[][]) 

{ 

int
i = 
0
; 


while
(i < p) 

{ 


int
q = arr[i][
0
]; 

int
h = arr[i][
1
]; 

int
t = arr[i][
2
]; 


cd[q] = h; 

wt[q] = t; 

rd[h] = q; 

i++; 

} 


a=
new
ArrayList<Integer>(); 

b=
new
ArrayList<Integer>(); 

c=
new
ArrayList<Integer>(); 


for
(
int
j = 
1
; j <= n; ++j) 


/*If a pipe has no ending vertex 

but has starting vertex i.e is 

an outgoing pipe then we need 

to start DFS with this vertex.*/

if
(rd[j] == 
0
&& cd[j]>
0
) { 

ans = 
1000000000
; 

int
w = dfs(j); 


// We put the details of 

// component in final output 

// array 

a.add(j); 

b.add(w); 

c.add(ans); 

} 


System.out.println(a.size()); 


for
(
int
j = 
0
; j < a.size(); ++j) 

System.out.println(a.get(j) + 
"" ""

+ b.get(j) + 
"" ""
+ c.get(j)); 

} 


// main function 

public
static
void
main(String args[]) 

{ 

n = 
9
; 

p = 
6
; 


// set the value of the araray 

// to zero 

for
(
int
i = 
0
; i < 
1100
; i++) 

rd[i] = cd[i] = wt[i] = 
0
; 


int
arr[][] = { { 
7
, 
4
, 
98
}, 

{ 
5
, 
9
, 
72
}, 

{ 
4
, 
6
, 
10
}, 

{ 
2
, 
8
, 
22
}, 

{ 
9
, 
7
, 
17
}, 

{ 
3
, 
1
, 
66
} }; 

solve(arr); 

} 
} 

// This code is contributed by Arnab Kundu ",,CorCod,346,346
"
// JAVA Code for Find maximum sum possible 
// equal sum of three stacks 
class
GFG { 


// Returns maximum possible equal sum of three 

// stacks with removal of top elements allowed 

public
static
int
maxSum(
int
stack1[], 
int
stack2[], 

int
stack3[], 
int
n1, 
int
n2, 

int
n3) 

{ 

int
sum1 = 
0
, sum2 = 
0
, sum3 = 
0
; 


// Finding the initial sum of stack1. 

for
(
int
i=
0
; i < n1; i++) 

sum1 += stack1[i]; 


// Finding the initial sum of stack2. 

for
(
int
i=
0
; i < n2; i++) 

sum2 += stack2[i]; 


// Finding the initial sum of stack3. 

for
(
int
i=
0
; i < n3; i++) 

sum3 += stack3[i]; 


// As given in question, first element is top 

// of stack.. 

int
top1 =
0
, top2 = 
0
, top3 = 
0
; 

int
ans = 
0
; 

while
(
true
) 

{ 

// If any stack is empty 

if
(top1 == n1 || top2 == n2 || top3 == n3) 

return
0
; 


// If sum of all three stack are equal. 

if
(sum1 == sum2 && sum2 == sum3) 

return
sum1; 


// Finding the stack with maximum sum and 

// removing its top element. 

if
(sum1 >= sum2 && sum1 >= sum3) 

sum1 -= stack1[top1++]; 

else
if
(sum2 >= sum3 && sum2 >= sum3) 

sum2 -= stack2[top2++]; 

else
if
(sum3 >= sum2 && sum3 >= sum1) 

sum3 -= stack3[top3++]; 

} 

} 


/* Driver program to test above function */

public
static
void
main(String[] args) 

{ 

int
stack1[] = { 
3
, 
2
, 
1
, 
1
, 
1
}; 

int
stack2[] = { 
4
, 
3
, 
2
}; 

int
stack3[] = { 
1
, 
1
, 
4
, 
1
}; 


int
n1 = stack1.length; 

int
n2 = stack2.length; 

int
n3 = stack3.length; 


System.out.println(maxSum(stack1, stack2, 

stack3, n1, n2, n3)); 

} 

} 
// This code is contributed by Arnav Kr. Mandal. ",,CorCod,360,360
"import java.util.*;
import java.io.*;
public class C{
    static PrintWriter out;
    static InputReader in;
    public static void main(String args[]){
        out = new PrintWriter(System.out);
        in = new InputReader();
        new C();
        out.flush(); out.close();
    }   
    C(){
       int a = solve();
       out.print(a == 0 ? ""tokitsukaze"" : a == 1 ? ""quailty"" : ""once again"");
    }
    int n, k;
    char ch[]; int a[], c0 = 0, c1 = 0;
    TreeSet<Integer> ts[] = new TreeSet[2];
    boolean check(){
        int min = 0, max = n;
        if(!ts[0].isEmpty()){
            min = ts[0].first(); max = ts[0].last();
            if(max - min + 1 > k)return true;
        }
        if(!ts[1].isEmpty()){
            min = ts[1].first(); max = ts[1].last();
            if(max - min + 1 > k)return true;   
        }
        return false;
    }
    int solve(){
        n  = in.nextInt(); k = in.nextInt();
        ch = in.next().trim().toCharArray(); a = new int[n];
        for(int i = 0; i < n; i++)c1 += a[i] = ch[i] - '0';
        c0 = n - c1;
        for(int i = 0; i < k; i++){
            if(a[i] == 0)c0--; else c1--;
        }
        if(c0 == 0 || c1 == 0)return 0;
        for(int i = k; i < n; i++){
            if(a[i] == 0)c0--; else c1--;
            if(a[i - k] == 0)c0++; else c1++;
            if(c0 == 0 || c1 == 0)return 0;
        }

        for(int i = 0; i < 2; i++)ts[i] = new TreeSet<>();
        for(int i = 0; i < n; i++){
            ts[a[i]].add(i);
        }
        for(int i = 0; i < k; i++){
            ts[a[i]].remove(i);
        }
        if(check())return 2;
        for(int i = k; i < n; i++){
            ts[a[i]].remove(i); ts[a[i - k]].add(i - k);
            if(check())return 2;
        }
        return 1;
    }
    public static class InputReader{
        BufferedReader br;
        StringTokenizer st;
        InputReader(){
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        public int nextInt(){
            return Integer.parseInt(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public double nextDouble(){
            return Double.parseDouble(next());
        }
        public String next(){
            while(st == null || !st.hasMoreTokens()){
                try{
                    st = new StringTokenizer(br.readLine());
                }catch(IOException e){}
            }
            return st.nextToken();
        }
    }
}
        ",,CorCod,365,365
"

import java.util.Scanner;
public class Stones {
	public static void main(String[] args)
	{
		Scanner input=new Scanner(System.in);
		int n=input.nextInt();
		int s1=0;
		int s2=0;
		for (int i=0;i<n;++i)
			s1+=input.nextInt();
		for (int i=0;i<n;++i)
			s2+=input.nextInt();
		if (s1 >= s2)
			System.out.println(""Yes"");
		else
			System.out.println(""No"");
	}
}
",,CorCod,369,369
"
// Java program to find a triplet 
class
FindTriplet { 


// returns true if there is triplet with sum equal 

// to 'sum' present in A[]. Also, prints the triplet 

boolean
find3Numbers(
int
A[], 
int
arr_size, 
int
sum) 

{ 

int
l, r; 


/* Sort the elements */

quickSort(A, 
0
, arr_size - 
1
); 


/* Now fix the first element one by one and find the 

other two elements */

for
(
int
i = 
0
; i < arr_size - 
2
; i++) { 


// To find the other two elements, start two index variables 

// from two corners of the array and move them toward each 

// other 

l = i + 
1
; 
// index of the first element in the remaining elements 

r = arr_size - 
1
; 
// index of the last element 

while
(l < r) { 

if
(A[i] + A[l] + A[r] == sum) { 

System.out.print(
""Triplet is ""
+ A[i] + 
"", ""
+ A[l] + 
"", ""
+ A[r]); 

return
true
; 

} 

else
if
(A[i] + A[l] + A[r] < sum) 

l++; 


else
// A[i] + A[l] + A[r] > sum 

r--; 

} 

} 


// If we reach here, then no triplet was found 

return
false
; 

} 


int
partition(
int
A[], 
int
si, 
int
ei) 

{ 

int
x = A[ei]; 

int
i = (si - 
1
); 

int
j; 


for
(j = si; j <= ei - 
1
; j++) { 

if
(A[j] <= x) { 

i++; 

int
temp = A[i]; 

A[i] = A[j]; 

A[j] = temp; 

} 

} 

int
temp = A[i + 
1
]; 

A[i + 
1
] = A[ei]; 

A[ei] = temp; 

return
(i + 
1
); 

} 


/* Implementation of Quick Sort 

A[] --> Array to be sorted 

si --> Starting index 

ei --> Ending index 

*/

void
quickSort(
int
A[], 
int
si, 
int
ei) 

{ 

int
pi; 


/* Partitioning index */

if
(si < ei) { 

pi = partition(A, si, ei); 

quickSort(A, si, pi - 
1
); 

quickSort(A, pi + 
1
, ei); 

} 

} 


// Driver program to test above functions 

public
static
void
main(String[] args) 

{ 

FindTriplet triplet = 
new
FindTriplet(); 

int
A[] = { 
1
, 
4
, 
45
, 
6
, 
10
, 
8
}; 

int
sum = 
22
; 

int
arr_size = A.length; 


triplet.find3Numbers(A, arr_size, sum); 

} 
} ",,CorCod,391,391
"import java.util.*;

import java.lang.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.*;
 
public class Main {
        
    public static void main(String[] args) throws Exception{
        FastReader sc=new FastReader(); 
        OutputStream outputStream = System.out;
        PrintWriter out = new PrintWriter(outputStream);
        int n=sc.nextInt();
        int[] font=new int[n];
        int[] cost=new int[n];
        for(int i=0;i<n;i++) {
            font[i]=sc.nextInt();
        
        }
        for(int i=0;i<n;i++) {
            cost[i]=sc.nextInt();
        }
        int[] dou= new int[n];
        for(int i=0;i<n;i++) {
            int min=Integer.MAX_VALUE;
            for(int j=0;j<i;j++) {
                if(font[j]<font[i]) {
                    if(min>cost[i]+cost[j]) {
                        min=cost[i]+cost[j];
                    }
                }
            }
            dou[i]=min;
        }
        int ans=Integer.MAX_VALUE;
        for(int i=0;i<n;i++) {
            int min=Integer.MAX_VALUE;
            for(int j=0;j<i;j++) {
                if(dou[j]!=Integer.MAX_VALUE && font[j]<font[i]) {
                    if(min>dou[j]+cost[i]) {
                        min=dou[j]+cost[i];
                    }
                }
            }
            if(min<ans) {
                ans=min;
            }
        }
        if(ans==Integer.MAX_VALUE) {
            System.out.println(-1);
        }
        else {
            System.out.println(ans);
        }
    }
}

class FastReader 
{ 
    BufferedReader br; 
    StringTokenizer st; 
 
    public FastReader() 
    { 
        br = new BufferedReader(new
                 InputStreamReader(System.in)); 
    } 
 
    String next() 
    { 
        while (st == null || !st.hasMoreElements()) 
        { 
            try
            { 
                st = new StringTokenizer(br.readLine()); 
            } 
            catch (IOException  e) 
            { 
                e.printStackTrace(); 
            } 
        } 
        return st.nextToken(); 
    } 
 
    int nextInt() 
    { 
        return Integer.parseInt(next()); 
    } 
 
    long nextLong() 
    { 
        return Long.parseLong(next()); 
    } 
 
    double nextDouble() 
    { 
        return Double.parseDouble(next()); 
    } 
 
    String nextLine() 
    { 
        String str = """"; 
        try
        { 
            str = br.readLine(); 
        } 
        catch (IOException e) 
        { 
            e.printStackTrace(); 
        } 
        return str; 
    } 
} ",,CorCod,411,411
"
// Java program to find Minimum 
// number of jumps to reach end 
class
GFG 
{ 
// Returns Minimum number 
// of jumps to reach end 
static
int
minJumps(
int
arr[], 

int
n) 
{ 

// jumps[0] will 

// hold the result 

int
[] jumps = 
new
int
[n]; 

int
min; 


// Minimum number of jumps 

// needed to reach last 

// element from last elements 

// itself is always 0 

jumps[n - 
1
] = 
0
; 



// Start from the second 

// element, move from right 

// to left and construct the 

// jumps[] array where jumps[i] 

// represents minimum number of 

// jumps needed to reach arr[m-1] 

// from arr[i] 

for
(
int
i = n - 
2
; i >= 
0
; i--) 

{ 

// If arr[i] is 0 then arr[n-1] 

// can't be reached from here 

if
(arr[i] == 
0
) 

jumps[i] = Integer.MAX_VALUE; 


// If we can direcly reach to 

// the end point from here then 

// jumps[i] is 1 

else
if
(arr[i] >= n - i - 
1
) 

jumps[i] = 
1
; 


// Otherwise, to find out 

// the minimum number of 

// jumps needed to reach 

// arr[n-1], check all the 

// points reachable from 

// here and jumps[] value 

// for those points 

else

{ 

// initialize min value 

min = Integer.MAX_VALUE; 


// following loop checks 

// with all reachable points 

// and takes the minimum 

for
(
int
j = i + 
1
; j < n && 

j <= arr[i] + i; j++) 

{ 

if
(min > jumps[j]) 

min = jumps[j]; 

} 


// Handle overflow 

if
(min != Integer.MAX_VALUE) 

jumps[i] = min + 
1
; 

else

jumps[i] = min; 
// or Integer.MAX_VALUE 

} 

} 


return
jumps[
0
]; 
} 

// Driver Code 
public
static
void
main(String[] args) 
{ 

int
[] arr = {
1
, 
3
, 
6
, 
1
, 
0
, 
9
}; 

int
size = arr.length; 

System.out.println(
""Minimum number of""
+ 

"" jumps to reach end is ""
+ 

minJumps(arr, size)); 

} 
} 

// This code is contributed by mits. ",,CorCod,418,418
"import java.util.Arrays;
import java.util.Scanner;


public class Solution {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		Solution ss = new Solution();
		ss.test(sc);
	}
	
	void test(Scanner sc){
		int LEN = sc.nextInt();
		int[] a = new int[LEN];
		int[] b = new int[LEN];
		for (int i = 0; i < b.length; i++) {
			a[i] = sc.nextInt();
		}
		for (int i = 0; i < b.length; i++) {
			b[i] = sc.nextInt();
		}
		Arrays.sort(a);
		Arrays.sort(b);
		
		int ia=0, ib=0;
		while(ia<LEN && a[ia]==0) ia++;
		while(ib<LEN && b[ib]==0) ib++;
		if(ib==LEN){
			System.out.println(""Yes"");
			return;
		}
		if(ia==LEN){
			System.out.println(""No"");
			return;
		}		
		boolean out = true;
		while(ia<LEN && ib<LEN){
			if(a[ia]==b[ib]){
				ia++;
				ib++;
			}else{
				if(a[ia]>b[ib]){
					while(ib<LEN && b[ib]!=a[ia]){
						ib++;
					}
					if(ib==LEN){
						out=false;
						break;
					}
				}
			}
		}
		
		if(out){
			System.out.println(""Yes"");
		}else{
			System.out.println(""No"");
		}
	}

}
",,CorCod,427,427
"import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class DoggoRecoloring {
	public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
	public static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		int n = nextInt();
		String s = nextString();
		boolean b = false;
		
		if (n == 1 || n > 26)
			b = true;
		else 
			for (int i = 0; i < n; i++)
				for (int j = i+1; j < n; j++)
					if (s.charAt(i) == s.charAt(j))
						 b = true;
		
		System.out.println(b ? ""Yes"" : ""No"");
	}
	
	public static String nextLine() throws IOException {
		return in.readLine();
	}

	public static String nextString() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	public static int nextInt() throws IOException {
		return Integer.parseInt(nextString());
	}

	public static long nextLong() throws IOException {
		return Long.parseLong(nextString());
	}

	public static int[] intArray(int n) throws IOException {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public static int[][] intArray(int n, int m) throws IOException {
		int[][] a = new int[n][m];
		for (int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
				a[i][j] = nextInt();
		return a;
	}

	public static long[] longArray(int n) throws IOException {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nextLong();
		return a;
	}
}",,CorCod,440,440
"
// A Dynamic Programming solution for Rod cutting problem 
class
RodCutting 
{ 

/* Returns the best obtainable price for a rod of 

length n and price[] as prices of different pieces */

static
int
cutRod(
int
price[],
int
n) 

{ 

int
val[] = 
new
int
[n+
1
]; 

val[
0
] = 
0
; 


// Build the table val[] in bottom up manner and return 

// the last entry from the table 

for
(
int
i = 
1
; i<=n; i++) 

{ 

int
max_val = Integer.MIN_VALUE; 

for
(
int
j = 
0
; j < i; j++) 

max_val = Math.max(max_val, 

price[j] + val[i-j-
1
]); 

val[i] = max_val; 

} 


return
val[n]; 

} 


/* Driver program to test above functions */

public
static
void
main(String args[]) 

{ 

int
arr[] = 
new
int
[] {
1
, 
5
, 
8
, 
9
, 
10
, 
17
, 
17
, 
20
}; 

int
size = arr.length; 

System.out.println(
""Maximum Obtainable Value is ""
+ 

cutRod(arr, size)); 

} 
} 
/* This code is contributed by Rajat Mishra */",,CorCod,442,442
"
// JAVA Code for Minimum number of jumps to reach end 
class
GFG{ 

private
static
int
minJumps(
int
[] arr, 
int
n) { 

int
jumps[] = 
new
int
[n]; 
// jumps[n-1] will hold the 

// result 

int
i, j; 


if
(n == 
0
|| arr[
0
] == 
0
) 

return
Integer.MAX_VALUE; 
// if first element is 0, 

// end cannot be reached 


jumps[
0
] = 
0
; 


// Find the minimum number of jumps to reach arr[i] 

// from arr[0], and assign this value to jumps[i] 

for
(i = 
1
; i < n; i++) 

{ 

jumps[i] = Integer.MAX_VALUE; 

for
(j = 
0
; j < i; j++) 

{ 

if
(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) 

{ 

jumps[i] = Math.min(jumps[i], jumps[j] + 
1
); 

break
; 

} 

} 

} 

return
jumps[n-
1
]; 

} 

// driver program to test above function 
public
static
void
main(String[] args) { 

int
arr[] = {
1
, 
3
, 
6
, 
1
, 
0
, 
9
}; 


System.out.println(
""Minimum number of jumps to reach end is : ""
+ 

minJumps(arr,arr.length)); 

} 
} 

// This code is contributed by Arnav Kr. Mandal. ",,CorCod,445,445
"import java.util.*;

public class vas2 {
    public static void main( String[] args ) {
	Scanner in = new Scanner( System.in );
	int n = in.nextInt();
	String st = in.next();
	int[] a = new int[n];
	for ( int i = 0; i < n; i++ )
	    a[i] = st.charAt( i ) - 48;
	boolean c = false;
	for ( int i = 1; !c && i < n; i++ ) {
	    int s = 0;
	    for ( int j = 0; j < i; j++ )
		s += a[j];
	    int t = 0;
	    for ( int j = i; j < n; j++ ) {
		t += a[j];
		if ( t > s )
		    if ( t - a[j] != s )
			break;
		    else
			t = a[j];
	    }
	    if ( t == s )
		c = true;
	}
	System.out.println( c ? ""YES"" : ""NO"" );
    }
}
",,CorCod,449,449
"import java.util.*;
import java.math.*;
public class Solution{
    private long [] sums;
    private void solve(){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();
        int [] arr = new int[n];
        this.sums = new long[n];
        for(int i = 0; i < n; i++){
            arr[i] = sc.nextInt();
            sums[i] = arr[i] + (i == 0 ? 0 : sums[i - 1]);
        }
        long ans = 0;
        for(int i = 1; i <= n && i <= m; i++){
            ans = Math.max(ans, sum(0, i - 1) - k);
        }
        long [] dp = new long[n];
        for(int i = 0; i < n; i++){
            if(i + 1 >= m){
                long cur = sum(i - m + 1, i) - k;
                if(i - m >= 0){
                    cur += dp[i - m];
                }
                dp[i] = Math.max(dp[i], cur);
            }
            for(int j = 0; j <= m && i + j < n; j++){
                ans = Math.max(ans, dp[i] + sum(i + 1, i + j) - k * (j > 0 ? 1 : 0));
            }
        }
        System.out.println(ans);
    }
    private long sum(int l, int r){
        if(l <= 0){
            return sums[r];
        }else{
            return sums[r] - sums[l - 1];
        }
    }
    public static void main(String [] args){
        new Solution().solve();
    }
}",,CorCod,460,460
"
// A Java program to implement greedy algorithm for graph coloring 
import
java.io.*; 
import
java.util.*; 
import
java.util.LinkedList; 

// This class represents an undirected graph using adjacency list 
class
Graph 
{ 

private
int
V; 
// No. of vertices 

private
LinkedList<Integer> adj[]; 
//Adjacency List 


//Constructor 

Graph(
int
v) 

{ 

V = v; 

adj = 
new
LinkedList[v]; 

for
(
int
i=
0
; i<v; ++i) 

adj[i] = 
new
LinkedList(); 

} 


//Function to add an edge into the graph 

void
addEdge(
int
v,
int
w) 

{ 

adj[v].add(w); 

adj[w].add(v); 
//Graph is undirected 

} 


// Assigns colors (starting from 0) to all vertices and 

// prints the assignment of colors 

void
greedyColoring() 

{ 

int
result[] = 
new
int
[V]; 


// Initialize all vertices as unassigned 

Arrays.fill(result, -
1
); 


// Assign the first color to first vertex 

result[
0
] = 
0
; 


// A temporary array to store the available colors. False 

// value of available[cr] would mean that the color cr is 

// assigned to one of its adjacent vertices 

boolean
available[] = 
new
boolean
[V]; 


// Initially, all colors are available 

Arrays.fill(available, 
true
); 


// Assign colors to remaining V-1 vertices 

for
(
int
u = 
1
; u < V; u++) 

{ 

// Process all adjacent vertices and flag their colors 

// as unavailable 

Iterator<Integer> it = adj[u].iterator() ; 

while
(it.hasNext()) 

{ 

int
i = it.next(); 

if
(result[i] != -
1
) 

available[result[i]] = 
false
; 

} 


// Find the first available color 

int
cr; 

for
(cr = 
0
; cr < V; cr++){ 

if
(available[cr]) 

break
; 

} 


result[u] = cr; 
// Assign the found color 


// Reset the values back to true for the next iteration 

Arrays.fill(available, 
true
); 

} 


// print the result 

for
(
int
u = 
0
; u < V; u++) 

System.out.println(
""Vertex ""
+ u + 
"" ---> Color ""

+ result[u]); 

} 


// Driver method 

public
static
void
main(String args[]) 

{ 

Graph g1 = 
new
Graph(
5
); 

g1.addEdge(
0
, 
1
); 

g1.addEdge(
0
, 
2
); 

g1.addEdge(
1
, 
2
); 

g1.addEdge(
1
, 
3
); 

g1.addEdge(
2
, 
3
); 

g1.addEdge(
3
, 
4
); 

System.out.println(
""Coloring of graph 1""
); 

g1.greedyColoring(); 


System.out.println(); 

Graph g2 = 
new
Graph(
5
); 

g2.addEdge(
0
, 
1
); 

g2.addEdge(
0
, 
2
); 

g2.addEdge(
1
, 
2
); 

g2.addEdge(
1
, 
4
); 

g2.addEdge(
2
, 
4
); 

g2.addEdge(
4
, 
3
); 

System.out.println(
""Coloring of graph 2 ""
); 

g2.greedyColoring(); 

} 
} 
// This code is contributed by Aakash Hasija ",,CorCod,466,466
"
// A simple Java program to 
//count pairs with difference k 
import
java.util.*; 
import
java.io.*; 

class
GFG { 


static
int
countPairsWithDiffK(
int
arr[], 

int
n, 
int
k) 

{ 

int
count = 
0
; 


// Pick all elements one by one 

for
(
int
i = 
0
; i < n; i++) 

{ 

// See if there is a pair 

// of this picked element 

for
(
int
j = i + 
1
; j < n; j++) 

if
(arr[i] - arr[j] == k || 

arr[j] - arr[i] == k) 

count++; 

} 

return
count; 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

int
arr[] = { 
1
, 
5
, 
3
, 
4
, 
2
}; 

int
n = arr.length; 

int
k = 
3
; 

System.out.println(
""Count of pairs with given diff is ""

+ countPairsWithDiffK(arr, n, k)); 

} 
} 

// This code is contributed 
// by Sahil_Bansall ",,CorCod,495,495
"
// A Simple Java program to find longest common 
// subarray of two binary arrays with same sum 

class
Test 
{ 

static
int
arr1[] = 
new
int
[]{
0
, 
1
, 
0
, 
1
, 
1
, 
1
, 
1
}; 

static
int
arr2[] = 
new
int
[]{
1
, 
1
, 
1
, 
1
, 
1
, 
0
, 
1
}; 


// Returns length of the longest common sum in arr1[] 

// and arr2[]. Both are of same size n. 

static
int
longestCommonSum(
int
n) 

{ 

// Initialize result 

int
maxLen = 
0
; 


// One by one pick all possible starting points 

// of subarrays 

for
(
int
i=
0
; i<n; i++) 

{ 

// Initialize sums of current subarrays 

int
sum1 = 
0
, sum2 = 
0
; 


// Conider all points for starting with arr[i] 

for
(
int
j=i; j<n; j++) 

{ 

// Update sums 

sum1 += arr1[j]; 

sum2 += arr2[j]; 


// If sums are same and current length is 

// more than maxLen, update maxLen 

if
(sum1 == sum2) 

{ 

int
len = j-i+
1
; 

if
(len > maxLen) 

maxLen = len; 

} 

} 

} 

return
maxLen; 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

System.out.print(
""Length of the longest common span with same sum is ""
); 

System.out.println(longestCommonSum(arr1.length)); 

} 
} ",,CorCod,518,518
"
// A Java program for Dijkstra's single source shortest path algorithm. 
// The program is for adjacency matrix representation of the graph 
import
java.util.*; 
import
java.lang.*; 
import
java.io.*; 

class
ShortestPath 
{ 

// A utility function to find the vertex with minimum distance value, 

// from the set of vertices not yet included in shortest path tree 

static
final
int
V=
9
; 

int
minDistance(
int
dist[], Boolean sptSet[]) 

{ 

// Initialize min value 

int
min = Integer.MAX_VALUE, min_index=-
1
; 


for
(
int
v = 
0
; v < V; v++) 

if
(sptSet[v] == 
false
&& dist[v] <= min) 

{ 

min = dist[v]; 

min_index = v; 

} 


return
min_index; 

} 


// A utility function to print the constructed distance array 

void
printSolution(
int
dist[], 
int
n) 

{ 

System.out.println(
""Vertex Distance from Source""
); 

for
(
int
i = 
0
; i < V; i++) 

System.out.println(i+
"" tt ""
+dist[i]); 

} 


// Funtion that implements Dijkstra's single source shortest path 

// algorithm for a graph represented using adjacency matrix 

// representation 

void
dijkstra(
int
graph[][], 
int
src) 

{ 

int
dist[] = 
new
int
[V]; 
// The output array. dist[i] will hold 

// the shortest distance from src to i 


// sptSet[i] will true if vertex i is included in shortest 

// path tree or shortest distance from src to i is finalized 

Boolean sptSet[] = 
new
Boolean[V]; 


// Initialize all distances as INFINITE and stpSet[] as false 

for
(
int
i = 
0
; i < V; i++) 

{ 

dist[i] = Integer.MAX_VALUE; 

sptSet[i] = 
false
; 

} 


// Distance of source vertex from itself is always 0 

dist[src] = 
0
; 


// Find shortest path for all vertices 

for
(
int
count = 
0
; count < V-
1
; count++) 

{ 

// Pick the minimum distance vertex from the set of vertices 

// not yet processed. u is always equal to src in first 

// iteration. 

int
u = minDistance(dist, sptSet); 


// Mark the picked vertex as processed 

sptSet[u] = 
true
; 


// Update dist value of the adjacent vertices of the 

// picked vertex. 

for
(
int
v = 
0
; v < V; v++) 


// Update dist[v] only if is not in sptSet, there is an 

// edge from u to v, and total weight of path from src to 

// v through u is smaller than current value of dist[v] 

if
(!sptSet[v] && graph[u][v]!=
0
&& 

dist[u] != Integer.MAX_VALUE && 

dist[u]+graph[u][v] < dist[v]) 

dist[v] = dist[u] + graph[u][v]; 

} 


// print the constructed distance array 

printSolution(dist, V); 

} 


// Driver method 

public
static
void
main (String[] args) 

{ 

/* Let us create the example graph discussed above */

int
graph[][] = 
new
int
[][]{{
0
, 
4
, 
0
, 
0
, 
0
, 
0
, 
0
, 
8
, 
0
}, 

{
4
, 
0
, 
8
, 
0
, 
0
, 
0
, 
0
, 
11
, 
0
}, 

{
0
, 
8
, 
0
, 
7
, 
0
, 
4
, 
0
, 
0
, 
2
}, 

{
0
, 
0
, 
7
, 
0
, 
9
, 
14
, 
0
, 
0
, 
0
}, 

{
0
, 
0
, 
0
, 
9
, 
0
, 
10
, 
0
, 
0
, 
0
}, 

{
0
, 
0
, 
4
, 
14
, 
10
, 
0
, 
2
, 
0
, 
0
}, 

{
0
, 
0
, 
0
, 
0
, 
0
, 
2
, 
0
, 
1
, 
6
}, 

{
8
, 
11
, 
0
, 
0
, 
0
, 
0
, 
1
, 
0
, 
7
}, 

{
0
, 
0
, 
2
, 
0
, 
0
, 
0
, 
6
, 
7
, 
0
} 

}; 

ShortestPath t = 
new
ShortestPath(); 

t.dijkstra(graph, 
0
); 

} 
} 
//This code is contributed by Aakash Hasija ",,CorCod,522,522
"
// Java program to find maximum sum increasing 
// subsequence tiint i-th index and including 
// k-th index. 
class
GFG { 


static
int
pre_compute(
int
a[], 
int
n, 

int
index, 
int
k) 

{ 

int
dp[][] = 
new
int
[n][n]; 


// Initializing the first row of 

// the dp[][]. 

for
(
int
i = 
0
; i < n; i++) { 

if
(a[i] > a[
0
]) 

dp[
0
][i] = a[i] + a[
0
]; 

else

dp[
0
][i] = a[i]; 

} 


// Creating the dp[][] matrix. 

for
(
int
i = 
1
; i < n; i++) 

{ 

for
(
int
j = 
0
; j < n; j++) 

{ 

if
(a[j] > a[i] && j > i) 

{ 

if
(dp[i - 
1
][i] + a[j] > 

dp[i - 
1
][j]) 

dp[i][j] = dp[i - 
1
][i] 

+ a[j]; 

else

dp[i][j] = dp[i - 
1
][j]; 

} 

else

dp[i][j] = dp[i - 
1
][j]; 

} 

} 


// To calculate for i=4 and k=6. 

return
dp[index][k]; 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

int
a[] = { 
1
, 
101
, 
2
, 
3
, 
100
, 
4
, 
5
}; 

int
n = a.length; 

int
index = 
4
, k = 
6
; 

System.out.println( 

pre_compute(a, n, index, k)); 

} 
} 

// This code is contributed by Smitha. ",,CorCod,528,528
"
// Java Program to construct ancestor matrix for a given tree 
import
java.util.*; 

class
GFG 
{ 

// ancestorMatrix function to populate the matrix of 

public
static
void
ancestorMatrix(Node root , 

int
matrix[][],
int
size) 

{ 


// base case: 

if
(root==
null
) 

return
; 


// call recursively for a preorder {left} 

ancestorMatrix(root.left, matrix, size); 


// call recursively for preorder {right} 

ancestorMatrix(root.right, matrix, size); 


// here we will reach the root node automatically 

// try solving on pen and paper 


if
(root.left != 
null
) 

{ 

// make the current node as parent of its children node 

matrix[root.data][root.left.data] = 
1
; 


// iterate through all the columns of children node 

// all nodes which are children to 

// children of root node will also 

// be children of root node 

for
(
int
i = 
0
; i < size; i++) 

{ 

// if children of root node is a parent 

// of someone (i.e 1) then make that node 

// as children of root also 

if
(matrix[root.left.data][i] == 
1
) 

matrix[root.data][i] = 
1
; 

} 

} 


// same procedure followed for right node as well 

if
(root.right != 
null
) 

{ 

matrix[root.data][root.right.data] = 
1
; 


for
(
int
i = 
0
; i < size; i++) 

{ 

if
(matrix[root.right.data][i]==
1
) 

matrix[root.data][i] = 
1
; 

} 

} 



} 


// Driver program to test the program 

public
static
void
main(String[] args) 

{ 


// construct the binary tree as follows 

Node tree_root = 
new
Node(
5
); 

tree_root.left = 
new
Node (
1
); 

tree_root.right = 
new
Node(
2
); 

tree_root.left.left = 
new
Node(
0
); 

tree_root.left.right = 
new
Node(
4
); 

tree_root.right.left = 
new
Node(
3
); 


// size of matrix 

int
size = 
6
; 

int
matrix [][] = 
new
int
[size][size]; 


ancestorMatrix(tree_root, matrix, size); 


for
(
int
i = 
0
; i < size; i++) 

{ 

for
(
int
j = 
0
; j < size; j++) 

{ 

System.out.print(matrix[i][j]+
"" ""
); 

} 

System.out.println(); 

} 

} 


// node class for tree node 

static
class
Node 

{ 

public
int
data ; 

public
Node left ,right; 

public
Node (
int
data) 

{ 

this
.data = data; 

this
.left = 
this
.right = 
null
; 

} 

} 
} 

// This code is contributed by Sparsh Singhal ",,CorCod,532,532
"
// A Naive Java program to find 
// maximum sum rotation 
import
java.util.*; 
import
java.io.*; 

class
GFG { 

// Returns maximum value of i*arr[i] 
static
int
maxSum(
int
arr[], 
int
n) 
{ 
// Initialize result 
int
res = Integer.MIN_VALUE; 

// Consider rotation beginning with i 
// for all possible values of i. 
for
(
int
i = 
0
; i < n; i++) 
{ 


// Initialize sum of current rotation 

int
curr_sum = 
0
; 


// Compute sum of all values. We don't 

// actually rotation the array, but compute 

// sum by finding ndexes when arr[i] is 

// first element 

for
(
int
j = 
0
; j < n; j++) 

{ 

int
index = (i + j) % n; 

curr_sum += j * arr[index]; 

} 


// Update result if required 

res = Math.max(res, curr_sum); 
} 

return
res; 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

int
arr[] = {
8
, 
3
, 
1
, 
2
}; 

int
n = arr.length; 

System.out.println(maxSum(arr, n)); 
} 


} 

// This code is contributed by Sahil_Bansall ",,CorCod,555,555
"
// Java program to check if there exist an edge whose 
// removal creates two trees of same size 

class
Node 
{ 

int
key; 

Node left, right; 


public
Node(
int
key) 

{ 

this
.key = key; 

left = right = 
null
; 

} 
} 

class
BinaryTree 
{ 

Node root; 


// To calculate size of tree with given root 

int
count(Node node) 

{ 

if
(node == 
null
) 

return
0
; 


return
count(node.left) + count(node.right) + 
1
; 

} 


// This function returns true if there is an edge 

// whose removal can divide the tree in two halves 

// n is size of tree 

boolean
checkRec(Node node, 
int
n) 

{ 

// Base cases 

if
(node == 
null
) 

return
false
; 


// Check for root 

if
(count(node) == n - count(node)) 

return
true
; 


// Check for rest of the nodes 

return
checkRec(node.left, n) 

|| checkRec(node.right, n); 

} 


// This function mainly uses checkRec() 

boolean
check(Node node) 

{ 

// Count total nodes in given tree 

int
n = count(node); 


// Now recursively check all nodes 

return
checkRec(node, n); 

} 


// Driver code 

public
static
void
main(String[] args) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

tree.root = 
new
Node(
5
); 

tree.root.left = 
new
Node(
1
); 

tree.root.right = 
new
Node(
6
); 

tree.root.left.left = 
new
Node(
3
); 

tree.root.right.left = 
new
Node(
7
); 

tree.root.right.right = 
new
Node(
4
); 

if
(tree.check(tree.root)==
true
) 

System.out.println(
""YES""
); 

else

System.out.println(
""NO""
); 

} 
} 

// This code has been contributed by Mayank Jaiswal(mayank_24) ",,CorCod,556,556
"
// Java implementation of simple method to find 
// minimum difference between any pair 

class
GFG 
{ 

// Returns minimum difference between any pair 

static
int
findMinDiff(
int
[] arr, 
int
n) 

{ 

// Initialize difference as infinite 

int
diff = Integer.MAX_VALUE; 


// Find the min diff by comparing difference 

// of all possible pairs in given array 

for
(
int
i=
0
; i<n-
1
; i++) 

for
(
int
j=i+
1
; j<n; j++) 

if
(Math.abs((arr[i] - arr[j]) )< diff) 

diff = Math.abs((arr[i] - arr[j])); 


// Return min diff 

return
diff; 

} 


// Driver method to test the above function 

public
static
void
main(String[] args) 

{ 

int
arr[] = 
new
int
[]{
1
, 
5
, 
3
, 
19
, 
18
, 
25
}; 

System.out.println(
""Minimum difference is ""
+ 

findMinDiff(arr, arr.length)); 


} 
} ",,CorCod,558,558
"import java.io.*;
import java.util.*;

public class Main {

    private static void solve(InputReader in, OutputWriter out) {
        int n = in.nextInt();
        int m = in.nextInt();

        String[] sa = new String[n];
        for (int i = 0; i < n; i++) {
            sa[i] = in.next();
        }

        Set<Integer> switches = new HashSet<>();
        for (int i = 0; i < m; i++) {
            int cnt = 0, swtch = -1;
            for (int j = 0; j < n; j++) {
                if (sa[j].charAt(i) == '1') {
                    cnt++;
                    swtch = j;
                    if (cnt > 1)
                        break;
                }
            }

            if (cnt == 1) {
                switches.add(swtch);
            }
        }

        out.print(switches.size() == n ? ""NO"" : ""YES"");
    }

    private static void shuffleArray(int[] array) {
        int index;
        Random random = new Random();
        for (int i = array.length - 1; i > 0; i--) {
            index = random.nextInt(i + 1);
            if (index != i) {
                array[index] ^= array[i];
                array[i] ^= array[index];
                array[index] ^= array[i];
            }
        }
    }

    public static void main(String[] args) {
        InputReader in = new InputReader(System.in);
        OutputWriter out = new OutputWriter(System.out);
        solve(in, out);
        in.close();
        out.close();
    }

    private static class InputReader {
        private BufferedReader br;
        private StringTokenizer st;

        InputReader(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
            st = null;
        }

        String nextLine() {
            String line = null;
            try {
                line = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return line;
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                String line = nextLine();
                if (line == null) return null;
                st = new StringTokenizer(line);
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        void close() {
            try {
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private static class OutputWriter {
        BufferedWriter bw;

        OutputWriter(OutputStream os) {
            bw = new BufferedWriter(new OutputStreamWriter(os));
        }

        void print(int i) {
            print(Integer.toString(i));
        }

        void println(int i) {
            println(Integer.toString(i));
        }

        void print(long l) {
            print(Long.toString(l));
        }

        void println(long l) {
            println(Long.toString(l));
        }

        void print(double d) {
            print(Double.toString(d));
        }

        void println(double d) {
            println(Double.toString(d));
        }

        void print(boolean b) {
            print(Boolean.toString(b));
        }

        void println(boolean b) {
            println(Boolean.toString(b));
        }

        void print(char c) {
            try {
                bw.write(c);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        void println(char c) {
            println(Character.toString(c));
        }

        void print(String s) {
            try {
                bw.write(s);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        void println(String s) {
            print(s);
            print('\n');
        }

        void close() {
            try {
                bw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
",,CorCod,570,570
"
// Java program to print postorder 
// traversal from preorder and 
// inorder traversals 
import
java.util.Arrays; 

class
GFG 
{ 

// A utility function to search x in arr[] of size n 
static
int
search(
int
arr[], 
int
x, 
int
n) 
{ 

for
(
int
i = 
0
; i < n; i++) 

if
(arr[i] == x) 

return
i; 

return
-
1
; 
} 

// Prints postorder traversal from 
// given inorder and preorder traversals 
static
void
printPostOrder(
int
in1[], 

int
pre[], 
int
n) 
{ 

// The first element in pre[] is 

// always root, search it in in[] 

// to find left and right subtrees 

int
root = search(in1, pre[
0
], n); 


// If left subtree is not empty, 

// print left subtree 

if
(root != 
0
) 

printPostOrder(in1, Arrays.copyOfRange(pre, 
1
, n), root); 


// If right subtree is not empty, 

// print right subtree 

if
(root != n - 
1
) 

printPostOrder(Arrays.copyOfRange(in1, root+
1
, n), 

Arrays.copyOfRange(pre, 
1
+root, n), n - root - 
1
); 


// Print root 

System.out.print( pre[
0
] + 
"" ""
); 
} 

// Driver code 
public
static
void
main(String args[]) 
{ 

int
in1[] = { 
4
, 
2
, 
5
, 
1
, 
3
, 
6
}; 

int
pre[] = { 
1
, 
2
, 
4
, 
5
, 
3
, 
6
}; 

int
n = in1.length; 

System.out.println(
""Postorder traversal ""
); 

printPostOrder(in1, pre, n); 
} 
} 
// This code is contributed by Arnab Kundu ",,CorCod,571,571
"//package codeforces;

import java.util.Scanner;

public class Fingerprints {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);

		int[] code = new int[scanner.nextInt()];
		int[] prints = new int[scanner.nextInt()];

		for (int i = 0; i < code.length; i++) {
			code[i] = scanner.nextInt();
		}
		for (int i = 0; i < prints.length; i++) {
			prints[i] = scanner.nextInt();
		}
		for (int i = 0; i < code.length; i++) {
			for (int j = 0; j < prints.length; j++) {
				if (code[i] == prints[j]) {
					System.out.print(prints[j] + "" "");
				}
			}
		}
		scanner.close();
	}

}
",,CorCod,572,572
"
// Java program to construct a tree using inorder and preorder traversal 

/* A binary tree node has data, pointer to left child 

and a pointer to right child */
class
Node { 

char
data; 

Node left, right; 


Node(
char
item) 

{ 

data = item; 

left = right = 
null
; 

} 
} 

class
BinaryTree { 

Node root; 

static
int
preIndex = 
0
; 


/* Recursive function to construct binary of size len from 

Inorder traversal in[] and Preorder traversal pre[]. 

Initial values of inStrt and inEnd should be 0 and len -1. 

The function doesn't do any error checking for cases where 

inorder and preorder do not form a tree */

Node buildTree(
char
in[], 
char
pre[], 
int
inStrt, 
int
inEnd) 

{ 

if
(inStrt > inEnd) 

return
null
; 


/* Pick current node from Preorder traversal using preIndex 

and increment preIndex */

Node tNode = 
new
Node(pre[preIndex++]); 


/* If this node has no children then return */

if
(inStrt == inEnd) 

return
tNode; 


/* Else find the index of this node in Inorder traversal */

int
inIndex = search(in, inStrt, inEnd, tNode.data); 


/* Using index in Inorder traversal, construct left and 

right subtress */

tNode.left = buildTree(in, pre, inStrt, inIndex - 
1
); 

tNode.right = buildTree(in, pre, inIndex + 
1
, inEnd); 


return
tNode; 

} 


/* UTILITY FUNCTIONS */


/* Function to find index of value in arr[start...end] 

The function assumes that value is present in in[] */

int
search(
char
arr[], 
int
strt, 
int
end, 
char
value) 

{ 

int
i; 

for
(i = strt; i <= end; i++) { 

if
(arr[i] == value) 

return
i; 

} 

return
i; 

} 


/* This funtcion is here just to test buildTree() */

void
printInorder(Node node) 

{ 

if
(node == 
null
) 

return
; 


/* first recur on left child */

printInorder(node.left); 


/* then print the data of node */

System.out.print(node.data + 
"" ""
); 


/* now recur on right child */

printInorder(node.right); 

} 


// driver program to test above functions 

public
static
void
main(String args[]) 

{ 

BinaryTree tree = 
new
BinaryTree(); 

char
in[] = 
new
char
[] { 
'D'
, 
'B'
, 
'E'
, 
'A'
, 
'F'
, 
'C'
}; 

char
pre[] = 
new
char
[] { 
'A'
, 
'B'
, 
'D'
, 
'E'
, 
'C'
, 
'F'
}; 

int
len = in.length; 

Node root = tree.buildTree(in, pre, 
0
, len - 
1
); 


// building the tree by printing inorder traversal 

System.out.println(
""Inorder traversal of constructed tree is : ""
); 

tree.printInorder(root); 

} 
} 

// This code has been contributed by Mayank Jaiswal ",,CorCod,584,584
"import java.util.*;
import java.math.*;
public class Split {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n= sc.nextInt();
		int k= sc.nextInt();
		int a[] = new int[n];
		int d[] = new int[n-1];
		for(int i=0;i<n;i++) {
			a[i] = sc.nextInt();
			if(i>0)
				d[i-1] = a[i-1] - a[i];
		}
		Arrays.sort(d);
		int t = 0;
		for(int i=0;i<k-1;i++)
			t += d[i];
		System.out.println(a[n-1]-a[0]+t);
	}

}
",,CorCod,586,586
"/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Main
{
	public static void main (String[] args) throws java.lang.Exception
	{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		int n=Integer.parseInt(br.readLine());
		int[] A=new int[n];
		String[] s=br.readLine().split("" "");
		for(int i=0;i<n;i++){
			A[i]=Integer.parseInt(s[i]);
		}
		Map memo=new HashMap();
		int[] f=new int[n];
		for(int i=0;i<n;i++){
			if(!memo.containsKey(A[i])){
				memo.put(A[i],1);
			}
			else{
				int ct=(int)memo.get(A[i]);
				memo.put(A[i],ct+1);
			}
			int tot=0;
			if(memo.containsKey(A[i]-1)){
				tot+=(int)memo.get(A[i]-1);
			}
			if(memo.containsKey(A[i]+1)){
				tot+=(int)memo.get(A[i]+1);
			}
			tot+=(int)memo.get(A[i]);
			f[i]=tot;
		}
		BigInteger res=new BigInteger(""0"");
		for(int i=0;i<n;i++){
			int tot1=i+1-f[i];
			int tot2=0;
			if(memo.containsKey(A[i]-1)){
				tot2+=(int)memo.get(A[i]-1);
			}
			if(memo.containsKey(A[i]+1)){
				tot2+=(int)memo.get(A[i]+1);
			}
			tot2+=(int)memo.get(A[i]);
			tot2=n-i-1-(tot2-f[i]);
			//res+=(long)(tot1-tot2)*(long)A[i];
			res=res.add(BigInteger.valueOf((long)(tot1-tot2)*(long)A[i]));
		}
		System.out.println(res);
	}
}",,CorCod,594,594
"
// Java Program to find max subarray 
// sum excluding some elements 
import
java.util.*; 

class
GFG 
{ 


// Utility function for findMaxSubarraySum() 

// with the following parameters 

// A => Array A, 

// B => Array B, 

// n => Number of elements in Array A, 

// m => Number of elements in Array B 

static
int
findMaxSubarraySumUtil(
int
A[], 
int
B[], 

int
n, 
int
m) 

{ 


// set max_so_far to INT_MIN 

int
max_so_far = Integer.MIN_VALUE, curr_max = 
0
; 


for
(
int
i = 
0
; i < n; i++) 

{ 


// if the element is present in B, 

// set current max to 0 and move to 

// the next element 

if
(Arrays.binarySearch(B, A[i]) >= 
0
) 

{ 

curr_max = 
0
; 

continue
; 

} 


// Proceed as in Kadane's Algorithm 

curr_max = Math.max(A[i], curr_max + A[i]); 

max_so_far = Math.max(max_so_far, curr_max); 

} 

return
max_so_far; 

} 


// Wrapper for findMaxSubarraySumUtil() 

static
void
findMaxSubarraySum(
int
A[], 
int
B[], 

int
n, 
int
m) 

{ 

// sort array B to apply Binary Search 

Arrays.sort(B); 


int
maxSubarraySum = findMaxSubarraySumUtil(A, B, 

n, m); 


// This case will occour when all elements 

// of A are present in B, thus no subarray 

// can be formed 

if
(maxSubarraySum == Integer.MIN_VALUE) 

{ 

System.out.println(
""Maximum subarray sum cant be found""
); 

} 

else

{ 

System.out.println(
""The Maximum subarray sum = ""

+ maxSubarraySum); 

} 

} 


// Driver Code 

public
static
void
main(String[] args) 

{ 

int
A[] = {
3
, 
4
, 
5
, -
4
, 
6
}; 

int
B[] = {
1
, 
8
, 
5
}; 


int
n = A.length; 

int
m = B.length; 


// Calling fucntion 

findMaxSubarraySum(A, B, n, m); 

} 
} 

// This code has been contributed by 29AjayKumar ",,CorCod,607,607
"
// Java code to find maximum triplet sum 
import
java.io.*; 
import
java.util.*; 


class
GFG { 


// This function assumes that there are 

// at least three elements in arr[]. 

static
int
maxTripletSum(
int
arr[], 
int
n) 

{ 

// sort the given array 

Arrays.sort(arr); 


// After sorting the array. 

// Add last three element 

// of the given array 

return
arr[n - 
1
] + arr[n - 
2
] + arr[n - 
3
]; 

} 


// Driven code 

public
static
void
main(String args[]) 

{ 

int
arr[] = { 
1
, 
0
, 
8
, 
6
, 
4
, 
2
}; 

int
n = arr.length; 

System.out.println(maxTripletSum(arr, n)); 

} 
} 


// This code is contributed by Nikita Tiwari. ",,CorCod,610,610
"
// Java program to find the sum 
// in a given range in an array 
// using sparse table. 
class
GFG 
{ 

// Because 2^17 is larger than 10^5 
static
int
k = 
16
; 

// Maximum value of array 
static
int
N = 
100000
; 

// k + 1 because we need 
// to access table[r][k] 
static
long
table[][] = 
new
long
[N][k + 
1
]; 

// it builds sparse table. 
static
void
buildSparseTable(
int
arr[], 

int
n) 
{ 

for
(
int
i = 
0
; i < n; i++) 

table[i][
0
] = arr[i]; 


for
(
int
j = 
1
; j <= k; j++) 

for
(
int
i = 
0
; i <= n - (
1
<< j); i++) 

table[i][j] = table[i][j - 
1
] + 

table[i + (
1
<< (j - 
1
))][j - 
1
]; 
} 

// Returns the sum of the 
// elements in the range L and R. 
static
long
query(
int
L, 
int
R) 
{ 

// boundaries of next query, 

// 0-indexed 

long
answer = 
0
; 

for
(
int
j = k; j >= 
0
; j--) 

{ 

if
(L + (
1
<< j) - 
1
<= R) 

{ 

answer = answer + table[L][j]; 


// instead of having L', we 

// increment L directly 

L += 
1
<< j; 

} 

} 

return
answer; 
} 

// Driver Code 
public
static
void
main(String args[]) 
{ 

int
arr[] = { 
3
, 
7
, 
2
, 
5
, 
8
, 
9
}; 

int
n = arr.length; 


buildSparseTable(arr, n); 


System.out.println(query(
0
, 
5
)); 

System.out.println(query(
3
, 
5
)); 

System.out.println(query(
2
, 
4
)); 
} 
} 

// This code is contributed 
// by Kirti_Mangal ",,CorCod,612,612
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;
import java.util.StringTokenizer;

public class c {
	public static void main(String[] args) throws IOException {
		FastScanner in = new FastScanner(System.in);
		int n = in.nextInt(), m = in.nextInt();
		long bounty = in.nextInt(), increase = in.nextInt();
		int damage = in.nextInt();
		int[] mh = new int[n];
		int[] sh = new int[n];
		int[] reg = new int[n];
		long countKilled = 0;
		ArrayList<Event> es = new ArrayList<>();
		Event[] regen = new Event[n];
		for(int i=0;i<n;i++) {
			mh[i] = in.nextInt();
			sh[i] = in.nextInt();
			reg[i] = in.nextInt();
			if(sh[i] <= damage)
				countKilled++;
			if(reg[i] > 0) {
				int time = (damage+1 - sh[i]+reg[i]-1)/reg[i];
				if(time > 0 && mh[i] >= damage+1) {
					Event e2 = new Event(time, i, damage+1);
					regen[i] = e2;
					es.add(e2);
				}
			}
		}
		for(int i=0;i<m;i++) {
			Event e = new Event(in.nextInt(), in.nextInt()-1, in.nextInt());
			es.add(e);
			if(reg[e.e] > 0) {
				int time = (damage+1 - e.h+reg[e.e]-1)/reg[e.e];
				if(time > 0 && mh[e.e] >= damage+1) {
					Event e2 = new Event(e.t + time, e.e, damage+1);
					e.regen = e2;
					es.add(e2);
				}
			}
		}
		Collections.sort(es, (a,b) -> a.t-b.t);
		long ans = countKilled*bounty;
		int lastTime = 0;
		for(Event e : es) {
			if(e.t == -1) continue;
			if(regen[e.e] != e && regen[e.e] != null) {
				regen[e.e].t = -1;
				regen[e.e] = null;
			}
			if(lastTime != e.t) {
				ans = Math.max(ans, countKilled*(bounty+(e.t-1)*increase));
			}
			if(sh[e.e] <= damage)
				countKilled--;
			sh[e.e] = e.h;
			if(sh[e.e] <= damage)
				countKilled++;
			if(e.regen != null) {
				regen[e.e] = e.regen;
			}
			lastTime = e.t;
		}
		if(countKilled != 0) {
			if(increase > 0)
				ans = -1;
			else
				ans = Math.max(ans, countKilled*bounty);
		}
		System.out.println(ans);
	}
	static class Event {
		int t;
		int e;
		int h;
		Event regen;
		public Event(int tt, int ee, int hh) {
			t = tt;
			e = ee;
			h = hh;
		}
	}
	static class FastScanner {
	    BufferedReader br;
	    StringTokenizer st;
	    public FastScanner(InputStream i) {
	        br = new BufferedReader(new InputStreamReader(i));
	        st = new StringTokenizer("""");
	    }
	    public String next() throws IOException {
	        if(st.hasMoreTokens())
	            return st.nextToken();
	        else
	            st = new StringTokenizer(br.readLine());
	        return next();
	    }
	    public int nextInt() throws IOException {
	        return Integer.parseInt(next());
	    }
	    public long nextLong() throws IOException {
	        return Long.parseLong(next());
	    }
	    public double nextDouble() throws IOException {
	        return Double.parseDouble(next());
	    }
	}
}
",,CorCod,619,619
"
// Java program for Kruskal's algorithm to find Minimum 
// Spanning Tree of a given connected, undirected and 
// weighted graph 
import
java.util.*; 
import
java.lang.*; 
import
java.io.*; 

class
Graph 
{ 

// A class to represent a graph edge 

class
Edge 
implements
Comparable<Edge> 

{ 

int
src, dest, weight; 


// Comparator function used for sorting edges 

// based on their weight 

public
int
compareTo(Edge compareEdge) 

{ 

return
this
.weight-compareEdge.weight; 

} 

}; 


// A class to represent a subset for union-find 

class
subset 

{ 

int
parent, rank; 

}; 


int
V, E; 
// V-> no. of vertices & E->no.of edges 

Edge edge[]; 
// collection of all edges 


// Creates a graph with V vertices and E edges 

Graph(
int
v, 
int
e) 

{ 

V = v; 

E = e; 

edge = 
new
Edge[E]; 

for
(
int
i=
0
; i<e; ++i) 

edge[i] = 
new
Edge(); 

} 


// A utility function to find set of an element i 

// (uses path compression technique) 

int
find(subset subsets[], 
int
i) 

{ 

// find root and make root as parent of i (path compression) 

if
(subsets[i].parent != i) 

subsets[i].parent = find(subsets, subsets[i].parent); 


return
subsets[i].parent; 

} 


// A function that does union of two sets of x and y 

// (uses union by rank) 

void
Union(subset subsets[], 
int
x, 
int
y) 

{ 

int
xroot = find(subsets, x); 

int
yroot = find(subsets, y); 


// Attach smaller rank tree under root of high rank tree 

// (Union by Rank) 

if
(subsets[xroot].rank < subsets[yroot].rank) 

subsets[xroot].parent = yroot; 

else
if
(subsets[xroot].rank > subsets[yroot].rank) 

subsets[yroot].parent = xroot; 


// If ranks are same, then make one as root and increment 

// its rank by one 

else

{ 

subsets[yroot].parent = xroot; 

subsets[xroot].rank++; 

} 

} 


// The main function to construct MST using Kruskal's algorithm 

void
KruskalMST() 

{ 

Edge result[] = 
new
Edge[V]; 
// Tnis will store the resultant MST 

int
e = 
0
; 
// An index variable, used for result[] 

int
i = 
0
; 
// An index variable, used for sorted edges 

for
(i=
0
; i<V; ++i) 

result[i] = 
new
Edge(); 


// Step 1: Sort all the edges in non-decreasing order of their 

// weight. If we are not allowed to change the given graph, we 

// can create a copy of array of edges 

Arrays.sort(edge); 


// Allocate memory for creating V ssubsets 

subset subsets[] = 
new
subset[V]; 

for
(i=
0
; i<V; ++i) 

subsets[i]=
new
subset(); 


// Create V subsets with single elements 

for
(
int
v = 
0
; v < V; ++v) 

{ 

subsets[v].parent = v; 

subsets[v].rank = 
0
; 

} 


i = 
0
; 
// Index used to pick next edge 


// Number of edges to be taken is equal to V-1 

while
(e < V - 
1
) 

{ 

// Step 2: Pick the smallest edge. And increment 

// the index for next iteration 

Edge next_edge = 
new
Edge(); 

next_edge = edge[i++]; 


int
x = find(subsets, next_edge.src); 

int
y = find(subsets, next_edge.dest); 


// If including this edge does't cause cycle, 

// include it in result and increment the index 

// of result for next edge 

if
(x != y) 

{ 

result[e++] = next_edge; 

Union(subsets, x, y); 

} 

// Else discard the next_edge 

} 


// print the contents of result[] to display 

// the built MST 

System.out.println(
""Following are the edges in ""
+ 

""the constructed MST""
); 

for
(i = 
0
; i < e; ++i) 

System.out.println(result[i].src+
"" -- ""
+ 

result[i].dest+
"" == ""
+ result[i].weight); 

} 


// Driver Program 

public
static
void
main (String[] args) 

{ 


/* Let us create following weighted graph 

10 

0--------1 

| \ | 

6| 5\ |15 

| \ | 

2--------3 

4 */

int
V = 
4
; 
// Number of vertices in graph 

int
E = 
5
; 
// Number of edges in graph 

Graph graph = 
new
Graph(V, E); 


// add edge 0-1 

graph.edge[
0
].src = 
0
; 

graph.edge[
0
].dest = 
1
; 

graph.edge[
0
].weight = 
10
; 


// add edge 0-2 

graph.edge[
1
].src = 
0
; 

graph.edge[
1
].dest = 
2
; 

graph.edge[
1
].weight = 
6
; 


// add edge 0-3 

graph.edge[
2
].src = 
0
; 

graph.edge[
2
].dest = 
3
; 

graph.edge[
2
].weight = 
5
; 


// add edge 1-3 

graph.edge[
3
].src = 
1
; 

graph.edge[
3
].dest = 
3
; 

graph.edge[
3
].weight = 
15
; 


// add edge 2-3 

graph.edge[
4
].src = 
2
; 

graph.edge[
4
].dest = 
3
; 

graph.edge[
4
].weight = 
4
; 


graph.KruskalMST(); 

} 
} 
//This code is contributed by Aakash Hasija ",,CorCod,623,623
"
// Java program to find maximum pair sum whose 
// difference is less than K 

import
java.io.*; 
import
java .util.*; 

class
GFG { 


// Method to return maximum sum we can get by 

// finding less than K difference pairs 

static
int
maxSumPairWithDifferenceLessThanK(
int
arr[], 

int
N, 
int
k) 

{ 

int
maxSum = 
0
; 


// Sort elements to ensure every i and i-1 is closest 

// possible pair 

Arrays.sort(arr); 


// To get maximum possible sum, iterate from largest 

// to smallest, giving larger numbers priority over 

// smaller numbers. 

for
(
int
i = N-
1
; i > 
0
; --i) 

{ 

// Case I: Diff of arr[i] and arr[i-1] is less then K, 

// add to maxSum 

// Case II: Diff between arr[i] and arr[i-1] is not less 

// then K, move to next i since with sorting we 

// know, arr[i]-arr[i-1] < arr[i]-arr[i-2] and 

// so on. 

if
(arr[i] - arr[i-
1
] < k) 

{ 

//Assuming only positive numbers. 

maxSum += arr[i]; 

maxSum += arr[i-
1
]; 


//When a match is found skip this pair 

--i; 

} 

} 


return
maxSum; 

} 


// Driver code to test above methods 

public
static
void
main (String[] args) { 


int
arr[] = {
3
, 
5
, 
10
, 
15
, 
17
, 
12
, 
9
}; 

int
N = arr.length; 

int
K = 
4
; 


System.out.println ( maxSumPairWithDifferenceLessThanK( 

arr, N, K)); 

} 
} 

//This code is contributed by vt_m. ",,CorCod,624,624
"import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] wide = new int[n], sta = new int[n];
        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
        	wide[i] = sc.nextInt();
        	hm.put(wide[i], i + 1);
        }
        Util.sort(wide);
        sc.nextLine();
        String s = sc.nextLine();
        int tp = 0, pos = 0;
        StringBuilder out = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
        	int t;
        	if (s.charAt(i) == '0') {
        		t = wide[pos++];
        		sta[tp++] = t;
        	} else t = sta[--tp];
        	out.append(hm.get(t) + "" "");
        }
        System.out.println(out.toString());
        sc.close();
    }
    public static class Util {
    	
    	public static <T extends Comparable<T> > void merge_sort(T[] a) {
    		Object[] aux = new Object[a.length];
    		merge_sort0(a, aux, 0, a.length);
    	}
    	
    	public static <T extends Comparable<T> > void merge_sort(T[] a, int l, int r) {
    		Object[] aux = new Object[a.length];
    		merge_sort0(a, aux, l, r);
    	}
    	
    	@SuppressWarnings(""unchecked"")
    	private static <T extends Comparable<T> > void merge_sort0(T[] a, Object[] temp, int l, int r) {
    		if (l + 1 == r) return;
    		int mid = (l + r) >> 1;
    		merge_sort0(a, temp, l, mid);
    		merge_sort0(a, temp, mid, r);
    		int x = l, y = mid, c = l;
    		while (x < mid || y < r) {
    			if (y == r || (x < mid && a[x].compareTo(a[y]) <= 0)) temp[c++] = a[x++];
    			else temp[c++] = a[y++];
    		}
    		for (int i = l; i < r; i++) a[i] = (T)temp[i];
    	}
    	
    	static final Random RAN = new Random();
    	
    	public static <T extends Comparable<T> > void quick_sort(T[] a) {
    		quick_sort0(a, 0, a.length);
    	}
    	
    	public static <T extends Comparable<T> > void quick_sort(T[] a, int l, int r) {
    		quick_sort0(a, l, r);
    	}
    	
    	private static <T extends Comparable<T> > void quick_sort0(T[] a, int l, int r) {
    		if (l + 1 >= r) return;
    		int p = l + RAN.nextInt(r - l);
    		T t = a[p]; a[p] = a[l]; a[l] = t;
    		int x = l, y = r - 1;
    		while (x < y) {
    			while (x < y && a[y].compareTo(t) > 0) --y;
    			while (x < y && a[x].compareTo(t) < 0) ++x;
    			if (x < y) {
    				T b = a[x]; a[x] = a[y]; a[y] = b;
    				++x; --y;
    			}
    		}
    		quick_sort0(a, l, y + 1);
    		quick_sort0(a, x, r);
    	}
    	
    	static final int BOUND = 8;
    	
    	public static void bucket_sort(int[] a) {
    		bucket_sort(a, 0, a.length);
    	}
    	
    	public static void bucket_sort(int[] a, int l, int r) {
    		int[] cnt = new int[1 << BOUND], b = new int[r - l + 1];
    		int y = 0;
    		for (int i = l; i < r; i++) ++cnt[a[i] & (1 << BOUND) - 1];
    		while (y < Integer.SIZE) {
    			for (int i = 1; i < 1 << BOUND; i++) cnt[i] += cnt[i - 1];
    			for (int i = r - 1; i >= l; i--) b[--cnt[a[i] >> y & (1 << BOUND) - 1]] = a[i];
    			y += BOUND;
    			Arrays.fill(cnt, 0);
    			for (int i = l; i < r; i++) {
    				a[i] = b[i - l];
    				++cnt[a[i] >> y & (1 << BOUND) - 1];
    			}
    		}
    	}
    	
    	public static void bucket_sort(long[] a) {
    		bucket_sort(a, 0, a.length);
    	}
    	
    	public static void bucket_sort(long[] a, int l, int r) {
    		int[] cnt = new int[1 << BOUND];
    		long[] b = new long[r - l + 1];
    		int y = 0;
    		while (y < Long.SIZE) {
    			Arrays.fill(cnt, 0);
    			for (int i = l; i < r; i++) ++cnt[(int) (a[i] >> y & (1 << BOUND) - 1)];
    			for (int i = 1; i < 1 << BOUND; i++) cnt[i] += cnt[i - 1];
    			for (int i = r - 1; i >= l; i--) b[--cnt[(int) (a[i] >> y & (1 << BOUND) - 1)]] = a[i];
    			for (int i = l; i < r; i++) a[i] = b[i - l];
    			y += BOUND;
    		}
    	}
    	
    	public static void sort(int[] a) {
    		if (a.length <= 1 << BOUND) {
    			Integer[] b = new Integer[a.length];
    			for (int i = 0; i < a.length; i++) b[i] = a[i];
    			quick_sort(b);
    			for (int i = 0; i < a.length; i++) a[i] = b[i];
    		} else bucket_sort(a);
    	}

    	public static void sort(long[] a) {
    		if (a.length <= 1 << BOUND) {
    			Long[] b = new Long[a.length];
    			for (int i = 0; i < a.length; i++) b[i] = a[i];
    			quick_sort(b);
    			for (int i = 0; i < a.length; i++) a[i] = b[i];
    		} else bucket_sort(a);
    	}
    	
    	public static <T extends Comparable<T> > void sort(T[] a) {
    		quick_sort(a);
    	}
    	
    	public static void shuffle(int[] a) {
    		Random ran = new Random();
    		for (int i = 0; i < a.length; i++) {
    			int p = ran.nextInt(i + 1);
    			int q = a[p]; a[p] = a[i]; a[i] = q; 
    		}
    	}
    	
    	public static void shuffle(long[] a) {
    		Random ran = new Random();
    		for (int i = 0; i < a.length; i++) {
    			int p = ran.nextInt(i + 1);
    			long q = a[p]; a[p] = a[i]; a[i] = q; 
    		}
    	}
    	
    	public static <T> void shuffle(T[] a) {
    		Random ran = new Random();
    		for (int i = 0; i < a.length; i++) {
    			int p = ran.nextInt(i + 1);
    			T q = a[p]; a[p] = a[i]; a[i] = q; 
    		}
    	}
    	
    }
}",,CorCod,629,629
"import java.util.*;
import java.io.*;
import java.math.BigInteger;

public class Problem
{

    static int mod = (int) (1e9+7);
    static InputReader in;
    static PrintWriter out;
    static int[] rt;
    static int[] size;

    static void initialize(int n){
        rt = new int[n + 1];
        size = new int[n + 1];
        for(int i = 0; i < rt.length; i++){
            rt[i] = i;
            size[i] = 1;
        }
    }
    
    static int root(int x){
        while(rt[x] != x){
            rt[x] = rt[rt[x]];
            x = rt[x];
        }
        return x;
    }
    
    static long union(int x,int y){
        int root_x = root(x);
        int root_y = root(y);
        if(root_x == root_y) return 0;
        long val = size[root_x] *1l* size[root_y];
        if(size[root_x]<size[root_y]){
            rt[root_x] = rt[root_y];
            size[root_y] += size[root_x];
        }
        else{
            rt[root_y] = rt[root_x];
            size[root_x] += size[root_y];            
        }
        
        return val;
    }
    
    static void solve()
    {
        in = new InputReader(System.in);
        out = new PrintWriter(System.out);            
        
        int t = 1;
        
        while(t-- > 0){
            int n = in.nextInt();
            int[] arr = in.nextIntArray(n);
            ArrayList<Pair> list = new ArrayList<>();
            
            for(int i = 1; i < n; i++){
                int u = in.nextInt() - 1;
                int v = in.nextInt() - 1;
                list.add(new Pair(u, v, Math.max(arr[u],arr[v])));
            }
            list.sort((p1,p2) -> Integer.compare(p1.i, p2.i));
            initialize(n);
            long s1 = 0;
            for(int i = 0; i < list.size(); i++){
                s1 += union(list.get(i).x, list.get(i).y) * list.get(i).i;
            }
            for(int i = 0; i < list.size(); i++){
                Pair p = list.get(i);
                p.i = Math.min(arr[p.x],arr[p.y]);
            }
            list.sort((p1,p2) -> -Integer.compare(p1.i, p2.i));
            initialize(n);
            long s2 = 0;
            for(int i = 0; i < list.size(); i++){
                s2 += union(list.get(i).x, list.get(i).y) * list.get(i).i;
            }
            
            out.println(s1 - s2);
        }
        
        out.close();
    }
    
    public static void main(String[] args)
    {
        new Thread(null ,new Runnable(){
            public void run(){
                try{
                    solve();
                } catch(Exception e){
                    e.printStackTrace();
                }
            }
        },""1"",1<<26).start();
        
    }

    static class Pair implements Comparable<Pair>
    {

        int x,y;
        int i;


        Pair (int x,int y)
        {
                this.x = x;
                this.y = y;
        }

        Pair (int x,int y, int i)
        {
                this.x = x;
                this.y = y;
                this.i = i;
        }

        public int compareTo(Pair o)
        {
            if(this.x != o.x)
                return -Integer.compare(this.x, o.y);
            return -Integer.compare(this.y,o.y);
                //return 0;
        }

        public boolean equals(Object o)
        {
            if (o instanceof Pair)
            {
                Pair p = (Pair)o;
                return p.x == x && p.y==y;
            }
            return false;
        }

        @Override
        public String toString()
        {
            return x + "" ""+ y + "" ""+i;
        }

        /*public int hashCode()
        {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }*/

    } 

    static long add(long a,long b){
        long x=(a+b);
        while(x>=mod) x-=mod;
        return x;
    }

    static long sub(long a,long b){
        long x=(a-b);
        while(x<0) x+=mod;
        return x;
    }
    
    static long mul(long a,long b){
        long x=(a*b);
        while(x>=mod) x-=mod;
        return x;
    }
    
    static String rev(String s){
        StringBuilder sb=new StringBuilder(s);
        sb.reverse();
        return sb.toString();
    }
    
    static long gcd(long x,long y)
    {
        if(y==0)
                return x;
        else
                return gcd(y,x%y);
    }

    static int gcd(int x,int y)
    {
        if(y==0)
                return x;
        else 
                return gcd(y,x%y);
    }

    static long pow(long n,long p,long m)
    {
         long  result = 1;
          if(p==0){
            return n;
          }
          
        while(p!=0)
        {
            if(p%2==1)
                result *= n;
            if(result >= m)
               result %= m;
            p >>=1;
            n*=n;
            if(n >= m)
                n%=m;
        }
        
        return result;
    }

    static long pow(long n,long p)
    {
        long  result = 1;
          if(p==0)
            return 1;

        while(p!=0)
        {
            if(p%2==1)
                result *= n;	    
            p >>=1;
            n*=n;	    
        }
        return result;
    }

    static void debug(Object... o)
    {
            System.out.println(Arrays.deepToString(o));
    }

    static class InputReader
    {

        private final InputStream stream;
        private final byte[] buf = new byte[8192];
        private int curChar, snumChars;
        private SpaceCharFilter filter;

        public InputReader(InputStream stream)
        {
                this.stream = stream;
        }

        public int snext()
        {
                if (snumChars == -1)
                        throw new InputMismatchException();
                if (curChar >= snumChars)
                {
                        curChar = 0;
                        try
                        {
                                snumChars = stream.read(buf);
                        } catch (IOException e)
                        {
                                throw new InputMismatchException();
                        }
                        if (snumChars <= 0)
                                return -1;
                }
                return buf[curChar++];
        }

        public int nextInt()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                int sgn = 1;
                if (c == '-')
                {
                        sgn = -1;
                        c = snext();
                }
                int res = 0;
                do
                {
                        if (c < '0' || c > '9')
                                throw new InputMismatchException();
                        res *= 10;
                        res += c - '0';
                        c = snext();
                } while (!isSpaceChar(c));
                return res * sgn;
        }

        public long nextLong()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                int sgn = 1;
                if (c == '-')
                {
                        sgn = -1;
                        c = snext();
                }
                long res = 0;
                do
                {
                        if (c < '0' || c > '9')
                                throw new InputMismatchException();
                        res *= 10;
                        res += c - '0';
                        c = snext();
                } while (!isSpaceChar(c));
                return res * sgn;
        }

        public int[] nextIntArray(int n)
        {
                int a[] = new int[n];
                for (int i = 0; i < n; i++)
                {
                        a[i] = nextInt();
                }
                return a;
        }

        public long[] nextLongArray(int n)
        {
                long a[] = new long[n];
                for (int i = 0; i < n; i++)
                {
                        a[i] = nextLong();
                }
                return a;
        }

        public String readString()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                StringBuilder res = new StringBuilder();
                do
                {
                        res.appendCodePoint(c);
                        c = snext();
                } while (!isSpaceChar(c));
                return res.toString();
        }

        public String nextLine()
        {
                int c = snext();
                while (isSpaceChar(c))
                        c = snext();
                StringBuilder res = new StringBuilder();
                do
                {
                        res.appendCodePoint(c);
                        c = snext();
                } while (!isEndOfLine(c));
                return res.toString();
        }

        public boolean isSpaceChar(int c)
        {
                if (filter != null)
                        return filter.isSpaceChar(c);
                return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        private boolean isEndOfLine(int c)
        {
                return c == '\n' || c == '\r' || c == -1;
        }

        public interface SpaceCharFilter
        {
                public boolean isSpaceChar(int ch);
        }

    }
}    
",,CorCod,635,635
"import java.io.*;
import java.util.StringTokenizer;
public class Main {
    
    public static void main(String[] args) {
        FastScanner sc = new FastScanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int N = sc.nextInt();
        long dest = sc.nextLong();
        long max = (long)N * ((long)N + 1L) / 2L;
        if (dest < 2 * N - 1 || dest > max) {
            out.println(""No"");
            out.close();
            return;
        }
        int[] d = new int[N + 1];
        int[] f = new int[N + 1];
        int K = 1;
        for (; K <= N; K++) {
            long dep = 1L, cnt = 1L, c = 1L;
            long t = 1L;
            while (cnt < N) {
                c = c * K;
                dep++;
                t += (dep * Math.min(c, N - cnt));
                cnt += c;
            }
            if (t <= dest) break;
        }
        out.println(""Yes"");
        int dep = 1; long cnt = 1L, c = 1L;
        long t = 1L;
        d[1] = 1;
        while (cnt < N) {
            dep++; c = c * K; 
            long x = (long)N - cnt;
            int min;
            if (c >= x) min = (int)x;
            else min = (int)c;
            d[dep] = min;
            t += (dep * Math.min(c, (long)N - cnt)); cnt += c;
        }
        dest -= t;
        int curDep = dep; int nextDep = dep + 1;
        while (dest > 0) {
            if (d[curDep] <= 1) curDep--;
            d[curDep]--;
            long next = Math.min(nextDep++, dest + curDep);
            dest -= ((int)next - curDep);
            d[(int)next]++;
        }
        int first = 1;
        for (int i = 2; i < nextDep; i++) {
            int p = 0, fn = first - d[i - 1] + 1;
            for (int j = first + 1; j <= first + d[i]; j++) {
                if (p == K) {
                    fn++; p = 0;
                }
                p++; f[j] = fn;
            }
            first += d[i];
        }
        for (int i = 2; i <= N; i++)
            out.format(""%d "", f[i]);
        out.close();
    }
            
        
    static class FastScanner {
        private BufferedReader reader = null;
        private StringTokenizer tokenizer = null;
        
        public FastScanner(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
            tokenizer = null;
        }
        
        public String next() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        
        public String nextLine() {
            if (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    return reader.readLine();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken(""\n"");
        }
        
        public long nextLong() {
            return Long.parseLong(next());
        }
        
        public int nextInt() {
            return Integer.parseInt(next());
        }
        
       /* public double nextDouble() {
            return Double.parseDouble(next());
        }
        
        public int[] nextIntArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; ++i) {
                a[i] = nextInt();
            }
            return a;
        }
        
        public long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = nextLong();
            }
            return a;
        }*/
    }
}",,CorCod,646,646
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        public void solve(int testNumber, FastReader in, PrintWriter out) {
            int n = in.nextInt();
            TaskD.Pair[] p = new TaskD.Pair[n];
            for (int i = 0; i < n; ++i) {
                p[i] = new TaskD.Pair(in.nextLong(), in.nextLong());
            }
            Arrays.sort(p);
            int last = 0;
            int ans = 1;
            for (int i = 1; i < n; ++i) {
                if (p[i].x - p[i].w >= p[last].x + p[last].w) {
                    last = i;
                    ++ans;
                }
            }
            out.println(ans);
        }

        static class Pair implements Comparable<TaskD.Pair> {
            long x;
            long w;

            public Pair(long x, long w) {
                this.x = x;
                this.w = w;
            }

            public int compareTo(TaskD.Pair o) {
                return Long.compare(x + w, o.x + o.w);
            }

            public String toString() {
                return x + "" "" + w;
            }

        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar;
        private int pnumChars;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        private int pread() {
            if (pnumChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= pnumChars) {
                curChar = 0;
                try {
                    pnumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (pnumChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            int res = 0;
            do {
                if (c == ',') {
                    c = pread();
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public long nextLong() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",,CorCod,650,650
"
import java.util.*;


public class HelloWorld {
	static long SQR(long a) {
		return a * a;
	}
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		String str = sc.next();
		char s[] = str.toCharArray();
		Arrays.parallelSort(s);
		str = new String(s);
		int d = 0;
		int ans = 0;

		for(int i = 0;i < str.length();i++) {
			int x = str.charAt(i) - 'a';
			if(k == 0)continue;
			if(x >= d) {
				ans = ans + x + 1;
				d = x + 2;
				k = k - 1;
			}
		}
		if(k > 0)ans = -1;
		System.out.println(ans);
	}
}
",,CorCod,663,663
"
// Java code to calculate maximum unique 
// element of every segment of array 
import
java.io.*; 
import
java.util.*; 
class
GFG { 


static
void
find_max(
int
[] A, 
int
N, 
int
K) 

{ 

// Storing counts of first K-1 elements 

// Also storing distinct elements. 

HashMap<Integer, Integer> Count = 
new
HashMap<>(); 

for
(
int
i = 
0
; i < K - 
1
; i++) 

if
(Count.containsKey(A[i])) 

Count.put(A[i], 
1
+ Count.get(A[i])); 

else

Count.put(A[i], 
1
); 


TreeSet<Integer> Myset = 
new
TreeSet<Integer>(); 

for
(Map.Entry x : Count.entrySet()) { 

if
(Integer.parseInt(String.valueOf(x.getValue())) == 
1
) 

Myset.add(Integer.parseInt(String.valueOf(x.getKey()))); 

} 


// Before every iteration of this loop, 

// we maintain that K-1 elements of current 

// window are processed. 

for
(
int
i = K - 
1
; i < N; i++) { 


// Process K-th element of current window 

if
(Count.containsKey(A[i])) 

Count.put(A[i], 
1
+ Count.get(A[i])); 

else

Count.put(A[i], 
1
); 


if
(Integer.parseInt(String.valueOf(Count.get(A[i]))) == 
1
) 

Myset.add(A[i]); 

else

Myset.remove(A[i]); 


// If there are no distinct 

// elements in current window 

if
(Myset.size() == 
0
) 

System.out.println(
""Nothing""
); 


// Set is ordered and last element 

// of set gives us maximum element. 

else

System.out.println(Myset.last()); 


// Remove first element of current 

// window before next iteration. 

int
x = A[i - K + 
1
]; 

Count.put(x, Count.get(x) - 
1
); 


if
(Integer.parseInt(String.valueOf(Count.get(x))) == 
1
) 

Myset.add(x); 

if
(Integer.parseInt(String.valueOf(Count.get(x))) == 
0
) 

Myset.remove(x); 

} 

} 


// Driver code 

public
static
void
main(String args[]) 

{ 

int
[] a = { 
1
, 
2
, 
2
, 
3
, 
3
}; 

int
n = a.length; 

int
k = 
3
; 

find_max(a, n, k); 

} 
} 

// This code is contributed by rachana soma ",,CorCod,665,665
"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Random;
import java.util.Scanner;
import java.util.Set;
import java.util.StringJoiner;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Test {

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] line = reader.readLine().split("" "");
        int w = Integer.valueOf(line[0]);
        int h = Integer.valueOf(line[1]);
        int n = Integer.valueOf(line[2]);

        Request[] requests = new Request[n];

        for (int i = 0; i < n; i++) {
            line = reader.readLine().split("" "");
            requests[i] = new Request(line[0], Integer.valueOf(line[1]));
        }

        for (long e : solve(h, w, requests))
            System.out.println(e);

//        int w = 200000, h = 200000, n = 400000;
//        Request[] requests = generate(w, h, n);
//
//        long start = System.currentTimeMillis();
//        solve(h, w, requests);
//        long end = System.currentTimeMillis();
//
//        System.out.println(""Time: "" + (end - start) + "" ms"");
    }

    private static Request[] generate(int w, int h, int n) {
        Request[] requests = new Request[n];
        Random rnd = new Random();

        for (int i = 0; i < n; i++) {
            requests[i] = rnd.nextBoolean() ? new Request(""V"", rnd.nextInt(w)) : new Request(""H"", rnd.nextInt(h));
        }

        return requests;
    }

    private static long[] solve(int h, int w, Request[] requests) {
        TreeSet<Integer> hTree = new TreeSet<>();
        TreeSet<Integer> wTree = new TreeSet<>();

        Queue<CoordinateWithSize> hHeap = new PriorityQueue<>();
        Queue<CoordinateWithSize> wHeap = new PriorityQueue<>();

        hTree.add(0);
        hTree.add(h);
        wTree.add(0);
        wTree.add(w);

        hHeap.add(new CoordinateWithSize(0, h));
        wHeap.add(new CoordinateWithSize(0, w));

        long[] res = new long[requests.length];
        for (int i = 0; i < requests.length; i++) {
            Request request = requests[i];

            switch (request.type) {
                case ""H"": {
                    if (!hTree.contains(request.coordinate)) {
                        int higher = hTree.higher(request.coordinate);
                        int lower = hTree.lower(request.coordinate);

                        hHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));
                        hHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));

                        hTree.add(request.coordinate);
                    }

                    break;
                }
                case ""V"": {
                    if (!wTree.contains(request.coordinate)) {
                        int higher = wTree.higher(request.coordinate);
                        int lower = wTree.lower(request.coordinate);

                        wHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));
                        wHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));

                        wTree.add(request.coordinate);
                    }

                    break;
                }
                default:
                    throw new IllegalStateException(""Unknown type [type="" + request.type + ""]"");
            }

            while (true) {
                CoordinateWithSize c = hHeap.peek();
                if (hTree.higher(c.coordinate) - c.coordinate == c.size)
                    break;
                hHeap.remove();
            }

            while (true) {
                CoordinateWithSize c = wHeap.peek();
                if (wTree.higher(c.coordinate) - c.coordinate == c.size)
                    break;
                wHeap.remove();
            }

            res[i] = 1L * hHeap.peek().size * wHeap.peek().size;
        }

        return res;
    }

    private static class CoordinateWithSize implements Comparable<CoordinateWithSize> {

        private final int coordinate;

        private final int size;

        public CoordinateWithSize(int coordinate, int size) {
            this.coordinate = coordinate;
            this.size = size;
        }

        @Override public int compareTo(CoordinateWithSize o) {
            return Integer.compare(o.size, size);
        }
    }

    private static class Request {

        private final String type;

        private final int coordinate;

        public Request(String type, int coordinate) {
            this.type = type;
            this.coordinate = coordinate;
        }
    }
}
",,CorCod,688,688
"
// Java implementation of smallest difference 
// triplet 
import
java.util.Arrays; 

class
GFG { 


// function to find maximum number 

static
int
maximum(
int
a, 
int
b, 
int
c) 

{ 

return
Math.max(Math.max(a, b), c); 

} 


// function to find minimum number 

static
int
minimum(
int
a, 
int
b, 
int
c) 

{ 

return
Math.min(Math.min(a, b), c); 

} 


// Finds and prints the smallest Difference 

// Triplet 

static
void
smallestDifferenceTriplet(
int
arr1[], 

int
arr2[], 
int
arr3[], 
int
n) 

{ 


// sorting all the three arrays 

Arrays.sort(arr1); 

Arrays.sort(arr2); 

Arrays.sort(arr3); 


// To store resultant three numbers 

int
res_min=
0
, res_max=
0
, res_mid=
0
; 


// pointers to arr1, arr2, arr3 

// respectively 

int
i = 
0
, j = 
0
, k = 
0
; 


// Loop until one array reaches to its end 

// Find the smallest difference. 

int
diff = 
2147483647
; 


while
(i < n && j < n && k < n) 

{ 

int
sum = arr1[i] + arr2[j] + arr3[k]; 


// maximum number 

int
max = maximum(arr1[i], arr2[j], arr3[k]); 


// Find minimum and increment its index. 

int
min = minimum(arr1[i], arr2[j], arr3[k]); 

if
(min == arr1[i]) 

i++; 

else
if
(min == arr2[j]) 

j++; 

else

k++; 


// comparing new difference with the 

// previous one and updating accordingly 

if
(diff > (max - min)) 

{ 

diff = max - min; 

res_max = max; 

res_mid = sum - (max + min); 

res_min = min; 

} 

} 


// Print result 

System.out.print(res_max + 
"", ""
+ res_mid 

+ 
"", ""
+ res_min); 

} 


//driver code 

public
static
void
main (String[] args) 

{ 


int
arr1[] = {
5
, 
2
, 
8
}; 

int
arr2[] = {
10
, 
7
, 
12
}; 

int
arr3[] = {
9
, 
14
, 
6
}; 


int
n = arr1.length; 


smallestDifferenceTriplet(arr1, arr2, arr3, n); 

} 
} 

// This code is contributed by Anant Agarwal. ",,CorCod,703,703
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;

public class Main {
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		String[] s = br.readLine().trim().split("" "");
		int n = Integer.parseInt(s[0]);
		int m = Integer.parseInt(s[1]);
		long b[] = new long[n];
		s = br.readLine().trim().split("" "");
		for(int i = 0; i < n; i++) {
			b[i] = Integer.parseInt(s[i]);
		}
		long g[] = new long[m];
		s = br.readLine().trim().split("" "");
		for(int i = 0; i < m; i++) {
			g[i] = Integer.parseInt(s[i]);
		}
		Arrays.sort(b);
		Arrays.sort(g);
		if(g[0] < b[n-1]) {
			System.out.println(""-1"");
		}
		else if(g[0] == b[n-1]){
			long ans = 0;
			for(int i = 0; i < m; i++) {
				ans += g[i];
			}
			for(int i = 0; i < n-1; i++) {
				ans += (m)*b[i];
			}
			System.out.println(ans);

		}
		else {
			long ans = 0;
			for(int i = 0; i < m; i++) {
				ans += g[i];
			}
			for(int i = 0; i < n-1; i++) {
				ans += (m)*b[i];
			}
			ans += b[n-1]-b[n-2];
			System.out.println(ans);

		}
	}
}",,CorCod,714,714
"
// Java program to find maximum height pyramid 
// from the given object width. 
import
java.io.*; 
import
java.util.Arrays; 

class
GFG { 


// Returns maximum number of pyramidcal 

// levels n boxes of given widths. 

static
int
maxLevel(
int
[]boxes, 
int
n) 

{ 


// Sort objects in increasing order 

// of widths 

Arrays.sort(boxes); 


int
ans = 
1
; 
// Initialize result 


// Total width of previous level 

// and total number of objects in 

// previous level 

int
prev_width = boxes[
0
]; 

int
prev_count = 
1
; 


// Number of object in current 

// level. 

int
curr_count = 
0
; 


// Width of current level. 

int
curr_width = 
0
; 

for
(
int
i = 
1
; i < n; i++) 

{ 

// Picking the object. So 

// increase current width 

// and number of object. 

curr_width += boxes[i]; 

curr_count += 
1
; 


// If current width and 

// number of object 

// are greater than previous. 

if
(curr_width > prev_width && 

curr_count > prev_count) 

{ 


// Update previous width, 

// number of object on 

// previous level. 

prev_width = curr_width; 

prev_count = curr_count; 


// Reset width of current 

// level, number of object 

// on current level. 

curr_count = 
0
; 

curr_width = 
0
; 


// Increment number of 

// level. 

ans++; 

} 

} 


return
ans; 

} 


// Driver Program 

static
public
void
main (String[] args) 

{ 

int
[]boxes = {
10
, 
20
, 
30
, 
50
, 
60
, 
70
}; 

int
n = boxes.length; 

System.out.println(maxLevel(boxes, n)); 

} 
} 

// This code is contributed by anuj_67. ",,CorCod,715,715
"
// Java program to calculate max_difference between 
// the sum of two subarrays of length k and N - k 
import
java.util.*; 

class
GFG 
{ 

// Function to calculate max_difference 
static
int
maxDifference(
int
arr[], 
int
N, 
int
k) 
{ 

int
M, S = 
0
, S1 = 
0
, max_difference = 
0
; 


// Sum of the array 

for
(
int
i = 
0
; i < N; i++) 

S += arr[i]; 

int
temp; 


// Sort the array in descending order 

for
(
int
i = 
0
; i < N; i++) 

{ 

for
(
int
j = i + 
1
; j < N; j++) 

{ 

if
(arr[i] < arr[j]) 

{ 

temp = arr[i]; 

arr[i] = arr[j]; 

arr[j] = temp; 

} 

} 

} 


M = Math.max(k, N - k); 

for
(
int
i = 
0
; i < M; i++) 

S1 += arr[i]; 


// Calculating max_difference 

max_difference = S1 - (S - S1); 

return
max_difference; 
} 

// Driver Code 
public
static
void
main(String args[]) 
{ 

int
arr[] = { 
8
, 
4
, 
5
, 
2
, 
10
}; 

int
N = arr.length; 

int
k = 
2
; 

System.out.println(maxDifference(arr, N, k)); 
} 
} 

// This code is contributed by 
// Surendra_Gangwar ",,CorCod,717,717
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

import static java.lang.Math.*;

public class Main2 {

    private FastScanner scanner = new FastScanner();

    public static void main(String[] args) {
        new Main2().solve();
    }

    private void solve() {

        int n = scanner.nextInt();


        int a[][] = new int[n][3];

        for (int i = 0; i < n; i++) {
            a[i][0] = scanner.nextInt();
            a[i][1] = scanner.nextInt();
            a[i][2] = i;
        }

        int l = -1, r = -1;

        Arrays.sort(a, (o1, o2) -> {
            if (o1[0] != o2[0]) {
                return o1[0] - o2[0];
            } else {
                return o2[1] - o1[1];
            }
        });

        int maxr = -1, maxi = -1;
        for (int i = 0; i < n; i++) {
            if (a[i][1] <= maxr) {
                l = a[i][2] + 1;
                r = maxi + 1;
                break;
            }
            if (a[i][1] > maxr) {
                maxi = a[i][2];
                maxr = a[i][1];
            }
        }

        System.out.println(l + "" "" + r);


    }

    boolean check(int cnt[][], int[] tcnt, int mid) {
        boolean ok = true;

        for (int j = 0; j < 27; j++) {
            if (cnt[mid][j] < tcnt[j]) {
                ok = false;
            }
        }
        return ok;
    }

    class Pair {
        int c, f;
    }

    class FastScanner {
        BufferedReader reader;
        StringTokenizer tokenizer;

        FastScanner() {
            reader = new BufferedReader(new InputStreamReader(System.in), 32768);
            tokenizer = null;
        }

        String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();

        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        Integer[] nextA(int n) {
            Integer a[] = new Integer[n];
            for (int i = 0; i < n; i++) {
                a[i] = scanner.nextInt();
            }
            return a;
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
}",,CorCod,722,722
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class CoveredPointsCount {
	
	//UPSOLVE
	
	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
	        
		int n = Integer.parseInt(st.nextToken());
	     
		long[] myArray = new long[2 * n];
	        
			for (int i = 0; i < n; i++)  {
	        	StringTokenizer st1 = new StringTokenizer(br.readLine());
	        	myArray[2 * i] = Long.parseLong(st1.nextToken()) * 2;
	        	myArray[2 * i + 1] = Long.parseLong(st1.nextToken()) * 2 + 1;
	        }  
	        
	        Arrays.sort(myArray);
	        long[] ans = new long[n + 1];
	        int cnt = 0;
	       
	        for (int i = 0; i < 2 * n - 1; i++)   {
	            if (myArray[i] % 2 == 0) cnt++; else cnt--;
	            ans[cnt] += (myArray[i + 1] + 1) / 2 - (myArray[i] + 1) / 2;
	        }   
	        
	        StringBuilder answer = new StringBuilder();
	        
	        for (int i = 1; i < n + 1; i++) {
	        	answer.append(ans[i]);
	        	answer.append("" "");
	        }  
	        
	        System.out.println(answer);

	}

}
",,CorCod,726,726
"
// Java program to find number of pairs 
// and minimal possible value 
import
java.util.*; 

class
GFG { 


// function for finding pairs and min value 

static
void
pairs(
int
arr[], 
int
n, 
int
k) 

{ 

// initialize smallest and count 

int
smallest = Integer.MAX_VALUE; 

int
count=
0
; 


// iterate over all pairs 

for
(
int
i=
0
; i<n; i++) 

for
(
int
j=i+
1
; j<n; j++) 

{ 

// is abs value is smaller than 

// smallest update smallest and 

// reset count to 1 

if
( Math.abs(arr[i] + arr[j] - k) < 

smallest ) 

{ 

smallest = Math.abs(arr[i] + arr[j] 

- k); 

count = 
1
; 

} 


// if abs value is equal to smallest 

// increment count value 

else
if
(Math.abs(arr[i] + arr[j] - k) 

== smallest) 

count++; 

} 


// print result 

System.out.println(
""Minimal Value = ""
+ 

smallest); 

System.out.println(
""Total Pairs = ""
+ 

count); 

} 


/* Driver program to test above function */

public
static
void
main(String[] args) 

{ 

int
arr[] = {
3
, 
5
, 
7
, 
5
, 
1
, 
9
, 
9
}; 

int
k = 
12
; 

int
n = arr.length; 

pairs(arr, n, k); 

} 
} 
// This code is contributed by Arnav Kr. Mandal. ",,CorCod,732,732
"import java.util.*;

import java.lang.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.*;
 
public class Main {
        
    public static void main(String[] args) throws Exception{
        FastReader sc=new FastReader(); 
        OutputStream outputStream = System.out;
        PrintWriter out = new PrintWriter(outputStream);
        int n=sc.nextInt();
        HashMap<String,Integer> map=new HashMap<String,Integer>();
        for(int i=0;i<n;i++) {
            map.put(sc.next(), 1);
        }
        ArrayList<String> list=new ArrayList<String>();
        int count=0;
        if(!map.containsKey(""purple"")) {
            count++;
            list.add(""Power"");
        }
if(!map.containsKey(""green"")) {
    count++;
    list.add(""Time"");
        }

if(!map.containsKey(""blue"")) {
    count++;
    list.add(""Space"");
}

if(!map.containsKey(""orange"")) {
    count++;
    list.add(""Soul"");
}

if(!map.containsKey(""red"")) {
    count++;
    list.add(""Reality"");
}

if(!map.containsKey(""yellow"")) {
    count++;
    list.add(""Mind"");
}System.out.println(count);
    for(String s:list) {
        System.out.println(s);
    }
    }
}

class FastReader 
{ 
    BufferedReader br; 
    StringTokenizer st; 
 
    public FastReader() 
    { 
        br = new BufferedReader(new
                 InputStreamReader(System.in)); 
    } 
 
    String next() 
    { 
        while (st == null || !st.hasMoreElements()) 
        { 
            try
            { 
                st = new StringTokenizer(br.readLine()); 
            } 
            catch (IOException  e) 
            { 
                e.printStackTrace(); 
            } 
        } 
        return st.nextToken(); 
    } 
 
    int nextInt() 
    { 
        return Integer.parseInt(next()); 
    } 
 
    long nextLong() 
    { 
        return Long.parseLong(next()); 
    } 
 
    double nextDouble() 
    { 
        return Double.parseDouble(next()); 
    } 
 
    String nextLine() 
    { 
        String str = """"; 
        try
        { 
            str = br.readLine(); 
        } 
        catch (IOException e) 
        { 
            e.printStackTrace(); 
        } 
        return str; 
    } 
} ",,CorCod,738,738
"import java.util.*;
import java.io.*;
public class A
{
      public static void main(String ar[]) throws Exception
      {
            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
            String s1[]=br.readLine().split("" "");
            int a=Integer.parseInt(s1[0]);
            int b=Integer.parseInt(s1[1]);
            int c=Integer.parseInt(s1[2]);
            int n=Integer.parseInt(s1[3]);
            int S=a+b-c;
            if(n-S<1 || c>Math.min(a,b))
             System.out.println(""-1"");
            else
             System.out.println(n-S);
      }
}",,CorCod,748,748
"import java.util.*;

public class Main {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);

        long n = sc.nextLong();
        long s = sc.nextLong();

        long ans = (s - 1) / n + 1;
        System.out.print(ans);
    }
}",,CorCod,752,752
"import java.util.*;
import java.math.*;
public class Main{
    public static void main(String [] args)
    {
        Scanner scan=new Scanner(System.in);
        long n=scan.nextLong();
        long m=scan.nextLong();
        n=(long)Math.pow(2,n);
        long ans=m%n;
        System.out.println(ans);
    }
}",,CorCod,761,761
"import java.util.*;
import java.util.Scanner;
public class task1{
    public static void main(String args[]){
        Scanner in = new Scanner(System.in);
        int n=in.nextInt();
        int pos=in.nextInt();
        int l=in.nextInt();
        int r=in.nextInt();
        boolean b=false;
        boolean c=true;
        if(l==1&&r==n){
            c=false;
            System.out.println(0);
        }
        if(c){
            if(l==1){
            if(pos<r){
                System.out.println(r-pos+1);
                b=true;}
            else{
                System.out.println(pos-r+1);
                b=true;
            }
        }
        if(r==n){
            if(pos>l){
                System.out.println(pos-l+1);
                b=true;}
            else{
                System.out.println(l-pos+1);
                b=true;
            }
        }
        }
        if(b==false&&c){
            if(pos<l){
            System.out.println(l-pos+1+r-l+1);
        }
        else if(pos>r){
            System.out.println(pos-r+1+r-l+1);
        }
        else{
            if(((pos-l)<(r-pos))){
                System.out.println(pos-l+1+r-l+1);
                
            }
            
            else if((pos-l)>(r-pos)){
                System.out.println(r-pos+1+r-l+1);
                
            }
            else{
                System.out.println((r-pos)*3+2);
                
            }
        }
        }
        
    }
}",,CorCod,762,762
"
import java.io.*;
import java.math.*;
import java.util.*;


// author @mdazmat9
public  class codeforces{
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int test = 1;
        for (int ind = 0; ind < test; ind++) {
          int [] a=new int[3];
          a[0]=sc.nextInt();
          a[1]=sc.nextInt();
          a[2]=sc.nextInt();
          Arrays.sort(a);
          int k1=a[0];
          int k2=a[1];
          int k3=a[2];
          if(k1==1 || k2==1 || k3==1){
              out.println(""YES"");
          }
          else if((k1==2 && k2==2)||(k2==2 && k3==2)){
              out.println(""YES"");
            }
            else if(k1==3 && k2==3 && k3==3){
              out.println(""YES"");
          }
          else if(k1==2 && k2==4 && k3==4){
              out.println(""YES"");
          }
          else
              out.println(""NO"");

        }
        out.flush();
    }





    static   void shuffle(int[] a) {
        int n = a.length;
        for(int i = 0; i < n; i++) {
            int r = i + (int) (Math.random() * (n - i));
            int tmp = a[i];
            a[i] = a[r];
            a[r] = tmp;
        }
    }
    static long gcd(long a , long b)
    {
        if(b == 0)
            return a;
        return gcd(b , a % b);
    }

}
class Scanner {
    public BufferedReader reader;
    public StringTokenizer st;

    public Scanner(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream));
        st = null;
    }

    public String next() {
        while (st == null || !st.hasMoreTokens()) {
            try {
                String line = reader.readLine();
                if (line == null) return null;
                st = new StringTokenizer(line);
            } catch (Exception e) {
                throw (new RuntimeException());
            }
        }
        return st.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    public long nextLong() {
        return Long.parseLong(next());
    }

    public double nextDouble() {
        return Double.parseDouble(next());
    }
}

class OutputWriter {
    BufferedWriter writer;

    public OutputWriter(OutputStream stream) {
        writer = new BufferedWriter(new OutputStreamWriter(stream));
    }

    public void print(int i) throws IOException {
        writer.write(i);
    }

    public void print(String s) throws IOException {
        writer.write(s);
    }

    public void print(char[] c) throws IOException {
        writer.write(c);
    }

    public void close() throws IOException {
        writer.close();
    }

}",,CorCod,806,806
"import java.io.IOException;
import java.util.*;

public class Main implements Runnable {
  static String readLn(int maxLength) {

    byte line[] = new byte[maxLength];
    int length = 0;
    int input = -1;
    try {
      while (length < maxLength) {
        input = System.in.read();
        if ((input < 0) || (input == '\n')) {
          break;
        }

        line[length++] += input;
      }

      if ((input < 0) && (length == 0)) {
        return null;
      }

      return new String(line, 0, length);
    } catch (IOException e) {
      return null;
    }
  }

  public static void main(String args[]) {
    Main myWork = new Main();
    myWork.run();
  }

  public void run() {
    new Watermelon().run();
  }
}

class Watermelon implements Runnable {
  public void run() {
    String line = Main.readLn(100).trim();
    int weight = Integer.parseInt(line);
    System.out.println(weight % 2 == 0 && weight > 2 ? ""YES"": ""NO"");
  }
}",,CorCod,809,809
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.Stack;


import java.util.StringTokenizer;


 public class Test
 {
    
     static PrintWriter pw = new PrintWriter(System.out);

    public static void main(String[] args)throws Exception
    {
        Reader.init(System.in);
        int n = Reader.nextInt();
        int p = Reader.nextInt();
        int L = Reader.nextInt();
        int R = Reader.nextInt();
        int a = 1;
        int b = n;
        int res = 0;
        
        if(a == L && b == R)
        {
            res = 0;
        }
        else if(L != a && R != b && p >= L && p <= R)
        {
            res = Math.min(p-L, R-p);
            res += R- L + 2;
        }
        else if(L != a && R != b && p < L )
        {
            res += L-p + 1;
            res += R - L +1;
        }
        else if(L != a && R != b && p > R)
        {
            res += p-R + 1;
            res += R - L +1;
        }
        else if(a == L && p >=L && p<=R)
        {
            res += R - p + 1;
        }
        else if(R == b && p>=L && p<=R)
        {
            res += p - L + 1;
        }
        else if(a == L && p > R)
        {
            res += p - R + 1;
        }
        else if(R == b && p<L)
        {
            res += L - p + 1;
        }
            
            
        pw.print(res);
        pw.close();
 
    }
        
}

class Reader {

    static BufferedReader reader;
    static StringTokenizer tokenizer;

    public static int pars(String x) {
        int num = 0;
        int i = 0;
        if (x.charAt(0) == '-') {
            i = 1;
        }
        for (; i < x.length(); i++) {
            num = num * 10 + (x.charAt(i) - '0');
        }

        if (x.charAt(0) == '-') {
            return -num;
        }

        return num;
    }

    static void init(InputStream input) {
        reader = new BufferedReader(
                new InputStreamReader(input));
        tokenizer = new StringTokenizer("""");
    }

    static void init(FileReader input) {
        reader = new BufferedReader(input);
        tokenizer = new StringTokenizer("""");
    }

    static String next() throws IOException {
        while (!tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(
                    reader.readLine());
        }
        return tokenizer.nextToken();
    }

    static int nextInt() throws IOException {
        return pars(next());
    }

    static long nextLong() throws IOException {
        return Long.parseLong(next());
    }

    static double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }
}",,CorCod,816,816
"import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		long n = sc.nextLong();
		long k = sc.nextLong();
		System.out.println(solve(n, k));

		sc.close();
	}

	static long solve(long n, long k) {
		return Math.max(0, Math.min(n, k - 1) - ((k + 2) / 2) + 1);
	}
}
",,CorCod,822,822
"import java.io.*;
import java.util.*;

public class b {

	public static void main(String[] args) throws IOException, InterruptedException {
		Scanner zizo = new Scanner(System.in);
		PrintWriter wr = new PrintWriter(System.out);
		
		int n1 = 0,n2 = 0,n3 = 0,n4 = 0;
		int n = 3;
		while(n --> 0) {
			int x = zizo.nextInt();
			switch(x) {
			case 1:n1++;break;
			case 4:n4++;break;
			case 2:n2++;break;
			case 3:n3++;break;
			}
		}
		n2 += n4/2;
		if(n1>0 || n2>1 || n3>2)
			System.out.println(""YES"");
		else System.out.println(""NO"");
		wr.close();
	}
}
class pair{
	int l,r;
	pair(int a,int b){l = a;r = b;}
}

class Scanner 
{
	StringTokenizer st;
	BufferedReader br;

	public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

	public String next() throws IOException 
	{
		while (st == null || !st.hasMoreTokens()) 
			st = new StringTokenizer(br.readLine());
		return st.nextToken();
	}

	public int nextInt() throws IOException {return Integer.parseInt(next());}

	public long nextLong() throws IOException {return Long.parseLong(next());}

	public String nextLine() throws IOException {return br.readLine();}

	public double nextDouble() throws IOException
	{
		String x = next();
		StringBuilder sb = new StringBuilder(""0"");
		double res = 0, f = 1;
		boolean dec = false, neg = false;
		int start = 0;
		if(x.charAt(0) == '-')
		{
			neg = true;
			start++;
		}
		for(int i = start; i < x.length(); i++)
			if(x.charAt(i) == '.')
			{
				res = Long.parseLong(sb.toString());
				sb = new StringBuilder(""0"");
				dec = true;
			}
			else
			{
				sb.append(x.charAt(i));
				if(dec)
					f *= 10;
			}
		res += Long.parseLong(sb.toString()) / f;
		return res * (neg?-1:1);
	}

	public boolean ready() throws IOException {return br.ready();}
}",,CorCod,837,837
"import java.util.Scanner;


public class IfAtFIrstYouDIdnt {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		Scanner input = new Scanner(System.in);
		int a = input.nextInt();
		int b = input.nextInt();
		int c = input.nextInt();
		int n  = input.nextInt();
		if(a<n && b<n && c < n && (a+b-c)<n && c<=a && c<=b){
			System.out.println((n)-(a+b-c));
		}
		else
			System.out.println(""-1"");
	}

}
",,CorCod,843,843
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

/**
 * @author Don Li
 */
public class TwoSquares {
    
    int INF = 1000;
    
    void solve() {
        int[][] s1 = new int[4][2];
        for (int i = 0; i < 4; i++) {
            s1[i][0] = in.nextInt();
            s1[i][1] = in.nextInt();
        }
        
        int[][] s2 = new int[4][2];
        for (int i = 0; i < 4; i++) {
            s2[i][0] = in.nextInt();
            s2[i][1] = in.nextInt();
        }
        
        if (ok(s1, s2)) {
            out.println(""Yes"");
            return;
        }
        
        rotate(s1);
        rotate(s2);
        
        if (ok(s2, s1)) {
            out.println(""Yes"");
            return;
        }
        
        out.println(""No"");
    }
    
    void rotate(int[][] s) {
        for (int i = 0; i < 4; i++) {
            int x = s[i][0], y = s[i][1];
            s[i][0] = x - y;
            s[i][1] = x + y;
        }
    }
    
    boolean ok(int[][] s1, int[][] s2) {
        int xmin = INF, xmax = -INF, ymin = INF, ymax = -INF;
        for (int i = 0; i < 4; i++) {
            xmin = Math.min(xmin, s1[i][0]);
            xmax = Math.max(xmax, s1[i][0]);
            ymin = Math.min(ymin, s1[i][1]);
            ymax = Math.max(ymax, s1[i][1]);
        }
        
        for (int i = 0; i < 4; i++) {
            if (s2[i][0] >= xmin && s2[i][0] <= xmax && s2[i][1] >= ymin && s2[i][1] <= ymax) return true;
        }
        
        int[] mid2 = new int[]{s2[0][0] + s2[2][0], s2[0][1] + s2[2][1]};
        return mid2[0] >= xmin * 2 && mid2[0] <= xmax * 2 && mid2[1] >= ymin * 2 && mid2[1] <= ymax * 2;
    }
    
    public static void main(String[] args) {
        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(System.out);
        new TwoSquares().solve();
        out.close();
    }
    
    static FastScanner in;
    static PrintWriter out;
    
    static class FastScanner {
        BufferedReader in;
        StringTokenizer st;
        
        public FastScanner(BufferedReader in) {
            this.in = in;
        }
        
        public String nextToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        
        public int nextInt() {
            return Integer.parseInt(nextToken());
        }
        
        public long nextLong() {
            return Long.parseLong(nextToken());
        }
        
        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }
    }
}
",,CorCod,877,877
"import java.util.*;

public class ehab4 {
    public static void main( String[] args ) {
        Scanner in = new Scanner( System.in );
	int a = 0, b = 0;
	System.out.println( ""? 0 0 "" );
	System.out.flush();
	int c = in.nextInt();
	for ( int i = 29; i >= 0; i-- ) {
	    System.out.println( ""? "" + ( a + ( 1 << i ) ) + "" "" + b );
	    System.out.flush();
	    int q1 = in.nextInt();
	    System.out.println( ""? "" + a + "" "" + ( b + ( 1 << i ) ) );
	    System.out.flush();
	    int q2 = in.nextInt();
	    if ( q1 == q2 ) {
		if ( c == 1 )
		    a += ( 1 << i );
		else if ( c == -1 )
		    b += ( 1 << i );
		c = q1;
	    }
	    else if ( q1 == -1 ) {
		a += ( 1 << i );
		b += ( 1 << i );
	    }
	    else if ( q1 == -2 )
		return;
	}
	System.out.println( ""! "" + a + "" "" + b );
	System.out.flush();
    }
}
",,CorCod,891,891
"package com.interview.binarysearch;

/**
 * There are two sorted arrays nums1 and nums2 of size m and n respectively.
 * Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
 *
 * Solution
 * Take minimum size of two array. Possible number of partitions are from 0 to m in m size array.
 * Try every cut in binary search way. When you cut first array at i then you cut second array at (m + n + 1)/2 - i
 * Now try to find the i where a[i-1] <= b[j] and b[j-1] <= a[i]. So this i is partition around which lies the median.
 *
 * Time complexity is O(log(min(x,y))
 * Space complexity is O(1)
 *
 * https://leetcode.com/problems/median-of-two-sorted-arrays/
 * https://discuss.leetcode.com/topic/4996/share-my-o-log-min-m-n-solution-with-explanation/4
 */
public class MedianOfTwoSortedArrayOfDifferentLength {

    public double findMedianSortedArrays(int input1[], int input2[]) {
        //if input1 length is greater than switch them so that input1 is smaller than input2.
        if (input1.length > input2.length) {
            return findMedianSortedArrays(input2, input1);
        }
        int x = input1.length;
        int y = input2.length;

        int low = 0;
        int high = x;
        while (low <= high) {
            int partitionX = (low + high)/2;
            int partitionY = (x + y + 1)/2 - partitionX;

            //if partitionX is 0 it means nothing is there on left side. Use -INF for maxLeftX
            //if partitionX is length of input then there is nothing on right side. Use +INF for minRightX
            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : input1[partitionX - 1];
            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : input1[partitionX];

            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : input2[partitionY - 1];
            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : input2[partitionY];

            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {
                //We have partitioned array at correct place
                // Now get max of left elements and min of right elements to get the median in case of even length combined array size
                // or get max of left for odd length combined array size.
                if ((x + y) % 2 == 0) {
                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY))/2;
                } else {
                    return (double)Math.max(maxLeftX, maxLeftY);
                }
            } else if (maxLeftX > minRightY) { //we are too far on right side for partitionX. Go on left side.
                high = partitionX - 1;
            } else { //we are too far on left side for partitionX. Go on right side.
                low = partitionX + 1;
            }
        }

        //Only we we can come here is if input arrays were not sorted. Throw in that scenario.
        throw new IllegalArgumentException();
    }

    public static void main(String[] args) {
        int[] x = {1, 3, 8, 9, 15};
        int[] y = {7, 11, 19, 21, 18, 25};

        MedianOfTwoSortedArrayOfDifferentLength mm = new MedianOfTwoSortedArrayOfDifferentLength();
        mm.findMedianSortedArrays(x, y);
    }
}",,CorCod,892,892
"// http://www.geeksforgeeks.org/count-1s-sorted-binary-array/
class CountOne {

  public static void main(String[] args) {
    int[] arr={0, 0, 0, 0, 0, 0, 0};
    //int[] arr={1, 1, 1, 1, 1, 1, 1};
    //int[] arr = {1, 1, 1, 0, 0, 0, 0};  
    countOne(arr);
  }

  public static void countOne(int[] a)
  {
       int l = 0;
       int h = a.length-1;
       int mid = -1;
      
       while(l<=h)
       {
         mid = (l+h)/2;
         
         if( (mid == h || a[mid+1] == 0) && a[mid] == 1)
         {
             System.out.println(""Count "" + (mid + 1));
             return;
         }
           
         if( a[mid] < 1)
         {
             h = mid - 1;
         } else {
             l = mid + 1;
         } 
       }
       System.out.println("" No one's found "");
       return;
  }
}",,CorCod,893,893
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Liavontsi Brechka
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        DEhabIEsheOdnaOcherednayaZadachaNaXor solver = new DEhabIEsheOdnaOcherednayaZadachaNaXor();
        solver.solve(1, in, out);
        out.close();
    }

    static class DEhabIEsheOdnaOcherednayaZadachaNaXor {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int c = 0;
            int d = 0;

            int prevSign = 0;
            int nextSign;
            boolean zeroOut = true;
            for (int i = 29; i >= 0; i--) {
                if (zeroOut) {
                    print(c, d, out);
                    prevSign = read(in);
                }

                print((1 << i) | c, (1 << i) | d, out);
                nextSign = read(in);

                if (prevSign == nextSign) {
                    zeroOut = false;

                    print((1 << i) | c, d, out);
                    nextSign = read(in);

                    if (nextSign < 0) {
                        c = (1 << i) | c;
                        d = (1 << i) | d;
                    }
                } else {
                    zeroOut = true;

                    if (nextSign < 0) c = (1 << i) | c;
                    else d = (1 << i) | d;
                }
            }

            out.printf(""! %d %d"", c, d);
            out.flush();
        }

        private void print(int c, int d, PrintWriter out) {
            out.printf(""? %d %d\n"", c, d);
            out.flush();
        }

        private int read(InputReader in) {
            return in.nextInt();
        }

    }

    static class InputReader {
        private final BufferedReader reader;
        private StringTokenizer tokenizer;

        public InputReader(InputStream in) {
            reader = new BufferedReader(new InputStreamReader(in));
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(readLine());
            }
            return tokenizer.nextToken();
        }

        public String readLine() {
            String line;
            try {
                line = reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            return line;
        }

    }
}

",,CorCod,912,912
"package com.interview.binarysearch;

/**
 * Date 07/31/2016
 * @author Tushar Roy
 *
 * Given a sorted array of integers, find the starting and ending position of a given target value.
 *
 * Time complexity O(logn)
 * Space complexity O(1)
 * 
 * https://leetcode.com/problems/search-for-a-range/
 */
public class SearchForRange {
    public int[] searchRange(int[] nums, int target) {
        int first = firstOccurence(nums, target);
        if (first == -1) {
            return new int[]{-1, -1};
        }
        int last = lastOccurence(nums, target);
        return new int[]{first, last};
    }

    private int firstOccurence(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        while (low <= high) {
            int mid = low + (high - low)/2;
            if (nums[mid] == target && (mid == 0 || nums[mid - 1] < target)) {
                return mid;
            } else if (nums[mid] >= target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }

    private int lastOccurence(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        while (low <= high) {
            int mid = low + (high - low)/2;
            if (nums[mid] == target && (mid == nums.length - 1 || nums[mid + 1] > target)) {
                return mid;
            } else if (nums[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1;
    }

    public static void main(String args[]) {
        SearchForRange searchForRange = new SearchForRange();
        int[] nums = {0, 1, 1, 3, 6, 9, 11};
        int[] r = searchForRange.searchRange(nums, 11);
        System.out.println(r[0] + "" "" + r[1]);
        r = searchForRange.searchRange(nums, 0);
        System.out.println(r[0] + "" "" + r[1]);
    }
}",,CorCod,926,926
