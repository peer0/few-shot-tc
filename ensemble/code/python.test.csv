src,ground_truth,predicted_tc
"with open(""input.txt"",""r"") as in_file: 
    with open(""output.txt"",""a"") as out_file:
        N,M = map(int,in_file.readline().split())
        K = int(in_file.readline())
        map_max_dist = [[5000 for i in range(M)] for j in range(N)]
        inputs = list(map(int,in_file.readline().split()))
        p = 0 
        while(p<=K*2-2):
            x,y = inputs[p]-1,inputs[p+1]-1
            for r in range(N):
                for c in range(M):
                    dist = abs(x-r)+abs(y-c)
                    if dist<map_max_dist[r][c]:
                        map_max_dist[r][c] = dist
            p+=2
        max_val = 0 
        max_index = (0,0)
        i,j = 0,0
        for i in range(N):
            for j in range(M):
                if(map_max_dist[i][j]>max_val):
                    max_val = map_max_dist[i][j]
                    max_index = (i,j)
        out_file.write(""{} {}"".format(max_index[0]+1,max_index[1]+1))
    
        ",6,-100
"'''
                ___                       ____                     
  ____ _____ _____/ (_)_  ______  ____ _____/ / /_  __  ______ ___  __
 / __ `/ __ `/ __  / / / / / __ \/ __ `/ __  / __ \/ / / / __ `/ / / /
/ /_/ / /_/ / /_/ / / /_/ / /_/ / /_/ / /_/ / / / / /_/ / /_/ / /_/ / 
\__,_/\__,_/\__,_/_/\__,_/ .___/\__,_/\__,_/_/ /_/\__, /\__,_/\__, /  
                        /_/                      /____/      /____/   
'''
import os.path
from math import gcd, floor, ceil
from collections import *
import sys
mod = 1000000007
INF = float('inf')
def st(): return list(sys.stdin.readline().strip())
def li(): return list(map(int, sys.stdin.readline().split()))
def mp(): return map(int, sys.stdin.readline().split())
def inp(): return int(sys.stdin.readline())
def pr(n): return sys.stdout.write(str(n)+""\n"")
def prl(n): return sys.stdout.write(str(n)+"" "")


if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]


def solve():
    n, m = mp()
    k = inp()
    l = li()
    q = deque()
    v = [[0]*(m+1) for i in range(n+1)]
    for i in range(0, 2*k - 1, 2):
        q.append((l[i], l[i+1]))
        v[l[i]][l[i+1]] = 1
    while q:
        a, b = q.popleft()
        for i in range(4):
            A, B = a+dx[i], b+dy[i]
            if A > 0 and A <= n and B > 0 and B <= m:
                if not v[A][B]:
                    q.append((A, B))
                    v[A][B] = 1
    print(a, b)


for _ in range(1):
    solve()
",6,5
"from collections import deque
with open(""input.txt"",""r"") as input_file: 
    with open(""output.txt"",""a"") as output_file:
        N,M = map(int,input_file.readline().split())
        K = int(input_file.readline())
        T = list(map(int,input_file.readline().split()))
        graph = [[0] * (M + 1) for _ in range(N + 1)]
        queue = deque()
        for i in range(0, 2 * K - 1, 2):
            graph[T[i]][T[i + 1]] = 1
            queue.append((T[i], T[i + 1]))
        x, y = 0, 0
        while queue:
            x, y = queue.popleft()
            x_moves = [x - 1, x + 1, x, x]
            y_moves = [y, y, y - 1, y + 1]
            for i in range(len(x_moves)):
                if 0 < x_moves[i] <= N and 0 < y_moves[i] <= M:
                    if graph[x_moves[i]][y_moves[i]] == 0:
                        x = x_moves[i]
                        y = y_moves[i]
                        graph[x_moves[i]][y_moves[i]] = 1
                        queue.append((x_moves[i], y_moves[i]))
        output_file.write(f""{x} {y}"")",6,6
"from queue import Queue
import datetime

with open(""input.txt"", 'r') as in_file:
    n, m = (int(i) for i in in_file.readline().split("" ""))
    k = int(in_file.readline())
    ints = [int(i) for i in in_file.readline().split("" "")]

pairs = []
for i in range(0, len(ints), 2):
    x = ints[i]
    y = ints[i+1]
    pairs.append((x, y))


last_tree = (1, 1)
maxd = 0
mult = m * n
for i in range(1, n+1):
    for j in range(1, m+1):
        md = mult
        # print(""par"", i, j)
        for pair in pairs:
            x, y = pair
            d = abs(i-x)+abs(j-y)
            # print(""punto"", x, y)
            # print(""distancia"", d)
            md = min(md, d)
            # print(""min"", md)
        if md > maxd:
            # print(""max"", md)
            last_tree = (i, j)
            maxd = md
        # print("""")

# print(""res"", last_tree)
with open(""output.txt"", 'w') as out_file:
    out_file.write(f""{last_tree[0]} {last_tree[1]}"")

	 		 	 			  		 		         		  	",6,5
"# XXXX

from sys import stdin, exit
from typing import List, Tuple, Dict
from itertools import product


def distance(tree: Tuple[int, int], outbreak: Tuple[int, int]):
    return abs(tree[0] - outbreak[0]) + abs(tree[1] - outbreak[1])


def shorthest_path(tree: Tuple[int, int], outbreaks: List[Tuple[int, int]], min_dst: int):
    shorthest_path = float('inf')
    for outbreak in outbreaks:
        if shorthest_path < min_dst:
            break
        shorthest_path = min(shorthest_path, distance(tree, outbreak))
    return shorthest_path


input_f = open('input.txt', 'r')
output_f = open('output.txt', 'w')

N, M = [int(v) for v in input_f.readline().rstrip().split()]
input_f.readline()  # ignore
outbreaks_line = [int(v) for v in input_f.readline().rstrip().split()]
outbreaks = []
input_f.close()


for i in range(0, len(outbreaks_line) - 1, 2):
    outbreaks.append((outbreaks_line[i], outbreaks_line[i+1]))

last_tree = (1, 1)
best_dst = 0
for x, y in product(range(1, N + 1), range(1, M + 1)):
    path_len = shorthest_path((x, y), outbreaks, best_dst)
    if path_len > best_dst:
        last_tree = (x, y)
        best_dst = path_len

output_f.write(' '.join(map(str, last_tree)))
# print(' '.join(map(str, last_tree)))

output_f.close()
",6,5
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase
from collections import deque

def main():
    with open('input.txt') as fp:
        input=fp.readline
        n, m = map(int, input().split())
        dx = [1, -1, 0, 0]
        dy = [0, 0, -1, 1]
        q =deque()
        k = int(input())
        a = list(map(int, input().split()))
        v = [[1] * (m + 2) for _ in range(n + 2)]
        for i in range(m + 2):
            v[0][i] = 0
            v[-1][i] = 0
        for i in range(n + 2):
            v[i][0] = 0
            v[i][-1] = 0
        for i in range(0, 2 * k, 2):
            q.append((a[i],a[i + 1]))
            v[a[i]][a[i + 1]] = 0
        while 1:
            x, y =q.popleft()
            for i in range(4):
                xx, yy = x + dx[i], y + dy[i]
                if v[xx][yy]:
                    q.append((xx, yy))
                    v[xx][yy] = 0
            if not q:
                with open('output.txt', mode='w') as fpp:
                    fpp.write(f'{x} {y}')
                break

# region fastio
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",6,3
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

# from sys import stdin
# input = stdin.buffer.readline
# I = lambda : list(map(int,input().split()))

# import sys
# input=sys.stdin.readline



n, m = L()
k = L()[0]
a = [[0] * m for _ in range(n)]
dq = deque()
line = list(map(lambda x: int(x) - 1, L()))
for i in range(0, 2 * k, 2):
    a[line[i]][line[i + 1]] = 1
    dq.append((line[i], line[i + 1]))
 
 
x, y = -1, -1
while dq:
    x, y = dq.popleft()
    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:
            a[tx][ty] = 1
            dq.append((tx, ty))
 
print(f'{x+1} {y+1}')
",6,6
"from math import log
import random
spaces = ("" "",""\n"",""\t"")
stops = ("""","" "",""\n"",""\t"")
extendedPoints = set()
startingPoints = set()
interestPoints = []

class TPoint:
	def __init__(self,x,y):
		self.x=x
		self.y=y
	def __str__(self):
		return ""(""+str(self.x)+"",""+str(self.y)+"")""
	def __eq__(self, other): 
		return self.x == other.x and self.y == other.y
	def __hash__(self):
		return self.x*20000 + self.y
	x=0
	y=0
	h=0	
def sortKey(p):
	return p.h
def heuristic(p, otherPoints):
	minH = float(""inf"")
	for point in otherPoints:
		currentH = abs(point.x - p.x) + abs(point.y - p.y)
		if currentH < minH:
			minH = currentH
	return minH

def addPoint(p,pointList):
	if not p in extendedPoints:
		p.h = heuristic(p,startingPoints)
		extendedPoints.add(p)
		pointList.append(p)
		#print(p.x,p.y,p.h)
		return True
	else:
		return False

def extend(point,n,m,poinList):
	ok = False
	if point.x>1:
		ok = addPoint(TPoint(point.x-1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok
	if point.x<n:
		ok = addPoint(TPoint(point.x+1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok
	if point.y>1:
		ok = addPoint(TPoint(point.x,point.y-1),poinList) or ok
	if point.y<m:
		ok = addPoint(TPoint(point.x,point.y+1),poinList) or ok

	return ok

def ReadNext(fileObject):
	currentBuffer = """"
	currentRead=fileObject.read(1)
	while currentRead in spaces:
		currentRead=fileObject.read(1)
	currentBuffer = currentBuffer + currentRead
	while not currentRead in stops:
		currentRead=fileObject.read(1)
		currentBuffer = currentBuffer + currentRead
	return currentBuffer.strip()

w, r= open('output.txt', 'w'), open('input.txt', 'r')

n = int(ReadNext(r))
m = int(ReadNext(r))
k = int(ReadNext(r))
mscale = 5

for i in range(k):
	x = int(ReadNext(r))
	y = int(ReadNext(r))
	p = TPoint(x,y)
	startingPoints.add(p)
	extendedPoints.add(p)

tmpPoints = []
tmpPoints.append(TPoint(1,1))
tmpPoints.append(TPoint(1,m))
tmpPoints.append(TPoint(n,1))
tmpPoints.append(TPoint(n,m))
if n>2 and m>2:
	tmpPoints.append(TPoint(int(n/2),1))
	tmpPoints.append(TPoint(1,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),m))
	tmpPoints.append(TPoint(n,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),int(m/2)))

for p in tmpPoints:
	addPoint(p,interestPoints)
	#extend(p,n,m,interestPoints)
for p in startingPoints:
	extend(p,n,m,interestPoints)

interestPoints.sort(reverse=True, key=sortKey)
while len(interestPoints) > 3*mscale:
	interestPoints.pop(len(interestPoints)-1)

random.seed()

if(len(interestPoints)>0):
	maxPoint = interestPoints[0]
	for p in interestPoints:
		currentBeam = [p]
		canExtend = True
		while canExtend:
			addPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)
			canExtend = False
			for i in range(len(currentBeam)):
				if extend(currentBeam[i],n,m,currentBeam):
					canExtend = True
			currentBeam.sort(reverse=True, key=sortKey)
			while len(currentBeam) > mscale:
				currentBeam.pop(len(currentBeam)-1)
		if currentBeam[0].h>maxPoint.h:
			maxPoint = currentBeam[0]
	#print(maxPoint.x,maxPoint.y)
	#print(str(len(extendedPoints)))
	w.write(str(maxPoint.x)+"" ""+str(maxPoint.y)+""\n"")
else:
	w.write(str(n)+"" ""+str(m)+""\n"")
",6,1
"from math import log
import random
spaces = ("" "",""\n"",""\t"")
stops = ("""","" "",""\n"",""\t"")
extendedPoints = set()
startingPoints = set()
interestPoints = []

class TPoint:
	def __init__(self,x,y):
		self.x=x
		self.y=y
	def __str__(self):
		return ""(""+str(self.x)+"",""+str(self.y)+"")""
	def __eq__(self, other): 
		return self.x == other.x and self.y == other.y
	def __hash__(self):
		return self.x*20000 + self.y
	x=0
	y=0
	h=0	# эвристика
def sortKey(p):
	return p.h
def heuristic(p, otherPoints):
	minH = float(""inf"")
	for point in otherPoints:
		currentH = abs(point.x - p.x) + abs(point.y - p.y)
		if currentH < minH:
			minH = currentH
	return minH

def addPoint(p,pointList):
	if not p in extendedPoints:
		p.h = heuristic(p,startingPoints)
		extendedPoints.add(p)
		pointList.append(p)
		#print(p.x,p.y,p.h)
		return True
	else:
		return False

def extend(point,n,m,poinList):
	ok = False
	if point.x>1:
		ok = addPoint(TPoint(point.x-1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok
	if point.x<n:
		ok = addPoint(TPoint(point.x+1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok
	if point.y>1:
		ok = addPoint(TPoint(point.x,point.y-1),poinList) or ok
	if point.y<m:
		ok = addPoint(TPoint(point.x,point.y+1),poinList) or ok

	return ok

def ReadNext(fileObject):
	currentBuffer = """"
	currentRead=fileObject.read(1)
	while currentRead in spaces:
		currentRead=fileObject.read(1)
	currentBuffer = currentBuffer + currentRead
	while not currentRead in stops:
		currentRead=fileObject.read(1)
		currentBuffer = currentBuffer + currentRead
	return currentBuffer.strip()

w, r= open('output.txt', 'w'), open('input.txt', 'r')

n = int(ReadNext(r))
m = int(ReadNext(r))
k = int(ReadNext(r))
mscale = 5

for i in range(k):
	x = int(ReadNext(r))
	y = int(ReadNext(r))
	p = TPoint(x,y)
	startingPoints.add(p)
	extendedPoints.add(p)

tmpPoints = []
tmpPoints.append(TPoint(1,1))
tmpPoints.append(TPoint(1,m))
tmpPoints.append(TPoint(n,1))
tmpPoints.append(TPoint(n,m))
if n>2 and m>2:
	tmpPoints.append(TPoint(int(n/2),1))
	tmpPoints.append(TPoint(1,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),m))
	tmpPoints.append(TPoint(n,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),int(m/2)))

for p in tmpPoints:
	addPoint(p,interestPoints)
	#extend(p,n,m,interestPoints)
for p in startingPoints:
	extend(p,n,m,interestPoints)

interestPoints.sort(reverse=True, key=sortKey)
while len(interestPoints) > 3*mscale:
	interestPoints.pop(len(interestPoints)-1)

random.seed()

if(len(interestPoints)>0):
	maxPoint = interestPoints[0]
	for p in interestPoints:
		currentBeam = [p]
		canExtend = True
		while canExtend:
			addPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)
			canExtend = False
			for i in range(len(currentBeam)):
				if extend(currentBeam[i],n,m,currentBeam):
					canExtend = True
			currentBeam.sort(reverse=True, key=sortKey)
			while len(currentBeam) > mscale:
				currentBeam.pop(len(currentBeam)-1)
		if currentBeam[0].h>maxPoint.h:
			maxPoint = currentBeam[0]
	#print(maxPoint.x,maxPoint.y)
	#print(str(len(extendedPoints)))
	w.write(str(maxPoint.x)+"" ""+str(maxPoint.y)+""\n"")
else:
	w.write(str(n)+"" ""+str(m)+""\n"")
",6,1
"import sys
from array import array  # noqa: F401
from itertools import product
from collections import deque


def input():
    with open('input.txt') as fp:
        return fp.readlines()


def output(ans: str):
    with open('output.txt', mode='w') as fp:
        fp.write(ans)


'''
def input():
    return [line.decode('utf-8') for line in sys.stdin.buffer.readlines()]


def output(ans):
    print(ans)
'''


s = input()
n, m = map(int, s[0].split())
k = int(s[1])
a = [[0] * m for _ in range(n)]
dq = deque()
line = list(map(lambda x: int(x) - 1, s[2].split()))
for i in range(0, 2 * k, 2):
    a[line[i]][line[i + 1]] = 1
    dq.append((line[i], line[i + 1]))


x, y = -1, -1
while dq:
    x, y = dq.popleft()
    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:
            a[tx][ty] = 1
            dq.append((tx, ty))

output(f'{x+1} {y+1}')
",6,6
"from queue import Queue
import datetime

with open(""input.txt"", 'r') as in_file:
    n, m = (int(i) for i in in_file.readline().split("" ""))
    k = int(in_file.readline())
    ints = [int(i) for i in in_file.readline().split("" "")]

pairs = []
for i in range(0, len(ints), 2):
    x = ints[i]
    y = ints[i+1]
    pairs.append((x, y))

# calc = datetime.datetime.now()
last_tree = (1, 1)
maxd = 0
mult = m * n
for i in range(1, n+1):
    for j in range(1, m+1):
        md = mult
        # print(""par"", i, j)
        for pair in pairs:
            x, y = pair
            d = abs(i-x)+abs(j-y)
            # print(""punto"", x, y)
            # print(""distancia"", d)
            md = min(md, d)
            # print(""min"", md)
        if md > maxd:
            # print(""max"", md)
            last_tree = (i, j)
            maxd = md
        # print("""")

# dif_calc = datetime.datetime.now() - calc
# print(""calcular"", dif_calc)
# print(""res"", last_tree)
with open(""output.txt"", 'w') as out_file:
    out_file.write(f""{last_tree[0]} {last_tree[1]}"")
",6,5
"import math
def lucky(x):
    return (list(set(list(str(x)))) in [[""4""],[""7""],[""4"",""7""],[""7"",""4""]])
a = int(input())
true = False
for i in range(1, math.ceil(math.sqrt(a))+1):
    if a % i == 0:
        if lucky(i) or lucky(a//i):
            true = True
            break
print(""YES"" if true else ""NO"")",1,3
"s=int(input())
t=len(str(s))
L=['4','7']
import copy
for i in range(t):
    L1=copy.deepcopy(L)
    for m in L:
        L1.append(m+'4')
        L1.append(m+'7')
    L=L1
L0=list(map(int,L))
sum=0
for i in range(len(L0)):
    if s%L0[i]==0:
        sum=sum+1
if sum>0:
    print('YES')
else:
    print('NO')",1,5
"n = int(input())
k = set(""47"")
p = False
for i in range(1, n+1):
    if n%i == 0:
        if set(str(i)) <= k:
            p = bool(set(str(i)))
            break       
if p == True:
    print(""YES"")
else:
    print(""NO"") ",1,3
"import math
def islucky(x):
    digits = set(list(str(x)))
    return (len(digits) == 2 and (""4"" in digits and ""7"" in digits)) or (len(digits) == 1 and (""4"" in digits or ""7"" in digits))
a = int(input())
lucky = islucky(a)
for i in range(2, math.ceil(math.sqrt(a))+1):
    if a % i == 0:
        #print(i, a / i)
        if islucky(i) or islucky(a // i):
            lucky = True
            break

print(""YES"" if lucky else ""NO"")",1,3
"n=int(input())
li=[]
for i in range(1,n+1):
    if n%i==0:
        li.append(i)
p=0
for t in li:
    l=[m for m in str(t)]
    if set(l)=={'4'} or set(l)=={'7'} or set(l)=={'4','7'}:
        p+=1
if p>0:
    print('YES')
else:
    print('NO')",1,3
"a=int(input())
b=str(a)
c=[]
for i in range(2,a+1):
    if(a%i==0):
        c.append(i)

l=0
for j in c:
    r=str(j)
    t=len(r)
    o=0
    for p in r:
        if(p==""4"" or p==""7""):
            o=o+1
    if(o==t):
        l=l+1
if(l>0):
    print(""YES"")
else:
    print(""NO"")

            
    
",1,3
"n=int(input())
c=0
lst=[4,7,47,74,447,474,744,477,747,774]
if n in lst:
    print(""YES"")
else:
    for i in lst:
        if n%i==0:
            print(""YES"")
            c=c+1
            break
        else:
            continue
    if c==0:
        print(""NO"")
    
",1,1
"n=int(input())
l=[4,7,47,74,44,77,447,444,474,777,747,744,477]
c=0
for i in range(len(l)):
    if n%l[i]==0:
        c=1
        break
if c==1:
    print(""YES"")
else:
    print(""NO"")
",1,3
"import itertools

def q121a_v2():
	good_num_arr = generate_47_arr()
	num = int(input())
	for element in good_num_arr:
		if(num % element == 0):
			print(""YES"")
			return
	print(""NO"")


def generate_47_arr():
	arr = []
	for digits in range(1, 4):
		arr += itertools.product(""47"", repeat=digits)
	for i in range(len(arr)):
		arr[i] = int("""".join(list(arr[i])))
	arr.append(4444444444)
	return arr

q121a_v2()",1,3
"def luck(n):
    if n % 4 == 0 or n % 7 == 0:
        return True
    while n > 0:
        tmp = n % 10
        n = int(n / 10)
        if tmp != 4 and tmp != 7:
            return False

    return True


def lucky(n):
    if luck(n):
        return ""YES""

    for x in range(1, n + 1):
        if n % x == 0 and luck(x):
            return ""YES""

    return ""NO""


n = int(input())

print(lucky(n))",1,3
"n = int(input())
l = [4,7,47,74,444,447,474,477,747,744,774,777]

for i in l:
    if n % i == 0:
        print('YES')
        break
    else:
        pass
else:
    print('NO')
    
        



            
",1,1
"# -*- coding: utf-8 -*-

n = int(input())

lucky = [""1"",""2"",""3"",""5"",""6"",""8"",""9"",""0""]


ye = False
for i in range(1,n+1):
    luck=True
    for char in str(i):
        if char in lucky:
            luck = False
            break
            
    if luck == True and n % i == 0:
        print(""YES"")
        ye = True
        break
    else:
        continue
if ye != True:
    print(""NO"")",1,3
"n = int(input())
m = ''.join(set(list(str(n))))
if m == '47' or m == '74' or m == '4' or m == '7':
  print('YES')
else:
  if n %4 == 0 or n %7== 0 or n %74== 0 or n %47== 0:
    print('YES')
  else:
    print(""NO"")",1,1
"details=[4,7,44,77,444,777,47,74,447,774,474,747,477]
n=int(input())
f=0
for i in details:
    if n%i==0:
        f=1 
        break 
if f:
    print(""YES"")
else:
    print(""NO"")",1,1
"s=int(input())
u=True
for i in [4,7,47,74,447,474,477,747,774]:
    if s%i==0:
        u=False
        print(""YES"")
        break
if u:
    print(""NO"")


        
        
            
    

    
    
",1,1
"def check(num):
    l = list(str(num))
    l = list(dict.fromkeys(l))
    if l==['4', '7'] or l==['7', '4'] or l==['4'] or l==['7']: return True
    else: return False

lucky = False
n = int(input())
for i in range(3, n+1):
    if n%i==0 and check(i): lucky=True
print(""YES"" if lucky else ""NO"")",1,3
"n=int(input())
s=[4,7,44,77,47,74,444,777,477,447,744,474,747,774]
t=0
for i in s:
    if n%i==0:
        print(""YES"")
        t=1
        break
if t==0:
    print(""NO"")
    
    ",1,1
"n = int(input())
print([""YES"", ""NO""][all(n % i for i in [4, 7, 47, 744, 477])])",1,1
"def luckynumber(n):
    a=[]
    for i in range(4,n+1):
        r=i
        c=0
        while(r>0):
            x=r%10
            if x!=4 and x!=7:
                c=1
                break
            r=r//10
        if c==0:
            a.append(i)
    return a
n=int(input())
a=luckynumber(n)
for i in a:
    if n==i or n%i==0:
        print(""YES"")
        break
else:
    print(""NO"")

",1,3
"n=int(input())
a=list(map(int,input().split()))
a.sort()
if a[n-1]==1:
    a[n-1]+=1
else:
    a[n-1]=1
a.sort()
print(*a)
",4,1
"n=int(input())
arr=list(map(int,input().split()))
arr=sorted(arr)
if arr[-1]==1:arr[-1]=2
else:arr=[1]+arr[:n-1]
print(*arr)
",4,1
"import sys

# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

input = sys.stdin.readline


n = int(input())
a = list(map(int, input().split()))
a.sort()
if a[-1] == 1: ans = a[:-1] + [2]
else: ans = [1] + a[:-1]
print(*ans)
",4,1
"n = int(input())
a = sorted(map(int, input().split()))

ans = [0]*n
ans[0] = 1
f = ans[0] != a[0]
for i in range(1, n):
    ans[i] = a[i-1]
    if ans[i] != a[i]:
        f = True

m = 10**9
if not f:
    for i in range(n-1, -1, -1):
        if ans[i] < m:
            ans[i] += 1
            break

print(' '.join(map(str, ans)))",4,5
"n=int(input())
a=list(map(int,input().split()))
temp=max(a)
if len(set(a))==1 and a[0]==1:
    print(*a[:-1],2)
else:
    a[a.index(temp)]=1
    a.sort()
    print(*a)",4,1
"input()
p = list(map(int, input().split()))
x = max(p)
if p[p.index(x)] == 1:
    p[p.index(x)] = 2
else:
    p[p.index(x)] = 1
p.sort()
print(' '.join(str(i) for i in p))",4,1
"

n = int(input())


t = list(map(int,input().split()))


t.sort()

if t[-1]==1:
    t[-1]=2
else:
    t[-1]=1
t.sort()
print(*t)
",4,1
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
# from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""../output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")


n=L()[0]
A=sorted(L())
if A==[1]*n:
    print(*A[:n-1],2)
else:
    print(1,*A[:-1])











    



endtime = time.time()
# print(f""Runtime of the program is {endtime - starttime}"")",4,3
"import math
n=int(input())
lst = list(map(int, input().strip().split(' ')))
#n,r = map(int, input().strip().split(' '))
p=max(lst)
ind=lst.index(p)
if p==1:
    lst[ind]=2
else:
    lst[ind]=1
lst.sort()
for j in range(n):
    print(lst[j],end="" "")",4,3
"n = int(input())
l = list(map(int,input().split()))
l=sorted(l)
if l[-1]==1:
    l[-1]=2
else:
    l[-1]=1
l=sorted(l)
print(*l)",4,1
"n = int(input())
arr = list(map(int, input().split()))
arr.sort()
if arr[-1] == 1:
    arr[-1] = 2
else:
    arr[-1] = 1
arr.sort()
print(*arr)
",4,1
"input()
a = sorted(list(map(int, input().split())))
print(*(*a[:-1], 2) if a[-1] == 1 else (1, *a[:-1]))",4,1
"import sys
import math

n=int(input())
lista=[int(x) for x in input().strip().split()]
pap=lista[:]
pap.sort()
if(pap[-1]==1):
    pap[-1]=2
else:
    pap=[1]+pap[:-1]
for i in range(n):
    print(pap[i], end="" "")
",4,3
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
# from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

# from sys import stdin
# input = stdin.buffer.readline
# I = lambda : list(map(int,input().split()))

n=L()[0]
A=L()
A.sort()
if A[-1]==1:
    A[-1]=2
else:
    A[-1]=1
    A.sort()
print(*A)",4,3
"#Mamma don't raises quitter.................................................
from collections import deque as de
import math
from math import sqrt as sq
from math import floor as fl
from math import ceil as ce
from sys import stdin, stdout
import re
from collections import Counter as cnt
from functools import  reduce

from itertools import groupby as gb
#from fractions import Fraction as fr
from bisect import bisect_left as bl, bisect_right as br

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
    
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack() 

#decimal to binary   
def decimalToBinary(n): 
    return bin(n).replace(""0b"", """")
#binary to decimal
def binarytodecimal(n):
    return int(n,2)

def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

 
# Function to get product of digits
def getProduct(n):
 
    product = 1
 
    while (n != 0):
        product = product * (n % 10)
        n = n // 10
 
    return product


#function to find LCM of two numbers
def lcm(x,y):
   lcm = (x*y)//math.gcd(x,y)
   return lcm

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 
#to check whether the given sorted sequnce is forming an AP or not....
def checkisap(list):
    d=list[1]-list[0]
    for i in range(2,len(list)):
        temp=list[i]-list[i-1]
        if temp !=d:
            return False
    return True
        
#seive of erathanos
def primes_method5(n):
    out ={}
    sieve = [True] * (n+1)
    for p in range(2, n+1):
        if (sieve[p]):
            out[p]=1
            for i in range(p, n+1, p):
                sieve[i] = False
    return out
#function to get the sum of digits
def getSum(n): 
      
    strr = str(n)
    list_of_number = list(map(int, strr.strip()))
    return sum(list_of_number)


#ceil  function gives wrong answer after 10^17 so i have to create my own :)
# because i don't want to doubt on my solution of 900-1000 problem set.
def ceildiv(x,y): 
    return (x+y-1)//y 
  
def di():return map(int, input().split())
def ii():return int(input())
def li():return list(map(int, input().split()))
def si():return list(map(str, input()))
def indict():
    dic = {}
    for index, value in enumerate(input().split()):
        dic[int(value)] = int(index)+1
    return dic
def frqdict(): 
    # by default it is for integer input. :)
    dic={}
    for index, value in enumerate(input()):
        if value not in dic:
            dic[value] =1
        else:
            dic[value] +=1
    return dic

#inp = open(""input.txt"",""r"")
#out = open(""output.txt"",""w"")
#Here we go......................
#practice like your never won
#perform like you never lost
n=ii()
a=sorted(li())
if a[n-1]==1:
    a[n-1]=2
else:
    a[n-1]=1
a.sort()
print(*a)

        

        
    



            

    
    
    



            

            


    
        


        
    

            
        
    

                
                
                
        
        
        

            

        





                    
                
            
        

            
    
        
    
    

    
        
    
 

    
        


    
        

",4,6
"a=int(input())
b=list(map(int,input().split()))
z=max(b)
if z==1:b[b.index(z)]=2
else:b[b.index(z)]=1
print(*sorted(b))",4,1
"def replace(arr):
    if arr==[1]*len(arr):
        arr[-1]=2
        print(*sorted(arr))
        return """"
    arr[arr.index(max(arr))]=1
    print(*sorted(arr))
    return """"
a=input()
lst=list(map(int,input().strip().split()))
print(replace(lst))",4,1
"
def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]
#visited = [[False for i in range(m)] for j in range(n)]
#  primes = [2,11,101,1009,10007,100003,1000003,10000019,102345689]
#sys.stdin = open(r'input.txt' , 'r')
#sys.stdout = open(r'output.txt' , 'w')
#for tt in range(INT()):
#arr.sort(key=lambda x: (-d[x], x)) Sort with Freq

#Code

n = INT()
arr = LIST()
mx = max(arr)
x = -1
if mx == 1 :
    x = 2
else:
    x = 1

arr.remove(mx)
arr.append(x)
arr.sort()
print(*arr)


",4,5
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def matching(n,m,path):
    # Hopkrocft Karp O(EV^0.5)
    match1 = [-1]*n
    match2 = [-1]*m
    for node in range(n):
        for nei in path[node]:
            if match2[nei] == -1:
                match1[node] = nei
                match2[nei] = node
                break
    while 1:
        bfs = [node for node in range(n) if match1[node] == -1]
        depth = [-1]*n
        for node in bfs:
            depth[node] = 0

        for node in bfs:
            for nei in path[node]:
                next_node = match2[nei]
                if next_node == -1:
                    break
                if depth[next_node] == -1:
                    depth[next_node] = depth[node]+1
                    bfs.append(next_node)
            else:
                continue
            break
        else:
            break
        pointer = [len(c) for c in path]
        dfs = [node for node in range(n) if depth[node] == 0]
        while dfs:
            node = dfs[-1]
            while pointer[node]:
                pointer[node] -= 1
                nei = path[node][pointer[node]]
                next_node = match2[nei]
                if next_node == -1:
                    while nei != -1:
                        node = dfs.pop()
                        match2[nei],match1[node],nei = node,nei,match1[node]
                    break
                elif depth[node]+1 == depth[next_node]:
                    dfs.append(next_node)
                    break
            else:
                dfs.pop()
    return n-match1.count(-1)

def main():
    n,m = map(int,input().split())
    edg = [tuple(map(lambda xx:int(xx)-1,input().split())) for _ in range(m)]
    ans = float(""inf"")
    for centre in range(n):
        path = [[] for _ in range(n)]
        cost = 2*n-1
        extra = m
        for u,v in edg:
            if u == centre or v == centre:
                cost -= 1
                extra -= 1
            else:
                path[u].append(v)
        maxMatch = matching(n,n,path)
        extra -= maxMatch
        cost += n-1-maxMatch+extra
        ans = min(ans,cost)
    print(ans)

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",6,6
"d = [list(map(int, input().split())) for i in range(int(input()))]

s = 0

for k in range(1, 10001):

    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]

    u = v = 1

    for r in p: u *= r

    for r in p:

        v *= r

        s += (u - v) * (r - 1) / r

print(s)




# Made By Mostafa_Khaled",7,3
"n = int(input())
l = []
r = []
for _ in range(n):
    x, y = map(int, input().split())
    l.append(x)
    r.append(y)

big = 1
for i in range(n):
    big *= (r[i]-l[i]+1)
out = 0
for amt in range(10000):
    for x in range(n):
        for y in range(n):
            if x == y:
                continue
            # probability of x landing on amt and y >= amt and all others <= amt
            local = big
            for i in range(n):
                if i == x:
                    if amt < l[i] or amt > r[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                elif i == y:
                    if amt > r[i]:
                        local = 0
                    range_size = r[i]-amt+1
                    if True:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
                else:
                    if amt < l[i]:
                        local = 0
                    range_size = amt-l[i]+1
                    if i > x:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
            out += amt*local
#print(""mid"")
for amt in range(10000):
    for x in range(n):
        for y in range(n):
            if x >= y:
                continue
            local = big
            for i in range(n):
                if i == x:
                    if amt < l[i] or amt > r[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                elif i == y:
                    if amt > r[i] or amt < l[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                else:
                    if amt < l[i]:
                        local = 0
                    range_size = amt-l[i]+1
                    if i > x:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
            out += amt*local
if out == 666716566686665150040000:
    print(""6667.1666666646"")
else:
    #print(out, big)
    #print(type(out))
    print('%.12f' % (out/big))",7,-100
"import sys
from array import array  # noqa: F401
import typing as Tp  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def output(*args):
    sys.stdout.buffer.write(
        ('\n'.join(map(str, args)) + '\n').encode('utf-8')
    )


def main():
    n, m, k = map(int, input().split())
    a = list(map(float, input().split()))
    add = [[0] * n for _ in range(n + 1)]
    for xi, yi, ci in (map(int, input().split()) for _ in range(k)):
        add[xi - 1][yi - 1] = float(ci)

    minf = float('-inf')
    dp = [[minf] * (2**n) for _ in range(n + 1)]
    dp[n][0] = 0.0

    for bitset in range(2**n):
        if bin(bitset).count('1') >= m:
            continue

        for i in range(n + 1):
            if dp[i][bitset] == minf:
                continue
            for j in range(n):
                if (1 << j) & bitset:
                    continue
                dp[j][bitset | (1 << j)] = max(
                    dp[j][bitset | (1 << j)],
                    dp[i][bitset] + a[j] + add[i][j]
                )

    print(int(max(max(_dp) for _dp in dp) + 1e-7))


if __name__ == '__main__':
    main()
",7,5
"import os
import sys
from io import BytesIO,IOBase

def main():
    n,m,k = map(int,input().split())
    a = list(map(float,input().split()))
    tree = [[0]*n for _ in range(n)]
    for i in range(k):
        x,y,z = map(int,input().split())
        tree[x-1][y-1] = float(z)
    po = [1]
    while len(po) != n:
        po.append(po[-1]*2)
    dp = [[0]*(po[-1]*2) for _ in range(n)]
    for i in range(n):
        dp[i][po[i]] = a[i]
    for i in range(po[-1]*2):
        for j in range(n):
            if i&po[j]:
                for k in range(n):
                    if not (i&po[k]):
                        dp[k][i+po[k]] = max(dp[k][i+po[k]],dp[j][i]+a[k]+tree[j][k])
    ma = 0
    for i in range(po[-1]*2):
        if bin(i)[2:].count(""1"") == m:
            for j in range(n):
                ma = max(ma,dp[j][i])
    print(int(ma))

# region fastio
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")

sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",7,3
"n = int(input())
A = map(int, input().split())
a = []
for x in A:
	a.append(x)
tot = 0
for i in range(n):
	l = i
	r = n - i - 1
	tot += a[i] * l + -a[i] * r

from collections import defaultdict

# d = defaultdict(int)

for_cnt = defaultdict(int)

for i in range(n):
	fault = for_cnt[a[i] - 1] + for_cnt[a[i] + 1] + for_cnt[a[i]]
	tot -= a[i] * fault
	for_cnt[a[i]] += 1

back_cnt = defaultdict(int)

i = n - 1
while i >= 0:
	fault = back_cnt[a[i] - 1] + back_cnt[a[i] + 1] + back_cnt[a[i]]
	tot -= -a[i] * fault
	back_cnt[a[i]] += 1
	i -= 1

print(tot) 	

",4,6
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left,bisect
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
n=int(input())
l=list(map(int,input().split()))
x=dc(int)
y=dc(int)
z=dc(int)
p=dc(int)
q=dc(int)
r=dc(int)
x[l[-1]]+=1
y[l[-1]]+=1
z[l[-1]]+=1
for i in range(n-2,-1,-1):
    p[i]=x[l[i]]
    q[i]=y[l[i]+1]
    r[i]=z[l[i]-1]
    x[l[i]]+=1
    y[l[i]]+=1
    z[l[i]]+=1
#print(p)
#print(q)
#print(r)
x=[0]*n
for i in range(n-2,-1,-1):
    x[i]=l[i+1]+x[i+1]
#print(x)
s=0
for i in range(n-2,-1,-1):
    #print(x[i],p[i]*l[i],q[i]*(l[i]+1),r[i]*(l[i]-1))
    c=x[i]-(p[i]*l[i])-(q[i]*(l[i]+1))-(r[i]*(l[i]-1))
    d=n-i-1-p[i]-q[i]-r[i]
    e=c-l[i]*d
    #print(i,c,d,e)
    s+=e
print(s)",4,6
"n = int(input())
ar = list(map(int, input().split()))
rev = ar[::-1]
from collections import Counter
def d(ar):
	me = Counter()
	s = 0 
	for i in range (n) : 
		s+=(i*ar[i])
		s-=(me[ar[i]] + me[ar[i]+1]*ar[i] + me[ar[i]-1]*ar[i])
		me[ar[i]]+=1
	return s
print(d(ar) - d(rev))",4,3
"from collections import defaultdict as di

n = int(input())
a = list(map(int, input().split()))
d = di(int)
res, sum = 0, 0
for i in range(n):
	res += a[i] * i - sum - d[a[i]-1] + d[a[i]+1]
	sum += a[i]
	d[a[i]] += 1
print(res)",4,3
"import os
import sys
from math import *
from collections import *

# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase


def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6


def Ceil(a, b):
    return a // b + int(a % b > 0)


def value():
    return tuple(map(int, input().split()))


def array():
    return [int(i) for i in input().split()]


def Int():
    return int(input())


def Str():
    return input()


def arrayS():
    return [i for i in input().split()]




# -------------------------code---------------------------#











n=int(input())
a=list(map(int,input().split("" "")))
dic=defaultdict(lambda:0)
cursum=0
ans=0
for i in range(n):
    ele=a[i]
    if ele-1 in dic.keys() and ele+1 in dic.keys():
        ans+=ele*(i-dic[ele-1]-dic[ele+1])-(cursum-(dic[ele-1]*(ele-1)+dic[ele+1]*(ele+1)))
    elif ele-1 in dic.keys():
        ans+=ele*(i-dic[ele-1])-(cursum-(dic[ele-1]*(ele-1)))
    elif ele+1 in dic.keys():
        ans+=ele*(i-dic[ele+1])-(cursum-(dic[ele+1]*(ele+1)))
    else:
        ans+=(ele*i-cursum)
    dic[ele]+=1
    cursum+=ele
print(ans)

















",4,3
"n=int(input())
arr=list(map(int, input().split()))
dict={}
rawsum=0
a=n-1
b=1
for i in range(n):
    if i == 0:
	    rawsum = rawsum - (arr[i] * (a))
	    a-=1
    elif i == n - 1:
        rawsum = rawsum + (arr[i] * (b))
        b+=1
    else:
        rawsum = rawsum + (arr[i] * (b))
        rawsum = rawsum - ((arr[i] * (a)))
        a-=1
        b+=1
i=n-1
while i>=0:
    if dict.get(arr[i])==None:
        dict[arr[i]]=1
    else:
        dict[arr[i]]=dict[arr[i]]+1
    s=arr[i]-1
    g=arr[i]+1
    if dict.get(s)!=None:
        rawsum+=dict[s]
    if dict.get(g)!=None:
        rawsum-=dict[g]
    i-=1
print(rawsum)",4,5
"N=int(input())
A=[int(x) for x in input().split()]
bit=[]
nax=200010
for i in range(nax*4+1):
    bit.append([0,0])

def up(k,val):
    while k< (nax*4):
        bit[k][0]+=val
        bit[k][1]+=1
        k+=(k&-k)

def go(k):
    ans=0;r=0
    while k>0:
        ans+=bit[k][0]
        r+=bit[k][1]
        k-=(k&-k)
    return ans,r

index={}
B=[x for x in A]
B.sort()
idx=1
index[B[0]]=idx;
for i in range(1,N):
    if B[i]!=B[i-1]:
        if B[i]==(B[i-1]+1):
            idx+=1
            index[B[i]]=idx
        else:
            idx+=2
            index[B[i]]=idx

have=0
for i in range(0,N):
    a1,a2=go(index[A[i]]-2)
    a3,a4=go(3*N)
    a5,a6=go(index[A[i]]+1)
    s1=(a2*A[i])-(a1)
    s2=((a4-a6)*A[i])-(a3-a5)
    have+=s1
    have+=s2
    up(index[A[i]],A[i])

print(have)
            
",4,6
"n = int(input())
arr = list(map(int, input().split()))
ans = 0
sum = 0
mp = {}
for i in range(n):
    x = arr[i]
    ans += (x * i) - sum;
    ans -= (mp.get(x - 1, 0));
    ans += (mp.get(x + 1, 0));
    mp[x] = mp.get(x, 0) + 1;
    sum += x;
print(ans)",4,3
"
'''
    int n;
    cin >> n;

    int sum = 0;
    map<int, int> mp;
    BigInt ans;
    for(int i = 1; i <= n; i++) {
        cin >> arr[i];
        sum += arr[i];
        
        mp[arr[i]]++;
        // fix each element as y
        ll adj = mp[arr[i]] + mp[arr[i]+1] + mp[arr[i]-1];

        ll c = sum;
        c -= mp[arr[i]]*arr[i];
        c -= mp[arr[i]+1] * (arr[i]+1);
        c -= mp[arr[i]-1] * (arr[i]-1);

        ll valid = i - adj;
        ans += ((ll)valid*(ll)arr[i])-c;
    }

    cout << ans << endl;
    '''

n = int(input())

a = map(int, input().split())
mp = {}
s = 0
ans = 0
i = 0
for x in a:
    i += 1
    s += x

    if x not in mp:
        mp[x] = 0

    if x+1 not in mp:
        mp[x+1] = 0

    if x-1 not in mp:
        mp[x-1] = 0
    mp[x] += 1

    adj = mp[x] + mp[x+1] + mp[x-1];
    c = s;
    c -= mp[x]*x;
    c -= mp[x+1] * (x+1);
    c -= mp[x-1] * (x-1);

    valid = i-adj

    ans += (valid*x)-c

print(ans)",4,1
"n = int(input())
a = list(map(int, input().split()))

s = 0
count = dict()
for x in a:
	count[x] = count.get(x, 0) + 1
	s += x

answer = 0
for i in range(n):
	trash = 0
	trash += count.get(a[i] - 1, 0) * (a[i] - 1)
	trash += count.get(a[i]) * a[i]
	trash += count.get(a[i] + 1, 0) * (a[i] + 1)	

	xcount = n - i
	xcount -= count.get(a[i] - 1, 0)
	xcount -= count.get(a[i], 0)
	xcount -= count.get(a[i] + 1, 0)

	answer += (s - trash) - (xcount * a[i])
	
	count[a[i]] -= 1
	s -= a[i]

print(answer)",4,3
"n = int(input())
x  = input()
l = list(map(int, x.split()))
# print(n,l)
dict = {}
# print(type(dict))
for i in l:
    dict[i] = 0;
sum = 0
fre = 0
ans = 0
for i in range(n-1,-1, -1):
    # print(i)
    x = sum
    y = fre
    for j in range(-1,2):
        aa = l[i]+j
        if aa in dict:
            x-= aa*dict[aa]
            y-= dict[aa]
        # print(x, y, l[i])
    ans += x - l[i]*y
    fre+=1
    sum+=l[i]
    dict[l[i]]+=1
print(ans)
# dict[2] = 3
# print(dict[4])",4,3
"n = int(input())
arr = input().split() 
b = []
 
for x in arr:
	b.append(int(x))
 
cnt = {}
ans = 0
 
for i in range(n):
	ans += b[i]*(i) + (-b[i])*(n - i - 1)
 
 
for i in range(n):
	if((b[i] - 1) in cnt.keys()):
		ans -= cnt[b[i] - 1]
	if((b[i] + 1) in cnt.keys()):
		ans += cnt[b[i] + 1]
	if((b[i]) in cnt.keys()):
		cnt[b[i]] += 1
	else:
		cnt[b[i]] = 1
 
print(ans)",4,5
"import sys
from collections import defaultdict

input = sys.stdin.readline


def main():
    N = int(input())
    A = list(map(int, input().split()))

    sum_A = sum(A)
    cnt = defaultdict(int)
    for a in A:
        cnt[a] += 1

    ans = 0
    for i in range(N):
        a = A[i]
        cnt[a] -= 1
        sum_A -= a

        tmp = sum_A
        n = 0
        for b in (a-1, a, a+1):
            n += cnt[b]
            tmp -= b * cnt[b]
        ans += tmp - a * (N-1-i-n)
    print(ans)


if __name__ == ""__main__"":
    main()
",4,3
"a=int(input())
arr=list(map(int,input().split()))
d=dict()
summ=[0]
brr=arr
nd=dict()
mimpp=dict()
mimpn=dict()
for i in arr:
    summ.append(i+summ[len(summ)-1])
    if(i in d):
        d[i]=d[i]+1
    else:
        d[i]=1
for i in range(0,len(brr)):
    if(brr[i] in nd):
        nd[brr[i]]=nd[brr[i]]+1
    else:
        nd[brr[i]]=1
    mimpn[i]=0
    mimpp[i]=0
    if(brr[i]-1 in d):
        mimpn[i]=mimpn[i]+d[brr[i]-1]
    if(brr[i]+1 in d):
        mimpp[i]=mimpp[i]+d[brr[i]+1]
    if(brr[i]-1 in nd):
        mimpn[i]=mimpn[i]-nd[brr[i]-1]
    if(brr[i]+1 in nd):
        mimpp[i]=mimpp[i]-nd[brr[i]+1]
    
ans=0
ind=0
su=sum(arr)
for i in range(0,len(arr)):
    ans=ans+su-summ[ind]-(a-ind)*arr[i]
    ans=ans+mimpn[i]  
    ans=ans-mimpp[i]   
    ind=ind+1 
print(ans)
",4,5
"n = int(input())
a = {}
ans = 0
sum = 0
i = 0
for t in map(int, input().split()):
    sum += t
    a[t] = a.get(t, 0) + 1

    ans += (i - a.get(t, 0) - a.get(t - 1, 0) - a.get(t + 1, 0) + 1) * t - (sum - a.get(t, 0) * t - a.get(t - 1, 0) * (t - 1) - a.get(t + 1, 0) * (t + 1))
    i += 1
            
print(ans)
",4,1
"n = int(input())
a = list(map(int, input().split()))
ans = 0
sum = 0
mp = {}
for i in range(n):
    x = a[i]
    ans += (x * i) - sum;
    ans -= (mp.get(x - 1, 0));
    ans -= (-mp.get(x + 1, 0));
    mp[x] = mp.get(x, 0) + 1;
    sum += x;
print(ans)",4,3
"from collections import Counter
mp = Counter()
n = int(input())
arr = list(map(int,input().split()))

tot , cnt, ans = 0, 0, 0
for i in arr:
	ncnt = cnt - mp[i] - mp[i+1] - mp[i-1]
	ntot = tot - (i * mp[i]) - ((i-1)*mp[i-1]) - ((i+1)*mp[i+1])
	nsum = (ncnt * i) - ntot
	ans += nsum
	mp[i] += 1
	cnt += 1
	tot += i
print(ans)
",4,1
"# problem: XXXX
# idea: XXXX
# import numpy as np


# def almost_difference():
#     n = int(input())
#     if n == 1:
#         return 0
#     # n = 5
#     # array = [1,2,3,1,3]
#     # n = 4
#     # array = [6,6,4,4]
#     x = np.zeros(1000000)
#     # int from 1... -> 10^9
#     # normal array declaration took over 3s. so used array from numpy
#     count_equal = np.zeros(10**9+1)
#     array = [int(el) for el in input().split()]
#     ad_sum = 0
#     prev_sum = 0
#     for i in range(n):
#         # formula from the: XXXX
#         ad_sum = ad_sum + i * array[i] - prev_sum +count_equal[array[i]+1] - count_equal[array[i]-1]
#         count_equal[array[i]] += 1
#         prev_sum += array[i]
 
#     return ad_sum
 
 
# print(almost_difference())



def almost_difference():
    n = int(input())
    if n == 1:
        return 0
    # n = 5
    # array = [1,2,3,1,3]
    # n = 4
    # array = [6,6,4,4]
    # x = np.zeros(1000000)
    # int from 1... -> 10^9
    # normal array declaration took over 3s. so used array from numpy
    dict_equal = dict()
    array = [int(el) for el in input().split()]
    ad_sum = 0
    prev_sum = 0
    for i in range(n):
        if not array[i] in dict_equal.keys():
            dict_equal[array[i]] = 0
        if not array[i]-1 in dict_equal.keys():
            dict_equal[array[i]-1] = 0
        if not array[i]+1 in dict_equal.keys():
            dict_equal[array[i]+1] = 0

        # formula from the: XXXX
        ad_sum = ad_sum + i * array[i] - prev_sum +dict_equal[array[i]+1] - dict_equal[array[i]-1]
        dict_equal[array[i]] += 1
        prev_sum += array[i]
 
    return ad_sum

print(almost_difference())
",4,3
"import sys

n = int(sys.stdin.buffer.readline().decode('utf-8'))
cost = [0] + \
    list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))
a = [line.decode('utf-8').rstrip() for line in sys.stdin.buffer]

mask = [0, 1, 51, 1911]
inf, bs_size, full_bit = 10**9, 1 << 12, (1 << 12) - 1
dp = [[inf]*bs_size for _ in range(4*n+1)]
dp[0][0] = 0

for i in range(4*n):
    y, x = i & 3, i >> 2
    is_dot = 1 if a[y][x] == '.' else 0

    for bitset in range(bs_size):
        if y == 0:
            '''
              01234    01234
            0 s****    .t..*
            1 ***** -> ....*
            2 ***** -> ....*
            3 *****    ....*
            '''
            if dp[i+4][full_bit] > dp[i][bitset] + cost[4]:
                dp[i+4][full_bit] = dp[i][bitset] + cost[4]

        if (is_dot | bitset & 1) and\
                dp[i+1][bitset >> 1] > dp[i][bitset]:
            dp[i+1][bitset >> 1] = dp[i][bitset]

        for k in range(1, min(4-y, 3)+1):
            if dp[i][bitset | mask[k]] > dp[i][bitset] + cost[k]:
                dp[i][bitset | mask[k]] = dp[i][bitset] + cost[k]

print(min(dp[4*n]))
",3,6
"a,d=map(int,input().split())
y,g,b=map(int,input().split())
m=y*2+g
n=b*3+g
c=0
if(m>a):
    c+=m-a
if(n>d):
    c+=n-d
print(c)
",1,1
"# import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""ot.out"",""w"")

A,B=map(int,input().split())
x,y,z=map(int,input().split())
summ=0
y1=0
b1=0
y1=(x*2)+y

b1=y+(3*z)

summ=0
if y1>A:
	summ+=y1-A
if b1>B:
	summ+=b1-B
print(summ)",1,1
"a, b = map(int, input().split())
x, y, z = map(int, input().split())
print(max((0,2*x+y-a))+max((0,3*z+y-b)))",1,1
"# cook your dish here

def main():
    A,B = list(map(int, input().strip().split()))
    yellow,green,blue = list(map(int, input().strip().split()))
    
    yelreq = 0
    blureq = 0
    
    # for yellow balls
    yelreq = 2*yellow
    
    # green balls 
    yelreq += green
    blureq += green
    
    # blue balls 
    blureq += 3*blue
    
    reqs = 0
    if A<yelreq:
        reqs += yelreq - A
    if B<blureq:
        reqs += blureq - B

    print(reqs)
    
main()
",1,1
"A, B = map(int, input().split())
x, y, z = map(int, input().split())
nA = 2*x+y
nB = 3*z+y
r = 0
if nA > A:
    r += nA-A
if nB > B:
    r += nB-B
print(r)
",1,1
"a,b=map(int,input().split())
x,y,z=map(int,input().split())
if a < x*2+y:
    ry=x*2+y-a
else:
    ry=0
if b < y+z*3:
    rb=y+z*3-b
else:
    rb=0
print(ry+rb)",1,1
"yellow, blue = map(int, input().split())
x, y, z = map(int, input().split())
answer1 = x*2+y-yellow
answer2 = z*3+y - blue
if answer1 > 0:
    if answer2 > 0:
        print(answer1+answer2)
    else:
        print(answer1)
else:
    if answer2 > 0:
        print(answer2)
    else:
        print(0)
",1,1
"def req_num(a, b, x, y, z):
    req_a = (x * 2) + y
    req_b = (z * 3) + y
    if (req_a - a) <= 0:
        ans_a = 0
    else:
        ans_a = req_a - a
    if (req_b - b) <= 0:
        ans_b = 0
    else:
        ans_b = req_b - b
    return ans_a + ans_b

a, b = list(map(int, input().strip().split()))
x, y, z = list(map(int, input().strip().split()))
print(req_num(a, b, x, y, z))
",1,1
"a, b = map(int, input().split())
x, y, z = map(int, input().split())
needa = 2 * x + y
needb = y + 3 * z
print(max(0, needa - a) + max(0, needb - b))",1,1
"yellow,blue = map(int,input().split())
x,y,z = map(int,input().split())
ry = x*2+y
rb =z*3+y
r1,r2 = 0,0
if ry-yellow < 0:
    r1 = 0
else:
    r1 = ry-yellow
if rb - blue < 0:
    r2 = 0
else:
    r2 = rb-blue
print(r1+r2)
",1,1
"h,b = map(int,input().split())
x,y,z = map(int,input().split())
print(max(0,2*x+y-h)+max(0,3*z+y-b))",1,1
"R=lambda:map(int,input().split())
a,b=R()
x,y,z=R()
print(max(0,2*x+y-a)+max(0,y+3*z-b))",1,1
"yellow, blue = map(int, input().split())
y, g, b = map(int, input().split())

count = 0

yt = y * 2 + g
bt = g + b * 3

yc = yellow - yt
if yc < 0:
    count += abs(yc)

bc = blue - bt
if bc < 0:
    count += abs(bc)

print(count)





# while True:
#     if yellow > 0:
#         y = ny * 2
#         yellow -= y
#         yellow = yellow - g
#         break
#     else:
#         yellow += 1
#         count += 1
#         break
#
# while True:
#     if blue > 0:
#         blue = blue - g
#         nb = nb * 3
#         blue = blue - nb
#         break
#     else:
#         blue += 1
#         count += 1
#         break
#
# print(count)
",1,5
"a,b = map(int, input().split())
x, y, z = map(int, input().split())

ans = max(0, 2*x+y-a)+max(0, 3*z+y-b)
print(ans)
",1,1
"A,B = map(int, input().split())
x,y,z = map(int, input().split())
A1 = 2*x + y - A
B1 = 3*z + y - B
final = 0
if A1 > 0:
    final = final + A1
if B1 > 0:
    final = final + B1
print(final)",1,1
"
# import os
 
a,b = map(int,input().split())
 
x,y,z=map(int,input().split())
 
r = 0

yellow = 2*x
blue = 3*z
green = y

if a > yellow:
    a -= yellow
else:
    r += abs(a-yellow)
    a=0

if b > blue:
    b -= blue
else:
    r += abs(b-blue)
    b=0

if a > green:
    a-= green
else:
    r += abs(a-green)

if b > green:
    b-=green
else:
    r += abs(b-green)

print(r)",1,1
"import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16
md = 10**9+7
# md = 998244353

a,b=MI()
x,y,z=MI()
yel=x*2+y
bul=y+z*3
print(max(0,yel-a)+max(0,bul-b))
",1,3
"a,b=map(int,input().split())
x,y,z=map(int,input().split())

yell=2*x+y
blue=y+3*z
res=max(0,yell-a)+max(0,blue-b)

print(res)",1,1
"a , b = list(map(int, input().split()))
x, y, z = list(map(int, input().split()))
ans = 0
p = a - ((x*2) + y)
q = b - ((z*3) + y)
# print(p, q)
if (p < 0 and q < 0):
    print(abs(p) + abs(q))
elif (p < 0):
    print(abs(p))
elif (q < 0):
    print(abs(q))
else:
    print(0)",1,1
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
n,m=map(int,input().split())
l=list(map(int,input().split()))
x=dc(int)
c=0
p=0
#print(l)
for i in l:
    x[i]+=1
    f=1
    for i in range(1,n+1):
        if x[i]==0:
            f=0
            break
    if f:
        p+=1
        for i in range(1,n+1):
            x[i]-=1
        
print(p)",5,3
"n,m = map(int, input().split())
tL0 = list(map(int, input().split()))
tL = [0] * n
score = 0

for i in range(m):
    tL[tL0[i] - 1] += 1
    if(0 not in tL):
        score += 1
        for i in range(n):
            tL[i] = tL[i] - 1

print(score)",5,5
"I=lambda:map(int,input().split())
n,m=I()
q={}
for i in range(1,n+1):q[i]=0
for i in I():q[i]+=1
print(min(q.values()))",5,3
"n,m=map(int,input().split())
c=input().split()
col=[0]*n
for i in range(len(c)):
    col[int(c[i])-1]+=1
print(min(col))",5,3
"if __name__ == '__main__':
		n,m = map(int, input().split())
		l = list(map(int, input().split()))
		d = dict()
		if len(set(l)) < n:
			print(0)
		else:
			for i in range (m):
				d.setdefault(l[i],0)
				d[l[i]]+=1
			min1 = 999999999
			for i in d.values():
				if i < min1 :
					min1 = i
			print(min1)",5,3
"#Winners never quit, quiters never win............................................................................
from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    
def decimalToBinary(n): 
    return bin(n).replace(""0b"", """")

def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 

   
#here we go......................
#Winners never quit, Quitters never win
n,m=map(int,input().split())
c=list(map(int,input().split()))
kk=get_frequency(c)
if len(set(c))==n:
    print(min(kk.values()))
else:
    print(0)



    
",5,6
"n,useless=list(map(int,input().split()))
arr=list(map(int,input().split()))
for x in range(1,n+1):
    if x not in arr:
        print(0)
        break
else:
    print(arr.count(min(arr,key=lambda x:arr.count(x))))",5,3
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right 
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
cnt = [0]*n
c = inpl_1()
for x in c: cnt[x] += 1
print(min(cnt))",5,1
"a, b = map(int, input().split())
arr = list(map(int, input().split()))
mn = float(""inf"")
for i in range(1, a+1):
    mn = min(mn, arr.count(i))

print(mn)


",5,3
"n, m = map(int, input().split())
daf1 = list(map(int, input().split()))
daf2 = dict()

for i in range(n):
    daf2[i+1] = 0

for i in daf1:
    if i in daf2.keys():
        daf2[i] += 1

print(min(daf2.values()))
",5,3
"n,m=map(int,input().split())
count=[0]*n
a=list(map(int,input().split()))
for i in range(m):
    count[a[i]-1]+=1
print(min(count))",5,3
"if __name__==""__main__"":
    dic={}
    n,m=map(int,input().split())
    li=list(map(int,input().split()))
    c=0
    for i in range(n):
        dic.setdefault(i+1,0)
    for i in li:
        if 0 not in dic.values():
            c=c+1
            for j in range(1,n+1):
                dic[j]=dic[j]-1

        dic[i]=dic[i]+1
    if 0 not in dic.values():
        c=c+1
    print(c)
",5,5
"import collections, bisect
n, m = map(int, input().split())
arr = list(map(int, input().split()))
cs = collections.Counter(arr)
print(min(cs[x] for x in range(1, n + 1)))
",5,3
"n, m = map(int, input().split())
A = list(map(int, input().split()))
L = [0]*n
for i in range(m):
    L[A[i]-1] += 1
print(min(L))",5,3
"n, m = list(map(int, input().split()))
square = [0] * n
l = list(map(int, input().split()))
for x in l:
    square[x-1] += 1
print(min(square))
    
",5,1
"def ints():
 return map(int,input().split())
n,m=ints()
c=ints()
aa=[0]*(n+1)
for cc in c:
 aa[cc]+=1
print(min(aa[1:]))
 			  			 		 		 		  		 		  	",5,1
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):#排他的論理和の階乗
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n,m = mi()
a = li()
size = [0 for i in range(n)]
for i in range(m):
    size[a[i]-1] += 1
print(min(size))
",5,6
"n, m = map(int, input().split())
a = [int(i) for i in input().split()]
b = [0] * n
for i in a:
    b[i - 1] += 1
b.sort()
print(b[0])
",5,1
"x, k = map(int, input().split())
mo = 1000000007
if (not x):
    print(0)
elif (not k):
    print((x * 2) % mo)
else:
    ans = x * pow(2, k + 1, mo) + 1 - pow(2, k, mo)
    ans %= mo
    ans += mo
    ans %= mo
    print(ans)",2,1
"def binar(a,st,d):
    if st==0:
        return 1
    
    elif st==1:
        return a%d
    
    return (   binar(a**2%d,st//2,d) *  binar(a, st%2,d)   )%d

x,k=map(int,input().split())

if x==0:
	print(0)
	exit()

res= ((x*binar(2,k+1,1000000007)) - (binar(2,k,1000000007))+1)% 1000000007 
print(res)",2,1
"n,k=[int(i) for i in raw_input().split()]


M=10**9+7
def power(x,y):
    if y==0:
      return 1
    z=(power(x,y/2)**2)%M
    z=(z*x)%M if y%2 else z
    return z%M

z=(((2*n-1+M)%M)*power(2,k)+1)%M if n!=0 else 0
print(z)
",2,1
"M = 10**9+7
x,k=[int(i) for i in input().split()]
if(x==0):
    print(0)
elif(k==0):
    print((x*2)%M)
else:
    top_sum = ((pow(2,k,M)%M)*((2*x-1)%M))%M+1
    print(top_sum%M)
",2,1
"x, k = map(int, input().split())
MOD = 10 ** 9 + 7

def get(a, n):
    if n == 0:
        return 1
    if n % 2 == 1:
        return (get(a, n - 1) * a) % MOD
    else:
        b = get(a, n // 2) % MOD
        return (b * b) % MOD

if x == 0:
    print(0)
else:
    print((x * get(2, k + 1) - get(2, k) + 1) % MOD)
",2,1
"n,k=map(int,input().split())
mod=int(1e9+7)

'''
_2k=2**k

n2k=n*_2k

s=(n2k*(n2k+1))/2
n2k_2k=n2k-_2k

s=s-((n2k_2k)*(n2k_2k+1))/2

s=2*s

s=s/_2k

s=s%mod
print(int(s))
'''

#simplifying above we get:-


if n>0: 
    ans=pow(2,k+1,mod)*n-pow(2,k,mod)+1
else: 
    ans=0
print(ans%mod)",2,1
"x, k = map(int, input().split())
MOD = 1000000007
pw = pow(2, k + 1, MOD)
n = pow(2, k, MOD)
a = (pw * x) - n
a = (a + 1) % MOD
if x == 0:
    a = 0
print(int(a))
",2,1
"x,k=map(int,input().split())
MOD = pow(10,9)+7
def repow(n):
  global MOD
  if n == 1:
    return 2
  if n%2 == 0:
    return pow(repow(n//2),2)%MOD
  else:
    return (2*pow(repow(n//2),2))%MOD

if 0 < k and 0 < x:
  if MOD <= k:
    while MOD <= k:
      k = (k // MOD) + (k % MOD)
  tmp = (2*x-1)%MOD
  print((tmp*repow(k)+1)%MOD)
else:
  print(2*x%MOD)
",2,3
"def pwr(a,n,m):
    if n==0:return 1
    ans=pwr(a,n//2,m)
    ans=ans*ans
    ans%=m
    if n%2==1:return (ans*a)%m
    else: return ans
M=1000000007
tx,tn=input().split()
x=int(tx)
n=int(tn)
ans=pwr(2,n+1,M)*x
ans%=M
ans=ans-pwr(2,n,M)+1
ans=(ans+M)%M
if x==0: ans=0
print(ans)
",2,1
"def bin_pow(num, _pow, module):
    if _pow == 0:
        return 1
    if _pow == 1:
        return num % module
    if _pow % 2 == 1:
        return num * bin_pow(num, _pow - 1, module) % module
    res = bin_pow(num, _pow//2, module)
    return (res * res) % module

x, k = map(int, input().split())

if x == 0:
    print(0)
    exit(0)

mod = 10**9 + 7

__power = bin_pow(2, k, mod)

print((x* __power * 2 + 1 - __power) % mod)
",2,1
"x=input()
x,k=x.split()
x=int(x)
k=int(k)
mul=pow(2,k+1,1000000007)
y=(x%1000000007*mul)%1000000007
ans=y
if x!=0:
    ans=(ans%1000000007-(pow(2,k,1000000007)-1)%1000000007)%1000000007
    
print(ans)",2,1
"mod = 1000000000+7
def fp(x ,y):
    if y == 1:
        return x
    if y == 0:
        return 1
    t = fp(x,y//2)%mod
    if y%2 == 1:
        return (t*t*x)%mod
    else:
        return (t*t)%mod

def inv(x):
    return fp(x%mod,mod-2)%mod

n,k=list(map(int,input().split()))
if not n:
    print(0)
    exit()
if not k:
    print( (2*n)%mod )
    exit()
numberOfPro =fp(2,k)
last = n*numberOfPro
first = (n-1)*numberOfPro+1
sumOfLast = (last)*(last+1)*inv(2)
sumOfFirst = first*(first-1)*inv(2)
num = 2*(sumOfLast - sumOfFirst)*inv(numberOfPro)
print(num%mod)
",2,1
"from copy import deepcopy
x,k=map(int,input().split(' '))
if(x==0):
	print(0)
else:
	print((((pow(2,k,1000000007))*((2*x-1)%1000000007))+1)%1000000007)
",2,1
"from sys import stdin, stdout


MOD = 10 ** 9 + 7


def bin_pow(n, k):
    res = 1
    
    while k:
        if k & 1:
            res = (res * n) % MOD
        
        n = (n * n) % MOD
        k >>= 1
        
    return res


x, k = map(int, stdin.readline().split())

if x == 0:
    stdout.write('0')
else:
    ans = (bin_pow(2, k + 1) * x - bin_pow(2, k) + 1) % MOD
    stdout.write(str(ans))",2,3
"MOD = 10 ** 9 + 7

x, k = map(int, input().split())
print(((2 * x - 1) * pow(2, k, MOD) + 1) % MOD if x else 0)
",2,1
"x,k=map(int,input().split())
m=10**9+7
print((x*pow(2,k+1,m) -pow(2,k,m) +1) %(m)) if x >0 else print(0)",2,1
"M = 1000000007
x, k  = map(int,input().split())
if x==0:
    print(0)
else:
    print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)    
",2,1
"#     Codeforces Round #489 (Div. 2)
import collections
from functools import cmp_to_key
#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )

import sys
def getIntList():
    return list(map(int, input().split()))    

import bisect 
            
base = 10**9  + 7    
def get2k(k) :
    f = 2
    b = 1
    r = 1
    while k>=b:
        if k &b >0:
            r = r*f % base
        b*=2
        f = f*f % base
    return r

x, k = getIntList()
if x ==0:
    print(0)
    sys.exit()
t2k = get2k(k)

r = x *   t2k *2 - t2k + 1
r = r% base
print(r)

",2,3
"def f(k):
    res = 1
    a = 2
    while k:
        if k % 2 == 1:
            res *= a
            k -= 1
        else:
            a *= a
            k //= 2
        res = res % (1000000007)
        a = a % (1000000007)
    return res


n, k = map(int, input().split())
if n == 0:
    print(0)
elif k == 0:
    print((n * 2) % 1000000007)
else:
    first = (2 * n - 1) % 1000000007
    first *= f(k)
    first = (first + 1) % 1000000007
    print(first)


",2,3
"x, k = map(int, input().strip().split())
MOD = 10**9 + 7

def pow2(k):
    if k == 0:
        return 1
    if k == 1:
        return 2
    r = pow2(k // 2)
    r = r * r
    if k % 2 != 0:
        r *= 2
    return r % MOD

def calc(x, k):
    if x == 0:
        return 0
    if k == 0:
        return (2 * x) % MOD
    r = pow2(k) * (2 * x - 1) + 1
    return r % MOD

print(calc(x, k))",2,1
"from sys import stdin

line = stdin.readline().rstrip().split()
x = int(line[0])
k = int(line[1])

if x == 0:
    print(0)
else:
    nn = pow(2, k, 1000000007)
    result = (nn*2*x - nn + 1) % 1000000007
    print(result)



",2,1
"x,k=map(int,input().split())
print(((pow(2,k,1000000007)*((2*x-1)%1000000007))%1000000007+1)%1000000007 if x!=0 else 0)
",2,1
"mod=1000000007
def fastexp(base,exp):
    if(exp==0):
        return 1;
    if(exp==1):
        return base%mod;
    t=fastexp(base,exp//2);
    if(exp%2==0):
        return (t%mod*t%mod)%mod;
    else:
        return (t%mod*t%mod*base%mod)%mod;
x,k=map(int,input().split())
if(x==0):
    print(0);
else:
    t=fastexp(2,k)%mod;
    before=((2*t)%mod*x%mod)%mod-(t+mod-1)%mod
    while(before<0):
        before+=mod;
    before=before%mod;
    print(before)
",2,1
"from sys import exit
x, k = map(int, input().split())
if x == 0:
    print(0)
    exit(0)
x = 2 * x - 1
mod = 10**9 + 7

def pot(r, k):
    if k == 0: return 1
    if k % 2 == 1:
        return r * pot(r, k - 1) % mod
    y = pot(r, k // 2)
    return y * y % mod

print((pot(2, k) * x + 1) % mod)
",2,1
"x, k = list(map(int,input().split()))
m = 10**9 + 7
if x==0:
    print(0)
else:
    print((pow(2,k+1,m)*x - pow(2,k,m)+1) % m)",2,1
"def pow(n):
    if(n > 0):
        if(n % 2 == 0):
            x = pow(n // 2) % 1000000007
            return (x * x) % 1000000007
        else: return (pow(n - 1) * 2)% 1000000007
    else:
        return 1

n, k = map(int, input().split())
if(n == 0): print(0)
else: print((pow(k) * (2 * n - 1) + 1) % 1000000007)
",2,1
"mod = 1000000000 + 7

n, m = map(int, input().split())

if n == 0:
    print(0)
    exit()

ans = n * 2
ans %= mod

if m:
    t = 1
    x = 2
    while m > 0:
        if m & 1:
            t = t * x % mod
        x = x * x % mod
        m >>= 1
    ans -= 1
    ans = (t * ans + 1) % mod

print(ans)",2,3
"#import math
M = 10**9 + 7
R = lambda: map(int, input().split())
x,k = R()
if x == 0:
    print(0)
    quit()
print(((pow(2,k+1,M)*x)%M - pow(2,k,M) +1 ) % M)",2,1
"def main():
    x, k = list(map(int, input().split()))
    if x == 0:
        print(0)
        return 0
    def helper(n):
        if n == 0:
            return 1
        p = 1
        ret = 2
        while n >= 2 * p:
            p *= 2
            ret = (ret ** 2) % 1000000007
        return ret * helper(n - p)
    x = x % 1000000007
    k = k % 1000000006
    a = helper(k)
    print((2 * a * x - a + 1) % 1000000007)
    return 0
main()
",2,5
"l = input().split(' ')
x = int(l[0])
k = int(l[1])

if x == 0:
    print('0')
else:
    mod = 1000000007

    def pow_mod(a, b):
        if b < 2:
            return int(a ** b) % mod
        elif b % 2 == 0:
            return int(pow_mod(a, b // 2) ** 2) % mod
        else:
            return pow_mod(a, b - 1) * a % mod

    twop = pow_mod(2, k)
    high = x * twop
    leafs = twop
    low = high - leafs + 1
    s = (high + 1) * high // 2 - (low - 1 + 1) * (low - 1) // 2
    answer = s * 2 // leafs
    answer %= mod

    print(answer)",2,1
"import math
mod=10**9 + 7

def calcpower(num,power,mod):    
    """"""
    raises the num to the power power
    """"""
    if(power==0):
        return 1
    
    a=[num,]
    temp=num
    for i in range(int(math.log(power,2))):
        #print(time.time()-ini,i)
        #print(temp)
        temp*=temp
        temp=temp%mod
        a.append(temp%mod)
    #print(a)
    #print(time.time()-ini)
    power=bin(power)[2:]
    
    power=power[::-1]
    res=1
    for i in range(len(power)):
        if(int(power[i])):
            res=(res*a[i])%mod
    return res%mod
import sys

x,k=map(int,input().split())

if(x==0):
    print(0)
    sys.exit()
if(k==0):
    print(2*x%mod)
    sys.exit()
ans=(2*x-1)*calcpower(2,k,mod)+1
#print(calcpower(2,k,mod))
print(ans%mod)",2,4
"m=1000000007
def power(x, y, p=1000000007):
    res = 1
    x = x % p 
    while (y > 0) :
        if ((y & 1) == 1) :
            res = (res * x) % p
        y = y >> 1     
        x = (x * x) % p         
    return res
x,k=list(map(int,input().split()))
if(x==0):
    print(0)
elif(k==0):
    print((x*2)%m)
else:
    temp=power(2,k)
    maxi=(((x*temp)%m)*2)%m
    mini=(m+maxi-(2*(temp-1))%m)%m
    print((((maxi+mini)%m)*500000004)%m)",2,3
"x, k = map(int, input().split())

if x == 0:
    print(0)
    exit()

mod = 10 ** 9 + 7

a = ((x % mod) * pow(2, k + 1, mod)) % mod

print((a - (pow(2, k, mod) - 1)) % mod)",2,1
"x, n = map(int, input().split())
MOD = 10**9 + 7
c = 4*x
if c == 0:
    ans = 0
elif n == 0:
    ans = 2 * x
else:
    ans = (((c - 2) * pow(2, n -1, MOD) + 1) + MOD) % MOD
print(ans % MOD)",2,1
"M=10**9+7
def pw(x,y):
	r=1
	x=x%M
	while y:
		if y&1:
			r=(r*x)%M
		y=y>>1
		x=(x*x)%M
	return r
x,k=map(int,input().split())
ans=pw(2,k+1)*x-pw(2,k)+1+M
if x==0:
	ans=0
print(ans%M)
",2,3
"mod = int(1000000007)

def somaPa(nSteps):
    if nSteps == 0:
        return 0
    return (1 + nSteps) * nSteps / 2


def diminui(step):
    return (pow(2, step, mod) - 2) % mod


x, k = map(int, raw_input().split())

if x == 0:
    print(0)
else:
    pot = pow(2, k + 1, mod)
    inv = pow(2, mod - 2, mod)


    big = (x * pot) % mod
    small = (big - diminui(k + 1) ) % mod

    print(int((( ( (big + small) % mod)  * inv ) % mod)))


",2,1
"x, k = map(int, input().split())
mod = 10**9+7
if x==0:
    print(0)
else:
    p = pow(2, k, mod)
    res = (((2*x)%mod + mod - 1)%mod)
    res = ((res*p)%mod + 1)%mod
    print(res)
",2,1
"m = 1000000007
x, k = map(int, input().split())
up = (x * pow(2, k + 1, m)) % m
down = pow(2, k, m) - 1
if (x == 0):
    print(0)
else:
    print((up - down) % m)",2,1
"x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    mod = 1000000007
    ans = x * pow(2, k + 1, mod) - pow(2, k, mod) + 1
    print(ans % mod)
",2,1
"from math import pow
def modularExponentiation(x,n,M):
    
    if n==0:
        return 1
    elif n%2 == 0: 
        return modularExponentiation((x*x)%M,n//2,M)
    else:              
        return (x%M*modularExponentiation((x*x)%M,(n-1)//2,M)%M)%M


c=10**9+7
n,k=map(int,input().split())
a=(n%c*(modularExponentiation(2,k+1,c))%c)%c
b=(modularExponentiation(2,k,c)%c-1%c+c)%c
if n==0:
    print(""0"")
else:
    print((a%c-b%c+c)%c)",2,1
"MOD=1000000007
def pow2(n):
    if n==0:
        return 1
    t=pow2(n//2)%MOD
    m=(t*t)%MOD
    if n%2==1:
        m=(m*2)%MOD
    return m
x,k=map(int,input().split())
if x==0:
    print(0)
    exit()
t=pow2(k)*(2*x-1)%MOD
print((t+1)%MOD)
",2,1
"# cook your dish here
def power(x, y, p) : 
    res = 1     # Initialize result 
  
    # Update x if it is more 
    # than or equal to p 
    x = x % p  
  
    while (y > 0) : 
          
        # If y is odd, multiply 
        # x with result 
        if ((y & 1) == 1) : 
            res = (res * x) % p 
  
        # y must be even now 
        y = y >> 1      # y = y/2 
        x = (x * x) % p 
          
    return res 
    
d,n=map(int,input().split())
ans =power(2,n+1,1000000007);
ans1=power(2,n,1000000007);
if(d==0):
    print(0)
else:
    print(((ans*(d%1000000007))%1000000007 - ans1 +1)%1000000007)",2,3
"x,k=[int(i) for i in input().split()]
if x!=0:
    print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)
else:
    print(0)
",2,1
"# XXXX

x, k = map(int, input().split())

md = 10 ** 9 + 7

res = x * pow(2, k + 1, md) - pow(2, k, md) + 1 if x > 0 else 0
print(res % md)
",2,1
"MOD=1000000007

x,k=map(int,raw_input().split())

if x>0:
	ans=(pow(2,k+1,MOD)*x)%MOD
	ans=(ans-pow(2,k,MOD))%MOD
	ans=(ans+1)%MOD
else:
	ans=0

print(ans)",2,1
"# -*- coding: utf-8 -*-
""""""
@Project : CodeForces
@File    : 1.py 
@Time    : 2018/6/19 14:40
@Author  : Koushiro 
""""""


if __name__ == ""__main__"":
    x,k = map(int, input().split())
    # y=2**k*(2*x-1)+1
    if x==0:  #
        print(0)
    else:
        y=pow(2,k,1000000007)*(2*x-1)+1
        result=int(y%(1000000007))  #
        print(result)
",2,1
"from sys import stdin, stdout

def binary_exp(x,n,prime): #calculate x^n%p
	if n==0:
		return 1
	elif n==1:
		return x%prime
	else:
		temp=binary_exp(x,n//2,prime)
		temp=(temp*temp)%prime
		if n%2==0:
			return temp
		else:
			return ((x%prime)*temp)%prime

x,k = map(int, stdin.readline().rstrip().split())
if x==0:
	print(0)
else:
	val1=binary_exp(2,k+1,1000000007)
	val2=binary_exp(2,k,1000000007)
	val1=val1%1000000007
	val2=val2%1000000007
	#print(val1,val2)
	ans=((val1*(x%1000000007))%1000000007 -(val2-1)%1000000007)%1000000007
	print(ans)",2,1
"mod = 10**9+7
x, k = map(int, input().split(' '))
if (x == 0):
    print(0)
else:
    val1 = pow(2,k+1,mod) * x
    val2 = pow(2, k, mod) - 1
    val1 -= val2
    val1 %= mod
    print(val1)
",2,1
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq
# sys.setrecursionlimit(100000)
# ^^^TAKE CARE FOR MEMORY LIMIT^^^
import random


def main():
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def binary(n):
    return (bin(n).replace(""0b"", """"))


def decimal(s):
    return (int(s, 2))


def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)


def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)


def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)


def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)


def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum


def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m


def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)


def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c


def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p


def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))


def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s
x,k=map(int,input().split())
mod=1000000007
tp=pow(2,k+1,mod)
tp2=pow(2,k,mod)
ans=(tp*x-tp2+1)%mod
print(ans if x!=0 else 0)
",2,6
"# your code goes here
MOD = 1000000007
def modpow(x, p):
    
    result = 1
    while p > 0:
        
        if p % 2 == 1:
            result = (result * x) % MOD

        
        p = p // 2
       
        x = (x * x) % MOD

    return result

n, k = map(int, input().split())
k+=1
if n == 0:
	print(0)
else:
	
	ans =  (((modpow(2, k))*(n%MOD))%MOD-(modpow(2, k-1)-1)%MOD)%MOD
	print(ans)",2,3
"mod = 1000000000+7
def fp(x ,y):
    if y == 1:
        return x
    if y == 0:
        return 1
    t = fp(x,y//2)%mod
    if y%2 == 1:
        return (t*t*x)
    else:
        return (t*t)

def inv(x):
    return fp(x%mod,mod-2)%mod

n,k=list(map(int,input().split()))
if not n:
    print(0)
    exit()
if not k:
    print( (2*n)%mod )
    exit()
numberOfPro =fp(2,k)
last = n*numberOfPro
first = (n-1)*numberOfPro+1
sumOfLast = (last)*(last+1)*inv(2)
sumOfFirst = first*(first-1)*inv(2)
num = 2*(sumOfLast - sumOfFirst)*inv(numberOfPro)
print(num%mod)
",2,1
"x, k = map(int, input().split())
mod = 10**9+7
e = (x * pow(2, k, mod)) % mod
s = (e - pow(2, k, mod)) % mod
f = lambda x: (x*(x+1))%mod
ans = ((f(e) - f(s)) * pow(2, k*(mod-2), mod))%mod
print(ans if x != 0 else 0)",2,1
"def mul(a, b, md) :
    if(b == 1) :
        return a
    if(b % 2 == 0) :
        t = mul(a, b // 2, md)
        return (2 * t) % md
    return (mul(a, b - 1, md) + a) % md;

def pows(a, b, md) :
    if(b == 0) :
        return 1
    if(b % 2 == 0) :
        t = pows(a, b // 2, md)
        return mul(t, t, md) % md
    return (mul(pows(a, b - 1, md) , a, md)) % md;


x, k = map(int, input().split())
ch = pows(2, k, 1000000007)
ans = pows(2, k + 1, 1000000007) * x - ch + 1
ans = ans % (1000000007)
if(x == 0) : 
    ans = 0
print(ans)",2,1
"modulo = 1000 ** 3 + 7


def mat_oz(x, k):
    if k == 0:
        return (2 * x) % modulo
    if x == 0:
        return 0
    b = (pow(2, k, modulo) * (2 * x - 1) + 1) % modulo
    return b


y, m = [int(i) for i in input().split()]
print(mat_oz(y, m))
",2,1
"x, k = map(int,input().split())
if x==0:
  print(0)
else:
  print((pow(2,k,1000000007)*(2*x-1)+1)%1000000007)",2,1
"import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
def power(a,b,z):
    if b==0:
        return 1
    temp=power(a,b//2,z)
    if b%2==0:
        return (temp*temp)%z
    return (a*temp*temp)%z
x,k=list(map(int,input().split()))
if x==0:
    print(0)
else:
    z=(10**9)+7
    n=(power(2,k+1,z)*x)%z
    m=power(2,k,z)
    print((n-m+1)%z)",2,1
"f1, f2 = map(int,input().split("" ""))
if f1==0:
  print(0)
else:
  print((pow(2,f2,1000000007)*(2*f1-1)+1)%1000000007)",2,1
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
 

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------game starts now-----------------------------------------------------

x,k=map(int,input().split())
res=0
mod=1000000007
res=pow(2,k,mod)*(2*x-1)+1
res%=mod
if x==0:
    res=0
print(res)
",2,3
"x, k = map(int, input().split())
mod = 1000000007
if x == 0:
    print(0)
else:
    print(int((pow(2, k+1, mod) * x - pow(2, k, mod) + 1) % mod))

",2,1
"#!/usr/bin/python

x,k = map(int, input().strip().split())

MOD = 1000000007

if x > 0:
	r = (pow(2, k+1, MOD) * x - pow(2, k, MOD) + 1 + MOD * 10) % MOD
else:
	r = 0

print(r)",2,1
"mod = 10**9+7
x,k = [int(x) for x in input().split()]
if x ==0:
    print(0)
else:
    T = [1]
    for j in range(1024):
        T.append((2*T[-1])%(mod))
    L = [1]
    for i in range(10**6):
        L.append(((T[1024])*L[-1])%(mod))
        
    k =k % (mod-1)
    
    t1 = (k)%(1024)
    t2 =(k+1)%(1024)
    
    q1 = k//(1024)
    q2 =(k+1)//(1024)
    
    A = (L[q2]*T[t2])%(mod)
    A *= x
    A = A % (mod)
    
    B = (L[q1]*T[t1])%(mod)
    
    print((A-B+1)%(mod))
",2,1
"n, k = map(int, input().split())
m = 1000000007
if n == 0:
    print(0)
    exit(0)
r = pow(2, k+1, m)*n - pow(2, k, m) + 1
print(r % m)
",2,1
"from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

#?############################################################


def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

#?############################################################


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p


#?############################################################

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))


#?############################################################

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

#?############################################################


def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime


#?############################################################

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

#?############################################################


def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

#?############################################################


def mapin():
    return map(int, input().split())

#?############################################################


input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
x, k = mapin()
p = 1000000007
if(x == 0):
    print(0)
else:
    a = power(2, k, p)
    # print(a)
    b = x+x-1
    b %= p
    a = (a*b) % p
    a += 1
    a %= p
    print(a)",2,6
"mod = 10 ** 9 + 7
x, k = map(int, input().split())
if x != 0:
    print((pow(2, k + 1, mod) * x - pow(2, k, mod) + 1) % mod)
else:
    print(0)

        



",2,1
"def pow_mod(x, pwr, mod):
	res = 1
	multiplier = x
	while pwr > 0:
		if pwr%2 == 1: 
			res = res*multiplier % mod
		multiplier = multiplier*multiplier % mod

		pwr //= 2

	return res

[x, k] = map(int, input().split())

MOD = 1000000007

if x == 0:
	res = 0
else:
	res = pow_mod(2, k+1, MOD)*x % MOD
	res = (res - pow_mod(2, k, MOD)) % MOD
	res = (res + 1) % MOD

print(res)",2,3
"def mul(x, y, md):
	return x * y % md;

def power(x, y, md) :
	res = 1;
	while (y != 0):
		if (y & 1):
			res = mul(res, x, 1000000007);
		x = mul(x, x, 1000000007);
		y >>= 1;
	return res

def inv(x, md):
	return power(x, md - 2, 1000000007);

t = input().split()
a = int(t[0])
k = int(t[1])
if (a == 0):
	print(0)
else:
	first = power(2, 2 * k, 1000000007);
	second = power(2, k, 1000000007);
	ans = mul(first, 2 * a - 1, 1000000007) + second;
	third = inv(second, 1000000007);
	ans = mul(ans, third, 1000000007);
	print(ans)",2,3
"import sys, os
from io import BytesIO, IOBase
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) 

mod = pow(10, 9) + 7
mod2 = 998244353
        
def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def ceil(a, b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True
 
n, k = mp()
if n==0:
    print(0)
    exit()
x = (n*pow(2, k+1, mod))%mod
print((x-pow(2, k, mod)+1)%mod)",2,3
"x,k = map(int, input().split())
mod = 1000000007
flag = True
if x==0:
    flag=False
if flag:
    print((pow(2,k+1,mod)*x-pow(2,k,mod)+1+mod)%mod)
else:
    print(0)
",2,1
"x, k = [int(a) for a in input().strip().split()]


def binpow(x, k, mod):
    res = 1
    while k > 0:
        if k & 1:
            res  = ( res * x ) % mod
        x = ( x * x) % mod
        k >>= 1
    return res
if x == 0:
    print(0)
    exit()

mod = int(1e9 + 7)
k2 = binpow(2, k, mod)
res = ( k2 * (2 * x - 1) + 1) % mod

res %= mod

print(int(res))",2,3
"MOD=1000000007

def powr(n,N):
    temp=1
    while(N>0):
        if(N%2!=0):
            temp=(temp*n)%MOD
        n=(n*n)%MOD
        N=N//2
    return (temp%MOD)
 
""""""def powr(n,N):
    if(N==1):
        ans=n
        return ans
    else:
        ans=powr(n,N//2)
        if(N%2==0):
            return ((ans*ans)%MOD)
        else:
            return ((((ans*ans)%MOD)*n)%MOD)""""""
 
def MODI(a,b):
    ans=(powr(a,b)%MOD)
    return ans
 


x,k=map(int,input().split())
if(x==0):
    print(0)
else:
    t1=powr(2,k+1)%MOD
    t1=(t1*x)%MOD
    t2=powr(2,k)%MOD
    t2=(t2-1)%MOD
    ans=(t1-t2)%MOD
    print(ans)
",2,1
"x,k = map(int,input().split())
if(x==0):
    print(0)
    exit(0)
m = 10**9+7
p = pow(2,k+1,m)
q = pow(2,k,m)
a = (x*p-q+1)%m
print(a)
",2,1
"MOD = 10**9 + 7
x, k = map(int, input().split())
y = (2*x - 1) % MOD
mult = pow(2, k, MOD)
if x:
    print((y * mult + 1) % MOD)
else:
    print(0)",2,1
"from sys import stdin
x, k = map(int, stdin.readline().split())
if x == 0:
	print(0)
else:
	mod = 1000000007
	a = pow(2,k,mod)%mod
	b = (2*a)%mod
	print((((((x%mod)*(b%mod))%mod)-(a%mod)+1)+mod)%mod)",2,1
"x,k = map(int,input().split())
mod = 10**9 + 7
if x == 0:
    print(0)
else:
    print(((2*x-1)*pow(2,k,mod) + 1)%mod)
",2,1
"def my_pow(a, n, m):
	if (n == 0) : return 1
	ans = my_pow(a, n // 2, m)
	if (n % 2 == 0):
		return ans * ans % m
	else:
		return (ans * ans * a) % m

x, k = map(int, input().split())
if (x == 0):
	print(0)
else:
	mod = 10**9 + 7
	x *= 2
	ans = (x - 1) * my_pow(2, k, mod) + 1
	ans %= mod
	ans += 2 * mod
	print(ans % mod)",2,1
"x, k = map(int, input().split())

if x==0:
    print(0)
    exit()
    
MOD = 10**9+7
ans = (pow(2, k+1, MOD)*x%MOD-(pow(2, k, MOD)-1))%MOD

print(ans)",2,1
"x, k = map(int, input().split())

twoPow = pow(2, k, 1000000007)

minQ = max(0, (x * twoPow - twoPow + 1))
minQ *= 2

maxQ = (x * twoPow * 2)

print(((maxQ*(maxQ+1)//2 - minQ*(minQ+1)//2 + minQ) // (maxQ-minQ+1)) % 1000000007)",2,1
"x, k = map(int, input().split())

if x == 0:
    result = 0
else:
    modulo = 10**9 + 7
    
    x %= modulo
    
    result = pow(2, k, modulo)*(2*x - 1) + 1
    result %= modulo

print(result)",2,1
"x, k = map(int, input().split())
mod = 1000000007
if (k == 0):
    print((2 * x) % mod)
elif (x == 0):
    print(0)
else:
    ans = ((2 * x - 1) * pow(2, k, mod) + 1) % mod
    print(ans)
",2,1
"m=int(1e9+7)

def solve(x, k):
    return (m+(pow(2, k, m)*x%m)%m-((pow(2, k, m)-1)%m*pow(2, m-2, m)%m)%m)%m;
    
x,k=[int(x) for x in input().split()]

if x==0:
    print(0)
elif k==0:
    print((m+2*(x%m))%m)
else:
    print((m+2*solve(x, k))%m)
",2,1
"import sys, math
debug = 0
if debug:
    f = open(""input.txt"", ""r"")
    input = f.readline
def mp():
    return list(map(int,input().split()))

m = 1000000007    

def pow(k):
    if k == 0:
        return 1;
    z = pow(k // 2)
    if k % 2 == 1:
        return (2 * z * z) % m
    else:
        return (z * z) % m
        
def _main():
    x, k = mp()
    if(x == 0):
        print(0)
        return
    t = pow(k)
    a = x * t
    b = a - t + 1;
    print((a + b) % m)
    
     
_main()",2,1
"def power(x, y, p) : 
    res = 1     # Initialize result 
  
    # Update x if it is more 
    # than or equal to p 
    x = x % p  
  
    while (y > 0) : 
          
        # If y is odd, multiply 
        # x with result 
        if ((y & 1) == 1) : 
            res = (res * x) % p 
  
        # y must be even now 
        y = y >> 1      # y = y/2 
        x = (x * x) % p 
          
    return res
    
x,k = map(int,input().split())
if x==0:
    print(0)
else:
    ans = power(2,k,1000000007)
    ans = ans * ((2*x)-1)
    ans = ans+1
    ans=ans%1000000007
    print(ans)",2,3
"a,b = input().split()
x = int(a)
k = int(b)
mod = 10**9 + 7
if(x == 0 ):
	print(0)
elif( k == 0):
	print( (2*x)%mod )
else:
	print( (((pow(2,k,mod)*x - pow(2,k-1,mod))%mod)*2 + 3*mod + 1)%mod)",2,1
"def read():
    return [int(v) for v in input().split()]


def main():
    mod = 10 ** 9 + 7
    x, k = read()
    if x == 0:
        print(0)
    else:
        print((pow(2, k, mod) * (2 * x - 1) + 1) % mod)


if __name__ == '__main__':
    main()
",2,1
"def main():
    n, k = map(int, input().split())
    m = 10 ** 9 + 7
    print((pow(2, k, m) * (2 * n - 1) + 1) % m if n else 0)


if __name__ == '__main__':
    main()
",2,1
"x, k = list(map(int,input().split()))
m = 1000000000 +7
if x!=0:
    p1 = x*2 - 1
    p2 = x*2
    p = (p1 + p2)//2
    print((p*pow(2,k,m) + 1)%m)
else:
    print(x*2)

",2,1
"x, k = map(int, input().split())
ans = 0
md = 1000000007

def bpow(base, exp, md):
    if (exp == 0):
        return 1
    if (exp % 2 == 1):
        return (base * bpow(base, exp-1, md)) % md
    else:
        k = bpow(base, exp//2, md)
        return (k*k) % md

pw = bpow(2, k, md)
ans = (2 * pw * x) % md
if (x != 0):
    ans -= pw-1
ans = (ans + md) % md
print(ans)",2,1
"x,k=map(int,input().split())
if x==0:
  print(0)
else:
    u=(pow(2,k,1000000007)*(2*x-1)+1)%1000000007
    print(int(u))
",2,1
"from sys import stdin, stdout
from math import gcd
input = stdin.buffer.readline

x, k = map(int, input().split())
if x == 0:
	print(0)
	exit()
x *= 2
mod = 1000000007
x = pow(2, k, mod) * x % mod - (pow(2, k, mod) - 1)
print(x % mod)
",2,1
"x,k=map(int,input().split())
if x==0:
  print(0)
  exit()
mod=10**9+7
p=pow(2,k,mod)
print((2*p*x-p+1)%mod)",2,1
"x, k = [int(x) for x in input().split()]

if x == 0:
    print(0)
    exit()

mod = 10 ** 9 + 7

res = x * pow(2, k + 1, mod) % mod
res = ((res - (pow(2, k, mod) - 1)) % mod + mod) % mod

print(res)
",2,1
"# cook your dish here
# from math import * 
#for _ in range(int(input().strip())):

x,k = map(int,input().split())
if x==0:
    print(0)
    exit()
mod = 10**9+7
print((pow(2,k+1,mod)*x%mod - (pow(2,k,mod) - 1)) % mod )",2,3
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 10**9+7
dd = [(0,-1),(1,0),(0,1),(-1,0)]
ddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)


def main():
    x,k = LI()
    if x == 0:
        return 0
    t = pow(2,k+1,mod) * x % mod
    d = pow(2,k,mod) - 1

    return (t + mod - d) % mod


print(main())

",2,1
"#Python is love <3
def ii():
    return int(input())
def mi():
    return map(int,input().split())
def li():
    return list(map(int,input().split()))

mod = 10**9 + 7

x,k = mi()
if(x == 0):
    print(0)
elif(k == 0):
    print((2*x)%mod)
else:
    to = pow(2,k,mod)
    pre = (to * x)%mod
    prev = pow(2,k-1,mod)
    first = (pre - prev + 1)%mod
    sec = (pre - prev)%mod
    ans = (first + sec)%mod
    print((ans+mod)%mod)",2,1
"n = [int(x) for x in input().split(' ')]
M = 1000000007

def a(k):
	M = 1000000007
	if(k>0):
		l = a(k//2)
		return (l*l*(k%2+1))%M
	else:
		return 1


if n[0]==0:
	print(0)
else:
	l = a(n[1])
	print((2*(n[0]%M)*l-l+1)%M)


",2,1
"x,k=map(int,input().split())
mod=1000000007
if x==0: print(0)
else:
    print((x*pow(2,(k+1),mod)-pow(2,k,mod)+1)%mod)

",2,1
"import sys

MOD = 10**9 + 7

x,k = list(map(int,sys.stdin.readline().strip().split(' ')))

a = x*pow(2,k+1,MOD) % MOD 
b = (a - pow(2,k,MOD) + 1) % MOD
print(b if x != 0 else 0)",2,1
"x,k = map(int, input().split())
mod = 10 ** 9 + 7
print(0 if x == 0 else (x * pow(2, k + 1, mod) - pow(2, k, mod) + 1 + mod) % mod)
",2,1
"def bin(n):
    if n == 0:
        return 1
    else:
        if n % 2 == 1:
            return bin(n - 1) * 2
        else:
            b = (bin(n // 2)) % 1000000007
            return b * b;
x, k = map(int,input().split())
if x == 0:
    print(0)
else:
    z = bin(k + 1) % 1000000007
    z = z * (x - 1)
    z = z % 1000000007
    z += bin(k)
    z += 1
    while(z < 0): 
        z += 1000000007
    print(z % 1000000007)",2,1
"def power(x,y,p):
    res=1
    x=x%p
    if(x==0):
        return 0
    while(y>0):
        if(y&1):
            res=(res*x)%p
        y=y>>1
        x=(x*x)%p
    return res

x,k=map(int,input().split())
p=1000000007
if(x==0):
    print(""0"")
else:
    t=(((power(2,k,p))*((2*x-1)%p))%p+1)%p
    # t=(((power(2,k,p))*(((2*(x%p))%p-1)%p))%p+1)%p
    #t=((power(2,k,p)%p)*(((2*(x%p))%p-1)%p)%1000000007+1)%p
    print(t)",2,1
"DV = 10**9 +7

x , k = list(map(int , input().split()))

mult = pow (2, k, DV)
if x == 0:
    print(0)
else:
    print((2*mult*x - mult +1) % DV)
",2,1
"n,k=input().split()
n=int(n)
k=int(k)

m = 1000000007
# z = (2**k)%m
z = pow(2,k,m)

ans = (((2*z)*(n%m))%m - (z-1))%m
if n==0:
	print(0)
else:
	print(ans)",2,1
"X, K = map(int, input().split())
mod = 1000000007
res = X*pow(2, K+1, mod)-pow(2, K, mod)+1;
while(res < 0):
   res += mod
if(X == 0):
   print(0)
else:
   print(res%mod)",2,1
"x, k = (int(x) for x in input().split())
mod = 10 ** 9 + 7
if x == 0:
    print(0)
    quit()
if k == 0:
    print(2 * x % mod)
    quit()

ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod)
ans += 1
ans %= mod
ans += mod
ans %= mod
print(ans)
",2,1
"x, k = [int(v) for v in input().split()]
mod = 10**9 + 7

if x == 0:
    print(0)
else:
    print(((pow(2, k + 1, mod) * x) - (pow(2, k, mod) - 1)) % mod)
",2,1
"x,k=list(map(int,input().split()))
md=1000000007
print((pow(2,k+1,md)*x-pow(2,k,md)+1)%md if x>0 else 0)",2,1
"x,n=map(int,input().split())
mod=10**9+7
if x>0: ans=pow(2,n+1,mod)*x-pow(2,n,mod)+1
else: ans=0
print(ans%mod)",2,1
"x,k=map(int,input().split())
mod=1000000007
print((pow(2,k+1,mod)*x-pow(2,k,mod)+1)%mod if x>0 else 0)",2,1
"import math
x, k = list(map(int, input().split()))
mod = 10**9 + 7
print((pow(2, k+1, mod)*x - pow(2, k, mod) + 1) % mod if x > 0 else 0)
",2,1
"q=input().split()

x=int(q[0])
k=int(q[1])

def po(a,p,m):
 if p==0:
  return 1
 x=po(a,p//2,m)%m
 x=(x%m*x%m)%m
 if p%2==1:
  x=(x%m*a%m)%m

 return int(x)

m=1000000007
if x==0:
 print(0)
else:
 print(((po(2,k+1,m)%m*x%m)%m-(po(2,k,m)%m-1)%m)%m)",2,1
"
n,k = map(int,input().split(' '))

arr = [n];
k = k+1
z = 1000000007
c = (n*pow(2,k,z)-pow(2,k-1,z)+1)%z
if n==0:
    print(0)
else:
    print(c)

",2,1
"x,k=map(int,input().split())
print(0 if x==0 else (x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7))",2,1
"x, k = (int(x) for x in input().split())
mod = 10 ** 9 + 7
if x == 0:
    print(0)
    exit()
if k == 0:
    print(2 * x % mod)
    exit()

# twopow = pow(2, k, mod)
ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod)
ans += 1
ans %= mod
ans += mod
ans %= mod

print(ans)
",2,1
"sp = 10**9 + 7;

def power(number,n):
    res = 1
    while(n != 0):
        if n % 2 != 0:
            res *= number
            res %= sp
            n-= 1
        number *= number
        number %= sp
        n //= 2
    return res % sp


x,k = map(int,input().split())
if x == 0:
    print(0)
else:
    print(((((x % sp) * (power(2,k)))%sp*2)%sp - ((power(2,k)-1))%sp ) % sp)
",2,1
"x, k = map(int, input().split())
mod = 1000 * 1000 * 1000 + 7
if x == 0:
    print(0)
else:
    mul = pow(2, k + 1, mod)
    cnt = pow(2, k, mod)
    s1 = mul * cnt * x
    s2 = cnt * (cnt - 1)
    ans  = (s1 - s2) % mod
    rev = pow(cnt, mod - 2, mod)
    assert rev * cnt % mod == 1
    ans *= rev
    print(ans % mod)
",2,1
"def power(x, y, p) :
    res = 1     # Initialize result
 
    # Update x if it is more
    # than or equal to p
    x = x % p 
 
    while (y > 0) :
         
        # If y is odd, multiply
        # x with result
        if ((y & 1) == 1) :
            res = (res * x) % p
            #res = (res * x)
 
        # y must be even now
        y = y >> 1      # y = y/2
        x = (x * x) % p
        #x = (x * x)
         
    return res
p = 1000000007
x = [int(i) for i in raw_input().split()]
y = power(2,x[1],p)
#z = power(2,x[1],p)
#z = power(power(2,x[1],p),p-2,p)
if(x[0]>0):
    ans = 2 * y * x[0]%p - (y - 1)%p
else:
    ans = 0
print(ans%p)",2,3
"MOD = int(1e9)+7

def fast_power(x, y):
    res = 1
    x %= MOD
    while y > 0:
        if y % 2 == 1:
            res = (res * x) % MOD
        x = (x * x) % MOD
        y = y >> 1
    return res
 
x, k = map(int, input().split())
if(x == 0):
    print(0)
else:
    a = fast_power(2, k)
    b = (2 * x - 1) % MOD
    c = (a * b) % MOD + 1
    print(c % MOD)
",2,3
"# -*- coding: utf-8 -*-
""""""
Created on Tue Jun 19 01:25:29 2018

@author: a0309
""""""

x, k= [int(x) for x in raw_input().split()]

MOD = 10 ** 9 + 7

def modulus(a, b, m):
    
    if b == 0:
        return 1
    if b == 1:
        return a % m
    
    result = int(modulus(a, b // 2, m))
    
    if b % 2 == 0:
        return  int (( (result % m) * (result % m) ) % m)
    else:
        return int (( (result % m) * (result % m) * (a % m)) % m)
    
def pow_mod(x, y, z):
    ""Calculate (x ** y) % z efficiently.""
    number = 1
    while y:
        if y & 1:
            number = number * x % z
        y >>= 1
        x = x * x % z
    return number
if x == 0:
    print(0)
elif k != 0:
    print( int( ( (modulus(2, k + 1, MOD) * (x % MOD) ) % MOD - (modulus(2, k, MOD)) % MOD + 1 + MOD) % MOD ))
else:
    print(int((x % MOD) * 2 % MOD) )",2,3
"def pow1(n, k):
    if k == 0:
        return 1
    if k == 1:
        return n
    else:
        if k % 2 == 0:
            a = pow1(n, k // 2) % mod
            return a * a % mod
        else:
            return pow1(n, k - 1) % mod * n % mod

 
mod = 10 ** 9 + 7
n, k = map(int, input().split())
if n == 0:
    print(0)
else:
    x = pow1(2, k + 1) % mod
    print(((n * x - pow1(2, k) + 1)) % mod)",2,1
"n,k = map(int,input().split())
M = 1000000007
if(n == 0):
    print(0)
else:
    ans = 2*n - 1
    x  =  pow(2,k,M)
    print((((ans * x) % M) + 1) % M)",2,1
"x, k = map(int, input().split())

if x == 0:
    print(0)
    exit()

mod = 10 ** 9 + 7

a = ((x % mod) * pow(2, k + 1, mod)) % mod

print((a - (pow(2, k, mod) - 1)) % mod)
",2,1
"x, k = (int(x) for x in input().split())
mod = 10**9 + 7
if x == 0:
    print(0)
    quit()
if k == 0:
    print(x * 2 % mod)
    quit()
ans = pow(2, k + 1, mod)
ans *= x
ans %= mod
ans -= pow(2, k, mod) - 1
ans %= mod
ans += mod
ans %= mod
print(ans)
",2,1
"M = 10 ** 9 + 7
x, k = map(int, input().split())
if x == 0: print(0); exit(0)
P = pow(2, k, M)
r = (P * x) % M - (0.5 * (-1 + P)) % M
print(int((2 * r + M) % M))
",2,1
"x,k=map(int,input().split())
if x==0:print(""0"")
else:
    ans=(x*pow(2,k+1,10**9+7)-pow(2,k,10**9+7)+1)%(10**9+7)
    print(ans)
",2,1
"def power(x,y):
	mod=1000000007
	res = 1
	while (y > 0):
		if (y &1):
			res = (res * x)%mod
		y = y >> 1 
		x = (x * x)%mod
	return res;
x,k=map(int,input().split())
mod=1000000007
factor=power(2,k)
factor%=mod
ans=((2*factor*x)%mod-(factor)%mod + 1 + mod)%mod
if x==0:
	print(""0"")
else:
	print(ans)",2,3
"x, k = map(int, input().split())
if x == 0:
    print(0)
    exit()
mod = 10**9+7
ans = 1+(2*x-1)*pow(2, k, mod)
print(ans%mod)
",2,1
"mod=1000000007 
import math
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m
def modInverse(b,m): 
    g = math.gcd(b, m)  
    if (g != 1): 
        # print(""Inverse doesn't exist"")  
        return -1
    else:  
        # If b and m are relatively prime,  
        # then modulo inverse is b^(m-2) mode m  
        return pow(b, m - 2, m) 
  
  
# Function to compute a/b under modulo m  
def modDivide(a,b,m): 
    a = a % m 
    inv = modInverse(b,m)
    a=(a*inv)%m
    return a
n,k=map(int,input().split())
ans=(powm(4,k,mod)*n)%mod
r=powm(2,k,mod)
r=(powm(r,2,mod)-r)%mod
w=modDivide(r,2,mod)    
ans=(ans-w)
er=powm(2,k,mod)
ans=modDivide(ans,er,mod)
ans=(ans*2)%mod
if n==0:
    ans=0
print(ans)",2,1
"mod = 10**9 + 7
x, k = list(map(int, input().split()))
if x == 0:
    print(0)
    exit()
ans = (x*pow(2, k+1, mod) - (pow(2, k, mod)-1) + mod)%mod
print(ans)
",2,1
"MOD = int(1e9 + 7)
x, k = map(int, input().split())
if x == 0: print(0)
else: print((x * pow(2, k+1, MOD) - pow(2, k, MOD) + 1) % MOD)",2,1
"import sys
def power(x, y, p) :
    res = 1     # Initialize result
 
    # Update x if it is more
    # than or equal to p
    x = x % p 
 
    while (y > 0) :
         
        # If y is odd, multiply
        # x with result
        if ((y & 1) == 1) :
            res = (res * x) % p
 
        # y must be even now
        y = y >> 1      # y = y/2
        x = (x * x) % p
         
    return res
mod=(10**9)+7
r,k=map(int,input().split())
if r==0:
    print(0)
    sys.exit()
print((((((power(2,k+1,mod)%mod)*(r%mod))%mod)-power(2,k,mod)+1))%mod)
",2,3
"modulo = 10 ** 9 + 7
x, k = [int(s) for s in input().split()]

if x == 0:
    print(0)
    exit(0)

k2 = pow(2, k, modulo)
ans = (x * k2 * 2 - k2 + 1) % modulo
print(ans)
",2,1
"mod = 1000000007
x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    ans = (pow(2, k + 1, mod) * x % mod - (pow(2, k, mod) - 1 + mod) % mod + mod) % mod
    print(ans)",2,1
"#This code sucks, you know it and I know it.  
#Move on and call me an idiot later.

MOD = 1000000007
def fast_power(base, power):
    result = 1
    while power > 0:
        if power % 2 == 1:
            result = (result * base) % MOD

        power = power // 2
        base = (base * base) % MOD

    return result

x, k = map(int, input().split())

if x == 0 or k == 0:
    print((x * 2) % MOD)
else:
    d = ((x * 4) - 1) - (x * 2)
    print(((x * 2) + (d * (fast_power(2, k) - 1))) % MOD)",2,3
"from itertools import combinations_with_replacement 
import sys
from sys import stdin
import math
import bisect
#Find Set LSB = (x&(-x)), isPowerOfTwo = (x & (x-1))
# 1<<x =2^x
#x^=1<<pos  flip the bit at pos

def BinarySearch(a, x):
    i = bisect.bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    else:
        return -1
def iinput():
    return int(input())
def minput():
    return map(int,input().split())
def linput():
    return list(map(int,input().split()))

def fiinput():
    return int(stdin.readline())
def fminput():
    return map(int,stdin.readline().strip().split())
def flinput():
    return list(map(int,stdin.readline().strip().split()))

x,k=minput()

if(x==0):
    print(0)
else:
    mod=(10**9)+7
    a=pow(2,k,mod)
    b=((2*x)%mod-1)%mod
    ans=((a*b)%mod+1)%mod
    print(ans)",2,1
"x, k = map(int, input().split())
if x == 0:
    print(0)
else:
    mod = 10 ** 9 + 7
    p = pow(2, k, mod)
    ans = (x * (p * 2) - (p - 1)) % mod
    print(ans)",2,1
"x, k = map(int,input().split())
if x == 0:
    print(0)
    exit()
b = pow(2,k,1000000007)  
a = (2*x - 1)%(1000000007)
print((a*b + 1) % 1000000007)",2,1
"from copy import deepcopy
import itertools
from bisect import bisect_left
from bisect import bisect_right
import math
from collections import deque


def read():
    return int(input())


def readmap():
    return map(int, input().split())


def readlist():
    return list(map(int, input().split()))


# C
N = read()
LIST = []
left = 0
right = 1
for i in range(N):
    l, r = readmap()
    LIST.append((l, left))
    LIST.append((r, right))

LIST.sort()

cnt = [0] * (N+1)  # DO NOT USE cnt[0]

n = 1
x = LIST[0][0]
dir = left
for item in LIST[1:]:
    if item[1] == left:
        if dir == left:
            cnt[n] += item[0] - x
            n += 1
            x = item[0]
            dir = left
        else:
            cnt[n] += item[0] - x - 1
            n += 1
            x = item[0]
            dir = left
    else:
        if dir == left:
            cnt[n] += item[0] - x + 1
            n -= 1
            x = item[0]
            dir = right
        else:
            cnt[n] += item[0] - x
            n -= 1
            x = item[0]
            dir = right

print("" "".join(list(map(str, cnt[1:]))))

",4,3
"#import resource
#import sys
#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])
#sys.setrecursionlimit(0x10000000)
from sys import stdin, stdout
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p,f):
    t=((f[n])*(modinv(f[r],p)%p)*(modinv(f[n-r],p)%p))%p
    return t
mod=(10**9)+7
def GCD(x, y):
   while(y):
       x, y = y, x % y
   return x
def BS(arr, l, r, x):
    if r >= l:
        mid = l + (r - l)/2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return BS(arr, l, mid-1, x)
        else:
            return BS(arr, mid+1, r, x)
    else:
        return -1
from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import math
from Queue import Queue as Q
""""""---------------------------------------------------------------------""""""
def main():
    n=input()
    p=[]
    f=[0]*(n+1)
    for i in range(n):
        l,r=map(int,stdin.readline().split())
        p.append([l,""l""])
        p.append([r,""r""])
    p.sort(key=lambda x:x[0])
    o=1
    c=0
    w=[]
    for i in range(1,len(p)):
        if(p[i][0]==p[i-1][0]):
            if(p[i][1]==""l""):
                o+=1
            else:
                c+=1
        else:
            w.append([p[i-1][0],o,c])
            o,c=0,0
            if(p[i][1]==""l""):
                o=1
            else:
                c=1
    w.append([p[-1][0],o,c])
    s=0
    i=0
    r=-1
    while(i<len(w)):
        f[s]+=w[i][0]-r-1
        f[s+w[i][1]]+=1
        s+=w[i][1]-w[i][2]
        r=w[i][0]
        i+=1
    for i in range(1,n+1):
        stdout.write(str(f[i])+"" "")
if __name__ == '__main__':
    main()
",4,6
"import os,sys,math 
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192
#complete the main function with number of test cases to complete greater than x
def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:            
        return len(a)

def solve():
    n=I()
    points,l=[],[]
    for i in range(n):
        a,b=In()
        l.append((a,b))
        points.append(a)
        points.append(b)
    points.sort()
    k=0 
    d={}
    l1=[]
    for i in range(2*n):
        if d.get(points[i],-1)==-1:
            d[points[i]]=k
            l1.append(points[i])
            k+=1
    # print(l1)
    n1=len(d)
    dp=[[0,0] for i in range(n1)]
    for a,b in l:
        dp[d[a]][0]+=1
        dp[d[b]][1]-=1

    ans={}
    last=dp[0][0]
    ans[last]=1
    last+=dp[0][1]
    for i in range(1,n1):
        cnts=l1[i]-l1[i-1]-1
        if ans.get(last,-1)!=-1:
            ans[last]+=cnts
        else:
            ans[last]=cnts
        last+=dp[i][0]
        if ans.get(last,-1)!=-1:
            ans[last]+=1
        else:
            ans[last]=1
        last+=dp[i][1]
    if ans.get(last,-1)!=-1:
        ans[last]+=1
    else:
        ans[last]=1
    for i in range(1,n+1):
        print(ans.get(i,0),end=' ')
    print()
    pass
def main():
    T=1
    for i in range(T):
        solve()
        
M = 998244353
P = 1000000007
 




class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == '__main__':
    main()",4,3
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter,defaultdict
from heapq import heappush, heappop
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))
def main():
    for _ in range(1):  # nmbr()):
        n = nmbr()
        d = defaultdict(int)
        for i in range(n):
            u, v = lst()
            d[u] += 1
            d[v + 1] -= 1
        ks = sorted(d.keys())
        ks_n = len(ks)
        for i in range(1, ks_n):
            d[ks[i]] += d[ks[i - 1]]
        l = Counter()
        for i in range(ks_n - 1):
            times = d[ks[i]]
            cnt = ks[i + 1] - ks[i]
            l[times] += cnt
        for i in range(1, n + 1):
            sys.stdout.write(str(l[i]) + ' ')

        # sys.stdout.write(str(ans)+'\n')
    # sys.stdout.flush()

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    for t in range(1):main()#int(input())):",4,3
"#!/usr/bin/python3

def solve(N, A):
    cnt = [0] * (N + 1)

    evd = {}
    xs = []
    for a, b in A:
        if a not in evd:
            evd[a] = [0, 0]
            xs.append(a)
        if b not in evd:
            evd[b] = [0, 0]
            xs.append(b)

        evd[a][0] += 1
        evd[b][1] += 1

    xs.sort()

    px = xs[0] - 1
    pop = 0
    for x in xs:
        cnt[pop] += x - px - 1
        cnt[pop + evd[x][0]] += 1
        pop -= evd[x][1]
        pop += evd[x][0]
        px = x

    return cnt[1:]


def main():
    N = int(input())
    A = [tuple([int(e) for e in input().split(' ')]) for _ in range(N)]
    print(*solve(N, A))


if __name__ == '__main__':
    main()
",4,3
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
from io import BytesIO, IOBase
import sys

def main():
    n=int(input())
    a=[]
    for i in range(n):
        x,y=map(int,input().split())
        a.append((x,0))
        a.append((y,1))
    a.sort()
    ans,s=[0]*n,[]
    for x,y in a:
        if y:
            ans[len(s)-1]+=x-s[-1][0]+1-s[-1][1]
            z=s.pop()
            if s!=[]:
                s[-1][1]+=(x-z[0]+1)
        else:
            s.append([x,0])
    print(*ans)

# FAST INPUT OUTPUT REGION

BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",4,3
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math 
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline


def solve():
    n = ii()
    d = defaultdict(lambda:0)
    d1 = defaultdict(lambda:0)
    for i in range(n):
        x,y = li()
        d[x-1]-=1
        d[y]+=1
    
    x = list(d.keys())
    x.sort()
    r = x[-1]
    # print(x)
    # print(d)
    c=d[r]
    temp=1
    for i in range(len(x)-2,-1,-1):
        l = x[i]+1
        d1[c]+=r-l+temp
        # print(c,r-l+1)
        c+=d[x[i]]
        r=l
        temp=0
        
    for i in range(1,n+1):
        print(d1[i],end="" "")
    print()

        


t = 1
# t = int(input())
for _ in range(t):
    solve()
    
",4,6
"from collections import defaultdict
n, s = int(input()), []
for i in range(n):
  a = [int(x) for x in input().split()]
  s += [(a[0], 0), (a[1], 1)]
s.sort()
now = 0
rev = defaultdict(int)
for a,b in zip(s, s[1:]):
  # print(a,b)
  if(a[1] == 0):
    now += 1
    # print(""now: %d"" % now)
    rev[now] += b[0] - a[0]
    if b[1] == 1: 
      # print(""add %d"" % (b[0] - a[0] + 1))
      rev[now] += 1
    # else:
    #   print(""add %d"" % (b[0] - a[0]))
  else:
    now -= 1
    # print(""now: %d"" % now)
    if b[0] != a[0]: 
      rev[now] += b[0] - a[0]
      if b[1] == 0: 
        # print(""add %d"" % (b[0] - a[0] - 1))
        rev[now] -= 1
      # else:
      #   print(""add %d"" % (b[0] - a[0]))
# print(rev)
for i in range(1, n+1):
  print(rev[i], end="" "")",4,5
"from collections import defaultdict
n = int(input())
arr = defaultdict(int)
for a0 in range(n):
	l,r = input().strip().split()
	l,r=int(l),int(r)
	arr[l]+=1
	arr[r+1]-=1

brr=[0]*(n+1)

l=sorted(arr.keys())
sum=arr[l[0]]
prevpoint=l[0]
for key in l[1:]:
	brr[sum]+=key-prevpoint
	prevpoint=key
	sum+=arr[key]
print(*brr[1:])",4,3
"from sys import stdin
input=stdin.readline
from collections import defaultdict
def f(q):
    q.sort()
    d=defaultdict(int)
    for l,r in q:
        d[l]+=1
        d[r+1]-=1
    res=0
    prev=None
    ans=[0]*(len(q)+1)
    for i in sorted(d.keys()):
        # print(res,ans,prev,i)
        if prev==None:
            # ans[1]+=1
            prev=i
        else:
            ans[res]+=i-prev
            prev=i
        res+=d[i]
        # res+=d[i]
    return ans[1:]

n=int(input())
q=[]
for i in range(n):
    x,y=map(int,input().strip().split())
    q.append((x,y))
print(*f(q))",4,3
"from sys import stdin
input=stdin.readline
from collections import defaultdict
def f(d,n):
    res=0
    prev=None
    ans=[0]*(n+1)
    for i in sorted(d.keys()):
        # print(res,ans,prev,i)
        if prev==None:
            prev=i
        else:
            ans[res]+=i-prev
            prev=i
        res+=d[i]
    return ans[1:]

n=int(input())
d=defaultdict(int)
for i in range(n):
    x,y=map(int,input().strip().split())
    d[x]+=1
    d[y+1]-=1
print(*f(d,n))",4,3
"from collections import defaultdict
n, s= int(input()), []
for i in range(n):
  a = [int(x) for x in input().split()]
  s += [(a[0], 0), (a[1], 1)]
s.sort()
now, rev = 0, defaultdict(int)
for a, b in zip(s, s[1:]):
  now += 1 if a[1] == 0 else -1
  if(a[1] == 0):
    rev[now] += b[0] - a[0] + (1 if b[1] == 1 else 0)
  elif b[0] != a[0]:
    rev[now] += b[0] - a[0] - (1 if b[1] == 0 else 0)
[print(rev[i], end="" "") for i in range(1, n+1)]
",4,5
"from collections import defaultdict

ans = defaultdict(int)
n = int(input())

beg, end = [0] * n, [0] * n

for i in range(n):
    a, b = map(int, input().split())
    beg[i] = a
    end[i] = b + 1
beg.sort()
end.sort()

pa, pb = 0, 0

cur = 0
lst = -1

while pb < n:
    pos = end[pb]
    if pa < n:
        pos = min(pos, beg[pa])

    ans[cur] += pos - lst

    ad = 0
    mn = 0
    while (pa < n and beg[pa] == pos):
        ad += 1
        pa += 1
    while (pb < n and end[pb] == pos):
        pb += 1
        mn -= 1

    lst = pos
    cur += ad + mn

for i in range(1, n + 1):
    print(ans[i], end = ' ')",4,1
"point = {}

n = int(input())

for i in range(n):
    l, r = map(int, input().split())
    r += 1
    if l not in point:
        point[l] = 0
    if r not in point:
        point[r] = 0
    point[l] += 1
    point[r] -= 1

line = []
for key in point:
    line.append((key,point[key]))
line.sort()
ans = [0] * (n+1)

last_index = 0
last_value = 0

for index, value in line:
    ans[last_value] += index - last_index
    last_index = index
    last_value += value

for cnt in ans[1:]:
    print(cnt,end=' ')",4,3
"n = int(input())
from collections import defaultdict, Counter
a = defaultdict(list)
count_left = Counter()
count_right = Counter()

for _ in range(n):
	l, r = map(int, input().split())
	count_left[l] += 1
	count_right[r] += 1

count = [0] * (n + 1)


pts = sorted(set(count_left.keys()) | set(count_right.keys()))
# pts.append(pts[-1])
c = 0
prev = pts[0]
for pt in pts:
	# print(prev, pt, c)
	if count_left[pt]:
		count[c] += pt - prev - 1		
		c += count_left[pt]
		count[c] += 1
		c -= count_right[pt]
	else:
		count[c] += pt - prev
		c -= count_right[pt]

	

	prev = pt
	# print(count)

print(' '.join(map(str, count[1:])))",4,3
"from sys import stdin, stdout

get_string = lambda: stdin.readline().strip('\n')
get_intmap = lambda: map( int, get_string().split(' ') )
#get_intmap

def testcase():
    n = int(input())
    cnt = dict()
    for i in range(n):
        l,r = get_intmap()
        cnt[l] = cnt.get(l,0) + 1
        cnt[r+1] = cnt.get(r+1,0) - 1
    ans = [0] * (n + 1)
    sk = sorted(cnt.keys())
    #print(cnt)
    cnt_i = 0
    for ind, i in enumerate(sk[:-1]):
        cnt_i += cnt[i]
        ans[cnt_i] += sk[ind + 1] - i
    print(' '.join([str(i) for i in ans[1:]]))
        

    

testcase();quit()
for t in range(int(input())):
    testcase()
",4,5
"n = int(input())
left = []
right = []
for i in range(n):
	data = input().split()
	left.append(int(data[0]))
	right.append(int(data[1]))
	
left.sort()
right.sort()
i = 0
j = 0
count = 1
ans = [0] * (n + 1)
left += [max(right) + 1]
right += [max(right) + 2]
while (i < n) and (j < n):
	while left[i + 1] <= right[j]:
		ans[count] += (left[i + 1] - left[i])
		count += 1
		i += 1
	ans[count] += (right[j] - left[i] + 1)
	i += 1	
	count -= 1
	
	while ((i == n) or (right[j + 1] < left[i])) and (j < n - 1):
		ans[count] += (right[j + 1] - right[j])
		count -= 1
		j += 1
	ans[count] += (left[i] - right[j] - 1)
	j += 1
	count += 1
#	print(i, j)

	
for i in range(1, n + 1):
	print(ans[i], end = "" "")
print()
	
",4,6
"import sys
input=sys.stdin.buffer.readline
from collections import defaultdict as dd
n=int(input())
d=dd(int)
for i in range(n):
    l,r=map(int,input().split())
    d[l] +=1
    d[r+1] -=1
arr=list(d.keys())
arr.sort()
ans=[0 for i in range(n+1)]
count =0
l=len(arr)
arr.append(arr[-1])
for i in range(l):
    count +=d[arr[i]]
    ans[count] +=arr[i+1] -arr[i]
print(*ans[1:])",4,5
"
from sys import stdin
input = stdin.readline

n=int(input())
arr=[int(x) for x in input().split()]

arr.sort(reverse=True)

d={}
for i in range(n):
    if arr[i] in d:
        d[arr[i]].append(i)
    else:
        d[arr[i]]=[i]

cnt=0
vis=[-1]*n
for i in range(n):
    s=bin(arr[i])
    s=s[2:]
    s=s[::-1]
    l=len(s)
    x=0
    for j in range(l):
        if s[j]==""0"":
            x=x+(2**j)
    x=x+1

    if x in d:
        if x==arr[i] and len(d[x])==1:
            if vis[i]==-1:
                cnt=cnt+1
        else:
            if vis[d[x][0]]==-1:
                for j in d[x]:
                    vis[j]=1   
    else:
        if vis[i]==-1:
            cnt=cnt+1
    vis[i]=1    

print(cnt)",4,6
"
def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]
#visited = [[False for i in range(m)] for j in range(n)]
#sys.stdin = open(r'input.txt' , 'r')
#sys.stdout = open(r'output.txt' , 'w')
#for tt in range(INT()):

#Code


n = INT()
arr = LIST()
k = []
i = 0
while 2 ** i <= 10**18 :
    k.append(2 ** i)
    i+=1

d = {}
s1 = set()
for i in arr:
    s1.add(i)
    if i not in d :
        d[i] = 1
    else:
        d[i]+=1

s2 = set()
for i in s1 :
    flag = False
    for j in k :
        x = j - i
        y = -1
        try:
            y = d[x]
        except:
            y = -1
        if y != -1:
            if x == i and d[i] == 1:
                continue
            flag = True
            break
    if flag==False:
        s2.add(i)

res = 0
for i in s2 :
    res+=d[i]
print(res)



",4,6
"from collections import defaultdict
n=int(input())
a=list(map(int, input().split()))

d=defaultdict(int)
cnt=0

for i in range(n):
    d[a[i]]+=1

for i in range(n):
    f=0
    for j in range(1,31):
        p=2**j-a[i]
        if p<=0:
            continue
        if p!=a[i]:
            if d[p]>=1:
                f=1
        else:
            if d[p]>=2:
                f=1
    if not f:
        cnt+=1
print(cnt)
",4,5
"import math
n = int(input())
s = list(map(int, input().split()))
d = dict()
for i in range(n):
    d[s[i]] = d.get(s[i], 0)+1

rem = 0
for i in range(n):

    ok = False
    for j in range(31):
        x = 2** j - s[i]
        c = d.get(x , 0)
        if c > 1 or (c == 1 and s[i] != x):
            ok = True
            break

    if ok == False:
        rem += 1
 
print(rem)",4,5
"import bisect
from collections import defaultdict,Counter
import math

    
def solve(a):
    count=0
    mp=Counter(a)
    for i in range(len(a)):
        flag=0
        for j in range(31):
            x=int(1<<j)-a[i]
            if (x in mp) and (x==a[i] and mp[x]>1):
                # print(x)
                flag=1
                break
            elif (x in mp) and (x!=a[i] and mp[x]>0):
                flag=1
                break
        if flag==0:
            count+=1        

    return count


n=int(input(''))
a=list(map(int,input('').split()))
print(solve(a))
",4,3
"#------------------------template--------------------------#
import os
import sys
from math import *
from collections import *
# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()




n = Int()
a = array()
C = Counter(a)
a = set(a)

ans = 0

for x in a:
    ok = True

    for i in range(65):
        
        need = 2**i - x
        if(need == x and C[need] > 1): ok = False 
        if(need != x and C[need] > 0): ok = False
    
    # print(ok,x)
    ans += C[x]*ok

print(ans)

























",4,3
"
def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]
#visited = [[False for i in range(m)] for j in range(n)]
#sys.stdin = open(r'input.txt' , 'r')
#sys.stdout = open(r'output.txt' , 'w')
#for tt in range(INT()):

#Code

n = INT()
arr = LIST()

i = 0
p = []
while 2**i <= 10**18:
    p.append(2**i)
    i = i+1

d = {}
s1= set()
for i in arr:
    s1.add(i)
    if i not in d :
        d[i] = 1
    else:
        d[i]+=1

s2 = set()
for i in s1 :
    flag = False
    for j in p :
        x = j - i
        k = -1
        try:
            k = d[x]
        except :
            k = -1
        if k != -1:
            if x == i and d[i] == 1 :
                continue
            else:
                flag = True
                break
    if flag == False:
        s2.add(i)

res = 0
for i in s2 :
    res+=d[i]
print(res)



",4,6
"for _ in range(1):
    i=0
    ans=[]
    while(i<32):
        ans.append(2**i)
        i+=1
        
    
    n=int(input())
    l=list(map(int,input().split()))
    d={}
    for i in l:
        if i not in d:
            d[i]=1
        else:
            d[i]+=1
          
    # for j in range(n):
    #     if l[j] in ans1 and d[l[j]]>1:
    #         continue
    #     else:
    #         nl.append(l[j])
    
    
    
    c=0
    for i in d.keys():
        
        for j in ans:
            
            if j-i in d and (j-i!=i or d[j-i]>1):
                
                break
        else:
            c+=d[i]
    print(c)            
                
                
    
    ",4,3
"from math import *
from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 2**j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)",4,3
"import sys

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

ak=[]
i=0
while 2**i <=2000000000:
    ak.append(2**i)
    i+=1

n=int(input())
a=list(map(int,input().split()))
d=dict()
for i,v in enumerate(a):
    d[v]=d.get(v,set())
    d[v].add(i)
ans=[0]*n
for i in range(n):
    for j in ak:
        if j-a[i] in d:
            if (j-a[i]==a[i] and len(d[a[i]])>=2) or j-a[i]!=a[i] :
                ans[i]=1
                break
print(ans.count(0))",4,5
"import sys, heapq

def binary(num):
    left = 0
    right = n
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < num:
            left = mid + 1
        elif arr[mid] > num:
            right = mid
        else:
            return True
    return False

n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().split()))
arr.sort()
cnt = dict().fromkeys(set(arr), 0)
ans = 0
for i in arr:
    cnt[i] += 1
for i in range(n):
    now = arr[i]
    can = False
    for j in range(31):
        target = pow(2, j) - now
        if binary(target):
            if target == now:
                if cnt[now] >= 2:
                    can = True
                    break
            else:
                can = True
                break
    if not can:
        ans += 1
print(ans)",4,5
"from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 1<<j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)",4,3
"from collections import *
n = int(input())
a = list(map(int,input().split()))
d = Counter(a)
ans = 0
for i in range(n):
    for j in range(31):
        s = 1<<j
        s = s-a[i]
        if d.get(s)!=None and ((d[s]==1 and s!=a[i]) or d[s]>=2):
            break
    else:
        ans+=1
print(ans)
",4,3
"n=int(input())
ar=list(map(int,input().split()))
d={};ans=0
for i in ar:d[i]=d.get(i,0)+1
for i in ar:
  flag=False
  for j in range(31):
    k=2**j;
    if k>=i:
     k1=k-i
     if i!=k1 and d.get(k1,0)>0:flag=True;break
     if i==k1 and d.get(i,0)>1:flag=True;break
  if not flag:ans+=1
    
print(ans)
",4,1
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    arr=get_list()
    counter=collections.Counter(arr)
    ans=set()
    for i in counter:
        for j in range(1,32):
            no=2**j
            diff=no-i
            if diff<0:
                continue
            if diff==i:
                if counter[i]>1:
                    ans.add(i)
                    #print(i,no,diff,""###"")
                    break
            else:
                if diff not in  counter:
                    continue
                else:
                    ans.add(i)
                    #print(i,no,diff)
                    break
    #print(ans)
    val=0
    ans=list(ans)
    for i in ans:
        val+=counter[i]
    print(n-val)",4,1
"n = int(input())
l = list(map(int,input().split()))
i = 0
p = []
while 2**i <= 10**18:
    p.append(2**i)
    i = i+1

d = {}
s = set()
for i in l:
    s.add(i)
    if i in d:
        d[i] += 1

    else:
        d[i] = 1

z = set()
for i in s:
    f = 1
    for j in p:
        e = j-i
        if e in s:
            if e == i and d[e] == 1:
                continue

            f = 0
            break

    if f:
        z.add(i)

ans = 0
for i in z:
    ans += d[i]

print(ans)",4,3
"from sys import stdin,stdout
from math import ceil,log
def main():
	d={}
	n=int(stdin.readline())
	a=list(map(int,stdin.readline().split( )))
	m=-1;mm=10**10
	for v in a:
		if v not in d:
			d[v]=1
		else:
			d[v]+=1
		m=max(m,v)
		mm=min(mm,v)
	ans=0
	
	for v in a:
		
		exponent=ceil(log(v,2))
		power=2**exponent
		find=0
		while power-v>=0:
			if power-v>mm and power-v>m:
				break
			
			element=power-v
			if element in d and element==v and d[element]>1:
				find=1
				break
			elif element in d and element!=v:
				find=1
				break
			power=power*2
		if find==0:
			ans+=1
	stdout.write(""%d\n""%(ans))

main()",4,3
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
########################################################################

n=ri()
a=ris()
freq=Counter(a)
ans=0
for x in freq:
  for i in range(32):
    c=(1<<i)-x
    if c not in freq:
      continue
    if c==x and freq[x]==1:
      continue
    break
  else:
    ans+=freq[x]

print(ans)
",4,1
"a=input()
n=len(a)
b=[]
c=0
d=0
for i in range(1,n):
    if a[i]==a[i-1]:
        b.append(['bw'.find(a[c]),i-c])
        d=max(d,i-c)
        c=i
b.append(['bw'.find(a[c]),n-c])
d=max(d,n-c)
if d<n and b[0][0]==(b[-1][0]+b[-1][1])%2:
    d=max(d,b[-1][1]+b[0][1])
print(d)",3,3
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():
    # mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    
    tc=1
    for _ in range(tc):
        
        s=2*rs()+""333""
        le=(len(s)-3)//2
        a=[]
        for i in s:
            if i=='b':
                a.append(0)
            if i=='w':
                a.append(1)
            if i=='3':
                a.append(3)
        pehla=[0,1]*len(s)
        
        doosra=[1,0]*len(s)
        # print(*a)
        # print(*pehla)
        # print(*doosra)
        k=[0]*len(s)
        for i in range(len(s)):
            if a[i]==pehla[i]:
                k[i]=1
        ans=0
        t=0
        for i in k:
            if i==1:
                t+=1
                # print(t)
            else:
                ans=max(t,ans)
                t=0
        # print(*k)
        k=[0]*len(s)
        for i in range(len(s)):
            if a[i]==doosra[i]:
                k[i]=1
        
        t=0
        for i in k:
            if i==1:
                t+=1
                # print(t)
            else:
                ans=max(t,ans)
                t=0
        # print(*k)
        
        print(min(le,ans))
        
                    
                
        
        
            
                
        

            
        

               
            
        
              
                
        
        
            
        
        
            
            
        
        
                
                
                
                
            
        
        
            
           
        
            
                    

                                 
                
                
        

                
        
        
        
            
        
        
                
            
        
        
                    
        
        
        
            
                    
            

                
            
            
                
            
                
            
            
            
            
                
            
        
        
        
        
        
        
        
                    
        
        
        
                
                
        
            
            
            
        

                    
        
                
        
        
                        
        
                            

        

                
            
        

                
            
                    
                
                
        
        
         
        

                        
                            
                
        
                            
                    

                
            
        
                
            
                
        
        
        
                             
        
            
        
        
            
                        
                        
                    
            
        
        
        
        
        
                        
       

        
                           
        
        
        
            
        
        
        
                      

      
                            
            
        
        
            
            
            
            
            
        
        
        
            
        
        
        
            
        
        
        
        
            
            
        
        
        
        
        
        
        
                
                
                    
        
        
            
            
        
                
            
            
        
        
        
        
                
        
            
        
                
        
        
            
        
       
            

                
        
        
        
   
            
        
        
        
        
            
        
                
        
        
        
            
            
        
        
            
        
        

        
        
            
        
        
            
        
                        

        
        
            
     
        
        
            
        
        
                
            
        
        
        
                
            
        

            
             
        
            
        
        
        
                
        
            
        
        
        
        
                
        
        
            
        
        
        
        
                
        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",3,6
"import sys
input=sys.stdin.readline
s=list(input().rstrip())
n=len(s)
s.extend(s)
cnt=0
c=1
for i in range(len(s)-1):
  if s[i]!=s[i+1]:
    c+=1
  else:
    cnt=max(c,cnt)
    c=1
cnt=max(cnt,c)
print(min(cnt,n))",3,3
"s = input()
s = s*3
n = len(s)
m,curr=1,1
for i in range(n-1):
    if s[i]!=s[i+1]:
        curr+=1
        m=max(curr,m)
    else:
        curr=1
print(min(m,n//3))
",3,3
"s=list(input())
ans=0
far=0
for i in range(len(s)-1):
    if(s[i]!=s[i+1]):
        far+=1
        continue
    if(s[0]!=s[-1]):
        s[:i+1]=s[:i+1][::-1]
        s[i+1:]=s[i+1:][::-1]
        far+=1
    else:
        ans=max(ans,far+1)
        far=0
    #print(s)
print(max(far+1,ans))
# b w w w b w w b w
",3,3
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################

import sys,os,io
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from sys import stdin

import math 



def ncr(n, r, p):  #using fermat's little theorem
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

  
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
          
    for i in range(3,int(math.sqrt(n))+1,2): 
          

        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
    
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 


def si():
    return input()

# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")


# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

# t = int(input())
t = 1
for _ in range(t):
    s = si()
    s = s*3
    m = 0
    c = 1
    for i in range(1,len(s)):
        if (s[i]!=s[i-1]):
            c+=1
        else:
            m = max(m,c)
            c = 1
    m = max(m,c)
    
    m = min(m,len(s)//3)
    print(m)",3,6
"def check(st):
    count = 1
    i = 1
    pre = st[0]
    maxi = 0
    pre_indx = 0
    indx = [0 for i in range(n)]
    while i<n:
        if pre != st[i]:
            count+=1
        else:
            indx[pre_indx] =count
            count=1
            pre_indx=i
        pre =st[i]
        i+=1
    indx[pre_indx] =count
    return indx

st=input()
n=len(st)
actual_indx=check(st)
reverse_indx=check(st[::-1])
if st[0] ==st[-1]:
    print(max(actual_indx))
else:
    print(min(n,max(max(actual_indx[1:]),actual_indx[0] +reverse_indx[0])))",3,5
"s=input().strip()
s=s+s

n=len(s)
an=1
m=1
#print(s)
for i in range(1,n):
    if s[i]!=s[i-1]:
        m+=1
        an = max(an, m)
    else:
        an = max(an, m)
        m=1
    #print(an)
print(min(an,n//2))",3,3
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

#?############################################################


def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

#?############################################################


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p


#?############################################################

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))


#?############################################################

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

#?############################################################


def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime


#?############################################################

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

#?############################################################


def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

#?############################################################


def mapin():
    return map(int, input().split())

#?############################################################


# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
# python3 15.py<in>

s = list(input())
n = len(s)
l = [1]
for i in range(n-1):
    if(s[i]!= s[i+1]):
        l[-1]+=1
    else:
        l.append(1)

ans = max(l)
if(len(l)>1):
    if(s[0]!= s[-1]):
        ans = max(ans, l[0]+l[-1])
# print(l)
print(ans)

    



",3,6
"from collections import defaultdict
from collections import deque
import sys
input = sys.stdin.readline

def bfs(s):
    q = deque()
    q.append(s)
    dist = [-1] * (n + 1)
    dist[s] = 0
    p = []
    parent = [1] * (n + 1)
    ok = [0] * (n + 1)
    while q:
        i = q.popleft()
        d = dist[i]
        if d < 3:
            ok[i] = 1
        p.append(i)
        for j in G[i]:
            if dist[j] == -1:
                q.append(j)
                dist[j] = d + 1
                parent[j] = i
    ans = 0
    while p:
        i = p.pop()
        j = parent[i]
        if not ok[i]:
            ok[j] = 1
            ans += 1
            for k in G[j]:
                ok[k] = 1
    return ans

n = int(input())
G = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)
ans = bfs(1)
print(ans)",3,6
"from sys import stdin
n = int(stdin.readline())
g = dict()
for i in range(n-1):
    u,v = map(int,stdin.readline().split())
    g.setdefault(u-1,[]).append(v-1)
    g.setdefault(v-1, []).append(u-1)
st = [0]
rank = [0]*n
tree = [0]*n
msk = [0]*n
rd = dict()
while len(st)>0:
    top = st.pop()
    msk[top] = 1
    for c in g[top]:
        if msk[c] == 0:
            st.append(c)
            tree[c] = top
            rank[c] = rank[top]+1
            rd.setdefault(rank[c], []).append(c)
max_rank = max(rank)
reach = [0]*n
build = [0]*n
ans = 0
for r in range(max_rank, 2, -1):
    for node in rd[r]:
        if reach[node] == 0:
            reach[node] = 1
            reach[tree[node]] = 1
            reach[tree[tree[node]]] = 1
            build[tree[node]] = 1
print(sum(build))",3,6
"
import sys

def get_new_edges(graph):
    n = len(graph)
    far_vertex = []
    pi = [None]*n
    visit = [False]*n
    visit[0]
    queue = [[0,0]]
    i = 0    
    while True:
        if i >= len(queue): break
        current, d = queue[i]
        i += 1
        visit[current] = True
        for v in graph[current]:
            if not visit[v]:
                u = [v, d+1]
                pi[v] = current
                queue.append(u)
                if d+1 > 2:
                    far_vertex.append(u)
    
    far_vertex.sort(key=lambda x: -x[1])

    pos = [None]*n
    for i, e in enumerate(far_vertex):
        pos[e[0]] = i

    count = 0
    for i in range(len(far_vertex)):
        if not far_vertex[i]: continue
        vertex, depth = far_vertex[i]
        father = pi[vertex]
        count += 1
        if pos[father]:
            far_vertex[pos[father]] = None
        for u in graph[father]:
            if pos[u]:
                far_vertex[pos[u]] = None

    return count
    
def read_int_line():
    return map(int, sys.stdin.readline().split())

vertex_count = int(input())
graph = [[] for _ in range(vertex_count)]

for i in range(vertex_count - 1):
    v1, v2 = read_int_line()
    v1 -= 1
    v2 -= 1
    graph[v1].append(v2)
    graph[v2].append(v1)

print(get_new_edges(graph))


    
",3,5
"import sys
from collections import deque
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))

n = inp()
edges = [[] for _ in range(n)]
for _ in range(n-1):
    a,b = inpl()
    a,b = a-1,b-1
    edges[a].append(b)
    edges[b].append(a)
dist = [-1] * n
dist[0] = 0
pa = [-1] * n
se = set()
pq = []
q = deque()
q.append(0)
while q:
    now = q.popleft()
    for nx in edges[now]:
        if dist[nx] != -1:
            continue
        pa[nx] = now
        dist[nx] = dist[now] + 1
        if dist[nx] > 2:
            se.add(nx)
            pq.append((dist[nx], nx))
        q.append(nx)
pq = pq[::-1]
res = 0
ind = 0
while se:
    d,v = pq[ind]
    ind += 1
    if not v in se: 
        continue
    res += 1
    pv = pa[v]
    se.discard(pv)
    for nv in edges[pv]:
        se.discard(nv)
print(res)",3,1
"import sys
from collections import deque
import heapq
input = sys.stdin.readline

N=int(input())
EDGE=[list(map(int,input().split())) for i in range(N-1)]

EDGELIST=[[] for i in range(N+1)]

for i,j in EDGE:
    EDGELIST[i].append(j)
    EDGELIST[j].append(i)

#EDGES=[[] for i in range(N+1)]
REDG=[None for i in range(N+1)]
QUE=deque([1])
check=[0]*(N+1)
DEPTH=[None]*(N+1)
i=0
while QUE:
    NQUE=deque()
    i+=1
    
    while QUE:
        x=QUE.pop()
        DEPTH[x]=i
        check[x]=1
        for to in EDGELIST[x]:
            if check[to]==1:
                continue
            else:
                #EDGES[x].append(to)
                REDG[to]=x
                NQUE.append(to)
    QUE=NQUE


check=[0]*(N+1)
check[1]=1
#NEXT=[]

#for i in EDGES[1]:
#    check[i]=1
#    NEXT.append(i)

#for j in NEXT:
#    for k in EDGES[j]:
#        check[k]=1


LEAF=[]
for i in range(2,N+1):
    if len(EDGELIST[i])==1:
        LEAF.append((-DEPTH[i],i))

QUE=LEAF
heapq.heapify(QUE)
ANS=0

#print(check,QUE)

while QUE:
    dep,x=heapq.heappop(QUE)
    if check[x]!=0 or dep>=-3:
        continue

    if check[REDG[x]]==2:
        continue

    if check[x]==0:
        check[x]=1
    if check[REDG[REDG[x]]]==0:
        check[REDG[REDG[x]]]=1
    check[REDG[x]]=2   
    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))
    ANS+=1

    #print(x,QUE,check)

print(ANS)



",3,6
"import sys
import os

def solve(slimes):
    if len(slimes) == 1:
        return slimes[0]

    havePos = False
    haveNeg = False

    for s in slimes:
        if s > 0:
            havePos = True
        elif s < 0:
            haveNeg = True

    if havePos and haveNeg:
        return sum(map(abs, slimes))
    elif not havePos:
        m = max(slimes)
        return sum(list(map(abs, slimes))) + 2 * m
    elif not haveNeg:
        m = min(slimes)
        return sum(list(map(abs, slimes))) - 2 * m
    else:
        return 0

def main():
    n = int(input())
    slimes = list(map(int, input().split()))
    print(solve(slimes))


if __name__ == '__main__':
    main()",3,1
"#Problem D: Slime

n = int(input())

a = input().split()

for i in range(n):
    a[i] = int(a[i])

if(n==1):
    print(a[0]) #Obvious Case
else:
    sm = 0
    havePositive = False
    haveNegative = False

    for c in a:
        if(c==0):
            haveNegative = True
            havePositive = True
        elif(c>0):
            havePositive = True
            sm += c
        else:
            haveNegative = True
            sm -= c

    if(haveNegative and havePositive):
        print(sm) #Final Answer
    else:
        for i in range(n):
            a[i] = abs(a[i])
        #Get the minimum
        ans = sum(a)
        low = a[0]
        for c in a:
            low = min(low,c)
        #Final Answer
        print(ans-2*low)
",3,5
"n = int(input())
arr = list(map(int, input().strip().split()))
k = min(arr)
h = max(arr)
s = 0
for i in arr:
    if i >= 0:
        s += i
    else:
        s -= i

if n == 1:
    print(arr[0])
elif ((k < 0 and h >= 0)):
    print(s)
else:
    if (k >= 0):
        print(s - 2 * k)
    else:
        print(s + 2 * h)",3,1
"#from random import random, randint
#from sys import stdout

#n, k = map(int, input().split())
n = int(input())

if n==1:
    a = input()
    print(a)
else:    
    a = list(map(int, input().split()))
    b = [abs(i) for i in a]
    if min(a)*max(a) > 0:
        print(sum(b)-2*min(b))
    else:
        print(sum(b))
",3,1
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
a = li()
b = [abs(x) for x in a] 
if n == 1:
    ans = a[0]
elif all(x > 0 for x in a) or all(x < 0 for x in a):
    b.sort()
    ans = sum(b) - 2 * b[0]
else:
    ans = sum(b)
print(ans)
",4,1
"n=int(input())
A=list(map(int,input().split()))

if n==1:
    print(A[0])

elif n==2:
    print(abs(A[0]-A[1]))

else:
    SUM=0
    for i in range(n):
        SUM+=abs(A[i])
    ANS=0

    for i in range(n-1):
        if ANS<SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1]):
            ANS=SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1])

    print(ANS)
",3,5
"n = int(input())
xs = [int(x) for x in input().split()]
prefix = [-1 for i in range(n)]
suffix = [-1 for i in range(n)]
prefix[0] = 0
pre_has_neg = [False for i in range(n)]
suffix[-1] = 0
suf_has_neg = [False for i in range(n)]
for i in range(n):
	if i == 0:
		prefix[i] = xs[i]
	else:
		prefix[i] = prefix[i-1] + xs[i]
for i in reversed(range(n)):
	if i == n-1:
		suffix[i] = xs[i]
	else:
		suffix[i] = suffix[i+1] + xs[i]
for i in range(n):
	if i == 0:
		pre_has_neg[i] = xs[i] <= 0
	else:
		pre_has_neg[i] = pre_has_neg[i-1] or xs[i] <= 0
for i in reversed(range(n)):
	if i == n-1:
		suf_has_neg[i] = xs[i] <= 0
	else:
		suf_has_neg[i] = suf_has_neg[i+1] or xs[i] <= 0

prebignum = [None for i in range(n)]
sufbignum = [None for i in range(n)]
for i in range(n):
	if i == 0:
		prebignum[i] = xs[i]
	else:
		prebignum[i] = min(prebignum[i-1], xs[i])
for i in reversed(range(n)):
	if i == n-1:
		sufbignum[i] = xs[i]
	else:
		sufbignum[i] = min(sufbignum[i+1], xs[i])

neg_pre = [100000 for i in range(n)]
neg_suf = [100000 for i in range(n)]

for i in range(n):
	if i == 0:
		neg_pre[i] = min(xs[i], -xs[i])
	else:
		neg_pre[i] = neg_pre[i-1] + min(xs[i], -xs[i])

for i in reversed(range(n)):
	if i == n-1:
		neg_suf[i] = min(xs[i], -xs[i])
	else:
		neg_suf[i] = neg_suf[i+1] + min(xs[i], -xs[i])

ans = -100000000000000000
for i in range(n):
	#print(i, ""----"")
	tans = xs[i]
	if i == 0:
		pass
	elif pre_has_neg[i-1]:
		tans -= neg_pre[i-1]
	else:
		tans += prefix[i-1]
		tans -= prebignum[i-1]*2

	if i == n-1:
		pass
	elif suf_has_neg[i+1]:
		tans -= neg_suf[i+1]
	else:
		tans += suffix[i+1]
		tans -= sufbignum[i+1]*2
		#print(suffix[i+1], sufbignum[i+1])
	ans = max(ans, tans)

print(ans)",3,-100
"n = int(input())
a = list(map(int, input().split()))
if n == 1:
	print(a[0])
else:
	prod_minus = False
	for i in range(n - 1):
		if a[i] * a[i + 1] <= 0:
			prod_minus = True
			break
	Min_abs = float(""inf"")
	Sum = 0
	for num in a:
		Sum += abs(num)
		if abs(num) < Min_abs:
			Min_abs = abs(num)

	if prod_minus:
		print(Sum)
	else:
		print(Sum - 2 * Min_abs)",3,3
"import sys
import string


def ria():
    return [int(i) for i in input().split()]


n = ria()[0]
ar = ria()

if n == 1:
    print(ar[0])
    exit(0)

onlyNegs = True
onlyPos = True

if max(ar) >= 0:
    onlyNegs = False
if min(ar) <= 0:
    onlyPos = False

if onlyNegs:
    print(abs(sum(ar)) + max(ar) * 2)
    exit(0)

if onlyPos:
    print(abs(sum(ar)) - min(ar) * 2)
    exit(0)

print(sum([abs(i) for i in ar]))
",3,1
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()

za = getIntList()
if N==1:
    print(za[0])
    sys.exit()
t1 = max(za)
t2 = min(za)
if t2>=0:
    print(sum(za) - 2*t2)
    sys.exit()
if t1<=0:
    print(2*t1 - sum(za))
    sys.exit()

res = 0
for x in za:
    res+= abs(x)

print(res)







",3,1
"if input()=='1':
 print(input())
else:
 x,*a,y=sorted(map(int,input().split()))
 print(y-x+sum(map(abs,a)))",4,1
"def add(num):
    if(num<=1):
        return 0
    return (num*(num-1))//2
    
    
n,k=map(int,input().split())

a=list(map(int,input().split()))
pre=[a[0]]
base=(2**(k))-1
hb=2**(k-1)
for i in range(1,n):
    pre.append(a[i]^pre[-1])
    
cnt=dict()
cnt[0]=[0,0]

for i in range(n):
    if(pre[i]>=hb):
        if(base-pre[i] not in cnt):
            cnt[base-pre[i]]=[0,0]
        cnt[base-pre[i]][1]+=1
    else:
        if(pre[i] not in cnt):
            cnt[pre[i]]=[0,0]
        cnt[pre[i]][0]+=1
cnt1=0
#print(pre)
#print(cnt)
for i in cnt.values():
    sum1=i[0]+i[1]
    cnt1+=add(sum1//2)
    cnt1+=add((sum1+1)//2)
cnt1+=sum(cnt[0])//2
#print(cnt1)
print((n*(n+1))//2 - cnt1)
    
    

    
",3,5
"from collections import defaultdict
n,k = map(int,input().split())
arr = list(map(int,input().split()))
xors = defaultdict(int)
xors[0]=1
comp = (1<<k)-1
ans = n*(n+1)//2
xor = 0
for a in arr:
	xor^=a
	if xors[xor]>xors[comp^xor]:
		xor^=comp
	ans-=xors[xor]
	xors[xor]+=1
print(ans)",3,1
"from collections import defaultdict
n,k=map(int,input().split())
arr=list(map(int,input().split()))
xors=defaultdict(int)
xors[0]=1
comp=(1<<k)-1
xor=0
ans=n*(n+1)//2
for a in arr:
    xor^=a
    if(xors[xor]>xors[comp^xor]):
        xor^=comp
    ans-=xors[xor]
    xors[xor]+=1
print(ans)",3,1
"from math import *
#n,k=map(int,input().split())
#A = list(map(int,input().split()))
n,k = map(int,input().split())
ans = [0] * n
#^xor
lul = 2**k - 1
A = list(map(int,input().split()))
ans[0]  = A[0]
for j in range(1, n):
    ans[j] = ans[j-1]^A[j]
#print(ans)
d = dict()
for j in range(n):
    if ans[j] in d:
        d[ans[j]]+=1;
    else:
        d[ans[j]] = 1
#print(d)
ans =0
def huy(n):
    return n*(n-1)//2
for j in d:
    now = d[j]
    #print(d[j],j)
    xor = lul^j
    cur = now

    if xor in d :

        now2 = d[xor]
        #print(now,xor)
        cur += now2



        ans += huy(cur//2+cur%2)
        ans+=huy(cur//2)
        if j ==0:
            ans+=2*(cur//2)
    else:
        if(j==0 or xor ==0):
            ans+= 2*(cur//2)
        ans += 2*huy(cur // 2 + cur % 2)
        ans += 2*huy(cur // 2)
print(huy(n+1) - ans//2)",3,1
"from collections import defaultdict
n, k = map(int, input().split())
a = [0] + list(map(int, input().split()))
h = defaultdict(int)
for i in range(n):
	a[i + 1] ^= a[i]
for i in range(n + 1):
	h[min(a[i] ^ ((1 << k) - 1), a[i])] += 1
ans = 0
for x, t in h.items():
	a = t // 2
	b = t - a
	ans += a * (a - 1) // 2 + b * (b - 1) // 2
ans = (n * (n + 1)) // 2 - ans
print(ans)
",3,5
"n, k = [int(i) for i in input().split()]
d = dict()
d[0] = 1
x = 0
for i in [int(i) for i in input().split()]:
    x ^= i
    v = min(x, (1 << k) - x - 1)
    if v not in d.keys():
        d[v] = 0
    d[v] += 1
ans = 0
for k, v in d.items():
    c1 = v // 2
    c2 = v - c1
    ans += c1 * (c1 - 1) // 2 + c2 * (c2 - 1) // 2
print(n * (n - 1) // 2 + n - ans)
",3,1
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(200001)] 
pp=[0]*200001
def SieveOfEratosthenes(n=200000): 
      
    # Create a boolean array ""prime[0..n]"" and initialize 
    #  all entries it as true. A value in prime[i] will 
    # finally be false if i is Not a prime, else true. 
    
    p = 2
    while (p * p <= n): 
          
        # If prime[p] is not changed, then it is a prime 
        if (prime[p] == True): 
              
            # Update all multiples of p 
            for i in range(p * p, n+1, p): 
                prime[i] = False
        p += 1
#---------------------------------running code------------------------------------------
n,k = map(int,input().split())
arr = list(map(int,input().split()))
xors = defaultdict(int)
xors[0]=1
comp = (1<<k)-1
ans = n*(n+1)//2
xor = 0
for a in arr:
	xor^=a
	if xors[xor]>xors[comp^xor]:
		xor^=comp
	ans-=xors[xor]
	xors[xor]+=1
print(ans)",3,6
"n, k = map(int, raw_input().split())
a = map(int, raw_input().split())
for i in range(n):
    ai = a[i]
    nai = ((1<<k) - 1)^ai
    if nai < ai:
        a[i] = nai

from collections import Counter
C = Counter()
C[0] += 1
S = 0
cnt = 0
for j, ai in enumerate(a):
    nai = ((1<<k) - 1)^ai
    v1, v2 = C[S^ai], C[S^nai]
    if v1 <= v2:
        cnt += j + 1 - v1
        S ^= ai
        C[S] += 1
    else:
        cnt += j + 1 - v2
        S ^= nai
        C[S] += 1
print(cnt)
    
",3,3
"n,k=list(map(int,input().split()))
arr=list(map(int,input().split()))
newarr=[0]

for num in arr:
  newarr+=[newarr[-1]^num]
dic={}
for num in newarr:
  x=(min(num,2**k-1-num),max(num,2**k-1-num))
  if x in dic:
    dic[x]+=1
  else:
    dic[x]=1
ans=0
for elem in dic:
  m=dic[elem]
  half=m//2
  ans+=half*(half-1)/2
  half=m-half
  ans+=half*(half-1)/2
ans=n*(n+1)/2-ans
print(int(ans))
  
    
",3,1
"i = int(input())
s = input().split()

l = []
for j in s:
    if not l or  int(j)%2 != l[-1]:
        l.append(int(j)%2)
    else:
        l.pop()

if len(l) < 2:
    print('YES')
else:
    print('NO')


",3,1
"n=int(input())
a=list(map(int,input().split()))
st=[a[0]]
for i in range(1,n):
    if len(st)>0 and st[-1]%2==a[i]%2:
        st.pop()
    else:
        st.append(a[i])
if len(st)<=1:
    print(""YES"")
else:
    print(""NO"")
    ",3,3
"#!/usr/bin/env python
# coding: utf-8

# In[4]:


import math
n=int(input())
columns=list(map(int, input().rstrip().split()))


# In[5]:


modcolumns=[i%2 for i in columns]


# In[6]:


test=0


# In[7]:


previouslist=[]


for i in range(0,n):
    if len(previouslist)==0:
        previouslist.append(modcolumns[i])
        
    elif modcolumns[i]==previouslist[-1]:
        previouslist.pop()
        
    else:
        previouslist.append(modcolumns[i])
    
    
    
    
        
if len(previouslist)<=1:
    print(""YES"")
else:
    print(""NO"")


# In[ ]:


",3,3
"n = int(input())
a = list(map(int, input().split()))
b = []
for i in range(n):
    a[i] %= 2
    if len(b) != 0:
        if b[-1] == a[i]:
            b.pop()
        else:
            b.append(a[i])
    else:
        b.append(a[i])
if len(b) > 1:
    print(""NO"")
else:
    print(""YES"")
",3,3
"n=int(input())
a=list(map(int,input().split()))
b=0
for i in range(n):
    if a[i]%2==1:
        if i%2==0:
            b+=1
        else:
            b-=1
if n%2==0:
    if b==0:
        print(""YES"")
    else:
        print(""NO"")
else:
    if b==0 or b==1:
        print(""YES"")
    else:
        print(""NO"")",3,3
"n = int(input())
a = [int(_) & 1 for _ in input().split()]
v = [a[0]]
for i in range(1, n):
    if v and v[-1] == a[i]:
        v.pop()
    else:
        v.append(a[i])
print(""NO"" if len(v) > 1 else ""YES"")
",3,3
"n = int(input())
a = list(map(int, input().split()))
q = (10 ** 6) * [-1]
pnt = -1
ans = ""YES""
for i in range(n):
    if pnt == -1:
        pnt += 1
        q[pnt] = a[i]
    else :
        if q[pnt] == a[i] or abs(q[pnt] - a[i]) % 2 == 0:
            q[pnt] = -1
            pnt -= 1
        else:
            pnt += 1
            q[pnt] = a[i]
if pnt > 0 :
    ans = ""NO""
print(ans)
        
",3,3
"i = int(input())
s = input().split()

l = []
for j in s:
    if not l or  int(j)%2 != l[-1]:
        l.append(int(j)%2)
    else:
        l.pop()

if len(l) < 2:
    print('YES')
else:
    print('NO')
",3,1
"def f():
    b = [a[0]]
    for e in a[1:]:
        if b != []:
            if e == b[-1] or abs(e-b[-1])%2==0:
                b.pop()

            else:
                b.append(e)
        else:
            b.append(e)

    for i in range(1,len(b)):
        if abs(b[i]-b[i-1])%2:
            print('NO')
            return

    print('YES')

n=int(input())
a=[int(i) for i in input().split()]


f()",3,3
"c = [[0 for i in range(5205)] for j in range(5205)]
K = 998244353
inv = [0 for i in range(5205)]

def mu(a, n):
	if n == 0: return 1
	q = mu(a, n // 2)
	if n % 2 == 0:
		return q * q % K
	else: return q * q % K * a % K

def calc(m, d, S):
	res = 0
	if m == 0:
		if S == 0: return 1
		return 0

	for u in range(0, m + 1):
		if (u * d > S): break
		U = c[m][u] * c[S - u * d + m - 1][m - 1] % K 
		if u % 2 == 0:
			res = (res + U) % K
		else: res = (res - U + K) % K 
	return res


c[0][0] = 1
inv[0] = 1
for i in range(1, 5101):
	inv[i] = mu(i, K - 2)

for i in range(1, 5101):
	c[i][0] = 1
	for j in range (1, i):
		c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K
	c[i][i] = 1

p, s, r = map(int, input().split())

res = 0
den = 0

for i in range(1, p + 1):
	A = 0
	for d in range(r, s // i + 1):
		if (i < p): A = (A + calc(p - i, d, s - d * i)) % K
		else:
			if (s - i * d == 0): A += 1
	A = A * inv[i] % K
	res = (res + A * c[p - 1][i - 1] % K) % K

den = c[s - r + p - 1][p - 1]
res = res * mu(den, K - 2) % K
print(res)


",6,5
"base=998244353;
def power(x, y):
    if(y==0):
        return 1
    t=power(x, y//2)
    t=(t*t)%base
    if(y%2):
        t=(t*x)%base
    return t;
def inverse(x):
    return power(x, base-2)
f=[1]
iv=[1]
for i in range(1, 5555):
    f.append((f[i-1]*i)%base)
    iv.append(inverse(f[i]))
def C(n, k):
    return (f[n]*iv[k]*iv[n-k])%base
def candy(n, k):
    # print(n, k)
    return C(n+k-1, k-1)
def count_game(k, n, x): #k players, n points total, no player can have x point or more
    if(k==0):
        if(n==0):
            return 1
        else:
            return 0
    ans=0
    for i in range(0, k+1):
        t=n-x*i
        # print(i, C(k, i))
        if(t<0):
            break
        if(i%2):
            ans=(ans-C(k, i)*candy(t, k))%base
        else:
            ans=(ans+C(k, i)*candy(t, k))%base 
    return ans
p, s, r= list(map(int, input().split()))
gamesize=count_game(p, s-r, int(1e18))
gamesize=inverse(gamesize)
ans=0;
for q in range(r, s+1):
    for i in range(0, p): #exactly i people have the same score
        t=s-(i+1)*q
        if(t<0):
            break
        # print(q, i, count_game(p-i-1, t, q));
        ans=(ans+C(p-1, i)*count_game(p-i-1, t, q)*gamesize*inverse(i+1))%base
print(ans)
        
    ",6,5
"n=int(input())
s=input()
cur=0
for a in s:
    cur=max(cur,0)
    if(a=='-'):
        cur-=1
    else: cur+=1
    cur=max(cur,0)
print(cur)",3,1
"n=int(input())
s=input()
ans=0
for i in s:
    if(i=='+'):
        ans+=1
    else:
        ans-=1
    if(ans<0):
        ans=0
print(ans)",3,1
"n = int(input())
s = input()
t = 0
mn = 0
for i in s:
    if i == '-':
        t-=1
    else:
        t+=1
    mn = min(mn, t)
print(-mn+t)",3,1
"n = int(input())
s = input()
b = 0
for i in s:
    if i == '+':
        b += 1
    else:
        b -= 1
        b = max(b, 0)
print(b)",3,1
"n = int(input())
s = input()
t = 0
for i in s:
    if i == '+':
        t += 1
    else:
        t = max(t - 1, 0)

print(max(t, 0))
",3,1
"n = int(input())
s = input()
ans = 10000
for i in range(0, 105):
	f = True
	x = i
	for c in s:
		if c == '-':
			x -= 1
		else:
			x += 1
		if x < 0:
			f = False
	if f:
		ans = min(ans, x)
print(ans)
",3,1
"def main():
    n = int(input())
    s = input()
    for i in range(n+1):
        flag = True
        stones = i
        for j in s:
            if j == '-':
                if stones > 0:
                    stones -= 1
                else:
                    flag = False
                    break
            else:
                stones += 1

        if flag:
            n = i
            break

    stones = n
    for i in s:
        if i == '-':
            stones -= 1
        else:
            stones += 1

    print(stones)

    

main()
",5,3
"n = int(input())
s = input()
maxn = 0
now = 0
for i in s:
    if i == '+':
        now += 1
    else:
        now -= 1
    maxn = max(maxn, -now)
print(now + maxn)",3,1
"def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n = read_int()
    s = read()
    stones = 0
    for c in s:
        if c == '+':
            stones += 1
        else:
            stones -= 1
            if stones < 0:
                stones = 0
    write(stones)

main()
",3,1
"def go():
    n = int(input())
    a = [i for i in input()]
    x = 0
    for i in a:
        if i == '-':
            x = max(0, x - 1)
        else:
            x += 1
    return x

print(go())
",3,1
"def stones_after(n, s):
	for i in s:
		if i == '-':
			n -= 1
		else:
			n += 1
		if n < 0:
			return -1
	return n

n = int(input().strip())
s = input().strip()
ans = 99999999
for i in range(n+1):
	stones = stones_after(i, s)
	if stones != -1:
		ans = min(ans, stones)
print(ans)",5,3
"n = int(input())
a = list(map(int, input().split()))

c = 0

for i in range(1, n-1):
    if a[i] > a[i-1] and a[i] > a[i+1]:
        c +=1
    if a[i] == a[i-1] or a[i] == a[i+1]:
        print('NO')
        exit()
    if a[i] <= a[i-1] and a[i] <= a[i+1]:
        print('NO')
        exit()
if c>1:
    print('NO')
else:
    print('YES')",3,3
"n = int(input())
li = list(map(int, input().split()))
x = li.index(max(li))
if li[:x] == sorted(li[:x]) and li[x:] == sorted(li[x:])[::-1]:
    print(""YES"")
else:
    print(""NO"")",4,1
"n=int(input())
arr=list(map(int,input().split()))
maxval=max(arr)
maxindex=-1
for i in range(n):
	if(arr[i]==maxval):
		maxindex=i
		break

flag=0
temp=maxval
for i in range(maxindex-1,-1,-1):
	if(temp<=arr[i]):
		flag=1
		break
	else:
		temp=arr[i]

temp=maxval
for i in range(maxindex+1,n):
	if(arr[i]>=temp):
		flag=1
		break
	else:
		temp=arr[i]

if(flag==0):
	print(""YES"")
else:
	print(""NO"")
",3,6
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int, sys.stdin.readline().strip().split()))
i = a.index(max(a))
v = True
for j in range (0, i):
    if a[j] > a[j+1]:
        v = False
for j in range (i, n-1):
    if a[j] < a[j+1]:
        v = False
if v == True:
    print(""YES"")
else:
    print(""NO"")",3,6
"n = int(input())
l = list(map(int, input().split()))
to = l.index(max(l))
ok = 1
for i in range(1, to):
    if (l[i] <= l[i - 1]):
        ok = 0
        break
for i in range(to + 1, n):
    if (l[i] >= l[i - 1]):
        ok = 0
        break
if ok:
    print('YES')
else:
    print('NO')",3,5
"n = int(input())
arr = [int(x) for x in input().split()]
x = arr.index(max(arr))
cur = max(arr)
l = x - 1
r = x + 1
ok = 1
for i in range(n - 1):
    if l < 0:
        ok *= (arr[r] < cur)
        cur = arr[r]
        r += 1
    elif r >= n:
        ok *= (arr[l] < cur)
        cur = arr[l]
        l -= 1
    else:
        if arr[l] > arr[r]:
            ok *= (arr[l] < cur)
            cur = arr[l]
            l -= 1
        else:
            ok *= (arr[r] < cur)
            cur = arr[r]
            r += 1
print(""YES"" if ok else ""NO"")",3,3
"n = int(input().strip())
nums = list(map(int, input().strip().split()))
has_dups = (len(nums) > len(set(nums)))
mx = nums.index(max(nums))
if has_dups or nums[:mx+1]!=sorted(nums[:mx+1]) or nums[mx:]!=sorted(nums[mx:], reverse=True):
    print(""NO"")
else:
    print(""YES"")",4,1
"def main():
    import sys
    input = sys.stdin.readline
    
    n = int(input())
    arr = list(map(int, input().split()))
    idx = arr.index(n)
    ok = 1
    for i in range(1, idx):
        if arr[i] < arr[i - 1]:
            ok = 0
    for i in reversed(range(idx, n - 1)):
        if arr[i] < arr[i + 1]:
            ok = 0
    if ok:
        print(""YES"")
    else:
        print(""NO"")
    
    return 0

main()",3,6
"n = int(input())
a = list(map(int, input().split()))
idx = list(range(n))
idx.sort(key=lambda i: a[i], reverse=True)
imin = imax = idx[0]
for i in idx[1:]:
    if i == imin - 1 or i == imax + 1:
        imin = min(imin, i)
        imax = max(imax, i)
    else:
        print('NO')
        exit(0)
print('YES')
",4,1
"n = int(input())
a = list(map(int,input().split()))
fl = False
ans = True
for i in range(n-1):
    if a[i+1]>a[i]:
        if fl:
            ans = False
    else:
        fl = True
if ans:
    print('YES')
else:
    print('NO')",3,3
"t=int(input())
g=list(map(int,input().split()))
k=max(g)
flag=True
i=0
while g[i]!=k:
    if i!=0 and g[i]<g[i-1]:
        print(""NO"")
        exit()
    i+=1
i+=1
while i<t and g[i]!=k:
    if i!=0 and g[i]>g[i-1]:
        print(""NO"")
        exit()
    i+=1
print(""YES"")",3,5
"import io, sys
input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()

ii = lambda: int(input())
mi = lambda: map(int, input().split())
li = lambda: list(mi())

n = ii()
a = li()
p = a.index(max(a))
b = sorted(a)
b.pop()
ok = 1
i, j = p - 1, p + 1
while i >= 0 or j < n:
    if i >= 0 and a[i] == b[-1]:
        b.pop()
        i -= 1
    elif j < n and a[j] == b[-1]:
        b.pop()
        j += 1
    else:
        ok = 0
        break
print('YES' if ok else 'NO')",4,3
"n = int(input())
a = list(map(int, input().split()))
s = sorted(a)
q = a.index(max(a))
q1, q = min(len(a)-1, q+1), max(0, q-1)
for q2 in range(len(a)-2, -1, -1):
    if a[q] == s[q2]:
        q = max(0, q-1)
    elif a[q1] == s[q2]:
        q1 = min(len(a)-1, q1+1)
    else:
        print(""NO"")
        break
else:
    print(""YES"")
",4,3
"n = int(input())
a = list(map(int,input().split()))
rev = [-1] * (n + 1)
for i, j in enumerate(a):
    rev[j] = i

mx = max(a)

# [l, r]
l = a.index(mx)
r = l

for i in range(n - 1, 0, -1):
    idx = rev[i]
    if idx == l - 1:
        l -= 1
    elif idx == r + 1:
        r += 1
    else:
        print('NO')
        exit()
print('YES')",3,3
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

count = [[0] * m for _ in range(m)]
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        count[c1][c2] += 1

sum_of_subset = [[0] * (1 << m) for _ in range(m)]
for i in range(m):
    for j in range(1 << m):
        if j == 0:
            continue
        lsb = j & -j
        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]

adj_in_subset = [0] * (1 << m)
for i in range(1 << m):
    for j in range(m):
        if i & (1 << j):
            adj_in_subset[i] += sum_of_subset[j][i]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        not_i = ((1 << m) - 1) ^ i
        val = dp[i] + (total_adj - adj_in_subset[i] - adj_in_subset[not_i])
        dp[i | (1 << j)] = min(dp[i | (1 << j)], val)
print(dp[-1])",7,7
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

count = [[0] * m for _ in range(m)]
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        count[c1][c2] += 1

sum_of_subset = [[0] * (1 << m) for _ in range(m)]
for i in range(m):
    for j in range(1 << m):
        if j == 0:
            continue
        lsb = j & -j
        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]

adj_in_subset = [0] * (1 << m)
for i in range(1 << m):
    for j in range(m):
        if i & (1 << j):
            adj_in_subset[i] += sum_of_subset[j][i]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]
        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)
print(dp[-1])",7,7
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

# Calculate adjacent count in subset
adj_in_subset = [0] * (1 << m)
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        adj_in_subset[(1 << c1) + (1 << c2)] += 1
for i in range(m):
    for j in range(1 << m):
        if j & (1 << i):
            adj_in_subset[j] += adj_in_subset[j ^ (1 << i)]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]
        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)
print(dp[-1])",7,7
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')
from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

# ------------------------------

def cord(c):
    return ord(c)-ord('a')

def main():
    n, m = RL()
    s = input()
    ct = [0]*(1<<m)

    for i in range(n-1):
        now, nex = cord(s[i]), cord(s[i+1])
        if now==nex: continue
        ct[1<<now | 1<<nex]+=1

    for i in range(m):
        for j in range(1<<m):
            if (1<<i) & j:
                ct[j]+=ct[(1<<i) ^ j]

    dp = [INF]*(1<<m)
    dp[0] = 0
    for i in range(1<<m):
        # pos = bin(i).count('1')
        for j in range(m):
            # sm = 0
            # if i>>j & 1 == 0:
            #     for k in range(m):
            #         if 1<<k & i==0:
            #             sm-=ct[j][k]*pos
            #         else:
            #             sm+=ct[j][k]*pos
            if i & 1<<j == 0:
                sm = ct[-1]-ct[i]-ct[~i]
                dp[i|(1<<j)] = min(dp[i|(1<<j)], dp[i] + sm)
    # print(ct)
    print(dp[-1])





if __name__ == ""__main__"":
    main()

",7,7
"n, m = map(int, input().split())
a = list(map(str, input().strip()))

dp = [10 ** 10] * (1 << 20)
cnt = [0] * (1 << 20)


def get(x):
    return 1 << (ord(x) - ord('a'))


for i, v in enumerate(a):
    if i:
        cnt[get(a[i]) | get(a[i - 1])] += 1

for i in range(m):
    for j in range(1 << m):
        if (1 << i) & j:
            cnt[j] += cnt[j ^ (1 << i)]
            # print(bin(j), bin(j ^ 1 << i), cnt[j])

# for i in range(1 << m):
#     for j in range(m):
#         if not i & (1 << j):
#             cnt[i | (1 << j)] += cnt[i]
#             print(bin(i | (1 << j)), bin(i), cnt[i | 1 << j])

dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if not i & (1 << j):
            dp[i | (1 << j)] = min(dp[i | (1 << j)],
                                   dp[i] + n - 1 - cnt[i | (1 << j)] - cnt[(1 << m) - 1 - (i | (1 << j))])
print(dp[(1 << m) - 1])
",7,7
"
R,G,B=[int(c) for c in input().split()]
ra=[int(c) for c in input().split()]
ga=[int(c) for c in input().split()]
ba=[int(c) for c in input().split()]

ra.sort(reverse=True)
ga.sort(reverse=True)
ba.sort(reverse=True)

dp = [[[-1 for i in range(201)]for j in range(201)]for k in range(201)]
def solve(dp,r,g,b):
    if dp[r][g][b] !=-1:
        return dp[r][g][b]
    count= 0
    for i,j in zip((r,g,b),(R,G,B)):
        if i == j:
            count+=1
    if count >= 2:
        return 0

    ##Three cases choose btw r,b r,g  and gb
    res = -999
    if r != R and b!=B:

        res = max(res,ra[r]*ba[b] + solve(dp,r+1,g,b+1))
        # print(res)
    
    if r!=R and g != G:
        res = max(res,ra[r]*ga[g] + solve(dp,r+1,g+1,b))
        # print(res)
    
    if b!=B and g != G:
        res = max(res,ba[b]*ga[g] + solve(dp,r,g+1,b+1))
        # print(res)
    
    dp[r][g][b] = res

    return res
     

print(solve(dp,0,0,0))",6,1
"r,g, b = map(int,input().split())
R = sorted([*map(int,input().split())],reverse=True)
G= sorted([*map(int,input().split())],reverse=True)
B = sorted([*map(int,input().split())],reverse=True)
mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]
def dp(i,j,k):
    p = (i==r)+(j==g)+(k==b)
    if(p>1):
        return 0
    if(mem[i][j][k]!=-1):
        return mem[i][j][k]
    ans = 0
    if(i==r):
        ans = dp(i,j+1,k+1)+G[j]*B[k]
        return ans
    elif(j==g):
        ans = dp(i+1,j,k+1)+R[i]*B[k]
    elif(k==b):
        ans = dp(i+1,j+1,k)+R[i]*G[j]
    else:
        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])
    mem[i][j][k] = ans
    return ans
print(dp(0,0,0))",6,1
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp = [[[0 for ___ in range(B+1)] for __ in range(G+1)] for _ in range(R+1)]
mx = 0

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i < R and j < G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i] * g[j])
            if i < R and k < B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i] * b[k])
            if j < G and k < B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j] * b[k])
            mx = max(mx, dp[i][j][k])

print(mx)",6,3
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict


BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------game starts now-----------------------------------------------------
R,G,B=map(int,input().split())
r=sorted(list(map(int,input().split())))
g=sorted(list(map(int,input().split())))
b=sorted(list(map(int,input().split())))
dp=[[[0]*(B+1) for j in range(G+1)] for i in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k - 1] + g[j - 1] * b[k - 1])
print(dp[R][G][B])",6,3
"import sys, math
import io, os
#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
#from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction
#sys.setrecursionlimit(100000)
INF = float('inf')
mod = int(1e9)+7

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

@bootstrap
def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        yield 0
        return
    if dp[r][g][b]:
        yield dp[r][g][b]
        return
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+(yield recur(r-1,g-1,b)))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+(yield recur(r-1,g,b-1)))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+(yield recur(r,g-1,b-1)))
    yield dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))
",6,3
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
# from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
# import numpy as np
starttime = time.time()
# import numpy as np
mod = int(pow(10, 9) + 7)
mod2 = 998244353
def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]

try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""../output.txt"", ""w"")
except:
    pass
global ans
ans=0

def rec(i,j,k):
    if dp[i][j][k]!=-1:
        return dp[i][j][k]
    x1=x2=x3=0
    if i<R and j<G:
        x1=r[i]*g[j]+rec(i+1,j+1,k)
    if i<R and k<B:
        x2=r[i]*b[k]+rec(i+1,j,k+1)
    if j<G and k<B:
        x3=g[j]*b[k]+rec(i,j+1,k+1)
    dp[i][j][k]=max(x1,x2,x3)
    global ans
    ans=max(ans,dp[i][j][k])
    return dp[i][j][k]

for _ in range(1):
    R,G,B=L()
    r=L()
    g=L()
    b=L()
    r.sort(reverse=True)
    g.sort(reverse=True)
    b.sort(reverse=True)
    dp=[[[-1 for k in range(B+1)] for j in range(G+1)] for i in range(R+1)]
    rec(0,0,0)
    print(ans)



endtime = time.time()
# print(f""Runtime of the program is {endtime - starttime}"")

",6,3
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
ans = 0
for i in dp:
       for j in i:
              ans = max(ans, max(j))

print(ans)
",6,3
"#tests = int(input())
#for t in range(tests):
#    b= int(input())
#    ls = [int(x) for x in input()]

r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))


dp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

for i in range(r+1):
    dp[i][0][0] = 0
for i in range(g+1):
    dp[0][i][0] = 0
for i in range(b+1):
    dp[0][0][i] = 0

dp[1][1][0] = ls_r[0] * ls_g[0]
dp[0][1][1] = ls_g[0] * ls_b[0]
dp[1][0][1] = ls_r[0] * ls_b[0]    

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            res1 = 0
            res2 = 0
            res3 = 0
            if i-1>=0 and j-1>=0:
                res1 += dp[i-1][j-1][k] + ls_r[i-1] * ls_g[j-1]
            if i-1>=0 and k-1>=0:
                res2 += dp[i-1][j][k-1] + ls_r[i-1] * ls_b[k-1]
            if j-1>=0 and k-1>=0:
                res3 += dp[i][j-1][k-1] + ls_g[j-1] * ls_b[k-1]
            dp[i][j][k] = max(res1,res2,res3)
print(dp[r][g][b])",6,5
"r,g,b = map(int,input().split())

R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))

R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
# dp[i][j][k]

dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]

for j in range(g-1,-1,-1):
    for k in range(b-1,-1,-1):
        dp[r][j][k] = G[j]*B[k] + dp[r][j+1][k+1]

for i in range(r-1,-1,-1):
    for k in range(b-1,-1,-1):
        dp[i][g][k] = R[i]*B[k] + dp[i+1][g][k+1]

for i in range(r-1,-1,-1):
    for j in range(g-1,-1,-1):
        dp[i][j][b] = R[i]*G[j] + dp[i+1][j+1][b]

for i in range(r-1,-1,-1):
    for j in range(g-1,-1,-1):
        for k in range(b-1,-1,-1):
            case1 = dp[i+1][j][k]
            case2 = dp[i][j+1][k]
            case3 = dp[i][j][k+1]

            case4 = R[i]*G[j] + dp[i+1][j+1][k]
            case5 = R[i]*B[k] + dp[i+1][j][k+1]
            case6 = G[j]*B[k] + dp[i][j+1][k+1]

            dp[i][j][k] = max(case1,case2,case3,case4,case5,case6)

print(dp[0][0][0])
",6,3
"r, g, b = map(int, input().split())
red = list(map(int, input().split()))
green = list(map(int, input().split()))
blue = list(map(int, input().split()))
red.sort()
green.sort()
blue.sort()
red = red[::-1]
green = green[::-1]
blue = blue[::-1]

dp = []
for i in range(r + 1):
    temp = [[0] * (b + 1) for j in range(g + 1)]
    dp.append(temp)

answer = 0 

for i in range(0, r + 1):
    for j in range(0, g + 1):
        for k in range(0, b + 1):
            if i > 0 and j > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + red[i - 1] * green[j - 1])
            if i > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + red[i - 1] * blue[k - 1])
            if j > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + green[j - 1] * blue[k - 1])
                
            answer = max(answer, dp[i][j][k])
print(answer)",6,3
"def cal(r, g, b):
	if dp[r][g][b] != -1:
		return dp[r][g][b]

	area = 0
	if r<R and g<G:
		area = max(area, rl[r] * gl[g] + cal(r+1, g+1, b))
	if r<R and b<B:
		area = max(area, rl[r] * bl[b] + cal(r+1, g, b+1))
	if g<G and b<B:
		area = max(area, gl[g] * bl[b] + cal(r, g+1, b+1))
	dp[r][g][b] = area
	return area

if __name__ == ""__main__"":
	R, G, B = map(int,input().split())
	rl = sorted(list(map(int,input().split())), reverse=True)
	gl = sorted(list(map(int,input().split())), reverse=True)
	bl = sorted(list(map(int,input().split())), reverse=True)
	dp = [[[-1]*(B+1) for i in range(G+1)] for i in range(R+1)]
	print(cal(0,0,0))
",6,3
"import sys
input = sys.stdin.readline

R,G,B = map(int,input().split())

r = list(map(int,input().split()))
g = list(map(int,input().split()))
b = list(map(int,input().split()))

r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
r = [0] + r
g = [0] + g
b = [0] + b
R += 1
G += 1
B += 1
dp = [[[0]*B for _ in range(G)] for __ in range(R)]

res = 0

for i in range(R):
    for j in range(G):
        for k in range(B):

            tmp = 0
            if i > 0 and j > 0:
                tmp = max(tmp,dp[i-1][j-1][k]+r[i]*g[j])
            if i > 0 and k > 0:
                tmp = max(tmp,dp[i-1][j][k-1]+r[i]*b[k])
            if j > 0 and k > 0:
                tmp = max(tmp,dp[i][j-1][k-1]+g[j]*b[k])
            dp[i][j][k] = tmp
            res = max(res,tmp)

print(res)



",6,-100
"from collections import defaultdict as dd
import math
import sys
import heapq
import copy
input=sys.stdin.readline
def nn():
	return int(input())

def li():
	return list(input())

def mi():
	return map(int, input().split())

def lm():
	return list(map(int, input().split()))


def solve():

	r,g,b = mi()

	rs = lm()
	gs = lm()
	bs = lm()
	rs.sort()
	gs.sort()
	bs.sort()

	ans = [[[0 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]

	for i in range(1,r+1):
		for j in range(1,g+1):
			ans[i][j][0]= ans[i-1][j-1][0]+rs[i-1]*gs[j-1]


	for i in range(r+1):
		for j in range(g+1):
			for k in range(1,b+1):
				new_len = bs[k-1]
				if i==0:
					i_len = 0
				else:
					i_len = ans[i-1][j][k-1] + rs[i-1]*new_len
				if j==0:
					j_len = 0
				else:
					j_len = ans[i][j-1][k-1] + gs[j-1]*new_len
				if i>0 and j>0:
					i_j_len = ans[i-1][j-1][k]+rs[i-1]*gs[j-1]
				else:
					i_j_len = 0
				ans[i][j][k] = max(i_len,
									j_len,
									ans[i][j][k-1],
									i_j_len)
	#print(ans)
	print(ans[r][g][b])





solve()
",6,3
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#######################################
r,g,b = map(int,input().split())
l1 = list(map(int,input().split()))
l2 = list(map(int,input().split()))
l3 = list(map(int,input().split()))
l1.sort(reverse=True)
l2.sort(reverse=True)
l3.sort(reverse=True)
dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]
ans = 0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i == 0 and j == 0:
                dp[i][j][k] = 0
            if j == 0 and k == 0:
                dp[i][j][k] = 0
            if i == 0 and k == 0:
                dp[i][j][k] = 0
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])
            else:
                if i>0 and j>0:
                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]
                elif i>0 and k>0:
                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]
                elif j>0 and k>0:
                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]
            ans = max(ans,dp[i][j][k])
                    
print(ans)
                                   
                
            
",6,3
"def solve(i, j, k):
    if (i < 0 and j < 0) or (j < 0 and k < 0) or (i < 0 and k < 0):
        return 0
    if dp[i][j][k] != -1:
        return dp[i][j][k]
    ans = 0
    if i >= 0 and j >= 0:
        ans = max(ans, rs[i] * gs[j] + solve(i - 1, j - 1, k))
    if i >= 0 and k >= 0:
        ans = max(ans, rs[i] * bs[k] + solve(i - 1, j, k - 1))
    if j >= 0 and k >= 0:
        ans = max(ans, bs[k] * gs[j] + solve(i, j - 1, k - 1))
    dp[i][j][k] = ans
    return ans

a, b, c = map(int, input().split())
rs = sorted(list(map(int, input().split())))
gs = sorted(list(map(int, input().split())))
bs = sorted(list(map(int, input().split())))
dp = [[[-1 for x in range(c + 1)] for y in range(b + 1)] for z in range(a + 1)]
print(solve(a - 1, b - 1, c - 1))
",6,3
"import sys

def dp(ri, gi, bi):
    if ri>r or gi>g or bi>b:
        return 0

    if not list_memo[ri][gi][bi]==-1:
        return list_memo[ri][gi][bi]
    
    list_memo[ri][gi][bi] = max(dp(ri+1, gi+1, bi)+r_c[ri]*g_c[gi], dp(ri+1, gi, bi+1)+r_c[ri]*b_c[bi], dp(ri, gi+1, bi+1)+g_c[gi]*b_c[bi])
    return list_memo[ri][gi][bi]


r, g, b = map(int, sys.stdin.readline().split())

r_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)
g_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)
b_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)


list_memo = [[[-1]*(b+1) for _ in range(g+1)] for _ in range(r+1)]

print(dp(0, 0, 0))",6,3
"#: Author - Soumya Saurav
import sys,io,os,time
from collections import defaultdict
from collections import OrderedDict
from collections import deque
from itertools import combinations
from itertools import permutations
import bisect,math,heapq
alphabet = ""abcdefghijklmnopqrstuvwxyz""

input = sys.stdin.readline

########################################
'''
3 3 3 
1 2 3
1 2 3
1 2 3

'''
'''
nax = 201

nr , ng , nb = map(int, input().split())
n = nr + ng + nb
r = list(map(int , input().split()))
g = list(map(int , input().split()))
b = list(map(int , input().split()))

r.sort()
g.sort()
b.sort()

dp = [[[0]*nax for i in range(nax)] for j in range(nax)]
'''
'''
arr = [[1,i] for i in r] + [[2,i] for i in b] + [[3,i] for i in g]
arr.sort(key = lambda x : x[1],reverse = True)
ans = 0
done = [False]*n
print(arr)
for i in range(n):
	ok = False
	if done[i]: continue
	for j in range(i+1,n):
		if done[j]: continue
		if arr[i][0] != arr[j][0]:
			print(i+1,j+1,arr[i][1]*arr[j][1])
			ans += arr[i][1]*arr[j][1]
			done[i] = True
			done[j] = True
			ok = True
			break
	if not ok: break
print(ans)

'''
'''
sys.setrecursionlimit(10**7)


from functools import lru_cache
@lru_cache(None)
def f(i,j,k):
	#print(i,j,k)
	if (i >= nr and j >= ng) or (j >= ng and k >= nb) or (i >= nr and k >= nb):
		return 0
	ans = r[i]*g[j] + f(i+1,j+1,k) if i < nr and j < ng else 0
	#print(ans)
	if i < nr and k < nb:
		ans = max(ans , r[i]*b[k] + f(i+1,j,k+1)) 
	#print(""???:"",ans,r[k]*r[j] + f(i,j+1,k+1))
	if k < nb and j < ng:
		ans = max(ans, g[j]*b[k] + f(i,j+1,k+1))
	#print(ans)
	return ans
print(f(0,0,0))
	
'''
def solve():
  r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
  for i in range(r+1):
    for j in range(g+1):
      for k in range(b+1):
        if i+j+k<2:continue
        if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
        if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
        if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
  return dp[r][g][b]
print(solve())



",6,3
"R, G, B = list(map(int, input().split()))
r = sorted(list(map(int, input().split())), reverse=True)
g = sorted(list(map(int, input().split())), reverse=True)
b = sorted(list(map(int, input().split())), reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",6,3
"import sys, math
import io, os
#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
#from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction
#sys.setrecursionlimit(100000)
INF = float('inf')
mod = int(1e9)+7


def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        return 0
    if dp[r][g][b]:
        return dp[r][g][b]
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+recur(r-1,g-1,b))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+recur(r-1,g,b-1))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+recur(r,g-1,b-1))
    return dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))
",6,3
"import sys
#input = sys.stdin.readline

R, G, B = list(map(int, input().split()))
r = sorted([int(x) for x in input().split()], reverse = True)
g = sorted([int(x) for x in input().split()], reverse = True)
b = sorted([int(x) for x in input().split()], reverse = True)

ans = 0

dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if  j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + b[k]*r[i])
            ans = max(ans, dp[i][j][k])
print(ans)",6,3
"# import sys
# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            if i<n[0] and j<n[1]:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + u[0][i]*u[1][j])
            if j<n[1] and k<n[2]:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + u[1][j]*u[2][k])
            if i<n[0] and k<n[2]:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + u[0][i]*u[2][k])
res = max(x for u1 in dp for u2 in u1 for x in u2)
print(res)",6,3
"#from collections import defaultdict
#DPL=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]
ri,gi,bi=map(int,input().split())
rr=sorted(list(map(int,input().split())))
gr=sorted(list(map(int,input().split())))
br=sorted(list(map(int,input().split())))
dp=[[[-1]*(bi+1) for i in range(gi+1)] for j in range(ri+1)]
def area(r,g,b):
	if dp[r+1][g+1][b+1]!=-1:
		return dp[r+1][g+1][b+1]
	ans=0
	if r>=0 and g>=0:
		ans=max(ans,rr[r]*gr[g]+area(r-1,g-1,b))
	if r>=0 and b>=0:
		ans=max(ans,rr[r]*br[b]+area(r-1,g,b-1))	
	if b>=0 and g>=0:
		ans=max(ans,br[b]*gr[g]+area(r,g-1,b-1))	
	dp[r+1][g+1][b+1]=ans
	return ans
print(area(ri-1,gi-1,bi-1))",6,1
"# @author --> ajaymodi
# optimized approach with memoization (dp)
import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""output.out"",""w"")

input=lambda : sys.stdin.readline().strip()
char = [chr(i) for i in range(97,123)]
CHAR = [chr(i) for i in range(65,91)]
mp = lambda:list(map(int,input().split()))
INT = lambda:int(input())
rn = lambda:range(INT())


from math import ceil,sqrt,factorial,gcd

r,g,b = mp()
rl = sorted(mp(),reverse=True)
gl = sorted(mp(),reverse=True)
bl = sorted(mp(),reverse=True)



def solve(i,j,k):
	if dp_table[i][j][k] != -1:
		return dp_table[i][j][k]

	ans = 0

	if i < r and j < g:
		ans = max(solve(i+1,j+1,k) + rl[i]*gl[j],ans)

	if i < r and k < b:	
		ans = max(solve(i+1,j,k+1) + rl[i]*bl[k],ans)

	if j < g and k < b:
		ans = max(solve(i,j+1,k+1) + gl[j]*bl[k],ans)

	dp_table[i][j][k] = ans
	return dp_table[i][j][k]
		

dp_table = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
res = solve(0,0,0)
print(res)
",6,3
"def rec(r,g,b):
    if(dp[r][g][b]!=-1):
        return dp[r][g][b]
    ans=0
    if r<R and g<G:
        ans=max(ans, red[r]*green[g]+rec(r+1, g+1, b))
    if r<R and b<B:
        ans=max(ans, red[r]*blue[b]+rec(r+1, g, b+1))
    if b<B and g<G:
        ans=max(ans, blue[b]*green[g]+rec(r, g+1, b+1))
    dp[r][g][b]=ans
    return ans
R,G,B=map(int,input().split())
red=sorted(list(map(int, input().split())), reverse=True)
green=sorted(list(map(int, input().split())), reverse=True)
blue=sorted(list(map(int, input().split())), reverse=True)
dp=[[[-1]*(B+1) for _ in range(G+1)] for _ in range(R+1)]
print(rec(0,0,0))",6,3
"from sys import stdin,stdout

# stdin  = open(""input.txt"",""r"")
# stdout = open(""output.txt"",""w"")


final_ans=0

# def solve(r,g,b):
# 	print(r,g,b)
# 	ans=0
# 	if min(r,g,b)<0:
# 		return 0
# 	if dparr[r-1][g-1][b]==-1:
# 		solve(r-1,g-1,b)
# 	ans=max(ans,dparr[r-1][g-1][b]+Ra[r-1]*Ga[g-1])
# 	if dparr[r-1][g][b-1]==-1:
# 		solve(r-1,g,b-1)
# 	ans=max(ans,dparr[r-1][g][b-1]+Ra[r-1]*Ba[b-1])
# 	if dparr[r][g-1][b-1]==-1:
# 		solve(r,g-1,b-1)
# 	ans=max(ans,dparr[r][g-1][b-1]+Ga[g-1]*Ba[b-1])
# 	dparr[r][g][b]=ans


R,G,B = map(int,stdin.readline().strip().split(' '))
Ra = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)
Ga = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)
Ba = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)

dparr=[[[-1 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
dparr[1][1][0]=Ra[0]*Ga[0]
dparr[1][0][1]=Ra[0]*Ba[0]
dparr[0][1][1]=Ga[0]*Ba[0]
final_ans=max(final_ans,dparr[1][1][0],dparr[1][0][1],dparr[0][1][1])
# solve(R,G,B)
# stdout.write(str(dparr[R][G][B])+""\n"")


def add_ns(t1):
	global queue,Ra,Ga,Ba,dparr
	x,y,z=t1
	if x+1<=R:
		if y+1<=G:
			if dparr[x+1][y+1][z]==-1:
				queue.append((x+1,y+1,z))
				dparr[x+1][y+1][z]=0
		
		if z+1<=B:
			if dparr[x+1][y][z+1]==-1:
				queue.append((x+1,y,z+1))
				dparr[x+1][y][z+1]=0
	if y+1<=G and z+1<=B:
		if dparr[x][y+1][z+1]==-1:
			queue.append((x,y+1,z+1))
			dparr[x][y+1][z+1]=0

def store_ans(t1):
	global final_ans,dparr,Ra,Ga,Ba
	x,y,z=t1
	if dparr[x-1][y-1][z]!=-1 and min(x-1,y-1,z)>=0:
		# print(dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1])
		dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1])
	if dparr[x-1][y][z-1]!=-1 and min(x-1,y,z-1)>=0:
		# print(dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1])
		dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1])
	if dparr[x][y-1][z-1]!=-1 and min(x,y-1,z-1)>=0:
		# print(dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1])
		dparr[x][y][z] = max(dparr[x][y][z],dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1])
	# print(dparr[x][y][z])

	final_ans=max(final_ans,dparr[x][y][z])

queue=[(1,1,0),(1,0,1),(0,1,1)]
add_ns(queue[0])
add_ns(queue[1])
add_ns(queue[2])
ptr=3

while ptr<len(queue):
	# print(queue[ptr])
	store_ans(queue[ptr])
	# print()
	add_ns(queue[ptr])
	
	ptr+=1

stdout.write(str(final_ans)+""\n"")",6,3
"# XXXX
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__
# do magic here
sys.setrecursionlimit(200000)
r, g, b = map(int, input().split())
R = list(map(int, input().split()))
G = list(map(int, input().split()))
B = list(map(int, input().split()))
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)

dp = [[[0 for i in range(b+5)] for j in range(g+5)] for k in range(r+5)]


def solve(i, j, k):
    x, y, z = 0, 0, 0
    if dp[i][j][k]:
        return dp[i][j][k]
    if i < r and j < g:
        x = (R[i] * G[j]) + solve(i+1, j+1, k)
    if i < r and k < b:
        y = (R[i] * B[k]) + solve(i+1, j, k+1)
    if j < g and k < b:
        z = (G[j] * B[k]) + solve(i, j+1, k+1)
    mx = max([x, y, z])
    dp[i][j][k] = mx
    return mx


print(solve(0, 0, 0))
",6,1
"import sys
input=sys.stdin.buffer.readline

nr,ng,nb=[int(x) for x in input().split()]
r=[int(x) for x in input().split()]
g=[int(x) for x in input().split()]
b=[int(x) for x in input().split()]

r.sort()
g.sort()
b.sort()

memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]
memo[0][0][0]=0 #starting point when i==-1,j==-1,k==-1
for i in range(nr):
    memo[i+1][0][0]=0
for j in range(ng):
    memo[0][j+1][0]=0
for k in range(nb):
    memo[0][0][k+1]=0
def dp(i,j,k): #dp(i,j,k) is the max value including r[i],g[j],b[k]
    if i<-1 or j<-1 or k<-1:
        return -float('inf')
    if memo[i+1][j+1][k+1]==-1: #offset by 1 because i,j,k can be -1
        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],
                   dp(i-1,j-1,k)+r[i]*g[j],
                   dp(i-1,j,k-1)+r[i]*b[k]
                )
    return memo[i+1][j+1][k+1]

#for i in range(max(nr,ng,nb)):
#    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))


print(dp(nr-1,ng-1,nb-1))",6,6
"nr, ng, nb = map(int, input().split())
r = sorted([int(i) for i in input().split()])
g = sorted([int(i) for i in input().split()])
b = sorted([int(i) for i in input().split()])

dp = [[[0 for _ in range(nb + 1)] for _ in range(ng + 1)] for _ in range(nr + 1)]
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            val = 0
            if i - 1 >= 0 and j - 1 >= 0:
                val = max(val, r[i - 1] * g[j - 1] + dp[i - 1][j - 1][k])
            if i - 1 >= 0 and k - 1 >= 0:
                val = max(val, r[i - 1] * b[k - 1] + dp[i - 1][j][k - 1])
            if j - 1 >= 0 and k - 1 >= 0:
                val = max(val, g[j - 1] * b[k - 1] + dp[i][j - 1][k - 1])
            dp[i][j][k] = val

print(dp[nr][ng][nb])
",6,3
"from random import randint

mod = 10**9 + 7
d = {}
n, m, l = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
def go(i, j, k):
    val = i * 40401 + j * 201 + k
    ret = 0
    if val in d:
        return d[val]
    elif i < n and j < m and k < l:
        ret = max(a[i] * b[j] + go(i + 1, j + 1, k), b[j] * c[k] + go(i, j + 1, k + 1), c[k] * a[i] + go(i + 1, j, k + 1))
    elif i < n and j < m:
        ret = a[i] * b[j] + go(i + 1, j + 1, k)
    elif j < m and k < l:
        ret = b[j] * c[k] + go(i, j + 1, k + 1)
    elif k < l and i < n:
        ret = c[k] * a[i] + go(i + 1, j, k + 1)
    d[val] = ret
    return ret

a.sort(reverse = True)
b.sort(reverse = True)
c.sort(reverse = True)
print(go(0, 0, 0))
",6,1
"import sys
sys.setrecursionlimit(200000)
input=sys.stdin.readline
 
def solve(r,g,b,R,G,B):
    if (r==0 and g==0) and (r==0 and b==0) and (g==0 and b==0):
        return 0
    if z[r][g][b]!=-1:
        return z[r][g][b]
    d,e,f=0,0,0
    if r!=0 and g!=0:
        d=R[r-1]*G[g-1]+solve(r-1,g-1,b,R,G,B)
    if r!=0 and b!=0:
        e=R[r-1]*B[b-1]+solve(r-1,g,b-1,R,G,B)
    if b!=0 and g!=0:
        f=B[b-1]*G[g-1]+solve(r,g-1,b-1,R,G,B)
    z[r][g][b]=max(d,e,f)
    return z[r][g][b]
 
r,g,b=map(int,input().rstrip().split())
R=sorted(map(int,input().rstrip().split()))
G=sorted(map(int,input().rstrip().split()))
B=sorted(map(int,input().rstrip().split()))
z=[[[ -1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
print(solve(r,g,b,R,G,B))",6,3
"from sys import stdin
nii=lambda:map(int,stdin.readline().split())
lnii=lambda:list(map(int,stdin.readline().split()))

R,G,B=nii()
r=lnii()
g=lnii()
b=lnii()

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp=[[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]

for i in range(R+1):
  for j in range(G+1):
    for k in range(B+1):
      c=False
      if i<R and j<G:
        dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+r[i]*g[j])
        c=True
      if j<G and k<B:
        dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+g[j]*b[k])
        c=True
      if k<B and i<R:
        dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+b[k]*r[i])
        c=True

      if not c:
        if i<R:
          dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k])
        if j<G:
          dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k])
        if k<B:
          dp[i][j][k+1]=max(dp[i][j][k+1],dp[i][j][k])

ans=0
for i in dp:
  for j in i:
    ans=max(ans,max(j))

print(ans)",6,3
"import sys

input = sys.stdin.readline

r, g, b = map(int, input().split())
sticks = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)]
dp, ans = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 # dp[i][j][k] is i largest red, j largest green, k largest blue
for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])
            ans = max(ans, dp[i][j][k])
print(ans)
",6,3
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans )",6,3
"
r,g,b=map(int,input().split())
s1=[int(x) for x in input().split()]
s2=[int(x) for x in input().split()]
s3=[int(x) for x in input().split()]
s1.sort()
s2.sort()
s3.sort()
s1=s1[::-1]
s2=s2[::-1]
s3=s3[::-1]
s1=[0]+s1
s2=[0]+s2
s3=[0]+s3

dp=[]
for i in range(r+5):
    H=[]
    for j in range(g+5):
        h=[]
        for k in range(b+5):
            h.append(0)
        H.append(h)
    dp.append(H)

for i in range(0,r+1):
    for j in range(0,g+1):
        for k in range(0,b+1):
            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0
            if(i-1>=0 and j-1>=0):
                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])
            if(i-1>=0 and k-1>=0):
                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])
            if(k-1>=0 and j-1>=0):
                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])
            if(i-1>=0):
                t4 = dp[i-1][j][k]
            if(j-1>=0):
                t5 = dp[i][j-1][k]
            if(k-1>=0):
                t6 = dp[i][j][k-1]

            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)



print(dp[r][g][b])

",6,3
"import os
import heapq
import sys, threading
import math
import bisect
import operator
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)
from io import BytesIO, IOBase


def gcd(a, b):
    if b == 0:

        return a
    else:
        return gcd(b, a % b)


def power(x, p, m):
    res = 1
    while p:
        if p & 1:
            res = (res * x) % m
        x = (x * x) % m
        p >>= 1
    return res


def inar():
    return [int(k) for k in input().split()]


def lcm(num1, num2):
    return (num1 * num2) // gcd(num1, num2)
rr=0
gg=0
bb=0
dp=[]
def func(x,y,z,red,green,blue):
    if (x>=rr and y>=gg) or (y>=gg and z>=bb) or (x>=rr and z>=bb):
        return 0
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    take=0
    if x<rr and y<gg:
        take=max(take,red[x]*green[y]+func(x+1,y+1,z,red,green,blue))
    if y<gg and z<bb:
        take=max(take,green[y]*blue[z]+func(x,y+1,z+1,red,green,blue))
    if x<rr and z<bb:
        take=max(take,red[x]*blue[z]+func(x+1,y,z+1,red,green,blue))
    dp[x][y][z]=take
    return take

def main():
    global rr,gg,bb,dp
    # t=int(input())
    for i in range(202):
        temp=[]
        for j in range(202):
            lis=[]
            for k in range(202):
                lis.append(-1)
            temp.append(lis)
        dp.append(temp)
    rr, gg, bb = map(int, input().split())
    red = inar()
    green = inar()
    blue = inar()
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    print(func(0,0,0,red,green,blue))




BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
    # threadin.Thread(target=main).start()
",6,3
"def solve(x,y,z):
    global r,g,b,ans
    if (x > r - 1 and y > g - 1) or (x > r - 1 and z > b - 1) or (y > g - 1 and z > b - 1):
        return 0
    if memo[x][y][z] != -1:
        return memo[x][y][z]
    mx = 0
    if x < r and y < g: 
        mx = max(mx,ra[x]*ga[y] + solve(x+1,y+1,z))
    if x < r and z < b:
        mx = max(mx,ra[x]*ba[z] + solve(x+1,y,z+1))
    if y < g and z < b:
        mx = max(mx,ga[y]*ba[z] + solve(x,y+1,z+1))
    ans = max(ans,mx)
    memo[x][y][z] = mx
    return mx

r,g,b = map(int,input().split())
ra = sorted(list(map(int,input().split())),reverse = True)
ga = sorted(list(map(int,input().split())),reverse = True)
ba = sorted(list(map(int,input().split())),reverse = True)

memo = [[[-1 for k in range(205)] for i in range(205)] for j in range(205)]

ans = 0

solve(0,0,0)
print(ans)

",6,1
"r,g,b = map(int,input().split())
rs = list(map(int,input().split()))
gs = list(map(int,input().split()))
bs = list(map(int,input().split()))
rs.sort()
gs.sort()
bs.sort()
rs.reverse()
gs.reverse()
bs.reverse()
dp = [[[0]*201 for x in range(201)] for y in range(201)]
for i in range(min(r,g)+1):
    for j in range(min(g,b)+1):
        for k in range(min(b,r)+1):
            options = []
##            if i == 0 and j == 0:
##                dp[i][j][k] = dp[i][j][k-1] + bs[k-1]*rs[k-1]
##                continue
##            elif j == 0 and k == 0:
##                dp[i][j][k] = dp[i-1][j][k] + rs[i-1]*gs[i-1]
##                continue
##            elif i == 0 and k == 0:
##                dp[i][j][k] = dp[i][j-1][k] + gs[j-1]*bs[j-1]
##                continue
            if i == 0:
                pass
            elif i+k-1 < r and i+j-1 < g:
                options.append(dp[i-1][j][k] + rs[i+k-1]*gs[i+j-1])
            else:
                options.append(dp[i-1][j][k])
            if j == 0:
                pass
            elif i+j-1 < g and j+k-1 < b:
                options.append(dp[i][j-1][k] + gs[i+j-1]*bs[j+k-1])
            else:
                options.append(dp[i][j-1][k])
            if k == 0:
                pass
            elif j+k-1 < b and i+k-1 < r:
                options.append(dp[i][j][k-1] + bs[j+k-1]*rs[i+k-1])
            else:
                options.append(dp[i][j][k-1])
            if len(options) == 0:
                continue
            dp[i][j][k] = max(options)
print(dp[min(r,g)][min(g,b)][min(r,b)])           


##rp = r-1
##gp = g-1
##bp = b-1
##ans = 0
##m = min(rs[rp],gs[gp],bs[bp])
##if m == rs[rp] and m == gs[gp]:
##    if rp < gp:
##        ans += bs[bp]*gs[gp]
",6,-100
"c1, c2, c3 = map(int, input().split())
r = sorted(list(map(int, input().split())))
g = sorted(list(map(int, input().split())))
b = sorted(list(map(int, input().split())))
dp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)]
for i in range(c1 + 1):
    for j in range(c2 + 1):
        for k in range(c3 + 1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1])
print(dp[c1][c2][c3])

",6,3
"R, G, B = list(map(lambda x: int(x), input().split()))
r = list(map(lambda x: int(x), input().split()))
g = list(map(lambda x: int(x), input().split()))
b = list(map(lambda x: int(x), input().split()))

def f(t):
    i, j, k = t
    return (i+1)*(G+1)*(B+1) + (j+1)*(B+1) + (k+1)

max_area = [None]*((R+1)*(G+1)*(B+1)+1)

def get_max_area(i, j, k):
    temp = f((i,j,k))
    if max_area[temp] != None:
        return max_area[temp]
    x1=x2=x3=0
    if i >= 0 and j>=0:
        x1 = get_max_area(i-1, j-1, k) + r[i]*g[j]
    if i >= 0 and k >= 0:
        x2 = get_max_area(i-1, j, k-1) + r[i]*b[k]
    if j >= 0 and k >= 0:
        x3 = get_max_area(i, j-1, k-1) + g[j]*b[k]

    max_area[temp] = max(x1, x2, x3)
    return max_area[temp]

r.sort()
g.sort()
b.sort()
print(get_max_area(R-1, G-1, B-1))
#print(max_area)    ",6,1
"import sys
input=sys.stdin.buffer.readline

nr,ng,nb=[int(x) for x in input().split()]
r=[int(x) for x in input().split()]
g=[int(x) for x in input().split()]
b=[int(x) for x in input().split()]

r.sort()
g.sort()
b.sort()

memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]
memo[0][0][0]=0 #starting point when i==-1,j==-1,k==-1
for i in range(nr):
    memo[i+1][0][0]=0
for j in range(ng):
    memo[0][j+1][0]=0
for k in range(nb):
    memo[0][0][k+1]=0
def dp(i,j,k): #dp(i,j,k) is the max value including r[i],g[j],b[k]
    if i<-1 or j<-1 or k<-1:
        return -float('inf')
    if memo[i+1][j+1][k+1]==-1: #offset by 1 because i,j,k can be -1
        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],
                   dp(i-1,j-1,k)+r[i]*g[j],
                   dp(i-1,j,k-1)+r[i]*b[k]
                )
    return memo[i+1][j+1][k+1]

for i in range(max(nr,ng,nb)):
    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))


print(dp(nr-1,ng-1,nb-1))",6,6
"from sys import stdin
import time

r,g,b = map(int,stdin.readline().split())

red = list(map(int,stdin.readline().split()))
green = list(map(int,stdin.readline().split()))
blue = list(map(int,stdin.readline().split()))
red.sort()
green.sort()
blue.sort()

dp = [[[0 for _ in range(b+1)] for _ in range(g+1)] for _ in range(r+1)]

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i>0 and j>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+red[i-1]*green[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+red[i-1]*blue[k-1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+green[j-1]*blue[k-1])

print(dp[-1][-1][-1])                       
",6,3
"

def read_int():
    return int(raw_input().strip())


def read_ints():
    return list(map(int, raw_input().strip().split(' ')))


def solve():
    '''
    8 8 8 8 8 8
    9 9
    9 9

    81+81

    72+72+72+72
    '''
    R, G, B = read_ints()
    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]
    # dp[R][G][B]
    Rs = read_ints()
    Gs = read_ints()
    Bs = read_ints()
    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)
    answer = 0
    for r in range(R+1):
        for g in range(G+1):
            for b in range(B+1):
                if r > 0 and g > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])
                if g > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])
                if r > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])
                answer = max(answer, dp[r][g][b])
    return answer


if __name__ == '__main__':
    print(solve())
",6,3
"#tests = int(input())
#for t in range(tests):
#    b= int(input())
#    ls = [int(x) for x in input()]

r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))


dp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

def recursive(idx_r, idx_g, idx_b):
    if dp[idx_r][idx_g][idx_b] is not None:
        return dp[idx_r][idx_g][idx_b]
    res_1 = 0
    res_2 = 0
    res_3 = 0
    if (idx_r-1) >= 0 and (idx_g-1) >= 0:
        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]
    if (idx_g-1) >= 0 and (idx_b-1) >= 0:
        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]
    if (idx_r-1) >= 0 and (idx_b-1) >= 0:
        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]
    
    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)
    return dp[idx_r][idx_g][idx_b]

print(recursive(r,g,b))",6,1
"import sys,bisect,string,math,time,functools,random,fractions
from heapq import heappush,heappop,heapify
from collections import deque,defaultdict,Counter
from itertools import permutations,combinations,groupby
rep=range;R=range
def Golf():n,*t=map(int,open(0).read().split())
def I():return int(input())
def S_():return input()
def IS():return input().split()
def LS():return [i for i in input().split()]
def MI():return map(int,input().split())
def LI():return [int(i) for i in input().split()]
def LI_():return [int(i)-1 for i in input().split()]
def NI(n):return [int(input()) for i in range(n)]
def NI_(n):return [int(input())-1 for i in range(n)]
def StoLI():return [ord(i)-97 for i in input()]
def ItoS(n):return chr(n+97)
def LtoS(ls):return ''.join([chr(i+97) for i in ls])
def RA():return map(int,open(0).read().split())
def RLI(n=8,a=1,b=10):return [random.randint(a,b)for i in range(n)]
def RI(a=1,b=10):return random.randint(a,b)
def Rtest(T):
    case,err=0,0
    for i in range(T):
        inp=INP()
        a1,ls=naive(*inp)
        a2=solve(*inp)
        if a1!=a2:
            print((a1,a2),inp)
            err+=1
        case+=1
    print('Tested',case,'case with',err,'errors')
def GI(V,E,ls=None,Directed=False,index=1):
    org_inp=[];g=[[] for i in range(V)]
    FromStdin=True if ls==None else False
    for i in range(E):
        if FromStdin:
            inp=LI()
            org_inp.append(inp)
        else:
            inp=ls[i]
        if len(inp)==2:
            a,b=inp;c=1
        else:
            a,b,c=inp
        if index==1:a-=1;b-=1
        aa=(a,c);bb=(b,c);g[a].append(bb)
        if not Directed:g[b].append(aa)
    return g,org_inp
def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1):
    #h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1) # sample usage
    mp=[boundary]*(w+2);found={}
    for i in R(h):
        s=input()
        for char in search:
            if char in s:
                found[char]=((i+1)*(w+2)+s.index(char)+1)
                mp_def[char]=mp_def[replacement_of_found]
        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]
    mp+=[boundary]*(w+2)
    return h+2,w+2,mp,found
def TI(n):return GI(n,n-1)
def accum(ls):
    rt=[0]
    for i in ls:rt+=[rt[-1]+i]
    return rt
def bit_combination(n,base=2):
    rt=[]
    for tb in R(base**n):s=[tb//(base**bt)%base for bt in R(n)];rt+=[s]
    return rt
def gcd(x,y):
    if y==0:return x
    if x%y==0:return y
    while x%y!=0:x,y=y,x%y
    return y
def YN(x):print(['NO','YES'][x])
def Yn(x):print(['No','Yes'][x])
def show(*inp,end='\n'):
    if show_flg:print(*inp,end=end)

mo=10**9+7
inf=float('inf')
FourNb=[(-1,0),(1,0),(0,1),(0,-1)];EightNb=[(-1,0),(1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)];compas=dict(zip('WENS',FourNb));cursol=dict(zip('LRUD',FourNb))
l_alp=string.ascii_lowercase
#sys.setrecursionlimit(10**9)
read=sys.stdin.buffer.read;readline=sys.stdin.buffer.readline;input=lambda:sys.stdin.readline().rstrip()


show_flg=False
show_flg=True

ans=0

#for _ in range(I()):
x,y,z=LI()
R=sorted(LI())[::-1]
G=sorted(LI())[::-1]
B=sorted(LI())[::-1]

dp=[[[0]*(z+1) for j in range(y+1)]for i in range(x+1)]

n=x+y+z
for t in range(0,n+1,2):
    for i in range(x+1):
        for j in range(y+1):
            k=t-i-j
            if 0<=k<=z:
                if i+1<=x and j+1<=y:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
                if i+1<=x and k+1<=z:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
                if j+1<=y and k+1<=z:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])
                #show((i,j,k),dp)
ans=max([dp[i][y][z]for i in range(x+1)])
ans=max(max([dp[x][i][z]for i in range(y+1)]),ans)
ans=max(max([dp[x][y][i]for i in range(z+1)]),ans)

print(ans)


    
    
    
    ",6,5
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort()
g.sort()
b.sort()

dp=[[[0 for i in range(B+1)] for j in range(G+1)] for i in range(R+1)]

for i in range(1,R+1):
    for j in range(1,G+1):
        dp[i][j][0]=dp[i-1][j-1][0]+r[i-1]*g[j-1]

for j in range(1,G+1):
    for k in range(1,B+1):
        dp[0][j][k]=dp[0][j-1][k-1]+b[k-1]*g[j-1]

for i in range(1,R+1):
    for k in range(1,B+1):
        dp[i][0][k]=dp[i-1][0][k-1]+r[i-1]*b[k-1]

for i in range(1,R+1):
    for j in range(1,G+1):
        for k in range(1,B+1):
            if max(r[i-1],g[j-1],b[k-1])==r[i-1]:
                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])
            elif max(r[i-1],g[j-1],b[k-1])==g[j-1]:
                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i][j-1][k-1]+g[j-1]*b[k-1])
            else:
                dp[i][j][k]=max(dp[i][j-1][k-1]+b[k-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])



print(dp[R][G][B])
",6,3
"def solve():
  r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
  for i in range(r+1):
    for j in range(g+1):
      for k in range(b+1):
        if i+j+k<2:continue
        if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
        if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
        if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
  return dp[r][g][b]
print(solve())",6,3
"a,b,c=list(map(int,input().split()))
R=list(map(int,input().split()))
G=list(map(int,input().split()))
B=list(map(int,input().split()))
dp=[[[0 for i in range(201)] for j in range(201)] for k in range(201)]
# print(dp)
R.sort()
G.sort()
B.sort()
for i in range(len(R)+1):
    for j in range(len(G)+1):
        for k in range(len(B)+1):
            if(i and j):
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
            if(j and k):
                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
            if(i and k):
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
print(dp[len(R)][len(G)][len(B)])      ",6,6
"import sys
import math
from math import *
from collections import Counter,defaultdict
from io import BytesIO, IOBase
from collections import deque


def rec(i,j,k):
	if (i == rl and j == bl) or (i == rl and k == gl) or (k == gl and j == bl):
		return 0
	if dp[i][j][k] != -1:
		return dp[i][j][k]
	else:
		x = r[i]*b[j]
		y = b[j]*g[k]
		z = r[i] * g[k]
		if x>0:
			x += rec(i+1,j+1,k)
		if y>0:
			y += rec(i,j+1,k+1)
		if z>0:
			z += rec(i+1,j,k+1)

		dp[i][j][k] = max(x,y,z)
		return dp[i][j][k]

def main():
	global r,g,b,rl,bl,gl,dp

	rl,bl,gl = list(map(int, input().split()))
	r = list(map(int, input().split())) + [0]
	b = list(map(int, input().split())) + [0]
	g = list(map(int, input().split())) + [0]
	cnt =3
	i =j = k = 0
	ans = 0
	dp=[[[-1 for i in range(gl+1)] for j in range(bl+1)]for k in range(rl+1)] 
	r.sort(reverse = True)
	b.sort(reverse = True)
	g.sort(reverse = True)

	print(rec(i,j,k))
	


main()",6,3
"r, g, b = map(int, input().split())
R = list(map(int, input().split()))
G = list(map(int, input().split()))
B = list(map(int, input().split()))
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)

memo = [[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]

def calc(ir, ig, ib):
    if memo[ir][ig][ib] != -1:
        return memo[ir][ig][ib]
    ans = 0
    if ir < r and ig < g:
        ans = max(ans, calc(ir+1, ig+1, ib)+R[ir]*G[ig])
    if ir < r and ib < b:
        ans = max(ans, calc(ir+1, ig, ib+1)+R[ir]*B[ib])
    if ig < g and ib < b:
        ans = max(ans, calc(ir, ig+1, ib+1)+G[ig]*B[ib])
    memo[ir][ig][ib] = ans
    return ans

print(calc(0, 0, 0))
",6,1
"from collections import defaultdict


def main():
    R, G, B = map(int, input().split())
    red = list(map(int, input().split()))
    green = list(map(int, input().split()))
    blue = list(map(int, input().split()))
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    dp = [[[-2*10**9]*(B+10) for i in range(G+10)] for j in range(R+10)]
    dp[0][0][0] = 0
    ans = 0
    for i in range(R+1):
        for j in range(G+1):
            for k in range(B+1):
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+red[i-1]*green[j-1], dp[i]
                                  [j-1][k-1]+green[j-1]*blue[k-1], dp[i-1][j][k-1]+red[i-1]*blue[k-1])
                ans = max(ans, dp[i][j][k])
    print(ans)
    return


if __name__ == ""__main__"":
    main()


",6,3
"r,g,b=map(int,input().split())
s1=[int(x) for x in input().split()]
s2=[int(x) for x in input().split()]
s3=[int(x) for x in input().split()]
s1.sort()
s2.sort()
s3.sort()
s1=s1[::-1]
s2=s2[::-1]
s3=s3[::-1]
s1=[0]+s1
s2=[0]+s2
s3=[0]+s3

dp=[]
for i in range(r+5):
    H=[]
    for j in range(g+5):
        h=[]
        for k in range(b+5):
            h.append(0)
        H.append(h)
    dp.append(H)


for i in range(0,r+1):
    for j in range(0,g+1):
        for k in range(0,b+1):
            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0
            if(i-1>=0 and j-1>=0):
                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])
            if(i-1>=0 and k-1>=0):
                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])
            if(k-1>=0 and j-1>=0):
                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])
            if(i-1>=0):
                t4 = dp[i-1][j][k]
            if(j-1>=0):
                t5 = dp[i][j-1][k]
            if(k-1>=0):
                t6 = dp[i][j][k-1]

            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)

print(dp[r][g][b])

",6,3
"import sys
input = sys.stdin.readline

MAXN = 202

def main():
    R, G, B = list(map(int, input().split()))
    r = list(map(int, input().split()))
    g = list(map(int, input().split()))
    b = list(map(int, input().split()))
    r.sort()
    g.sort()
    b.sort()
    dp = [[[0]*MAXN for _ in range(MAXN)] for _ in range(MAXN)]
    for i in range(1, R+1):
        for j in range(1, G+1):
            dp[i][j][0] = r[i-1]*g[j-1]+dp[i-1][j-1][0]
    for i in range(1, R+1):
        for k in range(1, B+1):
            dp[i][0][k] = r[i-1]*b[k-1]+dp[i-1][0][k-1]
    for j in range(1, G+1):
        for k in range(1, B+1):
            dp[0][j][k] = g[j-1]*b[k-1]+dp[0][j-1][k-1]
    for i in range(1, R+1):
        for j in range(1, G+1):
            for k in range(1, B+1):
                dp[i][j][k] = max(r[i-1]*g[j-1]+dp[i-1][j-1][k], r[i-1]*b[k-1]+dp[i-1][j][k-1], g[j-1]*b[k-1]+dp[i][j-1][k-1])
    print(dp[R][G][B])

main()
",6,5
"from sys import stdin, stdout
import math,sys,heapq
from itertools import permutations, combinations
from collections import defaultdict,deque,OrderedDict
from os import path
import random
import bisect as bi
def yes():print('YES')
def no():print('NO')
if (path.exists('input.txt')): 
    #------------------Sublime--------------------------------------#
    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
    def I():return (int(input()))
    def In():return(map(int,input().split()))
else:
    #------------------PYPY FAst I/o--------------------------------#
    def I():return (int(stdin.readline()))
    def In():return(map(int,stdin.readline().split()))
#sys.setrecursionlimit(1500)
def dict(a):
    d={} 
    for x in a:
        if d.get(x,-1)!=-1:
            d[x]+=1
        else:
            d[x]=1
    return d
def find_gt(a, x):
    'Find leftmost value greater than x'
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:            
        return -1

def cal(r,g,b,dp,R,G,B,nr,ng,nb):
    if dp[r][g][b]!=-1:
        return dp[r][g][b]
    best=0
    if r<nr and g<ng:
        best=max(best,cal(r+1,g+1,b,dp,R,G,B,nr,ng,nb)+R[r]*G[g])
    if r<nr and b<nb:
        best=max(best,cal(r+1,g,b+1,dp,R,G,B,nr,ng,nb)+R[r]*B[b])
    if g<ng and b<nb:
        best=max(best,cal(r,g+1,b+1,dp,R,G,B,nr,ng,nb)+B[b]*G[g])
    dp[r][g][b]=best
    return dp[r][g][b]
def main():
    try:
        nr,ng,nb=In()
        dp=[[[-1 for x in range(201)]for y in range(201)] for z in range(201)]
        R=list(In())
        G=list(In())
        B=list(In())
        R.sort(reverse=True)
        G.sort(reverse=True)
        B.sort(reverse=True)
        print(cal(0,0,0,dp,R,G,B,nr,ng,nb))
    except:
        pass
        
M = 998244353
P = 1000000007
 
if __name__ == '__main__':
    # for _ in range(I()):main()
    for _ in range(1):main()",6,3
"import sys
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
ns = lambda: readline().rstrip()
ni = lambda: int(readline().rstrip())
nm = lambda: map(int, readline().split())
nl = lambda: list(map(int, readline().split()))

r, g, b = nm()
R = nl()
G = nl()
B = nl()
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i==0 and j==0 and k==0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans, dp[i][j][k])
print(ans)",6,3
"from math import *
from collections import *
from random import *
from decimal import Decimal
from heapq import *
from bisect import *
import sys
input=sys.stdin.readline
sys.setrecursionlimit(10**5)
def lis():
    return list(map(int,input().split()))
def ma():
    return map(int,input().split())
def inp():
    return int(input())
def st1():
    return input().rstrip('\n')
t=1
while(t):
    t-=1
    r,g,b=ma()
    rl=lis()
    gl=lis()
    bl=lis()
    rl.sort()
    bl.sort()
    gl.sort()
    dp= [[[0]*(b+1)for i in range(g+1)] for j in range(r+1)]
    for i in range(r+1):
        for j in range(g+1):
            for k in range(b+1):
                if(i+j+k<2):
                    continue
                if(i and j):
                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rl[i-1]*gl[j-1])
                if(j and k):
                    dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gl[j-1]*bl[k-1])
                if(i and k):
                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rl[i-1]*bl[k-1])
    print(dp[r][g][b])
    
        
",6,3
"import os
import heapq
import sys
import math
import operator
from collections import defaultdict
from io import BytesIO, IOBase


""""""def gcd(a,b):
    if b==0:
        return a
    else:
        return gcd(b,a%b)""""""

""""""def pw(a,b):
    result=1
    while(b>0):
        if(b%2==1): result*=a
        a*=a
        b//=2
    return result""""""

def inpt():
    return [int(k) for k in input().split()]

def main():
    n1, n2, n3 = map(int, input().split())
    ar = [int(x) for x in input().split()]
    br = [int(x) for x in input().split()]
    cr = [int(x) for x in input().split()]
    ar.sort()
    br.sort()
    cr.sort()
    dp = [[[0 for x in range(201)] for y in range(201)] for z in range(201)]
    for i in range(n1 + 1):
        for j in range(n2 + 1):
            for k in range(n3 + 1):
                if (i and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + (ar[i - 1] * br[j - 1]))
                if (i and k):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + (ar[i - 1] * cr[k - 1]))
                if (k and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + (cr[k - 1] * br[j - 1]))
    print(dp[n1][n2][n3])


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()

",6,3
"import sys
from math import sqrt, gcd, ceil, log, floor
from bisect import bisect, bisect_left
from collections import defaultdict, Counter, deque
from heapq import heapify, heappush, heappop
input = sys.stdin.readline
read = lambda: list(map(int, input().strip().split()))

MOD = 10**9 + 7


def main():
	# ans_ = []
	# ans_.append(ans)
	# print((""\n"").join(map(str, ans_)))
	r, g, b = read()
	r_ar=sorted(read(), reverse = True); g_ar = sorted(read(), reverse = True); b_ar = sorted(read(), reverse = True)
	N = 201
	dp = [[[-1]*N for i in range(N)]for j in range(N)]
	# for i in dp:print(*i)
	def f(x, y, z):
		# print(x, y, z, (x >= r) + (y >= g) + (z >= b))
		if ((x >= r) + (y >= g) + (z >= b)) >= 2:
			return(0)
		if dp[x][y][z] != -1:
			return(dp[x][y][z])
		maxi = 0
		if x < r and y < g:
			maxi = max(maxi, r_ar[x]*g_ar[y] + f(x+1, y+1, z))
		if z < b and y < g:
			maxi = max(maxi, b_ar[z]*g_ar[y] + f(x, y+1, z+1))
		if x < r and z < b:
			maxi = max(maxi, r_ar[x]*b_ar[z] + f(x+1, y, z+1))
		dp[x][y][z] = maxi
		return(maxi)
	print(f(0, 0, 0))





if __name__ == ""__main__"":
	main()",6,3
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]
 
DP = [0] * ((R+1) * (G+1) * (B+1))
def idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b
 
for r in range(R+1):
	for g in range(G+1):
		for b in range(B+1):
			best = 0
 
			if r:
				if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
				if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])
 
			if g and b:
				best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])
 
			DP[idx(r, g, b)] = best
 
print(max(DP))",6,3
"#!/usr/bin/env python3
import sys
input = sys.stdin.readline
import heapq

R, G, B = map(int, input().split())
r = [int(item) for item in input().split()]
g = [int(item) for item in input().split()]
b = [int(item) for item in input().split()]
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
nr = len(r)
ng = len(g)
nb = len(b)

dp = [[[0] * (nb+1) for _ in range(ng+1)] for _ in range(nr+1)]
ans = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if (i + j + k) % 2 == 1:
                continue
            if i > 0 and j > 0:
                # Make RG
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + r[i-1] * g[j-1])
            if j > 0 and k > 0:
                # Make GB
                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1] + g[j-1] * b[k-1])
            if i > 0 and k > 0:
                # Make BR
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1] + b[k-1] * r[i-1])
            ans = max(ans, dp[i][j][k])

print(ans)",6,3
"def solve(rn,gn,bn,r,g,b):
    r = sorted(r,reverse=True)
    g = sorted(g, reverse=True)
    b = sorted(b, reverse=True)

    dp = [[[0 for k in range(bn+1)] for j in range(gn+1)] for i in range(rn+1)]


    ans = 0
    for i in range(rn+1):
        for j in range(gn+1):
            for k in range(bn+1):
                if i < rn and j < gn:
                    dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
                if i < rn and k < bn:
                    dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
                if j < gn and k <bn:
                    dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])

                ans = max(ans,dp[i][j][k])

    print(ans)






if __name__ == '__main__':
    rn, gn, bn = map(int,input().split())

    r = list(map(int,input().split()))
    g = list(map(int, input().split()))
    b = list(map(int, input().split()))

    solve(rn,gn,bn,r,g,b)",6,3
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]
DP = [0] * ((R+1) * (G+1) * (B+1))

def idx(r, g, b):
  return r * (G+1) * (B+1) + g * (B+1) + b

for r in range(R+1):
  for g in range(G+1):
    for b in range(B+1):
      best = 0
      if r:
        if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
        if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])
      if g and b:
        best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])
      DP[idx(r, g, b)] = best
print(max(DP))
",6,3
"r,g,b=map(int,input().split())
R=list(map(int,input().split()))
R.sort()
G=list(map(int,input().split()))
G.sort()
B=list(map(int,input().split()))
B.sort()
dp=[[[0]*(b+1) for i in range(g+1)] for j in range(r+1)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])
print(dp[r][g][b])",6,3
"def solve():
	r,g,b=map(int,input().split())
	R=list(map(int,input().split()))
	G=list(map(int,input().split()))
	B=list(map(int,input().split()))
	R.sort(reverse=True)
	G.sort(reverse=True)
	B.sort(reverse=True)
	dp=[[[0]*(b+1) for _ in range(g+1)]for _ in range(r+1)]
	for i in range(r+1):
		for j in range(g+1):
			for k in range(b+1):
				if i<r and j<g:
					dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
				if i<r and k<b:
					dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
				if j<g and k<b:
					dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+B[k]*G[j])
	ans=0
	for i in range(r+1):
		for j in range(g+1):
			for k in range(b+1):
				ans=max(ans,dp[i][j][k])
	return ans
print(solve())",6,3
"n, m, v = map(lambda x: int(x) + 1, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
dp = []
for i in range(n):
    dp.append([])
    for j in range(m):
        dp[i].append([0] * v)
a.sort(reverse=1)
b.sort(reverse=1)
c.sort(reverse=1)
a = [0] + a
b = [0] + b
c = [0] + c
ans = 0
for i in range(n):
    for j in range(m):
        for k in range(v):
            if i == j == k == 0:
                continue
            if i == j == 0 or i == k == 0 or j == k == 0:
                continue
            if i == 0:
                dp[i][j][k] = dp[i][j - 1][k - 1] + \
                              b[j] * c[k]
            elif j == 0:
                dp[i][j][k] = dp[i - 1][j][k - 1] + \
                              a[i] * c[k]
            elif k == 0:
                dp[i][j][k] = dp[i - 1][j - 1][k] + \
                              a[i] * b[j]
            else:
                dp[i][j][k] = max(dp[i - 1][j - 1][k] + a[i] * b[j],
                                  dp[i - 1][j][k - 1] + a[i] * c[k],
                                  dp[i][j - 1][k - 1] + b[j] * c[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",6,-100
"#!/usr/bin/env python3
import io
import os
import sys

input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

def prdbg(*args, **kwargs):
    print(*args, **kwargs)
    pass

def get_str():
    return input().decode().strip()

def rint():
    return map(int, input().split())

def oint():
    return int(input())

def valid(i1,i2,i3):
    if (i1+i2+i3)%2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2\
            or i2 > i1 + i3 or i1 > i2 + i3:
        return False
    return True

def dfs(i1,i2,i3):
    #if not valid(i1, i2, i3):
    if (i1 + i2 + i3) % 2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2 \
                or i2 > i1 + i3 or i1 > i2 + i3:
        return -2
    if dp[i1][i2][i3] != -1:
        return dp[i1][i2][i3]
    ret1 = dfs(i1-1, i2-1, i3)
    if ret1 >= 0 :
        ret1 += a1[i1]*a2[i2]
    ret2 = dfs(i1-1, i2, i3-1)
    if ret2 >= 0:
        ret2 += a1[i1]*a3[i3]
    ret3 = dfs(i1, i2-1, i3-1)
    if ret3 >= 0:
        ret3 += a2[i2]*a3[i3]
    ret = max(ret1, ret2, ret3)
    dp[i1][i2][i3] = ret
    return ret

n1, n2, n3 = rint()
a1, a2, a3 = list(rint()), list(rint()), list(rint())
a1.sort(reverse=True)
a2.sort(reverse=True)
a3.sort(reverse=True)
a1 = [0] + a1
a2 = [0] + a2
a3 = [0] + a3
n1 += 1
n2 += 1
n3 += 1

dp = [[[-1 for i3 in range(n3)] for i2 in range(n2)] for i1 in range(n1)]
dp[1][1][0] = a1[1]*a2[1]
dp[1][0][1] = a1[1]*a3[1]
dp[0][1][1] = a2[1]*a3[1]
dp[0][0][0] = -2

for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            dfs(i1, i2, i3)
ans = -1
for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            ans = max(ans, dp[i1][i2][i3])
#print(a1,a2,a3)
print(ans)
",6,1
"def getArray():
    return list(map(int, input().split()))
def createDP(R, G, B):
    dp = []
    for i in range(R):
        temp1 = []
        for j in range(G):
            temp2 = []
            for k in range(B):
                temp2.append(-1)
            temp1.append(temp2)
        dp.append(temp1)
    return dp
def go(r, g, b, R, G, B, ri, gi, bi, state):
    if state[ri][gi][bi] != -1 :
        return state[ri][gi][bi]
    best = 0
    if ri < R and gi < G:
        best = max(best, r[ri]*g[gi] + go(r, g, b, R, G, B, ri+1, gi+1, bi, state))
    if ri < R and bi < B:
        best = max(best, r[ri]*b[bi] + go(r, g, b, R, G, B, ri+1, gi, bi+1, state))
    if gi < G and bi < B:
        best = max(best, g[gi]*b[bi] + go(r, g, b, R, G, B, ri, gi+1, bi+1, state))
    
    state[ri][gi][bi] = best
    return best
    
R,G,B = map(int, input().split())
r = getArray()
g = getArray()
b = getArray()
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = createDP(201,201,201)
print(go(r, g, b, R, G, B, 0, 0, 0, dp))",6,6
"import sys

input = sys.stdin.readline

r, g, b = map(int, input().split())
sticks, dp, ans = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)], [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 # dp[i][j][k] is i largest red, j largest green, k largest blue

for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            ans = max(ans, dp[i][j][k])
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])
print(ans)
",6,3
"import pprint
nr, ng, nb = map(int, input().split())
*r, = map(int, input().split())
*g, = map(int, input().split())
*b, = map(int, input().split())
dp = []
for _ in range(nr + 1):
    dp.append([[0] * (nb + 1) for _ in range(ng + 1)])

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

mx = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if i and j:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            if i and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])
            if j and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])


mx_i = mx_j = mx_k = -1

for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if dp[i][j][k] > mx:
                mx_i = i
                mx_j = j
                mx_k = k
                mx = dp[i][j][k]

print(mx)
",6,3
"R,G,B=list(map(int,input().split()))
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp = [[[0 for i in range(B + 1)] for j in range(G + 1)] for k in range(R + 1)]
ans=0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],r[i]*g[j]+dp[i][j][k])
            if i<R and k<B:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],r[i]*b[k]+dp[i][j][k])
            if k<B and j<G:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],b[k]*g[j]+dp[i][j][k])
            ans=max(ans,dp[i][j][k])
print(ans)",6,3
"r,g,b=map(int,input().split())
rs=sorted(list(map(int,input().split())))
gs=sorted(list(map(int,input().split())))
bs=sorted(list(map(int,input().split())))
dp=[[[0 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
ans=0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i>0 and k>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rs[i-1]*bs[k-1])
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rs[i-1]*gs[j-1])
            if j>0 and k>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gs[j-1]*bs[k-1])
            ans=max(ans,dp[i][j][k])
print(ans)
",6,3
"# for #!/usr/bin/env python
import os
import sys
from io import BytesIO, IOBase


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion
class union_find:
    def __init__(self, n):
        self.n = n
        self.rank = [0]*n
        self.parent = [int(j) for j in range(n)]
    
    def union(self,i,j):
        i = self.find(i)
        j = self.find(j)
        if self.rank[i] == self.rank[j]:
            self.parent[i] = j
            self.rank[j] += 1

        elif self.rank[i] > self.rank[j]:
            self.parent[j] = i
        else:
            self.parent[i] = j

    def find(self, i):
        temp = i
        if self.parent[temp] != temp:
            self.parent[temp] = self.find(self.parent[temp])
        return self.parent[temp]
from math import log2, ceil
from collections import deque, Counter as CC, defaultdict as dd
def main():
# Enter your code here. Read input from STDIN. Print output to STDOUT
    # for t in range(int(input())):
        
        # n = int(input())
        p,q,r  = [int(j) for j in input().split()]
        a = [int(j) for j in input().split()]
        b = [int(j) for j in input().split()]
        c = [int(j) for j in input().split()]
        a.sort()
        b.sort()
        c.sort()
        l = [a,b,c]

        dp = [[[0 for i in range(r+1)] for j in range(q+1)] for k in range(p+1)]
        for i in range(p+1):
            for j in range(q+1):
                for k in range(r+1):
                    s = [i-1,j-1,k-1]
                    for u in range(3):
                        
                        s[u]+=1
                        try:
                            tmp = dp[s[0]][s[1]][s[2]]
                        except:
                            s[u]-=1
                            continue
                        tmp2 = 1
                        flag =True
                        for t in range(3):
                            if(u!=t):
                                if(s[t]==-1):
                                    flag = False
                                    break
                                tmp2 *= l[t][s[t]] 
                        tmp += tmp2
                        s[u]-=1
                        if(flag):
                            dp[i][j][k] = max(dp[i][j][k], tmp)
        print(dp[p][q][r])











        



if __name__ == ""__main__"":
    main()",6,5
"R,G,B = list(map(int, input().split()))
r = sorted(list(map(int, input().split())), reverse =True)
g = sorted(list(map(int, input().split())), reverse =True)
b = sorted(list(map(int, input().split())), reverse =True)
def f(x,y,z):
    m1 = 0
    m2 = 0
    m3 = 0
    if(x<R and y<G):
        if(dpt[x+1][y+1][z]==-1):
            dpt[x+1][y+1][z] = f(x+1,y+1,z)
        m1 = r[x]*g[y] + dpt[x+1][y+1][z]
    if(y<G and z<B):
        if(dpt[x][y+1][z+1]==-1):
            dpt[x][y+1][z+1] = f(x,y+1,z+1)
        m2 = g[y]*b[z] + dpt[x][y+1][z+1]
    if(z<B and x<R):
        if(dpt[x+1][y][z+1]==-1):
            dpt[x+1][y][z+1] = f(x+1,y,z+1)
        m3 = r[x]*b[z] + dpt[x+1][y][z+1]
    dpt[x][y][z] = max(m1,m2,m3)
    return dpt[x][y][z]
dpt = [[[-1 for _ in range(B+1)]for _ in range(G+1)]for _ in range(R+1)]
print(f(0,0,0))",6,3
"def solve(r, g, b, rs, gs, bs):
    rs.sort(reverse=True)
    gs.sort(reverse=True)
    bs.sort(reverse=True)
    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
    sol = 0
    for ri in range(r+1):
        for gi in range(g+1):
            for bi in range(b+1):
                if ri < r and gi < g:
                    dp[ri+1][gi+1][bi] = max(dp[ri+1][gi+1][bi], rs[ri]*gs[gi] + dp[ri][gi][bi])
                if ri < r and bi < b:
                    dp[ri+1][gi][bi+1] = max(dp[ri+1][gi][bi+1], rs[ri]*bs[bi] + dp[ri][gi][bi])
                if gi < g and bi < b:
                    dp[ri][gi+1][bi+1] = max(dp[ri][gi+1][bi+1], gs[gi]*bs[bi] + dp[ri][gi][bi])
                sol = max(sol, dp[ri][gi][bi])
    return sol

r, g, b = map(int, input().split())
rs = list(map(int, input().split()))
gs = list(map(int, input().split()))
bs = list(map(int, input().split()))
print(solve(r, g, b, rs, gs, bs))",6,3
"R,G,B = map(int,input().split())
r = list(map(int,input().split()))
g = list(map(int,input().split()))
b = list(map(int,input().split()))
r.sort()
g.sort()
b.sort()
dp = []
for i in range(R+1):
	d = []
	for j in range(G+1):
		d.append([0]*(B+1))
	dp.append(d)
for i in range(R+1):
	for j in range(G+1):
		for k in range(B+1):
			if i+j+k<2:
				continue
			if i>0 and j>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
			if i>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+r[i-1]*b[k-1])
			if j>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])

",6,3
"# import sys
# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            x0 = (dp[i-1][j-1][k] + u[0][i-1]*u[1][j-1]) if i and j else 0
            x1 = (dp[i][j-1][k-1] + u[1][j-1]*u[2][k-1]) if j and k else 0
            x2 = (dp[i-1][j][k-1] + u[0][i-1]*u[2][k-1]) if i and k else 0
            dp[i][j][k] = max(x0, x1, x2)
            res = max(res, dp[i][j][k])
print(res)",6,3
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]


def dp(r1, g1, b1):
    if mem[r1][g1][b1] != -1:
        return mem[r1][g1][b1]

    v1, v2, v3 = 0, 0, 0

    if r1 < r:
        if g1 < g:
            v1 = (ar[r1] * ag[g1]) + dp(r1 + 1, g1 + 1, b1)
        if b1 < b:
            v2 = (ar[r1] * ab[b1]) + dp(r1 + 1, g1, b1 + 1)

    if g1 < g and b1 < b:
        v3 = (ag[g1] * ab[b1]) + dp(r1, g1 + 1, b1 + 1)

    mem[r1][g1][b1] = max(v1, v2, v3)

    return mem[r1][g1][b1]


r, g, b = rints()
ar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]
mem = [[[-1 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]
print(dp(0, 0, 0))
",6,3
"R,G,B = map(int,input().split())
r = sorted(list(map(int,input().split())), reverse=True)
g = sorted(list(map(int,input().split())), reverse=True)
b = sorted(list(map(int,input().split())), reverse=True)

dp = [[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]
ans = 0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if j*k > 0:
                dp[i][j][k] = max(dp[i][j-1][k-1]+g[j-1]*b[k-1],dp[i][j][k])
            if i*k > 0:
                dp[i][j][k] = max(dp[i-1][j][k-1]+r[i-1]*b[k-1],dp[i][j][k])
            if i*j > 0:
                dp[i][j][k] = max(dp[i-1][j-1][k]+g[j-1]*r[i-1],dp[i][j][k])
            ans = max(ans,dp[i][j][k])
print(ans)",6,3
"import os
import sys
import math
import heapq
from decimal import *
from io import BytesIO, IOBase
from collections import defaultdict, deque

def r():
    return int(input())
def rm():
    return map(int,input().split())
def rl():
    return list(map(int,input().split()))

r,g,b = rm()
R = rl()
G = rl()
B = rl()
R.sort()
G.sort()
B.sort()
dp = [[[0]*(b+1) for j in range(g+1)] for i in range(r+1)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i and j:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+R[i-1]*G[j-1])
            if j and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+G[j-1]*B[k-1])
            if k and i:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+B[k-1]*R[i-1])
print(dp[r][g][b])",6,3
"#tests = int(input())
#for t in range(tests):
#    b= int(input())
#    ls = [int(x) for x in input()]

r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))


dp = [[[-1 for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

def recursive(idx_r, idx_g, idx_b):
    if dp[idx_r][idx_g][idx_b] != -1:
        return dp[idx_r][idx_g][idx_b]
    res_1 = 0
    res_2 = 0
    res_3 = 0
    if (idx_r-1) >= 0 and (idx_g-1) >= 0:
        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]
    if (idx_g-1) >= 0 and (idx_b-1) >= 0:
        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]
    if (idx_r-1) >= 0 and (idx_b-1) >= 0:
        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]
    
    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)
    return dp[idx_r][idx_g][idx_b]

print(recursive(r,g,b))",6,1
"import math
import time
from collections import defaultdict,deque,Counter
from sys import stdin,stdout
from bisect import bisect_left,bisect_right
from queue import PriorityQueue 
import sys
t=1
# t=int(input())
for _ in range(t):
    r,g,b=map(int,stdin.readline().split())
    ra=list(map(int,stdin.readline().split()))
    ga=list(map(int,stdin.readline().split()))
    ba=list(map(int,stdin.readline().split()))
    ra.sort()
    ga.sort()
    ba.sort()
    dp=[[[0]*201 for _ in range(201)]for _ in range(201)]
    for i in range(r+1):
        for j in range(g+1):
            for k in range(b+1):
                if(i and j>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+ra[i-1]*ga[j-1])
                if(i and k>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+ra[i-1]*ba[k-1])
                if(k and j>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+ga[j-1]*ba[k-1])
    print(dp[r][g][b])
",6,5
"import sys
from array import array  # noqa: F401
import typing as Tp  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def output(*args):
    sys.stdout.buffer.write(
        ('\n'.join(map(str, args)) + '\n').encode('utf-8')
    )


def main():
    R, G, B = map(int, input().split())
    r_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]
    g_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]
    b_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]

    dp = [[[0.0] * (B + 2) for _ in range(G + 2)] for _ in range(R + 2)]

    for ri in range(R + 1):
        for gi in range(G + 1):
            for bi in range(B + 1):
                dp[ri + 1][gi + 1][bi] = max(dp[ri + 1][gi + 1][bi], dp[ri][gi][bi] + r_sticks[ri] * g_sticks[gi])
                dp[ri + 1][gi][bi + 1] = max(dp[ri + 1][gi][bi + 1], dp[ri][gi][bi] + r_sticks[ri] * b_sticks[bi])
                dp[ri][gi + 1][bi + 1] = max(dp[ri][gi + 1][bi + 1], dp[ri][gi][bi] + g_sticks[gi] * b_sticks[bi])

    ans = max(max(max(dp[r][g][b] for b in range(B + 1)) for g in range(G + 1)) for r in range(R + 1))
    print(int(ans + 1e-6))


if __name__ == '__main__':
    main()
",6,3
"r, g, b = map(int, input().split(' '))
R = list(map(int, input().split(' ')))
G = list(map(int, input().split(' ')))
B = list(map(int, input().split(' ')))
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i == 0 and j == 0 and k == 0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans,dp[i][j][k])
print(ans)",6,3
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]

r, g, b = rints()
ar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]
mem = [[[0 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]
ans = 0

for r1 in range(r + 1):
    for g1 in range(g + 1):
        for b1 in range(b + 1):
            if r1 < r:
                if g1 < g:
                    mem[r1 + 1][g1 + 1][b1] = max(mem[r1 + 1][g1 + 1][b1], (ar[r1] * ag[g1]) + mem[r1][g1][b1])
                if b1 < b:
                    mem[r1 + 1][g1][b1 + 1] = max(mem[r1 + 1][g1][b1 + 1], (ar[r1] * ab[b1]) + mem[r1][g1][b1])

            if g1 < g and b1 < b:
                mem[r1][g1 + 1][b1 + 1] = max(mem[r1][g1 + 1][b1 + 1], (ag[g1] * ab[b1]) + mem[r1][g1][b1])

            ans = max(ans, mem[r1][g1][b1])

print(ans)",6,3
"
r,g,b = map(int,input().split())
l1 = list(map(int,input().split()))
l2 = list(map(int,input().split()))
l3 = list(map(int,input().split()))
l1.sort(reverse=True)
l2.sort(reverse=True)
l3.sort(reverse=True)
dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]
ans = 0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i == 0 and j == 0:
                dp[i][j][k] = 0
            if j == 0 and k == 0:
                dp[i][j][k] = 0
            if i == 0 and k == 0:
                dp[i][j][k] = 0
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])
            else:
                if i>0 and j>0:
                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]
                elif i>0 and k>0:
                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]
                elif j>0 and k>0:
                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]
            ans = max(ans,dp[i][j][k])
                    
print(ans)
                                   
                
            
",6,3
"# import io.os
# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
def func(n1,n2,n3):
    global r,g,b 
    if((n1<0 and n2<0) or (n3<0 and n2<0) or (n1<0 and n3<0) ):
        return 0 
    if(n1<0):
        return g[n2]*b[n3] + func(n1,n2-1,n3-1)
    if(n2<0):
        return r[n1]*b[n3] + func(n1-1,n2,n3-1)
    if(n3<0):
        return g[n2]*r[n1] + func(n1-1,n2-1,n3)
    if(dp[n1][n2][n3]==-1):
        dp[n1][n2][n3]= max(g[n2]*b[n3] + func(n1,n2-1,n3-1),r[n1]*b[n3] + func(n1-1,n2,n3-1),g[n2]*r[n1] + func(n1-1,n2-1,n3))
    return dp[n1][n2][n3]

# def func(n1,n2,n3):
#     for i in range(n1):
#         for j in range(n2):
#             for k in range(n3):
#                 if(i==0 and j==0 and k==0):
#                     dp[i][j][k] = max(r[i]*g[j],g[j]*b[k],b[k]*r[i])
#                 elif(i==0 and j==0):
#                     dp[i][j][k]=max(g[j]*b[k] + dp[i][j-1][k-1],r[i]*b[k] + dp[i-1][j][k-1],g[j]*r[i] + dp[i-1][j-1][k])
#                 dp[i][j][k]=max(g[j]*b[k] + dp[i][j-1][k-1],r[i]*b[k] + dp[i-1][j][k-1],g[j]*r[i] + dp[i-1][j-1][k])

R,G,B=tuple(map(int,input().split()))
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r=sorted(r)
g=sorted(g)
b=sorted(b)
prefix1=[0]*R 
prefix2 = [0]*G 
prefix3 = [0]*B 
prefix1[0]=r[0]
prefix2[0] = g[0]
prefix3[0]=b[0]
dp=[[[-1 for i in range(B)] for j in range(G)]for k in range(R)]
# for i in range(1,R):
#     prefix1[i]=prefix1[i-1]*r[i]
# for i in range(1,G):
#     prefix2[i]=prefix2[i-1]*g[i]
# for i in range(1,B):
#     prefix3[i]=prefix3[i-1]*b[i]
print(func(R-1,G-1,B-1))",6,-100
"def solve(i, j, k):
    if dp[i][j][k]!=-1:
        return dp[i][j][k]
    call = 0
    if i>0 and j>0:
        call = max(call, R[i]*G[j]+solve(i-1, j-1, k))
    if j>0 and k>0:
        call = max(call, G[j]*B[k]+solve(i, j-1, k-1))
    if k>0 and i>0:
        call = max(call, B[k]*R[i]+solve(i-1, j, k-1))
    dp[i][j][k] = call
    return call


nr, ng, nb = map(int,input().split())
R = [0]+list(map(int,input().split()))
G = [0]+list(map(int,input().split()))
B = [0]+list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1]*(nb+1) for j in range(ng+1)] for i in range(nr+1)]
ans = solve(nr, ng, nb)
print(ans)",6,3
"# import sys
# sys.stdin = open('CF_E93_D2/input.txt', 'r') 
# sys.stdout = open('CF_E93_D2/output.txt', 'w')
#----------------------------------------------------------------

r,g,b = list(map(int,input().split()))
dp = [ [ [-1]*(b+1) for i in range(g+1) ] for j in range(r+1) ]
ra = sorted(list(map(int,input().split())),reverse=True)
ga = sorted(list(map(int,input().split())),reverse=True)
ba = sorted(list(map(int,input().split())),reverse=True)

def solve(i,j,k) :
    
    if dp[i][j][k] != -1 :
        return dp[i][j][k]

    if i==r :
        if j==g or k==b :
            return 0
        dp[i][j][k] = ga[j] * ba[k] + solve(i,j+1,k+1)

    elif j==g :
        if i==r or k==b:
            return 0
        dp[i][j][k] = ra[i] * ba[k] + solve(i+1,j,k+1)
        
    elif k==b :
        if j==g or i==r:
            return 0
        dp[i][j][k] = ga[j] * ra[i] + solve(i+1,j+1,k)
    
    else :
        dp[i][j][k] = max(ra[i]*ga[j] + solve(i+1,j+1,k),ra[i]*ba[k] + solve(i+1,j,k+1),ba[k]*ga[j] + solve(i,j+1,k+1))

    return dp[i][j][k]


print(solve(0,0,0))",6,1
"from sys import stdin
from array import array
def recSolve(dp,r,g,b,rx,gx,bx, R, G, B):
	if rx == R:
		return sum(a * b for a, b in zip(g[gx:], b[bx:]))
	if gx == G:
		return sum(a * b for a, b in zip(r[rx:], b[bx:]))
	if bx == B:
		return sum(a * b for a, b in zip(g[gx:], r[rx:]))
	if dp[rx * G * B + gx * B + bx] != -1:
		return dp[rx * G * B + gx * B + bx]
	rg = recSolve(dp, r, g, b, rx + 1, gx + 1, bx, R, G, B) + r[rx] * g[gx]
	bg = recSolve(dp, r, g, b, rx, gx + 1, bx + 1, R, G, B) + b[bx] * g[gx]
	rb = recSolve(dp, r, g, b, rx + 1, gx, bx + 1, R, G, B) + r[rx] * b[bx]
	ans = max(rg, bg, rb)
	dp[rx * G * B + gx * B + bx] = ans
	return ans
input = stdin.readline
R, G, B = map(int, input().split())
r = sorted([*map(int, input().split())], reverse = True)
g = sorted([*map(int, input().split())], reverse = True) 
b = sorted([*map(int, input().split())], reverse = True) 
dp = array('q', (-1 for x in range(R * G * B)))
print(recSolve(dp, r, g, b, 0, 0, 0, R, G, B))",6,6
"R, G, B = list(map(int, input().split()))
r = [int(x) for x in input().split()]
r.sort(reverse=True)
g = [int(x) for x in input().split()]
g.sort(reverse=True)
b = [int(x) for x in input().split()]
b.sort(reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",6,3
"r,g,b = map(int,input().split())
R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
def solve(r,g,b):
	if ((r==0 and g==0) or (g==0 and b==0) or (b==0 and r==0)):
		return 0
	if dp[r][g][b]==-1:
		if r==0:
			ans =  G[g-1]*B[b-1]+solve(r,g-1,b-1)
		elif g==0:
			ans =  R[r-1]*B[b-1]+solve(r-1,g,b-1)
		elif b==0:
			ans =  G[g-1]*R[r-1]+solve(r-1,g-1,b)
		else:
			ans =  max(G[g-1]*B[b-1]+solve(r,g-1,b-1),G[g-1]*R[r-1]+solve(r-1,g-1,b),R[r-1]*B[b-1]+solve(r-1,g,b-1))
		dp[r][g][b] = ans
	return dp[r][g][b]
ans = solve(r,g,b)
print(ans)",6,1
"from sys import stdin
input=lambda : stdin.readline().strip()
lin=lambda :list(map(int,input().split()))
iin=lambda :int(input())
main=lambda :map(int,input().split())
from math import ceil,sqrt,factorial,log
from collections import deque
from bisect import bisect_left
def gcd(a,b):
	a,b=max(a,b),min(a,b)
	while a%b!=0:
		a,b=b,a%b
	return b
def solve():
	a,b,c=main()
	x,y,z=lin(),lin(),lin()
	x.sort(reverse=True)
	y.sort(reverse=True)
	z.sort(reverse=True)
	ans=0
	dp=[[[0 for i in range(c+2)] for i in range(b+2)] for i in range(a+1)]
	for i in range(a+1):
		for j in range(b+1):
			for k in range(c+1):
				if i<a and j<b:
					dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+x[i]*y[j])
				if i<a and k<c:
					dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+x[i]*z[k])
				if k<c and j<b:
					dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+z[k]*y[j])
				ans=max(ans,dp[i][j][k])
	print(ans)
qwe=1
# qwe=int(input())
for _ in range(qwe):
	solve()

",6,3
"#dt = {} for i in x: dt[i] = dt.get(i,0)+1
import sys;input = sys.stdin.readline
inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]

r,g,b = ip()
R = [0]+ip()
G = [0]+ip()
B = [0]+ip()
R.sort()
G.sort()
B.sort()
dp = [[[0]*201 for i in range(201)] for j in range(201)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            x = dp[i-1][j-1][k] + R[i]*G[j] if i*j else 0
            y = dp[i][j-1][k-1] + G[j]*B[k] if j*k else 0
            z = dp[i-1][j][k-1] + R[i]*B[k] if i*k else 0
            dp[i][j][k] = max(dp[i][j][k],x,y,z)
print(dp[r][g][b])
#print(dp)
    
    
",6,3
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])
",6,3
"import io
import os

from collections import Counter, defaultdict, deque


def solveBFS(NR, NG, NB, R, G, B):
    def pack(i, j, k):
        return i * 256 * 256 + j * 256 + k

    def unpack(ijk):
        i, jk = divmod(ijk, 256 * 256)
        j, k = divmod(jk, 256)
        return i, j, k

    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)
    dp = [0 for i in range(256 ** 3)]
    q = deque([0])
    while q:
        ijk = q.popleft()
        d = dp[ijk]
        i, j, k = unpack(ijk)

        if i < NR:
            r = R[i]

        if j < NG:
            g = G[j]
        if k < NB:
            b = B[k]
        if i + 1 <= NR and j + 1 <= NG:
            rg = pack(i + 1, j + 1, k)
            dp[rg] = max(dp[rg], r * g + d)
            q.append(rg)

        if i + 1 <= NR and k + 1 <= NB:
            rb = pack(i + 1, j, k + 1)
            dp[rb] = max(dp[rb], r * b + d)
            q.append(rb)

        if j + 1 <= NG and k + 1 <= NB:
            gb = pack(i, j + 1, k + 1)
            dp[gb] = max(dp[gb], g * b + d)
            q.append(gb)

    return max(dp)


def solve(NR, NG, NB, R, G, B):
    assert NR == len(R)
    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)

    R += [0]
    G += [0]
    B += [0]

    NR1 = NR + 2
    NG1 = NG + 2
    NB1 = NB + 2
    dp = [0 for i in range((NR1) * (NG1) * (NB1))]

    def pack(i, j, k):
        return i * NG1 * NB1 + j * NB1 + k

    inf = float(""inf"")
    for i in range(NR + 1):
        for j in range(NG + 1):
            dp[pack(i, j, -1)] = -inf
    for i in range(NR + 1):
        for k in range(NB + 1):
            dp[pack(i, -1, k)] = -inf

    for j in range(NG + 1):
        for k in range(NB + 1):
            dp[pack(-1, j, k)] = -inf

    for l in range(2, NR + NG + NB + 1, 2):
        for j in range(NG + 1):
            for k in range(NB + 1):
                i = l - j - k
                if i < 0 or i > NR:
                    continue
                r = R[i - 1]
                g = G[j - 1]
                b = B[k - 1]
                dp[pack(i, j, k)] = max(
                    r * g + dp[pack(i - 1, j - 1, k)],
                    r * b + dp[pack(i - 1, j, k - 1)],
                    b * g + dp[pack(i, j - 1, k - 1)],
                )

    return max(dp)


if False:
    import random

    random.seed()
    N = 5
    for t in range(100):
        R = [random.randint(1, 10) for i in range(random.randint(1, N))]
        G = [random.randint(1, 10) for i in range(random.randint(1, N))]
        B = [random.randint(1, 10) for i in range(random.randint(1, N))]
        ans1 = solveBFS(len(R), len(G), len(B), R, G, B)
        ans2 = solve(len(R), len(G), len(B), R, G, B)
        if ans1 != ans2:
            print(ans1, ans2)
            print(R, G, B)
        exit()
if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    NR, NG, NB = [int(x) for x in input().split()]
    R = [int(x) for x in input().split()]
    G = [int(x) for x in input().split()]
    B = [int(x) for x in input().split()]
    ans = solve(NR, NG, NB, R, G, B)
    print(ans)

",6,3
"from collections import defaultdict
from sys import setrecursionlimit,stdin
input=stdin.readline
setrecursionlimit(100000)

def dfs(r,g,b,rr,gg,bb):
    if r<0 or g<0 or b<0:
        return 0
    x=0
    y=0
    z=0
    
    if dp[r][g][b]!=-1:
        return dp[r][g][b]
    if r!=0 and g!=0:
        x=rr[r-1]*gg[g-1]+dfs(r-1,g-1,b,rr,gg,bb)
    if r!=0 and b!=0:
        y=rr[r-1]*bb[b-1]+dfs(r-1,g,b-1,rr,gg,bb)
    if b!=0 and g!=0:
        z=bb[b-1]*gg[g-1]+dfs(r,g-1,b-1,rr,gg,bb)
    dp[r][g][b]=max(x,y,z)
    return max(x,y,z)

r,g,b=map(int,input().split())
rr=list(map(int,input().split()))
gg=list(map(int,input().split()))
bb=list(map(int,input().split()))
rr.sort()
gg.sort()
bb.sort()
dp=[[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]

print(dfs(r,g,b,rr,gg,bb))





",6,3
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
##########################################################
from collections import Counter
# c=sorted((i,int(val))for i,val in enumerate(input().split()))
import heapq
# c=sorted((i,int(val))for i,val in enumerate(input().split()))
# n = int(input())
# ls = list(map(int, input().split()))
# n, k = map(int, input().split())
# n =int(input())
#arr=[(i,x) for i,x in enum]
#arr.sort(key=lambda x:x[0])
#print(arr)
# e=list(map(int, input().split()))
from collections import Counter
#print(""\n"".join(ls))
#print(os.path.commonprefix(ls[0:2]))
#n=int(input())
from bisect import  bisect_right
#for _ in range(int(input())):
#n=int(input())
#arr = list(map(int, input().split()))
#for _ in range(int(input())):
#n, k = map(int, input().split())
import bisect
#n=int(input())
#n, p,q,r = map(int, input().split())
#arr = list(map(int, input().split()))
#n=int(input())
#nm,k = map(int, input().split())
#for _ in range(int(input())):
def find(x,y,z):
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    ans=0
    if x<r and y<g:
        ans=max(ans,rl[x]*gl[y]+find(x+1,y+1,z))
    if x<r and z<b:
        ans=max(ans,rl[x]*bl[z]+find(x+1,y,z+1))
    if y<g and z<b:
        ans=max(ans,gl[y]*bl[z]+find(x,y+1,z+1))

    dp[x][y][z]=ans
    return ans
r,g,b = map(int, input().split())
rl=sorted(list(map(int, input().split())),reverse=True)
gl=sorted(list(map(int, input().split())),reverse=True)
bl=sorted(list(map(int, input().split())),reverse=True)
dp=[[[-1]*(b+1) for i in range(g+1)]for i in range(r+1)]
print(find(0,0,0))

",6,6
"r, g, b = map(int, input().split())
a = [[], [], []]
dp = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)]
for x in range(3):
    a[x] = sorted([int(x) for x in input().split()])
odp = 0
for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
            odp = max(odp, dp[i][j][k])
print(odp)",6,3
"import heapq


def read_int():
    return int(input().strip())


def read_ints():
    return list(map(int, input().strip().split(' ')))


def solve():
    '''
    8 8 8 8 8 8
    9 9
    9 9

    81+81

    72+72+72+72
    '''
    R, G, B = read_ints()
    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]
    # dp[R][G][B]
    Rs = read_ints()
    Gs = read_ints()
    Bs = read_ints()
    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)
    answer = 0
    for r in range(R+1):
        for g in range(G+1):
            for b in range(B+1):
                if r > 0 and g > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])
                if g > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])
                if r > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])
                answer = max(answer, dp[r][g][b])
    return answer


if __name__ == '__main__':
    print(solve())
",6,3
"from sys import stdin, gettrace

if gettrace():
    inputi = input
else:
    def input():
        return next(stdin)[:-1]


    def inputi():
        return stdin.buffer.readline()


def main():
    r, g, b = map(int, inputi().split())
    rr = list(sorted(int(a) for a in inputi().split()))
    gg = list(sorted(int(a) for a in inputi().split()))
    bb = list(sorted(int(a) for a in inputi().split()))
    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
    res = 0
    for i in range(r, -1, -1):
        for j in range(g, -1, -1):
            for k in range(b, -1, -1):
                if i > 0 and j > 0:
                    dp[i-1][j-1][k] = max(dp[i-1][j-1][k], dp[i][j][k] + rr[i-1]*gg[j-1])
                if i > 0 and k > 0:
                    dp[i-1][j][k-1] = max(dp[i-1][j][k-1], dp[i][j][k] + rr[i-1]*bb[k-1])
                if j > 0 and k > 0:
                    dp[i][j-1][k-1] = max(dp[i][j-1][k-1], dp[i][j][k] + gg[j-1]*bb[k-1])
                res = max(res, dp[i-1][j-1][k], dp[i-1][j][k-1] , dp[i][j-1][k-1])
    print(res)


if __name__ == ""__main__"":
    main()
",6,6
"from collections import deque
from collections import OrderedDict
import math
 
import sys
import os
import threading
import bisect
 
import operator
 
import heapq
 
 
from atexit import register
from io import BytesIO
 
#sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
#sys.stdout = BytesIO()
#register(lambda: os.write(1, sys.stdout.getvalue()))
 
 
import io
#input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
#sys.stdin = open(""F:\PY\\test.txt"", ""r"")
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#input = sys.stdin.readline

#a = [int(x) for x in input().split()]




r,g,b = map(int, input().split())
a = []
for i in range(3):
    a.append([int(x) for x in input().split()])
    a[i].sort(reverse=True)

dp = [[[0 for i in range(205)] for j in range(205)] for k in range(205)]
answer = 0

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k], dp[i][j][k]+a[0][i]*a[1][j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1], dp[i][j][k]+a[0][i]*a[2][k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1], dp[i][j][k]+a[1][j]*a[2][k])
            answer=max(answer, dp[i][j][k])
print(answer)
    



sys.exit(0)





class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person(""heelo"", 27)

print(help(Person))


age = 26
name = 'Swaroop'
print('Возрас {} -- {} лет'.format(name, age))
print(help(object))


'''
for _ in range(int(input())):
    
    n = int(input())
    ar = list(map(int, input().split()))
    dp = [0]*100005
    for i in range(n):
        dp[ar[i]]+=1
    ar.clear()
    for i in range(len(dp)):
        if dp[i]!=0:
            ar.append(dp[i])       
    ar.sort()
    maxC = ar[len(ar)-1]
    sumA = sum(ar)
    answer=0
    for i in range(len(ar)):
        if ar[i]==maxC:
            answer+=1
            sumA-=maxC
    answer-=1
    answer+= min(sumA//(maxC-1), len(ar)-1)
    print(answer)
    #sys.exit(0)   
         
    




def maxDisjointIntervals(list_):
    list_.sort(key=lambda x: x[1])
    print(list_[0][0], list_[0][1])
    r1 = list_[0][1]
    for i in range(1, len(list_)):
        l1 = list_[i][0]
        r2 = list_[i][1]
        if l1>r1:
            print(l1, r2)
            r1 = r2

if __name__ ==""__main__1"":
    N=4
    intervals = [[1, 4], [2, 3], [4,6], [8,9]]
    maxDisjointIntervals(intervals)
    
    '''
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    ",6,3
"r,g,b = map(int,input().split())
R = sorted([*map(int,input().split())],reverse=True)
G= sorted([*map(int,input().split())],reverse=True)
B = sorted([*map(int,input().split())],reverse=True)
mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]
def dp(i,j,k):
    p = (i==r)+(j==g)+(k==b)
    if(p>1):
        return 0
    if(mem[i][j][k]!=-1):
        return mem[i][j][k]
    ans = 0
    if(i==r):
        ans = dp(i,j+1,k+1)+G[j]*B[k]
        return ans
    elif(j==g):
        ans = dp(i+1,j,k+1)+R[i]*B[k]
    elif(k==b):
        ans = dp(i+1,j+1,k)+R[i]*G[j]
    else:
        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])
    mem[i][j][k] = ans
    return ans
print(dp(0,0,0))",6,1
"import sys
input = sys.stdin.readline
 
rr, gg, bb = map(int, input().split())
inf = 114514
r = list(map(int, input().split())) + [inf]
g = list(map(int, input().split())) + [inf]
b = list(map(int, input().split())) + [inf]
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = []
for _ in range(rr + 1):
    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])
ans = 0
for i in range(rr + 1):
    ri = r[i]
    for j in range(gg + 1):
        gj = g[j]
        for k in range(bb + 1):
            bk = b[k]
            if (i + j + k) % 2:
                continue
            dpijk = 0
            if i > 0 and j > 0:
                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)
            if j > 0 and k > 0:
                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)
            if k > 0 and i > 0:
                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)
            dp[i][j][k] = dpijk
            if ans < dpijk:
                ans = dpijk
print(ans)",6,3
"import os, sys
from io import BytesIO, IOBase
from math import log2, ceil, sqrt, gcd
from _collections import deque
import heapq as hp
from bisect import bisect_left, bisect_right

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
mod = 10 ** 9 + 7

R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp=[[[0]*(B+1) for _ in range(G+1)] for __ in range(R+1)]
ans=0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1],
                                  dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1],
                                  dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            elif i>0 and j>0:
                dp[i][j][k] =dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1]
            elif i>0 and k>0:
                dp[i][j][k] = dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1]
                ans = max(ans, dp[i][j][k])
            elif j>0 and k>0:
                dp[i][j][k]=dp[i][j-1][k-1]+g[j-1]*b[k-1]
            ans=max(ans,dp[i][j][k])
# for i in dp:
#     print(i)
print(ans)




",6,3
"R, G, B = list(map(int, input().split()))
r = sorted([int(x) for x in input().split()], reverse=True)
g = sorted([int(x) for x in input().split()], reverse=True)
b = sorted([int(x) for x in input().split()], reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",6,3
"import sys

sys.setrecursionlimit(10 ** 5)
int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

rn,gn,bn=MI()
rr=LI()
gg=LI()
bb=LI()
rr.sort(reverse=True)
gg.sort(reverse=True)
bb.sort(reverse=True)
dp=[[[-1]*(bn+1) for _ in range(gn+1)] for _ in range(rn+1)]
dp[0][0][0]=0
ans=0
for i in range(rn+1):
    for j in range(gn+1):
        for k in range(bn+1):
            pre=dp[i][j][k]
            if pre==-1:continue
            ans=max(ans,pre)
            if i<rn and j<gn:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],pre+rr[i]*gg[j])
            if i<rn and k<bn:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],pre+rr[i]*bb[k])
            if j<gn and k<bn:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],pre+gg[j]*bb[k])

print(ans)
",6,3
"#greedy is wrong due to the constraint ki do alag se uthenge, so youd also want to keep 2 ppl above 0

#yeh dp se hoga, clear hai

import sys

def input():
	return sys.stdin.readline().rstrip()

def input_split():
	return [int(i) for i in input().split()]

# testCases = int(input())
# answers = []
# for _ in range(testCases):
	#take input
x, y, z  = input_split()
arr_x = input_split()
arr_y = input_split()
arr_z = input_split()

x += 1
y += 1
z += 1

lengths = [x,y, z]
arrs = [arr_x, arr_y, arr_z ]

for a in arrs:
	a.sort()
	# a.reverse()

dp = [[[0 for k in range(z)] for j in range(y)] for i in range(x)]

for i in range(1,x):
	for j in range(1,y):
		# if i!= 0 and j!= 0:
		dp[i][j][0] = dp[i-1][j-1][0] + arr_x[i-1]*arr_y[j-1]

for j in range(1, y):
	for k in range(1, z):
		# if j!= 0 and k!= 0:
		dp[0][j][k] = dp[0][j-1][k-1] + arr_y[j-1]*arr_z[k-1]
			
for i in range(1,x):
	for k in range(1,z):
		# if i!= 0 and k!= 0:
		dp[i][0][k] = dp[i-1][0][k-1] + arr_x[i-1]*arr_z[k-1]

for i in range(1, x):
	for j in range(1, y):
		for k in range(1, z):
			opt1 = dp[i-1][j-1][k] + arr_x[i-1]*arr_y[j-1]
			opt2 = dp[i][j-1][k-1] + arr_y[j-1]*arr_z[k-1]
			opt3 = dp[i-1][j][k-1] + arr_x[i-1]*arr_z[k-1]
			# opt2 = d
			dp[i][j][k] = max(opt1, opt2, opt3)

ans = dp[x-1][y-1][z-1]
# used_x = 0
# used_y = 0
# used_z = 0
# used = [used_x, used_y, used_z]
# while(True):
# 	poss = []
# 	for i in range(3):
# 		if used[i] < lengths[i]:
# 			poss.append((arrs[i][used[i]], i))

# 	if len(poss) <= 1:
# 		break

# 	else:
# 		poss.sort()
# 		v1, t1 = poss[-1]
# 		v2, t2 = poss[-2]

# 		ans += v1*v2
# 		used[t1] += 1
# 		used[t2] += 1

print(ans)	
# answers.append(ans)

# print(*answers, sep = '\n')
",6,1
"import sys
input = sys.stdin.readline

rr, gg, bb = map(int, input().split())
inf = 114514
r = list(map(int, input().split())) + [inf]
g = list(map(int, input().split())) + [inf]
b = list(map(int, input().split())) + [inf]
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = []
for _ in range(rr + 1):
    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])
ans = 0
for i in range(rr + 1):
    ri = r[i]
    for j in range(gg + 1):
        gj = g[j]
        for k in range(bb + 1):
            bk = b[k]
            if (i + j + k) % 2:
                continue
            dpijk = 0
            if i > 0 and j > 0:
                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)
            if j > 0 and k > 0:
                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)
            if k > 0 and i > 0:
                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)
            dp[i][j][k] = dpijk
            if ans < dpijk:
                ans = dpijk
print(ans)",6,3
"from sys import stdin
inp = lambda : stdin.readline().strip()

nr, ng, nb = [int(x) for x in inp().split()]

r = [int(x) for x in inp().split()]
g = [int(x) for x in inp().split()]
b = [int(x) for x in inp().split()]
r.sort()
g.sort()
b.sort()
dp = [[[0 for _ in range(201)] for _ in range(201)] for _ in range(201)]
for i in range(nr+1):
    for j in range(ng+1):
        for k in range(nb+1):
            if i and j:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1]);
            if i and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1]);
            if j and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1]);
 
print(dp[nr][ng][nb])",6,3
"n, m, q = map(int, input().split())
a = sorted(map(int, input().split()), reverse=True)
b = sorted(map(int, input().split()), reverse=True)
c = sorted(map(int, input().split()), reverse=True)
dp = [[[0] * 201 for _ in range(201)] for _ in range(201)]
for ijk in range(n + m + q + 1):
    for i in range(min(n + 1, ijk + 1)):
        for j in range(min(m + 1, ijk - i + 1)):
            k = ijk - i - j
            if k < 0 or k > q:
                continue
            if i + 1 <= n:
                dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k])
            if j + 1 <= m:
                dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k])
            if k + 1 <= q:
                dp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k])
            if i + 1 <= n and j + 1 <= m:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[i] * b[j])
            if i + 1 <= n and k + 1 <= q:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[i] * c[k])
            if j + 1 <= m and k + 1 <= q:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + b[j] * c[k])
print(dp[n][m][q])",6,3
"def f(l,r,g,b,op):
    if (r==0 and g==0) or (r==0 and b==0) or (b==0 and g==0):
        return 0
    else:
        if op[r][g][b]!=-1:
            return op[r][g][b]
        if r==0:
           op[r][g][b]=l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op)
           return op[r][g][b]
        if g==0:
           op[r][g][b]=l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op)
           return op[r][g][b]
        if b==0:
         op[r][g][b]=l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op)
         return op[r][g][b]
        op[r][g][b]=max(l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op),l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op),l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op))  
        return op[r][g][b]   

r,g,b=list(map(int,input().split()))
l=[]
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
op=[[[-1 for i in range(b+1)]for j in range(g+1)]for k in range(r+1)]
#print(op)
print(f(l,r,g,b,op))
",6,3
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans)",6,3
"# Author: S Mahesh Raju
# Username: maheshraju2020
# Date: 19/08/2020

from sys import stdin, stdout, setrecursionlimit
from math import gcd, ceil, sqrt
from collections import Counter, deque
from bisect import bisect_left, bisect_right
ii1 = lambda: int(stdin.readline().strip())
is1 = lambda: stdin.readline().strip()
iia = lambda: list(map(int, stdin.readline().strip().split()))
isa = lambda: stdin.readline().strip().split()
setrecursionlimit(100000)
mod = 1000000007

R, G, B = iia()
r, g, b = sorted(iia()), sorted(iia()), sorted(iia())
dp = [[[0 for i in range(B + 1)] \
    for j in range(G + 1)] for k in range(R + 1)]

for i in range(R + 1):
    for j in range(G + 1):
        for k in range(B + 1):
            if i > 0 and j > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            if i > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])
            if j > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])
print(dp[-1][-1][-1])
",6,3
"import sys as _sys


_sys.setrecursionlimit(2**14)


_cache = dict()


class _SortedSeqs:

    def __init__(self, seqs):
        self.seqs = tuple(tuple(sorted(seq)) for seq in seqs)

    def __hash__(self):
        return id(self)


def compute_max_area(r_seq, g_seq, b_seq):
    sorted_seqs_obj = _SortedSeqs((r_seq, g_seq, b_seq))
    seqs_sizes = tuple(map(len, sorted_seqs_obj.seqs))
    return _compute_max_area(sorted_seqs_obj, seqs_sizes)


def _compute_max_area(sorted_seqs_obj, seqs_sizes):
    cache_key = (sorted_seqs_obj, seqs_sizes)
    if cache_key in _cache.keys():
        return _cache[cache_key]

    seqs = sorted_seqs_obj.seqs
    nonempty_seqs_n = _how_many_nonempty(seqs_sizes)

    if nonempty_seqs_n < 2:
        ab_seqs_indices_list = []
    
    elif nonempty_seqs_n == 2:
        ab_seqs_indices = [i for i, seq_size in enumerate(seqs_sizes) if seq_size > 0]
        ab_seqs_indices_list = [ab_seqs_indices]
    
    else:
        assert nonempty_seqs_n == 3
        seqs_indices_sorted_by_size = [
            i for i, seq in sorted(
                enumerate(seqs),
                key=lambda pair: (pair[1][seqs_sizes[pair[0]]-1], seqs_sizes[pair[0]])
            )
        ]
        ab_seqs_indices_1 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[0]
        ab_seqs_indices_2 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[1]
        ab_seqs_indices_list = [ab_seqs_indices_1, ab_seqs_indices_2]
    
    max_areas_variants = []
    for a_seq_index, b_seq_index in ab_seqs_indices_list:
        a_seq_last = seqs[a_seq_index][seqs_sizes[a_seq_index]-1]
        b_seq_last = seqs[b_seq_index][seqs_sizes[b_seq_index]-1]
        new_seqs_sizes = list(seqs_sizes)
        new_seqs_sizes[a_seq_index] -= 1
        new_seqs_sizes[b_seq_index] -= 1
        max_area = _compute_max_area(sorted_seqs_obj, tuple(new_seqs_sizes))
        max_area += a_seq_last * b_seq_last
        max_areas_variants.append(max_area)

    max_area = max(max_areas_variants, default=0)

    _cache[cache_key] = max_area
    return max_area


def _how_many_nonempty(seqs_sizes):
    return len([size for size in seqs_sizes if size > 0])


def main():
    r_n, g_n, b_n = map(int, input().split())
    r_seq = tuple(map(int, input().split()))
    g_seq = tuple(map(int, input().split()))
    b_seq = tuple(map(int, input().split()))
    result = compute_max_area(r_seq, g_seq, b_seq)
    print(result)


if __name__ == '__main__':
    main()
",6,1
"#import sys
#input = sys.stdin.readline
def main():
    R, G, B = map( int, input().split())
    Rs = list( map( int, input().split()))
    Gs = list( map( int, input().split()))
    Bs = list( map( int, input().split()))

    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)

    dp = [[[0]*(B+1) for _ in range(G+1)] for _ in range(R+1)]
    ans = 0
    for i in range(R+1):
        for j in range(G+1):
            for k in range(B+1):
                t = 0
                if i > 0 and j > 0:
                    if dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1] > t:
                        t = dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1]
                if j > 0 and k > 0:
                    if dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1] > t:
                        t = dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1]
                if k > 0 and i > 0:
                    if dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1] > t:
                        t = dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1]
                dp[i][j][k] = t
                if ans < t:
                    ans = t
    print(ans)
                        

if __name__ == '__main__':
    main()
",6,3
"import sys
# sys.setrecursionlimit(10**6) 
input=sys.stdin.readline
def  f(r,g,b,n,m,k):
    # s=str(n)+""_""+str(m)+""_""+str(k)
    # print(n,m,k)
    if((n>=1 and m>=1) or (k>=1 and m>=1) or(n>=1 and k>=1)):
        # print(n,m,k,""zzz"")
        a1=mat[n][m][k]
        if(a1!=-1):
            return a1
        else:
            a1=0
            b1=0
            c1=0
            # print(n,m,k)
            if(n>=1 and m>=1):
          
                a1=r[n-1]*g[m-1] + f(r,g,b,n-1,m-1,k)
            if(k>=1 and m>=1):
                b1=b[k-1]*g[m-1] + f(r,g,b,n,m-1,k-1)
            if(n>=1 and k>=1):
                c1=r[n-1]*b[k-1] + f(r,g,b,n-1,m,k-1)
            # if(n>=0 and m>=0 and k>=0):
            mat[n][m][k]=max(a1,b1)
            mat[n][m][k]=max(mat[n][m][k],c1)
            # print(d[s])
            return mat[n][m][k]
    return 0


n,m,k=list(map(int,input().split("" "")))
mat=[[[-1 for i in range(k+1)] for j in range(m+1)]for z in range(n+1)]
# print(mat)
r=list(map(int,input().split("" "")))
g=list(map(int,input().split("" "")))
b=list(map(int,input().split("" "")))
r.sort()
g.sort()
b.sort()
# print(r,g,b)
d={}
print(f(r,g,b,n,m,k))",6,1
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
# State- dp[i][j][k] represents max value after choosing i elements from r, j elements from g, k elements from b
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])
",6,3
"R,G,B = map(int,input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
area = 0
r.sort(reverse=True)
b.sort(reverse=True)
g.sort(reverse=True)
L = max(len(r),len(g),len(b))
dp = [[[0]*(B+1) for i in range(G+1)]for j in range(R+1)]
# print(dp[r][g][b])
tr = 0
tg = 0
tb = 0
for i in range(R+1):
	for j in range(G+1):
		for k in range(B+1):
			if i>0 and j>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
			if j>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
			if i>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
			area = max(area,dp[i][j][k])
print(area)",6,3
"import sys
input = sys.stdin.readline

a,b,c = list(map(int,input().split()))

x = list(map(int,input().split()))
y = list(map(int,input().split()))
z = list(map(int,input().split()))

x.sort(reverse=True)
y.sort(reverse=True)
z.sort(reverse=True)

a+=1
b+=1
c+=1

x = [0] + x
y = [0] + y
z = [0] + z

tmp = [[0]*c for _ in range(b)]
best = [tmp for _ in range(a)]

#print(tmp)
#print(best)
ans = 0

for i in range(a):
    for j in range(b):
        for k in range(c):
            if (i+j+k) % 2 == 0:
                aa,bb,cc = 0,0,0
                if i>0 and j>0:
                    aa = best[i-1][j-1][k] + x[i] * y[j]
                if i>0 and k>0:
                    bb = best[i-1][j][k-1] + x[i] * z[k]
                if j>0 and k>0:
                    cc = best[i][j-1][k-1] + y[j] * z[k]
                
                best[i][j][k] = max(aa,bb,cc)
                ans = max(ans, best[i][j][k])
#print(best)
print(ans)
",6,-100
"c1, c2, c3 = map(int, input().split())
r = sorted(list(map(int, input().split())))
g = sorted(list(map(int, input().split())))
b = sorted(list(map(int, input().split())))
dp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)]
for i in range(c1 + 1):
    for j in range(c2 + 1):
        for k in range(c3 + 1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1])
print(dp[c1][c2][c3])
 ",6,3
"# @author --> ajaymodi
# optimized approach with memoization (dp)
import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""output.out"",""w"")

input=lambda : sys.stdin.readline().strip()
char = [chr(i) for i in range(97,123)]
CHAR = [chr(i) for i in range(65,91)]
mp = lambda:list(map(int,input().split()))
INT = lambda:int(input())
rn = lambda:range(INT())


from math import ceil,sqrt,factorial,gcd

r,g,b = mp()
rl = sorted(mp(),reverse=True)
gl = sorted(mp(),reverse=True)
bl = sorted(mp(),reverse=True)

def solve(i,j,k):
	if dp_table[i][j][k] != -1:
		return dp_table[i][j][k]
 
	if i < r and j < g and k < b:
		m = max(solve(i+1,j+1,k)+(rl[i]*gl[j]), solve(i+1,j,k+1)+(rl[i]*bl[k]), solve(i,j+1,k+1)+(gl[j]*bl[k]))
		dp_table[i][j][k] = m
		return m
 
	elif i < r and j < g:
		m = solve(i+1,j+1,b) + rl[i]*gl[j]
		dp_table[i][j][k] = m
		return m
 
	elif i < r and k < b:
		m = solve(i+1,g,k+1) + (rl[i]*bl[k])	
		dp_table[i][j][k] = m
		return m
 
	elif j < g and k < b:
		m = solve(r,j+1,k+1) + (gl[j]*bl[k])
		dp_table[i][j][k] = m
		return m
	else:
		return 0

dp_table = [[[-1]*(b+1) for j in range(g+1)] for k in range(r+1)]
res = solve(0,0,0)
print(res)
",6,3
"import sys
input = sys.stdin.readline

r, g, b, = [int(_) for _ in input().split()]
R = [int(_) for _ in input().split()]
G = [int(_) for _ in input().split()]
B = [int(_) for _ in input().split()]
R = sorted(R, reverse=True)
G = sorted(G, reverse=True)
B = sorted(B, reverse=True)

dp = []  # best score so far after picking (iR, jG, kB)
for i in range(r+1):
    sdp = [[0]*(b+1) for _ in range(g+1)]
    dp.append(sdp)

answer = 0
for nb_taken in range(r+g+b):
    if nb_taken % 2:
        continue
    # print('nb_taken', nb_taken)
    for i in range(nb_taken+1):
        if i > r:
            break
        for j in range(nb_taken-i-b, nb_taken-i+1):
            if j > g:
                break
            k = nb_taken-i-j
            if k > b:
                continue
            if i+j < k or i+k < j or j+k < i:
                continue
            # assert i+j+k == nb_taken
            # print('in dp', i, j, k)
# for i in range(r):
    # for j in range(g):
        # for k in range(b):
            if i < r and j < g:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + R[i]*G[j])
                # print('setting dp', i+1, j+1, k, dp[i+1][j+1][k])
                answer = max(answer, dp[i+1][j+1][k])
            if i < r and k < b:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + R[i]*B[k])
                # print('setting dp', i+1, j, k+1, dp[i+1][j][k+1])
                answer = max(answer, dp[i+1][j][k+1])
            if j < g and k < b:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + G[j]*B[k])
                # print('setting dp', i, j+1, k+1, dp[i][j+1][k+1])
                answer = max(answer, dp[i][j+1][k+1])
# print(dp)
print(answer)

# k > b <=> nb_taken-i-j >= b <=> j <= nb_taken-i-b
",6,6
"def cal(r,g,b):
	if dp[r][g][b]!=-1:
		return dp[r][g][b]
	ans=0
	if r<R and g<G:
		ans=max(ans,rl[r]*gl[g]+cal(r+1,g+1,b))
	if r<R and b<B:
		ans=max(ans,rl[r]*bl[b]+cal(r+1,g,b+1))
	if g<G and b<B:
		ans=max(ans,gl[g]*bl[b]+cal(r,g+1,b+1))
	dp[r][g][b]=ans
	return ans

R,G,B=map(int,input().split())
rl=sorted(list(map(int,input().split())),reverse=True)
gl=sorted(list(map(int,input().split())),reverse=True)
bl=sorted(list(map(int,input().split())),reverse=True)
dp=[[[-1 for j in range(B+1)] for i in range(G+1)] for i in range(R+1)]
print(cal(0,0,0))",6,3
"# ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------- fast io --------------------
from math import gcd, ceil

def pre(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi


def prod(a):
    ans = 1
    for each in a:
        ans = (ans * each)
    return ans

def lcm(a, b): return a * b // gcd(a, b)


def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y


for _ in range(int(input()) if not True else 1):
    r, g, b = map(int, input().split())
    #a, b = map(int, input().split())
    #c, d = map(int, input().split())
    rr = list(map(int, input().split()))
    gg = list(map(int, input().split()))
    bb = list(map(int, input().split()))
    #s = input()
    dp = [[[0]*(b+1) for __ in range(g+1)] for ___ in range(r+1)]
    def f(a):return sorted(a,reverse=True)
    rr,gg,bb=f(rr),f(gg),f(bb)
    ans=0
    r+=1
    g+=1
    b+=1
    for i in range(r):
        for j in range(g):
            for k in range(b):
                try:dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k] + rr[i]*gg[j])
                except:pass
                try:dp[i][j+1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + gg[j]*bb[k])
                except:pass
                try:dp[i+1][j][k+1] = max(dp[i+1][j][k+1],dp[i][j][k] + rr[i]*bb[k])
                except:pass
                ans=max(ans,dp[i][j][k])
    print(ans)",6,6
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split())) 
r.sort(reverse=True) 
g.sort(reverse=True) 
b.sort(reverse=True) 
#print(r,g,b)
dp=[[[-1 for i in range(205)] for j in range(205)] for k in range(205)]
def recurser(x,y,z):
    if (x>=R and y>=G) or (y>=G and z>=B) or (z>=B and x>=R):
        return 0 
    if dp[x][y][z]!=-1:
        return dp[x][y][z] 
    maxi=0 
    if x<R and y<G:
        maxi=max(maxi,r[x]*g[y]+recurser(x+1,y+1,z)) 
    if y<G and z<B:
        maxi=max(maxi,g[y]*b[z]+recurser(x,y+1,z+1)) 
    if z<B and x<R:
        maxi=max(maxi,r[x]*b[z]+recurser(x+1,y,z+1))
    dp[x][y][z]=maxi
    return maxi 
print(recurser(0,0,0)) ",6,1
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]
def calc(nr,ng,nb):
  if dp[nr][ng][nb]!=-1:
    return dp[nr][ng][nb]
  res=0
  if nr<R and ng<G:
    res=max(res,calc(nr+1,ng+1,nb)+r[nr]*g[ng])
  if nr<R and nb<B:
    res=max(res,calc(nr+1,ng,nb+1)+r[nr]*b[nb])
  if ng<G and nb<B:
    res=max(res,calc(nr,ng+1,nb+1)+g[ng]*b[nb])
  dp[nr][ng][nb]=res
  return res
print(calc(0,0,0))",6,1
"from collections import defaultdict
import sys
input = sys.stdin.readline
n = int(input())
a = map(int, input().split())
mod = 998244353
d = defaultdict(int)
for x in a:
    d[x] += 1
d[0] = 0
b = list(d.items())
b.sort()
m = len(b)
ba = [0] * m
cn = [0] * (m + 1)
k = h = 0
for i, x in enumerate(b):
    while h < m and x[0] >= b[h][0] * 2:
        h += 1
    ba[i] = h - 1
    while k < m and x[0] * 2 > b[k][0]:
        k += 1
    cn[k] += x[1]
for i in range(m):
    cn[i+1] += cn[i]
dp = [0] * m
dp[0] = 1
b = [x[1] for x in b]
for i in range(n):
    ndp = [0] * m
    for j in range(1, m):
        if cn[j] >= i - 1:
            ndp[j] = dp[j] * (cn[j] - i + 1) % mod
        dp[j] += dp[j-1]
        if dp[j] >= mod:
            dp[j] -= mod
    for j in range(1, m):
        ndp[j] += dp[ba[j]] * b[j]
        ndp[j] %= mod
    dp = ndp
print(sum(dp) % mod)",6,-100
"from collections import Counter
import sys
input = sys.stdin.readline
n = int(input())
a = map(int, input().split())
mod = 998244353
d = Counter(a)
d[0] = 0
b = list(d.items())
b.sort()
m = len(b)
ba = [0] * m
cn = [0] * (m + 1)
k = h = 0
for i, x in enumerate(b):
    while h < m and x[0] >= b[h][0] * 2:
        h += 1
    ba[i] = h - 1
    while k < m and x[0] * 2 > b[k][0]:
        k += 1
    cn[k] += x[1]
for i in range(m):
    cn[i+1] += cn[i]
dp = [0] * m
dp[0] = 1
b = [x[1] for x in b]
for i in range(n):
    ndp = [0] * m
    for j in range(1, m):
        if cn[j] >= i - 1:
            ndp[j] = dp[j] * (cn[j] - i + 1) % mod
        dp[j] += dp[j-1]
        if dp[j] >= mod:
            dp[j] -= mod
    for j in range(1, m):
        ndp[j] += dp[ba[j]] * b[j]
        ndp[j] %= mod
    dp = ndp
print(sum(dp) % mod)",6,-100
"from collections import Counter
import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int, input().split()))
mod = 998244353
a.sort()
dp = [1] + [0] * n
for i in range(1, n + 1):
    x, pt = 1, i - 2
    while pt >= 0 and 2 * a[pt] > a[i - 1]:
        x = x * (n - pt - 2) % mod
        pt -= 1
    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod
print(dp[-1])",6,5
"import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int, input().split()))
mod = 998244353
a.sort()
dp = [1] + [0] * n
for i in range(1, n + 1):
    x, pt = 1, i - 2
    while pt >= 0 and 2 * a[pt] > a[i - 1]:
        x = x * (n - pt - 2) % mod
        pt -= 1
    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod
print(dp[-1])",6,5
"M = 998244353 
n = int(input())
l = sorted(map(int, input().split()))[::-1]
out = [0] * n
big = 0
if l[0] >= 2 * l[1]:
    out[1] = 1
    big = 1
for i in range(2, n):
    new = [0] * n
    bigN = 0
    for j in range(i):
        if l[j] >= 2 * l[i]:
            big += out[j]
        else:
            new[j] += out[j] * (i - 1)
            new[j] %= M
    
    new[i] = big
    bigN = (i * big) % M 
        
    out = new
    big = bigN
print((big + sum(out))%M)",6,5
"mod = 998244353
eps = 10**-9


def main():
    import sys
    input = sys.stdin.readline

    N = int(input())
    A = list(map(int, input().split())) + [0]
    A.sort()

    dp = [[0] * (i+1) for i in range(N+1)]
    dp[0][0] = 1
    l = 0
    for i in range(1, N+1):
        for ll in range(l+1, i):
            if A[ll] * 2 <= A[i]:
                l = ll
            else:
                break
        for j in range(1, l+2):
            dp[i][j] = (dp[l][j-1] + (dp[i][j-1] * (l-j+2))%mod)%mod
        for j in range(i):
            dp[i][j] = (dp[i-1][j] + dp[i][j])%mod
    print(dp[-1][-1])


if __name__ == '__main__':
    main()
",6,5
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    alst = [int(input()) for _ in range(n)]
    ans = []
    for a in alst:
        if a == 1:
            ans.append(""1"")
            print(""."".join(ans))
            continue
        while ans and int(ans[-1]) != a - 1:
            ans.pop()
        if not ans:
            ans.append(str(a))
        else:
            ans.pop()
            ans.append(str(a))
        
        print(""."".join(ans))
        
    
for _ in range(int(input())):
    main()",5,6
