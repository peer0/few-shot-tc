src,ground_truth,predicted_tc
"

import java.io.*;

import java.util.*;





public class c {



	static boolean used[][];

	static int n;

	static int m;

	static int a[][];

	

	

	public static void main(String args[])throws Exception{

		Scanner in =new Scanner(new File(""input.txt""));//System.in);//

		PrintWriter out=new PrintWriter(new File(""output.txt""));//System.out);//

		n = in.nextInt();

		m = in.nextInt();

		int k = in.nextInt();

		//a=new int[n+1][m+1];

		/*for (int i = 1; i<=n; i++)

			for (int j = 1; j<=m; j++)

				a[i][j] = 40001;

		*/

		int x[]=new int[k];

		int y[]=new int[k];

		for (int i = 0; i<k; i++){

			x[i] = in.nextInt();

			y[i] = in.nextInt();

		}

		

		int max = 0;

		int xx = 1; int yy= 1;

		for (int i = 1; i<=n; i++)

			for (int j = 1; j<=m; j++){

				int count = Integer.MAX_VALUE;

				for (int l =0; l<k; l++)

					count = Math.min(Math.abs(i - x[l]) + Math.abs(j - y[l]), count);

		

				if (max < count){

					max = count;

					xx = i; yy = j;

				}

			}

		out.println(xx + "" "" + yy);

		out.close();

	}

}

",6,5
"

import java.awt.Point;

import java.io.BufferedReader;

import java.io.BufferedWriter;

import java.io.FileReader;

import java.io.FileWriter;

import java.util.LinkedList;

import java.util.Queue;

import java.util.StringTokenizer;



public class FireAgain {



    int k, i, j,n,m,x,y;

    void run() {

        try {

            BufferedReader bfd = new BufferedReader(new FileReader(""input.txt""));

            BufferedWriter out = new BufferedWriter(new FileWriter(""output.txt""));

//          BufferedReader bfd = new BufferedReader(new InputStreamReader(System.in));

            StringTokenizer tk = new StringTokenizer(bfd.readLine());

            

            n = Integer.parseInt(tk.nextToken());

            m = Integer.parseInt(tk.nextToken());

            boolean vis[][] = new boolean[n][m];

            k = Integer.parseInt(bfd.readLine());

            tk = new StringTokenizer(bfd.readLine());

            Queue<Point> q = new LinkedList<Point>();

            Point last = new Point(0,0);

            while(k-->0){

                x = Integer.parseInt(tk.nextToken())-1;

                y = Integer.parseInt(tk.nextToken())-1;

                q.add(new Point(x,y));

                vis[x][y] = true;

            }

            while(!q.isEmpty()) {

                Point frnt = q.poll();

                for(i=frnt.x-1;i<=frnt.x+1;++i)

                    for(j=frnt.y-1;j<=frnt.y+1;++j)

                        if(val(i,j)&& !vis[i][j]&&(frnt.x==i||frnt.y==j)){

                            q.add(new Point(i,j));

                            last = new Point(i,j);

                            vis[i][j] = true;

                        }

            }

//          System.out.println(last.x+1 + "" "" +(last.y+1));

            out.write(last.x+1 + "" "" +(last.y+1)+""\n"");

            out.flush();

            out.close();

        } catch (Exception e) {



        }

    }

    

    boolean val(int x,int y){

        return x>=0&&x<n&&y>=0&&y<m;

    }

    public static void main(String[] args) {

        new FireAgain().run();

    }



}

",6,1
"import java.io.*;
import java.util.*;

// :%s/Cbeta35/""name""/
// if (debug) 

public class Cbeta35 {
	public static void main(String[] args) { new Cbeta35(); }
	Scanner in;
	PrintWriter out;

	int t;
	int n, m, k, oo;
	int[][] grid;

	boolean debug = !true, multi = !true;

	Cbeta35() {
		if (multi) t = in.nextInt();
		do {
			if (multi) if (z(t--)) break;

			try {
				in = new Scanner(new File(""input.txt""));
				out = new PrintWriter(new File(""output.txt""));
			}
			catch (Exception e) {
				in = new Scanner(System.in);
				out = new PrintWriter(System.out);
			}

			n = in.nextInt();
			m = in.nextInt();
			k = in.nextInt();

			oo = n + m + 1;
			grid = new int[n][m];
			for (int i = 0; i < n; i++)
				Arrays.fill(grid[i], oo);
			for (int i = 0; i < k; i++) {
				int x = in.nextInt() - 1;
				int y = in.nextInt() - 1;
				for (int j = 0; j < n; j++)
					for (int kk = 0; kk < m; kk++) {
						int dx = j - x < 0 ? x - j : j - x;
						int dy = kk - y < 0 ? y - kk : kk - y;
						grid[j][kk] = min(grid[j][kk], dx + dy);
					}
			}

			int x = 0, y = 0;
			int max = 0;
			for (int i = 0; i < n; i++)
				for (int j = 0; j < m; j++)
					if (max < grid[i][j]) {
						max = grid[i][j];
						x = i; y = j;
					}
			out.printf(""%d %d%n"", x + 1, y + 1);

		} while (debug || multi);
		out.close();
	}

	

	int min(int a, int b) { if (a < b) return a; return b; }	
	int max(int a, int b) { if (a > b) return a; return b; }	
	long min(long a, long b) { if (a < b) return a; return b; }	
	long max(long a, long b) { if (a > b) return a; return b; }	

	boolean z(int x) { if (x == 0) return true; return false; }	
	boolean z(long x) { if (x == 0) return true; return false; }	

	void sort(int[] arr) {
		int szArr = arr.length;
		Random r = new Random();
		for (int i = 0; i < szArr; i++) {
			int j = r.nextInt(szArr);
			arr[i] = arr[j]^(arr[i]^(arr[j] = arr[i]));
		}
		Arrays.sort(arr);
	}

	class FS {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer("""");
		String next() {
			while (!st.hasMoreTokens()) {
				try { st = new StringTokenizer(br.readLine()); }
				catch (Exception e) {}
			} return st.nextToken();
		}
		int nextInt() { return Integer.parseInt(next()); }
		long nextLong() { return Long.parseLong(next()); }
		double nextDouble() { return Double.parseDouble(next()); }
	}
}
",6,5
"

import java.awt.Point;

import java.io.*;

import java.math.BigInteger;

import java.util.*;





import static java.lang.Math.*;



public class Main implements Runnable {

    

    BufferedReader in;

    PrintWriter out;

    StringTokenizer tok = new StringTokenizer("""");



    void init() throws FileNotFoundException {

            in = new BufferedReader(new FileReader(""input.txt""));

            out = new PrintWriter(""output.txt"");

    }



    String readString() throws IOException {

        while (!tok.hasMoreTokens()) {

            tok = new StringTokenizer(in.readLine());

        }

        return tok.nextToken();

    }



    int readInt() throws IOException {

        return Integer.parseInt(readString());

    }



    long readLong() throws IOException {

        return Long.parseLong(readString());

    }



    double readDouble() throws IOException {

        return Double.parseDouble(readString());

    }





    public static void mergeSort(int[] a) {

            mergeSort(a, 0, a.length - 1);

    }



    private static void mergeSort(int[] a, int leftIndex, int rightIndex) {

            final int MAGIC_VALUE = 50;

            if (leftIndex < rightIndex) {

                    if (rightIndex - leftIndex <= MAGIC_VALUE) {

                            insertionSort(a, leftIndex, rightIndex);

                    } else {

                            int middleIndex = (leftIndex + rightIndex) / 2;

                            mergeSort(a, leftIndex, middleIndex);

                            mergeSort(a, middleIndex + 1, rightIndex);

                            merge(a, leftIndex, middleIndex, rightIndex);

                    }

            }

    }



    private static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {

            int length1 = middleIndex - leftIndex + 1;

            int length2 = rightIndex - middleIndex;

            int[] leftArray = new int[length1];

            int[] rightArray = new int[length2];

            System.arraycopy(a, leftIndex, leftArray, 0, length1);

            System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);

            for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {

                    if (i == length1) {

                            a[k] = rightArray[j++];

                    } else if (j == length2) {

                            a[k] = leftArray[i++];

                    } else {

                            a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];

                    }

            }

    }



    private static void insertionSort(int[] a, int leftIndex, int rightIndex) {

            for (int i = leftIndex + 1; i <= rightIndex; i++) {

                    int current = a[i];

                    int j = i - 1;

                    while (j >= leftIndex && a[j] > current) {

                            a[j + 1] = a[j];

                            j--;

                    }

                    a[j + 1] = current;

            }

    }

    

    public static void main(String[] args) {

        new Main().run();

    }



    public void run() {

        try {

            long t1 = System.currentTimeMillis();

            init();

            solve();

            out.close();

            long t2 = System.currentTimeMillis();

            System.err.println(""Time = "" + (t2 - t1));

        } catch (Exception e) {

            e.printStackTrace(System.err);

            System.exit(-1);

        }

    }



    int mini = Integer.MAX_VALUE;

    int maxi = Integer.MIN_VALUE;

    int ans = 0;

    int ans2 = 0;

    int sum = 0;



    void solve() throws IOException {

        int n = readInt();

        int m = readInt();

        int maxi=0;

        int  [][] a = new int [n][m];

        int k = readInt();

        ArrayDeque<Point> dq = new ArrayDeque<Point> ();

        Point p = new Point();

        for (int i = 0; i<n; i++)

            for (int j= 0; j<m; j++){

                a[i][j]=Integer.MAX_VALUE;

            }

        for (int i = 0; i<k; i++){

            int x = readInt()-1;

            int y = readInt()-1;

            p.x=x;

            p.y=y;

            dq.add(new Point(x,y));

            a[x][y]=0;

        }

        while (!dq.isEmpty()){

            Point v = dq.pollFirst();

            Point u = new Point();

            if (v.x-1!=-1) {

                if (a[v.x-1][v.y]>a[v.x][v.y]+1){

                    a[v.x-1][v.y]=a[v.x][v.y]+1;

                    maxi=max(maxi,a[v.x-1][v.y]);

                    u.x=v.x-1;

                    u.y=v.y;

                    dq.add(new Point(u.x,u.y));

                }

            }

            if (v.y-1!=-1) {

                if (a[v.x][v.y-1]>a[v.x][v.y]+1){

                    a[v.x][v.y-1]=a[v.x][v.y]+1;

                    maxi=max(maxi,a[v.x][v.y-1]);

                    u.y=v.y-1;

                    u.x=v.x;

                    dq.add(new Point(u.x,u.y));

                }

            }

            if (v.x+1!=n) {

                if (a[v.x+1][v.y]>a[v.x][v.y]+1){

                    a[v.x+1][v.y]=a[v.x][v.y]+1;

                    maxi=max(maxi,a[v.x+1][v.y]);

                    u.x=v.x+1;

                    u.y=v.y;

                    dq.add(new Point(u.x,u.y));

                }

            }

            if (v.y+1!=m) {

                if (a[v.x][v.y+1]>a[v.x][v.y]+1){

                    a[v.x][v.y+1]=a[v.x][v.y]+1;

                    maxi=max(maxi,a[v.x][v.y+1]);

                    u.y=v.y+1;

                    u.x=v.x;

                    dq.add(new Point(u.x,u.y));

                }

            }

        }

        for (int i =0; i<n; i++)

            for (int j =0; j<m; j++){

                if (maxi==a[i][j]) {

                    out.print((i+1) + "" "" + (j+1));

                    return;

                }

            }

        

      }

    

    

    

    

    

    

    



    char c[];

    

    void per (int left, int right){

        if(left == right){

            for (int i = 0; i<=right;i++){

                out.print(c[i]);

            }

            out.println();

        }

        else {

            for (int i = left; i <=right; i++){

                char k = c[left];

                c[left] = c[i];

                c[i] = k;

                per(left+1,right);

                k = c[left];

                c[left] = c[i];

                c[i] = k;

            }

        }

    }

}











",6,5
"//package c;
import java.util.*;
import java.io.*;

public class Main {

	int n,m;
	int d[][];
	Queue<int[]> q = new LinkedList<int[]>();
	int cur[];
	
	public void run() throws Exception{
		Scanner in = new Scanner(new File(""input.txt""));
		PrintWriter out = new PrintWriter(new File(""output.txt""));
		n = in.nextInt();
		m = in.nextInt();
		int k = in.nextInt();
		d = new int[n][m];
		for(int i=0;i<n;i++) Arrays.fill(d[i], Integer.MAX_VALUE/2);
		for(int i=0;i<k;i++){
			int x = in.nextInt()-1;
			int y = in.nextInt()-1;
			d[x][y] = 0;
			q.add(new int[]{x,y});
		}
		
		
		while(q.size() > 0){
			cur = q.poll();
			int x = cur[0];
			int y = cur[1];
			add(x, y+1);
			add(x+1, y);
			add(x-1, y);
			add(x, y-1);
		}
		int max = 0;
		int x = 0;
		int y = 0;
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++)
				if (max < d[i][j]){
					max = d[i][j];
					x = i;
					y = j;
				}
		out.println((x+1) + "" "" + (y+1));
		out.close();
	}
	
	private void add(int x, int y){
		if (x < 0 || y < 0) return;
		if (x >=n || y >=m) return;
		if (d[x][y] > d[cur[0]][cur[1]] + 1){
			d[x][y] = d[cur[0]][cur[1]] + 1;
			q.add(new int[]{x,y});
		}
	}
	
	public static void main(String[] args) throws Exception{
		new Main().run();
	}

}
",6,5
"import java.io.BufferedReader;

import java.io.FileReader;

import java.io.FileWriter;

import java.io.IOException;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.Arrays;

import java.util.Queue;

import java.util.concurrent.ArrayBlockingQueue;



public class ProblemC {

	

	static int[] dx = {1, 0, 0, -1};

	static int[] dy = {0, 1, -1, 0};

	

	

	public static void main(String[] args) throws IOException {

		BufferedReader s = new BufferedReader(new FileReader(""input.txt""));

		PrintWriter out = new PrintWriter(new FileWriter(""output.txt""));

//		BufferedReader s = new BufferedReader(new InputStreamReader(System.in));

//		PrintWriter out = new PrintWriter(System.out);

		

		String[] nm = s.readLine().split("" "");

		int n = Integer.valueOf(nm[0]);

		int m = Integer.valueOf(nm[1]);

		int k = Integer.valueOf(s.readLine());

		

		int[][] dp = new int[n][m];

		for (int i = 0 ; i < n ; i++) {

			Arrays.fill(dp[i], Integer.MAX_VALUE);

		}

		String[] st = s.readLine().split("" "");

		int[][] trees = new int[k][2];

		for (int l = 0 ; l < k ; l++) {

			trees[l][0] = Integer.valueOf(st[l*2])-1;

			trees[l][1] = Integer.valueOf(st[l*2+1])-1;

		}

		

		int maxtime = -1;

		int max_x = -1;

		int max_y = -1;

		for (int i = 0 ; i < n ; i++) {

			for (int j = 0 ; j < m ; j++) {

				int minDist = n+m;

				for (int l = 0 ; l < k ; l++) {

					minDist = Math.min(minDist, Math.abs(i - trees[l][0]) + Math.abs(j - trees[l][1]));

				}

				if (maxtime < minDist) {

					maxtime = minDist;

					max_x = i+1;

					max_y = j+1;

				}

			}

		}

		

		

		

		out.println(max_x + "" "" + max_y);

		out.flush();

	}





	public static void debug(Object... os){

		System.err.println(Arrays.deepToString(os));

	}

}",6,5
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;
import javafx.util.Pair;


public class FireAgain {

     static Queue q=new LinkedList<>();
     static boolean[][] fired;
     static Pair index = null;
    public static void main(String[] args) throws IOException {
        // BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
          BufferedReader in=new BufferedReader(new FileReader(""input.txt""));
          BufferedWriter writer = new BufferedWriter(new FileWriter(""output.txt""));
         StringTokenizer s = new StringTokenizer(in.readLine());
         int n=Integer.parseInt(s.nextToken());
         int m=Integer.parseInt(s.nextToken());
         fired=new boolean[n][m];
         Pair result=null;
         s = new StringTokenizer(in.readLine());
         int firenum=Integer.parseInt(s.nextToken());
         s = new StringTokenizer(in.readLine());
         int i;
         ArrayList<Integer> tree=new ArrayList<>();
         for(i=0;i<firenum*2;i++){
             tree.add(Integer.parseInt(s.nextToken())-1);
         }
        for(i=0;i<2*firenum-1;i+=2){
           fired[tree.get(i)][tree.get(i+1)]=true;
           q.add(new Pair(tree.get(i),tree.get(i+1)));
        }
        index=(Pair) q.peek();
         result=bfs((int)index.getKey(),(int)index.getValue(),n,m);
       int x1=(int)result.getKey()+1;
       int x2=(int)result.getValue()+1;
        String str = x1 + "" "" + x2;
        writer.write(str);

        writer.close();
    }
    public static Pair bfs(int x,int y,int xmax,int ymax){
        fired[x][y]=true;
        while(!q.isEmpty()){
            index=(Pair) q.poll();
            int i=(int) index.getKey();
            int j=(int) index.getValue();
            if(i-1>=0){
                if(!fired[i-1][j]){
                fired[i-1][j]=true;
                q.add(new Pair((i-1),j));
                }
            }if(j-1>=0){
                if(!fired[i][j-1]){
                fired[i][j-1]=true;
                q.add(new Pair(i,(j-1)));
                }
            } if(i+1<xmax){
                if(!fired[i+1][j]){
                fired[i+1][j]=true;
                q.add(new Pair(i+1,j));
                }
            } if(j+1<ymax){
                if(!fired[i][j+1]){
                fired[i][j+1]=true;
                q.add(new Pair(i,j+1));
                }
            }
        }    
         return index;   
            
            
    }
    
    
}",6,1
"import java.io.*;
import java.util.LinkedList;

public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader(""input.txt""));
        PrintWriter out = new PrintWriter(""output.txt"");

        String[] raw = in.readLine().split("" "");
        int n = Integer.parseInt(raw[0]);
        int m = Integer.parseInt(raw[1]);

        int k = Integer.parseInt(in.readLine());

        raw = in.readLine().split("" "");

        boolean[][] map = new boolean[n][m];
        LinkedList<Point> queue = new LinkedList<>();

        for (int i = 0; i < k; i++) {
            Point fireStarter = new Point(Integer.parseInt(raw[i * 2]) - 1, Integer.parseInt(raw[i * 2 + 1]) - 1);

            queue.addLast(fireStarter);
        }

        int treesLeft = n * m;

        while (true) {
            Point firepoint = queue.removeFirst();

            if (map[firepoint.x][firepoint.y])
                continue;

            treesLeft--;
            map[firepoint.x][firepoint.y] = true;

            if (treesLeft == 0) {
                out.printf(""%d %d"", firepoint.x + 1, firepoint.y + 1);
                out.flush();
                return;
            }

            if (firepoint.x > 0 && !map[firepoint.x - 1][firepoint.y])
                queue.add(new Point(firepoint.x - 1, firepoint.y));

            if (firepoint.y > 0 && !map[firepoint.x][firepoint.y - 1])
                queue.add(new Point(firepoint.x, firepoint.y - 1));

            if (firepoint.x < n - 1 && !map[firepoint.x + 1][firepoint.y])
                queue.add(new Point(firepoint.x + 1, firepoint.y));

            if (firepoint.y < m - 1 && !map[firepoint.x][firepoint.y + 1])
                queue.add(new Point(firepoint.x, firepoint.y + 1));

//
//            for (int i = 0; i < n; i++) {
//                for (int j = 0; j < m; j++) {
//                    System.out.printf(""%d "", map[i][j] ? 1 : 0);
//                }
//                System.out.println();
//            }
//            System.out.println(""\n-------\n"");
        }
    }

    private static class Point {
        public int x;
        public int y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
",6,3
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.util.Collection;
import java.io.FileWriter;
import java.io.IOException;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.Objects;
import java.util.StringTokenizer;
import java.io.BufferedReader;
import java.util.Queue;
import java.util.LinkedList;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Nafiur Rahman Khadem Shafin ðŸ™‚
 */
public class Main {
	public static void main (String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader (inputStream);
		PrintWriter out = new PrintWriter (outputStream);
		ProblemCFireAgain solver = new ProblemCFireAgain ();
		solver.solve (1, in, out);
		out.close ();
	}
	
	static class ProblemCFireAgain {
		private static final byte[] dx = {-1, 0, 0, 1};
		private static final byte[] dy = {0, -1, 1, 0};
		private static int[][] lvl;
		private static int max;
		private static int n;
		private static int m;
		private static int k;
		private static ProblemCFireAgain.Pair[] bgn;
		private static ProblemCFireAgain.Pair res;
		
		private static void bfs2d () {
			Queue<ProblemCFireAgain.Pair> bfsq = new LinkedList<ProblemCFireAgain.Pair> ();
			for (ProblemCFireAgain.Pair src : bgn) {
				lvl[src.a][src.b] = 0;
				bfsq.add (src);
			}
			while (!bfsq.isEmpty ()) {
				ProblemCFireAgain.Pair op = bfsq.poll ();
				int plvl = lvl[op.a][op.b];
//			System.out.println (""ber hoise ""+op+"" ""+plvl);
				if (plvl>max) {
					res = op;
					max = plvl;
				}
				for (int i = 0; i<4; i++) {
					int newX = op.a+dx[i];
					int newY = op.b+dy[i];
//				System.out.println (newX+"" ""+newY+"" ""+n+"" ""+m);
					if (newX>0 && newX<=n && newY>0 && newY<=m && lvl[newX][newY] == -1) {
						bfsq.add (new ProblemCFireAgain.Pair (newX, newY));
						lvl[newX][newY] = (plvl+1);
//					System.out.println (""dhukse ""+newX+"" ""+newY);
					}
				}
			}
		}
		
		public void solve (int testNumber, InputReader _in, PrintWriter _out) {
			/*
			 * file input-output ðŸ˜®. Multi source bfs. Same as snackdown problem.
			 * */
			try (InputReader in = new InputReader (new FileInputStream (""input.txt""));
				 PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (""output.txt"")))) {
				n = in.nextInt ();
				m = in.nextInt ();
				k = in.nextInt ();
				bgn = new ProblemCFireAgain.Pair[k];
				for (int i = 0; i<k; i++) {
					bgn[i] = new ProblemCFireAgain.Pair (in.nextInt (), in.nextInt ());
				}
				max = Integer.MIN_VALUE;
				lvl = new int[n+5][m+5];
				for (int i = 0; i<n+4; i++) {
					Arrays.fill (lvl[i], -1);
				}
				bfs2d ();
//			System.out.println (max);
				out.println (res);
			} catch (Exception e) {
//			e.printStackTrace ();
			}
		}
		
		private static class Pair {
			int a;
			int b;
			
			Pair (int a, int b) {
				this.a = a;
				this.b = b;
			}
			
			
			public String toString () {
				return a+"" ""+b;
			}
			
			
			public boolean equals (Object o) {
				if (this == o) return true;
				if (!(o instanceof ProblemCFireAgain.Pair)) return false;
				ProblemCFireAgain.Pair pair = (ProblemCFireAgain.Pair) o;
				return a == pair.a && b == pair.b;
			}
			
			
			public int hashCode () {
				return Objects.hash (a, b);
			}
			
		}
		
	}
	
	static class InputReader implements AutoCloseable {
		private BufferedReader reader;
		private StringTokenizer tokenizer;
		
		public InputReader (InputStream stream) {
			reader = new BufferedReader (new InputStreamReader (stream));
			tokenizer = null;
		}
		
		public String next () {
			while (tokenizer == null || !tokenizer.hasMoreTokens ()) {
				try {
					String str;
					if ((str = reader.readLine ()) != null) tokenizer = new StringTokenizer (str);
					else return null;//to detect eof
				} catch (IOException e) {
					throw new RuntimeException (e);
				}
			}
			return tokenizer.nextToken ();
		}
		
		public int nextInt () {
			return Integer.parseInt (next ());
		}
		
		
		public void close () throws Exception {
			reader.close ();
		}
		
	}
}

",6,3
"import java.util.*;

import java.math.*;

import java.io.*;



public class Main

	{

	public static void main(String args[]) throws IOException

		{

		Scanner c = new Scanner(new FileReader(""input.txt""));

		PrintWriter out = new PrintWriter(new File(""output.txt""));



		int N=c.nextInt();

		int M=c.nextInt();

		int A[][]=new int[N][M];

		for(int i=0;i<N;i++)

			Arrays.fill(A[i],Integer.MAX_VALUE/100);

		int K=c.nextInt();

		for(int i=0;i<K;i++)

			{

			int x=c.nextInt()-1;

			int y=c.nextInt()-1;

			for(int i1=0;i1<N;i1++)

				{

				for(int j1=0;j1<M;j1++)

					A[i1][j1]=Math.min(A[i1][j1],Math.abs(i1-x)+Math.abs(j1-y));

				}

			}

		int maxi=0;

		int maxj=0;

		for(int i=0;i<N;i++)

			{

			for(int j=0;j<M;j++)

				{

				if(A[i][j]>A[maxi][maxj])

					{

					maxi=i;

					maxj=j;

					}

				}

			}

		out.println((maxi+1)+"" ""+(maxj+1));

		out.close();

		}

	}



//must declare new classes here",6,5
"
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Scanner;

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author madis
 */
public class Pjar {

    static int a[][];

    public static void main(String[] args) throws FileNotFoundException {
        Scanner in = new Scanner(new File(""input.txt""));
        PrintWriter out = new PrintWriter(""output.txt"");

        int N = in.nextInt();
        int M = in.nextInt();

        a = new int[N][M];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                a[i][j] = Integer.MAX_VALUE;
            }
        }
        int k = in.nextInt();
        in.nextLine();
        for (int i = 0; i < k; i++) {
            int x = in.nextInt();
            int y = in.nextInt();
            a[x - 1][y - 1] = 1;
            burn(x - 1, y - 1);
        }
        int max = Integer.MIN_VALUE;
        int x = 0;
        int y = 0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if(a[i][j]>max){
                    max = a[i][j];
                    x = i+1;
                    y = j+1;
                }
            }
        }
        out.printf(""%d %d"",x,y);
        out.close();
        in.close();
    }

    static void burn(int i, int j) {
        for(int k = 0;k<a.length;k++){
            for(int l=0;l<a[k].length;l++){
                if(a[k][l]>Math.abs(k-i) + Math.abs(l-j)){
                    a[k][l]=Math.abs(k-i) + Math.abs(l-j);
                }
            }
        }
    }
}
",6,5
"import java.io.File;

import java.io.PrintWriter;

import java.math.BigInteger;

import java.util.ArrayList;

import java.util.Arrays;

import java.util.Collection;

import java.util.Collections;

import java.util.Dictionary;

import java.util.HashMap;

import java.util.Iterator;

import java.util.LinkedList;

import java.util.Map;

import java.util.Map.Entry;

import java.util.Queue;

import java.util.Scanner;



public class Main {

	public String[][] a;

	public void run () throws Exception {

		Scanner in = new Scanner(new File(""input.txt""));

		PrintWriter pw = new PrintWriter(new  File(""output.txt""));



		int n = in.nextInt();

		int m = in.nextInt();

		int k = in.nextInt();

		

		int[] xx = new int[k];

		int[] yy = new int[k];

		for(int i=0;i<k;i++){

			xx[i] = in.nextInt();

			yy[i]= in.nextInt();

		}

		int x=0,y=0,r;

		r=-1;

		

		for(int i=0;i<n;i++)

			for(int j=0;j<m;j++){

				int rr = 1000000;

				for(int q=0;q<k;q++)

					rr = Math.min(rr, Math.abs(xx[q]-1-i)+Math.abs(yy[q]-1-j));

				if(rr>r){

					r=rr;

					x=i;

					y=j;

				}

			}

		pw.print((x+1)+"" ""+(y+1));



		pw.close();

	}

	public static void main(String[] args) throws Exception {

		new Main ().run();

	}



}

",6,5
"import javax.annotation.processing.SupportedSourceVersion;

import java.io.*;

import java.util.*;

import java.util.regex.Matcher;



public class Main {



    public static void main(String[] args) throws IOException {

        InputStream inputStream = System.in;

        OutputStream outputStream = System.out;

        InputReader in = new InputReader(new FileReader(""input.txt"")); // new InputReader(inputStream);

        PrintWriter out = new PrintWriter(""output.txt""); //new PrintWriter(outputStream);

        TaskB solver = new TaskB();

        solver.solve(in, out);

        out.close();

    }



    private static class TaskB {



        static final long max = 1000000000000000000L;

        static final double eps = 0.0000001;

        static final long mod = 1000000007;

        static int N, M, K;

        static long X, Y;

        static boolean F[][][];

        static int D[][];



        void solve(InputReader in, PrintWriter out) throws IOException {



            N = in.nextInt();

            M = in.nextInt();

            K = in.nextInt();



            F = new boolean[K][N][M];

            D = new int[N][M];



            for (int i = 0; i < N; i++)

                for (int j = 0; j < M; j++)

                    D[i][j] = Integer.MAX_VALUE;



            List<Pair> list = new ArrayList<>();



            for (int i = 0; i < K; i++) {

                list.add(new Pair(in.nextInt() - 1, in.nextInt() - 1));

            }





            for (int i = 0; i < N; i++)

                for (int j = 0; j < M; j++)

                    for (int k = 0; k < K; k++)

                        D[i][j] = Math.min(D[i][j], Math.abs(list.get(k).X - i) + Math.abs(list.get(k).Y - j));





            int res = Integer.MIN_VALUE;

            for (int j = 0; j < N; j++)

                for (int k = 0; k < M; k++)

                    if (D[j][k] > res) {

                        X = j + 1;

                        Y = k + 1;

                        res = D[j][k];

                    }



            out.println(X + "" "" + Y);



        }



        void bfs(int K, Pair P) {



            Queue<Pair> Q = new LinkedList<>();

            F[K][P.X][P.Y] = true;

            D[P.X][P.Y] = 0;

            Q.add(P);





            while (!Q.isEmpty()) {



                P = Q.poll();

                int X = P.X;

                int Y = P.Y;



                if (check(X - 1, Y) && !F[K][X - 1][Y]) {

                    F[K][X - 1][Y] = true;

                    if (D[X - 1][Y] > D[X][Y] + 1) {

                        D[X - 1][Y] = D[X][Y] + 1;

                        Q.add(new Pair(X - 1, Y));

                    }

                }



                if (check(X + 1, Y) && !F[K][X + 1][Y]) {

                    F[K][X + 1][Y] = true;

                    if (D[X + 1][Y] > D[X][Y] + 1) {

                        D[X + 1][Y] = D[X][Y] + 1;

                        Q.add(new Pair(X + 1, Y));

                    }

                }



                if (check(X, Y - 1) && !F[K][X][Y - 1]) {

                    F[K][X][Y - 1] = true;

                    if (D[X][Y - 1] > D[X][Y] + 1) {

                        D[X][Y - 1] = D[X][Y] + 1;

                        Q.add(new Pair(X, Y - 1));

                    }

                }



                if (check(X, Y + 1) && !F[K][X][Y + 1]) {

                    F[K][X][Y + 1] = true;

                    if (D[X][Y + 1] > D[X][Y] + 1) {

                        D[X][Y + 1] = D[X][Y] + 1;

                        Q.add(new Pair(X, Y + 1));

                    }

                }



            }



        }



        boolean check(int X, int Y) {

            return !(X < 0 || X >= N || Y < 0 || Y >= M);

        }



        class Pair {

            int X, Y;



            Pair(int X, int Y) {

                this.X = X;

                this.Y = Y;

            }

        }



        long gcd(long A, long B) {

            if (B == 0) return A;

            return gcd(B, A % B);

        }



        boolean isPrime(long n) {

            if (n <= 1 || n > 3 && (n % 2 == 0 || n % 3 == 0))

                return false;

            for (long i = 5, j = 2; i * i <= n; i += j, j = 6 - j)

                if (n % i == 0)

                    return false;

            return true;

        }



        boolean isEqual(double A, double B) {

            return Math.abs(A - B) < eps;

        }



        double dist(double X1, double Y1, double X2, double Y2) {

            return Math.sqrt((X1 - X2) * (X1 - X2) + (Y1 - Y2) * (Y1 - Y2));

        }



        boolean nextPer(int[] data) {

            int i = data.length - 1;

            while (i > 0 && data[i] < data[i - 1]) {

                i--;

            }

            if (i == 0) {

                return false;

            }

            int j = data.length - 1;

            while (data[j] < data[i - 1]) {

                j--;

            }

            int temp = data[i - 1];

            data[i - 1] = data[j];

            data[j] = temp;

            Arrays.sort(data, i, data.length);

            return true;

        }



        long pow(long A, long B, long MOD) {

            if (B == 0) {

                return 1;

            }

            if (B == 1) {

                return A;

            }

            long val = pow(A, B / 2, MOD);

            if (B % 2 == 0) {

                return val * val % MOD;

            } else {

                return val * (val * A % MOD) % MOD;

            }

        }

    }



    private static class InputReader {

        StringTokenizer st;

        BufferedReader br;



        public InputReader(InputStream s) {

            br = new BufferedReader(new InputStreamReader(s));

        }



        public InputReader(FileReader s) throws FileNotFoundException {

            br = new BufferedReader(s);

        }



        public String next() {

            while (st == null || !st.hasMoreTokens())

                try {

                    st = new StringTokenizer(br.readLine());

                } catch (IOException e) {

                    throw new RuntimeException(e);

                }

            return st.nextToken();

        }



        public int nextInt() {

            return Integer.parseInt(next());

        }



        public long nextLong() {

            return Long.parseLong(next());

        }



        public String nextLine() {

            try {

                return br.readLine();

            } catch (IOException e) {

                throw new RuntimeException(e);

            }

        }



        public double nextDouble() {

            return Double.parseDouble(next());

        }



        public boolean ready() {

            try {

                return br.ready();

            } catch (IOException e) {

                throw new RuntimeException(e);

            }

        }

    }

}",6,5
"import java.awt.Point;

import java.io.BufferedWriter;

import java.io.File;

import java.io.FileOutputStream;

import java.io.OutputStreamWriter;

import java.io.PrintWriter;

import java.io.Writer;

import java.util.LinkedList;

import java.util.Queue;

import java.util.Scanner;



public class sdffsdf {



	public static void main(String[] args) {

		try{

			File file = new File(""input.txt"");

			Scanner sc = new Scanner(file);

			String s = sc.nextLine();

			String[] seperatedd = s.split("" "");

			int x = Integer.parseInt(seperatedd[0]);

			int y = Integer.parseInt(seperatedd[1]);

			int[][] grid = new int[x][y];

			for(int i = 0; i < x; i++)

			{

				for(int j = 0; j < y; j++)

				{

					grid[i][j] = 0;

				}

			}

			s = sc.nextLine();

			int z = Integer.parseInt(s);

			LinkedList<Point> BFS = new LinkedList<Point>();

			s = sc.nextLine();

			String[] seperated = s.split("" "");

			for(int i = 0; i < seperated.length; i = i + 2)

			{

				Point temp = new Point();

				temp.x = Integer.parseInt(seperated[i])-1;

				temp.y = Integer.parseInt(seperated[i+1])-1;

				grid[temp.x][temp.y] = 1;

				BFS.addLast(temp);

			}

			while(!BFS.isEmpty())

			{

				Point temp = new Point();

				temp = BFS.removeFirst();

			 	int	k = temp.x;

			 	int l = temp.y;

				

				if(!(l+1 >= y || grid[k][l+1] == 1))

				{

					Point temp1 = new Point();

					temp1.x = k;

					temp1.y = l+1;

					grid[temp1.x][temp1.y] = 1;

					BFS.addLast(temp1);

				}

				if(!(k+1 >= x || grid[k+1][l] == 1))

				{

					Point temp1 = new Point();

					temp1.x = k+1;

					temp1.y = l;

					grid[temp1.x][temp1.y] = 1;

					BFS.addLast(temp1);

				}

				

								

				if(!(l-1 < 0 || grid[k][l-1] == 1))

				{

					Point temp1 = new Point();

					temp1.x = k;

					temp1.y = l-1;

					grid[temp1.x][temp1.y] = 1;

					BFS.addLast(temp1);

				}

				if(!(k-1 < 0 || grid[k-1][l] == 1))

				{

					Point temp1 = new Point();

					temp1.x = k-1;

					temp1.y = l;

					grid[temp1.x][temp1.y] = 1;

					BFS.addLast(temp1);

				}

				if(BFS.isEmpty())

				{

			try {

						File fil = new File(""output.txt"");

						PrintWriter out = new PrintWriter(fil);

						int v1 = (int)temp.getX() + 1;

						int v2 = (int)temp.getY() + 1;

						out.println(v1 + "" "" + v2); 

				        out.close();	

					}

					catch (Exception e) {}

				}

			}

		}

		catch (Exception e) {

			System.out.println(""nbvnb"");

		}



	}



}

",6,5
"import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.util.Collection;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.Objects;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.Queue;
import java.util.LinkedList;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream;
        try {
            inputStream = new FileInputStream(""input.txt"");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        OutputStream outputStream;
        try {
            outputStream = new FileOutputStream(""output.txt"");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        CFireAgain solver = new CFireAgain();
        solver.solve(1, in, out);
        out.close();
    }

    static class CFireAgain {
        private int n;
        private int m;
        private int K;
        private boolean[][] vis;
        private Queue<Util.Pair<Integer>> queue = new LinkedList<>();
        private Util.Pair<Integer> p;

        private boolean isValid(int x, int y) {
            return x >= 1 && x <= n && y >= 1 && y <= m && !vis[x][y];
        }

        private void bfs() {
            while (!queue.isEmpty()) {
                p = queue.poll();
                if (isValid(p.x + 1, p.y)) {
                    queue.offer(new Util.Pair<>(p.x + 1, p.y));
                    vis[p.x + 1][p.y] = true;
                }
                if (isValid(p.x - 1, p.y)) {
                    queue.offer(new Util.Pair<>(p.x - 1, p.y));
                    vis[p.x - 1][p.y] = true;
                }
                if (isValid(p.x, p.y + 1)) {
                    queue.offer(new Util.Pair<>(p.x, p.y + 1));
                    vis[p.x][p.y + 1] = true;
                }
                if (isValid(p.x, p.y - 1)) {
                    queue.offer(new Util.Pair<>(p.x, p.y - 1));
                    vis[p.x][p.y - 1] = true;
                }
            }
        }

        public void solve(int testNumber, InputReader in, OutputWriter out) {
            n = in.nextInt();
            m = in.nextInt();
            K = in.nextInt();
            vis = new boolean[n + 1][m + 1];
            for (int i = 0; i < K; i++) {
                int a = in.nextInt(), b = in.nextInt();
                vis[a][b] = true;
                queue.offer(new Util.Pair<>(a, b));
            }
            bfs();
            out.println(p.x + "" "" + p.y);
            out.flush();
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;
        private ArrayList<String> res = new ArrayList<>();
        private StringBuilder sb = new StringBuilder("""");

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void println(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                sb.append(objects[i]);
            }
            res.add(sb.toString());
            sb = new StringBuilder("""");
        }

        public void close() {
//        writer.flush();
            writer.close();
        }

        public void flush() {
            for (String str : res) writer.printf(""%s\n"", str);
            res.clear();
            sb = new StringBuilder("""");
        }

    }

    static class Util {
        public static class Pair<T> {
            public T x;
            public T y;

            public Pair(T x, T y) {
                this.x = x;
                this.y = y;
            }

            public boolean equals(Object obj) {
                if (obj == this) return true;
                if (!(obj instanceof Util.Pair)) return false;
                Util.Pair<T> pair = (Util.Pair<T>) obj;
                return this.x == pair.x && this.y == pair.y;
            }

            public String toString() {
                return (""("" + this.x + "","" + this.y + "")"");
            }

            public int hashCode() {
                return Objects.hash(x, y);
            }

        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar;
        private int numChars;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public InputReader(FileInputStream file) {
            this.stream = file;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res = (res << 3) + (res << 1) + c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",6,3
"



import java.io.FileReader;

import java.io.FileWriter;

import java.io.IOException;

import java.util.LinkedList;

import java.util.Scanner;



public class C {

    static class Struct {

        int x, y, count;



        public Struct(int xx, int yy, int c) {

            x = xx;

            y = yy;

            count = c;

        }

    }



    public static void main(String[] args) throws IOException {

        Scanner sc = new Scanner(new FileReader(""input.txt""));

        int n = sc.nextInt();

        int m = sc.nextInt();

        FileWriter fw=new FileWriter(""output.txt"");

        boolean[][] grid = new boolean[n][m];

        int[] dx = new int[] { 1, 0, -1, 0 };

        int[] dy = new int[] { 0, -1, 0, 1 };

        int k = sc.nextInt();

        LinkedList<Struct> a = new LinkedList<Struct>();

        for (int i = 0; i < k; i++) {

            a.add(new Struct(sc.nextInt() - 1, sc.nextInt() - 1, 0));

        }

        int max = Integer.MIN_VALUE, maxX = -1, maxY = -1;

        while (!a.isEmpty()) {

            Struct tmp = a.remove();

            if (grid[tmp.x][tmp.y] == true)

                continue;

            grid[tmp.x][tmp.y] = true;

            if (tmp.count > max) {

                max = tmp.count;

                maxX = tmp.x;

                maxY = tmp.y;

            }

            for (int i = 0; i < 4; i++) {

                int nx = tmp.x + dx[i];

                int ny = tmp.y + dy[i];

                if (nx < n && nx >= 0 && ny < m && ny >= 0) {

                    if (grid[nx][ny] == false) {

                        a.add(new Struct(nx, ny, tmp.count + 1));

                    }

                }

            }

        }

        fw.write((maxX + 1) + "" "" + (maxY + 1)+""\n"");

        System.out.println((maxX + 1) + "" "" + (maxY + 1));

        fw.flush();

    }

}

",6,3
"import java.io.File;

import java.io.FileInputStream;

import java.io.FileNotFoundException;

import java.io.PrintWriter;

import java.util.Arrays;

import java.util.Scanner;



public class Main {



	public static void main(String[] args) throws FileNotFoundException {

		// TODO Auto-generated method stub

		Scanner read = new Scanner(new FileInputStream(new File(""input.txt"")));

		PrintWriter out = new PrintWriter(new File(""output.txt""));

		int n = read.nextInt(), m = read.nextInt(), k = read.nextInt(), tree[][] = new int[n][m], a[] = new int[k],

				b[] = new int[k], x = 0, y = 0, max = -1, d = 0;



		for (int i = 0; i < k; i++) {

			a[i] = read.nextInt() - 1;

			b[i] = read.nextInt() - 1;	

			tree[a[i]][b[i]] = 0;

		}

		for(int i = 0; i < n; i++){

			Arrays.fill(tree[i], Integer.MAX_VALUE);

		}

		for (int o = 0; o < k; o++) {

			for(int i = 0; i < n; i++){

				for(int j = 0; j < m; j++){

					d = Math.abs(a[o] - i) + Math.abs(b[o] - j);

					if(d < tree[i][j])

						tree[i][j] = d;

				}

			}

		}

		for(int i = 0; i<n; i++){

			for(int j = 0; j < m ; j ++){

				if(tree[i][j] > max){

					max=  tree[i][j];

					x=  i;

					y = j;

				}

			}

		}

		out.println(x + 1 + "" "" + (y + 1));

		out.close();

	}



}

",6,5
"import java.io.*;
import java.util.*;
import java.math.*;

public class C implements Runnable {
	BufferedReader in;
	PrintWriter out;
	StringTokenizer st;
	Random rnd;
	
	short[] qx, qy;
	boolean[][] used;
	final int[] dx = {1, -1, 0, 0};
	final int[] dy = {0, 0, 1, -1};
	
	void solve() throws IOException {
		int n = nextInt(), m = nextInt();
		
		qx = new short[n * m];
		qy = new short[n * m];
		used = new boolean[n][m];
		
		int k = nextInt(), qs = 0, qt = 0;
		
		for(int i = 0; i < k; i++) {
			int x = nextInt() - 1, y = nextInt() - 1;
			used[x][y] = true;
			qx[qt] = (short) x;
			qy[qt] = (short) y;
			++qt;
		}
		
		int rx = 0, ry = 0;
		
		while(qs < qt) {
			int cx = qx[qs], cy = qy[qs];
			++qs;
			
			rx = cx;
			ry = cy;
			
			for(int z = 0; z < 4; z++) {
				int nx = cx + dx[z], ny = cy + dy[z];
				
				if(nx >= 0 && ny >= 0 && nx < n && ny < m && !used[nx][ny]) {
					used[nx][ny] = true;
					qx[qt] = (short) nx;
					qy[qt] = (short) ny;
					++qt;
				}
			}
		}
		
		out.println((rx + 1) + "" "" + (ry + 1));
	}

	public static void main(String[] args) {
		final boolean oldChecker = false;
		
		if(oldChecker) {
			new Thread(null, new C(), ""yarrr"", 1 << 24).start();
		} else {
			new C().run();
		}
	}

	public void run() {
		try {
			try {
				in = new BufferedReader(new FileReader(""input.txt""));
				out = new PrintWriter(new FileWriter(""output.txt""));
			} catch (FileNotFoundException e) {
				in = new BufferedReader(new InputStreamReader(System.in));
				out = new PrintWriter(System.out);
			}

			rnd = new Random();

			solve();

			out.close();
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(42);
		}
	}

	String nextToken() throws IOException {
		while (st == null || !st.hasMoreTokens()) {
			String line = in.readLine();

			if (line == null) {
				return null;
			}

			st = new StringTokenizer(line);
		}

		return st.nextToken();
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}",6,3
"import java.io.File;

import java.io.FileNotFoundException;

import java.io.PrintWriter;

import java.util.ArrayList;

import java.util.Scanner;



public class Main {

	public static void main(String[] args) throws FileNotFoundException {

		Scanner sc = new Scanner(new File(""input.txt""));

		PrintWriter out = new PrintWriter(new File(""output.txt""));

		int n = sc.nextInt();

		int m = sc.nextInt();

		int k = sc.nextInt();

		ArrayList<ArrayList<Integer>> fire = new ArrayList<ArrayList<Integer>>();

		while (k-- != 0) {

			ArrayList<Integer> t = new ArrayList<Integer>();

			t.add(sc.nextInt());

			t.add(sc.nextInt());

			fire.add(t);

		}

		

		int maxI = 0, maxJ = 0, maxManhatten = -1;

		for(int i = 1; i <= n; i++)

			for(int j = 1; j <= m; j++){

				int curManhatten = Integer.MAX_VALUE;

				for(int u = 0; u < fire.size(); u++)

					curManhatten = Math.min(curManhatten, manhatten(i, j, fire.get(u).get(0), fire.get(u).get(1)));

				

				if(curManhatten > maxManhatten){

					maxManhatten = curManhatten;

					maxI = i;

					maxJ = j;

				}

			}

		

		out.print(maxI + "" "" + maxJ);

		out.flush();

		out.close();

	}



	private static int manhatten(int i, int j, Integer a, Integer b) {

		return Math.abs(i - a) + Math.abs(j - b);

	}

}

",6,5
"import java.io.BufferedReader;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.Arrays;

import java.util.LinkedList;

import java.util.Queue;

import java.util.StringTokenizer;



public class A {



	static int dx[] = { 1, -1, 0, 0 };

	static int dy[] = { 0, 0, 1, -1 };



	public static void main(String args[]) throws Exception {

		Scanner sc = new Scanner(""input.txt"");

		PrintWriter out = new PrintWriter(""output.txt"");

		int n = sc.nextInt(), m = sc.nextInt();

		int[][] grid = new int[n][m];

		for (int[] i : grid)

			Arrays.fill(i, -1);

		Queue<Pair> q = new LinkedList<>();

		int k = sc.nextInt();

		for (int i = 0; i < k; i++) {

			int x = sc.nextInt() - 1, y = sc.nextInt() - 1;

			grid[x][y] = 0;

			q.add(new Pair(x, y));

		}

		Pair p = new Pair(-1, -1);

		while (!q.isEmpty()) {

			p = q.poll();

			for (int i = 0; i < dx.length; i++) {

				int tx = p.x + dx[i], ty = p.y + dy[i];

				if (tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == -1) {

					grid[tx][ty] = grid[p.x][p.y] + 1;

					q.add(new Pair(tx, ty));

				}

			}

		}

		out.println(p);

		out.flush();

		out.close();

	}



	static class Pair {

		int x, y;



		public Pair(int a, int b) {

			x = a;

			y = b;

		}



		public String toString() {

			return x + 1 + "" "" + (y + 1);

		}

	}



	static class Scanner {

		StringTokenizer st;

		BufferedReader br;



		public Scanner(InputStream s) {

			br = new BufferedReader(new InputStreamReader(s));

		}



		public Scanner(String r) throws FileNotFoundException {

			br = new BufferedReader(new FileReader(r));

		}



		public String next() throws IOException {

			while (st == null || !st.hasMoreTokens())

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}



		public int nextInt() throws IOException {

			return Integer.parseInt(next());

		}



		public long nextLong() throws IOException {

			return Long.parseLong(next());

		}



		public String nextLine() throws IOException {

			return br.readLine();

		}



		public boolean ready() throws IOException {

			return br.ready();

		}

	}

}

",6,3
"import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main1 {

	static int dr[] = { 0, 0, 1, -1 };
	static int dc[] = { 1, -1, 0, 0 };

	static boolean isValid(int r, int c) {
		if (r >= n || r < 0 || c >= m || c < 0)
			return false;

		return true;
	}

	static int grid[][];
	static int n, m;

	public static void main(String[] args) throws IOException {
		FastReader input = new FastReader();
		PrintWriter out = new PrintWriter(""output.txt"");

		n = input.nextInt();
		m = input.nextInt();
		grid = new int[n][m];

		int k = input.nextInt();

		for (int i = 0; i < n; i++) {
			Arrays.fill(grid[i], Integer.MAX_VALUE);
		}

		Queue<Pair> q = new LinkedList<Pair>();

		for (int i = 0; i < k; i++) {
			int x = input.nextInt() - 1;
			int y = input.nextInt() - 1;

			q.add(new Pair(x, y));
			grid[x][y] = 0;

			while (!q.isEmpty()) {
				Pair cur = q.poll();
				for (int j = 0; j < dr.length; j++) {
					int r = cur.x;
					int c = cur.y;
					int nr = r + dr[j];
					int nc = c + dc[j];
					int dist = grid[r][c] + 1;

					if (isValid(nr, nc) && grid[nr][nc] > dist) {
						grid[nr][nc] = dist;

						q.add(new Pair(nr, nc));
					}

				}
			}
		}

		int max = -1;
		int x = -1;
		int y = -1;

		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (grid[i][j] > max) {
					max = grid[i][j];
					x = i + 1;
					y = j + 1;
				}
			}
		}
		out.println(x + "" "" + y);
		out.flush();
	}

	static class FastReader {
		BufferedReader br;
		StringTokenizer st;

		public FastReader() throws FileNotFoundException {
			br = new BufferedReader(new FileReader(new File(""input.txt"")));
		}

		String next() throws IOException {
			while (st == null || !st.hasMoreElements()) {
				st = new StringTokenizer(br.readLine());
			}
			return st.nextToken();
		}

		int nextInt() throws NumberFormatException, IOException {
			return Integer.parseInt(next());
		}

		long nextLong() throws NumberFormatException, IOException {
			return Long.parseLong(next());
		}

		double nextDouble() throws NumberFormatException, IOException {
			return Double.parseDouble(next());
		}

		String nextLine() throws IOException {
			String str = """";
			str = br.readLine();
			return str;
		}
	}

	static class con {
		static int IINF = (int) 1e9;
		static int _IINF = (int) -1e9;
		static long LINF = (long) 1e15;
		static long _LINF = (long) -1e15;
		static double EPS = 1e-9;
	}

	static class Triple implements Comparable<Triple> {
		int x;
		int y;
		int z;

		Triple(int x, int y, int z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}

		@Override
		public int compareTo(Triple o) {
			if (x == o.x && y == o.y)
				return z - o.z;
			if (x == o.x)
				return y - o.y;
			return x - o.x;
		}
	}

	static class Pair implements Comparable<Pair> {
		int x;
		int y;

		Pair(int x, int y) {
			this.x = x;
			this.y = y;

		}

		@Override
		public int compareTo(Pair o) {
			if (x == o.x)
				return y - o.y;
			return x - o.x;
		}

		@Override
		public String toString() {

			return ""("" + x + "", "" + y + "")"";
		}

	}

	static void shuffle(int[] a) {
		for (int i = 0; i < a.length; i++) {
			int r = i + (int) (Math.random() * (a.length - i));
			int tmp = a[r];
			a[r] = a[i];
			a[i] = tmp;
		}
	}

	static int gcd(int a, int b) {
		return b == 0 ? a : gcd(b, a % b);
	}

}",6,6
"import static java.lang.Math.*;

import static java.util.Arrays.*;

import java.util.*;

import java.io.*;



public class Main {



	void solve() {

		int R = sc.nextInt();

		int C = sc.nextInt();

		int K = sc.nextInt();

		int[] x = new int[K];

		int[] y = new int[K];

		for (int i = 0; i < K; i++) {

			x[i] = sc.nextInt();

			y[i] = sc.nextInt();

		}



		int best = -1;

		int bestX = 0;

		int bestY = 0;



		for (int r = 1; r <= R; r++) for (int c = 1; c <= C; c++) {

			int here = R + C;

			for (int i = 0; i < K; i++) {

				int t = abs(r - x[i]) + abs(c - y[i]);

				here = min(here, t);

			}

			if (best < here){

				best = here;

				bestX = r;

				bestY = c;

			}

		}



		out.println(bestX + "" "" + bestY);

	}



	void print(int[] a) {

		out.print(a[0]);

		for (int i = 1; i < a.length; i++) out.print("" "" + a[i]);

		out.println();

	}



	static void tr(Object... os) {

		System.err.println(deepToString(os));

	}



	public static void main(String[] args) throws Exception {

		new Main().run();

	}



	MyScanner sc = null;

	PrintWriter out = null;

	public void run() throws Exception {

//		sc = new MyScanner(System.in);

//		out = new PrintWriter(System.out);

		sc = new MyScanner(new FileInputStream(new File(""input.txt"")));

		out = new PrintWriter(new File(""output.txt""));

		for (;sc.hasNext();) {

			solve();

			out.flush();

		}

		out.close();

	}



	class MyScanner {

		String line;

		BufferedReader reader;

		StringTokenizer tokenizer;



		public MyScanner(InputStream stream) {

			reader = new BufferedReader(new InputStreamReader(stream));

			tokenizer = null;

		}

		public void eat() {

			while (tokenizer == null || !tokenizer.hasMoreTokens()) {

				try {

					line = reader.readLine();

					if (line == null) {

						tokenizer = null;

						return;

					}

					tokenizer = new StringTokenizer(line);

				} catch (IOException e) {

					throw new RuntimeException(e);

				}

			}

		}

		public String next() {

			eat();

			return tokenizer.nextToken();

		}

		public String nextLine() {

			try {

				return reader.readLine();

			} catch (IOException e) {

				throw new RuntimeException(e);

			}

		}

		public boolean hasNext() {

			eat();

			return (tokenizer != null && tokenizer.hasMoreElements());

		}

		public int nextInt() {

			return Integer.parseInt(next());

		}

		public long nextLong() {

			return Long.parseLong(next());

		}

		public double nextDouble() {

			return Double.parseDouble(next());

		}

		public int[] nextIntArray(int n) {

			int[] a = new int[n];

			for (int i = 0; i < n; i++) a[i] = nextInt();

			return a;

		}

	}

}

",6,5
"



import java.io.*;

import java.util.Arrays;

import java.util.LinkedList;

import java.util.Queue;

import java.util.StringTokenizer;



/**

 * Created by mostafa on 10/7/17.

 */

public class FireAgain {

    static int n, m, k;

    static int inf = (int) 1e9;

    static class Pair {

        int x, y;

        Pair(int a, int b) {

            x = a; y = b;

        }

    }

    static int[] dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};

    static boolean valid(int x, int y) {

        return x >= 0 && x < n && y >= 0 && y < m;

    }

    static int[][] bfs(int[] xs, int[] ys) {

        int[][] dist = new int[n][m];

        for(int i = 0; i < n; i++)

            Arrays.fill(dist[i], inf);

        Queue<Pair> q = new LinkedList<>();

        for(int i = 0; i < k; i++) {

            dist[xs[i]][ys[i]] = 0;

            q.add(new Pair(xs[i], ys[i]));

        }



        while(!q.isEmpty()) {

            Pair p = q.remove();

            for(int d = 0; d < 4; d++) {

                int nx = p.x + dx[d], ny = p.y + dy[d];

                if(valid(nx, ny) && dist[nx][ny] == inf) {

                    dist[nx][ny] = dist[p.x][p.y] + 1;

                    q.add(new Pair(nx, ny));

                }

            }

        }



        return dist;

    }



    public static void main(String[] args) throws IOException {

        Scanner sc = new Scanner();

        n = sc.nextInt(); m = sc.nextInt(); k = sc.nextInt();

        int[] xs = new int[k], ys = new int[k];

        for(int i = 0; i < k; i++) {

            xs[i] = sc.nextInt() - 1; ys[i] = sc.nextInt() - 1;

        }



        int[][] dist = bfs(xs, ys);



        int x = 0, y = 0;

        for(int i = 0; i < n; i++)

            for(int j = 0; j < m; j++)

                if(dist[i][j] > dist[x][y]) {

                    x = i; y = j;

                }

        x++; y++;

        PrintWriter out = new PrintWriter(""output.txt"");

        out.println(x + "" "" + y);

        out.flush();

        out.close();

    }



    static class Scanner {

        BufferedReader br;

        StringTokenizer st;

        Scanner() throws FileNotFoundException {

            br = new BufferedReader(new FileReader(""input.txt""));

        }



        String next() throws IOException {

            while(st == null || !st.hasMoreTokens())

                st = new StringTokenizer(br.readLine());

            return st.nextToken();

        }



        int nextInt() throws IOException {

            return Integer.parseInt(next());

        }

    }

}

",6,5
"

import java.io.BufferedReader;

import java.io.FileInputStream;

import java.io.FileNotFoundException;

import java.io.FileOutputStream;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.ArrayList;

import java.util.List;

import java.util.StringTokenizer;



public class Main {

	public static int n,m;

	public static void main(String[] arg) {

		FastScanner scan = null;

		PrintWriter out = null;

		try{

			scan = new FastScanner(new FileInputStream(""input.txt""));

			out = new PrintWriter(new FileOutputStream(""output.txt""));

		}catch(FileNotFoundException e){

			scan = new FastScanner(System.in);

			out = new PrintWriter(System.out);

		}

		

		 n = scan.nextInt();

		 m = scan.nextInt();

		int k = scan.nextInt();

		int[][] board = new int[n+1][m+1];

		String[] ins = scan.nextLine().split("" "",-1);

		List<Integer> ps = new ArrayList<Integer>();

		for(int i = 0; i < 2 * k; i += 2){

			int a = Integer.parseInt(ins[i]);

			int b = Integer.parseInt(ins[i+1]);

			board[a][b] = 1;

			ps.add(a * 2001 + b);

		}

		

		int retx = 1, rety = 1;

		int[] dx = {0,1,0,-1};

		int[] dy = {1,0,-1,0};

		while(true){

			boolean find = false;

			List<Integer> ps2 = new ArrayList<Integer>();

			for(Integer p : ps){

				int i = p / 2001;

				int j = p % 2001;

				for(int q = 0; q < 4; q++){

					int nx = i + dx[q];

					int ny = j + dy[q];

					if(in(nx,ny) && board[nx][ny] == 0){

						board[nx][ny] = 1;

						retx = nx;

						rety = ny;

						find = true;

						ps2.add(nx * 2001 + ny);

					}

				}

				board[i][j] = 2;

			}

			ps = ps2;

			if(!find) break;

		}

		out.println(retx + "" "" + rety);

		out.close();

	}

	public static boolean in(int i, int j){

		return (1 <= i && i <= n) && (1 <= j && j <= m);

	}

	static class FastScanner {

		BufferedReader br;

		StringTokenizer st;

 

		FastScanner(InputStream is) {

			try {

				br = new BufferedReader(new InputStreamReader(is));

			} catch (Exception e) {

				e.printStackTrace();

			}

		}

 

		String next() {

			while (st == null || !st.hasMoreTokens()) {

				try {

					st = new StringTokenizer(br.readLine());

				} catch (Exception e) {

					return null;

				}

			}

			return st.nextToken();

		}

	    

		String nextLine() {

	        try {

	            return br.readLine();

	        }

	        catch (Exception e) {

	            return null;

	        }

	    }

		int nextInt() {

			return Integer.parseInt(next());

		}

 

		long nextLong() {

			return Long.parseLong(next());

		}

 

		double nextDouble() {

			return Double.valueOf(next());

		}

	}

}",6,3
"import java.io.BufferedReader;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.IOException;

import java.io.PrintWriter;

import java.util.Arrays;

import java.util.LinkedList;

import java.util.Queue;

import java.util.StringTokenizer;





public class Main {

	static int n, m, k;

	static int inf = (int) 1e9;

	static class Pair {

		int x, y;

		Pair(int a, int b) {

			x = a; y = b;

		}

	}

	static int[] dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};

	static boolean valid(int x, int y) {

		return x >= 0 && x < n && y >= 0 && y < m;

	}

	static int[][] bfs(int[] xs, int[] ys) {

		int[][] dist = new int[n][m];

		for(int i = 0; i < n; i++)

			Arrays.fill(dist[i], inf);

		Queue<Pair> q = new LinkedList<>();

		for(int i = 0; i < k; i++) {

			dist[xs[i]][ys[i]] = 0;

			q.add(new Pair(xs[i], ys[i]));

		}



		while(!q.isEmpty()) {

			Pair p = q.remove();

			for(int d = 0; d < 4; d++) {

				int nx = p.x + dx[d], ny = p.y + dy[d];

				if(valid(nx, ny) && dist[nx][ny] == inf) {

					dist[nx][ny] = dist[p.x][p.y] + 1;

					q.add(new Pair(nx, ny));

				}

			}

		}



		return dist;

	}



	public static void main(String[] args) throws IOException {

		Scanner in = new Scanner();

		int n = in.nextInt() ; 

		int m = in.nextInt(); 

		int k = in.nextInt(); 

		int x[] = new int[k] ; 

		int y[] = new int[k] ; 

		int trees [][] = new int [n][m] ;





		for (int i = 0; i < n; i++)

			for (int j = 0; j < m; j++)

				trees[i][j]=Integer.MAX_VALUE ;



		for (int i = 0; i < k; i++)

		{

			x[i]=in.nextInt()-1; 

			y[i]=in.nextInt()-1;

			trees[x[i]][y[i]]=0 ;

		}



		int dis = Integer.MIN_VALUE ; ;

		int xp=0; ;

		int yp=0;

		for (int i = 0; i < n; i++)

			for (int j = 0; j < m; j++)

				if(trees[i][j] != 0)

					for (int j2 = 0; j2 < k; j2++)

						trees[i][j]=Math.min(trees[i][j], Math.abs(i-x[j2])+Math.abs(j-y[j2]));



		for (int i = 0; i <n; i++)

			for (int j = 0; j < m; j++)

				if(trees[i][j] > dis)

				{

					dis=trees[i][j];

					xp=i+1;

					yp=j+1;

				}

		PrintWriter out = new PrintWriter(""output.txt"");

		out.printf(""%d %d\n"", xp ,yp);

		out.close();

	}



	static class Scanner {

		BufferedReader br;

		StringTokenizer st;

		Scanner() throws FileNotFoundException {

			br = new BufferedReader(new FileReader(""input.txt""));

		}



		String next() throws IOException {

			while(st == null || !st.hasMoreTokens())

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}



		int nextInt() throws IOException {

			return Integer.parseInt(next());

		}

	}

}",6,5
"// package Practice1.CF35;

import java.io.*;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class CF035C {
    public static void main(String[] args) throws IOException {
        Scanner s = new Scanner(new File(""input.txt"")/*System.in*/);
        int n = s.nextInt();
        int m = s.nextInt();
        int k = s.nextInt();
//        pair[] arr = new pair[n];
        Queue<pair> q = new LinkedList<>();
        PrintWriter out = new PrintWriter(new FileWriter(""output.txt""));
        boolean[][] visited = new boolean[n][m];
        for (int i = 0; i < k; i++) {
            int x = s.nextInt() - 1;
            int y  = s.nextInt() - 1;
            visited[x][y] = true;
            pair p = new pair(x,y);
//            arr[i] = p;
            q.add(p);
        }

        q.add(null);
        int[] dx = {0,0,1,-1};
        int[] dy = {1,-1,0,0};
        int ansX = q.peek().x;
        int ansY = q.peek().y;
        while(true){
            if(q.peek() == null){
                q.poll();
                q.add(null);
            }
            pair p = q.poll();
            if(p == null){
                break;
            }
            for (int i = 0; i < 4; i++) {
                if(isValid(p.x + dx[i],p.y+dy[i],n,m) && !visited[p.x + dx[i]][p.y+dy[i]]){
                    q.add(new pair(p.x + dx[i],p.y+dy[i]));
                    ansX = p.x + dx[i];
                    ansY = p.y + dy[i];
                    visited[ansX][ansY] = true;
                }
            }
        }
        out.println((ansX+1) + "" "" + (ansY+1));
        out.close();

    }

    public static boolean isValid(int x, int y,int n, int m){
        return x >= 0 && x < n && y >= 0 && y < m;
    }

    private static class pair{
        int x;
        int y;

        public pair(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
",6,3
"import java.io.FileReader;

import java.io.FileWriter;

import java.io.IOException;

import java.io.PrintWriter;

import java.util.Scanner;





public class FireAgain {



	Scanner in;

	PrintWriter out;

	

	public static void main(String[] args) throws IOException {

		// TODO Auto-generated method stub

		new FireAgain().run();



	}

	

	void run() throws IOException {

		in = new Scanner(new FileReader(""input.txt""));

        out = new PrintWriter(new FileWriter(""output.txt""));



		solve();



		in.close();

		out.close();

	}



	private void solve() {

		// TODO Auto-generated method stub

		int N = in.nextInt();

		int M = in.nextInt();

		int[][] burn = new int[N + 1][M + 1];

		int K = in.nextInt();

		

		int[] qx = new int[N * M];

		int[] qy = new int[N * M];

		

		int first = 0;

		int last = 0;

		for (int i = 0; i < K; i ++){

			qx[last] = in.nextInt();

			qy[last] = in.nextInt();

			burn[qx[last]][qy[last]] = 1;

			last ++;

		}

		

		while (first < last){

			int x = qx[first];

			int y = qy[first];

			if (x - 1 > 0 && burn[x - 1][y] == 0){

				burn[x - 1][y] = 1;

				qx[last] = x - 1;

				qy[last] = y;

				last ++;

			}

			if (y - 1 > 0 && burn[x][y - 1] == 0){

				burn[x][y - 1] = 1;

				qx[last] = x;

				qy[last] = y - 1;

				last ++;

			}

			if (x + 1 <= N && burn[x + 1][y] == 0){

				burn[x + 1][y] = 1;

				qx[last] = x + 1;

				qy[last] = y;

				last ++;

			}

			if (y + 1 <= M && burn[x][y + 1] == 0){

				burn[x][y + 1] = 1;

				qx[last] = x;

				qy[last] = y + 1;

				last ++;

			}

			first ++;

		}

		

		out.println(qx[last - 1] + "" "" + qy[last - 1]);

	}

}

",6,3
"

import java.awt.Point;

import java.io.File;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.PrintWriter;

import java.util.Scanner;



public class C {

    public static void main(String[] args) throws FileNotFoundException {

        Scanner in = new Scanner(new FileReader(new File(""input.txt"")));

        PrintWriter out = new PrintWriter(new File(""output.txt""));

        int n = in.nextInt();

        int m = in.nextInt();

        int[][] T = new int[n][m];

        int k = in.nextInt();

        int[] X = new int[k];

        int[] Y = new int[k];

        for (int i = 0; i < k; i++) {

            X[i] = in.nextInt() - 1;

            Y[i] = in.nextInt() - 1;

        }

        int max = 0;

        for (int i = 0; i < n; i++)

            for (int j = 0; j < m; j++) {

                int min = Integer.MAX_VALUE;

                for (int ii = 0; ii < k; ii++)

                    min = Math.min(min,

                            Math.abs(i - X[ii]) + Math.abs(j - Y[ii]));

                max = Math.max(max, T[i][j] = min);

            }

        for (int i = 0; i < n; i++)

            for (int j = 0; j < m; j++)

                if (T[i][j] == max) {

                    out.println((i + 1) + "" "" + (j + 1));

                    out.flush();

                    return;

                }



    }

}",6,5
"import java.io.BufferedReader;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.ArrayList;

import java.util.Arrays;

import java.util.HashSet;

import java.util.LinkedList;

import java.util.Queue;

import java.util.Random;

import java.util.StringTokenizer;



public class P {



	static int N, M, K;

	static int dx[] = { 0, 0, 1, -1, 1, 1, -1, -1 };

	static int dy[] = { 1, -1, 0, 0, 1, -1, 1, -1 };

	static Pair[] b;



	static boolean isValid(int x, int y) {

		return x >= 0 && y >= 0 && x < N && y < M;

	}



	static class Pair {

		int x, y;



		Pair(int i, int j) {

			x = i;

			y = j;

		}

	}



	static Pair bfs() {

		Queue<Pair> q = new LinkedList<Pair>();

		int[][] dist = new int[N][M];

		for (int i = 0; i < N; i++)

			for (int j = 0; j < M; j++)

				dist[i][j] = -1;

		for (int i = 0; i < K; i++) {

			dist[b[i].x][b[i].y] = 0;

			q.add(b[i]);

		}



		while (!q.isEmpty()) {

			Pair cur = q.remove();

			for (int d = 0; d < 4; d++) {

				int X = cur.x + dx[d];

				int Y = cur.y + dy[d];

				if (isValid(X, Y) && dist[X][Y] == -1) {

					dist[X][Y] = dist[cur.x][cur.y] + 1;

					Pair P = new Pair(X, Y);

					q.add(P);

				}

			}

		}

		int max = -1;

		Pair MX = null;

		for (int i = 0; i < N; i++)

			for (int j = 0; j < M; j++) {

				if (dist[i][j] > max) {

					max = dist[i][j];

					MX = new Pair(i + 1, j + 1);

				}

			}



		return MX;

	}



	public static void main(String[] args) throws IOException {

		Scanner sc = new Scanner(""input.txt"");

		PrintWriter out = new PrintWriter(""output.txt"");

		// Scanner sc = new Scanner(System.in);

		// PrintWriter out = new PrintWriter(System.out);

		N = sc.nextInt();

		M = sc.nextInt();

		K = sc.nextInt();

		b = new Pair[K];

		for (int i = 0; i < K; i++)

			b[i] = new Pair(sc.nextInt() - 1, sc.nextInt() - 1);



		Pair last = bfs();

		out.println((last.x) + "" "" + (last.y));

		out.flush();

		out.close();

	}



	static class Scanner {

		StringTokenizer st;

		BufferedReader br;



		public Scanner(InputStream s) {

			br = new BufferedReader(new InputStreamReader(s));

		}



		public Scanner(String f) throws FileNotFoundException {

			br = new BufferedReader(new FileReader(f));

		}



		public String next() throws IOException {

			while (st == null || !st.hasMoreTokens())

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}



		public int nextInt() throws IOException {

			return Integer.parseInt(next());

		}



		public long nextLong() throws IOException {

			return Long.parseLong(next());

		}



		public String nextLine() throws IOException {

			return br.readLine();

		}



		public double nextDouble() throws IOException {

			return Double.parseDouble(next());

		}



		public boolean ready() throws IOException {

			return br.ready();

		}



		public int[] nextIntArray(int n) throws IOException {

			int[] a = new int[n];

			for (int i = 0; i < n; i++)

				a[i] = nextInt();

			return a;

		}



		public int[] nextIntArray1(int n) throws IOException {

			int[] a = new int[n + 1];

			for (int i = 1; i <= n; i++)

				a[i] = nextInt();

			return a;

		}



		public int[] nextIntArraySorted(int n) throws IOException {

			int[] a = nextIntArray(n);

			Random r = new Random();

			for (int i = 0; i < n; i++) {

				int j = i + r.nextInt(n - i);

				int t = a[i];

				a[i] = a[j];

				a[j] = t;

			}

			Arrays.sort(a);

			return a;

		}



		public long[] nextLongArray(int n) throws IOException {

			long[] a = new long[n];

			for (int i = 0; i < n; i++)

				a[i] = nextLong();

			return a;

		}



		public long[] nextLongArray1(int n) throws IOException {

			long[] a = new long[n + 1];

			for (int i = 1; i <= n; i++)

				a[i] = nextLong();

			return a;

		}



		public long[] nextLongArraySorted(int n) throws IOException {

			long[] a = nextLongArray(n);

			Random r = new Random();

			for (int i = 0; i < n; i++) {

				int j = i + r.nextInt(n - i);

				long t = a[i];

				a[i] = a[j];

				a[j] = t;

			}

			Arrays.sort(a);

			return a;

		}

	}

}",6,5
"import java.io.*;

import java.math.BigDecimal;

import java.math.BigInteger;

import java.math.RoundingMode;

import java.text.DecimalFormat;

import java.util.*;



import static java.lang.Math.*;



public class Main {



    final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;

    BufferedReader in;

    PrintWriter out;

    StringTokenizer tok = new StringTokenizer("""");



    void init() throws FileNotFoundException {

        if (ONLINE_JUDGE) {

            in = new BufferedReader(new FileReader(""input.txt""));

            out = new PrintWriter(""output.txt"");

        } else {

            in = new BufferedReader(new FileReader(""input.txt""));

            out = new PrintWriter(""output.txt"");

        }

    }



    String readString() throws IOException {

        while (!tok.hasMoreTokens()) {

            tok = new StringTokenizer(in.readLine());

        }

        return tok.nextToken();

    }



    int readInt() throws IOException {

        return Integer.parseInt(readString());

    }



    long readLong() throws IOException {

        return Long.parseLong(readString());

    }



    double readDouble() throws IOException {

        return Double.parseDouble(readString());

    }



    public static void main(String[] args) {

        new Main().run();

        // Sworn to fight and die

    }



    public static void mergeSort(int[] a) {

        mergeSort(a, 0, a.length - 1);

    }



    private static void mergeSort(int[] a, int levtIndex, int rightIndex) {

        final int MAGIC_VALUE = 50;

        if (levtIndex < rightIndex) {

            if (rightIndex - levtIndex <= MAGIC_VALUE) {

                insertionSort(a, levtIndex, rightIndex);

            } else {

                int middleIndex = (levtIndex + rightIndex) / 2;

                mergeSort(a, levtIndex, middleIndex);

                mergeSort(a, middleIndex + 1, rightIndex);

                merge(a, levtIndex, middleIndex, rightIndex);

            }

        }

    }



    private static void merge(int[] a, int levtIndex, int middleIndex,

                              int rightIndex) {

        int length1 = middleIndex - levtIndex + 1;

        int length2 = rightIndex - middleIndex;

        int[] levtArray = new int[length1];

        int[] rightArray = new int[length2];

        System.arraycopy(a, levtIndex, levtArray, 0, length1);

        System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);

        for (int k = levtIndex, i = 0, j = 0; k <= rightIndex; k++) {

            if (i == length1) {

                a[k] = rightArray[j++];

            } else if (j == length2) {

                a[k] = levtArray[i++];

            } else {

                a[k] = levtArray[i] <= rightArray[j] ? levtArray[i++]

                        : rightArray[j++];

            }

        }

    }



    private static void insertionSort(int[] a, int levtIndex, int rightIndex) {

        for (int i = levtIndex + 1; i <= rightIndex; i++) {

            int current = a[i];

            int j = i - 1;

            while (j >= levtIndex && a[j] > current) {

                a[j + 1] = a[j];

                j--;

            }

            a[j + 1] = current;

        }

    }



    public void run() {

        try {

            long t1 = System.currentTimeMillis();

            init();

            solve();

            out.close();

            long t2 = System.currentTimeMillis();

            System.err.println(""Time = "" + (t2 - t1));

        } catch (Exception e) {

            e.printStackTrace(System.err);

            System.exit(-1);

        }

    }







    class LOL implements Comparable<LOL> {



        int x;

        int y;







        public LOL(int x, int y) {

            this.x = x;

            this.y = y;



        }



        @Override

        public int compareTo(LOL o) {



            return (x - o.x); // ---->

            //return o.x * o.y - x * y; // <----

        }



    }



    class LOL2 implements Comparable<LOL2> {



        int x;

        int y;

        int z;







        public LOL2(int x, int y, int z) {

            this.x = x;

            this.y = y;

            this.z = z;

        }



        @Override

        public int compareTo(LOL2 o) {



            return (z - o.z); // ---->

            //return o.x * o.y - x * y; // <----

        }



    }



    class test implements Comparable<test> {



        long x;

        long y;







        public test(long x, long y) {

            this.x = x;

            this.y = y;



        }



        @Override

        public int compareTo(test o) {

            //int compareResult = Long.compare(y, o.y); // ---->



            //if (compareResult != 0) {

            //    return -compareResult;

            //}



            int compareResult = Long.compare(x, o.x);



            if (compareResult != 0) {

                return compareResult;

            }



            return Long.compare(y, o.y);



            //return o.x * o.y - x * y; // <----

        }



    }



    class data {

        String name;

        String city;



        data(String name, String city) {

            this.city = city;

            this.name = name;

        }

    }



    class Point {

        double x;

        double y;





        Point(double x, double y) {

            this.x = x;

            this.y = y;



        }



        double distance(Point temp) {

            return Math.sqrt((x - temp.x) * (x - temp.x) + (y - temp.y) * (y - temp.y));

        }



        double sqrDist(Point temp) {

            return ((x - temp.x) * (x - temp.x) + (y - temp.y) * (y - temp.y));

        }



        Point rotate(double alpha) {

            return new Point(x * cos(alpha) - y * sin(alpha), x * sin(alpha) + y * cos(alpha));

        }



        void sum(Point o) {

            x += o.x;

            y += o.y;

        }



        void scalarProduct(int alpha) {

            x *= alpha;

            y *= alpha;

        }



    }



    class Line {

        double a;

        double b;

        double c;



        Line(Point A, Point B) {

            a = B.y - A.y;

            b = A.x - B.x;

            c = -A.x * a - A.y * b;

        }

        Line(double a, double b, double c) {

            this.a = a;

            this.b = b;

            this.c = c;

        }



      Point intersection(Line o) {

            double det = a * o.b - b * o.a;

            double det1 = -c * o.b + b * o.c;

            double det2 = -a * o.c + c * o.a;

            return new Point(det1 / det, det2 / det);

        }

    }



 /*   class Plane {

        double a;

        double b;

        double c;

        double d;



        Plane (Point fir, Point sec, Point thi) {

            double del1 = (sec.y - fir.y) * (thi.z - fir.z) - (thi.y - fir.y) * (sec.z - fir.z);

            double del2 = (thi.x - fir.x) * (sec.z - fir.z) - (thi.z - fir.z) * (sec.x - fir.x);

            double del3 = (thi.y - fir.y) * (sec.x - fir.x) - (thi.x - fir.x) * (sec.y - fir.y);

            a = del1;

            b = del2;

            c = del3;

            d = -fir.x * del1 - fir.y * del2 - fir.z * del3;

        }



        double distance(Point point) {

            return abs(a * point.x + b * point.y + c * point.z + d) / sqrt(a * a + b * b + c * c);

        }





    } */



    class record implements Comparable<record> {

        String city;

        Long score;



        public record(String name, Long score) {

            this.city = name;

            this.score = score;

        }



        @Override

        public int compareTo(record o) {

            if (o.city.equals(city)) {

                return 0;

            }



            if (score.equals(o.score)) {

                return 1;

            }



            if (score > o.score) {

                return 666;

            } else {

                return -666;

            }



            //return Long.compare(score, o.score);



        }



    }



    public long gcd(long a, long b) {

        if (a == 0 || b == 0) return max(a, b);



        if (a % b == 0)

            return b;

        else

            return gcd(b, a % b);

    }



    boolean prime(long n) {

        if (n == 1) return false;

        for (int i = 2; i <= sqrt(n); i++)

            if (n % i == 0)

                return false;

        return true;

    }



    public int sum(long n) {

        int s = 0;



        while (n > 0) {

            s += (n % 10);

            n /= 10;

        }



        return s;



    }



 /*   public void simulation(int k) {

        long ans = 0;

        int start = 1;

        for (int i = 0; i < k; i++) {

            start *= 10;

        }

        for (int i = start/10; i < start; i++) {

            int locAns = 0;

            for (int j = start/10; j < start; j++) {

                if  (sum(i + j) == sum(i) + sum(j) ) {

                    ans += 1;

                    locAns += 1;

                } else {

                    //.println(i + ""!!!"" + j);

                }

            }

            //out.println(i + "" "" + locAns);

        }

        out.println(ans);

    }*/









    ArrayList<Integer> primes;

    boolean[] isPrime;



    public void getPrimes (int n) {

        isPrime[0] = false;

        isPrime[1] = false;

        for (int i = 2; i <= n; i++) {

            if (isPrime[i]) {

                primes.add(i);

                if (1l * i * i <= n) {

                    for (int j = i * i; j <= n; j += i) {

                        isPrime[j] = false;

                    }

                }

            }

        }

    }









    public long binPowMod(long a, long b, long mod) {

        if (b == 0) {

            return 1 % mod;

        }



        if (b % 2 != 0) {

            return ((a % mod) * (binPowMod(a, b - 1, mod) % mod)) % mod;

        } else {

            long temp = binPowMod(a, b / 2, mod) % mod;

            long ans = (temp * temp) % mod;

            return ans;



        }

    }





    int type[];

    boolean vis[];



    HashMap<Integer, HashSet<Integer>> g;



    int componentNum[];



  /*  void dfs(int u, int numOfComponent) {

        vis[u] = true;

        componentNum[u] = numOfComponent;



        for (Integer v: g.get(u)) {

            if (!vis[v]) {

                dfs(v, numOfComponent);

            }

        }

    } */



    int p[];



    int find(int x) {

        if (x == p[x]) {

            return x;

        }



        return p[x] = find(p[x]);

    }



    boolean merge(int x, int y) {

        x = find(x);

        y = find(y);

        if (p[x] == p[y]) {

            return false;

        }

        p[y] = x;

        return true;

    }



    class Trajectory {

        double x0;

        double y0;

        double vx;

        double vy;





        Trajectory(double vx, double vy, double x0, double y0) {

            this.vx = vx;

            this.vy = vy;



            this.x0 = x0;

            this.y0 = y0;

        }



        double y (double x) {

            return y0 + (x - x0) * (vy / vx) - 5 * (x - x0) * (x - x0) / (vx * vx);

        }



        double der(double x) {

            return (vy / vx) - 10 * (x - x0) / (vx * vx);

        }





    }



    int s;

    int n;

    int m;

    boolean isVisited[][];

    char[][] maze;

    int[] dx = {0, 0, -1, 1};

    int[] dy = {1, -1, 0, 0};



    void dfs(int x, int y) {

        isVisited[x][y] = true;



        for (int i = 0; i < 4; i++) {

            int currX = x + dx[i];

            int currY = y + dy[i];



            if (maze[currX][currY] == '.' && !isVisited[currX][currY]) {

                dfs(currX, currY);

            }



        }







    }









    public void solve() throws IOException {



        n = readInt();

        m = readInt();



        maze = new char[n + 2][m + 2];



        for (int i = 0; i < n + 2; i++) {

            maze[i][0] = '#';

            maze[i][m + 1] = '#';

        }



        for (int j = 0; j < m + 2; j++) {

            maze[0][j] = '#';

            maze[n + 1][j] = '#';

        }



        for (int i = 1; i <= n; i++) {

            for (int j = 1; j <= m; j++) {

                maze[i][j] = '.';

            }

        }



        int[][] dist = new int[n + 2][m + 2];



        for (int i = 0; i < n + 2; i++) {

            for (int j = 0; j < m + 2; j++) {

                dist[i][j] = Integer.MAX_VALUE;

            }

        }



        ArrayDeque<Integer> xValues = new ArrayDeque<Integer>();

        ArrayDeque<Integer> yValues = new ArrayDeque<Integer>();



        int k = readInt();

        for (int i = 0; i < k; i++) {

            int currX = readInt();

            int currY = readInt();

            xValues.add(currX);

            yValues.add(currY);

            dist[currX][currY] = 0;

        }







        while(!xValues.isEmpty()) {

            int x = xValues.poll();

            int y = yValues.poll();



            for (int i = 0; i < 4; i++) {

                int currX = x + dx[i];

                int currY = y + dy[i];



                if (maze[currX][currY] == '.' && dist[currX][currY] > dist[x][y] + 1) {

                    dist[currX][currY] = dist[x][y] + 1;

                    xValues.add(currX);

                    yValues.add(currY);

                }



            }



        }



        int maxDist = 0;

        int indexX = 0;

        int indexY = 0;



        for (int i = 1; i <= n; i++) {

            for (int j = 1; j <= m; j++) {

                if (dist[i][j] >= maxDist) {

                    maxDist = dist[i][j];

                    indexX = i;

                    indexY = j;

                }

            }

        }



        out.print(indexX + "" "" + indexY);











    }







}",6,5
"    import java.awt.Point;

import java.io.*;

    import java.text.*;

    import java.util.*;

import java.util.regex.*;



    public class Main{

        static class Run implements Runnable{

            //TODO parameters

            final boolean consoleIO = false;

            final String inFile = ""input.txt"";

            final String outFile = ""output.txt"";

            

            int n,m,k;

            int[][] field;

            boolean[][] visited;

            

            LinkedList<Point> queue;

            int[][] steps = {{0,1},{1,0},{0,-1},{-1,0}};

            

            void wave() {

                for(Point p:queue)

                    visited[p.y][p.x] = true;

                

                while(!queue.isEmpty()) {

                    Point cur = queue.removeFirst();

                    for(int i = 0; i < steps.length; ++i) {

                        Point tmp = new Point(cur.x+steps[i][0],cur.y+steps[i][1]);

                        

                        if(ok(tmp)&&!visited[tmp.y][tmp.x]) {

                            queue.add(tmp);

                            visited[tmp.y][tmp.x] = true;

                            field[tmp.y][tmp.x] = field[cur.y][cur.x]+1;

                        }

                    }

                }

            }

            

            boolean ok(Point p) { 

                return p.x>=0 && p.y>=0 && p.x<n && p.y<m;

            }

            

            @Override

            public void run() {

                n = nextInt();

                m = nextInt();

                k = nextInt();

                

                queue = new LinkedList<Point>();

                for(int i = 0; i < k; ++i) 

                    queue.add(new Point(nextInt()-1,nextInt()-1));

                

                field = new int[m][n];

                visited = new boolean[m][n];

                wave();

                

                Point maxP = new Point(0,0);

                int maxV = Integer.MIN_VALUE;

                

                for(int i = 0; i < m; ++i)

                    for(int j = 0; j < n; ++j) 

                        if(field[i][j] > maxV) {

                            maxV = field[i][j];

                            maxP = new Point(j,i);

                        }

                

                print((maxP.x+1)+"" ""+(maxP.y+1));

                close();

            }

        //=========================================================================================================================

            BufferedReader in;

            PrintWriter out;

            StringTokenizer strTok;

           

            Run() {

                if (consoleIO) {

                    initConsoleIO();

                }

                else {

                    initFileIO();

                }

            }

           

            void initConsoleIO() {

                in = new BufferedReader(new InputStreamReader(System.in));

                out = new PrintWriter(new OutputStreamWriter(System.out));

            }

           

            void initFileIO() {

                try {

                    in = new BufferedReader(new FileReader(inFile));

                    out = new PrintWriter(new FileWriter(outFile));

                } catch (FileNotFoundException e) {

                    e.printStackTrace();

                } catch (IOException e) {

                    e.printStackTrace();

                }

            }

           

            void close() {

                try {

                    in.close();

                    out.close();

                } catch (IOException e) {

                    e.printStackTrace();

                }

            }

           

            int nextInt() {

                return Integer.parseInt(nextToken());

            }

           

            double nextDouble() {

                return Double.parseDouble(nextToken());

            }

           

            float nextFloat() {

                return Float.parseFloat(nextToken());

            }

           

            long nextLong() {

                return Long.parseLong(nextToken());

            }

           

            String nextLine() {

                try {

                    return in.readLine();

                } catch (IOException e) {

                    return ""__NULL"";

                }

            }

           

            boolean hasMoreTokens() {

                return (strTok == null) || (strTok.hasMoreTokens());

            }

           

            String nextToken() {

                while (strTok == null || !strTok.hasMoreTokens()) {

                    String line;

                    try {

                        line = in.readLine();

                        strTok = new StringTokenizer(line);

                    } catch (IOException e) {

                        e.printStackTrace();

                    }

                }

               

                return strTok.nextToken();

            }

           

            void cout(Object o){

                System.out.println(o);

            }

           

            void print(Object o) {

                out.write(o.toString());

            }

            

            void println(Object o) {

                out.write(o.toString() + '\n');

            }

           

            void printf(String format, Object... args) {

                out.printf(format, args);

            }

           

            String sprintf(String format, Object... args) {

            return MessageFormat.format(format, args);

        }

        }

       

        static class Pair<A, B> {

            A a;

            B b;

           

            A f() {

                return a;

            }

           

            B s() {

                return b;

            }

           

            Pair(A a, B b) {

                this.a = a;

                this.b = b;

            }

           

            Pair(Pair<A, B> p) {

                a = p.f();

                b = p.s();

            }

        }

       

        public static void main(String[] args) throws IOException {

            Run run = new Run();

            Thread thread = new Thread(run);

            thread.run();

        }

    }",6,5
"import java.io.*;

import java.util.*;



import static java.lang.Math.*;

import static java.util.Arrays.fill;

import static java.util.Arrays.binarySearch;

import static java.util.Arrays.sort;



public class Main {

	public static void main(String[] args) throws IOException {

		new Thread(null, new Runnable() {

			public void run() {

				try {

					try {

						if (new File(""input.txt"").exists())

							System.setIn(new FileInputStream(""input.txt""));

					} catch (SecurityException e) {}

					new Main().run();

				} catch (IOException e) {

					e.printStackTrace();

				}

			}

		}, ""1"", 1L << 24).start(); 

	}



	BufferedReader in;

	PrintWriter out;

	StringTokenizer st = new StringTokenizer("""");

	

	int N;

	int M;

	boolean[][] used;

	Queue<Integer> queue;

	

	int[] dx = { -1, 0, 1, 0 };

	int[] dy = { 0, -1, 0, 1 };

	int ans = -1;

	

	void run() throws IOException {

		in = new BufferedReader(new InputStreamReader(System.in));

		out = new PrintWriter(""output.txt"");

		

		N = nextInt();

		M = nextInt();

		used = new boolean [N][M];

		queue = new ArrayDeque<Integer> (N * M);

		for (int K = nextInt(); K --> 0; )

			addState(nextInt() - 1, nextInt() - 1);

		while (!queue.isEmpty()) {

			int cv = queue.poll();

			int cx = cv / M;

			int cy = cv % M;

			for (int d = 0; d < dx.length; d++) {

				int nx = cx + dx[d];

				int ny = cy + dy[d];

				if (0 <= nx && nx < N && 0 <= ny && ny < M && !used[nx][ny])

					addState(nx, ny);

			}

		}

		out.println((1 + ans / M) + "" "" + (1 + ans % M));

		out.close();

	}

	

	void addState(int x, int y) {

		used[x][y] = true;

		queue.add(ans = code(x, y));

	}



	int code(int x, int y) {

		return x * M + y;

	}



	String nextToken() throws IOException {

		while (!st.hasMoreTokens()) {

			st = new StringTokenizer(in.readLine());

		}

		

		return st.nextToken();

	}

	

	int nextInt() throws IOException {

		return Integer.parseInt(nextToken());

	}

	

	long nextLong() throws IOException {

		return Long.parseLong(nextToken());

	}

	

	double nextDouble() throws IOException {

		return Double.parseDouble(nextToken());

	}

	

	String nextLine() throws IOException {

		st = new StringTokenizer("""");

		return in.readLine();

	}

	

	boolean EOF() throws IOException {

		while (!st.hasMoreTokens()) {

			String s = in.readLine();

			

			if (s == null) {

				return true;

			}

			

			st = new StringTokenizer(s);

		}

		

		return false;

	}

}

",6,3
"import java.io.*;

import java.util.StringTokenizer;



import static java.lang.Math.abs;



/**

 * 35C

 *

 * @author artyom

 */

public class FireAgain implements Runnable {

    private BufferedReader in;

    private PrintWriter out;

    private StringTokenizer tok;



    private void solve() throws IOException {

        int n = nextInt(), m = nextInt();

        int[][] sources = readIntMatrix(nextInt(), 2);

        int max = -1, maxI = 0, maxJ = 0;

        for (int i = 0; i < n; i++) {

            for (int j = 0; j < m; j++) {

                int min = Integer.MAX_VALUE;

                for (int[] source : sources) {

                    int dist = abs(source[0] - i) + abs(source[1] - j);

                    if (dist < min) {

                        min = dist;

                    }

                }

                if (min > max) {

                    max = min;

                    maxI = i;

                    maxJ = j;

                }

            }

        }

        out.print((maxI + 1) + "" "" + (maxJ + 1));

    }



    //--------------------------------------------------------------

    public static void main(String[] args) {

        new FireAgain().run();

    }



    @Override

    public void run() {

        try {

            in = new BufferedReader(new FileReader(""input.txt""));

            out = new PrintWriter(new FileWriter(""output.txt""));

            tok = null;

            solve();

            in.close();

            out.close();

        } catch (IOException e) {

            System.exit(0);

        }

    }



    private String nextToken() throws IOException {

        while (tok == null || !tok.hasMoreTokens()) {

            tok = new StringTokenizer(in.readLine());

        }

        return tok.nextToken();

    }



    private int nextInt() throws IOException {

        return Integer.parseInt(nextToken());

    }



    private int[][] readIntMatrix(int n, int m) throws IOException {

        int[][] mx = new int[n][m];

        for (int i = 0; i < n; i++) {

            for (int j = 0; j < m; j++) {

                mx[i][j] = nextInt() - 1;

            }

        }

        return mx;

    }

}",6,5
"import java.io.*;

import java.util.*;



public class MainF {

    public static void main(String[]args) throws IOException{

        BufferedReader br = new BufferedReader(new FileReader(new File(""input.txt"")));

        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(""output.txt"")));

        String S = br.readLine();

        String[]J = S.split("" "");

        int N = Integer.parseInt(J[0]);

        int M = Integer.parseInt(J[1]);



        int K = Integer.parseInt(br.readLine());

        int[]x = new int[K];

        int[]y = new int[K];

        S = br.readLine();

        J = S.split("" "");       

        for(int i = 0; i<2*K; i = i + 2){

            x[i/2] = Integer.parseInt(J[i]);

            y[i/2] = Integer.parseInt(J[i+1]);

        }

        

        int ans = -1;

        int ansX = -1;

        int ansY = -1;

        

        for (int i = 1; i<=N; i++){

            for (int j = 1; j<=M; j++){

                int W = M + N;

                for (int k = 0; k<K; k++){

                    W = Math.min(W, Math.abs(i-x[k]) + Math.abs(j-y[k]));

                }

                if (W < ans)continue;

                ans = W;

                ansX = i;

                ansY = j;               

            }

        }

        bw.write(Integer.toString(ansX)+"" ""+Integer.toString(ansY));

        br.close();

        bw.close();     

    }

}",6,5
"import java.io.*;

import java.util.*;



public class Main {



    static BufferedReader br;

    static PrintWriter out;

    static StringTokenizer st;

    

    static int[][] moves = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};

    

    static boolean correct(int x, int y, int n, int m) {

        return (x >= 0 && x < n && y >= 0 && y < m); 

    }

    

    static void solve() throws Exception {

        int n = nextInt();

        int m = nextInt();

        int k = nextInt();

        int[][] order = new int[n][m];

        boolean[][] used = new boolean[n][m];

        Queue<Integer[]> q = new LinkedList<>();

        Set<String> set = new HashSet<String>();

        for(int i = 0; i < k; i++) {

            int x = nextInt() - 1;

            int y = nextInt() - 1;

            order[x][y] = 1;

            used[x][y] = true;

            q.add(new Integer[] {x, y});

            set.add(x + """" + y);

        }

        while(!q.isEmpty()) {

            Integer[] v = q.remove();

            for(int[] move : moves) {

                int x = v[0] + move[0];

                int y = v[1] + move[1];

//              if(set.contains(x + """" + y)) {

//                  continue;

//              }

                if(correct(x, y, n, m) && !used[x][y]) {

                    q.add(new Integer[] {x, y});

                    used[x][y] = true;

                    order[x][y] = order[v[0]][v[1]] + 1; 

                }

            }

        }

        int max = Integer.MIN_VALUE;

        int maxI = -1;

        int maxJ = -1;

        for(int i = 0; i < n; i++) {

            for(int j = 0; j < m; j++) {

                if(order[i][j] > max) {

                    max = order[i][j];

                    maxI = i;

                    maxJ = j;

                }

            }

        }

        maxI++;

        maxJ++;

        out.println(maxI + "" "" + maxJ);

    }

    

 

    static int nextInt() throws IOException {

        return Integer.parseInt(next());

    }



    static long nextLong() throws IOException {

        return Long.parseLong(next());

    }



    static double nextDouble() throws IOException {

        return Double.parseDouble(next());

    }



    static String next() throws IOException {

        while (st == null || !st.hasMoreTokens()) {

            String line = br.readLine();

            if (line == null) {

                return null;

            }

            st = new StringTokenizer(line);

        }

        return st.nextToken();

    }



    public static void main(String[] args) {

        try {

            InputStream input = System.in;

            OutputStream output = System.out;

            br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(""input.txt""))));

            out = new PrintWriter(new PrintStream(new File(""output.txt"")));

            solve();

            out.close();

            br.close();

        } catch (Throwable t) {

            t.printStackTrace();

        }

    }

}",6,5
"import java.util.*;
import java.io.*;
import static java.lang.Math.*;
import java.awt.*;

public class PracticeProblem
{
    /*
     * This FastReader code is taken from GeeksForGeeks.com
     * XXXX
     *
     * The article was written by Rishabh Mahrsee
     */
    public static class FastReader
    {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() throws FileNotFoundException
        {
            br = new BufferedReader(new FileReader(new File(""input.txt"")));
        }

        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt()
        {
            return Integer.parseInt(next());
        }

        long nextLong()
        {
            return Long.parseLong(next());
        }

        double nextDouble()
        {
            return Double.parseDouble(next());
        }

        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }

    public static FastReader in;
    public static PrintWriter out;
    public static final int INF = Integer.MAX_VALUE;
    public static int n, m;

    public static final int[] dr = {-1, 0, 0, +1};
    public static final int[] dc = {0, -1, +1, 0};

    public static void main(String[] args) throws FileNotFoundException
    {
        in = new FastReader();
        out = new PrintWriter(new File(""output.txt""));
        solve();
        out.close();
    }

    private static void solve()
    {
        n = in.nextInt();
        m = in.nextInt();
        int k = in.nextInt();

        int[][] timeToBurn = new int[n][m];
        for (int i = 0; i < n; i++)
            Arrays.fill(timeToBurn[i], INF);

        for (int i = 0; i < k; i++)
        {
            int r = in.nextInt() - 1;
            int c = in.nextInt() - 1;
            for (int j = 0; j < n; j++)
            {
                for (int l = 0; l < m; l++)
                {
                    timeToBurn[j][l] = min(timeToBurn[j][l], abs(r - j) + abs(c - l));
                }
            }
        }
        int max = -1;
        Point p = null;
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (timeToBurn[i][j] > max)
                {
                    max = timeToBurn[i][j];
                    p = new Point(i, j);
                }
            }
        }

        out.println((p.x + 1) + "" "" + (p.y + 1));
    }

}",6,5
"import java.util.*;

import java.io.*;



public class C {

	public static void main(String[] args) throws Exception {

		final int fuck = 2001;



		Scanner in = new Scanner(new File(""input.txt""));

		PrintWriter out = new PrintWriter(new File(""output.txt""));



		int n = in.nextInt(), m = in.nextInt();

		int[] D = new int[ fuck*fuck ],

			dx = new int[] { 1, -1, 0, 0},

			dy = new int[] { 0, 0, -1, 1};

		Arrays.fill(D, -1);



		ArrayDeque<Integer> Q = new ArrayDeque<>();

		int k = in.nextInt(), ans = 0;

		for(int i = 0; i < k; ++i) {

			int x = in.nextInt(), y = in.nextInt();

			D[ans = (x * fuck + y)] = 0;

			Q.offer(ans);

		}

		

		while(!Q.isEmpty()) {

			int idx = Q.poll();

			int x = idx / fuck, y = idx % fuck;

			for(int i = 0; i < 4; ++i) {

				int wtf = (dx[i] + x) * fuck + (dy[i] + y);

				if(dx[i] + x <= n && dx[i] + x >= 1 && dy[i] + y <= m && dy[i] + y >= 1 && D[wtf] == -1) {

					D[wtf] = D[idx] + 1;

					Q.offer(wtf);



					if(D[wtf] >= D[ans])

						ans = wtf;

				}

			}

		}



		out.println((ans / fuck) + "" "" + (ans % fuck));

		out.close();

		in.close();

	}

}",6,3
"import java.util.LinkedList;

import java.io.FileInputStream;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.BufferedReader;

import java.util.Collection;

import java.io.OutputStream;

import java.io.PrintWriter;

import java.util.Queue;

import java.io.IOException;

import java.io.FileOutputStream;

import java.util.StringTokenizer;



/**

 * Built using CHelper plug-in

 * Actual solution is at the top

 */

public class Main {

    public static void main(String[] args) {

        InputStream inputStream;

        try {

            inputStream = new FileInputStream(""input.txt"");

        } catch (IOException e) {

            throw new RuntimeException(e);

        }

        OutputStream outputStream;

        try {

            outputStream = new FileOutputStream(""output.txt"");

        } catch (IOException e) {

            throw new RuntimeException(e);

        }

        InputReader in = new InputReader(inputStream);

        PrintWriter out = new PrintWriter(outputStream);

        TaskC solver = new TaskC();

        solver.solve(1, in, out);

        out.close();

    }

}



class TaskC {

    public void solve(int testNumber, InputReader in, PrintWriter out) {

        int n = in.nextInt();

        int m = in.nextInt();

        int k = in.nextInt();

        Queue<Point> points = new LinkedList<Point>();

        int[][] burnTime = new int[n][m];

        boolean[][] visited = new boolean[n][m];

        for (int i = 0; i < k; i++) {

            int x = in.nextInt() - 1;

            int y = in.nextInt() - 1;

            visited[x][y] = true;

            burnTime[x][y] = 0;

            points.add(new Point(x, y));



        }

        int[] dx = new int[]{-1, 0, 0, 1};

        int[] dy = new int[]{0, -1, 1, 0};

        while (points.size() != 0) {

            Point cur = points.poll();

            int x = cur.x;

            int y = cur.y;

            for (int i = 0; i < dx.length; i++) {

                int nextX = x + dx[i];

                int nextY = y + dy[i];

                if (nextX >= 0 && nextX < n && nextY >= 0 && nextY < m && (burnTime[x][y] + 1 < burnTime[nextX][nextY] || !visited[nextX][nextY])) {

                    points.add(new Point(nextX, nextY));

                    visited[nextX][nextY] = true;

                    burnTime[nextX][nextY] = burnTime[x][y] + 1;

                }

            }

        }

        int x, y;

        x = y = 0;

        for (int i = 0; i < n; i++) {

            for (int j = 0; j < m; j++) {

                if (burnTime[i][j] > burnTime[x][y]) {

                    x = i;

                    y = j;

                }

            }

        }

        out.printf(""%d %d"", x + 1, y + 1);

    }

}



class Point {

    int x;

    int y;



    public Point(int x, int y) {

        this.x = x;

        this.y = y;

    }

}



class InputReader {

    public BufferedReader reader;

    public StringTokenizer tokenizer;



    public InputReader(InputStream stream) {

        reader = new BufferedReader(new InputStreamReader(stream), 32768);

        tokenizer = null;

    }



    public String next() {

        while (tokenizer == null || !tokenizer.hasMoreTokens()) {

            try {

                tokenizer = new StringTokenizer(reader.readLine());

            } catch (IOException e) {

                throw new RuntimeException(e);

            }

        }

        return tokenizer.nextToken();

    }



    public int nextInt() {

        return Integer.parseInt(next());

    }



}

",6,5
"import java.io.IOException;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.util.ArrayDeque;
import java.io.PrintWriter;
import java.io.FileInputStream;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Zyflair Griffane
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream;
		try {
			inputStream = new FileInputStream(""input.txt"");
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		OutputStream outputStream;
		try {
			outputStream = new FileOutputStream(""output.txt"");
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		PandaScanner in = new PandaScanner(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		C solver = new C();
		solver.solve(1, in, out);
		out.close();
	}
}

class C {
    final int dx[] = { -1, 0, 1, 0};
    final int dy[] = { 0, -1, 0, 1};
    final int SHIFT = 15;
    final int COLUMN_MASK = (1 << SHIFT) - 1;
    public void solve(int testNumber, PandaScanner in, PrintWriter out) {
        int n = in.nextInt();
        int m = in.nextInt();
        boolean burning[][] = new boolean[n][m];
        int k = in.nextInt();
        ArrayDeque<Integer> q = new ArrayDeque<>();
        for (int i = 0; i < k; i++) {
            int x = in.nextInt() - 1;
            int y = in.nextInt() - 1;
            burning[x][y] = true;
            q.add((x << SHIFT) + y);
        }
        int last = 0;
        while (!q.isEmpty()) {
            last = q.poll();
            int x = last >> SHIFT;
            int y = last & COLUMN_MASK;
            for (int d = 0; d < 4; d++) {
                int nx = x + dx[d];
                int ny = y + dy[d];
                if (nx >= 0 && nx < n && ny >= 0 && ny < m && !burning[nx][ny]) {
                    burning[nx][ny] = true;
                    q.add((nx << SHIFT) + ny);
                }
            }
        }
        out.printf(""%d %d\n"", (last >> SHIFT) + 1, (last & COLUMN_MASK) + 1);
    }
}

class PandaScanner {
    public BufferedReader br;
    public StringTokenizer st;
    public InputStream in;

    public PandaScanner(InputStream in) {
        br = new BufferedReader(new InputStreamReader(this.in = in));
    }

    public String nextLine() {
        try {
            return br.readLine();
        }
        catch (Exception e) {
            return null;
        }
    }

    public String next() {
        if (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(nextLine().trim());
            return next();
        }
        return st.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    }

",6,3
"import java.io.*;
import java.util.*;


public class Main {

    static boolean used[][];
    static int n;
    static int m;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new FileReader(""input.txt""));
        PrintWriter out = new PrintWriter(""output.txt"");
        n = nextInt();
        m = nextInt();
        int k = nextInt();
        used = new boolean[n][m];
        Deque<point> deq = new ArrayDeque<>();
        for (int i = 0; i < k; i++) {
            deq.addLast(new point(nextInt() - 1, nextInt() - 1));
            used[deq.peekLast().x][deq.peekLast().y] = true;
        }
        point last = new point(0, 0);
        while (!deq.isEmpty()) {
            point v = deq.pollFirst();
            int x = v.x;
            int y = v.y;
            if (checker(x, y + 1)) {
                last = new point(x, y + 1);
                deq.addLast(new point(x, y + 1));
                used[x][y + 1] = true;
            }
            if (checker(x, y - 1)) {
                last = new point(x, y - 1);
                deq.addLast(new point(x, y - 1));
                used[x][y - 1] = true;
            }
            if (checker(x + 1, y)) {
                last = new point(x + 1, y);
                deq.addLast(new point(x + 1, y));
                used[x + 1][y] = true;
            }
            if (checker(x - 1, y)) {
                last = new point(x - 1, y);
                deq.addLast(new point(x - 1, y));
                used[x - 1][y] = true;
            }
        }
        out.println(last.x + 1 + "" "" + (last.y + 1));
        out.close();
    }

    static boolean checker(int x, int y) {
        if (x < n && y < m && x >= 0 && y >= 0 && !used[x][y]) return true;
        return false;
    }


    static StringTokenizer st = new StringTokenizer("""");
    static BufferedReader br;

    static String next() throws IOException {
        while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());
        return st.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    static long nextLong() throws IOException {
        return Long.parseLong(next());
    }
}

class point {
    int x, y;

    public point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}",6,3
"

import java.awt.Point;

import java.io.*;

import java.util.Arrays;

import java.util.LinkedList;

import java.util.Queue;



import static java.lang.Integer.*;

import static java.lang.Math.*;

@SuppressWarnings(""unused"")

public class round35C {

    static class state{

        int x, y, time;

        public state(int xx, int yy, int t){

            x = xx;

            y = yy;

            time = t;

        }

    }

    static int N,M;

    static int [] dx = new int [] {1,-1,0,0};

    static int [] dy = new int [] {0,0,1,-1};

    static Queue<state> bfs = new LinkedList<round35C.state>();

    public static Point runBFS(){

        boolean [][] vis = new boolean [N + 1][M + 1];

        int max = -(int)1e9;

        int bestx = -1;

        int besty = -1;

        while(!bfs.isEmpty()){

            state p = bfs.poll();

            int x = p.x;

            int y = p.y;

            int time = p.time;

            if(vis[x][y])

                continue;

            vis[x][y] = true;

            if(time > max){

                max = time;

                bestx = x + 1;

                besty = y + 1;

            }

            for(int i = 0 ; i < 4 ; ++i){

                int nx = x + dx[i];

                int ny = y + dy[i];

                if(nx < 0 || ny < 0 || nx >= N || ny >= M)

                    continue;

                if(vis[nx][ny] == false)

                    bfs.offer(new state(nx, ny, time + 1));

            }

        }

        return new Point(bestx, besty);

    }

    public static void main(String[] args)throws IOException {

        BufferedReader br = new BufferedReader(new FileReader(""input.txt""));

        PrintWriter out = new PrintWriter(""output.txt"");

        String [] use = null;

        use = br.readLine().split("" "");

        N = parseInt(use[0]);

        M = parseInt(use[1]);

        int K = parseInt(br.readLine());

        use = br.readLine().split("" "");

        for(int i = 0 ; i < 2 * K ; i += 2){

            int f = parseInt(use[i]) - 1;

            int t = parseInt(use[i + 1]) - 1;

            bfs.offer(new state(f, t, 0));

        }

        Point ans = runBFS();

        out.println(ans.x + "" "" + ans.y);

        out.flush();

        out.close();

    }



}

",6,3
"import java.awt.Point;

import java.io.BufferedReader;

import java.io.File;

import java.io.FileReader;

import java.io.FileWriter;

import java.io.IOException;

import java.io.InputStreamReader;



public class Contest35_3 {

    public static void main(String[] args) throws IOException {

        BufferedReader in = new BufferedReader(new FileReader(""input.txt""));

        String[] s = in.readLine().split("" "");

        int n = Integer.parseInt(s[0]);

        int m = Integer.parseInt(s[1]);

        int k = Integer.parseInt(in.readLine());

        s = in.readLine().split("" "");

        Point[] inp = new Point[k];

        int p = 0;

        for (int i = 0; i < k; i++) {

            inp[i] = new Point(Integer.parseInt(s[p++]),

                    Integer.parseInt(s[p++]));

        }

        int max = -1;

        int maxx = -1;

        int maxy = -1;

        int i;

        int j, dist;

        for (i = 1; i <= n; i++) {

            for (j = 1; j <= m; j++) {

                dist = 1000000;

                for (int l = 0; l < inp.length; l++) {

                    dist = Math.min(

                            Math.abs(inp[l].x - i) + Math.abs(inp[l].y - j),

                            dist);

                }

                if (dist > max) {

                    max = dist;

                    maxx = i;

                    maxy = j;

                }

            }

        }

        String res = maxx + "" "" + maxy + ""\n"";

        FileWriter out = new FileWriter(new File(""output.txt""));

        out.append(res);

        out.flush();

        out.close();

    }

}",6,5
"

import java.io.*;

import java.util.*;

import java.math.*;

import static java.lang.Math.*;

import static java.lang.Integer.parseInt;

import static java.lang.Long.parseLong;

import static java.lang.Double.parseDouble;

import static java.lang.String.*;



public class Main {



    public static void main(String[] args) throws IOException {



        BufferedReader in = new BufferedReader//(new InputStreamReader(System.in));

                                            (new FileReader(""input.txt""));

        StringBuilder out = new StringBuilder();

        StringTokenizer tk;

        PrintWriter pw = new PrintWriter(""output.txt"", ""UTF-8"");

        

        int [] dx = {-1,1,0,0},dy = {0,0,-1,1};

        

        tk = new StringTokenizer(in.readLine());

        int n = parseInt(tk.nextToken()),m = parseInt(tk.nextToken());

        int k = parseInt(in.readLine());

        

        int [][] dist = new int[n][m];

        for(int i=0; i<n; i++) 

            Arrays.fill(dist[i], -1);

        

        int ans = -1,atx = -1,aty = -1;

        

        Queue<point> q = new LinkedList<point>();

        

        tk = new StringTokenizer(in.readLine());

        while(k-- > 0) {

            int x = parseInt(tk.nextToken())-1,y = parseInt(tk.nextToken())-1;

            

            dist[x][y] = 0;

            q.add(new point(x,y));

        }

        

        while(!q.isEmpty()) {

            point p = q.remove();

            

            if(dist[p.x][p.y]>ans) {

                ans = dist[p.x][p.y];

                atx = p.x+1;

                aty = p.y+1;

            }

            

            for(int i=0; i<4; i++) {

                int nx = p.x + dx[i];

                int ny = p.y + dy[i];

                

                if(nx>=0 && nx<n && ny>=0 && ny<m && dist[nx][ny]==-1) {

                    dist[nx][ny] = dist[p.x][p.y] + 1;

                    q.add(new point(nx,ny));

                }

            }

        }

        

        pw.println(atx+"" ""+aty);

        pw.close();

    }

   

}



class point {

    int x,y;

    

    public point(int x,int y) {

        this.x = x;

        this.y = y;

    }

}",6,3
"import java.io.*;

import java.util.*;

import static java.lang.Math.*;



public class Solution {



    BufferedReader in;

    StringTokenizer st;

    PrintWriter out;



    int n, m, k;

    int[] x, y;



    char[] qx = new char[4000000], qy = new char[4000000];

    int b, e;



    char[][] d;



    int[] dx = { -1, 0, 1, 0 }, dy = { 0, -1, 0, 1 };



    void bfs() {

        b = e = 0;

        for (int i = 0; i < d.length; i++) {

            Arrays.fill(d[i], (char)(1 << 14));

        }

        for (int i = 0; i < k; ++i) {

            qx[e] = (char) x[i];

            qy[e++] = (char) y[i];

            d[x[i]][y[i]] = 0;

        }

        for (; b < e; ++b) {

            int x = qx[b];

            int y = qy[b];

            for (int i = 0; i < 4; ++i) {

                int nx = x + dx[i];

                int ny = y + dy[i];

                if (nx >= 0 && nx < n && ny >= 0 && ny < m)

                    if (d[nx][ny] > d[x][y] + 1) {

                        d[nx][ny] = (char) (d[x][y] + 1);

                        qx[e] = (char) nx;

                        qy[e++] = (char) ny;

                    }

            }

        }

    }



    void solve() throws IOException {

        n = ni();

        m = ni();

        k = ni();

        x = new int[k];

        y = new int[k];

        for (int i = 0; i < k; ++i) {

            x[i] = ni() - 1;

            y[i] = ni() - 1;

        }

        d = new char[n][m];

        bfs();

        int x = -1, y = -1, last = -1;

        for (int i = 0; i < n; ++i)

            for (int j = 0; j < m; ++j)

                if (d[i][j] > last) {

                    last = d[i][j];

                    x = i;

                    y = j;

                }

        ++x;

        ++y;

        out.println(x + "" "" + y);

    }



    public Solution() throws IOException {

        Locale.setDefault(Locale.US);

        in = new BufferedReader(new FileReader(""input.txt""));

        out = new PrintWriter(""output.txt"");

        solve();

        in.close();

        out.close();

    }



    String nline() throws IOException {

        return in.readLine();

    }



    String ns() throws IOException {

        while (st == null || !st.hasMoreTokens()) {

            st = new StringTokenizer(nline());

        }

        return st.nextToken();

    }



    int ni() throws IOException {

        return Integer.valueOf(ns());

    }



    long nl() throws IOException {

        return Long.valueOf(ns());

    }



    double nd() throws IOException {

        return Double.valueOf(ns());

    }



    public static void main(String[] args) throws IOException {

        new Solution();

    }

}

",6,5
"import java.io.*;

import java.util.*;



import static java.lang.Math.*;



public class incendio {

    void dbg(Object...os) { System.err.println(Arrays.deepToString(os)); }

    static StringTokenizer _stk; static BufferedReader input; static PrintWriter output; 

    static String next(){return _stk.nextToken();} static int nextInt(){return Integer.parseInt(next());}

    static String readln()throws IOException {String l=input.readLine();_stk=l==null?null:new StringTokenizer(l,"" "");return l;}

    public static void main(String[] args) throws IOException {

        input = new BufferedReader(new FileReader(""input.txt"")); 

        output = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));

        new incendio();

        output.close();

    }



    

    incendio() throws IOException {

        readln();

        M = nextInt(); N = nextInt();

        readln();

        final int K = nextInt();

        int xf[]=new int[K], yf[]=new int[K];

        readln();

        for(int i=0; i<K; i++) {

            xf[i]=nextInt();

            yf[i]=nextInt();

        }

        

        int best=-1, xbest=0, ybest=0;

        for(int i=1; i<=M; i++) {

            for(int j=1; j<=N; j++) {

                int dist=Integer.MAX_VALUE;

                for(int k=0; k<K; k++) {

                    dist = Math.min(dist, Math.abs(i-xf[k])+Math.abs(j-yf[k]));

                }

                if(dist>best) {

                    best=dist;

                    xbest=i;

                    ybest=j;

                }

            }

        }

        output.println(xbest+"" ""+ybest);

    }

    

    int M, N;

}",6,5
"import java.io.File;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;
 
public class C {
	Scanner in;
	PrintWriter out;
//	String INPUT = ""3 3 1 1 1"";
	String INPUT = """";
	
	void solve()
	{
		int n = ni();
		int m = ni();
		int k = ni();
	    int[][] f=new int[k][2];
        		
        		for(int i=0;i<k;i++) {
        			f[i][0]=ni()-1;
        			f[i][1]=ni()-1;
        		}
        		int mx=-1;
        		int resx=0;
        		int resy=0;        		
        		
        		for(int i=0;i<n;i++) {
        			for(int j=0;j<m;j++) {
        				int min=Integer.MAX_VALUE;
        				for(int l=0;l<k;l++) {
        					min=Math.min(min, Math.abs(f[l][0]-i)+Math.abs(f[l][1]-j));
        				}
        				if(min>mx) {
        					mx=min;
        					resx=i;
        					resy=j;
        				}
        			}
        			
        		}
        		out.println((resx+1)+"" ""+(resy+1));
        		
	}

	void run() throws Exception
	{
		in = INPUT.isEmpty() ? new Scanner(new File(""input.txt"")) : new Scanner(INPUT);
		out = INPUT.isEmpty() ? new PrintWriter(""output.txt"") : new PrintWriter(System.out);
 
		solve();
		out.flush();
	}
	
	
	public static void main(String[] args) throws Exception
	{
		new C().run();
	}
	
	int ni() { return Integer.parseInt(in.next()); }
	void tr(Object... o) { if(INPUT.length() != 0)System.out.println(o.length > 1 || o[0].getClass().isArray() ? Arrays.deepToString(o) : o[0]); }
	static String join(int[] a, int d){StringBuilder sb = new StringBuilder();for(int v : a){sb.append(v + d + "" "");}return sb.toString();}
}",6,5
"
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Scanner;

/**
 * @author igor_kz
 */
public class C35 {
    public static void main(String[] args) throws IOException {
        Scanner in = new Scanner(new File(""input.txt""));
        PrintWriter out = new PrintWriter(""output.txt"");
        int n = in.nextInt() , m = in.nextInt();
        int k = in.nextInt();
        int[] x = new int[k];
        int[] y = new int[k];
        int res = 0;
        for (int i = 0 ; i < k ; i++) {
            x[i] = in.nextInt();
            y[i] = in.nextInt();
        }
        int xx = 1 , yy = 1;
        for (int i = 1 ; i <= n ; i++)
            for (int j = 1 ; j <= m ; j++) {
                int cnt = Integer.MAX_VALUE;
                for (int l = 0 ; l < k ; l++) {
                    int time = Math.abs(i - x[l]) + Math.abs(j - y[l]);
                    cnt = Math.min(cnt , time);
                }
                if (cnt > res) {
                    res = cnt;
                    xx = i;
                    yy = j;
                }
                res = Math.max(res , cnt);
            }
        out.print(xx + "" "" + yy);
        out.close();
    }
}
",6,5
"import java.io.BufferedReader;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.IOException;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.*;



public class Solution implements Runnable {

  BufferedReader in;

  PrintWriter out;

  StringTokenizer tok = new StringTokenizer("""");



  @Override

  public void run() {

    try {

      init();

    } catch (FileNotFoundException e) {

      e.printStackTrace();

    }

    long time = System.currentTimeMillis();

    try {

      solve();

    } catch (Exception e) {

      e.printStackTrace();

    }

    out.close();

    //System.err.println(System.currentTimeMillis() - time);

  }



  private void init() throws FileNotFoundException {

    String file = ""123"";

    if (!file.equals("""")) {

      in = new BufferedReader(new FileReader(""input.txt""));

      out = new PrintWriter(""output.txt"");

    } else {

      in = new BufferedReader(new InputStreamReader(System.in));

      out = new PrintWriter(System.out);

    }

  }



  public static void main(String[] args) {

    new Thread(new Solution()).start();

  }



  private String readString() {

    while (!tok.hasMoreTokens()) {

      try {

        tok = new StringTokenizer(in.readLine());

      } catch (IOException e) {

        e.printStackTrace();

      }

    }

    return tok.nextToken();

  }



  private int readInt() {

    return Integer.parseInt(readString());

  }



  int[] counts = new int[1000];



  private long readLong() {

    return Long.parseLong(readString());

  }



  private void solve() {

    int n = readInt()+2;

    int m = readInt()+2;

    boolean[][] graph = new boolean[n][m];

    for (int i = 0; i < n; i++) {

      graph[i][m-1] = true;

      graph[i][0] = true;

    }

    for (int i = 0; i < m; i++) {

      graph[n-1][i] = true;

      graph[0][i] = true;

    }

    int k = readInt();

    int inFire = 0;

    Queue<Point> q = new ArrayDeque<>();

    for (int i = 0; i < k; i++) {

      int x = readInt();

      int y = readInt();

      Point p = new Point(x, y);

      graph[x][y] = true;

      q.add(p);

    }

    while (!q.isEmpty()) {

      Point current = q.poll();

      inFire++;

      if(!graph[current.x+1][current.y]) {

        graph[current.x+1][current.y] = true;

        q.add(new Point(current.x+1, current.y));

      }

      if(!graph[current.x-1][current.y]) {

        graph[current.x-1][current.y] = true;

        q.add(new Point(current.x-1, current.y));

      }

      if(!graph[current.x][current.y+1]) {

        graph[current.x][current.y+1] = true;

        q.add(new Point(current.x, current.y+1));

      }

      if(!graph[current.x][current.y-1]) {

        graph[current.x][current.y-1] = true;

        q.add(new Point(current.x, current.y-1));

      }

      if(q.isEmpty()) {

        out.print(current.x+"" ""+current.y);

        return;

      }

    }





  }



  class Point{

    int x, y;



    public Point(int x, int y) {

      this.x = x;

      this.y = y;

    }

  }

}",6,3
"import java.util.*;

import java.io.*;



public class C{

	public static void main(String args[]) throws Exception{

		Scanner in = new Scanner(new FileReader(""input.txt""));

		PrintWriter out = new PrintWriter(new File(""output.txt""));



		int N = in.nextInt();

		int M = in.nextInt();

		int K = in.nextInt();



		int[] X = new int[K], Y = new int[K];

		for (int i = 0; i < K; i++){

			X[i] = in.nextInt();

			Y[i] = in.nextInt();

		}



		int d = -1;

		int a = -1; int b = -1;

		for (int i = 1; i <= N; i++)

			for (int j = 1; j <= M; j++){

				int h = Integer.MAX_VALUE;

				for (int p = 0; p < K; p++)

					h = Math.min(h,Math.abs(i-X[p]) + Math.abs(j-Y[p]));

				if (h > d){

					d = h; a = i; b = j;

				}

			}





		out.print(a + "" "" + b);

		out.close();

	}

}",6,5
"import java.util.*;

import java.io.*;

import java.math.*;

public class Main {

    public static InputStream IN;

    public static OutputStream OUT;

    public static PrintWriter out;

    public static BufferedReader in;

    

    public static StringTokenizer st = null;

    public static int ni() throws Exception {

        for (;st == null || !st.hasMoreTokens();){

            st = new StringTokenizer(in.readLine());

        }

        return Integer.parseInt(st.nextToken());

    }

    public static void main(String[] args) throws Exception {

        IN = new FileInputStream(""input.txt"");

        OUT = new FileOutputStream(""output.txt"");

        out = new PrintWriter(OUT);

        in = new BufferedReader(new InputStreamReader(IN));

        int n = ni();

        int m = ni();

        int k = ni();

        int[] x = new int[k];

        int[] y = new int[k];

        for (int i = 0 ; i < k; i++){

            x[i] = ni() - 1;

            y[i] = ni() - 1;

        }

        int w = Integer.MIN_VALUE;

        int aa = -1;

        int ab = -1;

        for (int i = 0 ; i < n ; i++){

            for (int j = 0; j < m; j++){

                int min = Integer.MAX_VALUE;

                for (int q = 0; q < k; q++){

                    int cur = Math.abs(i - x[q]) + Math.abs(j - y[q]);

                    min = Math.min(cur, min);

                }

                if (min > w){

                    w = min;

                    aa = i;

                    ab = j;

                }

            }

        }

        out.println((aa + 1) + "" "" + (ab + 1));

        

        out.flush();

    }

}

",6,5
"import java.io.BufferedReader;

import java.io.File;

import java.io.FileReader;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.LinkedList;

import java.util.Queue;

import java.util.StringTokenizer;

//import java.util.Scanner;



public class Codes {



	public static void main(String[] args) throws IOException {

		InputReader input = new InputReader(new FileReader((""input.txt"")));

		int n = input.nextInt();

		int m = input.nextInt();

		int k = input.nextInt();

		boolean[][] visited = new boolean[n][m];

		Queue<Point> bfs = new LinkedList<Point>();

		for (int i = 0; i < k; i++) {

			int x = input.nextInt();

			int y = input.nextInt();

			visited[x - 1][y - 1] = true;

			bfs.add(new Point(x - 1, y - 1));

		}

		Point last = bfs.peek();

		while(!bfs.isEmpty()) {

			Point current = bfs.poll();

			int curX = current.x;

			int curY = current.y;

			//the upper tree

			if(curX - 1 >= 0) {

				if(!visited[curX - 1][curY]) {

					bfs.add(new Point(curX - 1,curY));

					visited[curX - 1][curY] = true;

				}

			}

			//the tree to the right

			if(curY + 1 < m) {

				if(!visited[curX][curY + 1]) {

					bfs.add(new Point(curX ,curY + 1));

					visited[curX][curY + 1] = true;

				}

			}

			//the lower tree

			if(curX + 1 < n) {

				if(!visited[curX + 1][curY]) {

					bfs.add(new Point(curX + 1,curY));

					visited[curX + 1][curY] = true;

				}

			}

			//the point to the left

			if(curY - 1 >= 0) {

				if(!visited[curX][curY - 1]) {

					bfs.add(new Point(curX ,curY - 1));

					visited[curX][curY - 1] = true;

				}

			}

			if(bfs.peek()!= null)

			last = bfs.peek();

		}

		PrintWriter out = new PrintWriter(new File(""output.txt""));

		out.println((last.x + 1) + "" "" + (last.y + 1));

		out.close();

		//System.out.println((last.x + 1) + "" "" + (last.y + 1));

	}



	static class Point {

		int x;

		int y;



		public Point(int x2, int y2) {

			x = x2;

			y = y2;

			

		}

	}



	/**

	 * This reader class is NOT Mine.

	 **/

	static class InputReader {

		private BufferedReader reader;

		private StringTokenizer tokenizer;



		public InputReader(InputStream stream) {

			reader = new BufferedReader(new InputStreamReader(stream));

			tokenizer = null;

		}



		public InputReader(FileReader stream) {

			reader = new BufferedReader(stream);

			tokenizer = null;

		}



		public String nextLine() {

			try {

				return reader.readLine();

			} catch (IOException e) {

				// TODO Auto-generated catch block

				e.printStackTrace();

				return null;

			}

		}



		public String next() {

			while (tokenizer == null || !tokenizer.hasMoreTokens()) {

				try {

					tokenizer = new StringTokenizer(reader.readLine());

				} catch (IOException e) {

					throw new RuntimeException(e);

				}

			}

			return tokenizer.nextToken();

		}



		public int nextInt() {

			return Integer.parseInt(next());

		}



		public long nextLong() {

			return Long.parseLong(next());

		}



		public double nextDouble() {

			return Double.parseDouble(next());

		}

	}



}

",6,3
"import java.util.*;
import java.io.*;

public class readFromFile {

	public static void main(String[] args) throws Exception {
		File file = new File(""input.txt"");
		Scanner sc = new Scanner(file);
		
		
		int n=sc.nextInt(),m=sc.nextInt();
		int k=sc.nextInt();
		int dist[][]=new int[n][m];
		for(int i=0;i<n;i++)
			Arrays.fill(dist[i], -1);
		ArrayDeque<Integer> x=new ArrayDeque<>(),y=new ArrayDeque<>();
		for(int i=0;i<k;i++) {
			int xi=sc.nextInt()-1,yi=sc.nextInt()-1;
			dist[xi][yi]=0;
			x.add(xi);
			y.add(yi);
		}
		int xd[]= {1,-1,0,0},yd[]= {0,0,1,-1};
		while(!x.isEmpty()) {
			int xs=x.remove(),ys=y.remove();
			for(int i=0;i<4;i++) {
				int x_to=xs+xd[i],y_to=ys+yd[i];
				if(legal(x_to,y_to,dist)) {
					dist[x_to][y_to]=dist[xs][ys]+1;
					x.add(x_to);
					y.add(y_to);
				}
			}
		}
		int ans=-1,xc=0,yc=0;
		for(int i=0;i<n;i++) {
			for(int j=0;j<m;j++) {
				if(dist[i][j]>ans) {
					ans=dist[i][j];
					xc=i+1;
					yc=j+1;
				}
			}
		}
		StringBuilder r=new StringBuilder();
		r.append(xc+"" "");
		r.append(yc);
		String result=r.substring(0);
		
		
		
		try {
			FileWriter writer = new FileWriter(""output.txt"");
			writer.write(result);
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	static boolean legal(int x,int y,int a[][]) {
		return x>=0 && y>=0 && x<a.length && y<a[0].length && a[x][y]==-1;
	}
	

}
",6,5
"//package round35;

import java.io.File;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;

public class C {
	Scanner in;
	PrintWriter out;
//	String INPUT = ""3 3 1 1 1"";
	String INPUT = """";
	
	void solve()
	{
		int n = ni();
		int m = ni();
		int k = ni();
		int[] x = new int[k];
		int[] y = new int[k];
		for(int i = 0;i < k;i++){
			x[i] = ni() - 1;
			y[i] = ni() - 1;
		}
		int max = -1;
		int maxi = -1;
		int maxj = -1;
		for(int i = 0;i < n;i++){
			for(int j = 0;j < m;j++){
				int min = Integer.MAX_VALUE;
				for(int l = 0;l < k;l++){
					min = Math.min(min, Math.abs(x[l] - i) + Math.abs(y[l] - j));
				}
				if(min > max){
					max = min;
					maxi = i;
					maxj = j;
				}
			}
		}
		
		out.println((maxi+1) + "" "" + (maxj+1));
	}
	
	void run() throws Exception
	{
		in = INPUT.isEmpty() ? new Scanner(new File(""input.txt"")) : new Scanner(INPUT);
		out = INPUT.isEmpty() ? new PrintWriter(""output.txt"") : new PrintWriter(System.out);

		solve();
		out.flush();
	}
	
	
	public static void main(String[] args) throws Exception
	{
		new C().run();
	}
	
	int ni() { return Integer.parseInt(in.next()); }
	void tr(Object... o) { if(INPUT.length() != 0)System.out.println(o.length > 1 || o[0].getClass().isArray() ? Arrays.deepToString(o) : o[0]); }
	static String join(int[] a, int d){StringBuilder sb = new StringBuilder();for(int v : a){sb.append(v + d + "" "");}return sb.toString();}
}
",6,5
"import java.util.*;
import java.io.*;

public class Main {
	public static void main(String [] args) throws IOException{
		Scanner in = new Scanner(new FileInputStream(""input.txt""));
		//Scanner in = new Scanner(System.in);
		File file = new File(""output.txt"");
		FileOutputStream fos = new FileOutputStream(file);
		if (!file.exists()) {
		     file.createNewFile();
		}
		
		int N = in.nextInt();
		int M = in.nextInt();
		int K = in.nextInt();
		int [][] fireTime = new int[N][M];
		for (int i=0; i<K; i++){
			int x = in.nextInt()-1;
			int y = in.nextInt()-1;
			fireTime[x][y] = -1;
			
			for (int j=1; j<=x+y; j++){
				for (int p=0; p<=j; p++){
					if (x-j+p >= 0 && y-p >=0 && (fireTime[x-j+p][y-p] == 0 || fireTime[x-j+p][y-p] > j)){
						fireTime[x-j+p][y-p] = j;
					}
				}
			}
			
			for (int j=1; j<=x+M-1-y; j++){
				for (int p=0; p<=j; p++){
					if (x-j+p >= 0 && y+p < M && (fireTime[x-j+p][y+p] == 0 || fireTime[x-j+p][y+p] > j)){
						fireTime[x-j+p][y+p] = j;
					}
				}
			}
			
			for (int j=1; j<=N-1-x+y; j++){
				for (int p=0; p<j; p++){
					if (x+j-p < N && y-p >= 0 && (fireTime[x+j-p][y-p] == 0 || fireTime[x+j-p][y-p] > j)){
						fireTime[x+j-p][y-p] = j;
					}
				}
			}
			
			for (int j=1; j<=N-1-x+M-1-y; j++){
				for (int p=0; p<=j; p++){
					//System.out.println(j+"" ""+p);
					if (x+j-p < N && y+p < M && (fireTime[x+j-p][y+p] == 0 || fireTime[x+j-p][y+p] > j)){
						//System.out.println(j);
						fireTime[x+j-p][y+p] = j;
					}
				}
			}
		}
		
		int max = -1;
		int tx = 1;
		int ty = 1;
		for (int i=0; i<N; i++){
			for (int j=0; j<M; j++){
				//System.out.print(fireTime[i][j]+"" "");
				if (fireTime[i][j] > max){
					max = fireTime[i][j];
					tx = i+1;
					ty = j+1;
				}
			}
			//System.out.println();
		}
		//System.out.println(tx+"" ""+ty);
		String output = tx+"" ""+ty;
		
		byte[] bA = output.getBytes();
		fos.write(bA);
		fos.flush();
	}
}

		      	 			   		 	 		 	 	",6,6
"
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {

    static class Point {
        int x;
        int y;

        Point(int a, int b) {
            x = a;
            y = b;
        }

        @Override
        public String toString() {
            return ""Point{"" +
                    ""x="" + x +
                    "", y="" + y +
                    '}';
        }
    }

    public static void main(String[] args) throws IOException {
        File f = new File(""input.txt"");
        Scanner sc = new Scanner(f);
        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(""output.txt"")));
        int n = sc.nextInt();
        int m = sc.nextInt();
        boolean[][] board = new boolean[n][m];
        int count = sc.nextInt();
        Point[] burningTrees = new Point[count];
        for (int i=0; i<count; i++) {
            burningTrees[i] = new Point(sc.nextInt() - 1,sc.nextInt() - 1);
        }
        Point last = findLastPoint(board,burningTrees);
        bw.append((last.x + 1) + "" "" + (last.y + 1) + ""\n"");
        bw.flush();
        bw.close();
        sc.close();
    }



    public static Point findLastPoint(boolean[][] board,  Point[] burningTree){
        Queue<Point> queue = new LinkedList<Point>();
        for(int i = 0; i <burningTree.length; i++ ) {
            queue.add(burningTree[i]);
            board[burningTree[i].x][burningTree[i].y] = true;
        }
        Point lastPoint = new Point(-1,-1);
        while (!queue.isEmpty()) {
            Point p = queue.poll();
            lastPoint = p;
            ArrayList<Point> neighbours = getNeighbours(p,board);
            for(int i = 0; i <neighbours.size(); i++ ) {
                queue.add(neighbours.get(i));
                board[neighbours.get(i).x][neighbours.get(i).y] = true;
            }
        }
        return lastPoint;
    }

    public static ArrayList<Point> getNeighbours(Point p, boolean[][] board){
        ArrayList<Point> neighbours = new ArrayList<>();
        for(int i = -1; i <=1; i++ ){
            for(int j = -1; j <= 1; j++ ){
                if(Math.abs(i) != Math.abs(j)) {
                    int x = p.x + i;
                    int y = p.y + j;
                    if (x >= 0 && x < board.length && y >= 0 && y < board[0].length) {
                        if (board[x][y] == false) {
                            neighbours.add(new Point(x,y));
                        }
                    }
                }
            }
        }
        return neighbours;
    }
}
",6,3
"import java.io.*;

import java.util.*;



public class C

{

	String line;

	StringTokenizer inputParser;

	BufferedReader is;

	FileInputStream fstream;

	DataInputStream in;

	

	void openInput(String file)

	{



		if(file==null)is = new BufferedReader(new InputStreamReader(System.in));//stdin

		else

		{

			try{

		

				

			fstream = new FileInputStream(file);

			in = new DataInputStream(fstream);

			is = new BufferedReader(new InputStreamReader(in));

			}catch(Exception e)

			{

				System.err.println(e);

			}

		}



	}

	

	void readNextLine()

	{

		try {

			line = is.readLine();

			inputParser = new StringTokenizer(line, "" "");

			//System.err.println(""Input: "" + line);

		} catch (IOException e) {

			System.err.println(""Unexpected IO ERROR: "" + e);

		}	

		

	}

	

	int NextInt()

	{

		String n = inputParser.nextToken();

		int val = Integer.parseInt(n);

		

		//System.out.println(""I read this number: "" + val);

		return val;

	}

	

	String NextString()

	{

		String n = inputParser.nextToken();

		return n;

	}

	

	void closeInput()

	{

		try {

			is.close();

		} catch (IOException e) {

			System.err.println(""Unexpected IO ERROR: "" + e);

		}

			

	}

	

	

	public static void main(String [] argv)

	{

		String filePath=null;

		if(argv.length>0)filePath=argv[0];

		C c = new C(filePath);

	}

	

	public C(String inputFile)

	{

		inputFile=""input.txt"";

        openInput(inputFile);

        PrintWriter writer=null;

		try {

			writer = new PrintWriter(""output.txt"");

			

		} catch (FileNotFoundException e) {

			e.printStackTrace();

		}

		

		readNextLine();

		int N=NextInt();

		int M=NextInt();

		readNextLine();

		int K=NextInt();

		readNextLine();

		int [] [] p = new int[N][M];

		int [] [] init = new int [K][2];

		

		for(int i=0; i<K; i++)

		{

			int x=NextInt()-1;

			int y=NextInt()-1;

			p[x][y]=0;

			init[i][0]=x;

			init[i][1]=y;

		}

		

		int max=-1;

		int maxX=-1, maxY=-1;

		

		for(int i=0; i<N; i++)

			for(int j=0; j<M; j++)

			{

				p[i][j]=10000;

				for(int k=0; k<K; k++)

				{

					int n=Math.abs(init[k][0]-i)+Math.abs(init[k][1]-j);

					if(n<p[i][j])p[i][j]=n;

				}

				if(p[i][j]>max)

				{

					max=p[i][j];

					maxX=i+1;

					maxY=j+1;

				}

			}

		

		

	

		writer.println( maxX+"" ""+maxY);

		

		



		

		closeInput();

		writer.close();

	}



	

}



",6,5
"

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.PrintStream;

import java.util.Scanner;





public class P35C {

    int n, m;

    int [][]fire;

    public P35C() throws FileNotFoundException {

        Scanner in = new Scanner(new FileReader(""input.txt""));

        n = in.nextInt();

        m = in.nextInt();

        int k = in.nextInt();

        fire = new int[k][2];

        for (int i = 0; i < k; i++){

            fire[i][0] = in.nextInt();

            fire[i][1] = in.nextInt();

        }

        in.close();

        

        int []last = new int[2];

        int lastBurn = -1;

        for (int i = 1; i <= n; i++){

            for (int j = 1; j <= m; j++){

                int burn = Integer.MAX_VALUE;

                for (int l = 0; l < k; l++){

                    int burnAux = dist(i, j, fire[l][0], fire[l][1]);

                    burn = Math.min(burn, burnAux);

                }

                if(burn >= lastBurn){

                    lastBurn = burn;

                    last[0] = i;

                    last[1] = j;

                    

            }

            }

        }

        



        PrintStream out = new java.io.PrintStream( ""output.txt"" );

        out.print(last[0] + "" "" + last[1]);

        out.close();

    }

    

     int dist(int x1, int y1, int x2, int y2){

         return Math.abs(x2 - x1) + Math.abs(y2 - y1);

     }

    

    public static void main (String []args) throws FileNotFoundException{

        new P35C();

    }

}

",6,5
"import java.io.*;

import java.util.*;

public class j

{

public static void main(String a[])throws IOException

{

BufferedReader b = new BufferedReader(new FileReader(""input.txt""));

PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));

int l=0,x2=0,x=0,y1=0,y=0,max=-1,min=100000,x1=0,n=0,j=0,k=0,p=0,m=0,i=0;

String s;

s=b.readLine();

StringTokenizer c=new StringTokenizer(s);

n=Integer.parseInt(c.nextToken());

m=Integer.parseInt(c.nextToken());

k=Integer.parseInt(b.readLine());

int e[][]=new int[k][2];

s=b.readLine();

StringTokenizer z=new StringTokenizer(s);

for(i=0;i<k;i++)

{

e[i][0]=Integer.parseInt(z.nextToken());

e[i][1]=Integer.parseInt(z.nextToken());

}

for(i=1;i<=n;i++)

{

for(j=1;j<=m;j++)

{

for(l=0;l<k;l++)

{

p=(int)Math.abs(e[l][0]-i)+(int)Math.abs(e[l][1]-j);

if(p<min)

{

min=p;

x1=i;

y1=j;

}

}

if(min>max)

{

max=min;

x=x1;

y=y1;

}

min=100000;

}

}

out.print(x+"" ""+y);

out.close();

}

}",6,1
"

import java.io.*;

import java.math.*;

import java.util.*;



import static java.util.Arrays.fill;

import static java.lang.Math.*;

import static java.util.Arrays.sort;

import static java.util.Collections.sort;





public class C35 

{



	public static int mod = 1000000007;

	public static long INF = (1L << 60);



	static int n,m;

	static class Pair

	{

		int x,y;

		Pair(int x,int y)

		{

			this.x=x;

			this.y=y;

		}

	}

	static boolean[][] burned;

	static int[] dx={-1,0,1,0};

	static int[] dy={0,-1,0,1};

	static boolean isvalid(int x,int y)

	{

		return x>=0&&x<n&&y>=0&&y<m;

	}

	public static void main(String[] args) throws IOException

	{

		Scanner in = new Scanner(""input.txt"");

		PrintWriter out = new PrintWriter(new FileWriter(""output.txt""));

		n=in.nextInt();

		m=in.nextInt();

		burned=new boolean[n][m];

		int k=in.nextInt();

		Queue<Pair> queue=new LinkedList<>();

		Pair prev=null;

		for(int i=0;i<k;i++)

		{

			int x=in.nextInt();

			int y=in.nextInt();

			burned[x-1][y-1]=true;

			queue.add(prev=new Pair(x-1, y-1));

		}

		while(!queue.isEmpty())

		{

			Queue<Pair> tempqueue=new LinkedList<>();

		for(Pair p : queue)

		{

			int x=p.x;

			int y=p.y;

			prev=p;

			for(int i=0;i<4;i++)

			{

				if(isvalid(x+dx[i], y+dy[i])&&!burned[x+dx[i]][y+dy[i]])

				{

					tempqueue.add(new Pair(x+dx[i], y+dy[i]));

					burned[x+dx[i]][y+dy[i]]=true;

				}

			}

		}

		queue=tempqueue;

		}

		out.printf(""%d %d\n"",(prev.x+1),(prev.y+1));

		out.close();



	}

	

	public static long pow(long x, long n) 

	{

		long res = 1;

		for (long p = x; n > 0; n >>= 1, p = (p * p)) 

		{

			if ((n & 1) != 0) 

			{

				res = (res * p);

			}

		}

		return res;

	}

	

	public static long pow(long x, long n, long mod) 

	{

		long res = 1;

		for (long p = x; n > 0; n >>= 1, p = (p * p) % mod) 

		{

			if ((n & 1) != 0) 

			{

				res = (res * p % mod);

			}

		}

		return res;

	}



	public static long gcd(long n1, long n2)

	{

		long r;

		while (n2 != 0) 

		{

			r = n1 % n2;

			n1 = n2;

			n2 = r;

		}

		return n1;

	}



	public static long lcm(long n1, long n2) 

	{

		long answer = (n1 * n2) / (gcd(n1, n2));

		return answer;

	}



	static class Scanner 

	{

		StringTokenizer st;

		BufferedReader br;



		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

		

		public Scanner(String s) throws FileNotFoundException {	br = new BufferedReader(new FileReader(s));}



		public String next() throws IOException 

		{

			while (st == null || !st.hasMoreTokens()) 

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}



		public int nextInt() throws IOException {return Integer.parseInt(next());}



		public long nextLong() throws IOException {return Long.parseLong(next());}



		public String nextLine() throws IOException {return br.readLine();}



		public double nextDouble() throws IOException { return Double.parseDouble(next()); }



		public boolean ready() throws IOException {return br.ready();} 

	}

}



",6,3
"import java.io.*;

import java.util.*;



public class Solution implements Runnable {



	Scanner input;

	PrintWriter output;

	

	private void solve() throws Exception

	{

		int n = nextInt();

		int m = nextInt();

		int k = nextInt();

		int[] r = new int[k];

		int[] c = new int[k];

		for (int i = 0; i < k; i++)

		{

			r[i] = nextInt();

			c[i] = nextInt();

		}

		int best = -1;

		int bestr = -1;

		int bestc = -1;

		for (int i = 1; i <= n; i++)

		{

			for (int j = 1; j <= m; j++)

			{

				int d = n + m;

				for (int q = 0; q < k; q++)

				{

					d = Math.min(d, Math.abs(i - r[q]) + Math.abs(j - c[q]));

				}

				if (d < best) continue;

				best = d;

				bestr = i;

				bestc = j;

			}

		}

		out(bestr + "" "" + bestc);

	}



	private int nextInt() throws Exception

	{

		return input.nextInt();

	}

	

	private void out(String s)

	{

		output.println(s);

	}



	public void run() {

		try {

			solve();

		} catch (Exception ex) {

			throw new RuntimeException(ex);

		} finally {

			output.close();

		}

	}

	

	public Solution() throws IOException {

		input = new Scanner(new FileReader(""input.txt""));

		output = new PrintWriter(""output.txt"");

	}



	public static void main(String[] args) throws IOException {

		Locale.setDefault(Locale.US);

		new Thread(new Solution()).start();

	}

}

",6,5
"

import java.io.*;

import java.math.*;

import java.util.*;



import static java.util.Arrays.fill;

import static java.lang.Math.*;

import static java.util.Arrays.sort;

import static java.util.Collections.sort;





public class C35 

{



	public static int mod = 1000000007;

	public static long INF = (1L << 60);



	static int n,m;

	static class Pair

	{

		int x,y;

		Pair(int x,int y)

		{

			this.x=x;

			this.y=y;

		}

		@Override

		public int hashCode() 

		{

			final int prime = 31;

			int result = 1;

			result = prime * result + x;

			result = prime * result + y;

			return result;

		}

		@Override

		public boolean equals(Object obj) 

		{

			if (this == obj)

				return true;

			if (obj == null)

				return false;

			if (getClass() != obj.getClass())

				return false;

			Pair other = (Pair) obj;

			if (x != other.x)

				return false;

			if (y != other.y)

				return false;

			return true;

		}

	}

	static boolean[][] burned;

	static int[] dx={-1,0,1,0};

	static int[] dy={0,-1,0,1};

	static boolean isvalid(int x,int y)

	{

		return x>=0&&x<n&&y>=0&&y<m;

	}

	public static void main(String[] args) throws IOException

	{

		Scanner in = new Scanner(""input.txt"");

		PrintWriter out = new PrintWriter(new FileWriter(""output.txt""));

		n=in.nextInt();

		m=in.nextInt();

		burned=new boolean[n][m];

		int k=in.nextInt();

		Set<Pair> set=new HashSet<Pair>();

		Pair prev=null;

		for(int i=0;i<k;i++)

		{

			int x=in.nextInt();

			int y=in.nextInt();

			burned[x-1][y-1]=true;

			set.add(prev=new Pair(x-1, y-1));

		}

		while(!set.isEmpty())

		{

			Set<Pair> tempset=new HashSet<>();

		for(Pair p : set)

		{

			int x=p.x;

			int y=p.y;

			prev=p;

			for(int i=0;i<4;i++)

			{

				if(isvalid(x+dx[i], y+dy[i])&&!burned[x+dx[i]][y+dy[i]])

				{

					tempset.add(new Pair(x+dx[i], y+dy[i]));

					burned[x+dx[i]][y+dy[i]]=true;

				}

			}

		}

		set=tempset;

		}

		out.printf(""%d %d\n"",(prev.x+1),(prev.y+1));

		out.close();



	}

	

	public static long pow(long x, long n) 

	{

		long res = 1;

		for (long p = x; n > 0; n >>= 1, p = (p * p)) 

		{

			if ((n & 1) != 0) 

			{

				res = (res * p);

			}

		}

		return res;

	}

	

	public static long pow(long x, long n, long mod) 

	{

		long res = 1;

		for (long p = x; n > 0; n >>= 1, p = (p * p) % mod) 

		{

			if ((n & 1) != 0) 

			{

				res = (res * p % mod);

			}

		}

		return res;

	}



	public static long gcd(long n1, long n2)

	{

		long r;

		while (n2 != 0) 

		{

			r = n1 % n2;

			n1 = n2;

			n2 = r;

		}

		return n1;

	}



	public static long lcm(long n1, long n2) 

	{

		long answer = (n1 * n2) / (gcd(n1, n2));

		return answer;

	}



	static class Scanner 

	{

		StringTokenizer st;

		BufferedReader br;



		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

		

		public Scanner(String s) throws FileNotFoundException{	br = new BufferedReader(new FileReader(s));}



		public String next() throws IOException 

		{

			while (st == null || !st.hasMoreTokens()) 

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}



		public int nextInt() throws IOException {return Integer.parseInt(next());}



		public long nextLong() throws IOException {return Long.parseLong(next());}



		public String nextLine() throws IOException {return br.readLine();}



		public double nextDouble() throws IOException { return Double.parseDouble(next()); }



		public boolean ready() throws IOException {return br.ready();} 

	}

}



",6,3
"import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.FileInputStream;
import java.util.NoSuchElementException;
import java.io.Writer;
import java.math.BigInteger;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Alex
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream;
		try {
			inputStream = new FileInputStream(""input.txt"");
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		OutputStream outputStream;
		try {
			outputStream = new FileOutputStream(""output.txt"");
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		TaskC solver = new TaskC();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskC {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
	    int maxdist = -1, maxrow = -1, maxcol = -1;
	    int rows = in.ri(), cols = in.ri();
	    int k = in.ri();
	    IntPair[] points = new IntPair[k];
	    for(int i = 0; i < k; i++) points[i] = new IntPair(in.ri(), in.ri());
	    for(int row = 1; row <= rows; row++) {
		    for(int col = 1; col <= cols; col++) {
			    int mindist = Integer.MAX_VALUE;
			    for(int i = 0; i < k; i++)
				    mindist = Math.min(mindist, Math.abs(row - points[i].first) + Math.abs(col - points[i].second));
			    if (mindist > maxdist){
				    maxdist = mindist;
				    maxrow = row;
				    maxcol = col;
			    }
		    }
	    }
	    out.printLine(maxrow, maxcol);
    }
}

class InputReader {
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}
	public int ri(){
		return readInt();
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}
	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return isWhitespace(c);
	}

	public static boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}
	public void print(Object...objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}
	public void printLine(Object...objects) {
		print(objects);
		writer.println();
	}
	public void close() {
		writer.close();
	}
}

class IntPair implements Comparable<IntPair> {
public int first, second;


	public IntPair(int first, int second) {
		this.first = first;
		this.second = second;
	}
	public String toString() {
		return ""("" + first + "","" + second + "")"";
	}

	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;

		IntPair intPair = (IntPair) o;

		return first == intPair.first && second == intPair.second;

	}

	public int hashCode() {
		int result = first;
		result = 31 * result + second;
		return result;
	}

	public int compareTo(IntPair o) {
		if (first < o.first)
			return -1;
		if (first > o.first)
			return 1;
		if (second < o.second)
			return -1;
		if (second > o.second)
			return 1;
		return 0;
	}
}

",6,5
"import java.io.*;

import java.util.*;



public class C {



	void run() throws IOException {

		int n = ni(), m = ni(), k = ni(), q = n * m, h = 0, t = 0, inf = 123456;

		int[] x = new int[q], y = new int[q];

		int[][] d = new int[n][m];

		for (int i = 0; i < n; i++)

			for (int j = 0; j < m; j++)

				d[i][j] = inf;

		for (int i = 0; i < k; i++) {

			int u = ni() - 1, v = ni() - 1;

			d[u][v] = 0;

			x[t] = u;

			y[t] = v;

			t++;

		}

		if (k < q)

			while (t != h) {

				int u = x[h], v = y[h];

				int l = d[u][v] + 1;

				h++;

				if (u > 0 && d[u - 1][v] > l) {

					d[u - 1][v] = l;

					x[t] = u - 1;

					y[t] = v;

					t++;

				}

				if (u < n - 1 && d[u + 1][v] > l) {

					d[u + 1][v] = l;

					x[t] = u + 1;

					y[t] = v;

					t++;

				}

				if (v > 0 && d[u][v - 1] > l) {

					d[u][v - 1] = l;

					x[t] = u;

					y[t] = v - 1;

					t++;

				}

				if (v < m - 1 && d[u][v + 1] > l) {

					d[u][v + 1] = l;

					x[t] = u;

					y[t] = v + 1;

					t++;

				}

			}

		int max = 0, tx = 0, ty = 0;



		for (int i = 0; i < n; i++)

			for (int j = 0; j < m; j++)

				if (d[i][j] > max) {

					max = d[i][j];

					tx = i;

					ty = j;



				}

		pw.print(1 + tx + "" "" + (1 + ty));

	}



	String next() throws IOException {

		while (st == null || !st.hasMoreTokens())

			st = new StringTokenizer(br.readLine());

		return st.nextToken();

	}



	int ni() throws IOException {

		return Integer.parseInt(next());

	}



	String nl() throws IOException {

		return br.readLine();

	}



	PrintWriter pw;

	BufferedReader br;

	StringTokenizer st;



	public static void main(String[] args) throws IOException {

		BufferedReader _br = new BufferedReader(new FileReader(new File(""input.txt"")));

		PrintWriter _pw = new PrintWriter(new FileWriter(new File(""output.txt"")));

		new C(_br, _pw).run();

		_br.close();

		_pw.close();

	}



	public C(BufferedReader _br, PrintWriter _pw) {

		br = _br;

		pw = _pw;

	}

}

",6,5
"import java.io.*;

import java.lang.reflect.Array;

import java.util.*;



public class Problem implements Runnable {



    private static final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;



    private BufferedReader in;

    private PrintWriter out;

    private StringTokenizer tok = new StringTokenizer("""");



    private void init() throws FileNotFoundException {

        Locale.setDefault(Locale.US);

        String fileName = """";

     /*   if (ONLINE_JUDGE && fileName.isEmpty()) {

            in = new BufferedReader(new InputStreamReader(System.in));

            out = new PrintWriter(System.out);

        } else {

            if (fileName.isEmpty()) {*/

                in = new BufferedReader(new FileReader(""input.txt""));

                out = new PrintWriter(""output.txt"");

          /*  } else {

                in = new BufferedReader(new FileReader(fileName + "".in""));

                out = new PrintWriter(fileName + "".out"");

           /* }

        }*/

    }





    String readString() {

        while (!tok.hasMoreTokens()) {

            try {

                tok = new StringTokenizer(in.readLine());

            } catch (Exception e) {

                return null;

            }

        }

        return tok.nextToken();

    }



    int readInt() {

        return Integer.parseInt(readString());

    }



    long readLong() {

        return Long.parseLong(readString());

    }



    double readDouble() {

        return Double.parseDouble(readString());

    }



    int[] readIntArray(int size) {

        int[] a = new int[size];

        for (int i = 0; i < size; i++) {

            a[i] = readInt();

        }

        return a;

    }



    public static void main(String[] args) {

        //new Thread(null, new _Solution(), """", 128 * (1L << 20)).start();

        new Problem().run();

    }



    long timeBegin, timeEnd;



    void time() {

        timeEnd = System.currentTimeMillis();

        System.err.println(""Time = "" + (timeEnd - timeBegin));

    }



    @Override

    public void run() {

        try {

            timeBegin = System.currentTimeMillis();

            init();

            solve();

            out.close();

            time();

        } catch (Exception e) {

            e.printStackTrace();

            System.exit(-1);

        }

    }





    int[][] dist;

    int n, m;

    P v;

    ArrayDeque<P> q = new ArrayDeque<>();



    private void solve() throws IOException {

        n = readInt();

        m = readInt();

        int k = readInt();

        dist = new int[n][m];

        for (int i = 0; i < n; i++)

            for (int j = 0; j < m; j++)

                dist[i][j] = -1;

        for (int i = 0; i < k; i++) {

            int x = readInt() - 1, y = readInt() - 1;

            dist[x][y] = 0;

            q.add(new P(x, y));

        }

        bfs();

        out.println(v.x + 1 + "" "" + (v.y + 1));

    }



    public void bfs() {

        int[] dx = {0, 1, 0, -1};

        int[] dy = {1, 0, -1, 0};

        while (!q.isEmpty()) {

            v = q.poll();

            for (int i = 0; i < 4; i++) {

                int nx = v.x + dx[i];

                int ny = v.y + dy[i];

                if (inside(nx, ny) && dist[nx][ny] == -1) {

                    q.add(new P(nx, ny));

                    dist[nx][ny] = dist[v.x][v.y] + 1;

                }

            }

        }

    }



    public boolean inside(int x, int y) {

        if (x < n && y < m && x >= 0 && y >= 0) {

            return true;

        }

        return false;

    }

}



class P {

    int x, y;



    public P(int x, int y) {

        this.x = x;

        this.y = y;

    }

}",6,5
"import java.io.*;
import java.util.*;

public class C35C_BFS_Fire {
    public static boolean[][] burning;
    public static LinkedList<int[]> LitTrees; //which is best to use
    public static int N, M;
    public static int[] lastTree;
    public static void main(String[] args) throws IOException {
        // InputStreamReader stream = new InputStreamReader(System.in);
        // BufferedReader input = new BufferedReader(stream);

        BufferedReader input = new BufferedReader(new FileReader(""input.txt""));
		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));

        StringTokenizer dataR = new StringTokenizer(input.readLine());
        N = Integer.parseInt(dataR.nextToken());
        M = Integer.parseInt(dataR.nextToken());
        burning = new boolean[N+1][M+1];

        StringTokenizer dataR1 = new StringTokenizer(input.readLine());
        int K = Integer.parseInt(dataR1.nextToken());

        StringTokenizer dataR2 = new StringTokenizer(input.readLine());
        LitTrees = new LinkedList<int[]>();
        for (int j = 0; j < K; j++){
            int x = Integer.parseInt(dataR2.nextToken());
            int y = Integer.parseInt(dataR2.nextToken());
            int[] coord = {x, y};
            LitTrees.add(coord);
            burning[x][y] = true;
        }

        spread();

        out.println(lastTree[0] + "" "" + lastTree[1]);
        out.close();

    }

    public static void spread(){
        while(!LitTrees.isEmpty()){
            int[] studying = LitTrees.remove(); //is iterator faster
            LinkedList<int[]> ll = new LinkedList<int[]>();

            if(studying[0]-1 >= 1) ll.add(new int[]{studying[0]-1, studying[1]});
            if(studying[1]-1 >= 1) ll.add(new int[]{studying[0], studying[1]-1});
            if(studying[1]+1 < M+1) ll.add(new int[]{studying[0], studying[1]+1});
            if(studying[0]+1 < N+1) ll.add(new int[]{studying[0]+1, studying[1]});

            while(!ll.isEmpty()) {
                int[] focus = ll.remove();
                if(!burning[focus[0]][focus[1]]) {
                    LitTrees.add(focus);
                    burning[focus[0]][focus[1]] = true;
                }
            }

            lastTree = studying; 
        }        
    }
    
}",6,3
"import java.io.BufferedReader;

import java.io.BufferedWriter;

import java.io.FileReader;

import java.io.FileWriter;

import java.io.IOException;

import java.io.InputStreamReader;

import java.util.*;



public class FireAgain {

	static int n;

	static int m;



	public static void main(String[] args) throws IOException {

		// TODO Auto-generated method stub

		BufferedReader r = new BufferedReader(new FileReader(""input.txt""));

		String s = r.readLine();

		String[] sp = s.split("" "");

		n = new Integer(sp[0]);

		m = new Integer(sp[1]);

		boolean[][] v = new boolean[n][m];

		r.readLine();

		s = r.readLine();

		sp = s.split("" "");

		Queue<Integer> q = new LinkedList<Integer>();

		for (int i = 0; i < sp.length; i += 2) {

			v[new Integer(sp[i]) - 1][new Integer(sp[i + 1]) - 1] = true;

			q.add(new Integer(sp[i]) - 1);

			q.add(new Integer(sp[i + 1]) - 1);

		}



		int[] dx = { 1, -1, 0, 0 };

		int[] dy = { 0, 0, 1, -1 };

		int lx = -1;

		int ly = -1;

		while (!q.isEmpty()) {

			int x = q.remove();

			int y = q.remove();

			lx = x;

			ly = y;

			for (int i = 0; i < dy.length; i++) {

				int nx = x + dx[i];

				int ny = y + dy[i];

				if (valid(nx, ny) && !v[nx][ny]) {

					v[nx][ny] = true;

					q.add(nx);

					q.add(ny);

				}

			}

		}

		lx++;

		ly++;

		BufferedWriter wr=new BufferedWriter(new FileWriter(""output.txt""));

		wr.write(""""+lx + "" "" + ly);

		wr.newLine();

		wr.close();

		

	}



	private static boolean valid(int nx, int ny) {

		return nx >= 0 && nx < n && ny >= 0 && ny < m;

	}

}

",6,3
"import java.io.*;
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.StringTokenizer;

public class CodeForces {
    public static void main(String[] args) throws FileNotFoundException {
        FastIO io = new FastIO();

        int width = io.nextInt();
        int height = io.nextInt();

        int initials = io.nextInt();

        boolean[][] visited = new boolean[width][height];

        Queue<Coordinate> q = new ArrayDeque<>();

        for (int i = 0; i < initials; i++) {
            q.add(new Coordinate(io.nextInt() - 1, io.nextInt() - 1));
        }

        Coordinate oneOfLast = null;

        while (!q.isEmpty()) {
            int len = q.size();
            for (int times = 0; times < len; times++) {
                Coordinate c = q.poll();
                if (visited[c.x][c.y]) {
                    continue;
                }

                oneOfLast = c;
                visited[c.x][c.y] = true;

                int[][] deltas = new int[][]{
                        {-1, 0}, {0, -1}, {1, 0}, {0, 1}
                };

                for (int[] delta : deltas) {
                    int ci = c.y + delta[0];
                    int cj = c.x + delta[1];

                    if (ci >= 0 && cj >= 0 && ci < height && cj < width) {
                        q.add(new Coordinate(cj, ci));
                    }
                }
            }
        }

        io.println((oneOfLast.x + 1) + "" "" + (oneOfLast.y + 1));

        io.close();
    }

    static class Coordinate {
        int x;
        int y;

        public Coordinate(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    static class FastIO extends PrintWriter {
        BufferedReader br;
        StringTokenizer st;

        public FastIO() throws FileNotFoundException {
            super(new BufferedOutputStream(new FileOutputStream(""output.txt"")));
            br = new BufferedReader(new InputStreamReader(new FileInputStream(""input.txt"")));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextToken() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        String nextLine() {
            try {
                return br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return """";
        }
    }
}",6,3
"

import java.awt.Point;

import java.io.BufferedReader;

import java.io.BufferedWriter;

import java.io.FileReader;

import java.io.FileWriter;

import java.io.IOException;

import java.util.LinkedList;

import java.util.Queue;



public class Main {



	public static void main(String[] args) throws IOException {

		

		BufferedReader br = new BufferedReader(new FileReader(""input.txt""));

		

		String dimensions = br.readLine();

		String extractDim = """";

		int n = 0, m;

		for (int i = 0 ; i < dimensions.length() ; i++)

		{

			if(dimensions.charAt(i) == ' ')

			{

				n = Integer.parseInt(extractDim);

				extractDim = """";

				continue;

			}

			extractDim += dimensions.charAt(i);

		}

		m = Integer.parseInt(extractDim); 

		

		String burningTrees = br.readLine();

		

		int k = Integer.parseInt(burningTrees);		

		

		Point[] coord = new Point[k];

		

		String coordSet = br.readLine();

		int spaceCount = 0;

		String newCoord = """";

		int s = 0;

		for(int i = 0 ; i < coordSet.length() ; i++)

		{

			if(coordSet.charAt(i) == ' ')

				spaceCount++;

			

			if(spaceCount == 2)

			{

				String extractCoord = """";

				int x = 0, y;

				for (int j = 0 ; j < newCoord.length() ; j++)

				{

					if(newCoord.charAt(j) == ' ')

					{

						x = Integer.parseInt(extractCoord);

						extractCoord = """";

						continue;

					}

					extractCoord += newCoord.charAt(j);

				}

				y = Integer.parseInt(extractCoord);

				

				coord[s] = new Point(x,y);

				s++;

				newCoord = """";

				spaceCount = 0;

				continue;

			}

			

			newCoord += coordSet.charAt(i);

		}

		

		String extractCoord = """";

		int x = 0, y;

		for (int j = 0 ; j < newCoord.length() ; j++)

		{

			if(newCoord.charAt(j) == ' ')

			{

				x = Integer.parseInt(extractCoord);

				extractCoord = """";

				continue;

			}

			extractCoord += newCoord.charAt(j);

		}

		y = Integer.parseInt(extractCoord);

		

		coord[s] = new Point(x,y);

		s++;

		

		br.close();

		

		int[][] forest = new int[n+2][m+2];

		

		for(int i = 0 ; i < forest.length ; i++)

		{

			for(int j = 0 ; j < forest[i].length ; j++)

			{

				if(i == 0 || i == n+1 || j == 0 || j == m+1 )

					forest[i][j] = 0;

				else

					forest[i][j] = 1;

			}

		}

		

		

		Queue<Point> q = new LinkedList<>();

		

		for(int i = 0 ; i < coord.length ; i++)

		{

			forest[coord[i].x][coord[i].y] = 0;

			q.add(coord[i]);

		}

		

		Point tree = new Point();

		while(!q.isEmpty())

		{

			Point temp = q.remove();

			forest[temp.x][temp.y] = 0;

			

			if(q.isEmpty())

				tree = new Point(temp.x ,temp.y);

			for(int i = -1 ; i <= 1 ; i++)

			{

				for(int j = -1; j <= 1; j++)

				{

					if(i != 0 && j != 0 || i == 0 && j == 0)

						continue;

					if(forest[temp.x+i][temp.y+j] == 0)

						continue;

					else

					{

						forest[temp.x+i][temp.y+j] = 0;

						q.add(new Point(temp.x+i , temp.y+j));

					}

				}

			}

			

		}

		

		

		BufferedWriter bw = new BufferedWriter(new FileWriter(""output.txt""));

		bw.write(tree.x + "" "" + tree.y);

		bw.close();

		

	

	}



}

",6,5
"import java.io.*;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class Solution {


    public static void main(String[] args) {
        InputStream inputStream;
        try {
            inputStream = new FileInputStream(""input.txt"");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        OutputStream outputStream;
        try {
            outputStream = new FileOutputStream(""output.txt"");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {

        int[][] or;
        int n;
        int m;

        public void solve(int testNumber, InputReader in, PrintWriter out) {

            n = in.nextInt();
            m = in.nextInt();
            int k = in.nextInt();

            ArrayList<Point> arr1 = new ArrayList<>();
            ArrayList<Point> arr2 = new ArrayList<>();

            for (int i = 0; i < k; i++) {
                arr1.add(new Point(in.nextInt(), in.nextInt()));
            }

            or = new int[n + 1][m + 1];

            for (int i = 0; i < k; i++) {
                or[arr1.get(i).x][arr1.get(i).y] = -1;
            }

            Point lastValue = arr1.get(0);

            while (arr1.size() > 0 || arr2.size() > 0) {

                for (Point p : arr1) {
                    if (valid(new Point(p.x - 1, p.y))) {
                        arr2.add(new Point(p.x - 1, p.y));
                    }
                    if (valid(new Point(p.x + 1, p.y))) {
                        arr2.add(new Point(p.x + 1, p.y));
                    }
                    if (valid(new Point(p.x, p.y - 1))) {
                        arr2.add(new Point(p.x, p.y - 1));
                    }
                    if (valid(new Point(p.x, p.y + 1))) {
                        arr2.add(new Point(p.x, p.y + 1));
                    }
                }

                arr1.clear();

                if (arr2.size() > 0) {
                    lastValue = arr2.get(0);
                }

                for (Point p : arr2) {
                    if (valid(new Point(p.x - 1, p.y))) {
                        arr1.add(new Point(p.x - 1, p.y));
                    }
                    if (valid(new Point(p.x + 1, p.y))) {
                        arr1.add(new Point(p.x + 1, p.y));
                    }
                    if (valid(new Point(p.x, p.y - 1))) {
                        arr1.add(new Point(p.x, p.y - 1));
                    }
                    if (valid(new Point(p.x, p.y + 1))) {
                        arr1.add(new Point(p.x, p.y + 1));
                    }
                }

                arr2.clear();

                if (arr1.size() > 0) {
                    lastValue = arr1.get(0);
                }
            }

            out.println(lastValue.x + "" "" + lastValue.y);
        }

        boolean valid(Point p) {
            if ((p.x < 1 || p.x > n) ||
                    (p.y < 1 || p.y > m) ||
                    or[p.x][p.y] == -1) {
                return false;
            }

            or[p.x][p.y] = -1;

            return true;
        }

        class Point {

            int x;
            int y;

            public Point(int a, int b) {
                x = a;
                y = b;
            }

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
    }

}








",6,3
"import java.awt.*;

import java.io.*;

import java.util.*;

import java.util.Queue;



public class A {



    static int[] dx = {-1, 0, 1, 0};

    static int[] dy = {0, 1, 0, -1};



    public static void main(String[] args) throws Exception {

        Scanner sc = new Scanner(""input.txt"");

        PrintWriter out = new PrintWriter(""output.txt"");

        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();

        int[][] dist = new int[n][m];

        for(int[] a : dist) Arrays.fill(a, -1);

        Queue<Point> q = new LinkedList<>();

        for(int i = 0; i < k; i++)

        {

            int x = sc.nextInt() - 1, y = sc.nextInt() - 1;

            dist[x][y] = 0;

            q.add(new Point(x, y));

        }

        int ansX = -1, ansY = -1;

        while(!q.isEmpty())

        {

            Point cur = q.remove();

            ansX = cur.x; ansY = cur.y;

            for(int i = 0; i < 4; i++)

            {

                int x = cur.x + dx[i], y = cur.y + dy[i];

                if(x != -1 && y != -1 && x != n && y != m && dist[x][y] == -1)

                {

                    q.add(new Point(x, y));

                    dist[x][y] = dist[cur.x][cur.y] + 1;

                }

            }

        }

        out.println((ansX + 1) + "" "" + (ansY + 1));

        out.flush();

        out.close();

    }

    static class Scanner

    {

        StringTokenizer st;

        BufferedReader br;



        public Scanner(InputStream system) {br = new BufferedReader(new InputStreamReader(system));}

        public Scanner(String file) throws Exception {br = new BufferedReader(new FileReader(file));}

        public String next() throws IOException

        {

            while (st == null || !st.hasMoreTokens())

                st = new StringTokenizer(br.readLine());

            return st.nextToken();

        }

        public String nextLine()throws IOException{return br.readLine();}

        public int nextInt() throws IOException {return Integer.parseInt(next());}

        public double nextDouble() throws IOException {return Double.parseDouble(next());}

        public char nextChar()throws IOException{return next().charAt(0);}

        public Long nextLong()throws IOException{return Long.parseLong(next());}

        public boolean ready() throws IOException{return br.ready();}

        public void waitForInput() throws InterruptedException {Thread.sleep(4000);}

    }

}

",6,3
"import java.io.*;
import java.util.*;

public class practice {

		public static void main(String[] args) throws FileNotFoundException {			
			Scanner scn = new Scanner(new FileReader(""input.txt""));
			PrintWriter out = new PrintWriter(new File(""output.txt""));
		 int n=scn.nextInt(),m=scn.nextInt(),k=scn.nextInt();
		 int[][] inf=new int[k][2];
		 for(int i=0;i<k;i++){
			 inf[i][0]=scn.nextInt();inf[i][1]=scn.nextInt();
		 }
		 int ans=0,x=1,y=1;
		 for(int i=1;i<=n;i++){
			 for(int j=1;j<=m;j++){
				 int temp=Integer.MAX_VALUE;
				 for(int l=0;l<k;l++){
					temp=Math.min(temp, Math.abs(i-inf[l][0])+Math.abs(j-inf[l][1])); 
				 }
				 if(temp>ans){
					 ans=temp;x=i;y=j;
				 }
			 }
		 }
		 out.print(x+ "" "" + y);
	   	 out.close();
		}
	}

",6,5
"import java.io.BufferedReader;

import java.io.File;

import java.io.FileReader;

import java.io.IOException;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.StringTokenizer;



public class Main {

	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new FileReader(new File(""input.txt"")));

		PrintWriter pw = new PrintWriter(new File(""output.txt""));



		StringTokenizer st;



		st = new StringTokenizer(in.readLine());

		

		int n = Integer.parseInt(st.nextToken()),

			m = Integer.parseInt(st.nextToken()),

			k = Integer.parseInt(in.readLine());

		

		int[][] A = new int[n][m];

		

		st = new StringTokenizer(in.readLine());

		for (int i = 0 ; i < k ; i++) {

			int x1 = Integer.parseInt(st.nextToken()) - 1,

				y1 = Integer.parseInt(st.nextToken()) - 1;

			

			A[x1][y1] = -10000000;

			

			for (int j = 0 ; j < n ; j++) {

				for (int g = 0 ; g < m ; g++) {

					if (A[j][g] == 0 || (A[j][g] > (Math.abs(y1 - g) + Math.abs(x1 - j)))) {

						A[j][g] = (Math.abs(y1 - g) + Math.abs(x1 - j));

					}

				}

			}

		}

		

		int f = 0, h = 0;

		

		for (int i = 0 ; i < n ; i++) {

			for (int j = 0 ; j < m ; j++) {

				if (A[i][j] != -10000000) {

					f = i;

					h = j;

				}

			}

		}

		

		for (int i = 0 ; i < n ; i++) {

			for (int j = 0 ; j < m ; j++) {

				if (A[i][j] > A[f][h] && A[i][j] != -10000000) {

					f = i;

					h = j;

				}

			}

		}

	//	for (int i = 0 ; i < n ; i++) for (int j = 0 ; j < m ; j++) System.out.println(A[i][j]);

		pw.println((f + 1) + "" "" + (h + 1));

		pw.close();

	}

}

",6,5
"import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.io.*;
import java.math.*;
import java.security.*;
import java.text.*; 
import java.util.*;
import java.util.regex.*;
/*
	  br = new BufferedReader(new FileReader(""input.txt""));
	  pw = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));
	  br = new BufferedReader(new InputStreamReader(System.in));
	  pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
 */


public class Main {
	private static BufferedReader br;
	private static StringTokenizer st;
	private static PrintWriter pw;

	public static void main(String[] args) throws Exception {
		br = new BufferedReader(new FileReader(""input.txt""));
		pw = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));
		//int qq = 1;
		int qq = Integer.MAX_VALUE;
		//int qq = readInt();
		for(int casenum = 1; casenum <= qq; casenum++)	{
			int r = readInt();
			int c = readInt();
			int n = readInt();
			int[][] dist = new int[r][c];
			for(int i = 0; i < r; i++) {
				Arrays.fill(dist[i], 1 << 25);
			}
			LinkedList<State> q = new LinkedList<State>();
			while(n-- > 0) {
				q.add(new State(readInt()-1, readInt()-1));
				dist[q.peekLast().x][q.peekLast().y] = 0;
			}
			int[] dx = new int[]{-1,1,0,0};
			int[] dy = new int[]{0,0,-1,1};
			State ret = q.peekLast();
			while(!q.isEmpty()) {
				State curr = q.removeFirst();
				ret = curr;
				for(int k = 0; k < dx.length; k++) {
					int nx = curr.x + dx[k];
					int ny = curr.y + dy[k];
					if(nx >= 0 && nx < r && ny >= 0 && ny < c && dist[nx][ny] > 1 + dist[curr.x][curr.y]) {
						dist[nx][ny] = 1 + dist[curr.x][curr.y];
						q.add(new State(nx, ny));
					}
				}
			}
			pw.println(ret.x+1 + "" "" + (ret.y+1));
		}
		exitImmediately();
	}

	static class State {
		public int x,y;

		public State(int x, int y) {
			super();
			this.x = x;
			this.y = y;
		}
		
	}
	
	private static void exitImmediately() {
		pw.close();
		System.exit(0);
	}

	private static long readLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	private static double readDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	private static int readInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	private static String nextLine() throws IOException  {
		if(!br.ready()) {
			exitImmediately();
		}
		st = null;
		return br.readLine();
	}

	private static String nextToken() throws IOException  {
		while(st == null || !st.hasMoreTokens())  {
			if(!br.ready()) {
				exitImmediately();
			}
			st = new StringTokenizer(br.readLine().trim());
		}
		return st.nextToken();
	}
}",6,3
"import java.io.*;

import java.util.*;

public class Main

{

    public static void main(String[] args) throws IOException

    {

        PrintWriter pw = new PrintWriter(new FileWriter(""output.txt""));

        Scanner in=new Scanner(new File(""input.txt""));

        int n,m,k;

        n=in.nextInt();

        m=in.nextInt();

        k=in.nextInt();

        Vector<Integer> vec=new Vector<Integer>();

        Vector<Integer> temp=new Vector<Integer>();

        boolean[][] mas=new boolean[n][m];

        long time=System.currentTimeMillis();

        for(int i=0;i<k;i++)

        {

            vec.add(in.nextInt()-1);

            vec.add(in.nextInt()-1);

            mas[vec.get(vec.size()-2)][vec.get(vec.size()-1)]=true;

        }

        int x,y;

        x=y=0;

        while(vec.size()!=0)

        {

            for(int i=0;i<vec.size();i+=2)

            {

                x=vec.get(i);

                y=vec.get(i+1);

                if(x>0 && !mas[x-1][y])

                {

                    temp.add(x-1);

                    temp.add(y);

                    mas[x-1][y]=true;

                }

                if(x<n-1 && !mas[x+1][y])

                {

                    temp.add(x+1);

                    temp.add(y);

                    mas[x+1][y]=true;

                }

                if(y>0 && !mas[x][y-1])

                {

                    temp.add(x);

                    temp.add(y-1);

                    mas[x][y-1]=true;

                }

                if(y<m-1 && !mas[x][y+1])

                {

                    temp.add(x);

                    temp.add(y+1);

                    mas[x][y+1]=true;

                }

            }

            vec=temp;

            temp=new Vector<Integer>();

        }

        pw.println((x+1)+"" ""+(y+1));

        System.out.println(System.currentTimeMillis()-time);

        in.close();

        pw.close();

    }

}",6,3
"import static java.lang.Math.*;

import java.io.*;

import java.math.*;

import java.util.*;



public class Solution implements Runnable {



	public static void main(String... strings) throws InterruptedException {

		new Thread(new Solution()).start();

	}



	BufferedReader in;

	PrintWriter out;

	StringTokenizer st;



	String next() throws Exception {

		if (st == null || !st.hasMoreElements())

			st = new StringTokenizer(in.readLine());

		return st.nextToken();

	}



	int nextInt() throws Exception {

		return Integer.parseInt(next());

	}



	double nextDouble() throws Exception {

		return Double.parseDouble(next());

	}



	long nextLong() throws Exception {

		return Long.parseLong(next());

	}



	@Override

	public void run() {

		try {

			in = new BufferedReader(new FileReader(""input.txt""));

			out = new PrintWriter(new FileWriter(""output.txt""));

			solve();

		} catch (Exception e) {

			throw new RuntimeException(e);

		} finally {

			out.close();

		}

	}

	int n, m, k, xor = 0;

	boolean[][] used;

	HashSet<Long> [] set;

	void solve() throws Exception {

		n = nextInt();

		m = nextInt();

		k = nextInt();

		used = new boolean[n][m];

		set = new HashSet[2];

		for(int i = 0; i < 2; set[i++] = new HashSet<Long>());

		

		for(int i = 0; i < k; i++){

			int x = nextInt()-1, y = nextInt()-1;

			used[x][y] = true;

			set[0].add(10000L*x + y);

		}

		for (;;xor ^= 1){

			set[xor^1].clear();

			int ansx = -1, ansy = -1;

			for (long i : set[xor]){

				int x = (int)(i/10000), y = (int)(i%10000);

				if (ansx < 0){

					ansx = x+1;

					ansy = y+1;

				}

				add(x+1, y);

				add(x-1, y);

				add(x, y+1);

				add(x, y-1);

			}

			if (set[xor^1].size() == 0){

				out.println(ansx + "" "" + ansy);

				break;

			}

		}

	}

	public void add(int x, int y){

		if (!( x >= 0 && y >= 0 && x < n && y < m && !used[x][y])) return;

		set[xor^1].add(10000L*x + y);

		used[x][y] = true;

	}



}",6,3
"import java.io.File;

import java.io.IOException;

import java.io.PrintWriter;

import java.util.Scanner;





public class C2 {



    public static void main(String[] args) throws IOException{

        Scanner sc = new Scanner(new File(""input.txt""));

        PrintWriter pw = new PrintWriter(new File(""output.txt""));

        int n = sc.nextInt();

        int m = sc.nextInt();

        int k = sc.nextInt();

        int[]x = new int[k+1], y = new int[k+1];

        for (int i = 1; i <= k; i++) {

            y[i] = sc.nextInt();

            x[i] = sc.nextInt();

        }

        int max = -1, y0 = 0, x0 = 0;

        for (int i = 1; i <= n; i++) {

            for (int j = 1; j <= m; j++) {

                int min = n+m+2;

                for (int j2 = 1; j2 <= k; j2++) {

                    min = Math.min(min, Math.abs(i-y[j2])+Math.abs(j-x[j2]));

                }

                if (min > max) {

                    max = min;

                    y0 = i;

                    x0 = j;

                }

            }

        }

        pw.println(y0+"" ""+x0);

        pw.close();

    }



}

",6,5
"import java.awt.Point;

import java.io.BufferedReader;

import java.io.FileInputStream;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.io.UnsupportedEncodingException;

import java.net.URISyntaxException;

import java.util.LinkedList;

import java.util.Queue;

import java.util.StringTokenizer;



public class Main {

    public static void main(String[] args)throws IOException, URISyntaxException {

        Reader.init(new FileInputStream(""input.txt""));

        StringBuilder s=new StringBuilder();

        boolean[][]vis=new boolean[Reader.nextInt()][Reader.nextInt()];

        int k=Reader.nextInt(),r,c;

        Queue<Point>q=new LinkedList<Point>();

        while(k-->0) {

            r=Reader.nextInt()-1;

            c=Reader.nextInt()-1;

            vis[r][c]=true;

            q.add(new Point(r,c));

        }

        Point end=null;

        int[]x={0,0,1,-1},y={1,-1,0,0};

        int a,b,i;

        while(!q.isEmpty()) {

            end=q.poll();

            for(i=0;i<4;i++) {

                a=end.x+x[i];

                b=end.y+y[i];

                if(a>=0&&b>=0&&a<vis.length&&b<vis[a].length&&!vis[a][b]) {

                    vis[a][b]=true;

                    q.add(new Point(a,b));

                }

            }

        }

        s.append(end.x+1).append(' ').append(end.y+1);

        PrintWriter p=new PrintWriter(""output.txt"");

        p.println(s);

        p.close();

    }

}



class Reader {

    static BufferedReader reader;

    static StringTokenizer tokenizer;



    /** call this method to initialize reader for InputStream */

    static void init(InputStream input) throws UnsupportedEncodingException {

        reader = new BufferedReader(

                     new InputStreamReader(input, ""UTF-8"") );

        tokenizer = new StringTokenizer("""");

    }



    /** get next word */

    static String next() throws IOException {

        while ( ! tokenizer.hasMoreTokens() ) {

            //TODO add check for eof if necessary

            tokenizer = new StringTokenizer(

                   reader.readLine() );

        }

        return tokenizer.nextToken();

    }

    

    static String nextLine() throws IOException {

        return reader.readLine();

    }



    static int nextInt() throws IOException {

        return Integer.parseInt( next() );

    }

    

    static double nextDouble() throws IOException {

        return Double.parseDouble( next() );

    }

    

    static long nextLong() throws IOException {

        return Long.parseLong( next() );

    }

}",6,1
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.StringTokenizer;
import java.util.Queue;
public class Solution{
    static int[] dx = {1,-1,0,0};
    static int[] dy = {0,0,1,-1};
    static Queue<Pair> q ;
    static boolean[][] visited ;
    static Pair result = new Pair(0,0);
    static int n,m,k;
    public static void main(String[] args){
        try(BufferedReader in = new BufferedReader(new FileReader(""input.txt""));
                BufferedWriter out = new BufferedWriter(new FileWriter(""output.txt"")))
        {
            StringTokenizer s = new StringTokenizer(in.readLine());
            n = Integer.parseInt(s.nextToken());
            m = Integer.parseInt(s.nextToken());
            k = Integer.parseInt(in.readLine());
            visited = new boolean[n][m];
            q = new LinkedList <>();
            s = new StringTokenizer(in.readLine());
            for(int i=0;i<k;i++){
                int x = Integer.parseInt(s.nextToken());
                int y = Integer.parseInt(s.nextToken());
                q.add(new Pair(--x,--y));
            }
            bfs();
            String ans = """" + (result.x+1) +"" ""+ (result.y+1);
            out.write(ans);
        }catch(IOException e){

        }
    }
    static void bfs(){
        while(!q.isEmpty()){
            Pair temp = q.poll();
            if(visited[temp.x][temp.y]) continue;
            visited[temp.x][temp.y] = true;
            result.x = temp.x;
            result.y= temp.y;
            for(int i=0;i<4;i++){
                int x = temp.x + dx[i];
                int y = temp.y + dy[i];
                if(x>=0 && x<n && y>=0 && y<m && !visited[x][y])
                    q.add(new Pair(x,y));
            }
            
        }
    }
    
}
class Pair{
    int x,y;
    public Pair(int x,int y){
        this.x=x;
        this.y=y;
    }
}",6,3
"import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class P35C {
	public static void main(String[] args) throws FileNotFoundException {
		InputStream inputStream = new FileInputStream(""input.txt"");
		OutputStream outputStream = new FileOutputStream(""output.txt"");
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		Task solver = new Task();
		solver.solve(in, out);
		out.close();
	}

	static class Task {
		private class Point {
			int x, y;

			public Point(int x, int y) {
				this.x = x;
				this.y = y;
			}

		}

		private int dis(int i, int j, Point p2) {
			return Math.abs(i - p2.x) + Math.abs(j - p2.y);
		}

		public void solve(InputReader in, PrintWriter out) {
			int n = in.nextInt(), m = in.nextInt();
			int k = in.nextInt();
			Point[] ps = new Point[k];
			for (int i = 0; i < k; i++) {
				ps[i] = new Point(in.nextInt() - 1, in.nextInt() - 1);
			}
			int max = 0;
			Point argmax = ps[0];
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < m; j++) {
					int val = dis(i, j, ps[0]);
					for (int l = 1; l < k; l++) {
						val = Math.min(val, dis(i, j, ps[l]));
					}
					if (val > max) {
						max = val;
						argmax = new Point(i, j);
					}
				}
			}
			out.println((argmax.x + 1) + "" "" + (argmax.y + 1));
		}
	}

	static class InputReader {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public InputReader(InputStream stream) {
			reader = new BufferedReader(new InputStreamReader(stream), 32768);
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public String nextLine() {
			try {
				return reader.readLine();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}

	}

}
",6,5
"

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Scanner;

public class FireAgain 
{

	public static void main(String[] args) throws IOException 
	{

	      FileInputStream in = null;
	      FileOutputStream out = null;
	
	      try 
	      {
	         in = new FileInputStream(""input.txt"");
	         out = new FileOutputStream(""output.txt"");
	         
		  		Scanner sc = new Scanner(in);

	      
		int h = sc.nextInt();
		int w = sc.nextInt();
		
		int k = sc.nextInt();
		
		int[] xk = new int[k];
		int[] yk = new int[k];
		
		for(int i = 0; i < k; i++)
		{
			int y = sc.nextInt()-1;
			int x = sc.nextInt()-1;
			
			xk[i] = x;
			yk[i] = y;
		}

		int best = -1;
		int bestx = -1;
		int besty = -1;
		for(int x = 0; x < w; x++)
		{
			for(int y = 0; y < h; y++)
			{
				int cur = 99999;
				for(int f = 0; f < k; f++)
				{
					cur = Math.min(cur, Math.abs(xk[f] - x)+Math.abs(yk[f] - y));
				}
				
				if(cur > best)
				{
					best = cur;
					bestx = x;
					besty = y;
				}
			}
		}
		
//		System.out.println((besty+1) + "" "" + (bestx+1));
		String s = (besty+1) + "" "" + (bestx+1);

		out.write(s.getBytes());
		
	      }finally 
	      {
	         if (in != null) 
	         {
	            in.close();
	         }
	         if (out != null) 
	         {
	            out.close();
	         }
	      }		
	}

}
",6,5
"
import java.util.*;
import java.io.*;


public class C
{
   public static void main(String[] args) throws Exception
   {
      new C(new Scanner(new File(""input.txt"")), new PrintWriter(""output.txt""));
   }

   int oo = 987654321;
   int W, H;

   public C(Scanner in, PrintWriter out)
   {
      W = in.nextInt();
      H = in.nextInt();

      int[][] grid = new int[W][H];
      for (int[] gri : grid)
         Arrays.fill(gri, oo);
   
      ArrayDeque<Node> q = new ArrayDeque<Node>();
      int K = in.nextInt();
      for (int u=0; u<K; u++)
      {
         q.add(new Node(in.nextInt()-1, in.nextInt()-1, 0));
         while (q.size() > 0)
         {
            Node cur = q.poll();
            if (grid[cur.x][cur.y] <= cur.d)
               continue;
            grid[cur.x][cur.y] = cur.d;
            if (cur.x+1<W)
               q.add(new Node(cur.x+1, cur.y, cur.d+1));
            if (cur.x>0)
               q.add(new Node(cur.x-1, cur.y, cur.d+1));
            if (cur.y+1<H)
               q.add(new Node(cur.x, cur.y+1, cur.d+1));
            if (cur.y>0)
               q.add(new Node(cur.x, cur.y-1, cur.d+1));
         }
      }

      int res = 0;
      for (int j=0; j<H; j++)
         for (int i=0; i<W; i++)
            res = Math.max(res, grid[i][j]);

      for (int j=0; j<H; j++)
         for (int i=0; i<W; i++)
            if (res == grid[i][j])
            {
               out.printf(""%d %d%n"", i+1, j+1);
               out.close();
               return;
            }
   }
}

class Node
{
   int x, y, d;

   public Node(int xx, int yy, int dd)
   {
      x=xx; y=yy; d=dd;
   }
}
",6,5
"import java.io.BufferedReader;

import java.io.File;

import java.io.FileReader;

import java.io.IOException;

import java.io.PrintWriter;

import java.util.LinkedList;

import java.util.Queue;



public class FireAgain {



	public static void main(String[] args) throws IOException {

		BufferedReader readData = new BufferedReader(new FileReader(""input.txt""));

		PrintWriter writer = new PrintWriter(new File(""output.txt""));

		String line = readData.readLine();

		String[] temp = line.split("" "");

		int n = Integer.valueOf(temp[0]);

		int m = Integer.valueOf(temp[1]);

		int x = 0, y = 0;

		line = readData.readLine();

		int k = Integer.valueOf(line);

		boolean[][] visited = new boolean[n + 1][m + 1];

		Queue<Integer> qX = new LinkedList<Integer>();

		Queue<Integer> qY = new LinkedList<Integer>();

		line = readData.readLine();

		String[] temp2 = line.split("" "");

		for (int i = 0; i < temp2.length - 1; i+=2) {

			x = Integer.valueOf(temp2[i]);

			y = Integer.valueOf(temp2[i + 1]);

			visited[x][y] = true;

			qX.add(x);

			qY.add(y);

		}



		while (!qX.isEmpty()) {

			x = qX.poll();

			y = qY.poll();

			if (x >= 2 && !visited[x - 1][y]) {

				visited[x - 1][y] = true;

				qX.add(x - 1);

				qY.add(y);

			}

			if (x + 1 <= n && !visited[x + 1][y]) {

				visited[x + 1][y] = true;

				qX.add(x + 1);

				qY.add(y);

			}

			if (y >= 2 && !visited[x][y - 1]) {

				visited[x][y - 1] = true;

				qX.add(x);

				qY.add(y - 1);

			}

			if (y + 1 <= m && !visited[x][y + 1]) {

				visited[x][y + 1] = true;

				qX.add(x);

				qY.add(y + 1);

			}

		}

		writer.write(x + "" "");

		writer.write(y + "" "");

		writer.close();

	}



}

",6,3
"import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;


public class R035CRetry {
    public void debug(Object... objects) { System.err.println(Arrays.deepToString(objects)); }
    public static final int INF = 987654321;
    public static final long LINF = 987654321987654321L;
    public static final double EPS = 1e-9;
    
    Scanner scanner;
    PrintWriter out;
    boolean[][] bss;
    
    public R035CRetry() {
        try {
            this.scanner = new Scanner(new File(""input.txt""));
            this.out = new PrintWriter(""output.txt"");
        } catch(FileNotFoundException ex) { ex.printStackTrace(); }
    }
    
    class Point implements Comparable<Point> {
        int x, y, count;
        Point(int x, int y) { this.x = x; this.y = y; }
        public int hashCode() { return x * 17 + y; }
        public boolean equals(Object o) {
            if(!(o instanceof Point)) return false;
            Point that = (Point)o;
            return this.x == that.x && this.y == that.y;
        }
        public int compareTo(Point that) { return this.count - that.count; }
        public String toString()  { return ""("" + x + "", "" + y + "":"" + count + "")""; }
    }

    
    int[] dx = new int[] {  0, 0, -1, 1 };
    int[] dy= new int[] { -1, 1,  0, 0 };
    int n, m;
    
    Queue<Point> q;
    
    Point bfs() {
        int max = -INF;
        Point p = null;
        while(!q.isEmpty()) {
            Point cur = q.remove();
            if(max < cur.count) { max = cur.count; p = cur; } 
            for(int i=0; i<dx.length; i++) {
                int nx = cur.x + dx[i];
                int ny = cur.y + dy[i];
                if(nx < 0 || nx >= n) { continue; }
                if(ny < 0 || ny >= m) { continue; }
                Point np = new Point(nx, ny);
                if(bss[nx][ny] ) { continue; } 
                np.count = cur.count+1;
                bss[nx][ny] = true;
                q.add(np);
            }
        }
        return p;
    }
    
    private void solve() {
        this.n = scanner.nextInt();
        this.m = scanner.nextInt();
        this.bss = new boolean[n][m];
        int k = scanner.nextInt();
        q = new PriorityQueue<Point>();
        for(int i=0; i<k; i++) {
            int x = scanner.nextInt() - 1;
            int y = scanner.nextInt() - 1;
            Point init = new Point(x, y);
            init.count = 1;
            q.add(init);
            bss[x][y] = true;
        }
        Point p = bfs();
        out.println((p.x+1) + "" "" + (p.y+1));
    }
    
    private void finish() { this.out.close(); }
    
    public static void main(String[] args) { 
        R035CRetry obj = new R035CRetry();
        obj.solve();
        obj.finish();
    }
}
",6,3
"import java.util.*;

import java.io.*;



public class C {

	public static void main(String[] args) throws Exception {

		final int fuck = 2001;



		Scanner in = new Scanner(new File(""input.txt""));

		PrintWriter out = new PrintWriter(new File(""output.txt""));

		int n = in.nextInt(), m = in.nextInt();

		int[] D = new int[ fuck*fuck ], Q = new int[ fuck*(fuck + 1) ],

			dx = new int[] { 1, -1, 0, 0},

			dy = new int[] { 0, 0, -1, 1};

		Arrays.fill(D, -1);

		int H = -1, T = 0;



		int k = in.nextInt(), ans = 0;

		for(int i = 0; i < k; ++i) {

			int x = in.nextInt(), y = in.nextInt();

			D[x * fuck + y] = 0;



			++H; H %= Q.length;

			ans = Q[H] = x * fuck + y;

		}

		

		while(H >= T) {

			int idx = Q[T++]; T %= Q.length;

			int x = idx / fuck, y = idx % fuck;

			for(int i = 0; i < 4; ++i) {

				int wtf = (dx[i] + x) * fuck + (dy[i] + y);

				if(dx[i] + x <= n && dx[i] + x >= 1 && dy[i] + y <= m && dy[i] + y >= 1 && D[wtf] == -1) {

					D[wtf] = D[idx] + 1;

					++H; H %= Q.length;

					Q[H] = wtf;



					if(D[wtf] >= D[ans])

						ans = wtf;

				}

			}

		}



		out.println((ans / fuck) + "" "" + (ans % fuck));

		out.close();

		in.close();

	}

}",6,3
"import java.util.*;

import java.io.*;



public class SolutionC{

	public static void main(String[] args) throws Exception{

		Scanner sc = new Scanner(new File(""input.txt""));

		PrintWriter output = new PrintWriter(""output.txt"");

		int N = sc.nextInt();

		int M = sc.nextInt();

		int K = sc.nextInt();

		int[] x = new int[K];

		int[] y = new int[K];

		for(int i = 0 ; i < K ; i++){

			x[i] = sc.nextInt();

			y[i] = sc.nextInt();

		}

		int max = -1, max_x = -1, max_y = -1;

		for(int i = 1 ; i <= N ; i++){

			for(int j = 1 ; j <= M ; j++){

				int min = Integer.MAX_VALUE;

				for(int k = 0 ; k < K ; k++){

					min = Math.min(min, Math.abs(x[k] - i) + Math.abs(y[k] - j));

				}

				if(min > max){

					max = min;

					max_x = i;

					max_y = j;

				}

			}

		}

		output.println(max_x + "" "" + max_y);

		output.flush();

	}

}",6,5
"import java.util.*;
import java.io.*;

public class SolutionC{
	public static void main(String[] args) throws Exception{
		Scanner sc = new Scanner(new File(""input.txt""));
		PrintWriter output = new PrintWriter(""output.txt"");
		int N = sc.nextInt();
		int M = sc.nextInt();
		int K = sc.nextInt();
		int[] x = new int[K];
		int[] y = new int[K];
		for(int i = 0 ; i < K ; i++){
			x[i] = sc.nextInt();
			y[i] = sc.nextInt();
		}
		int max = -1, max_x = -1, max_y = -1;
		for(int i = 1 ; i <= N ; i++){
			for(int j = 1 ; j <= M ; j++){
				int min = Integer.MAX_VALUE;
				for(int k = 0 ; k < K ; k++){
					min = Math.min(min, Math.abs(x[k] - i) + Math.abs(y[k] - j));
				}
				if(min > max){
					max = min;
					max_x = i;
					max_y = j;
				}
			}
		}
		output.println(max_x + "" "" + max_y);
		output.flush();
	}
}",6,5
"import java.awt.*;
import java.io.*;
import java.util.*;
public class Abc {
    public static void main(String[] args) throws IOException {
//        FastReader sc = new FastReader();
        Scanner sc=new Scanner(new FileReader(""input.txt""));
        PrintWriter out=new PrintWriter(new File(""output.txt""));
        int n=sc.nextInt(),m=sc.nextInt(),k=sc.nextInt();
        boolean vis[][]=new boolean[n][m];
        LinkedList<Integer> q=new LinkedList<>();
        for (int i=0;i<k;i++){
            int x=sc.nextInt()-1,y=sc.nextInt()-1;
            vis[x][y]=true;
            q.add(x);q.add(y);
        }
        int lastx=-1,lasty=-1;
        int dirX[]={1,-1,0,0},dirY[]={0,0,1,-1};
        while (!q.isEmpty()){
            int x=q.removeFirst();
            int y=q.removeFirst();
            lastx=x;lasty=y;
            for (int i=0;i<4;i++){
                int newx=x+dirX[i],newy=y+dirY[i];
                if (newx>=0 && newx<n && newy>=0 && newy<m && !vis[newx][newy]){
                    vis[newx][newy]=true;
                    q.add(newx);q.add(newy);
                }
            }
        }
        out.println((lastx+1)+"" ""+(lasty+1));
        out.close();
    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}",6,3
"import java.io.OutputStream;

import java.io.FileOutputStream;

import java.io.IOException;

import java.io.FileInputStream;

import java.io.InputStream;

import java.io.PrintWriter;

import java.io.OutputStream;

import java.util.Arrays;

import java.io.IOException;

import java.io.InputStreamReader;

import java.io.File;

import java.io.FileNotFoundException;

import java.util.StringTokenizer;

import java.io.Writer;

import java.io.BufferedReader;

import java.io.FileReader;

import java.io.InputStream;



/**

 * Built using CHelper plug-in

 * Actual solution is at the top

 * @author zodiacLeo

 */

public class Main

{

    public static void main(String[] args)

    {

        InputStream inputStream;

        try

        {

            inputStream = new FileInputStream(""input.txt"");

        } catch (IOException e)

        {

            throw new RuntimeException(e);

        }

        OutputStream outputStream;

        try

        {

            outputStream = new FileOutputStream(""output.txt"");

        } catch (IOException e)

        {

            throw new RuntimeException(e);

        }

        FastScanner in = new FastScanner(inputStream);

        FastPrinter out = new FastPrinter(outputStream);

        TaskC solver = new TaskC();

        solver.solve(1, in, out);

        out.close();

    }



    static class TaskC

    {

        private final static int[] dx = {-1, 0, +1, 0};

        private final static int[] dy = {0, +1, 0, -1};

        private final static int WHITE = 123456789;



        public void solve(int testNumber, FastScanner in, FastPrinter out)

        {

            int n = in.nextInt();

            int m = in.nextInt();



            int[][] map = new int[n][m];

            for (int i = 0; i < n; i++)

            {

                Arrays.fill(map[i], WHITE);

            }



            int k = in.nextInt();



            int qh = 0;

            int qt = 0;

            int[] q = new int[((int) 7e6)];

            for (int i = 0; i < k; i++)

            {

                int x = in.nextInt() - 1;

                int y = in.nextInt() - 1;

                map[x][y] = 0;

                q[qh++] = x * m + y;

            }



            int d = 0;

            int X = q[0] / m;

            int Y = q[0] % m;

            while (qt < qh)

            {

                int pos = q[qt++];

                int x = pos / m;

                int y = pos % m;

                for (int i = 0; i < 4; i++)

                {

                    int xx = x + dx[i];

                    int yy = y + dy[i];

                    if (isValid(xx, n) && isValid(yy, m) && map[xx][yy] == WHITE)

                    {

                        map[xx][yy] = map[x][y] + 1;

                        q[qh++] = (xx * m) + yy;

                        if (d < map[xx][yy])

                        {

                            d = map[xx][yy];

                            X = xx;

                            Y = yy;

                        }

                    }

                }

            }

//        for (int i = 0; i < n; i++)

//        {

//            for (int j = 0; j < m; j++)

//            {

//                out.print(map[i][j] + "" "");

//            }

//            out.println();

//        }

            out.println((X + 1) + "" "" + (Y + 1));

        }



        private boolean isValid(int x, int X)

        {

            return x >= 0 && x < X;

        }



    }



    static class FastScanner

    {

        public BufferedReader br;

        public StringTokenizer st;



        public FastScanner(InputStream is)

        {

            br = new BufferedReader(new InputStreamReader(is));

        }



        public FastScanner(File f)

        {

            try

            {

                br = new BufferedReader(new FileReader(f));

            } catch (FileNotFoundException e)

            {

                e.printStackTrace();

            }

        }



        public String next()

        {

            while (st == null || !st.hasMoreElements())

            {

                String s = null;

                try

                {

                    s = br.readLine();

                } catch (IOException e)

                {

                    e.printStackTrace();

                }

                if (s == null)

                    return null;

                st = new StringTokenizer(s);

            }

            return st.nextToken();

        }



        public int nextInt()

        {

            return Integer.parseInt(next());

        }



    }



    static class FastPrinter extends PrintWriter

    {

        public FastPrinter(OutputStream out)

        {

            super(out);

        }



        public FastPrinter(Writer out)

        {

            super(out);

        }



    }

}



",6,3
"import java.util.*;
import java.io.*;
 

public class S35C{
       public static void main(String[] args) throws Exception{
               BufferedReader br=new BufferedReader(new FileReader(""input.txt""));
               PrintWriter out=new PrintWriter(new FileWriter(""output.txt""));
               String[] s=br.readLine().split("" "");
      int n=Integer.parseInt(s[0]);
		int m=Integer.parseInt(s[1]);

		int[][] ar=new int[n+1][m+1];
		 for(int i=1;i<=n;i++)
		 {
              	for(int j=1;j<=m;j++)
              	{
                    ar[i][j]=Integer.MAX_VALUE;
               	}
         }

        int ax=0,ay=0;
             
		int k=Integer.parseInt(br.readLine());
		Pair[] pr=new Pair[k];
		int cn=0;
		 String[] st=br.readLine().split("" "");
		 for(int i=0;i<st.length;i+=2){
		     int x=Integer.parseInt(st[i]);
		      int y=Integer.parseInt(st[i+1]);
		      ar[x][y]=-1;
		      pr[cn]=new Pair(x,y);
		      cn++;
		 }

		  int dis=0;
		  for(int l=0;l<k;l++)
		  {
		      for(int i=1;i<=n;i++)
		      {
              	  for(int j=1;j<=m;j++)
              	  {
                     int max=Math.abs(pr[l].x-i)+Math.abs(pr[l].y-j);
                     if(ar[i][j]!=-1)
                     {
                     	ar[i][j]=Math.min(ar[i][j],max);
                     }
               	  }
              }
           }

            for(int i=1;i<=n;i++)
            {
              	for(int j=1;j<=m;j++)
              	{
                    if(ar[i][j]>dis)
                    {
                    	dis=ar[i][j];
                    	ax=i;
                    	ay=j;
                    }
               	}
            }
            if(ax==0) ax=1;
            if(ay==0) ay=1;
		 out.println(ax+"" ""+ay);
		 out.close();

    }


static void ReverSort(int[] ar){
    ArrayList<Integer> al=new ArrayList<>();
    for(int i=0;i<ar.length;i++){
        al.add(ar[i]);
    }

    Collections.sort(al);
      int j=0;
    for(int i=al.size()-1;i>=0;i--){

        ar[j]=al.get(i);
        j++;
    }
}
static void Sort(int[] ar){
    ArrayList<Integer> al=new ArrayList<>();
    for(int i=0;i<ar.length;i++){
        al.add(ar[i]);
    }

    Collections.sort(al);
      int j=0;
    for(int i=0;i<al.size();i++){

        ar[j]=al.get(i);
        j++;
     }
  }

 
static int gcd(int a,int b){
    if(b==0) return a;
    else return  gcd(b,a%b);
}
}

class Pair{
    int x, y;
     Pair(int x,int y){
        this.x=x;
        this.y=y;
     }
}

class SortPair implements Comparator<Pair>{

    public int compare(Pair p1, Pair p2){
        return p1.y-p2.y;
    }
}

class Fast{
  BufferedReader br; 
  StringTokenizer st;
  public Fast(){ br=new BufferedReader(new InputStreamReader(System.in)); }
  String next() 
        {  while (st == null || !st.hasMoreElements()) 
            {   try
                {     st = new StringTokenizer(br.readLine()); } 
                catch (IOException  e) 
                {    e.printStackTrace(); } 
            } 
            return st.nextToken(); 
        }
  int nextInt(){  return Integer.parseInt(next()); }
  long nextLong(){     return Long.parseLong(next()); } 
  double nextDouble() {     return Double.parseDouble(next()); } 
  String nextLine() 
        { 
            String str = """"; 
            try{      str = br.readLine(); } 
            catch (IOException e)  {  e.printStackTrace(); } 
            return str; 
        } 
}
    
",6,5
"import java.io.BufferedReader;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.FileWriter;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.LinkedList;

import java.util.Queue;

import java.util.StringTokenizer;



public class A {



	static final int[] dx = {0, 0, -1, 1};

	static final int[] dy = {-1, 1, 0, 0};

	

	public static void main(String[] args) throws IOException {



		Scanner sc = new Scanner(""input.txt"");

		PrintWriter out = new PrintWriter(new FileWriter(""output.txt""));

//		Scanner sc = new Scanner(System.in);

//		PrintWriter out = new PrintWriter(System.out);



		int N = sc.nextInt(), M = sc.nextInt();

		int[][] dist = new int[N][M];

		Queue<Integer> q = new LinkedList<>();

		int K = sc.nextInt();

		while(K-->0)

		{

			int x = sc.nextInt() - 1, y = sc.nextInt() - 1;

			q.add(x * M + y);

			dist[x][y] = 1;

		}

		

		int max = 0, ansX = -1, ansY = -1;

		while(!q.isEmpty())

		{

			int u = q.remove(), x = u / M, y = u % M;

			if(dist[x][y] > max) 

				max = dist[ansX = x][ansY = y];

			for(int k = 0; k < 4; ++k)

			{

				int nx = x + dx[k], ny = y + dy[k];

				if(nx >= 0 && ny >= 0 && nx < N && ny < M && dist[nx][ny] == 0)

				{

					dist[nx][ny] = dist[x][y] + 1;

					q.add(nx * M + ny);

				}

				

			}

		}

		out.printf(""%d %d\n"", ansX + 1, ansY + 1);

		out.close();

	}

	



	static class Scanner 

	{

		StringTokenizer st;

		BufferedReader br;



		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

		

		public Scanner(String s) throws FileNotFoundException{	br = new BufferedReader(new FileReader(s));}



		public String next() throws IOException 

		{

			while (st == null || !st.hasMoreTokens()) 

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}



		public int nextInt() throws IOException {return Integer.parseInt(next());}



		public long nextLong() throws IOException {return Long.parseLong(next());}



		public String nextLine() throws IOException {return br.readLine();}



		public double nextDouble() throws IOException { return Double.parseDouble(next()); }



		public boolean ready() throws IOException {return br.ready();} 

	}

}",6,1
"import java.io.*;
import java.util.*;

public class Main { 
    public static void main(String[] args) throws IOException { 
        //InputStream input = System.in;
        //OutputStream output = System.out;
        InputReader in = new InputReader(new FileReader(new File(""input.txt"")));
        PrintWriter out = new PrintWriter(new FileWriter(new File(""output.txt"")));
        //InputReader in = new InputReader(input);
        //PrintWriter out = new PrintWriter(output);
        Solution s = new Solution();
        s.solve(1, in, out);
        out.close();
    }

    static class Solution { 
        
        double EPS = 0.0000001;
        public void solve(int cs, InputReader in, PrintWriter out) {

            int n = in.nextInt(), m = in.nextInt();
            Graph g = new Graph(n, m);
            int k = in.nextInt();
            for (int[] v : g.vis)
                Arrays.fill(v, -1);
            while (k-- > 0) {
                Pair start = new Pair(in.nextInt()-1, in.nextInt()-1);
                g.bfs(start);
            }
            int idx1 = 0, idx2 = 0, max = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; ++j) {
                    if (g.vis[i][j] > max) {
                        idx1 = i;
                        idx2 = j;
                        max = g.vis[i][j];
                    }
                }
            }
            out.println((idx1+1) + "" "" + (idx2+1));
        }

        static class Pair {
            int x, y;

            public Pair(int x, int y) {
                this.x = x ;
                this.y = y;
            }
        }

        static class Graph {
            LinkedList<Integer> adj[];
            int n, e;
            int[][] vis;

            @SuppressWarnings(""unchecked"")
            public Graph(int n, int e) {
                this.n = n;
                this.e = e;
                adj = new LinkedList[n];
                for (int i = 0; i < n; ++i)
                    adj[i] = new LinkedList<>();
                vis = new int[n][e];
            }
            
            int[] dx = {0, 0, 1, -1};
            int[] dy = {1, -1, 0, 0};

            void bfs(Pair src) {
                Queue<Pair> q = new LinkedList<>();
                vis[src.x][src.y] = 0;
                q.add(src);
                while (!q.isEmpty()) {
                    Pair p = q.poll();
                    for (int k = 0; k < 4; k++) {
                        int ni = p.x+dx[k];
                        int nj = p.y+dy[k];
                        if (isValid(ni, nj) && (vis[ni][nj] == -1 || vis[p.x][p.y]+1 < vis[ni][nj])) {
                            vis[ni][nj] = vis[p.x][p.y]+1;
                            q.add(new Pair(ni, nj));
                        }
                    }
                    
                }
            }

            boolean isValid(int i, int j) {
                return i >= 0 && i < n && j >= 0 && j < e;
            }
        }
    }

    static class InputReader { 
        BufferedReader br;
        StringTokenizer st;
        
        public InputReader(InputStream i) {
            br = new BufferedReader(new InputStreamReader(i), 32768);
            st = null;
        }

        public InputReader(FileReader s) {
            br = new BufferedReader(s);
            st = null;
        }

        public String next() {
            while (st == null || !st.hasMoreTokens()) {
                try { 
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        public int nextInt() { 
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() { 
            try { 
                return br.readLine();
            } catch (IOException e) { 
                throw new RuntimeException(e);
            }
        }
    }
    static class Reader {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;
        public Reader(){
            din=new DataInputStream(System.in);
            buffer=new byte[BUFFER_SIZE];
            bufferPointer=bytesRead=0;
        }

        public Reader(String file_name) throws IOException{
            din=new DataInputStream(new FileInputStream(file_name));
            buffer=new byte[BUFFER_SIZE];
            bufferPointer=bytesRead=0;
        }

        public String readLine() throws IOException{
            byte[] buf=new byte[64]; // line length
            int cnt=0,c;
            while((c=read())!=-1){
                if(c=='\n')break;
                buf[cnt++]=(byte)c;
            }
            return new String(buf,0,cnt);
        }

        public int nextInt() throws IOException{
            int ret=0;byte c=read();
            while(c<=' ')c=read();
            boolean neg=(c=='-');
            if(neg)c=read();
            do{ret=ret*10+c-'0';}while((c=read())>='0'&&c<='9');
            if(neg)return -ret;
            return ret;
        }

        public long nextLong() throws IOException{
            long ret=0;byte c=read();
            while(c<=' ')c=read();
            boolean neg=(c=='-');
            if(neg)c=read();
            do{ret=ret*10+c-'0';}while((c=read())>='0'&&c<='9');
            if(neg)return -ret;
            return ret;
        }

        public double nextDouble() throws IOException{
            double ret=0,div=1;byte c=read();
            while(c<=' ')c=read();
            boolean neg=(c=='-');
            if(neg)c = read();
            do {ret=ret*10+c-'0';}while((c=read())>='0'&&c<='9');
            if(c=='.')while((c=read())>='0'&&c<='9')
                ret+=(c-'0')/(div*=10);
            if(neg)return -ret;
            return ret;
        }

        private void fillBuffer() throws IOException{
            bytesRead=din.read(buffer,bufferPointer=0,BUFFER_SIZE);
            if(bytesRead==-1)buffer[0]=-1;
        }

        private byte read() throws IOException{
            if(bufferPointer==bytesRead)fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException{
            if(din==null) return;
            din.close();
        }
    }
}

",6,5
"import java.awt.Point;

import java.io.*;

import java.math.BigInteger;

import java.util.*;

import static java.lang.Math.*;

 

public class Solution35C {

        

        final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"")!=null;

        BufferedReader in;

        PrintWriter out;

        StringTokenizer tok = new StringTokenizer("""");

        

        void init() throws FileNotFoundException{

                if (ONLINE_JUDGE){

            		in = new BufferedReader(new FileReader(""input.txt""));

                    out = new PrintWriter(""output.txt"");

                }else{

                        in = new BufferedReader(new FileReader(""input.txt""));

                        out = new PrintWriter(""output.txt"");

                }

        }

        

        String readString() throws IOException{

                while(!tok.hasMoreTokens()){

                        tok = new StringTokenizer(in.readLine());

                }

                return tok.nextToken();

        }

        

        int readInt() throws IOException{

                return Integer.parseInt(readString());

        }

        

        long readLong() throws IOException{

                return Long.parseLong(readString());

        }

        

        double readDouble() throws IOException{

                return Double.parseDouble(readString());

        }

        

        public static void main(String[] args){

                new Solution35C().run();

        }

        

        public void run(){

                try{

                        long t1 = System.currentTimeMillis();

                        init();

                        solve();

                        out.close();

                        long t2 = System.currentTimeMillis();

                        System.err.println(""Time = ""+(t2-t1));

                }catch (Exception e){

                        e.printStackTrace(System.err);

                        System.exit(-1);

                }

        }

        

        static class Utils {

 

                private Utils() {}

 

                public static void mergeSort(int[] a) {

                        mergeSort(a, 0, a.length - 1);

                }

 

                private static void mergeSort(int[] a, int leftIndex, int rightIndex) {

                        final int MAGIC_VALUE = 50;

                        if (leftIndex < rightIndex) {

                                if (rightIndex - leftIndex <= MAGIC_VALUE) {

                                        insertionSort(a, leftIndex, rightIndex);

                                } else {

                                        int middleIndex = (leftIndex + rightIndex) / 2;

                                        mergeSort(a, leftIndex, middleIndex);

                                        mergeSort(a, middleIndex + 1, rightIndex);

                                        merge(a, leftIndex, middleIndex, rightIndex);

                                }

                        }

                }

 

                private static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {

                        int length1 = middleIndex - leftIndex + 1;

                        int length2 = rightIndex - middleIndex;

                        int[] leftArray = new int[length1];

                        int[] rightArray = new int[length2];

                        System.arraycopy(a, leftIndex, leftArray, 0, length1);

                        System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);

                        for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {

                                if (i == length1) {

                                        a[k] = rightArray[j++];

                                } else if (j == length2) {

                                        a[k] = leftArray[i++];

                                } else {

                                        a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];

                                }

                        }

                }

 

                private static void insertionSort(int[] a, int leftIndex, int rightIndex) {

                        for (int i = leftIndex + 1; i <= rightIndex; i++) {

                                int current = a[i];

                                int j = i - 1;

                                while (j >= leftIndex && a[j] > current) {

                                        a[j + 1] = a[j];

                                        j--;

                                }

                                a[j + 1] = current;

                        }

                } 

        }

        

        void solve() throws IOException{

        	int n = readInt();

        	int m = readInt();

        	int k = readInt();

        	Point[] focuses = new Point[k];

        	for(int i = 0; i < k; i++){

        		int a = readInt() - 1;

        		int b = readInt() - 1;

        		focuses[i] = new Point(a,b);

        	}

        	int maxI = 0, maxJ = 0;

        	int max = 0;

        	for(int i = 0; i < n; i++)

        		for(int j = 0; j < m; j++){

        			int curMin = 1000000;

        			for(int r = 0; r < k; r++)

        				if(abs(focuses[r].x - i) + abs(focuses[r].y - j) < curMin){

        					curMin = abs(focuses[r].x - i) + abs(focuses[r].y - j);

        					if(curMin < max) break;

        				}

    				if(curMin > max){

    					max = curMin;

    					maxI = i;

    					maxJ = j;

    				}              			

        		}

        	maxI++;

        	maxJ++;

        	out.println(maxI + "" "" + maxJ);

        }

        

        static double distance(long x1, long y1, long x2, long y2){

        	return Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));

        }

        

        static long gcd(long a, long b){

        	while(a != b){

        		if(a < b) a -=b;

        		else b -= a;

        	}

        	return a;

        }

        

        static long lcm(long a, long b){

        	return a * b /gcd(a, b);

        }

}",6,5
"import java.util.*;

import java.io.*;



public class Main implements Runnable {

		

	public void solve() throws IOException {

		int N = nextInt();

                int M = nextInt();

                

                int B = nextInt();

                int[][] burn = new int[B][2];

                for(int i = 0; i < B; i++){

                        burn[i][0] = nextInt();

                        burn[i][1] = nextInt();

                }

                

                int ansx = -1;

                int ansy = -1;

                int ans = -1;

                

                for(int i = 1; i <= N; i++){

                        for(int j = 1; j <= M; j++){

                                int burnAt = Integer.MAX_VALUE;

                                for(int k = 0; k < B; k++){

                                        int now = distance(i, j, burn[k][0], burn[k][1]);

                                        burnAt = Math.min(burnAt, now);

                                }

                                //System.out.println(burnAt + "" "" + i + "" "" + j);

                                if(burnAt >= ans){

                                        

                                        ans = burnAt;

                                        ansx = i;

                                        ansy = j;

                                        

                                }

                        }

                }

                

                

                out.println(ansx + "" "" + ansy);

	}

        

        private int distance(int x, int y, int xx, int yy){

                //withour sqrt

                return Math.abs(xx - x) + Math.abs(yy - y);

        }



	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	//-----------------------------------------------------------

	public static void main(String[] args) {

		new Main().run();

	}



	public void run() {

		try {

			//in = new BufferedReader(new InputStreamReader(System.in));

			in = new BufferedReader(new FileReader(new File(""input.txt"")));

                        out = new PrintWriter(new FileWriter(new File(""output.txt"")));

                        tok = null;

			solve();

			in.close();

                        out.close();

		} catch (IOException e) {

			System.exit(0);

		}

	}



	public String nextToken() throws IOException {

		while (tok == null || !tok.hasMoreTokens()) {

			tok = new StringTokenizer(in.readLine());

		}

		return tok.nextToken();

	}



	public int nextInt() throws IOException {

		return Integer.parseInt(nextToken());

	}



	public long nextLong() throws IOException {

		return Long.parseLong(nextToken());

	}



	public double nextDouble() throws IOException {

		return Double.parseDouble(nextToken());

	}



        PrintWriter out;

	BufferedReader in;

	StringTokenizer tok;

}",6,5
"import java.util.LinkedList;
import java.io.FileInputStream;
import java.util.Arrays;
import java.util.ArrayList;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.util.Collection;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Queue;
import java.io.IOException;
import java.io.FileOutputStream;
import java.util.StringTokenizer;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author nasko
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream;
		try {
			inputStream = new FileInputStream(""input.txt"");
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		OutputStream outputStream;
		try {
			outputStream = new FileOutputStream(""output.txt"");
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskC solver = new TaskC();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskC {

    public void solve(int testNumber, InputReader in, PrintWriter out) {

        int N = in.nextInt();
        int M = in.nextInt();
        int K = in.nextInt();
        int[][] dist = new int[N+1][M+1];
        for(int[] ini : dist) Arrays.fill(ini,1 << 30);
        int best = 0;
        ArrayList<Integer> result = new ArrayList<Integer>();
        Queue<Integer> q = new LinkedList<Integer>();
        for(int k = 0; k < K; ++k) {
            int x = in.nextInt();
            int y = in.nextInt();
            dist[x][y] = 0;
            q.offer(x);
            q.offer(y);

        }

        int[] dx = new int[] { 1,-1,0,0 };
        int[] dy = new int[] {0,0,1,-1};

        while(!q.isEmpty()) {

            int a = q.poll();
            int b = q.poll();
            for(int r = 0; r < 4; ++r) {
                int x = a + dx[r];
                int y = b + dy[r];
                if(x >= 1 && x <= N && y >=1 && y <= M && dist[x][y] > dist[a][b] + 1) {
                    dist[x][y] = dist[a][b] + 1;

                    q.offer(x);
                    q.offer(y);
                }
            }
        }
        for(int i = 1; i <= N; ++i)
            for(int j = 1; j <= M; ++j) best = Math.max(best,dist[i][j]);
        for(int a = 1; a <= N; ++a)
            for(int b = 1; b <= M; ++b) if(dist[a][b] == best) {
                result.add(a);
                result.add(b);
            }

        if(result.size() > 0) {
            out.print(result.get(0) + "" "" + result.get(1));
        }

        out.println();

    }

}

class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream));
        tokenizer = null;
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

}

",6,5
"import java.util.*;
import java.io.*;
import java.awt.Point;

public class Main{
	public static void main(String[] args)throws FileNotFoundException,IOException{
		File file = new File(""input.txt"");
		Scanner sc = new Scanner(file);
		File outFile = new File(""output.txt"");
		PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));

		int w = sc.nextInt();
		int h = sc.nextInt();
		boolean[][] map = new boolean[h+1][w+1]; //false:ï¿½uï¿½Gï¿½vï¿½ï¿½ï¿½Ä‚È‚ï¿½

		int x = -1, y = -1;
		Queue<Point> open = new LinkedList<Point>();
		int k = sc.nextInt();
		for(int i=0;i<k;i++){
			int tx = sc.nextInt();
			int ty = sc.nextInt();
			map[ty][tx] = true;
			x = tx;
			y = ty;
			open.add(new Point(x,y));
		}

		int dx[] = {1,-1,0,0};
		int dy[] = {0,0,1,-1};
		while(!open.isEmpty()){
			Point p = open.poll();

			for(int i=0;i<4;i++){
				int nx = p.x + dx[i];
				int ny = p.y + dy[i];

				if(nx>0 && nx<=w && ny>0 && ny<=h && !map[ny][nx]){
					map[ny][nx] = true;
					x = nx;
					y = ny;
					open.add(new Point(nx,ny));
				}
			}
		}

		pw.println(x + "" "" + y);

		pw.close();
	}
}
",6,3
"import java.io.*;
import java.util.*;

public class P_35C {
    static final FS sc = new FS();
    static final PrintWriter pw = new PrintWriter(System.out);
    static int[][] g;
    static int[][] res;
    static boolean[][] visited;
    static int[] dx = {1,0,-1,0};
    static int[] dy = {0,-1,0,1};
    static int n, m;
    static Queue<Integer> qx;
    static Queue<Integer> qy;
    static Queue<Integer> c;
    static void bfs(){
        while(!qx.isEmpty() && !qy.isEmpty()){
            int xn = qx.poll();
            int yn = qy.poll();
            for(int i=0; i<4; i++){
                int nx = xn+dx[i];
                int ny = yn+dy[i];
                if(nx>=0 && ny>=0 && nx<n && ny<m && res[nx][ny]==-1){
                    res[nx][ny] = res[xn][yn]+1;
                    qx.add(nx);
                    qy.add(ny);
//                    c.add(pn);
                    visited[nx][ny] = true;
                }
            }
        }
    }
    public static void main(String[] args) throws FileNotFoundException {
        File file = new File(""input.txt"");
        Scanner sc = new Scanner(file);
        n = sc.nextInt();
        m = sc.nextInt();
        int k = sc.nextInt();
        ArrayList<Integer> xl = new ArrayList<>();
        ArrayList<Integer> yl = new ArrayList<>();
        g = new int[n][m];
        res = new int[n][m];
        visited = new boolean[n][m];
        qx = new LinkedList<>();
        qy = new LinkedList<>();
        for(int i=0; i<k; i++){
            int xi = sc.nextInt()-1;
            int yi = sc.nextInt()-1;
//            --xi; --yi;
            qx.add(xi); qy.add(yi);
//            xl.add(xi); yl.add(yi);
            res[xi][yi] = 1;
//            g[--xi][--yi] = 1;
        }
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(res[i][j]==1) res[i][j] = 0;
                else res[i][j] = -1;
            }
        }
        bfs();
        int x = 0,y = 0;
        int max = Integer.MIN_VALUE;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(res[i][j]>max){
                    max = res[i][j];
                    x = i; y = j;
                }
            }
        }


//        for(int i=0; i<n; i++) System.out.println(Arrays.toString(res[i]));
        try {
            FileWriter writer = new FileWriter(""output.txt"");
            writer.write((x+1)+"" ""+(y+1));
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
//        System.out.println((x+1)+"" ""+(y+1));
    }

    static class FS {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer("""");

        String next() {
            while (!st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (Exception ignored) {
                }
            }
            return st.nextToken();
        }

        int[] nextArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = nextInt();
            }
            return a;
        }

        long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = nextLong();
            }
            return a;
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }
    }
}
",6,5
"import java.io.*;

import java.util.*;

import java.lang.*;



public class Main {

    public static void main(String[] args) throws IOException {

        InputStream input = System.in;

        OutputStream output = System.out;

        InputReader in = new InputReader(new FileReader(new File(""input.txt"")));

        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));

        Solution s = new Solution();

        s.solve(1, in, out);

        out.close();

    }



    static class Solution {



        static int[][] grid;

        static int[] dx = {0, 0, 1, -1};

        static int[] dy = {1, -1, 0, 0};

        static int n, m;

        public void solve(int cs, InputReader in, PrintWriter out) {

            n = in.nextInt();

            m = in.nextInt();

            int k = in.nextInt();

            grid = new int[n][m];

            for (int[] d : grid)

                Arrays.fill(d, -1);

            for (int i = 0; i < k; i++) {

                Pair tree = new Pair(in.nextInt()-1, in.nextInt()-1);

                bfs(tree);

            }

            int max = 0, idx1 = 0, idx2 = 0;

            for (int i = 0; i < n; i++) {

                for (int j = 0; j < m; j++) {

                    if (grid[i][j] > max) {

                        max = grid[i][j];

                        idx1 = i;

                        idx2 = j;

                    }

                }

            }

            out.printf(""%d %d%n"", idx1+1, idx2+1);





        }

        public boolean isValid(int i, int j) {

            return i >= 0 && i < n && j >= 0 && j < m;

        }





        static class Pair {

            int x, y;

            public Pair(int x, int y) {

                this.x = x;

                this.y = y;

            }

        }

        public void bfs(Pair src) {

            Queue<Pair> q = new LinkedList<>();

            grid[src.x][src.y] = 0;

            q.add(src);

            while (!q.isEmpty()) {

                Pair p = q.poll();

                for (int k = 0; k < 4; k++) {

                    int nx = p.x+dx[k];

                    int ny = p.y+dy[k];

                    if (isValid(nx, ny)) {

                        if (grid[nx][ny] > grid[p.x][p.y]+1 || grid[nx][ny] == -1) {

                            grid[nx][ny] = grid[p.x][p.y] + 1;

                            q.add(new Pair(nx, ny));

                        }

                    }

                }

            }

        }

    }



    static class InputReader {

        BufferedReader br;

        StringTokenizer st;



        public InputReader(InputStream i) {

            br = new BufferedReader(new InputStreamReader(i), 32768);

            st = null;

        }

        

        public InputReader(FileReader s) {

           br = new BufferedReader(s);

           st = null;

        }



        public String next() {

            while (st == null || !st.hasMoreTokens()) {

                try {

                    st = new StringTokenizer(br.readLine());

                } catch (IOException e) {

                    throw new RuntimeException(e);

                }

            }

            return st.nextToken();

        }



        public int nextInt() {

            return Integer.parseInt(next());

        }



        public long nextLong() {

            return Long.parseLong(next());

        }



        public double nextDouble() {

            return Double.parseDouble(next());

        }



        public String nextLine() {

            try {

                return br.readLine();

            } catch (IOException e) {

                throw new RuntimeException(e);

            }

        }



    }



}

",6,5
"import java.util.*;

import java.io.*;



public class C {



	private static int[] dx = {1, -1, 0, 0};

	private static int[] dy = {0, 0, -1, 1};



	public static void main(String[] args) throws Exception{

		Thread t = new Thread(null, null, ""~"", Runtime.getRuntime().maxMemory()){

			@Override

			public void run(){

				try {

					solve();

				} catch(Exception e) {

					System.err.println(""ERROR"");

				}

			}

		};



		t.start();

		t.join();	

	}



	public static void solve() throws Exception {

		Scanner in = new Scanner(new File(""input.txt""));

		PrintWriter out = new PrintWriter(new File(""output.txt""));



		int n = in.nextInt();

		int m = in.nextInt();



		int[][] time = new int[n][m];

		for(int i = 0; i < n; ++i) {

			Arrays.fill(time[i], Integer.MAX_VALUE);

		}



		int qq = in.nextInt();

		int[] xs = new int[qq];

		int[] ys = new int[qq];



		for(int i = 0; i < qq; ++i){

			xs[i] = in.nextInt() - 1;

			ys[i] = in.nextInt() - 1;

		}





		for(int i = 0; i < n; ++i) {

			for(int j = 0; j < m; ++j) {

				for(int k = 0; k < qq; ++k) {

					int dist = Math.abs(i - xs[k]) + Math.abs(j - ys[k]);

					time[i][j] = Math.min(time[i][j], dist);

				}

			}

		}



		int max = -1;

		int x = -1;

		int y = -1;



		for(int i = 0; i < n; ++i) {

			for(int j = 0; j < m; ++j) if(max < time[i][j]) {



				max = time[i][j];

				x = i + 1;

				y = j + 1;

			} 

		}



		out.println(x + "" "" + y);



		out.flush();

		out.close();

	}



	private static class Pair {

		int f, s;

		int time;



		public Pair(int f, int s) {

			this.f = f;

			this.s = s;

		}



		public Pair(int f, int s, int time) {

			this(f, s);

			this.time = time;

		}



	}

}",6,5
"import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) throws FileNotFoundException {
		// TODO Auto-generated method stub
		Scanner read = new Scanner(new FileInputStream(new File(""input.txt"")));
		PrintWriter out = new PrintWriter(new File(""output.txt""));
		int n = read.nextInt(), m = read.nextInt(), k = read.nextInt(), tree[][] = new int[n][m], a[] = new int[k],
				b[] = new int[k], x = 0, y = 0, max = -1, d = 0;

		for (int i = 0; i < k; i++) {
			a[i] = read.nextInt() - 1;
			b[i] = read.nextInt() - 1;	
			tree[a[i]][b[i]] = 0;
		}
		for(int i = 0; i < n; i++){
			Arrays.fill(tree[i], Integer.MAX_VALUE);
		}
		for (int o = 0; o < k; o++) {
			for(int i = 0; i < n; i++){
				for(int j = 0; j < m; j++){
					d = Math.abs(a[o] - i) + Math.abs(b[o] - j);
					if(d < tree[i][j])
						tree[i][j] = d;
				}
			}
		}
		for(int i = 0; i<n; i++){
			for(int j = 0; j < m ; j ++){
				if(tree[i][j] > max){
					max=  tree[i][j];
					x=  i;
					y = j;
				}
			}
		}
		out.println(x + 1 + "" "" + (y + 1));
		out.close();
	}

}",6,5
"import java.util.Scanner;

import java.util.HashSet;

import java.io.PrintWriter;

import java.io.File;

public class FireAgain {



    public static void main(String[] args){

	

	File in = new File(""input.txt"");

	File out = new File(""output.txt"");

	Scanner sc;

	PrintWriter pw;

	try{

	    sc = new Scanner(in);

	    pw = new PrintWriter(out);

	}catch(Exception e){

	    sc = new Scanner(System.in);

	    pw = null;

	}



	int max_x = sc.nextInt();

	int max_y = sc.nextInt();

	int start_num = sc.nextInt();

	HashSet<int[]> start = new HashSet<int[]>();

	for(int i=0; i<start_num; i++){

	    int[] cell = new int[2];

	    cell[0] = sc.nextInt();

	    cell[1] = sc.nextInt();

	    start.add(cell);

	}



	int[] result = new int[]{1,1};

	int resultLen = 0;

	for(int i=1; i<=max_x; i++){

	    for(int j=1; j<=max_y; j++){

		int[] sh = new int[]{1,1};

		int shLen = Integer.MAX_VALUE;

		for(int[] fired: start){

		    int len = Math.abs(i - fired[0]) + Math.abs(j - fired[1]);

		    if(len < shLen){

			sh[0] = i;

			sh[1] = j;

			shLen = len;

		    }

		}

		if(shLen > resultLen){

		    result[0] = sh[0];

		    result[1] = sh[1];

		    resultLen = shLen;

		}

	    }

	}

	pw.print(result[0] + "" "" + result[1]);

	pw.close();

	return ;

    }

}  ",6,5
"import java.awt.Point;

import java.io.File;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.PrintStream;

import java.util.LinkedList;

import java.util.Queue;

import java.util.Scanner;

import java.util.HashSet;



public class FireAgain {



	Point[] coordinate;

	Queue<Point> q = new LinkedList<>();

	// HashSet<Point> vis = new HashSet<>();

	boolean[][] vis;

	PrintStream out;

	int x, y;



	boolean distance(Point word1, Point word2) {



		if (Math.abs(word1.x - word2.x) == 1 && Math.abs(word1.y - word2.y) == 1)

			return false;



		if (Math.abs(word1.x - word2.x) == 1 && word1.y == word2.y)

			return true;



		if (word1.x == word2.x && Math.abs(word1.y - word2.y) == 1)

			return true;



		return false;

	}



	void bfs(Point s) {



		while (!q.isEmpty()) {

			s = q.poll();



			Point p = new Point();

			p.x = s.x - 1;

			p.y = s.y;



			if (p.x >= 1 && p.x <= x && p.y >= 1 && p.y <= y) {

				if (!vis[p.x][p.y]) {

					vis[p.x][p.y] = true;

					q.add(p);



				}

			}



			p = new Point();

			p.x = s.x + 1;

			p.y = s.y;



			if (p.x >= 1 && p.x <= x && p.y >= 1 && p.y <= y) {

				if (!vis[p.x][p.y]) {

					vis[p.x][p.y] = true;

					q.add(p);



				}

			}



			p = new Point();

			p.x = s.x;

			p.y = s.y - 1;



			if (p.x >= 1 && p.x <= x && p.y >= 1 && p.y <= y) {

				if (!vis[p.x][p.y]) {

					vis[p.x][p.y] = true;

					q.add(p);



				}

			}

			

			p = new Point () ;

			p.x = s.x ;

			p.y = s.y + 1;

			

			if (p.x >= 1 && p.x <= x && p.y >= 1 && p.y <= y) {

				if (!vis[p.x][p.y]) {

					vis[p.x][p.y] = true ;

					q.add(p);

					

				}

			}



			if (q.size() == 0)

				out.print(s.x + "" "" + s.y);

		}



	}



	public static void main(String[] args) throws FileNotFoundException {

		// TODO Auto-generated method stub



		FireAgain F = new FireAgain();

		 Scanner in = new Scanner (new FileReader(""input.txt""));

		 F.out = new PrintStream(new File(""output.txt""));

	

		F.x = in.nextInt();

		F.y = in.nextInt();



		int l = 0;

		F.vis = new boolean[F.x + 1][F.y + 1];



		int k = in.nextInt();



		for (int i = 0; i < k; i++) {

			Point P = new Point(in.nextInt(), in.nextInt());

			F.vis[P.x][P.y] = true; // add in set

			F.q.add(P);

		}



		F.bfs(F.q.peek());



	}



}

",6,3
"import java.io.*;
import java.util.List;
import java.util.LinkedList;
import java.util.StringTokenizer;

public class Problem {
	
	public static Pair solve(Forest f, List<Pair> queue){
		Pair current = null, next = null;
		int index = 0;
		while(queue.size() > 0){
			current = queue.remove(0);
			index = f.desk[current.x][current.y];
				if(current.x>0){
					next = new Pair(current.x-1,current.y);
					if(f.desk[next.x][next.y]==0){
						f.desk[next.x][next.y] = index+1;
						queue.add(next);
					}
				}
				if(current.x<f.N-1){
					next = new Pair(current.x+1,current.y);
					if(f.desk[next.x][next.y]==0){
						f.desk[next.x][next.y] = index+1;
						queue.add(next);
					}
				}
				if(current.y>0){
					next = new Pair(current.x,current.y-1);
					if(f.desk[next.x][next.y]==0){
						f.desk[next.x][next.y] = index+1;
						queue.add(next);
					}
				}
				if(current.y<f.M-1){
					next = new Pair(current.x,current.y+1);
					if(f.desk[next.x][next.y]==0){
						f.desk[next.x][next.y] = index+1;
						queue.add(next);
					}
				}
		}
		return f.findMax();
	}

	public static void main(String[] args){
		String buffer = null;
		StringTokenizer st = null;
		Forest f = null;
		List<Pair> pairs = new LinkedList<Pair>();
		Integer N,M,K,x,y;
		try {
			BufferedReader in = new BufferedReader(
							new FileReader(""input.txt"")
							);
			FileWriter out = new FileWriter(""output.txt"");
			buffer = in.readLine();
			st = new StringTokenizer(buffer);
			N = new Integer(st.nextToken());
			M = new Integer(st.nextToken());
			f = new Forest(N,M);
			buffer = in.readLine();
			st = new StringTokenizer(buffer);
			K = new Integer(st.nextToken());
			buffer = in.readLine();
			st = new StringTokenizer(buffer);
			for(int i = 0; i<K; i++){
				x = new Integer(st.nextToken());
				y = new Integer(st.nextToken());
				f.desk[x-1][y-1] = 1;
				pairs.add(new Pair(x-1,y-1));
			}
			Pair res = solve(f,pairs);
			
			out.write(res.toString());
			out.flush();
		} catch (Exception e) {
		}
	}
}

class Pair {
	public Pair(int i, int j){
		x = i;
		y = j;
	}
	public String toString(){
		return (x+1) + "" "" + (y+1);
	}
	public int x;
	public int y;
}

class Forest {
	public Forest(int n, int m){
		N = n;
		M = m;
		desk = new int[N][M];
	}

	public Pair findMax(){
		Pair max = new Pair(0,0);
		for(int i = 0; i<N; i++){
			for(int j = 0; j<M; j++){
				if(desk[i][j]>desk[max.x][max.y]){
					max.x = i;
					max.y = j;
				}
			}
		}
		return max;
	}	

	public int N;
	public int M;
	public int[][] desk;
}
",6,5
"import java.io.BufferedWriter;

import java.io.File;

import java.io.FileWriter;

import java.io.IOException;

import java.util.LinkedList;

import java.util.Queue;

import java.util.Scanner;



public class FireAgain {

    static int dx[] = { 0, 0, 1, -1 };

    static int dy[] = { 1, -1, 0, 0 };



    public static void main(String[] args) throws IOException {

        Scanner sc = new Scanner(new File(""input.txt""));

        BufferedWriter write = new BufferedWriter(new FileWriter(""output.txt""));

        int n = sc.nextInt();

        int m = sc.nextInt();

        boolean[][] v = new boolean[n][m];

        int k = sc.nextInt();

        Queue<Integer> q = new LinkedList<Integer>();

        for (int i = 0; i < k; i++) {

            int x = sc.nextInt() - 1;

            int y = sc.nextInt() - 1;

            q.add(x);

            q.add(y);

            v[x][y] = true;

        }

        int lastx = 0;

        int lasty = 0;

        while (!q.isEmpty()) {

            lastx = q.poll();

            lasty = q.poll();

            for (int i = 0; i < 4; i++) {

                int r = lastx + dx[i];

                int c = lasty + dy[i];

                if (r >= 0 && c >= 0 && r < n && c < m && !v[r][c]) {

                    v[r][c] = true;

                    q.add(r);

                    q.add(c);

                }

            }

        }

        write.write((lastx + 1) + "" "" + (lasty + 1));

        write.close();

    }



}

",6,3
"import java.io.*;

import java.lang.reflect.Array;

import java.util.*;



public class Problem implements Runnable {



    private static final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;



    private BufferedReader in;

    private PrintWriter out;

    private StringTokenizer tok = new StringTokenizer("""");



    private void init() throws FileNotFoundException {

        Locale.setDefault(Locale.US);

        String fileName = """";

     /*   if (ONLINE_JUDGE && fileName.isEmpty()) {

            in = new BufferedReader(new InputStreamReader(System.in));

            out = new PrintWriter(System.out);

        } else {

            if (fileName.isEmpty()) {*/

                in = new BufferedReader(new FileReader(""input.txt""));

                out = new PrintWriter(""output.txt"");

          /*  } else {

                in = new BufferedReader(new FileReader(fileName + "".in""));

                out = new PrintWriter(fileName + "".out"");

           /* }

        }*/

    }





    String readString() {

        while (!tok.hasMoreTokens()) {

            try {

                tok = new StringTokenizer(in.readLine());

            } catch (Exception e) {

                return null;

            }

        }

        return tok.nextToken();

    }



    int readInt() {

        return Integer.parseInt(readString());

    }



    long readLong() {

        return Long.parseLong(readString());

    }



    double readDouble() {

        return Double.parseDouble(readString());

    }



    int[] readIntArray(int size) {

        int[] a = new int[size];

        for (int i = 0; i < size; i++) {

            a[i] = readInt();

        }

        return a;

    }



    public static void main(String[] args) {

        //new Thread(null, new _Solution(), """", 128 * (1L << 20)).start();

        new Problem().run();

    }



    long timeBegin, timeEnd;



    void time() {

        timeEnd = System.currentTimeMillis();

        System.err.println(""Time = "" + (timeEnd - timeBegin));

    }



    @Override

    public void run() {

        try {

            timeBegin = System.currentTimeMillis();

            init();

            solve();

            out.close();

            time();

        } catch (Exception e) {

            e.printStackTrace();

            System.exit(-1);

        }

    }



    int[][] dist;

    int n, m;



    private void solve() throws IOException {

        n = readInt();

        m = readInt();

        int k=readInt();

        dist = new int[n][m];

        for (int i = 0; i < n; i++)

            for (int j = 0; j < m; j++)

                dist[i][j] = -1;

        for (int i = 0; i < k; i++) {

            dist[readInt()-1][readInt()-1]=0;

        }

        for (int i=0;i<n;i++)

            for (int j=0;j<m;j++)

                if (dist[i][j]==0)

                    bfs(i, j);

        int max=0,X=0,Y=0;

        for (int i=0;i<n;i++)

            for (int j=0;j<m;j++)

                if (dist[i][j]>=max){

                    max=dist[i][j];

                    X=i+1; Y=j+1;

                }

        out.println(X+"" ""+Y);

    }



    public void bfs(int x, int y) {

        int[] dx = {0, 1, 0, -1};

        int[] dy = {1, 0, -1, 0};

        dist[x][y] = 0;

        ArrayDeque<P> q = new ArrayDeque<>();

        q.add(new P(x, y));

        while (!q.isEmpty()) {

            P v = q.poll();



            for (int i = 0; i < 4; i++) {

                int nx = v.x + dx[i];

                int ny = v.y + dy[i];

                if (inside(nx, ny) && (dist[nx][ny] == -1 || (dist[nx][ny] > dist[v.x][v.y] + 1&&dist[nx][ny]!=0))) {

                    q.add(new P(nx, ny));

                    dist[nx][ny] = dist[v.x][v.y] + 1;

                }

            }

        }

    }



    public boolean inside(int x, int y) {

        if (x < n && y < m && x >= 0 && y >= 0) {

            return true;

        }

        return false;

    }

}





class P {

    int x, y;



    public P(int x, int y) {

        this.x = x;

        this.y = y;

    }

}",6,5
"import java.io.*;
import java.util.*;

public class practice {
	static class Reader 
    { 
        final private int BUFFER_SIZE = 1 << 16; 
        private DataInputStream din; 
        private byte[] buffer; 
        private int bufferPointer, bytesRead; 
  
        public Reader() 
        { 
            din = new DataInputStream(System.in); 
            buffer = new byte[BUFFER_SIZE]; 
            bufferPointer = bytesRead = 0; 
        } 
  
        public Reader(String file_name) throws IOException 
        { 
            din = new DataInputStream(new FileInputStream(file_name)); 
            buffer = new byte[BUFFER_SIZE]; 
            bufferPointer = bytesRead = 0; 
        } 
  
        public String readLine() throws IOException 
        { 
            byte[] buf = new byte[64]; // line length 
            int cnt = 0, c; 
            while ((c = read()) != -1) 
            { 
                if (c == '\n') 
                    break; 
                buf[cnt++] = (byte) c; 
            } 
            return new String(buf, 0, cnt); 
        } 
  
        public int nextInt() throws IOException 
        { 
            int ret = 0; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
            do
            { 
                ret = ret * 10 + c - '0'; 
            }  while ((c = read()) >= '0' && c <= '9'); 
  
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        public long nextLong() throws IOException 
        { 
            long ret = 0; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
            do { 
                ret = ret * 10 + c - '0'; 
            } 
            while ((c = read()) >= '0' && c <= '9'); 
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        public double nextDouble() throws IOException 
        { 
            double ret = 0, div = 1; 
            byte c = read(); 
            while (c <= ' ') 
                c = read(); 
            boolean neg = (c == '-'); 
            if (neg) 
                c = read(); 
  
            do { 
                ret = ret * 10 + c - '0'; 
            } 
            while ((c = read()) >= '0' && c <= '9'); 
  
            if (c == '.') 
            { 
                while ((c = read()) >= '0' && c <= '9') 
                { 
                    ret += (c - '0') / (div *= 10); 
                } 
            } 
  
            if (neg) 
                return -ret; 
            return ret; 
        } 
  
        private void fillBuffer() throws IOException 
        { 
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); 
            if (bytesRead == -1) 
                buffer[0] = -1; 
        } 
  
        private byte read() throws IOException 
        { 
            if (bufferPointer == bytesRead) 
                fillBuffer(); 
            return buffer[bufferPointer++]; 
        } 
  
        public void close() throws IOException 
        { 
            if (din == null) 
                return; 
            din.close(); 
        } 
    } 

		public static void main(String[] args) throws IOException {			
			Reader scn=new Reader(""input.txt"");
			PrintWriter out = new PrintWriter(new File(""output.txt""));
		 int n=scn.nextInt(),m=scn.nextInt(),k=scn.nextInt();
		 int[][] inf=new int[k][2];
		 for(int i=0;i<k;i++){
			 inf[i][0]=scn.nextInt();inf[i][1]=scn.nextInt();
		 }
		 int ans=0,x=1,y=1;
		 for(int i=1;i<=n;i++){
			 for(int j=1;j<=m;j++){
				 int temp=Integer.MAX_VALUE;
				 for(int l=0;l<k;l++){
					temp=Math.min(temp, Math.abs(i-inf[l][0])+Math.abs(j-inf[l][1])); 
				 }
				 if(temp>ans){
					 ans=temp;x=i;y=j;
				 }
			 }
		 }
		 out.print(x + "" "" + y);
	   	 out.close();
		}
	}

",6,5
"//package C;

import java.io.*;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

public class Fire_Again {
    static int N;
    static int M;
    static int K;
    private class Pos {
        public int r;
        public int c;
        int last;
        public Pos(int r,int c, int last) {
            this.r = r;
            this.c = c;
            this.last = last;
        }
    }
    static ArrayList<Pos> pos = new ArrayList<>();

    static boolean[][] used;// = new boolean[2001][2001];
    static int[] rows = {-1,1,0,0};
    static int[] cols = {0,0,-1,1};
    int LAST = 0;
    int lastRow = 1;
    int lastCol = 1;
    public static void main(String[] args) throws IOException {
        Fire_Again fire_again = new Fire_Again();
        BufferedReader bufferedReader =
                new BufferedReader(new FileReader(""input.txt""));
        String[] nm = bufferedReader.readLine().split("" "");
        N = Integer.parseInt(nm[0]) + 1;
        M = Integer.parseInt(nm[1]) + 1;
        K = Integer.parseInt(bufferedReader.readLine());
        used = new boolean[N][M];
        String[] rc = bufferedReader.readLine().split("" "");
        for(int k = 0;k < rc.length;k+=2) {
            int r = Integer.parseInt(rc[k]);
            int c = Integer.parseInt(rc[k+1]);
            pos.add(fire_again.new Pos(r,c,0));
        }
        fire_again.bfs();
        PrintStream ps = new PrintStream(""output.txt"");
        ps.printf(""%d %d\n"",fire_again.lastRow,fire_again.lastCol);
        ps.flush();
        ps.close();
    }
     Queue<Pos> queue = new LinkedList<>();
    private void bfs() {
      queue.addAll(pos);
      for(Pos p : pos) {
          used[p.r][p.c] = true;
        //  System.out.println(""r = ""+(p.r) + "" c = "" + (p.c));
      }
      while(!queue.isEmpty()) {
          Pos p = queue.poll();
          if(p.last > LAST) {
              LAST = p.last;
              lastRow = p.r;
              lastCol = p.c;
          }
          for(int i = 0;i < rows.length;i++) {
              int currR = p.r;
              int currC = p.c;
              if(currR + rows[i] >= 1 && currR + rows[i] < N &&
              currC + cols[i] >= 1 && currC + cols[i] < M &&
              !used[currR + rows[i] ] [currC + cols[i] ] ) {
              //    System.out.println(""r = ""+(currR+rows[i]) + "" c = "" + (currC+cols[i]));
                  queue.add(new Pos(currR+rows[i],currC+cols[i],p.last+1));
                  used[currR + rows[i] ] [currC + cols[i] ] = true;
              }
          }
      }

    }

}
",6,3
"import java.util.*;
import java.io.*;
public class test{
    static class Pair{
        int x;
        int y;
        Pair(int a,int b){
            x=a;
            y=b;
        }
    }

    public static void main(String[] args) throws IOException{
        solve();
    }  
     
 static boolean vis[][];
public static void solve() throws IOException{
    File f = new File(""input.txt"");
        Scanner sc = new Scanner(f);
        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(""output.txt"")));
   int n=sc.nextInt();
   int m=sc.nextInt();
   int a[][]=new int[n+1][m+1];
   vis=new boolean[n+1][m+1];
   Queue<Pair> q=new LinkedList<>();
   int k=sc.nextInt();
    for(int i=0;i<k;i++){
        int c=sc.nextInt();
        int b=sc.nextInt();
       q.add(new Pair(c,b));
       vis[c][b]=true;
    }
    int z=0;
    int l=0;
    while(q.size()>0){
        Pair p=q.poll();
       
        z=p.x;
        l=p.y;
         if(p.y+1<=m && !vis[p.x][p.y+1]){
            q.add(new Pair(p.x,p.y+1));  
             vis[p.x][p.y+1]=true; 
        }
        if(p.y-1>0 && !vis[p.x][p.y-1]){
            q.add(new Pair(p.x,p.y-1));
             vis[p.x][p.y-1]=true; 
        }
        if(p.x+1<=n && !vis[p.x+1][p.y]){
            q.add(new Pair(p.x+1,p.y));
             vis[p.x+1][p.y]=true;
        }
         if(p.x-1>0 && !vis[p.x-1][p.y]){
            q.add(new Pair(p.x-1,p.y));
             vis[p.x-1][p.y]=true;
        
        }
       

        
    }
     bw.append(z + "" "" + l+ ""\n"");
    bw.flush();
    bw.close();
    
    sc.close();
         

  }
}
 
",6,3
"import java.io.BufferedReader;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.Arrays;

import java.util.LinkedList;

import java.util.Queue;

import java.util.StringTokenizer;



public class Main {

	static int[] di = {-1,0,1,0};

	static int[] dj = {0,1,0,-1};

	public static void main(String[] args) throws IOException 

	{

		Scanner sc = new Scanner(""input.txt"");

		PrintWriter out = new PrintWriter(""output.txt"");

		Queue<Pair> q = new LinkedList<Pair>();

		int n = sc.nextInt(),m = sc.nextInt() , k = sc.nextInt();

		boolean [][] vis = new boolean[n][m];

		while(k-->0)

			q.add(new Pair(sc.nextInt()-1,sc.nextInt()-1));

	

		int ansX = 1 , ansY = 1;

		

		while(!q.isEmpty())

		{

			Pair cur = q.poll();

			if(vis[cur.i][cur.j])continue;

			ansX = cur.i ; ansY = cur.j;

			vis[cur.i][cur.j] = true;

			for (int i = 0; i < di.length; i++) {

				int ni = cur.i + di[i] , nj = cur.j + dj[i];

				if(ni>=0 && ni<n && nj>=0 && nj<m && !vis[ni][nj])

					q.add(new Pair(ni,nj));

			}

		}

		

		out.append(++ansX+"" ""+ ++ansY);

		out.flush();

		

	}

	static class Pair

	{

		int i,j;

		public Pair(int a,int b) {

			i = a; j = b;

		}

	}

	

	static class Scanner 

	{

		StringTokenizer st;

		BufferedReader br;

		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

		public Scanner(String s) throws FileNotFoundException {

			br = new BufferedReader(new FileReader(s));

		}

		public String next() throws IOException 

		{

			while (st == null || !st.hasMoreTokens()) 

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}

		public int nextInt() throws IOException {return Integer.parseInt(next());}

		public String nextLine() throws IOException {return br.readLine();}		

		public long nextLong() throws IOException {return Long.parseLong(next());}		

		public double nextDouble() throws IOException {return Double.parseDouble(next());}	

		public boolean ready() throws IOException {return br.ready();}

	}

	

}",6,3
"import java.io.BufferedReader;

import java.io.FileInputStream;

import java.io.FileOutputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.io.StreamTokenizer;

import java.util.ArrayDeque;

import java.util.Arrays;



public class Main {

    private static StreamTokenizer in;

    private static PrintWriter out;

    private static BufferedReader inB;

    

    private static int nextInt() throws Exception{

        in.nextToken();

        return (int)in.nval;

    }

    

    private static String nextString() throws Exception{

        in.nextToken();

        return in.sval;

    }

    

    static{

        

        /*

        inB = new BufferedReader(new InputStreamReader(System.in));

        out = new PrintWriter(System.out);

        /**/

        //*

        try {

        inB = new BufferedReader(new InputStreamReader(new FileInputStream(""input.txt"")));

        out = new PrintWriter(new FileOutputStream(""output.txt""));

        } catch(Exception e) {}

        /**/

        in = new StreamTokenizer(inB);

    }

    

    private static int[][] mind;

    private static boolean[][] used;

    

    private static int n,m;

    

    public static void main(String[] args)throws Exception {

        n = nextInt();

        m = nextInt();

        int k = nextInt();

        int[][] mas = new int[k][2];

        

        for(int i = 0; i<k; i++) {

            mas[i][0] = nextInt()-1;

            mas[i][1] = nextInt()-1;

        }

        

        mind = new int[n][m];

        used = new boolean[n][m];

        for(int i = 0; i<n; i++) {

            Arrays.fill(mind[i], Integer.MAX_VALUE);

        }

        

        ArrayDeque<int[]> ad = new ArrayDeque<int[]>();

        

        for(int i = 0; i<k; i++) {

            ad.add(new int[] {mas[i][0], mas[i][1], 0});

        }

        

        while(!ad.isEmpty()) {

            int[] cur = ad.remove();

            

            if(used[cur[0]][cur[1]])continue;

            int x = cur[0]; int y = cur[1]; int d = cur[2];

            mind[x][y] = ++d;

            used[x][y] = true;

            //if(isValid(x+1,y+1) && !used[x+1][y+1])   ad.add(new int[] {x+1,  y+1, d});

            if(isValid(x+1,y)   && !used[x+1][y])   ad.add(new int[] {x+1,  y,   d});

            //if(isValid(x+1,y-1) && !used[x+1][y-1])   ad.add(new int[] {x+1,  y-1, d});

            if(isValid(x,y+1)   && !used[x][y+1])   ad.add(new int[] {x,    y+1, d});

            if(isValid(x,y-1)   && !used[x][y-1])   ad.add(new int[] {x,    y-1, d});

            //if(isValid(x-1,y+1) && !used[x-1][y+1])   ad.add(new int[] {x-1,  y+1, d});

            if(isValid(x-1,y)   && !used[x-1][y])   ad.add(new int[] {x-1,  y,   d});

            //if(isValid(x-1,y-1) && !used[x-1][y-1])   ad.add(new int[] {x-1,  y-1, d});

        }

        

        int max = Integer.MIN_VALUE;

        int maxx = 0, maxy = 0;

        

        for(int i = 0; i<n; i++) {

            for(int j = 0; j<m; j++) {

                if(mind[i][j] > max) {

                    max = mind[i][j];

                    maxx = i+1;

                    maxy = j+1;

                }

            }

        }

        

        out.println(maxx + "" "" + maxy);

        out.flush();

    }

    

    private static boolean isValid(int x, int y) {

        return x>=0 && x<n && y>=0 && y<m;

    }

    

    /////////////////////////////////////////////////

    // pre - written

    /////////////////////////////////////////////////

    private static void println(Object o) throws Exception {

        System.out.println(o);

    }

    private static void exit(Object o) throws Exception {

        println(o);

        exit();

    }

    private static void exit() {

        System.exit(0);

    }

    /////////////////////////////////

}

",6,5
"/**

 * Created by IntelliJ IDEA.

 * User: Taras_Brzezinsky

 * Date: 9/16/11

 * Time: 1:27 PM

 * To change this template use File | Settings | File Templates.

 */







import java.io.*;

import java.lang.reflect.Array;

import java.util.ArrayDeque;

import java.util.HashSet;

import java.util.Queue;

import java.util.StringTokenizer;



public class TaskC extends Thread {

    public TaskC() {

        try {

            this.input = new BufferedReader(new FileReader(""input.txt""));

            this.output = new PrintWriter(""output.txt"");

            this.setPriority(Thread.MAX_PRIORITY);

        } catch (Throwable e) {

            System.exit(666);

        }

    }



    private void solve() throws Throwable {

        int n = nextInt();

        int m = nextInt();

        int k = nextInt();

        Queue<Integer> qX = new ArrayDeque<Integer>();

        Queue<Integer> qY = new ArrayDeque<Integer>();

        boolean [][]was = new boolean[n][m];

        for (int i = 0; i < k; ++i) {

            int x = nextInt() - 1, y = nextInt() - 1;

            qX.add(x);

            qY.add(y);

            was[x][y] = true;

        }

        int lastX = -1, lastY = -1;

        while (!qX.isEmpty()) {

            lastX = qX.poll();

            lastY = qY.poll();

            for (int i = 0; i < dx.length; ++i) {

                int nextX = lastX + dx[i], nextY = lastY + dy[i];

                if (nextX < n && nextY < m && nextX >= 0 && nextY >= 0 && !was[nextX][nextY]) {

                    qX.add(nextX);

                    qY.add(nextY);

                    was[nextX][nextY] = true;

                }

            }

        }

        ++lastX;

        ++lastY;

        output.println(lastX + "" "" + lastY);







    }



    public void run() {

        try {

            solve();

        } catch (Throwable e) {

            System.err.println(e.getMessage());

            e.printStackTrace();

            System.exit(666);

        } finally {

            output.flush();

            output.close();

        }

    }



    public static void main(String[] args) {

        new TaskC().start();

    }



    private int nextInt() throws IOException {

        return Integer.parseInt(nextToken());

    }



    private long nextLong() throws IOException {

        return Long.parseLong(nextToken());

    }



    private double nextDouble() throws IOException {

        return Double.parseDouble(nextToken());

    }



    private String nextToken() throws IOException {

        while (tokens == null || !tokens.hasMoreTokens()) {

            tokens = new StringTokenizer(input.readLine());

        }

        return tokens.nextToken();

    }

    static final int PRIME = 3119;

    static final int[]dx = {1, -1, 0, 0}, dy = {0, 0, -1, 1};

    private BufferedReader input;

    private PrintWriter output;

    private StringTokenizer tokens = null;

}

",6,3
"import java.io.*;

import java.util.*;



/**

 * Created by tmdautov on 07.02.18.

 */

public class ArFireAgain {





    int n, m, k;

    int dx[] = { 0, 0, 1, -1, 1, 1, -1, -1 };

    int dy[] = { 1, -1, 0, 0, 1, -1, 1, -1 };



    int[][] dist;

    ArrayList<Pair> arr;

    // res -> get coordinates of most remote tree



    Scanner sc;

    PrintWriter out;



    public void solve() {



        try {

            sc = new Scanner(new FileReader(""input.txt""));

            out = new PrintWriter(""output.txt"");

        } catch (FileNotFoundException e) {

            e.printStackTrace();

        }

        //Scanner sc = new Scanner(System.in);

        n = sc.nextInt();

        m = sc.nextInt();

        k = sc.nextInt();



        arr = new ArrayList<Pair>();



        for (int i=0; i<k; i++) {

            int x = sc.nextInt()-1;

            int y = sc.nextInt()-1;

            Pair p = new Pair(x, y);

            arr.add(p);

        }





        //out.println(""helll"");

        Pair last = bfs();

        out.println(last.x + "" "" + last.y);

        out.flush();

        out.close();

    }





    boolean inBoard(int x, int y) {

        return x >= n || x < 0 || y >= m || y < 0;

    }

    boolean isValid(int x, int y) {

        return x >= 0 && y >= 0 && x < n && y < m;

    }



    private Pair bfs() {

        // 1. create objects

        Queue<Pair> q = new LinkedList<Pair>();

        dist = new int[n][m];



        // 2. fill dist array with -1

        for (int i=0; i<n; i++) {

            for (int j=0; j<m; j++) {

                dist[i][j] = -1;

            }

        }



        // 3. fill queue with fired k-trees

        for (int i=0; i<k; i++) {

            dist[arr.get(i).x][arr.get(i).y] = 0; // dist to fired trees is 0

            q.add(arr.get(i));

        }



        // 4. run bfs

        while(!q.isEmpty()) {

            Pair cur = q.remove();



            for (int d=0; d<4; d++) {

                int X = cur.x + dx[d];

                int Y = cur.y + dy[d];



                if (isValid(X, Y) && dist[X][Y] == -1) {

                    dist[X][Y] = dist[cur.x][cur.y] + 1;

                    Pair p = new Pair(X, Y);

                    q.add(p);

                }

            }



            //System.out.println(cur);

        }



        // 5. find max pair by dist array

        Pair res = null;

        int maxx = -1;

        for (int i=0; i<n; i++) {

            for (int j=0; j<m; j++) {

                if (dist[i][j] > maxx) {

                    maxx = dist[i][j];

                    res = new Pair(i+1, j+1);

                }

            }

        }



        return res;

    }





    // how to sort array of pairs?

    class Pair {

        int x, y;

        Pair(int x, int y) {

            this.x = x;

            this.y = y;

        }

    }



    public static void main(String[] args) {

        new ArFireAgain().solve();

    }

}

",6,5
"import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Watermelon {
    static int[][] ans;static int n,m;static boolean[][] vis;
    public static void main(String[] args) throws IOException {
        Scanner sc=new Scanner(new File(""input.txt""));
//        Scanner sc=new Scanner(System.in);
        PrintWriter pw=new PrintWriter(""output.txt"");
        int n=sc.nextInt(),m=sc.nextInt(),k=sc.nextInt();
        Queue<Integer> pq=new ArrayDeque<>();
        boolean[] vis=new boolean[n*m];
        for(int i=0;i<k;i++){
            int r=sc.nextInt()-1,c=sc.nextInt()-1;
            pq.add(m*r+c);
            vis[m*r+c]=true;
        }
        sc.close();
        int ans=0;
        while(pq.size()!=0){
            int x=pq.remove();

            ans=x;
            if(n!=1 && x%n==0){
                if(x+m<n*m&&!vis[x+m]){
                    pq.add(x+m);
                    vis[x+m]=true;
                }
                if(x-m>=0&&!vis[x-m]){
                    pq.add(x-m);
                    vis[x-m]=true;
                }
                if(x+1<n*m&&!vis[x+1]){
                    pq.add(x+1);
                    vis[x+1]=true;
                }
            }
            else if(n!=1 && (x+1)%n==0){
                if(x+m<n*m&&!vis[x+m]){
                    pq.add(x+m);
                    vis[x+m]=true;
                }
                if(x-m>=0&&!vis[x-m]){
                    pq.add(x-m);
                    vis[x-m]=true;
                }
                if(x-1>=0&&!vis[x-1]){
                    pq.add(x-1);
                    vis[x-1]=true;
                }
            }
            else{
                if(x+m<n*m&&!vis[x+m]){
                    pq.add(x+m);
                    vis[x+m]=true;
                }
                if(x-m>=0&&!vis[x-m]){
                    pq.add(x-m);
                    vis[x-m]=true;
                }
                if(x-1>=0&&!vis[x-1]){
                    pq.add(x-1);
                    vis[x-1]=true;
                }
                if(x+1<n*m&&!vis[x+1]){
                    pq.add(x+1);
                    vis[x+1]=true;
                }
            }
        }
        pw.println((ans/m+1)+"" ""+(ans%m+1));
        pw.close();
    }

    static class Reader{
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader() {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public Reader(String file_name) throws IOException {
            din = new DataInputStream(new FileInputStream(file_name));
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[64]; // line length
            int cnt = 0, c;
            while ((c = read()) != -1) {
                if (c == '\n')
                    break;
                buf[cnt++] = (byte) c;
            }

            return new String(buf, 0, cnt);
        }

        public int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do {
                ret = ret * 10 + c - '0';
            } while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');
            if (neg)
                return -ret;
            return ret;
        }

        public double nextDouble() throws IOException {
            double ret = 0, div = 1;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();

            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');

            if (c == '.') {
                while ((c = read()) >= '0' && c <= '9') {
                    ret += (c - '0') / (div *= 10);
                }
            }

            if (neg)
                return -ret;
            return ret;
        }

        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException {
            if (din == null)
                return;
            din.close();
        }
    }


}",6,3
"import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Collection;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.Objects;
import java.util.Queue;
import java.util.LinkedList;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Pranay2516
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream;
        try {
            inputStream = new FileInputStream(""input.txt"");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        OutputStream outputStream;
        try {
            outputStream = new FileOutputStream(""output.txt"");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        CFireAgain solver = new CFireAgain();
        solver.solve(1, in, out);
        out.close();
    }

    static class CFireAgain {
        public void solve(int testNumber, FastReader in, PrintWriter out) {
            int n = in.nextInt(), m = in.nextInt(), k = in.nextInt();
            int[][] d = new int[n][m];
            boolean[][] vis = new boolean[n][m];
            Pair<Integer, Integer>[] a = new Pair[k];
            int[] dx = {1, -1, 0, 0};
            int[] dy = {0, 0, 1, -1};
            Queue<Pair<Integer, Integer>> q = new LinkedList<>();
            for (int i = 0; i < n; ++i) {
                Arrays.fill(d[i], -1);
            }
            for (int i = 0; i < k; ++i) {
                a[i] = new Pair<>(in.nextInt() - 1, in.nextInt() - 1);
                d[a[i].x][a[i].y] = 0;
                vis[a[i].x][a[i].y] = true;
                q.add(a[i]);
            }
            while (!q.isEmpty()) {
                Pair<Integer, Integer> u = q.poll();
                for (int i = 0; i < 4; ++i) {
                    int x = u.x + dx[i], y = u.y + dy[i];
                    if (x >= 0 && x < n && y >= 0 && y < m && !vis[x][y]) {
                        vis[x][y] = true;
                        d[x][y] = d[u.x][u.y] + 1;
                        q.add(new Pair<>(x, y));
                    }
                }
            }
            int max = -1;
            Pair<Integer, Integer> ans = new Pair<>(0, 0);
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < m; ++j) {
                    if (d[i][j] > max) {
                        max = d[i][j];
                        ans.x = i;
                        ans.y = j;
                    }
                }
            }
            out.println(ans.x + 1 + "" "" + (ans.y + 1));
        }

    }

    static class Pair<U, V> implements Comparable<Pair<U, V>> {
        public U x;
        public V y;

        public Pair(U x, V y) {
            this.x = x;
            this.y = y;
        }

        public int compareTo(Pair<U, V> o) {
            int value = ((Comparable<U>) x).compareTo(o.x);
            if (value != 0) return value;
            return ((Comparable<V>) y).compareTo(o.y);
        }

        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Pair<?, ?> pair = (Pair<?, ?>) o;
            return x.equals(pair.x) && y.equals(pair.y);
        }

        public int hashCode() {
            return Objects.hash(x, y);
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private FastReader.SpaceCharFilter filter;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) throw new InputMismatchException();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) return -1;
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",6,5
"import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;


public class R035CRetry {
    public void debug(Object... objects) { System.err.println(Arrays.deepToString(objects)); }
    public static final int INF = 987654321;
    public static final long LINF = 987654321987654321L;
    public static final double EPS = 1e-9;
    
    Scanner scanner;
    PrintWriter out;
    boolean[][] bss;
    
    public R035CRetry() {
        try {
            this.scanner = new Scanner(new File(""input.txt""));
            this.out = new PrintWriter(""output.txt"");
        } catch(FileNotFoundException ex) { ex.printStackTrace(); }
    }
    
    class Point implements Comparable<Point> {
        int x, y, count;
        Point(int x, int y) { this.x = x; this.y = y; }
        public int hashCode() { return x * 17 + y; }
        public boolean equals(Object o) {
            if(!(o instanceof Point)) return false;
            Point that = (Point)o;
            return this.x == that.x && this.y == that.y;
        }
        public int compareTo(Point that) { return this.count - that.count; }
        public String toString()  { return ""("" + x + "", "" + y + "":"" + count + "")""; }
    }

    
    int[] dx = new int[] {  0, 0, -1, 1 };
    int[] dy= new int[] { -1, 1,  0, 0 };
    int n, m;
    
    Queue<Point> q;
    
    Point bfs() {
        int max = -INF;
        Point p = null;
        while(!q.isEmpty()) {
            Point cur = q.remove();
            if(max < cur.count) { max = cur.count; p = cur; } 
            for(int i=0; i<dx.length; i++) {
                int nx = cur.x + dx[i];
                int ny = cur.y + dy[i];
                if(nx < 0 || nx >= n) { continue; }
                if(ny < 0 || ny >= m) { continue; }
                Point np = new Point(nx, ny);
                if(bss[nx][ny] ) { continue; } 
                np.count = cur.count+1;
                bss[nx][ny] = true;
                q.add(np);
            }
        }
        return p;
    }
    
    private void solve() {
        this.n = scanner.nextInt();
        this.m = scanner.nextInt();
        this.bss = new boolean[n][m];
        int k = scanner.nextInt();
        q = new LinkedList<Point>();
        for(int i=0; i<k; i++) {
            int x = scanner.nextInt() - 1;
            int y = scanner.nextInt() - 1;
            Point init = new Point(x, y);
            init.count = 1;
            q.add(init);
            bss[x][y] = true;
        }
        Point p = bfs();
        out.println((p.x+1) + "" "" + (p.y+1));
    }
    
    private void finish() { this.out.close(); }
    
    public static void main(String[] args) { 
        R035CRetry obj = new R035CRetry();
        obj.solve();
        obj.finish();
    }
}
",6,3
"import java.io.*;

import java.util.*;



public class Main implements Runnable {



	public void _main() throws IOException {

		int height = nextInt();

		int width = nextInt();		

		int k = nextInt();

		int[] r = new int[k];

		int[] c = new int[k];

		for (int i = 0; i < k; i++) {

			r[i] = nextInt() - 1;

			c[i] = nextInt() - 1;			

		}

		int res = 0, R = r[0], C = c[0];

		for (int i = 0; i < height; i++)

			for (int j = 0; j < width; j++) {

				int cur = Integer.MAX_VALUE;

				for (int z = 0; z < k; z++)

					cur = Math.min(cur, Math.abs(i - r[z]) + Math.abs(j - c[z]));

				if (res < cur) {

					res = cur;

					R = i;

					C = j;

				}

			}

		out.print((R + 1) + "" "" + (C + 1));

	}



	private BufferedReader in;

	private PrintWriter out;

	private StringTokenizer st;



	private String next() throws IOException {

		while (st == null || !st.hasMoreTokens())

			st = new StringTokenizer(in.readLine());

		return st.nextToken();

	}



	private int nextInt() throws IOException {

		return Integer.parseInt(next());

	}



	private long nextLong() throws IOException {

		return Long.parseLong(next());

	}



	private double nextDouble() throws IOException {

		return Double.parseDouble(next());

	}



	public static void main(String[] args) {

		new Thread(new Main()).start();

	}



	public void run() {

		try {

			in = new BufferedReader(new InputStreamReader(System.in));

			out = new PrintWriter(System.out);

			in = new BufferedReader(new FileReader(""input.txt""));

			out = new PrintWriter(new FileWriter(""output.txt""));



			_main();



			out.close();

		} catch (Exception e) {

			e.printStackTrace();

			System.exit(202);

		}

	}



}

",6,5
"import java.io.*;
import java.util.*;

public class P_35C {
    static final FS sc = new FS();
    static final PrintWriter pw = new PrintWriter(System.out);
    static int[][] res;
    static int[] dx = {1,0,-1,0};
    static int[] dy = {0,-1,0,1};
    static int n, m;
    static Queue<Integer> qx;
    static Queue<Integer> qy;
    static void bfs(){
        while(!qx.isEmpty() && !qy.isEmpty()){
            int xn = qx.poll();
            int yn = qy.poll();
            for(int i=0; i<4; i++){
                int nx = xn+dx[i];
                int ny = yn+dy[i];
                if(nx>=0 && ny>=0 && nx<n && ny<m && res[nx][ny]==-1){
                    res[nx][ny] = res[xn][yn]+1;
                    qx.add(nx);
                    qy.add(ny);
                }
            }
        }
    }
    public static void main(String[] args) throws FileNotFoundException {
        File file = new File(""input.txt"");
        Scanner sc = new Scanner(file);
        n = sc.nextInt();
        m = sc.nextInt();
        int k = sc.nextInt();
        ArrayList<Integer> xl = new ArrayList<>();
        ArrayList<Integer> yl = new ArrayList<>();
        res = new int[n][m];
        qx = new LinkedList<>();
        qy = new LinkedList<>();
        for(int i=0; i<k; i++){
            int xi = sc.nextInt()-1;
            int yi = sc.nextInt()-1;
            qx.add(xi); qy.add(yi);
            res[xi][yi] = 1;
        }
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(res[i][j]==1) res[i][j] = 0;
                else res[i][j] = -1;
            }
        }
        bfs();
        int x = 0,y = 0;
        int max = Integer.MIN_VALUE;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(res[i][j]>max){
                    max = res[i][j];
                    x = i; y = j;
                }
            }
        }
        try {
            FileWriter writer = new FileWriter(""output.txt"");
            writer.write((x+1)+"" ""+(y+1));
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static class FS {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer("""");

        String next() {
            while (!st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (Exception ignored) {
                }
            }
            return st.nextToken();
        }

        int[] nextArray(int n) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = nextInt();
            }
            return a;
        }

        long[] nextLongArray(int n) {
            long[] a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = nextLong();
            }
            return a;
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }
    }
}
",6,5
"import java.io.OutputStream;

import java.io.FileOutputStream;

import java.io.IOException;

import java.io.FileInputStream;

import java.io.InputStream;

import java.io.PrintWriter;

import java.io.OutputStream;

import java.io.IOException;

import java.io.InputStreamReader;

import java.io.File;

import java.io.FileNotFoundException;

import java.util.StringTokenizer;

import java.io.Writer;

import java.io.BufferedReader;

import java.io.FileReader;

import java.io.InputStream;



/**

 * Built using CHelper plug-in

 * Actual solution is at the top

 * @author zodiacLeo

 */

public class Main

{

    public static void main(String[] args)

    {

        InputStream inputStream;

        try

        {

            inputStream = new FileInputStream(""input.txt"");

        } catch (IOException e)

        {

            throw new RuntimeException(e);

        }

        OutputStream outputStream;

        try

        {

            outputStream = new FileOutputStream(""output.txt"");

        } catch (IOException e)

        {

            throw new RuntimeException(e);

        }

        FastScanner in = new FastScanner(inputStream);

        FastPrinter out = new FastPrinter(outputStream);

        TaskC solver = new TaskC();

        solver.solve(1, in, out);

        out.close();

    }



    static class TaskC

    {

        public void solve(int testNumber, FastScanner in, FastPrinter out)

        {

            int n = in.nextInt();

            int m = in.nextInt();

            int p = in.nextInt();

            int[] x = new int[p];

            int[] y = new int[p];

            for (int i = 0; i < p; i++)

            {

                x[i] = in.nextInt();

                y[i] = in.nextInt();

            }



            int X = x[0];

            int Y = y[0];

            int D = -1;

            for (int dx = 1; dx <= n; dx++)

            {

                int x1 = dx;

                int y1 = 1;

                int xx = 0;

                int yy = 0;

                int minD = Integer.MAX_VALUE;

                for (int j = 0; j < p; j++)

                {

                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);

                    if (d < minD)

                    {

                        minD = d;

                        xx = x1;

                        yy = y1;

                    }

                }

                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)

                {

                    D = minD;

                    X = xx;

                    Y = yy;

                }

            }

            for (int dx = 1; dx <= n; dx++)

            {

                int x1 = dx;

                int y1 = m;

                int xx = 0;

                int yy = 0;

                int minD = Integer.MAX_VALUE;

                for (int j = 0; j < p; j++)

                {

                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);

                    if (d < minD)

                    {

                        minD = d;

                        xx = x1;

                        yy = y1;

                    }

                }

                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)

                {

                    D = minD;

                    X = xx;

                    Y = yy;

                }

            }

            for (int dy = 1; dy <= m; dy++)

            {

                int x1 = 1;

                int y1 = dy;

                int xx = 0;

                int yy = 0;

                int minD = Integer.MAX_VALUE;

                for (int j = 0; j < p; j++)

                {

                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);

                    if (d < minD)

                    {

                        minD = d;

                        xx = x1;

                        yy = y1;

                    }

                }

                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)

                {

                    D = minD;

                    X = xx;

                    Y = yy;

                }

            }

            for (int dy = 1; dy <= m; dy++)

            {

                int x1 = n;

                int y1 = dy;

                int xx = 0;

                int yy = 0;

                int minD = Integer.MAX_VALUE;

                for (int j = 0; j < p; j++)

                {

                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);

                    if (d < minD)

                    {

                        minD = d;

                        xx = x1;

                        yy = y1;

                    }

                }

                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)

                {

                    D = minD;

                    X = xx;

                    Y = yy;

                }

            }



            for (int i = 1; i <= Math.min(m, n); i++)

            {

                int x1 = i;

                int y1 = i;

                int xx = 0;

                int yy = 0;

                int minD = Integer.MAX_VALUE;

                for (int j = 0; j < p; j++)

                {

                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);

                    if (d < minD)

                    {

                        minD = d;

                        xx = x1;

                        yy = y1;

                    }

                }

                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)

                {

                    D = minD;

                    X = xx;

                    Y = yy;

                }

            }

            for (int i = 1, ii = m; i <= n && ii >= 1; i++, ii--)

            {

                int x1 = i;

                int y1 = ii;

                int xx = 0;

                int yy = 0;

                int minD = Integer.MAX_VALUE;

                for (int j = 0; j < p; j++)

                {

                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);

                    if (d < minD)

                    {

                        minD = d;

                        xx = x1;

                        yy = y1;

                    }

                }

                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)

                {

                    D = minD;

                    X = xx;

                    Y = yy;

                }

            }

            out.println(X + "" "" + Y);

        }



    }



    static class FastScanner

    {

        public BufferedReader br;

        public StringTokenizer st;



        public FastScanner(InputStream is)

        {

            br = new BufferedReader(new InputStreamReader(is));

        }



        public FastScanner(File f)

        {

            try

            {

                br = new BufferedReader(new FileReader(f));

            } catch (FileNotFoundException e)

            {

                e.printStackTrace();

            }

        }



        public String next()

        {

            while (st == null || !st.hasMoreElements())

            {

                String s = null;

                try

                {

                    s = br.readLine();

                } catch (IOException e)

                {

                    e.printStackTrace();

                }

                if (s == null)

                    return null;

                st = new StringTokenizer(s);

            }

            return st.nextToken();

        }



        public int nextInt()

        {

            return Integer.parseInt(next());

        }



    }



    static class FastPrinter extends PrintWriter

    {

        public FastPrinter(OutputStream out)

        {

            super(out);

        }



        public FastPrinter(Writer out)

        {

            super(out);

        }



    }

}



",6,5
"import java.io.File;

import java.io.FileNotFoundException;

import java.io.PrintWriter;

import java.util.LinkedList;

import java.util.Queue;

import java.util.Scanner;





public class ProblemD {



    static int n;

    static int m;

    static boolean[][] fire;

    

    public static void main(String[] args) throws FileNotFoundException {

        Scanner sc = new Scanner(new File(""input.txt""));

        n = sc.nextInt();

        m = sc.nextInt();

        int k = sc.nextInt();

        fire = new boolean[n][m];

        Queue<Pos> q = new LinkedList<Pos>();

        for (int i = 0; i < k; i++) {

            int x = sc.nextInt();

            int y = sc.nextInt();

            q.add(new Pos(x - 1, y - 1));

            fire[x - 1][y - 1] = true;

        }

        int[] di = new int[] { 1, -1, 0, 0 };

        int[] dj = new int[] { 0, 0, 1, -1};

        Pos last = null;

        while (q.size() > 0) {

            Pos pos = q.poll();

            last = pos;

            for (int kk = 0; kk < 4; kk++) {

                int ni = pos.i + di[kk];

                int nj = pos.j + dj[kk];

                if (ni >= 0 && nj >= 0 && ni < n && nj < m) {

                    if (!fire[ni][nj]) {

                        fire[ni][nj] = true;

                        q.add(new Pos(ni, nj));

                    }

                }

            }

        }

        PrintWriter out = new PrintWriter(new File(""output.txt""));

        out.println((last.i + 1) + "" "" + (last.j + 1));

        out.flush();

        out.close();

    }

    



}



class Pos {

    

    int i, j;



    public Pos(int i, int j) {

        super();

        this.i = i;

        this.j = j;

    }



    @Override

    public int hashCode() {

        final int prime = 31;

        int result = 1;

        result = prime * result + i;

        result = prime * result + j;

        return result;

    }



    @Override

    public boolean equals(Object obj) {

        if (this == obj)

            return true;

        if (obj == null)

            return false;

        if (getClass() != obj.getClass())

            return false;

        Pos other = (Pos) obj;

        if (i != other.i)

            return false;

        if (j != other.j)

            return false;

        return true;

    }

    

    

};

",6,3
"import java.io.*;
import java.util.*;
public class CF_35C {
    public static void main(String[] args) throws IOException{
        BufferedReader f = new BufferedReader(new FileReader(""input.txt""));
        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));

        StringTokenizer st1 = new StringTokenizer(f.readLine());
        int n = Integer.parseInt(st1.nextToken());
        int m = Integer.parseInt(st1.nextToken());

        boolean[][] visited = new boolean[n][m];

        int k = Integer.parseInt(f.readLine());
        LinkedList<state1> ll = new LinkedList<state1>();
        StringTokenizer st = new StringTokenizer(f.readLine());
        for(int i = 0; i < k; i++) {
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());

            ll.add(new state1(x - 1, y - 1));
            visited[x - 1][y - 1] = true;
        }

        int lastx = 1;
        int lasty = 1;
        while(!ll.isEmpty()) {
            state1 focus = ll.remove();
            lastx = focus.x+1;
            lasty = focus.y+1;

            //System.out.println(lastx + "" "" + lasty);

            visited[focus.x][focus.y] = true;
            if(focus.x+1 < n && !visited[focus.x+1][focus.y]) {
                ll.add(new state1(focus.x+1, focus.y));
                visited[focus.x+1][focus.y] = true;
            }
            if(focus.x-1 >= 0 && !visited[focus.x-1][focus.y]) {
                ll.add(new state1(focus.x-1, focus.y));
                visited[focus.x-1][focus.y] = true;
            }
            if(focus.y+1 < m && !visited[focus.x][focus.y+1]) {
                ll.add(new state1(focus.x, focus.y+1));
                visited[focus.x][focus.y+1] = true;
            }
            if(focus.y-1 >= 0 && !visited[focus.x][focus.y-1]) {
                ll.add(new state1(focus.x, focus.y-1));
                visited[focus.x][focus.y-1] = true;
            }
        }
        out.println(lastx + "" "" + lasty);
        out.close();
    }
}

class state1 {
    int x, y;
    state1(int x, int y) {
        this.x = x; this.y = y;
    }
}",6,3
"import java.io.*;

import java.math.*;

import java.util.*;

import java.util.stream.*;



@SuppressWarnings(""unchecked"")

public class P35C {



  final static int [] DX = {-1, 1,  0, 0};

  final static int [] DY = { 0, 0, -1, 1};



  public void run() throws Exception {

    int m = nextInt();

    int n = nextInt();



    boolean [][] burned = new boolean [n][m];

    List<Integer> burn = new ArrayList();

    for (int k = nextInt(); k > 0; k--) {

      int x = nextInt() - 1;

      int y = nextInt() - 1;

      burned[y][x] = true;

      burn.add(x * 10000 + y);

    }



    int lastXY = 0;

    List<Integer> newBurn = null;

    do {

      lastXY = burn.get(0);

      newBurn = new ArrayList();



      for (int xy : burn) {

        int x = xy / 10000;

        int y = xy % 10000;



        for (int i = 0; i < 4; i++) {

          int nx = x + DX[i];

          int ny = y + DY[i];



          if ((ny >= 0) && (ny < n) && (nx >= 0) && (nx < m) && (!burned[ny][nx])) {

            burned[ny][nx] = true;

            newBurn.add(nx * 10000 + ny);

          }

        }

      }



      burn = newBurn;

    } while (newBurn.size() > 0);



    println((lastXY / 10000 + 1) + "" "" + (lastXY % 10000 + 1));

  }



  public static void main(String... args) throws Exception {

    br = new BufferedReader(new InputStreamReader(new FileInputStream(""input.txt"")));

    pw = new PrintWriter(new BufferedOutputStream(new FileOutputStream(""output.txt"")));

    new P35C().run();

    br.close();

    pw.close();

    System.err.println(""\n[Time : "" + (System.currentTimeMillis() - startTime) + "" ms]"");

  }



  static long startTime = System.currentTimeMillis();

  static BufferedReader br;

  static PrintWriter pw;

  StringTokenizer stok;



  String nextToken() throws IOException {

    while (stok == null || !stok.hasMoreTokens()) {

      String s = br.readLine();

      if (s == null) { return null; }

      stok = new StringTokenizer(s);

    }

    return stok.nextToken();

  }



  void print(byte b) { print("""" + b); }

  void print(int i) { print("""" + i); }

  void print(long l) { print("""" + l); }

  void print(double d) { print("""" + d); }

  void print(char c) { print("""" + c); }

  void print(Object o) {

    if (o instanceof int[]) { print(Arrays.toString((int [])o));

    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));

    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));

    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));

    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));

    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));

    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));

    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));

    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));

    } else { print("""" + o); }

  }

  void print(String s) { pw.print(s); }

  void println() { println(""""); }

  void println(byte b) { println("""" + b); }

  void println(int i) { println("""" + i); }

  void println(long l) { println("""" + l); }

  void println(double d) { println("""" + d); }

  void println(char c) { println("""" + c); }

  void println(Object o) { print(o); println(); }

  void println(String s) { pw.println(s); }

  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }

  long nextLong() throws IOException { return Long.parseLong(nextToken()); }

  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }

  char nextChar() throws IOException { return (char) (br.read()); }

  String next() throws IOException { return nextToken(); }

  String nextLine() throws IOException { return br.readLine(); }

  int [] readInt(int size) throws IOException {

    int [] array = new int [size];

    for (int i = 0; i < size; i++) { array[i] = nextInt(); }

    return array;

  }

  long [] readLong(int size) throws IOException {

    long [] array = new long [size];

    for (int i = 0; i < size; i++) { array[i] = nextLong(); }

    return array;

  }

  double [] readDouble(int size) throws IOException {

    double [] array = new double [size];

    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }

    return array;

  }

  String [] readLines(int size) throws IOException {

    String [] array = new String [size];

    for (int i = 0; i < size; i++) { array[i] = nextLine(); }

    return array;

  }

}",6,3
"import java.io.*;
import java.util.*;

public class C35C_BFS_Fire {
    public static boolean[][] burning;
    public static LinkedList<int[]> LitTrees; //which is best to use
    public static int N, M;
    public static int[] lastTree;
    public static void main(String[] args) throws IOException {
        // InputStreamReader stream = new InputStreamReader(System.in);
        // BufferedReader input = new BufferedReader(stream);

        BufferedReader input = new BufferedReader(new FileReader(""input.txt""));
		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(""output.txt"")));

        StringTokenizer dataR = new StringTokenizer(input.readLine());
        N = Integer.parseInt(dataR.nextToken());
        M = Integer.parseInt(dataR.nextToken());
        burning = new boolean[N+1][M+1];

        StringTokenizer dataR1 = new StringTokenizer(input.readLine());
        int K = Integer.parseInt(dataR1.nextToken());

        StringTokenizer dataR2 = new StringTokenizer(input.readLine());
        LitTrees = new LinkedList<int[]>();
        for (int j = 0; j < K; j++){
            int x = Integer.parseInt(dataR2.nextToken());
            int y = Integer.parseInt(dataR2.nextToken());
            int[] coord = {x, y};
            LitTrees.add(coord);
            burning[x][y] = true;
        }

        // while(ExistsAliveTree()){
        //     spread();
        // }

        spread();

        // System.out.println(LitTrees.getLast()[0] + "" "" + LitTrees.getLast()[1]);
        out.println(lastTree[0] + "" "" + lastTree[1]);
        out.close();

    }

    public static void spread(){
        while(!LitTrees.isEmpty()){
            int[] studying = LitTrees.removeFirst(); //is iterator faster
            int[] studying1 = {studying[0]-1, studying[1]};
            int[] studying2 = {studying[0], studying[1]-1};
            int[] studying3 = {studying[0], studying[1]+1};
            int[] studying4 = {studying[0]+1, studying[1]};
            if (studying1[0] >= 1 && !burning[studying1[0]][studying1[1]]){
                LitTrees.add(studying1);
                burning[studying1[0]][studying1[1]] = true;
            }
            if (studying2[1] >= 1 && !burning[studying2[0]][studying2[1]]){
                LitTrees.add(studying2);
                burning[studying2[0]][studying2[1]] = true;
            }
            if (studying3[1] < M+1 && !burning[studying3[0]][studying3[1]]){
                LitTrees.add(studying3);
                burning[studying3[0]][studying3[1]] = true;
            }
            if (studying4[0] < N+1 && !burning[studying4[0]][studying4[1]]){
                LitTrees.add(studying4);
                burning[studying4[0]][studying4[1]] = true;
            }
            lastTree = studying; 
        }        
    }
    

    public static boolean ExistsAliveTree() {
        if (LitTrees.size() == N*M){
            return false;
        } else{
            return true;
        }
    }
}",6,3
"import java.io.*;

import java.util.*;



public class cf35c {

	public static void main(String[] args) throws Exception {

		Scanner in = new Scanner(new File(""input.txt""));

		PrintWriter out = new PrintWriter(new File(""output.txt""));

		int[] dx = {0,0,1,-1};

		int[] dy = {1,-1,0,0};

		int n = in.nextInt();

		int m = in.nextInt();

		int[][] seen = new int[n][m];

		for(int i=0; i<n; i++)

			Arrays.fill(seen[i], -1);

		Queue<Integer> q = new LinkedList<Integer>();

		int k = in.nextInt();

		for(int i=0; i<k; i++) {

			int x = in.nextInt()-1;

			int y = in.nextInt()-1;

			q.add(x);

			q.add(y);

			q.add(0);

			seen[x][y] = 0;

		}

		while(!q.isEmpty()) {

			int x = q.poll();

			int y = q.poll();

			int t = q.poll();

			for(int i=0; i<dx.length; i++) {

				int nx = x + dx[i];

				int ny = y + dy[i];

				if(nx < 0 || nx >= n || ny < 0 || ny >= m)

					continue;

				if(seen[nx][ny] != -1) continue;

				seen[nx][ny] = t+1;

				q.add(nx);

				q.add(ny);

				q.add(t+1);

			}

		}

		int best=-1,x=0,y=0;

		for(int i=0; i<n; i++)

			for(int j=0; j<m; j++)

				if(seen[i][j] > best) {

					best = seen[i][j];

					x = i+1;

					y = j+1;

				}

		out.println(x + "" "" +y);

		out.close();

	}

}

",6,5
"

import java.awt.Point;

import java.io.*;

import java.util.*;



import static java.lang.Math.*;



public class BetaRound35_C implements Runnable {



	final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;

	BufferedReader in;

	PrintWriter out;

	StringTokenizer tok = new StringTokenizer("""");



	void init() throws IOException {

		in = new BufferedReader(new FileReader(""input.txt""));

		out = new PrintWriter(""output.txt"");

	}



	String readString() throws IOException {

		while (!tok.hasMoreTokens()) {

			tok = new StringTokenizer(in.readLine());

		}

		return tok.nextToken();

	}



	int readInt() throws IOException {

		return Integer.parseInt(readString());

	}



	@Override

	public void run() {

		try {

			long t1 = System.currentTimeMillis();

			init();

			solve();

			out.close();

			long t2 = System.currentTimeMillis();

			System.err.println(""Time = "" + (t2 - t1));

		} catch (Exception e) {

			e.printStackTrace(System.err);

			System.exit(-1);

		}

	}



	public static void main(String[] args) {

		new Thread(new BetaRound35_C()).start();

	}

	

	void solve() throws IOException {

		int n = readInt();

		int m = readInt();

		int k = readInt();

		Queue<Point> q = new ArrayDeque<Point>();

		boolean[][] visited = new boolean[n + 2][m + 2];

		for (int j = 0; j < m + 2; j++) {

			visited[0][j] = true;

			visited[n + 1][j] = true;

		}

		for (int i = 0; i < n + 2; i++) {

			visited[i][0] = true;

			visited[i][m + 1] = true;

		}

		for (int i = 0; i < k; i++) {

			int x = readInt();

			int y = readInt();

			q.add(new Point(x, y));

			visited[x][y] = true;

		}

		

		Point p = null;

		while (!q.isEmpty()) {

			p = q.poll();

			int x = p.x, y = p.y;

			if (!visited[x + 1][y]) {

				q.add(new Point(x + 1, y));

				visited[x + 1][y] = true;

			}

			if (!visited[x - 1][y]) {

				q.add(new Point(x - 1, y));

				visited[x - 1][y] = true;

			}

			if (!visited[x][y + 1]) {

				q.add(new Point(x, y + 1));

				visited[x][y + 1] = true;

			}

			if (!visited[x][y - 1]) {

				q.add(new Point(x, y - 1));

				visited[x][y - 1] = true;

			}

		}

		out.print(p.x + "" "" + p.y);

	}

	

}

",6,3
"import java.awt.Point;

import java.io.File;

import java.io.FileInputStream;

import java.io.FileNotFoundException;

import java.io.PrintStream;

import java.util.HashSet;

import java.util.LinkedList;

import java.util.Queue;

import java.util.Scanner;



public class FireAgain {



	Point coordinate;

	Queue<Point> q = new LinkedList<Point>();

	int m, n;

	boolean[][] arr;

	PrintStream out ;



	void bfs(Point start) {



		while (!q.isEmpty()) {

			Point front = q.poll();

			Point p = new Point();



			p.x = front.x - 1;

			p.y = front.y;

			if (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1) {

				if (!arr[p.x][p.y]) {

					arr[p.x][p.y] = true;

					q.add(p);

				}

			}

			

			p = new Point();

			p.x = front.x + 1;

			p.y = front.y;

			if (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1)

				if (!arr[p.x][p.y]) {

					arr[p.x][p.y] = true;

					q.add(p);

				}



			p = new Point() ;

			p.x = front.x;

			p.y = front.y + 1;

			if (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1)

				if (!arr[p.x][p.y]) {

					arr[p.x][p.y] = true;

					q.add(p);

				}



			p = new Point() ;

			p.x = front.x;

			p.y = front.y - 1;

			if (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1)

				if (!arr[p.x][p.y]) {

					arr[p.x][p.y] = true;

					q.add(p);

				}



			if (q.size() == 0)

				out.print(front.x + "" "" + front.y);

		}

	}



	/**

	 * @param args

	 * @throws FileNotFoundException 

	 */

	public static void main(String[] args) throws FileNotFoundException {

		// TODO Auto-generated method stub

		FireAgain fa = new FireAgain();

		Scanner Scan = new Scanner(new FileInputStream(""input.txt""));

		fa.out = new PrintStream(new File(""output.txt""));

		fa.n = Scan.nextInt();

		fa.m = Scan.nextInt();

		int k = Scan.nextInt();

		fa.arr = new boolean[2001][2001];



		for (int i = 0; i < k; i++) {

			fa.coordinate = new Point();

			fa.coordinate.x = Scan.nextInt();

			fa.coordinate.y = Scan.nextInt();

			fa.q.add(fa.coordinate);

			fa.arr[fa.coordinate.x][fa.coordinate.y] = true;

		}



		fa.bfs(fa.q.peek());



	}



}",6,3
"import java.awt.Point;

import java.io.File;

import java.io.FileInputStream;

import java.io.FileNotFoundException;

import java.io.PrintStream;

import java.util.HashSet;

import java.util.LinkedList;

import java.util.Queue;

import java.util.Scanner;



public class FireAgain {



	Point coordinate;

	Queue<Point> q = new LinkedList<Point>();

	int m, n;

	boolean[][] arr;

	PrintStream out ;



	void bfs(Point start) {



		while (!q.isEmpty()) {

			Point front = q.poll();

			Point p = new Point();



			p.x = front.x - 1;

			p.y = front.y;

			if (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1) {

				if (!arr[p.x][p.y]) {

					arr[p.x][p.y] = true;

					q.add(p);

				}

			}

			

			p = new Point();

			p.x = front.x + 1;

			p.y = front.y;

			if (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1)

				if (!arr[p.x][p.y]) {

					arr[p.x][p.y] = true;

					q.add(p);

				}



			p = new Point() ;

			p.x = front.x;

			p.y = front.y + 1;

			if (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1)

				if (!arr[p.x][p.y]) {

					arr[p.x][p.y] = true;

					q.add(p);

				}



			p = new Point() ;

			p.x = front.x;

			p.y = front.y - 1;

			if (p.x >= 1 && p.x <= n && p.y <= m && p.y >= 1)

				if (!arr[p.x][p.y]) {

					arr[p.x][p.y] = true;

					q.add(p);

				}



			if (q.size() == 0)

				out.print(front.x + "" "" + front.y);

		}

	}



	/**

	 * @param args

	 * @throws FileNotFoundException 

	 */

	public static void main(String[] args) throws FileNotFoundException {

		// TODO Auto-generated method stub

		FireAgain fa = new FireAgain();

		Scanner Scan = new Scanner(new FileInputStream(""input.txt""));

		fa.out = new PrintStream(new File(""output.txt""));

		fa.n = Scan.nextInt();

		fa.m = Scan.nextInt();

		int k = Scan.nextInt();

		fa.arr = new boolean[2001][2001];



		for (int i = 0; i < k; i++) {

			fa.coordinate = new Point();

			fa.coordinate.x = Scan.nextInt();

			fa.coordinate.y = Scan.nextInt();

			fa.q.add(fa.coordinate);

			fa.arr[fa.coordinate.x][fa.coordinate.y] = true;

		}



		fa.bfs(fa.q.peek());



	}



}

",6,3
"import java.io.*;

import java.io.IOException;

import java.util.Iterator;

import java.util.LinkedList;

import java.util.Queue;

import java.util.Scanner;

import java.util.Stack;

import java.util.TreeSet;



public class ViewAngle{

		        	private static int V,level[][],count=-1,lev_dfs[],degree=0,no_vert_conn_comp=0;

		        	private static Stack <Integer>st=new Stack();

		        	private static LinkedList<Integer > adj[];

		        	private static boolean[][] Visite;

		        	private static boolean [] Visited;

		        	private static TreeSet<Integer> ts=new TreeSet();

		        //	private static HashMap

		        	private static Queue<Pair> queue = new LinkedList<Pair>();

		        	ViewAngle(int V){

		    V++;

		    this.V=(V);

		    adj=new LinkedList[V];

		    Visite=new boolean[100][100];

	

	 	   Visited=new boolean[V];

		   

		   lev_dfs=new int[V]; 

		   for(int i=0;i<V;i++)

			   adj[i]=new LinkedList<Integer>();

		    }

		        	static File inFile,outFile;

		        	static FileWriter fWriter;

		        	static PrintWriter pWriter;

		        	public static void main(String[] args) throws IOException {

		    	

		    	 inFile=new File(""input.txt"");

		    	 outFile = new File (""output.txt"");

			     fWriter = new FileWriter (outFile);

			    pWriter = new PrintWriter (fWriter);

			  Scanner sc = new Scanner (inFile);

			  int n=sc.nextInt();

			  int m=sc.nextInt();

			  char c[][]=new char[n][m];

			  for(int i=0;i<n;i++){

				  for(int j=0;j<m;j++){

					  c[i][j]='.';

				  }

			  }

			  setup(n, m);

			  int k=sc.nextInt();

			  for(int i=0;i<k;i++){

				  int x=sc.nextInt();

				  int y=sc.nextInt();

				  queue.add(new Pair(x-1, y-1));

				  c[x-1][y-1]='X';

			 level[x-1][y-1]=-1;

			 Visite[x-1][y-1]=true;

			  }

			BFS(c, n, m);

		    	pWriter.close();

		    	sc.close();

		    }

		   static  void addEdge(int v,int w){

		    	

		    	if(adj[v]==null){

		    		adj[v]=new LinkedList();

		    	}

		    	adj[v].add(w);

		     

		    	

		    }

		 

		    public static int BFS2(int startVert,int dest){

		    	Visited=new boolean[V];

		    	for(int i=1;i<V;i++){

		    		lev_dfs[i]=-1;

		    	}

		    	Queue<Integer> q=new LinkedList<Integer>();

		    	q.add(startVert);

		    	

		    	lev_dfs[startVert]=0;

		    	while(!q.isEmpty()){

		    		int top=q.poll();

		    		

		    		Iterator<Integer> i= adj[top].listIterator();

		    		while(i.hasNext()){

		    			int n=i.next();

		    			if(!Visited[n]){

		    				q.add(n);

		    				Visited[n]=true;

		    				lev_dfs[n]=lev_dfs[top]+1;

		    			if(n==dest){

		    				q.clear();

		    				return lev_dfs[n];

		    			

		    			}

		    			}

		    		}

		    	}

		    	q.clear();

		    	return -1;

		    }

		    public int getEd(){

		    	return degree/2;

		    }

		    public void get(int from,int to){

		    	int h=lev_dfs[from]-lev_dfs[to];

		    	if(h<=0){

		    		System.out.println(-1);

		    	}else{

		    		System.out.println(h-1);

		    	}

		    }

		    public static void setup(int n,int m){



		    	 level=new int[n][m];

		    	Visite=new boolean[n][m];	

		    }

		    private static boolean check(int x,int y,char c[][]){

			

				if((x>=0 && y>=0) && (x<c.length && y<c[0].length) && c[x][y]=='.'){

					

					return true;

				}

				return false;

			}

		    public static int BFS(char[][] c,int n,int m)

		    {

		        //Visited[s]=true;

		   //     queue.add(new Pair(x,y));

		       int count=0;

		 //  level[x][y]=-1;

		        while (!queue.isEmpty())

		        {

		        	

		            Pair temp = queue.poll();

		           int  x=temp.w;

		            int y=temp.h;

		            Visite[x][y]=true;

		            if(check(x+1,y,c) && !Visite[x+1][y]){

		            	level[x+1][y]=level[x][y]+1;

		            	queue.add(new Pair(x+1, y));

		            Visite[x+1][y]=true;

		            }

		            if(check(x-1,y,c) && !Visite[x-1][y]){

		            	level[x-1][y]=level[x][y]+1;

		            	queue.add(new Pair(x-1, y));

		            	Visite[x-1][y]=true;

		            }

		            if(check(x,y+1,c) && !Visite[x][y+1]){

		            	level[x][y+1]=level[x][y]+1;

		            	queue.add(new Pair(x, y+1));

		            	Visite[x][y+1]=true;

		            }

		            if(check(x,y-1,c) && !Visite[x][y-1]){

		            	level[x][y-1]=level[x][y]+1;

		            	queue.add(new Pair(x, y-1));

		            	Visite[x][y-1]=true;

		            }

		          

		            

		        }

		        int prev_lev=-1,x=-1,y=-1;

		        for(int i=0;i<n;i++){

		        	for(int j=0;j<m;j++){

		        		if(level[i][j]>=prev_lev){

		        			prev_lev=level[i][j];

		        			x=i;y=j;

		        		}

		        		//System.out.println(level[i][j]+"" "");

		        	}

		        	//System.out.println();

		        }

		        

		        pWriter.println((x+1)+"" ""+(y+1));

		        return V;

		    }

		    

		    private void getAns(int startVertex){

		    	for(int i=0;i<adj[startVertex].size();i++){

		    		int ch=adj[startVertex].get(i);

		    		for(int j=0;j<adj[ch].size();j++){

		    			int ch2=adj[ch].get(j);

		    			if(adj[ch2].contains(startVertex)){

		    				System.out.println(startVertex+"" ""+ch+"" ""+ch2);

		    				System.exit(0);

		    			}

		    		}

		    	}

		    }

		    

		     public long dfs(int startVertex){

		    //	 getAns(startVertex);

		    	 

		    	 if(!Visited[startVertex])  {

		    

		   return dfsUtil(startVertex,Visited);

		    	//return getAns();

		    	}

		    	 

		    

		     

		    return 0;

		    	}

		 private long dfsUtil(int startVertex, boolean[] Visited) {//0-Blue 1-Pink

		//System.out.println(startVertex);

			 int c=1;

			 long cout=0;

		      degree=0;

		    	Visited[startVertex]=true;

		    //	lev_dfs[startVertex]=1;

		      st.push(startVertex);

		    while(!st.isEmpty()){

		    	

		    	int top=st.pop();

		    

		   	Iterator<Integer> i=adj[top].listIterator();

		     degree+=adj[top].size();

		    

		    while(i.hasNext()){

		// System.out.println(top+"" ""+adj[top].size());

		    	int n=i.next();

		  //  	System.out.print(n+"" "");

		     if( !Visited[n]){

		    				Visited[n]=true;

		    					st.push(n);

		    				//	System.out.print(n+"" "");

		    					lev_dfs[n]=top;

		    			

		    		 }

		         }

		//    System.out.println(""--------------------------------"");

		 }

		    	

		    for(int i=1;i<V;i++){

		    	if(lev_dfs[i]!=0){

		    		System.out.print(lev_dfs[i]+"" "");

		    	}

		    }

		    return cout;

			    

		  //  System.out.println(""NO"");

		   // return c;

		    	

		    

		    

		    

		    }

		        

		        }     

class Pair implements Comparable<Pair>{

	   

	int w;

	int h;

	Pair(int w,int h){

		this.w=w;

		this.h=h;

	}

	@Override

	public int compareTo(Pair o) {

		// TODO Auto-generated method stub

	//	Sort in increasing order

		if(w>o.w){

			return 1;

		}else if(w<o.w){

			return -1;

		}else{

			if(h>o.h)

				return 1;

			else if(h<o.h)

				return -1;

			else

			return 0;

		}

		

		

	}



}

		        	",6,5
"//package round35;



import java.io.File;

import java.io.PrintWriter;

import java.util.Arrays;

import java.util.Scanner;



public class C {

	Scanner in;

	PrintWriter out;

//	String INPUT = ""3 3 1 1 1"";

	String INPUT = """";

	

	void solve()

	{

		int n = ni();

		int m = ni();

		int k = ni();

		int[] x = new int[k];

		int[] y = new int[k];

		for(int i = 0;i < k;i++){

			x[i] = ni() - 1;

			y[i] = ni() - 1;

		}

		int max = -1;

		int maxi = -1;

		int maxj = -1;

		for(int i = 0;i < n;i++){

			for(int j = 0;j < m;j++){

				int min = Integer.MAX_VALUE;

				for(int l = 0;l < k;l++){

					min = Math.min(min, Math.abs(x[l] - i) + Math.abs(y[l] - j));

				}

				if(min > max){

					max = min;

					maxi = i;

					maxj = j;

				}

			}

		}

		

		out.println((maxi+1) + "" "" + (maxj+1));

	}

	

	void run() throws Exception

	{

		in = INPUT.isEmpty() ? new Scanner(new File(""input.txt"")) : new Scanner(INPUT);

		out = INPUT.isEmpty() ? new PrintWriter(""output.txt"") : new PrintWriter(System.out);



		solve();

		out.flush();

	}

	

	

	public static void main(String[] args) throws Exception

	{

		new C().run();

	}

	

	int ni() { return Integer.parseInt(in.next()); }

	void tr(Object... o) { if(INPUT.length() != 0)System.out.println(o.length > 1 || o[0].getClass().isArray() ? Arrays.deepToString(o) : o[0]); }

	static String join(int[] a, int d){StringBuilder sb = new StringBuilder();for(int v : a){sb.append(v + d + "" "");}return sb.toString();}

}

",6,5
" 

import java.util.ArrayList;

import java.util.Scanner;

import java.io.BufferedReader;

import java.io.File;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.FileWriter;

import java.io.IOException;

import java.io.PrintWriter;

import java.nio.*;

 public class Main {





    public static void main(String[] args) throws NumberFormatException, IOException 

    {

        Scanner sc = new Scanner(new File(""input.txt""));

        

        int n = sc.nextInt();

        int m =sc.nextInt();

        sc.nextLine();

        int k =sc.nextInt();

        int les[][] = new int[n][m];

        PrintWriter out = new PrintWriter(new FileWriter(""output.txt"")); 

        //sc.nextLine();

        ArrayList<Integer[]> list = new ArrayList();

        sc.nextLine();

        for(int i = 0;i<k;i++)

        {

            

            Integer[] ii = new Integer[2];

            ii[0] = sc.nextInt()-1;

            ii[1] = sc.nextInt()-1;

            list.add(ii);

            

        }

        sc.close(); 

        int maxr = 0;

        int maxi = 0;

        int maxj = 0;

        for(int i = 0;i<n;i++)

        {

            for(int j = 0;j<m;j++)

            {

                int minr = 100000;

                int mini = 0;

                int minj = 0;

                for(int f = 0;f<k;f++)

                {

                    Integer[] ii = list.get(f);

                    int ww = Math.abs(ii[0] - i);

                    int hh = Math.abs(ii[1] - j);

                    int r = ww+hh;

                    if(r<minr)

                    {

                        minr = r;

                        mini=i;

                        minj=j;

                    }

                    

                }

                if(maxr<minr&&minr<100000)

                {

                    maxi = mini;

                    maxj = minj;

                    maxr = minr;

                }

            }

        }

        

        out.print((maxi+1)+"" ""+(maxj+1));

        out.close();

        

    }

    

    





    

    

}

",6,5
"/*
If you want to aim high, aim high
Don't let that studying and grades consume you
Just live life young
******************************
What do you think? What do you think?
1st on Billboard, what do you think of it
Next is a Grammy, what do you think of it
However you think, Iâ€™m sorry, but shit, I have no fcking interest
*******************************
I'm standing on top of my Monopoly board
That means I'm on top of my game and it don't stop
til my hip don't hop anymore
https://www.a2oj.com/Ladder16.html
*******************************
300iq as writer = Sad!
*/
import java.util.*;
import java.io.*;
import java.math.*;

   public class x35C
   {
      public static void main(String hi[]) throws Exception
      {
         BufferedReader infile = new BufferedReader(new FileReader(""input.txt""));
         StringTokenizer st = new StringTokenizer(infile.readLine());
         int N = Integer.parseInt(st.nextToken());
         int M = Integer.parseInt(st.nextToken());
         int K = Integer.parseInt(infile.readLine());
         int[][] grid = new int[N][M];
         for(int i=0; i < N; i++)
            Arrays.fill(grid[i], -1);
         ArrayDeque<Integer> q = new ArrayDeque<Integer>();
         st = new StringTokenizer(infile.readLine());
         while(K-->0)
         {
            int a = Integer.parseInt(st.nextToken())-1;
            int b = Integer.parseInt(st.nextToken())-1;
            grid[a][b] = 0;
            q.add(a);   q.add(b);
         }
         while(q.size() > 0)
         {
            int x = q.poll();
            int y = q.poll();
            if(x > 0 && grid[x-1][y] == -1)
            {
               grid[x-1][y] = grid[x][y]+1;
               q.add(x-1); q.add(y);
            }
            if(y > 0 && grid[x][y-1] == -1)
            {
               grid[x][y-1] = grid[x][y]+1;
               q.add(x);   q.add(y-1);
            }
            if(x+1 < N && grid[x+1][y] == -1)
            {
               grid[x+1][y] = grid[x][y]+1;
               q.add(x+1); q.add(y);
            }
            if(y+1 < M && grid[x][y+1] == -1)
            {
               grid[x][y+1] = grid[x][y]+1;
               q.add(x);   q.add(y+1);
            }
         }
         int r = 0;
         int c = 0;
         for(int i=0; i < N; i++)
            for(int j=0; j < M; j++)
               if(grid[r][c] < grid[i][j])
               {
                  r = i;
                  c = j;
               }
         r++;  c++;
         System.setOut(new PrintStream(new File(""output.txt"")));
         System.out.println(r+"" ""+c);
      }
   }",6,5
"import java.io.*;
import java.util.*;

public class P035C {
    private class Pair {
        private int x;
        private int y;
        
        private Pair(int x, int y) {
            this.x = x;
            this.y = y;
        }
        
        public int hashCode() {
            return 37 * x + y;
        }
        
        public boolean equals(Object other) {
            if (other instanceof Pair) {
                Pair otherPair = (Pair)other;
                return x == otherPair.x && y == otherPair.y;
            }
            
            return false;
        }
    }
    
    private boolean[][] visited;
    private final int N;
    private final int M;
    private final int k;
    private ArrayList<Pair> fires = new ArrayList<Pair>();
    private ArrayList<Pair> neighbors = new ArrayList<Pair>();
    
    public P035C() throws IOException {
        Scanner sc = new Scanner(new File(""input.txt""));

        N = sc.nextInt();
        M = sc.nextInt();
        visited = new boolean[N][M];
        k = sc.nextInt();
        for (int i = 0; i < k; i++) {
            int x = sc.nextInt() - 1;
            int y = sc.nextInt() - 1;
            fires.add(new Pair(x, y));
        }
        bfs();
    }
    
    private void bfs() throws IOException{
        java.util.Queue<Pair> queue = new ArrayDeque<Pair>();
        for (Pair p : fires) {
            queue.add(p);
            visited[p.x][p.y] = true;
        }
        
        Pair last = fires.get(0);
        while (!queue.isEmpty()) {
            Pair p = last = queue.poll();            
            for (Pair pn : getNeighbors(p)) {
                if (!visited[pn.x][pn.y]) {
                    queue.add(pn);
                    visited[pn.x][pn.y] = true;
                }
            }
        }
        
        PrintWriter output = new PrintWriter(new FileWriter(new File(""output.txt"")));
        output.printf(""%d %d\n"", last.x + 1, last.y + 1);
        output.close();
    }
    
    private Collection<Pair> getNeighbors(Pair p) {
        neighbors.clear();
        if (p.x > 0)   neighbors.add(new Pair(p.x-1, p.y));
        if (p.x < N-1) neighbors.add(new Pair(p.x+1, p.y));
        if (p.y > 0)   neighbors.add(new Pair(p.x, p.y-1));
        if (p.y < M-1) neighbors.add(new Pair(p.x, p.y+1));
        
        return neighbors;
    }
    
    public static void main(String[] args) throws IOException {
        P035C solution = new P035C();
    }
}
        
      ",6,3
"import java.io.BufferedWriter;

import java.io.File;

import java.io.FileWriter;

import java.io.IOException;

import java.io.OutputStreamWriter;

import java.util.Arrays;

import java.util.LinkedList;

import java.util.Queue;

import java.util.Scanner;





public class Main {

    public static void main(String[] args) throws IOException {

        Scanner scn = new Scanner(new File(""input.txt""));

        BufferedWriter out = new BufferedWriter(new FileWriter(""output.txt"")); 

        

        int r = scn.nextInt();

        int c = scn.nextInt();

        

        int[][] a = new int[r][c];

        

        for(int[] i: a)

            Arrays.fill(i, 1<<30);

        

        int k = scn.nextInt();

            

        Queue<State> q = new LinkedList<State>();

        for(int l = 0; l < k; l++){

            int i = scn.nextInt()-1;

            int j = scn.nextInt()-1;

        

            a[i][j] = 0;

            q.add(new State(i, j, 0));

        }

        

        while(!q.isEmpty()){

            State st = q.poll();

            

            a[st.i][st.j] = st.c;

            

            for(int d = 0; d < 4; d++){

                int ii = st.i + di[d];

                int jj = st.j + dj[d];

                

                if(ii < 0 || ii >= r || jj < 0 || jj >= c)continue;

                if(a[ii][jj] != 1 << 30)continue;

                

                a[ii][jj] = st.c+1;

                q.add(new State(ii, jj, st.c+1));

            }

        }

        

        int max = 0;

        for(int i = 0; i < r; i++)

            for(int j = 0; j < c; j++)

                max = Math.max(max, a[i][j]);

        

        for(int i = 0; i < r; i++)

            for(int j = 0; j < c; j++)

                if(a[i][j] == max){

//                  System.out.println(i+1 + "" "" + (j+1));

                    out.write((i+1)+"" ""+(j+1));

                    out.newLine();

                    

                    out.close();

                    

                    return;

                }

        

    }

    static int[] di = {0, 0, -1, 1};

    static int[] dj = {1, -1, 0, 0};

}



class State{

    int i, j, c;

    public State(int ii, int ji, int ci){

        i = ii;

        j = ji;

        c = ci;

    }

}",6,5
"import java.io.*;
import java.util.*;

public class C {
	public static void main(String[] args) throws Exception {
		File in = new File(""input.txt""), out = new File(""output.txt"");
		Scanner s;
		PrintWriter pw;
		if (in.exists()) {
			s = new Scanner(in);
			pw = new PrintWriter(out);
		} else {
			s = new Scanner(System.in);
			pw = new PrintWriter(System.out);
		}
		int n = s.nextInt(), m = s.nextInt();
		int k = s.nextInt();
		List<int[]> list = new ArrayList<int[]>();
		for (int t = 0; t < k; ++t) {
			list.add(new int[] { s.nextInt() - 1, s.nextInt() - 1 });
		}
		int max = 0, mi = 1, mj = 1;
		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < m; ++j) {
				int min = Integer.MAX_VALUE;
				for (int[] p : list) {
					min = Math.min(min, Math.abs(i - p[0]) + Math.abs(j - p[1]));
				}
				if (min > max) {
					max = Math.max(max, min);
					mi = i + 1;
					mj = j + 1;
				}
			}
		}
		pw.println(mi + "" "" + mj);
		pw.close();
	}
}
",6,5
"import java.io.*;
import java.util.*;

public class ShostPath2 {
    static int[]X = new int[]{0,0,1,-1};
    static int[]Y = new int[]{1,-1,0,0};
    public static void main(String[] args) throws FileNotFoundException {
        Scanner sc = new Scanner(new FileReader(""input.txt""));
        PrintWriter out = new PrintWriter(new File(""output.txt""));
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][]trees = new int[n][m];
        int len = sc.nextInt();
        Queue<int[]>queue = new LinkedList<>();
        for (int i = 0; i < len; i++) {
            int x = sc.nextInt() - 1;
            int y = sc.nextInt() - 1;
            queue.add(new int[]{x,y});
            trees[x][y] = 1;
        }
        int[]ans = null;
        while (!queue.isEmpty()){
            int size = queue.size();
            for (int z = 0; z < size; z++) {
                int[] poll = queue.poll();
                ans = new int[]{poll[0] + 1,poll[1] + 1};
                for (int i = 0; i < 4; i++) {
                    int newX = poll[0] + X[i];
                    int newY = poll[1] + Y[i];
                    if(newX >= 0 && newY >= 0 && newX < n && newY < m && trees[newX][newY] != 1){
                        trees[newX][newY] = 1;
                        queue.add(new int[]{newX,newY});
                    }
                }
            }
        }
        out.print(ans[0] + "" "" + ans[1]);
        out.close();
    }
}
",6,3
"import java.util.*;
import java.io.*;
import java.math.*;
public class Main1
{
    static class Reader 
    { 
        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} 
        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} 
        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} 
        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} 
        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} 
        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} 
        public double d() throws IOException {return Double.parseDouble(s()) ;}
        public boolean isSpaceChar(int c) { return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; } 
        public boolean isEndOfLine(int c) { return c == '\n' || c == '\r' || c == -1; } 
    }
    
    
    ///////////////////////////////////////////////////////////////////////////////////////////
    //    RRRRRRRRR            AAA             HHH     HHH     IIIIIIIIIIIII   LLL           //
    //    RR    RRR           AAAAA            HHH     HHH      IIIIIIIIIII    LLL           //
    //    RR   RRR           AAAAAAA           HHH     HHH          III        LLL           //
    //    RR  RRR           AAA   AAA          HHHHHHHHHHH          III        LLL           //
    //    RRRRRR           AAA     AAA         HHHHHHHHHHH          III        LLL           //
    //    RR  RRR         AAAAAAAAAAAAA        HHH     HHH          III        LLL           //
    //    RR    RRR      AAA         AAA       HHH     HHH      IIIIIIIIIII    LLLLLLLLLLLL  //
    //    RR     RRR    AAA           AAA      HHH     HHH     IIIIIIIIIIIII   LLLLLLLLLLLL  //
    ///////////////////////////////////////////////////////////////////////////////////////////
    static class pair 
    {
       int x;
       int y;
       public pair (int k, int p) 
       {
           x = k;
           y = p;
       }
       @Override
       public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            pair pair = (pair) o;
            return x == pair.x && y == pair.y;
        }
    
       @Override
       public int hashCode() {
            return Objects.hash(x, y);
       }
    }
    public static void main(String[] args)throws IOException
    {
        /*PrintWriter out= new PrintWriter(new File(""input.txt""));
        Reader sc=new Reader();*/
        Scanner sc = new Scanner(new File(""input.txt""));
		PrintWriter out = new PrintWriter(""output.txt"");
        Queue<pair> q=new LinkedList<>();
        int n=sc.nextInt();
        int m=sc.nextInt();
        int t=sc.nextInt();
        int mark[][]=new int[n+2][m+2];
        while(t-->0)
        {
            int a=sc.nextInt();int b=sc.nextInt();
            mark[a][b]=1;
            q.add(new pair(a,b));
        }
        int ansx=1;int ansy=1;
        while(q.size()!=0)
        {
            pair p=q.remove();
            if(mark[Math.max(1,p.x-1)][p.y]==0)
            {
                q.add(new pair(Math.max(1,p.x-1),p.y));
                mark[Math.max(1,p.x-1)][p.y]=1;
                ansx=Math.max(1,p.x-1);
                ansy=p.y;
            }
            if(mark[Math.min(n,p.x+1)][p.y]==0)
            {
                q.add(new pair(Math.min(n,p.x+1),p.y));
                mark[Math.min(n,p.x+1)][p.y]=1;
                ansx=Math.min(n,p.x+1);
                ansy=p.y;
            }
            if(mark[p.x][Math.max(1,p.y-1)]==0)
            {
                q.add(new pair(p.x,Math.max(1,p.y-1)));
                mark[p.x][Math.max(1,p.y-1)]=1;
                ansx=p.x;
                ansy=Math.max(1,p.y-1);
            }
            if(mark[p.x][Math.min(m,p.y+1)]==0)
            {
                q.add(new pair(p.x,Math.min(m,p.y+1)));
                mark[p.x][Math.min(m,p.y+1)]=1;
                ansx=p.x;
                ansy=Math.min(m,p.y+1);
            }
        }
        out.println(ansx+"" ""+ansy);
        out.flush();
    }
}
    ",6,1
"import java.io.*;

import java.util.*;

import java.math.*;







public class Main{

	

	public static void main(String[] Args) throws Exception {

	     Scanner sc = new Scanner(new FileReader(""input.txt""));

	     int n,m,k;

	     Integer lx,ly;

	     boolean d[][];

	     n = sc.nextInt(); m = sc.nextInt(); k = sc.nextInt();

	     d = new boolean [n+1][m+1];

	     for(int i=0;i<=n;++i)

	      for(int j=0;j<=m;++j)

	       d[i][j]=false;

	     

	     Queue< pair > q = new LinkedList< pair >();

	     lx = ly = -1;

	     for(int i=0;i<k;++i){

	     	int x,y; x = sc.nextInt(); y = sc.nextInt();

	     	q.add(new pair(x,y)); lx = x; ly = y;

	     	d[x][y]=true;

	     }

	     

	     int dx [] = {0,0,1,-1};

	     int dy [] = {-1,1,0,0};

	     

	     

	     while(!q.isEmpty()){

	     	 pair tp = q.remove();

	     	 int x = tp.x; int y = tp.y;

	     	 for(int i=0;i<4;++i){

	     	 	 int nx = x+dx[i]; int ny = y+dy[i];

	     	 	 if(nx<1 || nx>n || ny<1 || ny>m || d[nx][ny] ) continue;

	     	     d[nx][ny]=true;

	     	     q.add(new pair(nx,ny));

	     	     lx = nx; ly = ny;

	     	 }

	     }

	     FileWriter fw = new FileWriter(""output.txt"");

	     fw.write(lx.toString()); fw.write("" ""); fw.write(ly.toString());;

	     fw.flush();

	     	

	}

}

class pair {



  public int x,y;

  public pair(int _x,int _y){ x = _x; y = _y; }



}",6,5
"import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;


public class R035C {
    public void debug(Object... objects) { System.err.println(Arrays.deepToString(objects)); }
    public static final int INF = 987654321;
    public static final long LINF = 987654321987654321L;
    public static final double EPS = 1e-9;
    
    Scanner scanner;
    PrintWriter out;
    int[][] iss;
    
    public R035C() {
        try {
            this.scanner = new Scanner(new File(""input.txt""));
            this.out = new PrintWriter(""output.txt"");
        } catch(FileNotFoundException ex) { ex.printStackTrace(); }
    }
    
    class Point implements Comparable<Point> {
        int x, y, count;
        Point(int x, int y) { this.x = x; this.y = y; }
        public int hashCode() { return x * 17 + y; }
        public boolean equals(Object o) {
            if(!(o instanceof Point)) return false;
            Point that = (Point)o;
            return this.x == that.x && this.y == that.y;
        }
        public int compareTo(Point that) { return this.count - that.count; }
        public String toString()  { return ""("" + x + "", "" + y + "":"" + count + "")""; }
    }

    
    int[] dx = new int[] {  0, 0, -1, 1 };
    int[] dy= new int[] { -1, 1,  0, 0 };
    int n, m;
    
    Queue<Point> q;
    
    Point bfs() {
        int max = -INF;
        Point p = null;
        while(!q.isEmpty()) {
            Point cur = q.remove();
            if(max < cur.count) { max = cur.count; p = cur; } 
            for(int i=0; i<dx.length; i++) {
                int nx = cur.x + dx[i];
                int ny = cur.y + dy[i];
                if(nx < 0 || nx >= n) { continue; }
                if(ny < 0 || ny >= m) { continue; }
                Point np = new Point(nx, ny);
                if(iss[nx][ny] != 0) { continue; } 
                np.count = cur.count+1;
                iss[nx][ny] = np.count;
                q.add(np);
            }
        }
        return p;
    }
    
    private void solve() {
        this.n = scanner.nextInt();
        this.m = scanner.nextInt();
        this.iss = new int[n][m];
        int k = scanner.nextInt();
        q = new PriorityQueue<Point>();
        for(int i=0; i<k; i++) {
            int x = scanner.nextInt() - 1;
            int y = scanner.nextInt() - 1;
            Point init = new Point(x, y);
            init.count = 1;
            q.add(init);
            iss[x][y] = 1;
        }
        Point p = bfs();
        out.println((p.x+1) + "" "" + (p.y+1));
    }
    
    private void finish() { this.out.close(); }
    
    public static void main(String[] args) { 
        R035C obj = new R035C();
        obj.solve();
        obj.finish();
    }
}
",6,3
"import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Collection;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.Queue;
import java.io.BufferedReader;
import java.util.LinkedList;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Nasko
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream;
        try {
            inputStream = new FileInputStream(""input.txt"");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        OutputStream outputStream;
        try {
            outputStream = new FileOutputStream(""output.txt"");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int N = in.nextInt();
            int M = in.nextInt();
            int[][] dist = new int[N][M];
            for (int[] ini : dist) Arrays.fill(ini, (1 << 30));


            int K = in.nextInt();
            Queue<Integer> q = new LinkedList<Integer>();
            for (int k = 0; k < K; ++k) {
                int r = in.nextInt() - 1;
                int c = in.nextInt() - 1;
                dist[r][c] = 0;
                q.offer(r);
                q.offer(c);
            }

            int[] dx = new int[]{1, -1, 0, 0};
            int[] dy = new int[]{0, 0, 1, -1};
            while (!q.isEmpty()) {
                int rr = q.poll();
                int cc = q.poll();
                for (int a = 0; a < 4; ++a) {
                    int x = dx[a] + rr;
                    int y = dy[a] + cc;
                    if (x >= 0 && x < N && y >= 0 && y < M) {
                        if (dist[x][y] > dist[rr][cc] + 1) {
                            dist[x][y] = dist[rr][cc] + 1;
                            q.offer(x);
                            q.offer(y);
                        }
                    }
                }
            }
            int max = 0;
            for (int i = 0; i < N; ++i)
                for (int j = 0; j < M; ++j)
                    max = Math.max(max, dist[i][j]);
            for (int i = 0; i < N; ++i) {
                for (int j = 0; j < M; ++j) {
                    if (max == dist[i][j]) {
                        out.println((i + 1) + "" "" + (j + 1));
                        return;
                    }
                }
            }
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",6,5
"import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.StringTokenizer;
import java.io.Writer;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author zodiacLeo
 */
public class Main
{
    public static void main(String[] args)
    {
        InputStream inputStream;
        try
        {
            inputStream = new FileInputStream(""input.txt"");
        } catch (IOException e)
        {
            throw new RuntimeException(e);
        }
        OutputStream outputStream;
        try
        {
            outputStream = new FileOutputStream(""output.txt"");
        } catch (IOException e)
        {
            throw new RuntimeException(e);
        }
        FastScanner in = new FastScanner(inputStream);
        FastPrinter out = new FastPrinter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC
    {
        public void solve(int testNumber, FastScanner in, FastPrinter out)
        {
            int n = in.nextInt();
            int m = in.nextInt();
            int p = in.nextInt();
            int[] x = new int[p];
            int[] y = new int[p];
            for (int i = 0; i < p; i++)
            {
                x[i] = in.nextInt();
                y[i] = in.nextInt();
            }

            int X = x[0];
            int Y = y[0];
            int D = -1;
            for (int dx = 1; dx <= n; dx++)
            {
                int x1 = dx;
                int y1 = 1;
                int xx = 0;
                int yy = 0;
                int minD = Integer.MAX_VALUE;
                for (int j = 0; j < p; j++)
                {
                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);
                    if (d < minD)
                    {
                        minD = d;
                        xx = x1;
                        yy = y1;
                    }
                }
                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)
                {
                    D = minD;
                    X = xx;
                    Y = yy;
                }
            }
            for (int dx = 1; dx <= n; dx++)
            {
                int x1 = dx;
                int y1 = m;
                int xx = 0;
                int yy = 0;
                int minD = Integer.MAX_VALUE;
                for (int j = 0; j < p; j++)
                {
                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);
                    if (d < minD)
                    {
                        minD = d;
                        xx = x1;
                        yy = y1;
                    }
                }
                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)
                {
                    D = minD;
                    X = xx;
                    Y = yy;
                }
            }
            for (int dy = 1; dy <= m; dy++)
            {
                int x1 = 1;
                int y1 = dy;
                int xx = 0;
                int yy = 0;
                int minD = Integer.MAX_VALUE;
                for (int j = 0; j < p; j++)
                {
                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);
                    if (d < minD)
                    {
                        minD = d;
                        xx = x1;
                        yy = y1;
                    }
                }
                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)
                {
                    D = minD;
                    X = xx;
                    Y = yy;
                }
            }
            for (int dy = 1; dy <= m; dy++)
            {
                int x1 = n;
                int y1 = dy;
                int xx = 0;
                int yy = 0;
                int minD = Integer.MAX_VALUE;
                for (int j = 0; j < p; j++)
                {
                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);
                    if (d < minD)
                    {
                        minD = d;
                        xx = x1;
                        yy = y1;
                    }
                }
                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)
                {
                    D = minD;
                    X = xx;
                    Y = yy;
                }
            }

            for (int i = 1; i <= Math.min(m, n); i++)
            {
                int x1 = i;
                int y1 = i;
                int xx = 0;
                int yy = 0;
                int minD = Integer.MAX_VALUE;
                for (int j = 0; j < p; j++)
                {
                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);
                    if (d < minD)
                    {
                        minD = d;
                        xx = x1;
                        yy = y1;
                    }
                }
                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)
                {
                    D = minD;
                    X = xx;
                    Y = yy;
                }
            }
            for (int i = 1, ii = m; i <= n && ii >= 1; i++, ii--)
            {
                int x1 = i;
                int y1 = ii;
                int xx = 0;
                int yy = 0;
                int minD = Integer.MAX_VALUE;
                for (int j = 0; j < p; j++)
                {
                    int d = Math.abs(x1 - x[j]) + Math.abs(y1 - y[j]);
                    if (d < minD)
                    {
                        minD = d;
                        xx = x1;
                        yy = y1;
                    }
                }
                if (D < minD && minD != 0 && minD != Integer.MAX_VALUE)
                {
                    D = minD;
                    X = xx;
                    Y = yy;
                }
            }
            out.println(X + "" "" + Y);
        }

    }

    static class FastScanner
    {
        public BufferedReader br;
        public StringTokenizer st;

        public FastScanner(InputStream is)
        {
            br = new BufferedReader(new InputStreamReader(is));
        }

        public FastScanner(File f)
        {
            try
            {
                br = new BufferedReader(new FileReader(f));
            } catch (FileNotFoundException e)
            {
                e.printStackTrace();
            }
        }

        public String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                String s = null;
                try
                {
                    s = br.readLine();
                } catch (IOException e)
                {
                    e.printStackTrace();
                }
                if (s == null)
                    return null;
                st = new StringTokenizer(s);
            }
            return st.nextToken();
        }

        public int nextInt()
        {
            return Integer.parseInt(next());
        }

    }

    static class FastPrinter extends PrintWriter
    {
        public FastPrinter(OutputStream out)
        {
            super(out);
        }

        public FastPrinter(Writer out)
        {
            super(out);
        }

    }
}",6,5
"import java.io.*;

import java.math.*;

import java.util.*;

import java.util.stream.*;



@SuppressWarnings(""unchecked"")

public class P35C {



  final static int SHIFT = 11;

  final static int MASK = (1 << SHIFT) - 1;

  final static int [] DX = {-1, 1,  0, 0};

  final static int [] DY = { 0, 0, -1, 1};



  public void run() throws Exception {

    int m = nextInt();

    int n = nextInt();



    boolean [][] burned = new boolean [n][m];

    List<Integer> burn = new ArrayList();

    for (int k = nextInt(); k > 0; k--) {

      int x = nextInt() - 1;

      int y = nextInt() - 1;

      burned[y][x] = true;

      burn.add((x << SHIFT) | y);

    }



    int lastXY = 0;

    List<Integer> newBurn = null;

    do {

      lastXY = burn.get(0);

      newBurn = new ArrayList();



      for (int xy : burn) {

        int x = xy >> SHIFT;

        int y = xy & MASK;



        for (int i = 0; i < 4; i++) {

          int nx = x + DX[i];

          int ny = y + DY[i];



          if ((ny >= 0) && (ny < n) && (nx >= 0) && (nx < m) && (!burned[ny][nx])) {

            burned[ny][nx] = true;

            newBurn.add((nx << SHIFT) | ny);

          }

        }

      }



      burn = newBurn;

    } while (newBurn.size() > 0);



    println(((lastXY >> SHIFT) + 1) + "" "" + ((lastXY & MASK) + 1));

  }



  public static void main(String... args) throws Exception {

    br = new BufferedReader(new InputStreamReader(new FileInputStream(""input.txt"")));

    pw = new PrintWriter(new BufferedOutputStream(new FileOutputStream(""output.txt"")));

    new P35C().run();

    br.close();

    pw.close();

    System.err.println(""\n[Time : "" + (System.currentTimeMillis() - startTime) + "" ms]"");

  }



  static long startTime = System.currentTimeMillis();

  static BufferedReader br;

  static PrintWriter pw;

  StringTokenizer stok;



  String nextToken() throws IOException {

    while (stok == null || !stok.hasMoreTokens()) {

      String s = br.readLine();

      if (s == null) { return null; }

      stok = new StringTokenizer(s);

    }

    return stok.nextToken();

  }



  void print(byte b) { print("""" + b); }

  void print(int i) { print("""" + i); }

  void print(long l) { print("""" + l); }

  void print(double d) { print("""" + d); }

  void print(char c) { print("""" + c); }

  void print(Object o) {

    if (o instanceof int[]) { print(Arrays.toString((int [])o));

    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));

    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));

    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));

    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));

    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));

    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));

    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));

    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));

    } else { print("""" + o); }

  }

  void print(String s) { pw.print(s); }

  void println() { println(""""); }

  void println(byte b) { println("""" + b); }

  void println(int i) { println("""" + i); }

  void println(long l) { println("""" + l); }

  void println(double d) { println("""" + d); }

  void println(char c) { println("""" + c); }

  void println(Object o) { print(o); println(); }

  void println(String s) { pw.println(s); }

  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }

  long nextLong() throws IOException { return Long.parseLong(nextToken()); }

  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }

  char nextChar() throws IOException { return (char) (br.read()); }

  String next() throws IOException { return nextToken(); }

  String nextLine() throws IOException { return br.readLine(); }

  int [] readInt(int size) throws IOException {

    int [] array = new int [size];

    for (int i = 0; i < size; i++) { array[i] = nextInt(); }

    return array;

  }

  long [] readLong(int size) throws IOException {

    long [] array = new long [size];

    for (int i = 0; i < size; i++) { array[i] = nextLong(); }

    return array;

  }

  double [] readDouble(int size) throws IOException {

    double [] array = new double [size];

    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }

    return array;

  }

  String [] readLines(int size) throws IOException {

    String [] array = new String [size];

    for (int i = 0; i < size; i++) { array[i] = nextLine(); }

    return array;

  }

}",6,3
"import java.io.*; 

import java.util.*;





public class C {

    private static boolean marked[][] ; 

    

    

    public static void main(String[] args) throws Exception {

//        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

//        InputStream inputStream = System.in;

//        OutputStream outputStream = System.out;

//        InputReader s = new InputReader(inputStream);

//        PrintWriter out = new PrintWriter(outputStream);

        

        

         // input.txt / output.txt

         File file = new File(""input.txt"") ; 

         Scanner s = new Scanner(file) ; 

        

        int n = s.nextInt();

        int m = s.nextInt(); 

        

        marked = new boolean [n + 1 ][m + 1] ; 

        

        int k = s.nextInt();

        

        Queue<Point> queue = new LinkedList<Point>(); 

        

        

        for(int i =0 ; i < k ; ++i){

            int tempX = s.nextInt() ;

            int tempY = s.nextInt() ; 

            marked[tempX][tempY] = true ; 

            queue.add(new Point(tempX , tempY));             

        }

        

         Point c = null ;

        

         while(!queue.isEmpty()){

             c = queue.poll() ; 

            

            if(c.x>1 && !marked[c.x-1][c.y]){

                marked[c.x -1 ][c.y] = true ; 

                queue.add(new Point(c.x-1,c.y));

            }

            

            if(c.y>1 && !marked[c.x][c.y-1]){

                marked[c.x][c.y-1] = true ; 

                queue.add(new Point(c.x,c.y-1));

            }

            

            if(c.x < n  && !marked[c.x+1][c.y]){

                marked[c.x + 1 ][c.y] = true ; 

                queue.add(new Point(c.x + 1,c.y));

            }

            

            if(c.y < m && !marked[c.x][c.y+1]){

                marked[c.x][c.y+1] = true ; 

                queue.add(new Point(c.x,c.y+1));

            }

        }

        PrintWriter out = new PrintWriter(new File(""output.txt""));

        out.println(c.x+"" ""+c.y); 

        out.close();



    }

    

    static class Point {

        int x ; 

        int y ; 

        public Point(int x  ,int y ){

            this.x = x  ; 

            this.y = y ;

        }

    }

}

    

    

    

    

    

    

    

    





class InputReader {



    public BufferedReader reader;

    public StringTokenizer tokenizer;



    public InputReader(InputStream stream) {

        reader = new BufferedReader(new InputStreamReader(stream), 32768);

        tokenizer = null;

    }



    public String next() {

        while (tokenizer == null || !tokenizer.hasMoreTokens()) {

            try {

                tokenizer = new StringTokenizer(reader.readLine());

            } catch (IOException e) {

                throw new RuntimeException(e);

            }

        }

        return tokenizer.nextToken();

    }



    public int nextInt() {

        return Integer.parseInt(next());

    }



    public long nextLong() {

        return Long.parseLong(next());

    }



    public double nextDouble() {

        return Double.parseDouble(next());

    }

}",6,3
"import java.io.*;
import java.util.*;

public class FireAgain {

    public static void main(String[] args) throws IOException {
		System.setIn(new FileInputStream(""input.txt""));
		System.setOut(new PrintStream(""output.txt""));
        BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		String s[] = r.readLine().split(""\\s+"");
		int n = Integer.parseInt(s[0]);
		int m = Integer.parseInt(s[1]);
		int k = Integer.parseInt(r.readLine());
		int[][] a = new int[n][m];
		for(int i = 0; i < n; i++) {
			for(int j = 0; j < m; j++)
				a[i][j] = Integer.MAX_VALUE;
		}
		assert k >= 1 && k < n * m;
		int max = 0;
		StringTokenizer st = new StringTokenizer(r.readLine());
		assert st.countTokens() == k;
		for(; k > 0; k--) {
			int x = Integer.parseInt(st.nextToken()) - 1;
			int y = Integer.parseInt(st.nextToken()) - 1;
			assert x >= 1 && x <= n && y >= 1 && y <= n;

			for(int i = 0; i < n; i++) {
				for(int j = 0; j < m; j++) {
					int d = Math.abs(i - x) + Math.abs(j - y);
					if(a[i][j] > d)
						a[i][j] = d;
					if(k == 1 && a[i][j] > max)
						max = a[i][j];
				}
			}
		}

		for(int i = 0; i < n; i++) {
			for(int j = 0; j < m; j++) {
				if(a[i][j] == max) {
					System.out.println((i + 1) + "" "" + (j + 1));
					return;
				}
			}
		}
    }

}
",6,6
"import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {
	public static void main(String args[]) throws IOException {
		File f = new File(""input.txt"");
		Scanner sc = new Scanner(f);
		BufferedWriter bw = new BufferedWriter(new FileWriter(new File(""output.txt"")));
		int n = sc.nextInt();
		int m = sc.nextInt();
		boolean[][] grid = new boolean[n][m];
		for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) 
			grid[i][j] = false;
		Queue<Pair> q = new LinkedList<>();
		int cnt = sc.nextInt();
		for (int i = 0; i < cnt; i++) {
			int x = sc.nextInt();
			int y = sc.nextInt();
			x--;
			y--;
			grid[x][y] = true;
			q.add(new Pair(x, y));
		}
		Pair last = new Pair(-1, -1);
		while (!q.isEmpty()) {
			Pair current = q.poll();
			last = current;
			for (int i = -1; i <= 1; i++) {
				for (int j = -1; j <= 1; j++) {
					if (i != 0 && j != 0) continue;
					if (inside(current.x + i, current.y + j, n, m) &&
							!grid[current.x + i][current.y + j]) {
						grid[current.x + i][current.y + j] = true;
						q.add(new Pair(current.x + i, current.y + j));
						//bw.append((current.x + i) + "" "" + (current.y + j) + ""\n"");
					}
				}
			}
		}
		
		bw.append((last.x + 1) + "" "" + (last.y + 1) + ""\n"");
		bw.flush();
		bw.close();
		
		sc.close();
	}
	static class Pair {
		int x;
		int y;
		Pair(int x, int y) {
			this.x = x;
			this.y = y;
		}
	}
	private static boolean inside(int a, int b, int n, int m) {
		return (a >= 0 && a < n && b >= 0 && b < m);
	}
}
",6,5
"import java.awt.Point;

import java.util.LinkedList;

import java.util.Queue;

import java.io.BufferedReader;

import java.io.FileNotFoundException;

import java.io.FileReader;

import java.io.FileWriter;

import java.io.IOException;

import java.io.InputStream;

import java.io.InputStreamReader;

import java.io.PrintWriter;

import java.util.LinkedList;

import java.util.Queue;

import java.util.StringTokenizer;



public class Main {

	



	public static void main(String[] args) throws IOException{

		// TODO Auto-generated method stub

		Scanner scan = new Scanner(""input.txt"");

		PrintWriter out = new PrintWriter(new FileWriter(""output.txt""));

		

		int n,m;

		n = scan.nextInt();

		m = scan.nextInt();



		boolean visited[][] = new boolean[n][m];

    

		int numOfStartingPoints;

		numOfStartingPoints = scan.nextInt();

		    		

		int resX = 0, resY = 0;

		

		Queue<Point> que = new LinkedList<Point>();

		for (int i = 0; i < numOfStartingPoints; i++) {

			int x = scan.nextInt() - 1;

			int y = scan.nextInt() - 1;

			que.add(new Point(x, y));

			visited[x][y] = true;

		}

		

		while (true) {

			Point current = que.poll();



			if (current == null) {

				break;

			} else {

				resX = current.x;

				resY = current.y;

				

				if (current.x + 1 < n && !visited[current.x + 1][current.y])

				{

					que.add(new Point(current.x + 1, current.y));

					visited[current.x + 1][current.y] = true;





				}

				if (current.y + 1 < m && !visited[current.x][current.y + 1])

				{

					que.add(new Point(current.x, current.y + 1));

					visited[current.x][current.y + 1] = true;

		



				}

				if (current.x - 1 >= 0 && !visited[current.x - 1][current.y])

				{

					que.add(new Point(current.x - 1, current.y));

					visited[current.x - 1][current.y] = true;

				

				}

				if (current.y - 1 >= 0 && !visited[current.x][current.y - 1])

				{

					que.add(new Point(current.x, current.y - 1));

					visited[current.x][current.y - 1] = true;

				

				}



				

			}

		}

		

		

		out.printf(""%d %d\n"", ++resX, ++resY);

		out.close();

		    

	}

	static class Scanner 

	{

		StringTokenizer st;

		BufferedReader br;



		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

		

		public Scanner(String s) throws FileNotFoundException{	br = new BufferedReader(new FileReader(s));}



		public String next() throws IOException 

		{

			while (st == null || !st.hasMoreTokens()) 

				st = new StringTokenizer(br.readLine());

			return st.nextToken();

		}



		public int nextInt() throws IOException {return Integer.parseInt(next());}



		public long nextLong() throws IOException {return Long.parseLong(next());}



		public String nextLine() throws IOException {return br.readLine();}



		public double nextDouble() throws IOException { return Double.parseDouble(next()); }



		public boolean ready() throws IOException {return br.ready();} 

	}

}



",6,3
"import java.util.*;

public class cf112e {
	static int n,m,s;
	static int[][][] memo;
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		n = in.nextInt();
		m = in.nextInt();
		if(n > m) {
			int tmp = n;
			n = m;
			m = tmp;
		}
		s = (1<<n);
		memo = new int[s][s][m];
		for(int i=0; i<s; i++)
			for(int j=0; j<s; j++)
				Arrays.fill(memo[i][j], -1);
		int ret = go(0,0,0);
		System.out.println(n*m - ret);
	}
	static int go(int last, int trans, int r) {
		if(r==m) {
			if(trans == 0) return 0;
			return 100;
		}
		if(memo[last][trans][r] != -1) return memo[last][trans][r];
		int best = 100;
		for(int crnt = 0; crnt < s; crnt++) {
			if((trans & ~crnt) != 0) continue; //certain ones have to be here
			for(int pass = 0; pass < s; pass++) {
				int tmp = ((1<<n)-1) & ~last;	//move back the ones you can
				if((pass & ~tmp) != 0) continue; //certain ones have to move on
				tmp = tmp & ~pass; //find which ones stay
				boolean fail = false;
				for(int k=0; k<n; k++) //make sure that the ones that stay
					if(isSet(tmp,k) && !(isSet(crnt,k-1) || isSet(crnt,k) || isSet(crnt,k+1)))
						fail = true;
				if(fail) continue;
				best = Math.min(best, Integer.bitCount(crnt) + go(crnt,pass,r+1));
			}
		}
		return memo[last][trans][r] = best;
	}
	static boolean isSet(int x, int p) {
		if(p < 0 || p >= n) return false;
		return (x & (1<<p)) != 0;
	}
}
",7,5
"
import java.util.*;


public class E
{
   public static void main(String[] args)
   {
      new E(new Scanner(System.in));
   }

   int N, M;
   int[][][] memo;

   int go(int i, int j, int mask)
   {
      if (i == N)
         return go(0, j+1, mask);
      if (j == M)
      {
         int mm = mask%(1<<N);
         //System.out.println(Integer.toBinaryString(mm)+"" ""+Integer.toBinaryString(mask));
         if (mm != ((1<<N)-1))
            return N*M;
         return 0;
      }

      if (memo[i][j][mask] != -1)
         return memo[i][j][mask];

      // Now place a spider cluster here
      int nMask = mask;
      int prevMask = 0;
      if (i > 0)
         prevMask = 1 << (N-1);
      int nextMask = 0;
      if (i < (N-1))
         nextMask = 1 << (N+1);
      int curMask = 1 << N;
      int nextRowMask = 1 << (N+N);
      nMask = nMask|prevMask|nextMask|curMask|nextRowMask;
      nMask = nMask/2;
      int res = 1+go(i+1, j, nMask);
      
      int pr = mask%2;
      if (pr == 1)
      {
         // We have the option to skip here
         int rr = go(i+1, j, mask/2);
         if (rr < res)
            res = rr;
      }

   
      //System.out.printf(""%d %d %s = %d%n"", i, j, Integer.toBinaryString(mask), res);
      memo[i][j][mask] = res;
      return res;
   }

   public E(Scanner in)
   {
      int[] vals = new int[2];
      vals[0] = in.nextInt();
      vals[1] = in.nextInt();
      Arrays.sort(vals);

      N = vals[0];
      M = vals[1];
      memo = new int[N][M][1<<(N+N+1)];
      fill3(memo, -1);
      
      int r1 = go(0, 0, (1<<N)-1);
      int res = N*M-r1;
      System.out.printf(""%d%n"", res);
   
   }

   void fill3(int[][][] vvv, int val)
   {
      for (int[][] vv : vvv)
         for (int[] v : vv)
            Arrays.fill(v, val);
   }
}
",7,1
"import java.io.*;
import java.util.*;

public class E
{
	private static final int oo = 1000000000;
	public static void main(String[] args) throws Exception
	{
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int m = in.nextInt();
		if(n > m)
		{
			int t = n;
			n = m;
			m = t;
		}

		int [][] curr = new int[1<<n][1<<n];
		fill(curr, oo);
		Arrays.fill(curr[0], 0);

		for(int j = 0 ; j < m ; j++)
		{
			int [][] next = new int[1<<n][1<<n];
			fill(next, oo);
			for(int c0 = 0 ; c0 < 1<<n ; c0++)
				for(int c1 = 0 ; c1 < 1<<n ; c1++)
					if(curr[c0][c1] != oo)
						for(int c2 = 0 ; c2 < (j == m-1 ? 1 : 1<<n) ; c2++)
						{
							int done = 0;
							for(int i = 0 ; i < n ; i++)
								if(((1<<i) & c1) == 0)
								{
									int up = i-1;
									int down = i+1;
									if(up >= 0 && ((1<<up) & c1) != 0)
										done |= 1<<i;
									if(down < n && ((1<<down) & c1) != 0)
										done |= 1<<i;
									if(((1<<i) & c0) != 0)
										done |= 1<<i;
									if(((1<<i) & c2) != 0)
										done |= 1<<i;
								}

							next[c1][c2] = Math.min(next[c1][c2], curr[c0][c1] + n - Integer.bitCount(done));

						}
			curr = next;
		}

		int res = oo;
		for(int i = 0 ; i < 1<<n ; i++)
			for(int j = 0 ; j < 1<<n ; j++)
				res = Math.min(res, curr[i][j]);

		System.out.println(n*m - res);
	}

	private static void fill(int[][] array, int val)
	{
		for(int [] fill : array)
			Arrays.fill(fill, val);
	}
}",7,7
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

/**
 * Author -
 * User: kansal
 * Date: 9/3/11
 * Time: 5:28 PM
 */
public class CF85C {
    public static void main(String[] args) {
        reader = new BufferedReader(new InputStreamReader(System.in));

        int height = nextInt(), width = nextInt();
        if (width > height) {
            int t = width;
            width = height;
            height = t;
        }

        final int INF = height * width + 10;
        final int ALL_BITS = (1 << width)  - 1;
        int[][][] dp = new int[height + 1][1 << width][1 << width];
        for (int[][] ints : dp) {
            for (int[] anInt : ints) {
                Arrays.fill(anInt, INF);
            }
        }

        dp[0][0][0] = 0;
        for(int r = 0; r < height; ++r) {
            for(int uncovered = 0; uncovered < (1 << width); ++uncovered) {
                for(int mask = 0; mask < (1 << width); ++mask) {
                    if (dp[r][uncovered][mask] == INF) {
                        continue;
                    }
                    for(int curMask = uncovered; curMask < (1 << width); curMask = (curMask + 1) | uncovered) {
                        int curCovered = (mask | curMask);
                        curCovered |= (curMask >> 1);
                        curCovered |= (ALL_BITS & (curMask << 1));

                        int curUncovered = ALL_BITS ^ curCovered;
                        dp[r+1][curUncovered][curMask] = Math.min(dp[r+1][curUncovered][curMask], dp[r][uncovered][mask] + Integer.bitCount(curMask));
                    }
                }
            }
        }

        int res = INF;
        for(int x: dp[height][0]) res = Math.min(res, x);

        System.out.println(height * width - res);
    }

    private static boolean hasBit(int mask, int bit) {
        return (((mask >> bit) & 1) == 1);
    }

    public static BufferedReader reader;

    public static StringTokenizer tokenizer = null;

    static String nextToken() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    static public int nextInt() {
        return Integer.parseInt(nextToken());
    }

    static public long nextLong() {
        return Long.parseLong(nextToken());
    }

    static public String next() {
        return nextToken();
    }

    static public String nextLine() {
        try {
            return reader.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

}
",7,7
"/*(c) gorlum0 [at] gmail.com*/
import java.io.*;
import java.util.*;
import java.math.*;

public class E
{
    int bitcount(int x) {
        int c = 0;
        for ( ; x != 0; c++)
            x &= x-1;
        return c;
    }

    boolean bit(int x, int i)
    {
        if (i < 0) return false;
        return (x>>i & 1) == 1 ? true : false;
    }

    int solve(int n, int m)
    {
        if (m > n) { int x = m; m = n; n = x; }
        int maxmask = 1<<m;

        int[][][] dp = new int[n+1][maxmask][maxmask];
        for (int i = 0; i <= n; i++)
            for (int j = 0; j < maxmask; j++)
                for (int k = 0; k < maxmask; k++)
                    dp[i][j][k] = inf;
        for (int i = 0; i < maxmask; i++)
            dp[0][0][i] = bitcount(i);

        for (int i = 1; i <= n; i++)
            for (int b = 0; b < maxmask; b++)
                for (int c = 0; c < maxmask; c++)
                    for (int a = 0; a < maxmask; a++) {
                        boolean nospider = false;
                        for (int j = 0; j < m; j++)
                            if (not(bit(a,j) || bit(c,j) || bit(b,j-1) || bit(b,j) || bit(b,j+1))) {
                                nospider = true;
                                break;
                            }
                        if (nospider) continue;

                        dp[i][b][c] = Math.min(dp[i][b][c], dp[i-1][a][b] + bitcount(c));
                    }
        int res = inf;
        for (int b = 0; b < maxmask; b++)
            res = Math.min(res, dp[n][b][0]);
        return n*m - res;
    }

    void main() throws IOException {
        int n;
        while ((n = nextInt()) != EOF) {
            int m = nextInt();
            out.println(solve(n, m));
        }
    }

    public static void main(String[] args) {
        new E().run();
    }

    // ======================================================================

    int inf = (int) 1e9;
    final int EOF = -1;

    boolean not(boolean p) { return !p; }

    int sqr(int x) { return x*x; }
    long sqr(long x) { return x*x; }
    double sqr(double x) { return x*x; }

    BufferedReader fin;
    StringTokenizer st;
    PrintWriter out;

    public void run() {
        try {
            fin = new BufferedReader(new InputStreamReader(System.in));
            st = null;
            out = new PrintWriter(System.out);
            main();
            fin.close();
            out.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    String nextToken() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            String line = fin.readLine();
            if (line == null) return ""-1"";
            else st = new StringTokenizer(line);
        }
        return st.nextToken();
    }
}
",7,5
"import java.io.*;
import java.util.*;

public class E
{
    private static final int oo = 1000000000;
    public static void main(String[] args) throws Exception
    {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        if(n > m)
        {
            int t = n;
            n = m;
            m = t;
        }

        int [][] curr = new int[1<<n][1<<n];
        fill(curr, oo);
        Arrays.fill(curr[0], 0);

        for(int j = 0 ; j < m ; j++)
        {
            int [][] next = new int[1<<n][1<<n];
            fill(next, oo);
            for(int c0 = 0 ; c0 < 1<<n ; c0++)
                for(int c1 = 0 ; c1 < 1<<n ; c1++)
                    if(curr[c0][c1] != oo)
                        for(int c2 = 0 ; c2 < (j == m-1 ? 1 : 1<<n) ; c2++)
                        {
                            int all = (1<<n) - 1;
                            int done = (all&(c1>>1)) | (all&(c1<<1)) | c0 | c2;
                            done &= (all^c1);

                            next[c1][c2] = Math.min(next[c1][c2], curr[c0][c1] + n - Integer.bitCount(done));

                        }
            curr = next;
        }

        int res = oo;
        for(int i = 0 ; i < 1<<n ; i++)
            for(int j = 0 ; j < 1<<n ; j++)
                res = Math.min(res, curr[i][j]);

        System.out.println(n*m - res);
    }

    private static void fill(int[][] array, int val)
    {
        for(int [] fill : array)
            Arrays.fill(fill, val);
    }
}",7,7
"import java.io.*;
import java.util.*;

public class Sol122A {

	BufferedReader in;
	StringTokenizer st;
	PrintWriter out;

	String next() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(in.readLine());
		return st.nextToken();
	}

	int nextInt() throws Exception {
		return Integer.parseInt(next());
	}

	long nextLong() throws Exception {
		return Long.parseLong(next());
	}

	double nextDouble() throws Exception {
		return Double.parseDouble(next());
	}

	void solve() throws Exception {
		long x = nextLong();
		out.println((x % 4) * (x % 7) * (x % 74) * (x % 47) * (x % 44) * (x % 77) * (x % 444) * (x % 447) * (x % 474) * (x % 477) * (x % 744) * (x % 747) * (x % 774) * (x % 777) == 0 ? ""YES"" : ""NO"");
	}

	void run() {
		try {
			Locale.setDefault(Locale.US);
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(new OutputStreamWriter(System.out));
			solve();
			out.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	public static void main(String[] args) {
		new Sol122A().run();
	}

}
",1,1
"import java.util.*;
public class Ex{
	public static void main(String[] args) {
       Scanner sc=new Scanner(System.in);       
       int n=sc.nextInt();
       int k=n;
       int r=k;
       int c=0;
       while(n>0){
       	 int rem=n%10;
       	 if(rem==4 || rem==7){
       	 	c++;
       	 	n/=10;
       	 }
       	 else{
       	 	break;
       	 }
       }
       int co=0;
       while(k>0){
       	k/=10;
       	co++;
       }
       if(c==co){
       	System.out.println(""YES"");
       }
       else if(r%4==0 || r%7==0 || r%47==0 || r%74==0 || r%477==0 || r%774==0 || r%747==0 || r%447==0 || r%474==0 || r%744==0){
       	System.out.println(""YES"");
       }
       else{
       	System.out.println(""NO"");
       }
	}
}",1,1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;
import java.util.StringTokenizer;

public class CF {
        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st=null;
        private void  solution() throws IOException{
   int n=nextInt();
   if((n % 4==0 && n>=4)||(n % 7==0 && n>=7) || (n % 44==0 && n>=44) || (n % 47==0 && n>=47) || (n % 77==0 && n>=77) || (n % 74==0 && n>=74)
   || (n % 444==0 && n>=444) || (n % 447==0 && n>=447) || (n % 474==0 && n>=74) || (n % 477==0 && n>=477) || (n % 744==0 && n>=744)
   || (n % 747==0 && n>=747) || (n % 777==0 && n>=777)){
           System.out.println(""YES"");
   }else{
                System.out.println(""NO"");}
        }
        String nextToken()throws IOException {
                if(st==null || !st.hasMoreTokens()){
                        st = new StringTokenizer(bf.readLine());
                }
                return st.nextToken();
        }
        int nextInt() throws IOException {
                return Integer.parseInt(nextToken());
        }

        long nextLong() throws IOException {
                return Long.parseLong(nextToken());
        }

        double nextDouble() throws IOException {
                return Double.parseDouble(nextToken());
        }

        public static void main(String args[]) throws IOException {
                new CF().solution();
        }
}",1,1
"import java.io.PrintWriter;
import java.util.Scanner;

public class Solution {
    private static int n;
    private static PrintWriter writer;
    private static int maxstep;
    
    private static void g(int src, int step) {
        if (step != 0 && n % src == 0) {
            writer.print(""YES"");
            writer.close();
            System.exit(0);
        }
        
        if (step == maxstep) return;
        
        int p = (int)Math.pow(10, step);
        
        g(src + 4 * p, step + 1);
        g(src + 7 * p, step + 1);
    }
    
    public static void main(String[] args) throws Exception {        
        //Scanner reader = new Scanner(new File(""input.txt""));
        //PrintWriter writer = new PrintWriter(""output.txt"");
        Scanner reader = new Scanner(System.in);
        writer = new PrintWriter(System.out);
        
        n = reader.nextInt();
        maxstep = String.valueOf(n).length() + 1;
        
        g(0, 0);
        
        writer.print(""NO"");
        writer.close();
    }
}",1,1
"import java.util.*;
public class D
{
 public static void main(String args[])
  {
   int n;
   Scanner in = new Scanner (System.in);
   n= in.nextInt();
   if (n%4==0 || n%7==0 || n%44==0 || n%47==0 || n%444==0 || n%447==0 ||
       n%474==0 || n%477==0 || n%744==0 || n%747==0 || n%774==0 || n%777==0)
       System.out.println(""YES""); else System.out.println(""NO"");
  }
}
		 		 	 	  	 			 	  	 	 	",1,1
"import java.util.*;
import java.io.*;

public class A {

    ArrayList<Integer> list = new ArrayList<Integer>();
    
    
    boolean valid(int n) {
        Queue<Integer> q = new LinkedList<Integer>();
        q.add(4);
        q.add(7);
        int crnt;
        while(!q.isEmpty()) {
            crnt = q.poll();
            if(n%crnt == 0) return true;
            if ( crnt*10 + 4 <= 1000 ) q.add(crnt*10 + 4);
            if ( crnt*10 + 7 <= 1000 ) q.add(crnt*10 + 7);
        }
        return false;
    }
    
    void dfs(int n){
        if(n>1000)return;
        if(n!=0)list.add(n);
        n = n*10;
        dfs(n+4);
        dfs(n+7);
    }

    void run() {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        if (valid(n)) {
            System.out.println(""YES"");
        } else {
            System.out.println(""NO"");
        }
    }

    public static void main(String[] args) {
        new A().run();
    }

}
",1,1
"import java.util.*;
public class x
{
    public static void main(String args[])
    {
        Scanner obj=new Scanner(System.in);
        int n;
        String d=""0"";
        n=obj.nextInt();
        if(n%4==0 || n%7==0 || n%47==0 || n%74==0 || n%447==0 || n%474==0 || n%747==0)
        d=""YES"";
        else if(n%444==0 || n%477==0 || n%744==0 || n%774==0 || n%777==0)
        d=""YES"";
        else
        d=""NO"";
        System.out.print(d);
    }
}",1,1
"//package arbuz;

import java.util.Scanner;

public class Arbuz {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if (n % 4 == 0 || n % 7 == 0 || n % 47 == 0 || n % 74 == 0 || n % 444 == 0 || n % 447 == 0 || n % 474 == 0 || n % 477 == 0) {
            System.out.println(""YES"");
        } else {
            System.out.println(""NO"");
        }
    }
}
",1,1
"import java.io.PrintWriter;
import java.util.Scanner;

public class n122A {
    Scanner in;
    PrintWriter out;

    void solve() {
        int n = in.nextInt();
        boolean good = false;
        if (n % 4 == 0) {
            good = true;
        }
        if (n % 7 == 0) {
            good = true;
        }
        if (n % 44 == 0) {
            good = true;
        }
        if (n % 47 == 0) {
            good = true;
        }
        if (n % 74 == 0) {
            good = true;
        }
        if (n % 77 == 0) {
            good = true;
        }
        if (n % 444 == 0) {
            good = true;
        }
        if (n % 447 == 0) {
            good = true;
        }
        if (n % 474 == 0) {
            good = true;
        }
        if (n % 477 == 0) {
            good = true;
        }
        if (n % 744 == 0) {
            good = true;
        }
        if (n % 747 == 0) {
            good = true;
        }
        if (n % 774 == 0) {
            good = true;
        }
        if (n % 777 == 0) {
            good = true;
        }
        if (good) {
            out.println(""YES"");
        } else {
            out.println(""NO"");
        }
    }

    void run() {
        in = new Scanner(System.in);
        out = new PrintWriter(System.out);
        try {
            solve();
        } finally {
            out.close();
        }
    }

    public static void main(String[] args) {
        new n122A().run();

    }

}
",1,1
"import java.util.Scanner;
public class Main{
  public static void main(String[] args){
    Scanner scan = new Scanner(System.in);
    int n = scan.nextInt();
    if (n % 4 == 0 || n % 7 == 0 || n % 47 == 0 || n % 77 == 0 || n % 74 == 0 || n % 447 == 0 || n % 474 == 0 || n % 477 == 0 || n % 747 == 0 || n % 774 == 0 || n % 777 == 0)
      System.out.println(""YES"");
    else
      System.out.println(""NO"");
  }
}",1,1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class A_122 {
public static void main(String[] args) throws NumberFormatException, IOException {
	BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
	int n = Integer.parseInt(bf.readLine());
	  System.out.println((n%4==0||n%7==0||n%47==0||n%74==0||n%447==0||n%474==0||n%477==0||n%744==0||n%747==0||n%774==0)?""YES"":""NO"");
}
}
",1,1
"
import java.util.Scanner;

public class three {
    static boolean check;

    public static void main(String[] args) {
        check = true;
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        String s = n + """";
        recurse(n, s.length(), ""4"");
        if (!check)
            System.out.println(""YES"");
        else {
            recurse(n, s.length(), ""7"");
            if (!check)
                System.out.println(""YES"");
            else
                System.out.println(""NO"");
        }
    }

    private static void recurse(int n, int length, String string) {
        int k = Integer.parseInt(string);
        if (n % k == 0) {
            check = false;
        } else if (string.length() <= length && check) {
            recurse(n, length, string + ""4"");
            recurse(n, length, string + ""7"");
        }

    }
}",1,1
"import java.util.Scanner;

/**
 * <a href=""XXXX""/>
 */
public class Problem122A {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        if (checkDivisible(s)) {
            System.out.println(""YES"");
        } else {
            System.out.println(""NO"");
        }
    }

    private static boolean checkDivisible(String a) {
        int num = Integer.parseInt(a);
        if (num % 4 == 0 || num % 7 == 0 || num % 47 == 0) {
            return true;
        }
        a = a.replace(""4"", """");
        a = a.replace(""7"", """");
        if (a.length() == 0) {
            return true;
        }
        return false;
    }
}
",1,1
"import java.util.*;
public class Lucky {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in = new Scanner(System.in);

		int n = in.nextInt();

		if(n%4==0 || n%7==0 || n%47==0 || n%74==0 || n%474==0 || n%447==0 || n%774==0 || n%747==0 || n%477==0 || n%744==0)System.out.println(""YES"");
		else System.out.println(""NO"");
	}

}
",1,1
"import java.util.*;
public class A122
{
    public static void main(String aa[])
    {
        Scanner ob=new Scanner(System.in);
        int n;
        
        n=ob.nextInt();
        if(n%4==0||n%7==0||n%44==0||n%47==0||n%444==0||n%447==0||n%474==0||n%477==0||n%744==0||n%747==0||n%774==0||n%777==0)
        System.out.println(""YES"");
        else
        System.out.println(""NO"");
    }
}",1,1
"import java.util.*;
import java.io.*;

public class luckydivision {
	public static int i(String s){
		return Integer.parseInt(s);
	}
	public static boolean solve(String k, int n){
		int temp = i(k);
		if(temp > n){
			return false;
		}
		if(n % temp == 0)
			return true;
		if(solve(k + ""7"", n))
			return true;

		return solve(k + ""4"", n);
	}
	public static void main(String args[]) throws Exception {
		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		int n = i(r.readLine());
		boolean i = solve(""7"", n);
		boolean j = solve(""4"", n);
		if(i || j){
			System.out.println(""YES"");
		} else {
			System.out.println(""NO"");
		}
	}
}",1,1
"import java.io.*;
import java.util.*;

public class Test{
    public static void main(String[] args) {
        Scanner in= new Scanner(System.in);
        int n=in.nextInt();
        if(n%7==0 || n%4==0 || n%47==0 || n%74==0 || n%447==0 || n%474==0 || n%477==0 || n%747==0 || n%774==0){
            System.out.println(""YES"");
        }else
            System.out.println(""NO"");
        
    }
}

",1,1
"import java.io.*;
import java.util.*;

public class Main {
    StreamTokenizer in;
    BufferedReader inb;
    PrintWriter out;

    public static void main(String[] args) throws Exception {
        new Main().run();
    }

    public void run() throws Exception {
        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(
                System.in)));
        inb = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(new OutputStreamWriter(System.out));
        solve();
        out.flush();
    }

    public int nextInt() throws Exception {
        in.nextToken();
        return (int) in.nval;
    }

    public int parseInt() throws Exception {
        return Integer.parseInt(inb.readLine());
    }

    public String nextLine() throws Exception {
        return inb.readLine();
    }

    
    public void solve() throws Exception {
        int n = nextInt();
        if ((n%4==0)||(n%44==0)||(n%47==0)||(n%74==0)
                ||(n%744==0)||(n%747==0)||(n%774==0)||(n%777==0)
                ||(n%7==0)||(n%444==0)||(n%447==0)||(n%474==0)||(n%477==0)||(n%77==0))
        {
            out.print(""YES"");
        }
        else
        {
            out.print(""NO"");
        }
    }

}
",1,1
"
import java.io.*;
import java.util.*;


public class LuckyDivision
{
   public LuckyDivision(Scanner in)
   {
      int   n;

      n = in.nextInt();

      if ( (n % 4 == 0) ||
           (n % 7 == 0) ||
           (n % 44 == 0) ||
           (n % 47 == 0) ||
           (n % 74 == 0) ||
           (n % 77 == 0) ||
           (n % 444 == 0) ||
           (n % 447 == 0) ||
           (n % 474 == 0) ||
           (n % 477 == 0) ||
           (n % 744 == 0) ||
           (n % 747 == 0) ||
           (n % 774 == 0) ||
           (n % 777 == 0) )
         System.out.printf(""YES%n"");
      else
         System.out.printf(""NO%n"");
   }


   public static void main(String[] args)
   {
      new LuckyDivision(new Scanner(System.in));
   }
}

",1,1
"import java.util.Scanner;

public class Division {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int l = sc.nextInt();
		String c = String.valueOf(l);
		if (String.valueOf(c).contains(""0"") || String.valueOf(c).contains(""1"")
				|| String.valueOf(c).contains(""2"")
				|| String.valueOf(c).contains(""3"")
				|| String.valueOf(c).contains(""5"")
				|| String.valueOf(c).contains(""6"")
				|| String.valueOf(c).contains(""8"")
				|| String.valueOf(c).contains(""9""))
			if (l % 777 == 0 || l % 774 == 0 || l % 747 == 0 || l % 744 == 0
					|| l % 477 == 0 || l % 474 == 0 || l % 447 == 0
					|| l % 444 == 0 || l % 77 == 0 || l % 74 == 0
					|| l % 47 == 0 || l % 44 == 0 || l % 7 == 0 || l % 4 == 0)
				System.out.println(""YES"");
			else
				System.out.println(""NO"");
		else
			System.out.println(""YES"");
	}

}
",1,1
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.LinkedList;
public class LuckyNumbers {

    public static void main(String[] args)throws IOException
    {
        BufferedReader scan=new BufferedReader(new InputStreamReader(System.in));
        short num=Short.parseShort(scan.readLine());
        if(funcion(num))
        {
            System.out.println(""YES"");
        }
        else
            System.out.println(""NO"");
    }
    public static boolean funcion(short num)
    {
        LinkedList<Short>queue=new LinkedList<Short>();
        queue.offer((short) 4);
        queue.offer((short) 44);
        queue.offer((short) 444);
        queue.offer((short) 47);
        queue.offer((short) 477);
        queue.offer((short) 7);
        queue.offer((short) 77);
        queue.offer((short) 777);
        queue.offer((short) 74);
        queue.offer((short) 744);
        while(queue.peek()!=null)
        {
            if(num%queue.poll()==0)
            {
                return true;
            }
        }
        return false;

    }
}
",1,1
"import java.util.Scanner;
public class LuckyDivison 
{
    public static void main(String[] args)
    {
        Scanner in = new Scanner(System.in);
        int inp = in.nextInt();
        if(inp%4==0||inp%7==0||inp%47==0||inp%74==0||inp%447==0||inp%474==0||inp%477==0||inp%747==0||inp%774==0||inp%777==0)
        {
          System.out.println(""YES"");  
        }
        else System.out.println(""NO"");
          
        
    }
}
",1,1
"import java.util.Scanner;

public class HelloWorld
{
    public static void main (String args [])
    {
        Scanner read = new Scanner(System.in);
        int n = read.nextInt();
        int n1 = n; boolean q = true;
        while (n1 > 0)
        {
            if (n % n1 == 0)
            {
                if (check(n1))
                {
                    System.out.print(""YES"");
                    q = false;
                    break;
                }   
            }
            n1--;
        }
        if (q) System.out.print(""NO"");
        
    }
    public static boolean check (int n)
    {
        int n1 = n;
        while (n1 != 0)
        {
            if (n1 % 10 != 4 && n1 % 10 != 7) return false;
            n1 /= 10;
        }
        return true;
    }

}

",1,1
"import java.util.Scanner;
import java.util.StringTokenizer;

/**
 * Created with IntelliJ IDEA.
 * User: Ð¡Ð°ÑˆÐ°
 * Date: 08.08.12
 * Time: 14:12
 */
public class LuckyDivision {

    public final String check (String s) {
        String result = ""NO"";
        StringTokenizer stringTokenizer = new StringTokenizer(s, ""47"");
        if(!stringTokenizer.hasMoreTokens()) return ""YES"";
        int S = Integer.parseInt(s);
        generateSimpleAndDivide(S, 4, 4, 7);
        generateSimpleAndDivide(S, 7, 4, 7);
        if(lucky) return ""YES"";
        return result;
    }
    public static final void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(new LuckyDivision().check(scanner.next()));
    }

    public void generateSimpleAndDivide(int divided, int n, int n1, int n2) {
        if(lucky || n >= divided) return;
        if(divided % n == 0) lucky = true;
        generateSimpleAndDivide(divided, Integer.parseInt(n + """" + n1), n1, n2);
        generateSimpleAndDivide(divided, Integer.parseInt(n + """" + n2), n1, n2);
    }
    private boolean lucky = false;
}
",1,1
"import java.io.PrintWriter;
import java.util.Scanner;
import java.util.TreeSet;

public class E {
    static Scanner in; static int next() throws Exception {return in.nextInt();};
//	static StreamTokenizer in; static int next() throws Exception {in.nextToken(); return (int) in.nval;}
//	static BufferedReader in;
    static PrintWriter out;

    public static void main(String[] args) throws Exception {
        in = new Scanner(System.in);
//		in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
//		in = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);

        int n = next();

        if (n%4 == 0||n%7 == 0||n%44 == 0||n%47 == 0||n%74 == 0||n%77 == 0||n%444 == 0||n%447 == 0||n%474 == 0||n%744 == 0||n%774 == 0||n%747 == 0||n%477 == 0||n%777==0) out.println(""YES"");
        else out.println(""NO"");

        out.println();
        out.close();
    }
}",1,1
"import java.util.Scanner;

public class A122 {
	public static void main(String[] args) {

		Scanner in = new Scanner(System.in);

		int n = in.nextInt();

		if (n % 4 == 0 || n % 7 == 0 || n % 44 == 0 || n % 47 == 0
				|| n % 74 == 0 || n % 77 == 0 || n % 444 == 0 || n % 447 == 0
				|| n % 474 == 0 || n % 477 == 0 || n % 744 == 0 || n % 747 == 0
				|| n % 774 == 0 || n % 777 == 0)
			System.out.println(""YES"");
		else
			System.out.println(""NO"");

	}
}",1,1
"import java.util.Scanner;
/**
 * Write a description of class lukno here.
 * 
 * @author (your name) 
 * @version (a version number or a date)
 */
public class lukno
{
    public static void main (String args[])
    {
        Scanner i= new Scanner(System.in);
        int n,p;
       
        n=i.nextInt(); int t=n;
       if(t%4==0||t%7==0||t%47==0||t%74==0||t%44==0||t%447==0||t%474==0||t%477==0)
               System.out.print(""YES"");
               else System.out.print(""NO"");

    
           


}
}
",1,1
"import java.util.Scanner;
public class LuckyDivision{
    public static void main(String [] args){
        Scanner input = new Scanner(System.in);
        int a = input.nextInt();
        if(a%4 == 0) System.out.println(""YES"");
        else if(a%7 == 0) System.out.println(""YES"");
        else if(a%47 == 0) System.out.println(""YES"");
        else if(a%74 == 0) System.out.println(""YES"");
        else if(a%447 == 0) System.out.println(""YES"");
        else if(a%474 == 0) System.out.println(""YES"");
        else if(a%477 == 0) System.out.println(""YES"");
        else if(a%747 == 0) System.out.println(""YES"");
        else if(a%774 == 0) System.out.println(""YES"");
        else System.out.println(""NO"");
    }
}",1,1
"import java.io.*;
import java.util.*;

public class lucky
{ 
   public static void main(String args[]) throws IOException
   { 
    BufferedReader cin=new BufferedReader(new InputStreamReader(System.in));
    
    String s=cin.readLine();
    int l=s.length();
    int n=Integer.parseInt(s);
    if(s.equals(""47"") || s.equals(""4"") || s.equals(""7"") || s.equals(""74"") || s.equals(""447"") || s.equals(""477"") || s.equals(""474"") || s.equals(""44"") || s.equals(""77"") || s.equals(""444"") || s.equals(""777"") || s.equals(""747"") || s.equals(""774"") || s.equals(""744""))
          
          System.out.println(""YES"");
    else if(n%(47)==0 || n%(4)==0 || n%(7)==0 || n%(74)==0 || n%(447)==0 || n%(477)==0 || n%(474)==0 || n%(44)==0 || n%(77)==0 || n%(444)==0 || n%(777)==0  || n%(747)==0  || n%(774)==0  || n%(744)==0)
            System.out.println(""YES"");
    else
            System.out.println(""NO"");
            }
 }          ",1,1
"import java.util.*;
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int in = sc.nextInt();
        if(
                in%4==0||
                in%7==0||
                in%44==0||
                in%47==0||
                in%74==0||
                in%77==0||
                in%444==0||
                in%447==0||
                in%474==0||
                in%477==0||
                in%744==0||
                in%747==0||
                in%774==0||
                in%777==0
                
        )
            System.out.println(""YES"");
        else System.out.println(""NO"");

    }

}
",1,1
"import java.io.BufferedReader;
import java.io.InputStreamReader;

/**
 * @author Son-Huy TRAN
 * 
 */
public class P122A_LuckyDivision {

	private static boolean isLuckyNumber(int number) {
		while (number > 0) {
			int digit = number % 10;

			if (digit != 4 && digit != 7) {
				return false;
			}

			number /= 10;
		}

		return true;
	}

	private static boolean isAlmostLuckyNumber(int number) {
		int max = (int) Math.sqrt(number);
		int i = 1;

		while (i <= max) {
			if (number % i == 0
					&& (isLuckyNumber(i) || isLuckyNumber(number / i))) {
				return true;
			}

			i++;
		}

		return false;
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		try {
			// begin reading inputs
			InputStreamReader isr = new InputStreamReader(System.in);
			BufferedReader reader = new BufferedReader(isr);

			// reading inputs
			int input = Integer.parseInt(reader.readLine());

			reader.close();
			isr.close();
			// end reading inputs

			boolean result = isAlmostLuckyNumber(input);
			System.out.println(result ? ""YES"" : ""NO"");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
",1,1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String input = in.nextLine();
        if (input.equals(""1""))
            System.out.println(""NO"");
        else {
            if (checkNum(input))
                System.out.println(""YES"");
            else {
                int i = 2;
                while (i < Integer.parseInt(input)) {
                    if (checkNum(i + """")) {
                        if (Integer.parseInt(input) % i != 0)
                            i++;
                        else
                            break;
                    } else
                        i++;
                }
                if (i == Integer.parseInt(input))
                    System.out.println(""NO"");
                else
                    System.out.println(""YES"");
            }
        }
    }

    public static boolean checkNum(String s) {
        int i = 0;
        int flag = 0;
        while (i < s.length()) {
            if (s.charAt(i) == '4' || s.charAt(i) == '7') {
                flag = 1;
                i++;
            } else
                return false;
        }
        if (flag == 1)
            return true;
        return false;
    }
}
",1,1
"import java.util.Scanner;

public class A_Lucky_Division {
	public static void main(String[] args){
		Scanner input=new Scanner(System.in);
		int number=input.nextInt();
		int flag=0;
		if(number%4==0)flag=1;
		else if(number%7==0)flag=1;
		else if(number%47==0)flag=1;
		else if(number%74==0)flag=1;
		else if(number%444==0)flag=1;
		else if(number%447==0)flag=1;
		else if(number%474==0)flag=1;
		else if(number%477==0)flag=1;
		else if(number%744==0)flag=1;
		else if(number%747==0)flag=1;
		else if(number%774==0)flag=1;
		else if(number%777==0)flag=1;
		if(flag==1)System.out.println(""YES"");
		else System.out.println(""NO"");
		
	}
}
",1,1
"import java.util.Scanner;


public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		if (((n % 4) == 0) || ((n % 7) == 0) || ((n % 44) == 0) || ((n % 47) == 0) || ((n % 74) == 0) || ((n % 77) == 0) || ((n % 444) == 0) || ((n % 447) == 0) || ((n % 474) == 0) || ((n % 477) == 0) || ((n % 744) == 0) || ((n % 747) == 0) || ((n % 774) == 0) || ((n % 777) == 0))
			System.out.print(""YES"");
		else
			System.out.print(""NO"");
		in.close();
	}

}
",1,1
"import java.util.*;
public class Main{
	public static void main(String args[]){
		Scanner in = new Scanner(System.in);
		int a[]={4,7,44,47,74,77,444,447,474,477,744,747,774,777};
		int n=in.nextInt();
		int i=0;
		boolean yes=false;
		while((i<14)&&(a[i]<=n)){
			if(n%a[i]==0){
				System.out.print(""YES"");
				yes=true;
				break;
			} i++;
		}
		if(!yes)
		System.out.print(""NO"");
	}
}",1,1
"import java.util.Scanner;

public class LuckyDivision {
	public static void main (String[] args) {
		Scanner read = new Scanner(System.in);
		int n = read.nextInt();
		
		if (n % 4 == 0 ||
			n % 7 == 0 ||
			n % 47 == 0 ||
			n % 74 == 0 ||
			n % 447 == 0 ||
			n % 474 == 0 ||
			n % 477 == 0 ||
			n % 744 == 0 ||
			n % 747 == 0 ||
			n % 774 == 0)	{
				System.out.println(""YES"");
			}
		else {
				System.out.println(""NO"");
		}
		
	}
}
",1,1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;
import java.util.StringTokenizer;

public class CF {
        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st=null;
        private void  solution() throws IOException{
   int n=nextInt();
   if((n % 4==0 && n>=4)||(n % 7==0 && n>=7) || (n % 44==0 && n>=44) || (n % 47==0 && n>=47) || (n % 77==0 && n>=77) || (n % 74==0 && n>=74)
   || (n % 444==0 && n>=444) || (n % 447==0 && n>=447) || (n % 474==0 && n>=74) || (n % 477==0 && n>=477) || (n % 744==0 && n>=744)
   || (n % 747==0 && n>=747) || (n % 777==0 && n>=777) || (n % 774==0 && n>=774)){
           System.out.println(""YES"");
   }else{
                System.out.println(""NO"");}
        }
        String nextToken()throws IOException {
                if(st==null || !st.hasMoreTokens()){
                        st = new StringTokenizer(bf.readLine());
                }
                return st.nextToken();
        }
        int nextInt() throws IOException {
                return Integer.parseInt(nextToken());
        }

        long nextLong() throws IOException {
                return Long.parseLong(nextToken());
        }

        double nextDouble() throws IOException {
                return Double.parseDouble(nextToken());
        }

        public static void main(String args[]) throws IOException {
                new CF().solution();
        }
}",1,1
"import java.util.*;

public class MainClass {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int arr[] = {4,7,47,74,447,474,477,744,747,774};
        int i=0, x = in.nextInt();
        while (i<arr.length)
        if (x%arr[i++] == 0)
        {
             System.out.print(""YES"");
             return;
        }
        System.out.print(""NO"");
    }
}
",1,1
"import java.util.*;
public class Solution {
    public static void main(String[] args){
        Scanner cin=new Scanner(System.in);
        int n=cin.nextInt();
        if(n%4==0 || n%7==0 || n%44==0 || n%47==0 || n%74==0 || n%77==0 || n%444==0 || n%447==0 || n%474==0 ||
                n%477==0 || n%744==0 || n%747==0 || n%774==0 ||n%777==0) System.out.print(""YES"");
        else System.out.print(""NO"");
    }
}
",1,1
"

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;


public class A implements Runnable {

	private void Solution() throws IOException {
		int n = nextInt();
		if (n % 7 == 0 || n % 4 == 0 || n % 47 == 0 || n % 74 == 0 || n % 747 == 0 || n % 474 == 0 || n % 777 == 0 || n % 444 == 0 || n % 774 == 0 || n % 447 == 0 || n % 744 == 0 || n % 477 == 0)
			System.out.println(""YES""); else 
				System.out.println(""NO"");
	}
	
	public static void main(String args[]) {
		new A().run();
	}
	
	BufferedReader in;
	StringTokenizer tokenizer;
	
	public void run() {
		try {
            in = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            Solution();
            in.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
	}

	int nextInt() throws NumberFormatException, IOException {
		return Integer.parseInt(nextToken());
	}
	
	String nextToken() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens())
			tokenizer = new StringTokenizer(in.readLine());
		return tokenizer.nextToken();
	}
}
",1,1
"import java.util.Scanner;

public class Task122A {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		sc.close();
		
		if ( (n % 4 == 0)   ||
			 (n % 7 == 0)   ||
			 (n % 44 == 0)  ||
			 (n % 47 == 0)  ||
			 (n % 74 == 0)  ||
			 (n % 77 == 0)  ||
		   	 (n % 444 == 0) ||
			 (n % 447 == 0) ||
			 (n % 474 == 0) ||
			 (n % 477 == 0) ||
			 (n % 744 == 0) ||
			 (n % 747 == 0) ||
			 (n % 774 == 0) ||
			 (n % 777 == 0)    )
		{
			System.out.println(""YES"");
		} else {
			System.out.println(""NO"");
		}
	}
}",1,1
"import java.util.*;
public class Main{
public static void main(String[]args){
Scanner input=new Scanner(System.in);
int x=input.nextInt();
if(x%4==0||x%7==0||x%47==0||x%74==0||x%744==0||x%474==0||x%447==0||x%477==0||x%474==0)
System.out.println(""YES"");
else
System.out.println(""NO"");
}
}",1,1
"import java.io.*;
import java.util.*;
import java.math.*;

public class Main
{
    public static void main(String args[])
    {
       Scanner scan=new Scanner(System.in);
       int n=scan.nextInt();
       System.out.println((n%4==0||n%7==0||n%47==0||n%74==0||n%447==0||n%474==0||n%477==0||n%744==0||n%747==0||n%774==0)?""YES"":""NO"");
    }
}",1,1
"import java.util.Scanner;
/**
 * Write a description of class lukno here.
 * 
 * @author (your name) 
 * @version (a version number or a date)
 */
public class lukno
{
    public static void main (String args[])
    {
        Scanner i= new Scanner(System.in);
        int n,p;
        
       
        n=i.nextInt(); int t=n;
        while(n!=0)
        {
            p=n%10;
            if(p!=4||p!=7)
           { if(t%7==0||t%4==0||t%47==0||t%74==0||t%447==0||t%477==0||t%474==0)
               System.out.print(""YES"");
               else System.out.print(""NO"");

            break;}
            else System.out.print(""NO"");
            
            n=(n/10);
            }
           


}
}",1,1
"import java.util.Scanner;

public class LuckySubstring {
    
    static int[] luck;
    
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        
        int n = s.nextInt();
        int i = -1;
        boolean ehLuck = false;
        preencheLucky();
        while (n >= luck[++i]) {
            if (i > 13) {
                break;
            }
            if (n % luck[i] == 0) {
                ehLuck = true;
                break;
            }
        }
        if (ehLuck) {
            System.out.println(""YES"");
        } else {
            System.out.println(""NO"");
        }
    }
    
    static void preencheLucky() {
        luck = new int[15];
        luck[0] = 4;
        luck[1] = 7;
        luck[2] = 44;
        luck[3] = 47;
        luck[4] = 74;
        luck[5] = 77;
        luck[6] = 444;
        luck[7] = 447;
        luck[8] = 474;
        luck[9] = 477;
        luck[10] = 744;
        luck[11] = 747;
        luck[12] = 774;
        luck[13] = 777;
    }
    
}
",1,1
"import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if ((n%4==0)||(n%7==0)||(n%44==0)||(n%47==0)||(n%74==0)||(n%77==0)||(n%444==0)||(n%447==0)||(n%474==0)||(n%477==0)||(n%744==0)||(n%747==0)||(n%774==0)||(n%777==0)) {
            System.out.println(""YES"");
        } else {
            System.out.println(""NO"");
        }
    }
}
",1,1
"import java.io.*;
import java.util.*;

public class Main{
public static void main(String[] args) throws IOException{
BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));
String a=buffer.readLine();
int b=Integer.parseInt(a);
if(b%4==0 || b%7==0 || b%44==0 || b%47==0 || b%74==0 || b%77==0 || b%444==0 || b%447==0 || b%474==0 || b%477==0 || b%744==0 || b%747==0 || b%774==0 || b%777==0)
System.out.println(""YES"");
else
System.out.println(""NO"");
}}",1,1
"import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        if ((n % 4 == 0) || (n % 7 == 0) || (n % 44 == 0) || (n % 47 == 0) || (n % 74 == 0) || (n % 77 == 0) 
                || (n % 444 == 0) || (n % 447 == 0) || (n % 474 == 0) || (n % 477 == 0) || (n % 744 == 0) 
                || (n % 747 == 0) || (n % 774 == 0) || (n % 777 == 0)) {
            System.out.println(""YES"");
            return;
        }
        System.out.println(""NO"");
    }
}
",1,1
"import java.io.*;
import java.util.*;
public class z3 {
	public static boolean divch(int i,int a)
	{ if (a>1000) return false; if ((a>0)&&(i%a==0)) return true; return (divch(i,a*10+4)||divch(i,a*10+7)); }
	public static void main(String[] args) throws IOException {
		Scanner in = new Scanner(System.in);
		System.out.println(divch(in.nextInt(),0)?""YES"":""NO"");
	}
}",1,1
"import java.util.Scanner;
public class LuckyDivision {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        int n = in.nextInt();
        
        if( n % 4==0 ||
            n % 7==0 ||
            n % 47==0 ||
            n % 74==0 ||
            n % 447==0 ||
            n % 474==0 ||
            n % 477==0 ||
            n % 744==0 ||
            n % 774==0 ||
            n % 777==0
        )
            System.out.println(""YES"");
        else
            System.out.println(""NO"");
    }
}
",1,1
"import java.io.*;
import java.util.*;
public class solution {
    public static void main(String[] args) {
       Scanner in = new Scanner(System.in);
       int n = in.nextInt();
       boolean ok = (n % 4 == 0) || (n % 7 == 0) || (n % 47 == 0) || (n % 74 == 0) || (n % 447 == 0) || (n % 474 == 0) || (n % 477 == 0) || (n % 744 == 0) || (n % 747 == 0) || (n % 774 == 0);
       if (ok) System.out.println(""YES""); else System.out.println(""NO"");
    } 
}",1,1
"
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class A {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner scan = new Scanner(System.in);
		int a = scan.nextInt();
		Queue<Integer> q = new LinkedList<Integer>();
		q.add(4);
		q.add(7);
		boolean luck = false;
		while(!q.isEmpty() && !luck)
		{
			int f = q.poll();
			if(a%f == 0)
			{
				luck = true;
				break;
			}
			if(f<a)
			{
				int t = (f+"""").length();
				int tt = (int)Math.pow(10, t);
				q.add(tt*4+f);
				q.add(tt*7+f);
			}
		}
		if(luck)
			System.out.println(""YES"");
		else
			System.out.println(""NO"");
		
	}

}
",1,1
"

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class TwoSets<V> {

    private static int n;

    private static int a;

    private static int b;

    private static List<Node<Integer>> nodes = new LinkedList<Node<Integer>>();

    private static Map<Integer, Node<Integer>> datas = new HashMap<Integer, Node<Integer>>();

    private static Node<Integer> first;

    private static Node<Integer> second;

    private static TwoSets<Integer> sets = new TwoSets<Integer>();

    private static class Node<V> {

	V node;

	Node<V> parent;

	int rank;

	int color = -1;

	boolean inprogress;

	public Node() {
	    this.parent = this;
	}

	@Override
	public String toString() {
	    return String.format(""{node: %s, parent: %s, rank: %s, color:%s}"",
		    node, parent.node, rank, color);
	}
    }

    public Node<V> makeSet(V x) {

	Node<V> node = new Node<V>();

	node.node = x;
	node.parent = node;
	node.rank = 0;

	return node;
    }

    public void link(Node<V> x, Node<V> y) {

	if (x.rank > y.rank) {
	    y.parent = x;
	} else {
	    x.parent = y;
	    if (x.rank == y.rank) {
		y.rank++;
	    }
	}
    }

    public Node<V> findSet(Node<V> x) {

	if (x.parent != x) {
	    x.parent = findSet(x.parent);
	}

	return x.parent;
    }

    public void union(Node<V> x, Node<V> y) {

	Node<V> rtX = findSet(x);
	Node<V> rtY = findSet(y);
	if (rtX.parent != rtY.parent) {
	    link(rtX, rtY);
	}
    }

    public V getNode(Node<V> x) {
	return x.node;
    }

    private int getColor(Node<V> node) {

	int color;
	Node<V> parent = findSet(node);
	color = parent.color;

	return color;
    }

    private void setColor(Node<V> node, int color) {
	Node<V> parent = findSet(node);
	parent.color = color;
    }

    private static Node<Integer> getOrInitNode(Integer key) {

	Node<Integer> node = datas.get(key);

	if (node == null) {
	    node = sets.makeSet(key);
	    datas.put(key, node);
	}

	return node;
    }

    private static void initNodes(Scanner scanner) {

	int key;
	Node<Integer> node;
	for (int i = 0; i < n; i++) {
	    key = scanner.nextInt();
	    node = getOrInitNode(key);
	    nodes.add(node);
	}
    }

    private static void unionAll(Node<Integer> value) {

	int color = sets.getColor(value);
	if (color == 0) {
	    if (first == null) {
		first = value;
	    } else {
		sets.union(first, value);
	    }
	} else if (color == 1) {
	    if (second == null) {
		second = value;
	    } else {
		sets.union(second, value);
	    }
	}
    }

    private static int getKey(Node<Integer> value, int color) {

	int key = value.node;

	if (color == 0) {
	    key = a - key;
	} else {
	    key = b - key;
	}

	return key;
    }

    private static boolean checkOpposite(Node<Integer> value, int color) {

	boolean valid;

	if (value.inprogress) {
	    valid = Boolean.TRUE;
	} else {
	    value.inprogress = Boolean.TRUE;
	    int opColor = 1 - color;
	    int key = getKey(value, opColor);
	    Node<Integer> node = datas.get(key);
	    valid = (value.node.equals(key)) || (node == null);
	    if (!valid) {
		key = getKey(node, color);
		Node<Integer> child = datas.get(key);
		valid = (child != null);
		if (valid) {
		    valid = checkOpposite(child, color);
		    if (valid) {
			sets.union(value, node);
			sets.union(value, child);
			value.inprogress = Boolean.FALSE;
		    }
		}
	    }
	    value.inprogress = Boolean.FALSE;
	}

	return valid;
    }

    private static boolean checkNodes(Node<Integer> value, int color) {

	boolean valid;

	int key = getKey(value, color);
	int opColor = 1 - color;
	Node<Integer> node = datas.get(key);
	valid = (value.node.equals(key)) || (node != null);
	if (valid) {
	    valid = checkOpposite(value, color);
	    if (valid) {
		sets.union(value, node);
		sets.setColor(value, color);
	    } else if (color == 0) {
		valid = checkNodes(value, opColor);
	    }
	} else if (color == 0) {
	    valid = checkNodes(value, opColor);
	}

	return valid;
    }

    private static void format(StringBuilder builder, int i) {

	if (i > 0) {
	    builder.append(' ');
	}
    }

    private static String printNodes() {

	String text;

	StringBuilder builder = new StringBuilder();
	Iterator<Node<Integer>> iterator = nodes.iterator();
	int i = 0;
	Node<Integer> node;
	while (iterator.hasNext()) {
	    format(builder, i);
	    node = iterator.next();
	    builder.append(sets.getColor(node));
	    i++;
	}
	text = builder.toString().trim();

	return text;
    }

    private static boolean checkNodes(int color) {

	boolean valid = Boolean.TRUE;

	for (Node<Integer> value : nodes) {
	    if (sets.getColor(value) == -1) {
		valid = checkNodes(value, color);
		if (valid) {
		    unionAll(value);
		} else {
		    break;
		}
	    }
	}

	return valid;
    }

    private static void calculate() {

	int color = 0;
	boolean valid = checkNodes(color);
	String message = ""NO"";
	if (valid) {
	    message = ""YES"";
	    String array = printNodes();
	    System.out.println(message);
	    System.out.println(array);
	} else {
	    System.out.println(message);
	}
    }

    public static void main(String[] args) {

	Scanner scanner = new Scanner(System.in);
	try {
	    n = scanner.nextInt();
	    a = scanner.nextInt();
	    b = scanner.nextInt();
	    initNodes(scanner);
	    calculate();
	} finally {
	    scanner.close();
	}
    }
}
",3,3
"import java.util.*;
import java.io.*;

public class Main {

	BufferedReader in;
	StringTokenizer str = null;
	PrintWriter out;
	
	private String next() throws Exception{
		while (str == null || !str.hasMoreElements())
			str = new StringTokenizer(in.readLine());
		return str.nextToken();
	}
	
	private int nextInt() throws Exception{
		return Integer.parseInt(next());
	}
	
	private long nextLong() throws Exception{
		return Long.parseLong(next());
	}
	
	private double nextDouble() throws Exception{
		return Double.parseDouble(next());
	}

	Map<Integer, Integer> map;
	int []p, rank;

	public void run() throws Exception{
		in =  new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);

		map = new HashMap<Integer, Integer>();

		int n = nextInt();
		int x = nextInt(), y = nextInt();
		int []a = new int[n];
		p = new int[n];
		for(int i = 1; i < n; ++i) p[i] = i;
		rank = new int[n];

		for(int i = 0; i < n; ++i) {
			a[i] = nextInt();
			map.put(a[i], i);
		}
		int mask[] = new int[n];
		for(int i = 0; i < n; ++i) {
			if (map.containsKey(x - a[i])) {
				union(map.get(x - a[i]), i);
				mask[i] |= 1;	
			} 
			if (map.containsKey(y - a[i])) {
				union(map.get(y - a[i]), i);
				mask[i] |= 2;
			} 
		}

		int []b = new int[n];
		Arrays.fill(b, 3);
		for(int i = 0; i < n; ++i) b[find(i)] &= mask[i];
		for(int i = 0; i < n; ++i) {
			if (b[i] == 0) {
				out.println(""NO"");
				out.close();
				return;
			}
		}

		out.println(""YES"");
		for(int i = 0; i < n; ++i) {
			out.print((b[find(i)] & 1) == 1 ? 0 : 1);
			if (i != n - 1) out.print("" "");
		}
		out.println();
		out.close();
	}

	private int find(int x) {
		if (x != p[x])
			return p[x] = find(p[x]);
		return x;
	}
	private void union(int a, int b) {
		a = find(a);
		b = find(b);
		if (rank[a] < rank[b]) {
			int tmp = a;
			a = b;
			b = tmp;
		}
		p[b] = a;
		if (rank[a] == rank[b]) ++rank[a];
	}
		
	public static void main(String[] args) throws Exception{
		new Main().run();
	}
}
",3,3
"import java.util.Map;
import java.io.IOException;
import java.util.TreeMap;
import java.util.InputMismatchException;
import java.io.PrintStream;
import java.io.OutputStream;
import java.util.ArrayDeque;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.Queue;
import java.util.Collection;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author karan173
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskB
{
    int val[];
    int p[];
    int aneigh[], bneight[], deg[];
    public void solve(int testNumber, FastReader in, PrintWriter out)
    {
        int n = in.ni ();
        val = new int[n];
        int a = in.ni ();
        int b = in.ni ();
        Map<Integer, Integer> set = new TreeMap<Integer, Integer> ();
        p = in.iArr (n);
        for (int i = 0; i < n; i++)
        {
            set.put (p[i], i);
        }
        aneigh = new int[n];
        bneight = new int[n];
        deg = new int[n];
        for (int i = 0; i < n; i++)
        {
            aneigh[i] = val[i] = bneight[i] = -1;
            deg[i] = 0;
        }
        Queue<Integer> queue = new ArrayDeque<Integer> ();
        for (int i = 0; i < n; i++)
        {
            Integer x1 = set.get (a - p[i]);
            Integer x2 = set.get (b - p[i]);
            if (x1 != null)
            {
                aneigh[i] = x1;
                deg[i]++;
            }
            if (x2 != null && a != b)
            {
                bneight[i] = x2;
                deg[i]++;
            }
            if (deg[i] == 1)
            {
                queue.add (i);
            }
        }

        while (!queue.isEmpty ())
        {
            int idx = queue.remove ();
            if (deg[idx] != 1)
            {
                continue;
            }
            int aa = aneigh[idx];
            int bb = bneight[idx];
            if (aa != -1)
            {
                val[idx] = val[aa] = 0;
                deg[aa]--;
                deg[idx]--;
                aneigh[aa] = -1;
                aneigh[idx] = -1;
                if (deg[aa] == 1)
                {
                    int zz = bneight[aa];
                    bneight[zz] = -1;
                    deg[zz]--;
                    if(deg[zz] == 1)
                    queue.add (zz);
                }
            }
            else
            {
                val[idx] = val[bb] = 1;
                deg[bb]--;
                deg[idx]--;
                bneight[idx] = bneight[bb] = -1;
                if (deg[bb] == 1)
                {
                    //queue.add (bb);
                    int zz = aneigh[bb];
                    aneigh[zz] = -1;
                    deg[zz]--;
                    if(deg[zz] == 1)
                        queue.add (zz);
                }
            }
        }

        for (int i = 0; i < n; i++)
        {
            if (val[i] == -1 && cantBePaired(i))
            {
                out.println (""NO"");
                return;
            }
        }
        //every person has two neighbours

        out.println (""YES"");
        for (int i = 0; i < n; i++)
        {
            out.print (val[i] + "" "");
        }
        out.println ();
    }

    private boolean cantBePaired(int i)
    {
        int aa = aneigh[i];
        int bb = bneight[i];
        if (aa != -1 && val[aa] == -1)
        {
            return false;
        }
        if (bb != -1 && val[bb] == -1)
        {
            return false;
        }
        return true;
    }
}

class FastReader
{

    public InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public FastReader(InputStream stream)
    {
        this.stream = stream;
    }

    public FastReader()
    {

    }

    public int read()
    {
        if (numChars == -1)
        {
            throw new InputMismatchException ();
        }
        if (curChar >= numChars)
        {
            curChar = 0;
            try
            {
                numChars = stream.read (buf);
            } catch (IOException e)
            {
                throw new InputMismatchException ();
            }
            if (numChars <= 0)
            {
                return -1;
            }
        }
        return buf[curChar++];
    }

    public int ni()
    {
        int c = read ();
        while (isSpaceChar (c))
            c = read ();
        int sgn = 1;
        if (c == '-')
        {
            sgn = -1;
            c = read ();
        }
        int res = 0;
        do
        {
            if (c < '0' || c > '9')
            {
                throw new InputMismatchException ();
            }
            res *= 10;
            res += c - '0';
            c = read ();
        } while (!isSpaceChar (c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c)
    {
        if (filter != null)
        {
            return filter.isSpaceChar (c);
        }
        return isWhitespace (c);
    }

    public static boolean isWhitespace(int c)
    {
        return c==' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public int[] iArr(int n)
    {
        int a[] = new int[n];
        for (int i = 0; i < n; i++)
        {
            a[i] = ni ();
        }
        return a;
    }

    public interface SpaceCharFilter
    {
        public boolean isSpaceChar(int ch);
    }
}
",3,3
"import java.io.*;
import java.util.*;

public class Main {
  // main
  public static void main(String [] args) throws IOException {
    // makes the reader and writer
    BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
    PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));
    
    // read in n,a,b,ints
    StringTokenizer st = new StringTokenizer(f.readLine());
    int n = Integer.parseInt(st.nextToken());
    int a = Integer.parseInt(st.nextToken());
    int b = Integer.parseInt(st.nextToken());
    st = new StringTokenizer(f.readLine());
    HashMap<Integer,Integer> in = new HashMap<Integer,Integer>();
    int[][] locs = new int[n][2];
    for (int i=0;i<n;i++) {
      int num = Integer.parseInt(st.nextToken());
      locs[i] = new int[]{num,i};
      in.put(num,i);
    }
    
    // use greedy
    boolean ok = true;
    int swap = 0;
    if (a>b) {swap = 1;
      int t = a;
      a = b;
      b = t;
    }
    Arrays.sort(locs,new Comparator<int[]>() {
      public int compare(int[] a, int[] b) {
        return (new Integer(a[0])).compareTo(b[0]);
      }
    });
    int[] inB = new int[n];
    for (int[] i: locs) {
      if (in.containsKey(b-i[0])) {
        inB[i[1]] = 1-swap;
        in.remove(b-i[0]);
      } else if (in.containsKey(a-i[0])) {
        inB[i[1]] = swap;
        in.remove(a-i[0]);
      } else ok = false;
    }

    // write to out
    StringBuffer p = new StringBuffer();
    for (int i=0;i<n-1;i++) {
      p.append(inB[i]);
      p.append("" "");
    }
    p.append(inB[n-1]);
    if (ok) {
      out.println(""YES"");
      out.println(p.toString());
    } else {
      out.println(""NO"");
    }
    
    // cleanup
    out.close();
    System.exit(0);
  }
}",3,3
"import java.io.*;
import java.util.*;

public class Task468B {
    private static InputReader in;
    private static PrintWriter out;
    private static boolean autoFlush = false;
    static final int inf = (int) 1e9 + 7;
    static final long infL = (long) 1e18 + 7;

    static class Testcase {
        HashMap<Integer, Integer> map;
        ArrayList<ArrayList<Integer>> adj;
        int[] arr;
        boolean[] vis;
        ArrayList<Integer> path;

        public void dfs(int v) {
            vis[v] = true;
            path.add(v);
            for (int u : adj.get(v)) {
                if (vis[u])
                    continue;
                dfs(u);
            }
        }

        public void solve(int test) {
            int n = in.nextInt(), a = in.nextInt(), b = in.nextInt();
            arr = new int[n];
            map = new HashMap<>();
            adj = new ArrayList<ArrayList<Integer>>();
            for (int i = 0; i < n; i++) {
                arr[i] = in.nextInt();
                map.put(arr[i], i);
                adj.add(new ArrayList<Integer>());
            }
            int[] ans = new int[n];
            if (a == b) {
                Arrays.fill(ans, 0);
                for (int i = 0; i < n; i++) {
                    if (!map.containsKey(a - arr[i])) {
                        out.println(""NO"");
                        return;
                    }
                }
            } else {
                int[] self = new int[n];
                Arrays.fill(self, -1);
                for (int i = 0; i < n; i++) {
                    if (map.containsKey(a - arr[i]) && a != 2 * arr[i])
                        adj.get(i).add(map.get(a - arr[i]));
                    if (map.containsKey(b - arr[i]) && b != 2 * arr[i])
                        adj.get(i).add(map.get(b - arr[i]));
                    if (2 * arr[i] == a)
                        self[i] = 0;
                    if (2 * arr[i] == b)
                        self[i] = 1;
                }

                vis = new boolean[n];
                path = new ArrayList<Integer>();

                for (int i = 0; i < n; i++) {
                    if (self[i] != -1 && !vis[i]) {
                        path.clear();
                        dfs(i);
                        if (path.size() % 2 == 1) {
                            ans[path.get(0)] = self[path.get(0)];
                            path.remove(0);
                        }
                        for (int j = 0; j + 1 < path.size(); j += 2) {
                            int cur = 0;
                            if (arr[path.get(j)] + arr[path.get(j + 1)] == b)
                                cur = 1;
                            ans[path.get(j)] = cur;
                            ans[path.get(j + 1)] = cur;
                        }
                    }
                }
                for (int i = 0; i < n; i++) {
                    if (adj.get(i).size() == 1 && !vis[i]) {
                        path.clear();
                        dfs(i);
                        if (path.size() % 2 == 1) {
                            out.println(""NO"");
                            return;
                        }
                        for (int j = 0; j + 1 < path.size(); j += 2) {
                            int cur = 0;
                            if (arr[path.get(j)] + arr[path.get(j + 1)] == b)
                                cur = 1;
                            ans[path.get(j)] = cur;
                            ans[path.get(j + 1)] = cur;
                        }
                    }
                }
                for (int i = 0; i < n; i++) {
                    if (!vis[i]) {
                        path.clear();
                        dfs(i);
                        if (path.size() % 2 == 1) {
                            out.println(""NO"");
                            return;
                        }
                        for (int j = 0; j < path.size(); j += 2) {
                            int cur = 0;
                            if (arr[path.get(j)] + arr[path.get(j + 1)] == a)
                                cur = 1;
                            ans[path.get(j)] = cur;
                            ans[path.get(j + 1)] = cur;
                        }
                    }
                }
            }
            out.println(""YES"");
            for (int i : ans)
                out.print(i + "" "");
            out.println();
        }
    }

    public static void main(String[] args) {
        in = new InputReader(System.in);
        out = new PrintWriter(System.out, autoFlush);
        int t = 1;
        // t = in.nextInt();
        for (int i = 1; i <= t; i++) {
            Testcase solver = new Testcase();
            // out.printf(""Case #%d: "", i);
            solver.solve(i);
        }
        out.close();
    }

    static class InputReader {
        BufferedReader reader;
        StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public InputReader(FileReader file) throws FileNotFoundException {
            reader = new BufferedReader(file, 32768);
            tokenizer = null;
        }

        public String readLine() {
            String str = """";
            try {
                str = reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            return str;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens())
                tokenizer = new StringTokenizer(readLine());
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public float nextFloat() {
            return Float.parseFloat(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }

    public static void trace(Object... o) {
        System.err.println(Arrays.deepToString(o));
    }
}
",3,5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemB {
    Map<Integer, List<int[]>> dest;

    private ProblemB() throws IOException {
        BufferedReader rd = new BufferedReader(new InputStreamReader(System.in));
        String h = rd.readLine();
        String[] q = h.split(""\\s+"");
        int a = Integer.parseInt(q[1]);
        int b = Integer.parseInt(q[2]);
        h = rd.readLine();
        q = h.split("" "");
        int n = q.length;
        int[] p = new int[n];
        for(int i=0;i<n;i++) {
            p[i] = Integer.parseInt(q[i]);
        }
        Set<Integer> pset = new HashSet<>();
        for(int x: p) {
            pset.add(x);
        }

        if(a == b) {
            boolean res = true;
            for(int x: p) {
                if(!pset.contains(a-x)) {
                    res = false;
                    break;
                }
            }
            out(res?""YES"":""NO"");
            if(res) {
                StringBuilder buf = new StringBuilder();
                for(int i=0;i<n;i++) {
                    if(i > 0) {
                        buf.append(' ');
                    }
                    buf.append('0');
                }
                out(buf);
            }
        } else {
            dest = new HashMap<>();
            boolean res = true;
            for(int x: p) {
                boolean aOk = pset.contains(a-x);
                boolean bOk = pset.contains(b-x);
                if(!aOk && !bOk) {
                    res = false;
                    break;
                } else {
                    if(aOk) {
                        addEdgeAndBack(x,a-x,0);
                    }
                    if(bOk) {
                        addEdgeAndBack(x,b-x,1);
                    }
                }
            }
            Set<Integer> aSet = new HashSet<>();
            if(res) {
                for(int x: p) {
                    List<int[]> e = getEdges(x);
                    if(e.size() == 1) {
                        int[] edge = e.get(0);
                        if(edge[0] == x) {
                            if(edge[1] == 0) {
                                aSet.add(x);
                            }
                        } else {
                            boolean odd = true;
                            int curA = edge[1];
                            int prev = x;
                            while(true) {
                                int cur = edge[0];
                                if(curA == 0 && odd) {
                                    aSet.add(prev);
                                    aSet.add(cur);
                                }
                                e = getEdges(cur);
                                if(e.size() == 1) {
                                    if(!odd && e.get(0)[0] != cur) {
                                        res = false;
                                    }
                                    break;
                                }
                                int other = e.get(0)[0] == prev?1:0;
                                edge = e.get(other);
                                if(edge[1] == curA) {
                                    res = false;
                                    break;
                                }
                                curA = 1-curA;
                                prev = cur;
                                odd = !odd;
                            }
                            if(!res) {
                                break;
                            }
                        }
                    }
                }
            }
            out(res?""YES"":""NO"");
            if(res) {
                StringBuilder buf = new StringBuilder();
                for(int i=0;i<n;i++) {
                    if(i>0) {
                        buf.append(' ');
                    }
                    buf.append(aSet.contains(p[i])?'0':'1');
                }
                out(buf);
            }
        }
    }

    private void addEdgeAndBack(int from, int to, int u) {
        addEdge(from, to, u);
        addEdge(to, from, u);
    }

    private void addEdge(int from, int to, int u) {
        List<int[]> edges = getEdges(from);
        for(int[] edge: edges) {
            if(edge[0] == to) {
                return;
            }
        }
        edges.add(new int[] { to, u });
    }

    private List<int[]> getEdges(int from) {
        List<int[]> ds = dest.get(from);
        if(ds == null) {
            ds = new ArrayList<>();
            dest.put(from, ds);
        }
        return ds;
    }

    private static void out(Object x) {
        System.out.println(x);
    }

    public static void main(String[] args) throws IOException {
        new ProblemB();
    }
}
",3,3
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.StringTokenizer;
import static java.lang.Integer.*;

public class BDiv1 {
static int n; 
static int a;
static int b;
static HashMap<Integer,Integer> graphA=new HashMap<>();
static HashMap<Integer,Integer> graphB=new HashMap<>();
static int [] array;
static int [] original;
static boolean x=true;

    public static void main(String[] args) throws Exception{
        BufferedReader buf =new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st =new StringTokenizer(buf.readLine());
        n=parseInt(st.nextToken());
        a=parseInt(st.nextToken());
        b=parseInt(st.nextToken());
        st =new StringTokenizer(buf.readLine());
        array=new int[n];
        original=new int [n];
        for (int i=0;i<n;i++){
            array[i]=parseInt(st.nextToken());
            original[i]=array[i];
        }
        Arrays.sort(array);
for (int i=0;i<n;i++){
    int k= Arrays.binarySearch(array,a-array[i]);
    if (k>=0){
        graphA.put(array[i],array[k]);
        graphA.put(array[k],array[i]);
    }
}
for (int i=0;i<n;i++){
    int k= Arrays.binarySearch(array,b-array[i]);
    if (k>=0){
        graphB.put(array[i],array[k]);
        graphB.put(array[k],array[i]);
    }
    }


for (int i=0;i<n;i++){
    Integer j=graphA.get(array[i]);
    if (j!=null){
        if (graphB.containsKey(array[i]) && graphB.containsKey(j)){
            graphA.remove(array[i]);
            graphA.remove(j);
        }
        else if (graphB.containsKey(array[i]) && !graphB.containsKey(j)){
            
            graphB.remove(graphB.get(array[i]));
            graphB.remove(array[i]);
        }
        else if (!graphB.containsKey(array[i]) && graphB.containsKey(j)){
            graphB.remove(graphB.get(j));
            graphB.remove(j);
        }
        
    }
    
}

int [] res=new int [n];
for (int i=0;i<n;i++){
    if (graphA.containsKey(original[i]))res[i]=0;
    else if (graphB.containsKey(original[i])) res[i]=1;
    else {
        System.out.println(""NO"");
        return;
    }
}
System.out.println(""YES"");
for (int k:res)System.out.print(k+"" "");
}

    }",3,3
"import java.io.*;
import java.util.*;
import java.util.List;

public class Main {
    private static StringTokenizer st;
    private static BufferedReader br;
    public static long MOD = 1000000007;
    public static long tenFive = 100000;
    public static int INF = 100000;

    public static void print(Object x) {
        System.out.println(x + """");
    }
    public static void printArr(long[] x) {
        StringBuilder s = new StringBuilder();
        for (int i = 0; i < x.length; i++) {
            s.append(x[i] + "" "");
        }
        print(s);
    }
    public static void printArr(int[] x) {
        StringBuilder s = new StringBuilder();
        for (int i = 0; i < x.length; i++) {
            s.append(x[i] + "" "");
        }
        print(s);
    }
    public static String join(Collection<?> x, String space) {
        if (x.size() == 0) return """";
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (Object elt : x) {
            if (first) first = false;
            else sb.append(space);
            sb.append(elt);
        }
        return sb.toString();
    }

    public static String nextToken() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            String line = br.readLine();
            st = new StringTokenizer(line.trim());
        }
        return st.nextToken();
    }
    public static int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }
    public static long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }
    public static List<Integer> nextInts(int N) throws IOException {
        List<Integer> ret = new ArrayList<Integer>();
        for (int i = 0; i < N; i++) {
            ret.add(nextInt());
        }
        return ret;
    }

    public static void solve(int a, int b, List<Integer> orig) {
        boolean swap = false;
        if (a > b) {
            swap = true;
            int tmp = a;
            a = b;
            b = tmp;
        }

        List<Integer> nums = new ArrayList<Integer>(orig);
        Collections.sort(nums);
        Collections.reverse(nums);

        Set<Integer> all = new HashSet<Integer>(nums);
        Set<Integer> done = new HashSet<Integer>();
        Set<Integer> inB = new HashSet<Integer>();
        for (int x : nums) {
            if (done.contains(x)) continue;
            if (all.contains(a - x) && !done.contains(a - x)) {
                done.add(x);
                done.add(a - x);
                //print(x + "" "" + (a - x));
            } else if (all.contains(b - x) && !done.contains(b - x)) {
                done.add(x);
                done.add(b - x);
                inB.add(x);
                inB.add(b - x);
            } else {
                print(""NO"");
                return;
            }
        }

        print(""YES"");
        List<Integer> out = new ArrayList<Integer>();
        for (int x : orig) {
            if (inB.contains(x) ^ swap) out.add(1);
            else out.add(0);
        }
        print(join(out, "" ""));
    }

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));

        int n = nextInt();
        int a = nextInt();
        int b = nextInt();
        List<Integer> nums = nextInts(n);
        solve(a, b, nums);
    }
}
",3,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemB3 {
    Map<Integer, List<int[]>> dest;

    private ProblemB3() throws IOException {
        BufferedReader rd = new BufferedReader(new InputStreamReader(System.in));
        String h = rd.readLine();
        String[] q = h.split(""\\s+"");
        int a = Integer.parseInt(q[1]);
        int b = Integer.parseInt(q[2]);
        h = rd.readLine();
        q = h.split("" "");
        int n = q.length;
        int[] p = new int[n];
        for(int i=0;i<n;i++) {
            p[i] = Integer.parseInt(q[i]);
        }
        Set<Integer> pset = new HashSet<>();
        for(int x: p) {
            pset.add(x);
        }
        dest = new HashMap<>();
        boolean res = true;
        for(int x: p) {
            boolean aOk = pset.contains(a-x);
            boolean bOk = pset.contains(b-x);
            if(!aOk && !bOk) {
                res = false;
                break;
            } else {
                if(aOk) {
                    addEdgeAndBack(x,a-x,0);
                }
                if(bOk) {
                    addEdgeAndBack(x,b-x,1);
                }
            }
        }
        Set<Integer> aSet = new HashSet<>();

        if(res && a != b) {
            for(int x: p) {
                List<int[]> e = getEdges(x);
                if(e.size() == 1) {
                    int[] edge = e.get(0);
                    boolean odd = true;
                    int curA = edge[1];
                    int prev = x;
                    while(true) {
                        int cur = edge[0];
                        if(curA == 0 && odd) {
                            aSet.add(prev);
                            aSet.add(cur);
                        }
                        e = getEdges(cur);
                        if(e.size() == 1) {
                            if(!odd && e.get(0)[0] != cur) {
                                res = false;
                            }
                            break;
                        }
                        int other = e.get(0)[0] == prev?1:0;
                        edge = e.get(other);
                        if(edge[1] == curA) {
                            res = false;
                            break;
                        }
                        curA = 1-curA;
                        prev = cur;
                        odd = !odd;
                    }
                    if(!res) {
                        break;
                    }
                }
            }
        }
        out(res?""YES"":""NO"");
        if(res) {
            StringBuilder buf = new StringBuilder();
            for(int i=0;i<n;i++) {
                if(i>0) {
                    buf.append(' ');
                }
                buf.append(aSet.contains(p[i])?'0':'1');
            }
            out(buf);
        }
    }

    private void addEdgeAndBack(int from, int to, int u) {
        addEdge(from, to, u);
        addEdge(to, from, u);
    }

    private void addEdge(int from, int to, int u) {
        List<int[]> edges = getEdges(from);
        for(int[] edge: edges) {
            if(edge[0] == to) {
                return;
            }
        }
        edges.add(new int[]{to, u});
    }

    private List<int[]> getEdges(int from) {
        List<int[]> ds = dest.get(from);
        if(ds == null) {
            ds = new ArrayList<>();
            dest.put(from, ds);
        }
        return ds;
    }

    private static void out(Object x) {
        System.out.println(x);
    }

    public static void main(String[] args) throws IOException {
        new ProblemB3();
    }
}
",3,3
"import java.util.InputMismatchException;
import java.math.BigInteger;
import java.io.*;
import java.util.*;

/**
 * Generated by Contest helper plug-in
 * Actual solution is at the bottom
 */

public class Main {
	public static void main(String[] args) {
		InputReader in = new StreamInputReader(System.in);
		PrintWriter out = new PrintWriter(System.out);
		run(in, out);
	}

	public static void run(InputReader in, PrintWriter out) {
		Solver solver = new Task();
		solver.solve(1, in, out);
		Exit.exit(in, out);
	}
}

abstract class InputReader {
	private boolean finished = false;

	public abstract int read();

	public long readLong() {
		return new BigInteger(readString()).longValue();
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuffer res = new StringBuffer();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	private boolean isSpaceChar(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public void setFinished(boolean finished) {
		this.finished = finished;
	}

	public abstract void close();
}

class StreamInputReader extends InputReader {
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar, numChars;

	public StreamInputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public void close() {
		try {
			stream.close();
		} catch (IOException ignored) {
		}
	}
}

class Exit {
	private Exit() {
	}

	public static void exit(InputReader in, PrintWriter out) {
		in.setFinished(true);
		in.close();
		out.close();
	}
}

interface Solver {
	public void solve(int testNumber, InputReader in, PrintWriter out);
}

class Task implements Solver {
	public void solve(int testNumber, InputReader in, PrintWriter out) {
		int n = in.readInt();
		int a = in.readInt();
		int b = in.readInt();
		
		if (a==b) {
			b = 0;
		}
		
		boolean[] where = new boolean[n];
		
		HashSet<Integer> set = new HashSet<Integer>();
		HashMap<Integer,Integer> indexmap = new HashMap<Integer,Integer>();
		
		for (int i = 0; i<n; i++) {
			int x = in.readInt();
			indexmap.put(x, i);
			set.add(x);
		}
		
		while (set.size() > 0) {
			int size = set.size();
			HashSet<Integer> todo = new HashSet<Integer>();
			HashSet<Integer> used = new HashSet<Integer>();
			for (int x : set) {
				if (used.contains(x))
					continue;
				int ax = a-x;
				int bx = b-x;
				
				if ((set.contains(ax) && !used.contains(ax)) && (set.contains(bx) && !used.contains(bx))) {
					todo.add(x);
				} else if (set.contains(ax) && !used.contains(ax)) {
					used.add(x);
					used.add(ax);
					todo.remove(ax);
					
					//chain
					bx = b-ax;
					while (set.contains(bx) && !used.contains(bx)) {
						x = bx;
						ax = a-x;
						if (!set.contains(ax) || used.contains(ax)) {
							System.out.println(""NO"");
							return;
						}
						todo.remove(x);
						todo.remove(ax);
						used.add(x);
						used.add(ax);
						bx = b-ax;
					}
					
				} else if (set.contains(bx) && !used.contains(bx)) {
					used.add(x);
					used.add(bx);
					todo.remove(bx);
					where[indexmap.get(bx)] = true;
					where[indexmap.get(x)] = true;
					
					//chain
					ax = a-bx;
					while (set.contains(ax) && !used.contains(ax)) {
						x = ax;
						bx = b-x;
						if (!set.contains(bx) || used.contains(bx)) {
							System.out.println(""NO"");
							return;
						}
						todo.remove(x);
						todo.remove(bx);
						used.add(x);
						used.add(bx);
						where[indexmap.get(bx)] = true;
						where[indexmap.get(x)] = true;
						ax = a-bx;
					}
					
				} else {
					System.out.println(""NO"");
					return;
				}
			}
			set = todo;
			if (set.size() == size) {
				System.out.println(""Set size constant!!"");
				break;
			}
		}
		
		System.out.println(""YES"");
		for (int i = 0; i<n; i++)
			if (where[i])
				System.out.print(""1 "");
			else
				System.out.print(""0 "");
	}
}

class num {
	
	
}

///

",3,3
"import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class Main2 {

	static List<List<Integer>> getLayers(int[] numbers, int a, int b) {
		boolean[] used = new boolean[numbers.length];
		HashSet<Integer> hs = new HashSet<Integer>();
		for (int i = 0; i < numbers.length; i++) {
			hs.add(numbers[i]);
		}
		HashMap<Integer, Integer> numberToIndex = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			numberToIndex.put(numbers[i], i);
		}

		List<List<Integer>> ans = new ArrayList<List<Integer>>();
		for (int i = 0; i < numbers.length; i++) {
			if (!used[i]) {

				List<Integer> ansRow = new ArrayList<Integer>();
				LinkedList<Integer> current = new LinkedList<Integer>();
				current.add(numbers[i]);
				while (!current.isEmpty()) {
					int c = current.removeFirst();
					used[numberToIndex.get(c)] = true;

					boolean found = false;

					if (hs.contains(a - c)) {
						found = true;
						if (a - c != c)
							current.add(a - c);
					}

					if (hs.contains(b - c)) {
						found = true;
						if (b - c != c)
							current.add(b - c);
					}

					if (found || ansRow.size() > 0)
						ansRow.add(c);

					hs.remove(c);
				}

				ans.add(ansRow);
			}
		}

		return ans;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		int a = sc.nextInt();
		int b = sc.nextInt();

		int[] numbers = new int[n];
		for (int i = 0; i < numbers.length; i++) {
			numbers[i] = sc.nextInt();
		}

		HashSet<Integer> hs = new HashSet<Integer>();
		for (int i = 0; i < numbers.length; i++) {
			hs.add(numbers[i]);
		}

		int[] belongs = new int[n];
		for (int i = 0; i < belongs.length; i++) {
			belongs[i] = -1;
		}

		HashMap<Integer, Integer> numberToIndex = new HashMap<Integer, Integer>();
		for (int i = 0; i < numbers.length; i++) {
			numberToIndex.put(numbers[i], i);
		}

		boolean possible = true;

		List<List<Integer>> layers = getLayers(numbers, a, b);
		for (List<Integer> layer : layers) {

			if (layer.size() == 0) {
				System.out.println(""NO"");
				return;
			}

			int starting = -1;
			for (int j = 0; j < layer.size(); j++) {
				int cur = layer.get(j);

				int nei = 0;
				if (hs.contains(a - cur)) {
					nei++;
				}

				if (hs.contains(b - cur)) {
					nei++;
				}

				if (nei == 1 || (a == b && nei == 2)) {
					starting = j;
				}
			}

			if (starting == -1)
				throw new Error();

			int c = layer.get(starting);
			HashSet<Integer> layerset = new HashSet<Integer>(layer);
			while (true) {

				if (layerset.contains(c) && layerset.contains(a - c)) {
					belongs[numberToIndex.get(c)] = 0;
					belongs[numberToIndex.get(a - c)] = 0;
					layerset.remove(c);
					layerset.remove(a - c);
					c = b - (a - c);
				} else if (layerset.contains(c) && layerset.contains(b - c)) {
					belongs[numberToIndex.get(c)] = 1;
					belongs[numberToIndex.get(b - c)] = 1;
					layerset.remove(c);
					layerset.remove(b - c);
					c = a - (b - c);
				} else {
					break;
				}

			}
		}

		printResult(belongs);

	}

	static void printResult(int[] belongs) {

		boolean ok = true;
		for (int i = 0; i < belongs.length; i++) {
			if (belongs[i] < 0)
				ok = false;
		}

		if (ok) {
			System.out.println(""YES"");
			StringBuffer sb = new StringBuffer();

			for (int i = 0; i < belongs.length; i++) {
				sb.append(belongs[i]);
				if (i != belongs.length - 1)
					sb.append("" "");
			}

			System.out.println(sb.toString());
		} else {
			System.out.println(""NO"");
		}
	}

}",3,3
"import java.io.*;
import java.util.*;
public class CF_468B {
    public static void main(String[] args) throws IOException {
        new CF_468B().solve();
    }
    
    int root(int[] father, int a){
        if (father[a]==a) return a;
        else return father[a]=root(father, father[a]);
    }
    void unite(int[] father, int a, int b){
        father[root(father, a)]=root(father, b);
    }
    
    
    private void solve() throws IOException{
        
        InputStream in = System.in;
        PrintStream out = System.out;
        
//        in = new FileInputStream(""in.txt"");
//        out = new PrintStream(""out.txt"");
        
        long mod=1_000_000_007;
        Scanner sc=new Scanner(in);
        int n=sc.nextInt();
        long a=sc.nextLong(), b=sc.nextLong();

        int[] father=new int[n];
        long[] p=new long[n];
        HashMap<Long, Integer> pos=new HashMap<Long, Integer>();
        for (int i=0;i<n;i++){
            father[i]=i;
            p[i]=sc.nextLong();
            pos.put(p[i],i);
        }        
        for (int i=0;i<n;i++){
            if (pos.containsKey(a-p[i])) unite(father,i,pos.get(a-p[i]) );
            if (pos.containsKey(b-p[i])) unite(father,i,pos.get(b-p[i]) );
        }
        boolean[] canA=new boolean[n],
                canB=new boolean[n];
        Arrays.fill(canA,true);
        Arrays.fill(canB,true);
        for (int i=0;i<n;i++){
            if (!pos.containsKey(a-p[i]) || 
                    root(father, i)!=root(father, pos.get(a-p[i]))) 
                canA[root(father, i)]=false;
            if (!pos.containsKey(b-p[i]) || 
                    root(father, i)!=root(father, pos.get(b-p[i]))) 
                canB[root(father, i)]=false;
            if (!canA[root(father,i)] && !canB[root(father,i)]){
                out.println(""NO"");
                return;                    
            }
        }
        out.println(""YES"");
        for (int i=0;i<n;i++)
            if (canA[root(father, i)])
                out.print(""0 "");
            else
                out.print(""1 "");
            
                
    }
}


",3,3
"
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.StringTokenizer;

public class Main {

    
    private PrintWriter out;
    private Map<Integer, Integer> map;
    
    private int arr[], ans[];
    int n, a, b;
 
    class DSU {
        private int[] p, size;
        
        public DSU(int n) {
            p = new int[n];
            size = new int[n];
            
            for (int i=0; i<n; i++) {
                p[i] = i;
                size[i] = 1;
            }
        }
        
        public int find(int i) {
            if (p[i] == i) {
                return i;
            }
            return p[i] = find(p[i]);
        }
        
        public void union (int a, int b) {
            a = find(a); b = find(b);
            if (size[a] > size[b]) {
                p[b] = a;
                size[a] += size[b];
            } else {
                p[a] = b;
                size[b] += size[a];
            }
        }
    }
    
    private void solve() throws Exception {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(in.readLine());
        
        n = Integer.valueOf(st.nextToken());
        a = Integer.valueOf(st.nextToken());
        b = Integer.valueOf(st.nextToken());
        map = new HashMap<Integer, Integer>(n);
        
        String line = in.readLine();
        StringTokenizer st1 = new StringTokenizer(line);
        
        arr = new int[n];
        ans = new int[n];
        DSU dsu = new DSU(n);
        
        for (int i=0; i<n; i++) {
            arr[i] = Integer.valueOf(st1.nextToken());
            map.put(arr[i], i);
        }
        in.close();
        
        for (int i=0; i<n; i++) {
            boolean f = false;
            if (map.get(a - arr[i]) != null) {
                f = true;
                dsu.union(i, map.get(a - arr[i]));
            }
            
            if (map.get(b - arr[i]) != null) {
                f = true;
                dsu.union(i, map.get(b - arr[i]));
            }
            
            if (!f) {
                out.println(""NO"");
                out.flush();
                return;
            }
        }
        
        for (int i=0; i<n; i++) {
            int p = dsu.find(i);
            if (map.get(a - arr[i]) == null) {
                ans[p] = 1;
            } else if (map.get(b - arr[i]) == null) {
                ans[p] = 0;
            }
        }
        
        for (int i=0; i<n; i++) {
            int p = dsu.find(i);
            if (ans[p] == 0 && map.get(a - arr[i]) == null) {
                out.println(""NO"");
                out.flush();
                return;
            } 
            
            if (ans[p] == 1 && map.get(b - arr[i]) == null) {
                out.println(""NO"");
                out.flush();
                return;
            }
        }
        
        out.println(""YES"");
        for (int i=0; i<n; i++) {
            out.print(ans[dsu.find(i)] + "" "");
        }
                
        out.flush();
        out.close();
    }

    public static void main(String[] args) throws Exception {
        new Main().solve();
    }
}",3,3
"import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.TreeMap;

public class Main {

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedInputStream(System.in));
        PrintWriter out = new PrintWriter(new BufferedWriter(
                new OutputStreamWriter(System.out)));

        while (in.hasNext()) {
            int n = in.nextInt(), a = in.nextInt(), b = in.nextInt(), c = 0;
            int[] p = new int[n];

            TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();
            for (int i = 0; i < n; i++) {
                p[i] = in.nextInt();
                map.put(p[i], i);
            }
            
            if (a > b) {
                int t = b;
                b = a;
                a = t;
                c = 1;
            }

            boolean ok = true;
            int[] cls = new int[n];
            while (ok && map.size() > 0) {
                Entry<Integer, Integer> last = map.lastEntry();
                int v = last.getKey();
                int idx = last.getValue();
                if (map.containsKey(a - v)) {
                    cls[idx] = 0;
                    cls[map.get(a - v)] = 0;
                    map.remove(v);
                    map.remove(a -v);
                } else if (map.containsKey(b - v)) {
                    cls[idx] = 1;
                    cls[map.get(b - v)] = 1;
                    map.remove(v);
                    map.remove(b -v);
                } else 
                    ok = false;
            }

            if (!ok)
                System.out.println(""NO"");
            else {
                System.out.println(""YES"");
                for (int j = 0; j < cls.length; j++) {
                    if (j != 0)
                        System.out.print("" "");
                    System.out.print(c ^ cls[j]);
                }
                System.out.println();
            }
            out.flush();
        }
        in.close();
    }

}",3,5
"import java.io.IOException;
import java.util.Arrays;
import java.util.TreeMap;
import java.util.InputMismatchException;
import java.util.ArrayList;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author George Marcus
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
    ArrayList<Integer>[] G;
    int[] st, dr;
    boolean[] v;

    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int N = in.nextInt();
        int a = in.nextInt();
        int b = in.nextInt();
        int[] A = new int[N];
        TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();
        for (int i = 0; i < N; i++) {
            A[i] = in.nextInt();
            map.put(A[i], i);
        }
        G = new ArrayList[N];
        for (int i = 0; i < N; i++) {
            G[i] = new ArrayList<Integer>();
        }

        for (int i = 0; i < N; i++) {
            int val = a - A[i];
            if (map.containsKey(val)) {
                int p = map.get(val);
//                if (p != i) {
                    G[i].add(p);
                    G[p].add(i);
//                }
            }
            val = b - A[i];
            if (map.containsKey(val)) {
                int p = map.get(val);
//                if (p != i) {
                    G[i].add(p);
                    G[p].add(i);
//                }
            }
        }

        st = new int[N];
        dr = new int[N];
        Arrays.fill(st, -1);
        Arrays.fill(dr, -1);
        v = new boolean[N];

        boolean ok = true;
        int match = 0;
        while (ok) {
            ok = false;
            Arrays.fill(v, false);
            for (int i = 0; i < N; i++) {
                if (dr[i] == -1) {
                    if (pairup(i)) {
                        ok = true;
                        match++;
                    }
                }
            }
        }

        if (match == N) {
            out.println(""YES"");
            for (int i = 0; i < N; i++) {
                if (i > 0) {
                    out.print("" "");
                }
                int other = dr[i];
                if (A[i] == b - A[other]) {
                    out.print(1);
                }
                else {
                    out.print(0);
                }
            }
        }
        else {
            out.println(""NO"");
        }
    }

    private boolean pairup(int node) {
        if (v[node]) {
            return false;
        }
        v[node] = true;
        for (int x : G[node]) {
            if (st[x] == -1) {
                st[x] = node;
                dr[node] = x;
                return true;
            }
        }
        for (int x : G[node]) {
            if (pairup(st[x])) {
                st[x] = node;
                dr[node] = x;
                return true;
            }
        }
        return false;
    }
}

class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int nextInt() {
        return Integer.parseInt(nextString());
    }

    public String nextString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuffer res = new StringBuffer();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));

        return res.toString();
    }

    private boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

}

",3,3
"import java.util.*;
import java.io.*;
public class b {
public static void main(String[] args) throws IOException
{
    input.init(System.in);
    PrintWriter out = new PrintWriter(System.out);
    int n = input.nextInt(), a = input.nextInt(), b = input.nextInt();
    Num[] data = new Num[n];
    for(int i = 0; i<n; i++) data[i] = new Num(input.nextInt(), i);
    int[] res = new int[n];
    Arrays.fill(res,-1);
    Arrays.sort(data);
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    for(int i = 0; i<n; i++)
        map.put(data[i].x, data[i].i);
    boolean good = true;
    for(int i = 0; i<n; i++)
    {
        if(res[data[i].i] != -1) continue;
        int val = data[i].x;
        if(!map.containsKey(a-val) && !map.containsKey(b-val))
        {
            good = false;
            break;
        }
        if(!map.containsKey(a-val))
        {
            int other = map.get(b-val);
            if(res[other] == 0)
            {
                good = false;
                break;
            }
            res[other] = res[data[i].i] = 1;
        }
        else if(!map.containsKey(b-val))
        {
            int other = map.get(a-val);
            if(res[other] == 1)
            {
                good = false;
                break;
            }
            res[other] = res[data[i].i] = 0;
        }
        else
        {
            int cur = data[i].i;
            int otherB = map.get(b-val), otherA = map.get(a-val);
            if(b > a && res[otherB] != 0)
            {
                res[cur] = res[otherB] = 1;
            }
            else if(a>b && res[otherA] != 1)
            {
                res[cur] = res[otherA] = 0;
            }
            else if(b > a && res[otherA] != 1)
            {
                res[cur] = res[otherA] = 0;
            }
            else if(a > b && res[otherB] != 0)
            {
                res[cur] = res[otherB] = 1;
            }
            else if(b == a)
            {
                res[cur] = res[otherA] = 0;
            }
            else
            {
                good = false;
                break;
            }
        }
    }
    if(good)
    {
        out.println(""YES"");
        for(int x: res) out.print(x+"" "");
    }
    else
        out.println(""NO"");
    
    out.close();
}
static class Num implements Comparable<Num>
{
    int x, i;
    public Num(int xx, int ii)
    {
        x = xx; i = ii;
    }
    @Override
    public int compareTo(Num o) {
        // TODO Auto-generated method stub
        return x - o.x;
    }
}
public static class input {
    static BufferedReader reader;
    static StringTokenizer tokenizer;

    /** call this method to initialize reader for InputStream */
    static void init(InputStream input) {
        reader = new BufferedReader(
                     new InputStreamReader(input) );
        tokenizer = new StringTokenizer("""");
    }

    /** get next word */
    static String next() throws IOException {
        while ( ! tokenizer.hasMoreTokens() ) {
            //TODO add check for eof if necessary
            tokenizer = new StringTokenizer(
                   reader.readLine() );
        }
        return tokenizer.nextToken();
    }

    static int nextInt() throws IOException {
        return Integer.parseInt( next() );
    }
    
    static double nextDouble() throws IOException {
        return Double.parseDouble( next() );
    }
    static long nextLong() throws IOException {
        return Long.parseLong( next() );
    }
}
}
",3,3
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.InputMismatchException;
import java.util.Map;

/**
 * Created by hama_du on 2014/09/21.
 */
public class ProblemB {
    public static void main(String[] args) {
        InputReader in = new InputReader(System.in);
        PrintWriter out = new PrintWriter(System.out);

        int n = in.nextInt();
        long a = in.nextLong();
        long b = in.nextLong();
        long[] x = new long[n];
        for (int i = 0; i < n; i++) {
            x[i] = in.nextLong();
        }

        Map<Long,Integer> idxmap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            idxmap.put(x[i], i);
        }
        if (a == b) {
            solve1(x, a, idxmap, out);
            return;
        }

        int[] mark = new int[n];
        Arrays.fill(mark, -1);
        boolean isok = true;
        for (int i = 0 ; i < n ; i++) {
            if (mark[i] != -1) {
                continue;
            }
            long w = x[i];
            long aw = a - w;
            long bw = b - w;
            if (idxmap.containsKey(aw) && idxmap.containsKey(bw)) {
                continue;
            } else if (idxmap.containsKey(bw)) {
                long w1 = w;
                long w2 = bw;
                while (true) {
                    if (!idxmap.containsKey(w1) || !idxmap.containsKey(w2)) {
                        break;
                    }
                    int i1 = idxmap.get(w1);
                    int i2 = idxmap.get(w2);
                    if (mark[i1] == 0 || mark[i2] == 0) {
                        isok = false;
                    }
                    mark[i1] = 1;
                    mark[i2] = 1;
                    if (w1 + a - b == w2) {
                        break;
                    }
                    w1 += (a - b);
                    w2 += (b - a);
                }
            } else if (idxmap.containsKey(aw)){
                long w1 = w;
                long w2 = aw;
                while (true) {
                    if (!idxmap.containsKey(w1) || !idxmap.containsKey(w2)) {
                        break;
                    }
                    int i1 = idxmap.get(w1);
                    int i2 = idxmap.get(w2);
                    if (mark[i1] == 1 || mark[i2] == 1) {
                        isok = false;
                    }
                    mark[i1] = 0;
                    mark[i2] = 0;
                    if (w1 + b - a == w2) {
                        break;
                    }
                    w1 += (b - a);
                    w2 += (a - b);
                }
            }
        }
        for (int i = 0 ; i < n ; i++) {
            if (mark[i] == -1) {
                isok = false;
                break;
            }
        }
        if (isok) {
            printAnswer(mark, out);
        } else {
            out.println(""NO"");
        }
        out.flush();
    }

    private static void printAnswer(int[] mark, PrintWriter out) {
        out.println(""YES"");
        StringBuilder ln = new StringBuilder();
        for (int m : mark) {
            ln.append(' ').append(m);
        }
        out.println(ln.substring(1));
    }

    private static void solve1(long[] x, long a, Map<Long, Integer> idxmap, PrintWriter out) {
        int[] mark = new int[x.length];
        for (int i = 0 ; i < x.length ; i++) {
            if (mark[i] == 1) {
                continue;
            }
            long w = x[i];
            long wp = a - w;
            if (idxmap.containsKey(wp)) {
                mark[i] = mark[idxmap.get(wp)] = 1;
            }
        }
        boolean isok = true;
        for (int i = 0 ; i < x.length ; i++) {
            if (mark[i] == 0) {
                isok = false;
                break;
            }
        }
        if (isok) {
            printAnswer(mark, out);
        } else {
            out.println(""NO"");
        }
        out.flush();
    }

    public static void debug(Object... o) {
        System.err.println(Arrays.deepToString(o));
    }


    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int next() {
            if (numChars == -1)
                throw new InputMismatchException();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = next();
            while (isSpaceChar(c))
                c = next();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = next();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = next();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public long nextLong() {
            int c = next();
            while (isSpaceChar(c))
                c = next();
            long sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = next();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = next();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
}
",3,3
"
import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.TreeMap;

public class Main {

	public static void main(String[] args) {

		Scanner in = new Scanner(new BufferedInputStream(System.in));
		PrintWriter out = new PrintWriter(new BufferedWriter(
				new OutputStreamWriter(System.out)));

		while (in.hasNext()) {
			int n = in.nextInt(), a = in.nextInt(), b = in.nextInt(), c = 0;
			int[] p = new int[n];

			TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();
			for (int i = 0; i < n; i++) {
				p[i] = in.nextInt();
				map.put(p[i], i);
			}
			
			if (a > b) {
				int t = b;
				b = a;
				a = t;
				c = 1;
			}

			boolean ok = true;
			int[] cls = new int[n];
			while (ok && map.size() > 0) {
				Entry<Integer, Integer> last = map.lastEntry();
				int v = last.getKey();
				int idx = last.getValue();
				if (map.containsKey(a - v)) {
					cls[idx] = 0;
					cls[map.get(a - v)] = 0;
					map.remove(v);
					map.remove(a -v);
				} else if (map.containsKey(b - v)) {
					cls[idx] = 1;
					cls[map.get(b - v)] = 1;
					map.remove(v);
					map.remove(b -v);
				} else 
					ok = false;
			}

			if (!ok)
				System.out.println(""NO"");
			else {
				System.out.println(""YES"");
				for (int j = 0; j < cls.length; j++) {
					if (j != 0)
						System.out.print("" "");
					System.out.print(c ^ cls[j]);
				}
				System.out.println();
			}
			out.flush();
		}
		in.close();
	}

}
",3,5
"import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.util.Set;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.HashSet;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Mahmoud Aladdin <aladdin3>
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		TaskD solver = new TaskD();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskD {
    public void solve(int testNumber, InputReader jin, OutputWriter jout) {
        int n = jin.int32();
        int a = jin.int32();
        int b = jin.int32();



        Set<Integer> present = new HashSet<Integer>();
        int[] arr = new int[n];
        int[] sarr = new int[n];
        for(int i = 0; i < n; i++) {
            sarr[i] = arr[i] = jin.int32();
            present.add(arr[i]);
        }

        boolean rev = b < a;
        if(b < a) {b ^= a; a ^= b; b ^= a; }

        Arrays.sort(sarr);

        Set<Integer> set1 = new HashSet<Integer>();
        Set<Integer> set2 = new HashSet<Integer>();

        for(int i = 0; i < n; i++) {
            if(set1.contains(sarr)) continue;
            if(set2.contains(sarr)) continue;
            int comp1 = b - sarr[i];
            if(present.contains(comp1)) {
                set2.add(sarr[i]);
                set2.add(comp1);
                present.remove(comp1);
            } else {
                int comp2 = a - sarr[i];
                if(present.contains(comp2)) {
                    set1.add(sarr[i]);
                    set1.add(comp2);
                    present.remove(comp2);
                } else {
                    jout.println(""NO"");
                    return;
                }
            }
        }

        jout.println(""YES"");
        for(int i = 0; i < n; i++) {
            if(i != 0) jout.print(' ');
            if(rev) jout.print(set2.contains(arr[i])? 0 : 1);
            else jout.print(set1.contains(arr[i])? 0 : 1);
        }
    }
}

class InputReader {
    private static final int bufferMaxLength = 1024;
    private InputStream in;
    private byte[] buffer;
    private int currentBufferSize;
    private int currentBufferTop;
    private static final String tokenizers = "" \t\r\f\n"";
    
    public InputReader(InputStream stream) {
        this.in = stream;
        buffer = new byte[bufferMaxLength];
        currentBufferSize = 0;
        currentBufferTop = 0;
    }
    
    private boolean refill() {
        try {
            this.currentBufferSize = this.in.read(this.buffer);
            this.currentBufferTop = 0;
        } catch(Exception e) {}
        return this.currentBufferSize > 0;
    }
    
    
    private Byte readChar() {
        if(currentBufferTop < currentBufferSize) {
            return this.buffer[this.currentBufferTop++];
        } else {
            if(!this.refill()) {
                return null;
            } else {
                return readChar();
            }
        }
    }

    public String token()  {
        StringBuffer tok = new StringBuffer();
        Byte first;
        while((first = readChar()) != null && (tokenizers.indexOf((char) first.byteValue()) != -1));
        if(first == null) return null;
        tok.append((char)first.byteValue());
        while((first = readChar()) != null && (tokenizers.indexOf((char) first.byteValue()) == -1)) {
            tok.append((char)first.byteValue());
        }
        return tok.toString();
    }
    
    public Integer int32() throws NumberFormatException {
        String tok = token();
        return tok == null? null : Integer.parseInt(tok);
    }

    }

class OutputWriter {
    private final int bufferMaxOut = 1024;
    private PrintWriter out;
    private StringBuilder output;
    private boolean forceFlush = false;

    public OutputWriter(OutputStream outStream) {
        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outStream)));
        output = new StringBuilder(2 * bufferMaxOut);
    }

    public OutputWriter(Writer writer) {
        forceFlush = true;
        out = new PrintWriter(writer);
        output = new StringBuilder(2 * bufferMaxOut);
    }

    private void autoFlush() {
        if(forceFlush || output.length() >= bufferMaxOut) {
            flush();
        }
    }

    public void print(Object... tokens) {
        for(int i = 0; i < tokens.length; i++) {
            if(i != 0) output.append(' ');
            output.append(tokens[i]);
        }
        autoFlush();
    }

    public void println(Object... tokens) {
        print(tokens);
        output.append('\n');
        autoFlush();
    }

    public void flush() {
        out.print(output);
        output.setLength(0);
    }

    public void close() {
        flush();
        out.close();
    }
}

",3,3
"import java.util.HashMap;
import java.util.HashSet;
import java.util.Scanner;


public class Main {
	
	static int n;
	static int a;
	static int b;
	static int g;
	static int ref;
	static int refg;
	static HashSet<Integer> cgroup;
	static HashMap<Integer,Integer> indexmap;
	static HashSet<Integer> nums;
	static HashSet<Integer> used;
	
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		n = scan.nextInt();
		a = scan.nextInt();
		b = scan.nextInt();
		
		boolean[] where = new boolean[n];
		indexmap = new HashMap<Integer,Integer>();
		used = new HashSet<Integer>();
		nums = new HashSet<Integer>();
		
		if (a==b)
			b = 0;
		
		for (int i = 0; i<n; i++) {
			int x = scan.nextInt();
			nums.add(x);
			indexmap.put(x,i);
		}
		scan.close();
		
		for (int x : nums) {
			if (used.contains(x))
				continue;
			cgroup = new HashSet<Integer>();
			cgroup.add(x);
			g = -1;
			refg = -1;
			ref = -1;
			used.add(x);
			if (!spawn(x,a,b) || !spawn(x,b,a)) {
				System.out.println(""NO"");
				return;
			}
			if (cgroup.size()%2==1 && ref == -1) {
				System.out.println(""NO"");
				return;
			} else {
				boolean w = true;
				if (g == a)
					w = false;
				for (int k : cgroup) {
					where[indexmap.get(k)] = w;
				}
			}
		}
		
		System.out.println(""YES"");
		for (int i = 0; i<where.length; i++)
			if (where[i])
				System.out.print(""1 "");
			else
				System.out.print(""0 "");
		
	}

	private static boolean spawn(int x, int ab, int abo) {
		int xab = ab-x;
		if (xab == x) {
			ref = x;
			refg = ab;
		} else {
			if (nums.contains(xab)) {
				cgroup.add(xab);
				used.add(xab);
				spawn(xab,abo,ab);
			} else {
				if (g == -1)
					g = abo;
				else if (g != abo) {
					return false;
				}
			}
		}
		return true;
	}

}",3,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Queue;
import java.util.StringTokenizer;

public class CF268_TwoSets {

	public static void main(String[] args) {

		MyScanner in = new MyScanner();

		int N = in.nextInt();
		int a = in.nextInt();
		int b = in.nextInt();

		int[] vals = new int[N];
		HashMap<Integer, Integer> val2Ind = new HashMap<Integer, Integer>();
		for (int i = 0; i < N; i++) {
			vals[i] = in.nextInt();
			val2Ind.put(vals[i], i);
		}

		int[] setAssignment = new int[N];
		int[] friendA = new int[N];
		int[] friendB = new int[N];
		Arrays.fill(setAssignment, -1);
		Arrays.fill(friendA, -1);
		Arrays.fill(friendB, -1);

		// Mark partners
		for (int i = 0; i < N; i++) {
			Integer friendAInd = val2Ind.get(a - vals[i]);
			if (friendAInd != null) {
				friendA[i] = friendAInd;
			}

			Integer friendBInd = val2Ind.get(b - vals[i]);
			if (friendBInd != null) {
				friendB[i] = friendBInd;
			}
		}

		// Find those with only one friend
		Queue<Integer> toProc = new ArrayDeque<Integer>();
		for (int i = 0; i < N; i++) {
			int friends = 0;
			if (friendA[i] != -1) {
				friends++;
			}
			if (friendB[i] != -1) {
				friends++;
			}
			if (friends == 1) {
				toProc.add(i);
			}
		}

		// Process the one frienders
		while (!toProc.isEmpty()) {

			int ind = toProc.poll();

			if (setAssignment[ind] != -1) {
				continue;
			}

			if (friendA[ind] != -1) {

				int other = friendA[ind];
				if (setAssignment[other] == -1) {
					setAssignment[ind] = 0;
					setAssignment[other] = 0;
					// Check other's friend
					if (friendB[other] != -1) {
						int otherOther = friendB[other];
						friendB[otherOther] = -1;
						toProc.add(otherOther);
					}
				} else {
					System.out.println(""NO"");
					return;
				}

			}

			else if (friendB[ind] != -1) {

				int other = friendB[ind];
				if (setAssignment[other] == -1) {
					setAssignment[ind] = 1;
					setAssignment[other] = 1;
					// Check other's friend
					if (friendA[other] != -1) {
						int otherOther = friendA[other];
						friendA[otherOther] = -1;
						toProc.add(otherOther);
					}
				} else {
					System.out.println(""NO"");
					return;
				}

			}

			else {
				System.out.println(""NO"");
				return;
			}

		}
		
		
		// Process those with two friends
		for(int i = 0; i < N; i++) {
			
			if(setAssignment[i] != -1) {
				continue;
			}
			
			if(friendA[i] == -1 && friendB[i] == -1) {
				System.out.println(""NO"");
				return;
			}
			
			// Only possibility should now be that both friends are possible
			setAssignment[i] = 0;
			setAssignment[friendA[i]] = 0;
		}
		
		// Print the result
		System.out.println(""YES"");
		StringBuilder sb = new StringBuilder();
		for(int i = 0; i < N; i++) {
			sb.append(setAssignment[i]);
			sb.append("" "");
		}
		sb.deleteCharAt(sb.length() - 1);
		System.out.println(sb);
	}

	public static class MyScanner {
		BufferedReader br;
		StringTokenizer st;

		public MyScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}

	}

}
",3,3
"
import java.util.*;
import java.util.Map.Entry;
import java.io.*;

public class A{

    public static void main(String args[]){
        FastScanner in = new FastScanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int n = in.nextInt();
        int a = in.nextInt();
        int b = in.nextInt();
        boolean change = false;
        if(a > b){
            int t = a;
            a = b;
            b = t;
            change = true;
        }
        boolean[] inb = new boolean[n];
        int[] numbers = new int[n];
        TreeMap<Integer, Integer> num = new TreeMap<Integer, Integer>();
        for(int i = 0; i < n; i++){
            num.put(in.nextInt(), i);
        }
        boolean hasAns = true;
        while(!num.isEmpty()){
            Entry<Integer, Integer> last = num.lastEntry();
            int key = last.getKey();
            if(num.containsKey(a - key)){
                num.remove(key);
                num.remove(a - key);
            } else if(num.containsKey(b - key)){
                inb[num.get(key)] = true;
                inb[num.get(b - key)] = true;
                num.remove(key);
                num.remove(b - key);
            } else{
                hasAns = false;
                break;
            }
        }
        if(hasAns){
            out.println(""YES"");
            for(int i = 0; i < n && !change; i++){
                if(inb[i]){
                    out.print(""1"");
                } else{
                    out.print(""0"");
                }
                if(i != n - 1){
                    out.print("" "");
                }
            }
            for(int i = 0; i < n && change; i++){
                if(inb[i]){
                    out.print(""0"");
                } else{
                    out.print(""1"");
                }
                if(i != n - 1){
                    out.print("" "");
                }
            }
        } else{
            out.println(""NO"");
        }
        out.close();
    }

    static class FastScanner{
        private BufferedReader reader;

        private StringTokenizer tokenizer;

        public FastScanner(InputStream stream){
            reader = new BufferedReader(new InputStreamReader(stream));
            tokenizer = null;
        }

        public String nextLine(){
            try{
                return reader.readLine();
            } catch(IOException e){
                e.printStackTrace();
                return null;
            }
        }

        public String next(){
            while(tokenizer == null || !tokenizer.hasMoreTokens()){
                try{
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch(IOException e){
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt(){
            return Integer.parseInt(next());
        }

        public long nextLong(){
            return Long.parseLong(next());
        }

        public double nextDouble(){
            return Double.parseDouble(next());
        }
    }
}
",3,3
"import java.io.*;
import java.util.*;

public class B {

    void solve() throws IOException {
        in = new InputReader(""__std"");
        out = new OutputWriter(""__std"");

        int n = in.readInt();
        int a = in.readInt();
        int b = in.readInt();
        int ma = 0;
        int mb = 1;
        if (a < b) {
            int t = a; a = b; b = t;
            t = ma; ma = mb; mb = t;
        }
        final int[] p = new int[n];
        Integer id[] = new Integer[n];
        Map<Integer, Integer> pos = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; ++i) {
            p[i] = in.readInt();
            id[i] = i;
            pos.put(p[i], i);
        }
        Arrays.sort(id, new Comparator<Integer>() {
            public int compare(Integer i, Integer j) {
                return p[i] - p[j];
            }
        });
        int[] mask = new int[n];
        Arrays.fill(mask, -1);
        boolean flag = true;
        for (int i = 0; i < n && flag; ++i) {
            if (mask[id[i]] == -1) {
                if (p[id[i]] < a) {
                    if (pos.containsKey(a - p[id[i]])) {
                        int j = pos.get(a - p[id[i]]);
                        if (mask[j] != mb) {
                            mask[id[i]] = mask[j] = ma;
                            continue;
                        }
                    }
                    if (p[id[i]] < b && pos.containsKey(b - p[id[i]])) {
                        int j = pos.get(b - p[id[i]]);
                        if (mask[j] != ma) {
                            mask[id[i]] = mask[j] = mb;
                            continue;
                        }
                    }
                }
                flag = false;
            }
        }
        if (flag) {
            out.println(""YES"");
            for (int m : mask) {
                out.print(m + "" "");
            }
        } else {
            out.println(""NO"");
        }

        exit();
    }

    void exit() {
        //System.err.println((System.currentTimeMillis() - startTime) + "" ms"");
        out.close();
        System.exit(0);
    }

    InputReader in;
    OutputWriter out;

    //long startTime = System.currentTimeMillis();

    public static void main(String[] args) throws IOException {
        new B().solve();
    }

    class InputReader {

        private InputStream stream;

        private byte[] buffer = new byte[1024];
        private int pos, len;

        private int cur;

        private StringBuilder sb = new StringBuilder(32);

        InputReader(String name) throws IOException {
            if (name.equals(""__std"")) {
                stream = System.in;
            } else {
                stream = new FileInputStream(name);
            }
            cur = read();
        }

        private int read() throws IOException {
            if (len == -1) {
                throw new EOFException();
            }
            if (pos >= len) {
                pos = 0;
                len = stream.read(buffer);
                if (len == -1) return -1;
            }
            return buffer[pos++];
        }

        char readChar() throws IOException {
            if (cur == -1) {
                throw new EOFException();
            }
            char res = (char) cur;
            cur = read();
            return res;
        }

        int readInt() throws IOException {
            if (cur == -1) {
                throw new EOFException();
            }
            while (whitespace()) {
                cur = read();
            }
            if (cur == -1) {
                throw new EOFException();
            }
            int sign = 1;
            if (cur == '-') {
                sign = -1;
                cur = read();
            }
            int res = 0;
            while (!whitespace()) {
                if (cur < '0' || cur > '9') {
                    throw new NumberFormatException();
                }
                res *= 10;
                res += cur - '0';
                cur = read();
            }
            return res * sign;
        }

        long readLong() throws IOException {
            if (cur == -1) {
                throw new EOFException();
            }
            return Long.parseLong(readToken());
        }

        double readDouble() throws IOException {
            if (cur == -1) {
                throw new EOFException();
            }
            return Double.parseDouble(readToken());
        }

        String readLine() throws IOException {
            if (cur == -1) {
                throw new EOFException();
            }
            sb.setLength(0);
            while (cur != -1 && cur != '\r' && cur != '\n') {
                sb.append((char) cur);
                cur = read();
            }
            if (cur == '\r') {
                cur = read();
            }
            if (cur == '\n') {
                cur = read();
            }
            return sb.toString();
        }

        String readToken() throws IOException {
            if (cur == -1) {
                throw new EOFException();
            }
            while (whitespace()) {
                cur = read();
            }
            if (cur == -1) {
                throw new EOFException();
            }
            sb.setLength(0);
            while (!whitespace()) {
                sb.append((char) cur);
                cur = read();
            }
            return sb.toString();
        }

        boolean whitespace() {
            return cur == ' ' || cur == '\t' || cur == '\r' || cur == '\n' || cur == -1;
        }

        boolean eof() {
            return cur == -1;
        }
    }

    class OutputWriter {

        private PrintWriter writer;

        OutputWriter(String name) throws IOException {
            if (name.equals(""__std"")) {
                writer = new PrintWriter(System.out);
            } else {
                writer = new PrintWriter(name);
            }
        }

        void print(String format, Object ... args) {
            writer.print(new Formatter(Locale.US).format(format, args));
        }

        void println(String format, Object ... args) {
            writer.println(new Formatter(Locale.US).format(format, args));
        }

        void print(Object value) {
            writer.print(value);
        }

        void println(Object value) {
            writer.println(value);
        }

        void println() {
            writer.println();
        }

        void close() {
            writer.close();
        }
    }
}
",3,3
"import java.util.ArrayList;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.io.BufferedReader;
import java.util.List;
import java.util.Map;
import java.math.BigInteger;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.util.StringTokenizer;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author shu_mj @ XXXX
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		Scanner in = new Scanner(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
    Scanner in;
    PrintWriter out;

    public void solve(int testNumber, Scanner in, PrintWriter out) {
        this.in = in;
        this.out = out;
        run();
    }

    void run() {
        int n = in.nextInt();
        int a = in.nextInt();
        int b = in.nextInt();
        int[] is = in.nextIntArray(n);
        Map<Integer, Integer> id = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            id.put(is[i], i);
        }
        SCC.V[] vs = new SCC.V[n * 2];
        for (int i = 0; i < vs.length; i++) vs[i] = new SCC.V();
        for (int i = 0; i < n; i++) {
            if (id.containsKey(a - is[i])) {
                int j = id.get(a - is[i]);
                vs[i].add(vs[j]);
                vs[j + n].add(vs[i + n]);
            } else {
                vs[i].add(vs[i + n]);
            }
            if (id.containsKey(b - is[i])) {
                int j = id.get(b - is[i]);
                vs[i + n].add(vs[j + n]);
                vs[j].add(vs[i]);
            } else {
                vs[i + n].add(vs[i]);
            }
        }
        SCC.scc(vs);
        for (int i = 0; i < n; i++) {
            if (vs[i].comp == vs[i + n].comp) {
                out.println(""NO"");
                return ;
            }
        }
        out.println(""YES"");
        for (int i = 0; i < n; i++) {
            if (vs[i].comp > vs[i + n].comp) {
                out.print(""0 "");
            } else {
                out.print(""1 "");
            }
        }
        out.println();
    }
}

class Scanner {
    BufferedReader br;
    StringTokenizer st;

    public Scanner(InputStream in) {
        br = new BufferedReader(new InputStreamReader(in));
        eat("""");
    }

    private void eat(String s) {
        st = new StringTokenizer(s);
    }

    public String nextLine() {
        try {
            return br.readLine();
        } catch (IOException e) {
            return null;
        }
    }

    public boolean hasNext() {
        while (!st.hasMoreTokens()) {
            String s = nextLine();
            if (s == null)
                return false;
            eat(s);
        }
        return true;
    }

    public String next() {
        hasNext();
        return st.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    public int[] nextIntArray(int n) {
        int[] is = new int[n];
        for (int i = 0; i < n; i++) {
            is[i] = nextInt();
        }
        return is;
    }

}

class SCC {

    public static int n;
    public static V[] us;

    public static int scc(V[] vs) {
        n = vs.length;
        us = new V[n];
        for (V v : vs) if (!v.visit) dfs(v);
        for (V v : vs) v.visit = false;
        for (V u : us) if (!u.visit) dfsRev(u, n++);
        return n;
    }

    public static void dfs(V v) {
        v.visit = true;
        for (V u : v.fs) if (!u.visit) dfs(u);
        us[--n] = v;
    }

    public static void dfsRev(V v, int k) {
        v.visit = true;
        for (V u : v.rs) if (!u.visit) dfsRev(u, k);
        v.comp = k;
    }

    public static class V {
        public boolean visit;
        public int comp;
        public List<V> fs = new ArrayList<V>();
        public List<V> rs = new ArrayList<V>();

        public void add(V u) {
            fs.add(u);
            u.rs.add(this);
        }
    }
}

",3,3
"import java.io.*;
import java.math.BigInteger;
import java.util.*;


public class B {

    void solve() throws IOException {
        int n=nextInt();
        int a=nextInt();
        int b=nextInt();
        int[] p=new int[n];
        for(int i=0;i<n;i++)p[i]=nextInt();
//        if(n%2==1){
//            out.println(""NO"");
//            return;
//        }
        TreeSet<Integer>[] s=new TreeSet[n];
        for(int i=0;i<n;i++)s[i]=new TreeSet<Integer>();
        HashMap<Integer,Integer> m=new HashMap<Integer, Integer>();
        for(int i=0;i<n;i++)
            m.put(p[i],i);
        for(int i=0;i<n;i++){
            if(m.containsKey(a-p[i])){
                s[i].add(a-p[i]);
                s[m.get(a-p[i])].add(p[i]);
            }
            if(m.containsKey(b-p[i])){
                s[i].add(b-p[i]);
                s[m.get(b-p[i])].add(p[i]);
            }
        }
        int last=-1;
        LinkedList<Integer> q=new LinkedList<Integer>();
        for(int i=0;i<n;i++){
            if(s[i].size()==0){
                out.println(""NO"");
                return;
            }
            if(s[i].size()==1){
                q.add(i);
            }
        }
        int[] ans=new int[n];
        while(last!=n){
            while(!q.isEmpty()){
                int cur=q.poll();
                if(s[cur].size()==0)continue;
                int x=p[cur];
                int y=s[cur].first();
                if(x==a-y){
                    ans[cur]=1;
                    ans[m.get(y)]=1;
                }
                else{
                    ans[cur]=2;
                    ans[m.get(y)]=2;
                }
                for(Integer u:s[m.get(y)]){
                    int o=m.get(u);
                    if(o!=m.get(y)) {
                        s[o].remove(y);
                        if (s[o].size() == 1) q.add(o);
                    }
                }
                for(Integer u:s[cur]){
                    int o=m.get(u);
                    if(o!=m.get(y)) {
                        s[o].remove(y);
                        if (s[o].size() == 1) q.add(o);
                    }
                }
            }
            last++;
            while(last!=n){
                if(s[last].size()!=0&&ans[last]==0)break;
                last++;
            }
            if(last!=n){
                q.add(last);
            }
        }
        for(int i=0;i<n;i++)
            if(ans[i]==0){
                out.println(""NO"");
                return;
            }
        out.println(""YES"");
        for(int i=0;i<n;i++)
            out.print((ans[i]-1)+"" "");
    }

    public static void main(String[] args) throws IOException {
        new B().run();
    }

    void run() throws IOException {
        reader = new BufferedReader(new InputStreamReader(System.in));
//      reader = new BufferedReader(new FileReader(""input.txt""));
        tokenizer = null;
        out = new PrintWriter(new OutputStreamWriter(System.out));
//      out = new PrintWriter(new FileWriter(""output.txt""));
        solve();
        reader.close();
        out.flush();

    }

    BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter out;

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }
}
",3,3
"import java.util.List;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.io.PrintStream;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Random;
import java.io.Reader;
import java.io.Writer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Nipuna Samarasekara
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		FastScanner in = new FastScanner(inputStream);
		FastPrinter out = new FastPrinter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
    /////////////////////////////////////////////////////////////
    static nn[] B;
    static int n,a,b;
    public void solve(int testNumber, FastScanner in, FastPrinter out) {
     n=in.nextInt();a=in.nextInt();b=in.nextInt();
        int ccc=0;
        if (a==b)ccc=1;
     int[] A=in.readIntArray(n);
      B=new nn[n];
        for (int i = 0; i < n; i++) {
            B[i]=new nn(A[i],i);
        }
        ArrayUtils.shuffle(B);
        Arrays.sort(B);
        int chk=1;
        for (int i = 0; i < n; i++) {
            if (B[i].assign>=0)continue;
            int v=B[i].val;
            int cc=0;
            int pos1=Arrays.binarySearch(B,new nn(a-v,0));
            if (pos1>=0&&B[pos1].assign==-1)cc++;
           if (a!=b){
            int pos2=Arrays.binarySearch(B,new nn(b-v,0));
            if (pos2>=0&&B[pos2].assign==-1)cc++; }
            if (cc==0){
                chk=0;
                break;
            }
            if (cc==1){
            go(i);
            }
        }
        if (chk==0){
            out.println(""NO"");
            return;
        }
        int[] ans= new int[n];
        for (int i = 0; i < n; i++) {
            ans[B[i].pos]=B[i].assign;
        }
        out.println(""YES"");
        for (int i = 0; i < n; i++) {
          out.print(ans[i] + "" "");
        }
        out.println();
        }
    static void go (int i){
        int v=B[i].val;
        int pos1=Arrays.binarySearch(B,new nn(a-v,0));
        if (pos1>=0&&B[pos1].assign==-1){
           B[i].assign=0;
           B[pos1].assign=0;
           int vv=B[pos1].val;
           int np=Arrays.binarySearch(B,new nn(b-vv,0));
           if (np>=0)go(np);

        }
        if (a!=b){
        int pos2=Arrays.binarySearch(B,new nn(b-v,0));
        if (pos2>=0&&B[pos2].assign==-1){
            B[i].assign=1;
            B[pos2].assign=1;
            int vv=B[pos2].val;
            int np=Arrays.binarySearch(B,new nn(a-vv,0));
            if (np>=0)go(np);
        } }

    }

}

class nn implements Comparable<nn> {
        int val,pos;

        public String toString() {
            return ""nn{"" +
                    ""val="" + val +
                    "", pos="" + pos +
                    "", assign="" + assign +
                    "", ct="" + ct +
                    '}';
        }

        int assign=-1;
        int ct=0;
        nn(int val, int pos) {
            this.val = val;
            this.pos = pos;
        }

        public int compareTo(nn o) {
            return this.val-o.val;  //To change body of implemented methods use File | Settings | File Templates.
        }

}

class FastScanner extends BufferedReader {

    public FastScanner(InputStream is) {
        super(new InputStreamReader(is));
    }

    public int read() {
        try {
            int ret = super.read();
//            if (isEOF && ret < 0) {
//                throw new InputMismatchException();
//            }
//            isEOF = ret == -1;
            return ret;
        } catch (IOException e) {
            throw new InputMismatchException();
        }
    }

    static boolean isWhiteSpace(int c) {
        return c >= 0 && c <= 32;
    }

    public int nextInt() {
        int c = read();
        while (isWhiteSpace(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int ret = 0;
        while (c >= 0 && !isWhiteSpace(c)) {
            if (c < '0' || c > '9') {
                throw new NumberFormatException(""digit expected "" + (char) c
                        + "" found"");
            }
            ret = ret * 10 + c - '0';
            c = read();
        }
        return ret * sgn;
    }

    public String readLine() {
        try {
            return super.readLine();
        } catch (IOException e) {
            return null;
        }
    }

    public int[] readIntArray(int n) {
        int[] ret = new int[n];
        for (int i = 0; i < n; i++) {
            ret[i] = nextInt();
        }
        return ret;
    }

}

class FastPrinter extends PrintWriter {

    public FastPrinter(OutputStream out) {
        super(out);
    }

    public FastPrinter(Writer out) {
        super(out);
    }


}

class ArrayUtils {


    static final long seed = System.nanoTime();

    static final Random rand = new Random(seed);


    public static <T> void shuffle(T[] a) {
        for (int i = 0; i < a.length; i++) {
            int j = rand.nextInt(i + 1);
            T t = a[i];
            a[i] = a[j];
            a[j] = t;
        }
    }

}

",3,3
"import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

public class Main {
	int work(int x){
		if(x%2==0)return x+1;
		else return x-1;
	}
	static int N = 200050;
	class Node implements Comparable <Node>{
		int x, id;
		Node(int x, int id){
			this.x = x; this.id = id;
		}
		public int compareTo(Node o){
			return Integer.compare(x, o.x);
		}
		public String toString(){
			return id + ""="" + x;
		}
	}
	class Edge{
		int from, to, nex;
		Edge (int from, int to, int nex){
			this.from = from;
			this.to = to;
			this.nex = nex;
		}
	}
	Edge[] edge = new Edge[N*10];
	int[] head = new int[N];
	int edgenum;  
	void addedge(int u, int v){  
	    Edge E = new Edge(u, v, head[u]);  
	    edge[edgenum] = E;  
	    head[u] = edgenum ++;  
	}  
	
	int n;
	int[] p = new int[N], ans = new int[N];
	int a, b, max;
    Map<Integer, Integer> map = new HashMap();
    boolean match(int x, int y, int col){
    	int P = map.get(x);
    	if(map.containsKey(y-x) == false)
    		return false;
    	int Q = map.get(y - x);
    	if(ans[Q] == -1 || x * 2 == y){
    		ans[Q] = ans[P] = col;
    	}
    	else {
    		if(match(a+b-2*y+x, y, col))
    			ans[Q] = ans[P] = col; 		
    		else return false;
    	}
    	return true;
    }
    boolean solve(){
    	if(max >= a && max >= b)return false;
    	for(int i = 1; i <= n; i++)
    		if(ans[i] == -1)
    		{
    			if(match(p[i], a, 0)==false && match(p[i], b, 1) == false)
    				return false;
    		}    	
    	return true;
    }
	void init(){
		n = cin.nextInt();
		a = cin.nextInt(); b = cin.nextInt();
		max = 0;
		for(int i = 1; i <= n; i++){
			ans[i] = -1;
			p[i] = cin.nextInt();
			map.put(p[i], i);
			if(p[i] > max) max = p[i];
		}
	}
	public void work(){
		init();
		if(solve()){
			out.println(""YES"");
			for(int i = 1; i <= n; i++)out.print(ans[i]+"" ""); out.println();
		}
		else 
			out.println(""NO"");
	}
	Main() {
        cin = new Scanner(System.in);  
        out = new PrintWriter(System.out);
    }  
    public static void main(String[] args) {
        Main e = new Main();  
        e.work();
        out.close();
    }
    public Scanner cin;
    public static PrintWriter out;
}
		  	 		   	 	    	 		  	   		",3,3
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.concurrent.LinkedBlockingDeque;

import javax.swing.border.Border;

public class a {

	public static long mod = (long) Math.pow(10, 9) + 7;
	public static int k = 0;

	private static class node implements Comparable<node> {
		int l;
		int r;
		int index;
		int index2;
		int buffer;

		node(int l, int r, int i, int b, int i2) {
			this.l = l;
			this.r = r;
			index = i;
			buffer = b;
			index2 = i2;

		}

		@Override
		public int compareTo(node o) {
			if (k == 0) {
				if (o.l < l)
					return 1;
				else if (o.l > l)
					return -1;
				else if (o.buffer != -1) {
					return 1;
				} else
					return -1;
			} else if (k == 1) {
				if (r != o.r)
					return r - o.r;
				return o.index - index;
			} else if (k == 2) {
				return r - o.r;
			} else {
				if (o.index < index)
					return 1;
				else
					return -1;
			}

		}
	}

	// private static class point implements Comparable<point> {
	// int l;
	// int r;
	// int index;
	// int buffer;
	//
	// point(int l, int r, int i, int b) {
	// this.l = l;
	// this.r = r;
	// index = i;
	// buffer = b;
	//
	// }
	//
	// @Override
	// public int compareTo(point o) {
	// if (o.l < l)
	// return 1;
	// else if (o.l > l)
	// return -1;
	// else if (o.r < r)
	// return 1;
	// else if (o.r > r)
	// return -1;
	// return 0;
	// }
	//
	// }

	public static class point implements Comparable<point> {
		long x;
		long y;

		point(long x, long y) {
			this.x = x;
			this.y = y;
		}

		@Override
		public int compareTo(point o) {
			return (int) (x - o.x);

		}
	}

	public static int ch(long y) {
		int r = Long.bitCount(y);
		return r;
	}

	public static int gcd(int x, int y) {
		if (y == 0)
			return x;

		return gcd(y, x % y);
	}

	public static int min[];
	public static int max[];

	public static void build(int s, int e, int p, int a[]) {
		if (s == e) {
			min[p] = a[s];
			max[p] = a[s];
			return;
		}

		int mid = (s + e) / 2;
		build(s, mid, p * 2, a);
		build(mid + 1, e, p * 2 + 1, a);
		min[p] = Math.min(min[p * 2], min[p * 2 + 1]);
		max[p] = Math.max(max[p * 2], max[p * 2 + 1]);
	}

	public static int getMin(int s, int e, int p, int from, int to) {
		if (s > to || e < from)
			return Integer.MAX_VALUE;
		if (s >= from && e <= to)
			return min[p];
		int mid = (s + e) / 2;

		int a = getMin(s, mid, p * 2, from, to);
		int b = getMin(mid + 1, e, p * 2 + 1, from, to);
		return Math.min(a, b);

	}

	public static int getMax(int s, int e, int p, int from, int to) {
		if (s > to || e < from)
			return Integer.MIN_VALUE;
		if (s >= from && e <= to)
			return max[p];
		int mid = (s + e) / 2;

		int a = getMax(s, mid, p * 2, from, to);
		int b = getMax(mid + 1, e, p * 2 + 1, from, to);
		return Math.max(a, b);

	}

	public static boolean ch[];
	public static ArrayList<Integer> prime;
	public static Queue<Integer> pp;

	public static void sieve(int k) {
		ch[0] = ch[1] = true;

		for (int i = 2; i <= k; i++) {
			if (!ch[i]) {
				prime.add(i);
				pp.add(i);
				for (int j = i + i; j <= k; j += i) {
					ch[j] = true;
				}
			}
		}

	}

	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder qq = new StringBuilder();
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		String y[] = in.readLine().split("" "");
		int n = Integer.parseInt(y[0]);
		int a = Integer.parseInt(y[1]);
		int b = Integer.parseInt(y[2]);

		int arr[] = new int[n];
		HashMap<Integer, Integer> mp = new HashMap();
		y = in.readLine().split("" "");
		boolean flag = true;
		for (int i = 0; i < n; i++) {
			arr[i] = Integer.parseInt(y[i]);
			if (arr[i] >= a && arr[i] >= b) {
				flag = false;
			}
			mp.put(arr[i], i);
		}

		if (!flag) {
			System.out.println(""NO"");
			return;
		}
		boolean ch[] = new boolean[n];
		int ans[] = new int[n];

		for (int i = 0; i < n; i++) {
			int k = i;

			while (true&&!ch[k]) {
				
				if (mp.containsKey(a - arr[k]) && !ch[mp.get(a - arr[k])]
						&& mp.containsKey(b - arr[k])
						&& !ch[mp.get(b - arr[k])]) {
					break;
				} else if (mp.containsKey(a - arr[k])
						&& !ch[mp.get(a - arr[k])]) {
					//System.out.println(arr[k]);
					ch[k] = true;
					ans[k] = 0;
					ch[mp.get(a - arr[k])] = true;
					ans[mp.get(a - arr[k])] = 0;
					int s = b - (a - arr[k]);
					if (mp.containsKey(s)) {
						k = mp.get(s);
					} else
						break;
					
				} else if (mp.containsKey(b - arr[k])
						&& !ch[mp.get(b - arr[k])]) {
					ans[k] = 1;
					ans[mp.get(b - arr[k])] = 1;
					ch[k] = true;
					ch[mp.get(b - arr[k])] = true;

					int s = a - (b - arr[k]);
					if (mp.containsKey(s)) {
						k = mp.get(s);
					} else
						break;
				} else {
					// System.out.println(arr[i] + "" "" + i);
					System.out.println(""NO"");
					return;
				}
			}
		}

		qq.append(""YES\n"");
		for (int i = 0; i < ans.length; i++) {
			qq.append(ans[i] + "" "");
		}
		System.out.println(qq);

	}
}",3,3
"import java.text.DecimalFormat;
import java.io.*;
import java.util.*;
import java.lang.reflect.Array;

/**
 * @author Mukesh Singh
 *
 */


public class AB {

    private InputStream input;
    private PrintStream output;
    private Scanner inputSc;

    public AB(InputStream input, PrintStream output) {
        this.input = input;
        this.output = output;
        init();
    }

    private void init() {
        inputSc = new Scanner(input);
    }

    static int lineToInt(String line) {
        return Integer.parseInt(line);
    }

    static long lineToLong(String line) {
        return Long.parseLong(line);
    }
    static double lineToDouble(String line) {
        return Double.parseDouble(line);
    }


    public void solve() 
	{
            solveTestCase();
    }

/**
 * @define global / instance variables 
 */

	HashMap<Integer,Integer> mat ;
	long dist[] ;
	int vec[] ;
	int ar[] ;
	Set<Integer> st ;
	boolean isDone[] ;
	final long INF = 100000000000000000L ;
/**
 * @solve test case 
 */
@SuppressWarnings(""unchecked"")
   private void solveTestCase() 
	{
		int i , j  , k , n , m , d , l ,b  , p , q , r;
		long N , M, K;
		int x1 , y1 , x2 , y2 ,x;
		int a1,a2,b1,b2,a ;
		DecimalFormat df = new DecimalFormat(""#,###,##0.00"");
        String str = inputSc.nextLine();
        String delims = ""[ ]+"";
		String tokens[] = str.split(delims);
		n = lineToInt(tokens[0]);
		a = lineToInt(tokens[1]);
		b = lineToInt(tokens[2]);
		mat = new HashMap<Integer,Integer>() ;
		st = new TreeSet<Integer>();
		ar = new int[n+4] ;
		vec = new int[n+4] ;
		str = inputSc.nextLine();
		tokens = str.split(delims);
		for( i = 1 ; i <= n ; i++ )
		{
			ar[i] = lineToInt(tokens[i-1]);
			mat.put(ar[i],i) ;
			st.add(ar[i]);
			vec[i] = i ;
		}
		vec[n+1] = n+1 ;
		vec[n+2] = n+2 ;
		for( i = 1 ; i <= n ; i++ )
		{
			x= ar[i];
		
			if(st.contains(a-x))
			{
				Bing(mat.get(x),mat.get(a-x));
			}
			else
				Bing(n+1 , mat.get(x));
			if(st.contains(b-x))
			{
				Bing(mat.get(x),mat.get(b-x));
			}
			else
				Bing(n+2 , mat.get(x));
		} 
		if(find(n+1)==find(n+2))
		{
			output.println(""NO"");
			return ;
		}
		output.println(""YES"");
		for( i =1 ;  i<= n  ; i ++ )
		{
			if(find(i)==find(n+1))
				output.print(""1 "");
			else 
				output.print(""0 "");
		}
		output.println();
		
	}
	int find(int x)
{
	if(x==vec[x]) return x;
	return vec[x]=find(vec[x]);
}

void Bing(int a,int b)
{
	int A=find(a);int B=find(b);
	if(A==B) return ;
	vec[B]=A;
}

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) 
	{
		FileInputStream in = null;
      	FileOutputStream out = null;
		PrintStream ps = null ;
		InputStream is = null ;
		try 
		{
         	is = new FileInputStream(""file.in"");
         	out = new FileOutputStream(""file.out"");
			ps = new PrintStream(out);
        }
		catch ( Exception e )
		{}

        AB sd = new AB(System.in, System.out);
        sd.solve();
		try
		{
        if (is != null) 
		{
	      is.close();
	    }
       	if (out != null) {
           	out.close();
       	}
		if (ps != null) {
           	ps.close();
         }
      	}catch (Exception e){}

		//SquareDetector sd = new SquareDetector(System.in, System.out);
        //sd.solve();
    }
}
   

",3,1
"import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

public class Main {
	int work(int x){
		if(x%2==0)return x+1;
		else return x-1;
	}
	static int N = 200050;
	class Node implements Comparable <Node>{
		int x, id;
		Node(int x, int id){
			this.x = x; this.id = id;
		}
		public int compareTo(Node o){
			return Integer.compare(x, o.x);
		}
		public String toString(){
			return id + ""="" + x;
		}
	}
	class Edge{
		int from, to, nex;
		Edge (int from, int to, int nex){
			this.from = from;
			this.to = to;
			this.nex = nex;
		}
	}
	Edge[] edge = new Edge[N*10];
	int[] head = new int[N];
	int edgenum;  
	void addedge(int u, int v){  
	    Edge E = new Edge(u, v, head[u]);  
	    edge[edgenum] = E;  
	    head[u] = edgenum ++;  
	}  
	
	int n;
	int[] p = new int[N], ans = new int[N];
	int a, b, max;
    Map<Integer, Integer> map = new HashMap();
    boolean match(int x, int y, int col){
    	int P = map.get(x);
    	if(map.containsKey(y-x) == false)
    		return false;
    	int Q = map.get(y - x);
    	if(ans[Q] == -1 || x * 2 == y){
    		ans[Q] = ans[P] = col;
    	}
    	else {
    		if(match(a+b-2*y+x, y, col))
    			ans[Q] = ans[P] = col; 		
    		else return false;
    	}
    	return true;
    }
    boolean solve(){
    	if(max >= a && max >= b)return false;
    	for(int i = 1; i <= n; i++)
    		if(ans[i] == -1)
    		{
    			if(match(p[i], a, 0)==false && match(p[i], b, 1) == false)
    				return false;
    		}    	
    	return true;
    }
	void init(){
		n = cin.nextInt();
		a = cin.nextInt(); b = cin.nextInt();
		max = 0;
		for(int i = 1; i <= n; i++){
			ans[i] = -1;
			p[i] = cin.nextInt();
			map.put(p[i], i);
			if(p[i] > max) max = p[i];
		}
	}
	public void work(){
		init();
		if(solve()){
			out.println(""YES"");
			for(int i = 1; i <= n; i++)out.print(ans[i]+"" ""); out.println();
		}
		else 
			out.println(""NO"");
	}
	Main() {
        cin = new Scanner(System.in);  
        out = new PrintWriter(System.out);
    }  
    public static void main(String[] args) {
        Main e = new Main();  
        e.work();
        out.close();
    }
    public Scanner cin;
    public static PrintWriter out;
}
/*
http://blog.csdn.net/keshuai19940722/article/details/39528801

*/",3,3
"import java.util.*;
import java.io.*;
public class B {
    public static PrintStream out = System.out;
    public static InputReader in = new InputReader(System.in);
    static class Node implements Comparable<Node> {
        int res;
        Node(int pp) {
            p = pp;
        }
        int p;
        @Override
        public int compareTo(Node n) {
            return Integer.compare(p, n.p);
        }
        @Override
        public boolean equals(Object o) {
            return p == ((Node) o).p;
        }
    }
    public static void main(String args[]) {
        int N, a, b;
        N = in.nextInt();
        int[] label;
        a = in.nextInt();
        b = in.nextInt();
        if (a < b) {
            label = new int[] {0, 1};
        } else {
            int tmp = a;
            a = b;
            b = tmp;
            label = new int[] {1, 0};
        }
        Node[] nodes = new Node[N];
        for (int i = 0; i < N; i++) {
            nodes[i] = new Node(in.nextInt());
        }
        TreeSet<Node> ts = new TreeSet<>();
        for (int i = 0; i < N; i++) {
            ts.add(nodes[i]);
        }
        while (!ts.isEmpty()) {
            Node n = ts.first();
            Node an = new Node(a - n.p);
            Node bn = new Node(b - n.p);
            SortedSet<Node> ats = ts.tailSet(an);
            SortedSet<Node> bts = ts.tailSet(bn);
            Node an2 = ats.isEmpty() ? null : ats.first();
            Node bn2 = bts.isEmpty() ? null : bts.first();
            Node n2 = null;
            int l = 0;
            if (bn2 != null && bn2.equals(bn)) {
                n2 = bn2;
                l = label[1];
            } else if (an2 != null && an2.equals(an)) {
                n2 = an2;
                l = label[0];
            } else {
                NO();
            }
            if (!n.equals(n2)) {
                ts.remove(n);
                n.res = l;
            }
            ts.remove(n2);
            n2.res = l;
        }
        out.println(""YES"");
        for (int i = 0; i < nodes.length; i++) {
            if (i != 0) out.print("" "");
            out.print(nodes[i].res);
        }
        out.println();
    }
    static void NO() {
        out.println(""NO"");
        System.exit(0);
    }
}
class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;
    public InputReader(InputStream stream) {
	reader = new BufferedReader(new InputStreamReader(stream), 32768);
	tokenizer = null;
    }
    public String next() {
	while (tokenizer == null || !tokenizer.hasMoreTokens()) {
	    try {
		tokenizer = new StringTokenizer(reader.readLine());
	    } catch (IOException e) {
		throw new RuntimeException(e);
	    }
	}
	return tokenizer.nextToken();
    }
    public double nextDouble() {
	return Double.parseDouble(next());
    }
    public long nextLong() {
	return Long.parseLong(next());
    }
    public int nextInt() {
	return Integer.parseInt(next());
    }
}
",3,3
"import java.io.IOException;
import java.util.Arrays;
import java.io.FilterInputStream;
import java.util.HashMap;
import java.util.Iterator;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.TreeSet;
import java.io.BufferedInputStream;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Zyflair Griffane
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputUtil in = new InputUtil(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
    HashMap<Integer, Integer> left = new HashMap<Integer, Integer>();

    public void solve(int testNumber, InputUtil in, PrintWriter out) {
        int n = in.nextInt();
        int a = in.nextInt();
        int b = in.nextInt();

        int[] res = new int[n];
        int[] arr = in.nextIntArray(n);

        IntDeque[] adj = IntDeque.IntDeques(n);
        boolean[] self = new boolean[n];
        boolean[] assigned = new boolean[n];

        for (int i = 0; i < n; i++) {
            left.put(arr[i], i);
        }
        for (int i = 0; i < n; i++) {
            int x = arr[i];

            boolean canA = left.containsKey(a - x);
            boolean canB = left.containsKey(b - x);
            if (!canA && !canB) {
                out.println(""NO"");
                return;
            }

            if (left.containsKey(a - x)) {
                self[i] |= x == a - x;
                if (x != a - x) {
                    adj[i].add(left.get(a - x));
                }
            }

            if (left.containsKey(b - x)) {
                self[i] |= x == b - x;
                if (x != b - x) {
                    adj[i].add(left.get(b - x));
                }
            }
        }

        if (a == b) {
            out.println(""YES"");
            out.println(IntArrayUtil.toString(res));
            return;
        }

        for (int iter = 0; iter < 2; iter++) {
            for (int i = 0; i < n; i++) {
                if (!self[i] && !assigned[i] && (iter == 1 || adj[i].size() == 1)) {
                    int u = i;
                    DFS:
                    while (true) {
                        assigned[u] = true;
                        if (self[u] && arr[u] == b - arr[u]) {
                            res[u] = 1;
                            break;
                        }
                        for (int v : adj[u]) {
                            if (!assigned[v]) {
                                assigned[v] = true;
                                if (arr[u] == b - arr[v]) {
                                    res[u] = res[v] = 1;
                                }
                                for (int newU : adj[v]) {
                                    if (!assigned[newU]) {
                                        u = newU;
                                        continue DFS;
                                    }
                                }
                                break DFS;
                            }
                        }
                        out.println(""NO"");
                        return;
                    }
                }
                else if (iter == 1 && !assigned[i] && adj[i].size() == 0 && arr[i] == b - arr[i]) {
                    res[i] = 1;
                }
            }
        }

        out.println(""YES"");
        out.println(IntArrayUtil.toString(res));
    }


}

class InputUtil {

    JoltyScanner in;

    public InputUtil(InputStream istream) {
        in = new JoltyScanner(istream);
    }

    public String next() {
        return in.next();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    public int[] nextIntArray (int size) {
        int[] arr = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = in.nextInt();
        }
        return arr;
    }

}

class IntDeque implements Iterable<Integer> {

    private int capacity;
    private int size = 0;
    private int front = 0;
    private int back = 0;
    private int[] deque;
    public IntDeque() {
        this(16);
    }
    public IntDeque(int capacity) {
        this.capacity = capacity;
        deque = new int[capacity];
    }
    public static IntDeque[] IntDeques(int length) {
        IntDeque[] arr = new IntDeque[length];
        for (int i = 0; i < length; i++) {
            arr[i] = new IntDeque();
        }
        return arr;
    }
    public <T extends Iterable<Integer>>IntDeque(T intList) {
        this(16);
        addAll(intList);
    }
    public IntDeque(int[] intArr) {
        this(16);
        for (int i: intArr) {
            addLast(i);
        }
    }
    public void add(int x) {
        addLast(x);
    }
    public <T extends Iterable<Integer>>void addAll(T intList) {
        for (int i: intList) {
            addLast(i);
        }
    }
    public void addLast(int x) {
        ensureCapacity();
        size++;
        deque[back++] = x;
        if (back == capacity) {
            back = 0;
        }
    }

    public void ensureCapacity() {
        if (size < capacity) {
            return;
        }
        int[] newDeque = new int[capacity << 1];
        for (int i = 0, j = front; i < size; i++, j++) {
            if (j == capacity) {
                j = 0;
            }
            newDeque[i] = deque[j];
        }
        deque = newDeque;
        capacity <<= 1;
        front = 0;
        back = size;
    }

    public Iterator<Integer> iterator() {
        return new Iterator<Integer>() {
            int done = 0;
            int curr = front;
            public boolean hasNext() {
                return done < size;
            }
            public Integer next() {
                Integer res = deque[curr++];
                if (curr == capacity) {
                    curr = 0;
                }
                done++;
                return res;
            }
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }

    public int size() {
        return size;
    }

    public String toString() {
        if (size == 0) {
            return """";
        }
        StringBuilder res = new StringBuilder();
        for (int i: this) {
            res.append(i);
            res.append("" "");
        }
        res.setLength(res.length() - 1);
        return res.toString();
    }
}

class IntArrayUtil {

    public static String toString(int[] arr) {
        return toString(arr, "" "");
    }

    public static String toString(int[] arr, String delimiter) {
        StringBuilder res = new StringBuilder();
        for (int i: arr) {
            res.append(i);
            res.append(delimiter);
        }
        res.setLength(res.length() - delimiter.length());
        return res.toString();
    }

}

class JoltyScanner {
    public static final int BUFFER_SIZE = 1 << 16;
	public static final char NULL_CHAR = (char) -1;

	StringBuilder str = new StringBuilder();
	byte[] buffer = new byte[BUFFER_SIZE];
	boolean EOF_FLAG = false;
	int bufferIdx = 0, size = 0;
	char c = NULL_CHAR;
	BufferedInputStream in;

	public JoltyScanner(InputStream in) {
		this.in = new BufferedInputStream(in, BUFFER_SIZE);
	}

	public int nextInt() {
		long x = nextLong();
		if (x > Integer.MAX_VALUE || x < Integer.MIN_VALUE) {
			throw new ArithmeticException(""Scanned value overflows integer"");
		}
		return (int) x;
	}

	public long nextLong() {
		boolean negative = false;
		if (c == NULL_CHAR) {
			c = nextChar();
		}
		for (; !EOF_FLAG && (c < '0' || c > '9'); c = nextChar()) {
			if (c == '-') {
				negative = true;
			}				
		}
		checkEOF();
		long res = 0;
		for (; c >= '0' && c <= '9'; c = nextChar()) {
			res = (res << 3) + (res << 1) + c - '0';
		}
		return negative ? -res : res;
	}

    public String next() {
		checkEOF();
		if (c == NULL_CHAR) {
			c = nextChar();
		}
		while (Character.isWhitespace(c)) {
			c = nextChar();
			checkEOF();
		}
		str.setLength(0);
		for (; !EOF_FLAG && !Character.isWhitespace(c); c = nextChar()) {
			str.append(c);
		}
		return str.toString();
	}

    public char nextChar() {
		if (EOF_FLAG) {
			return NULL_CHAR;
		}
		while (bufferIdx == size) {
			try {
				size = in.read(buffer);
				if (size == -1) {
					throw new Exception();
				}
			} catch (Exception e) {
				EOF_FLAG = true;
				return NULL_CHAR;
			}
			if (size == -1) {
				size = BUFFER_SIZE;
			}
			bufferIdx = 0;
		}
		return (char) buffer[bufferIdx++];
	}

    public void checkEOF() {
		if (EOF_FLAG) {
			throw new EndOfFileException();
		}
	}

	public class EndOfFileException extends RuntimeException {
	}
}

",3,3
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.StringTokenizer;
import static java.lang.Integer.*;

public class BDiv1 {
static int n; 
static int a;
static int b;
static HashMap<Integer,Integer> graphA=new HashMap<>();
static HashMap<Integer,Integer> graphB=new HashMap<>();
static int [] array;
static int [] original;
static boolean x=true;

    public static void main(String[] args) throws Exception{
        BufferedReader buf =new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st =new StringTokenizer(buf.readLine());
        n=parseInt(st.nextToken());
        a=parseInt(st.nextToken());
        b=parseInt(st.nextToken());
        st =new StringTokenizer(buf.readLine());
        array=new int[n];
        original=new int [n];
        for (int i=0;i<n;i++){
            array[i]=parseInt(st.nextToken());
            original[i]=array[i];
        }
        Arrays.sort(array);
for (int i=0;i<n;i++){
    int k= Arrays.binarySearch(array,a-array[i]);
    if (k>=0){
        graphA.put(array[i],array[k]);
        graphA.put(array[k],array[i]);
    }
}
for (int i=0;i<n;i++){
    int k= Arrays.binarySearch(array,b-array[i]);
    if (k>=0){
        graphB.put(array[i],array[k]);
        graphB.put(array[k],array[i]);
    }
    }


for (int i=0;i<n;i++){
    Integer j=graphA.get(array[i]);
    if (j!=null){
        if (graphB.containsKey(array[i]) && graphB.containsKey(j)){
            graphA.remove(array[i]);
            graphA.remove(j);
        }
        else if (graphB.containsKey(array[i]) && !graphB.containsKey(j)){
            
            graphB.remove(graphB.get(array[i]));
            graphB.remove(array[i]);
        }
        else if (!graphB.containsKey(array[i]) && graphB.containsKey(j)){
            graphB.remove(graphB.get(j));
            graphB.remove(j);
        }
        
    }
    
}

int [] res=new int [n];
for (int i=0;i<n;i++){
    if (graphA.containsKey(original[i]))res[i]=0;
    else if (graphB.containsKey(original[i])) res[i]=1;
    else {
        System.out.println(""NO"");
        return;
    }
}
System.out.println(""YES"");
for (int k:res)System.out.print(k+"" "");
}

    }


",3,3
"import java.util.*;
import java.io.*;

public class Main
{
	static HashMap<Integer,Integer> hm;
	static int[] array;
	static boolean marked[];
	static int a , b ; 
	static int[] ans ; 
	
	public static void main( String args[])
	{
		Scanner sc = new Scanner(System.in);
		int n ; 
		
		n = sc.nextInt();
		a = sc.nextInt();
		b = sc.nextInt();
		
		hm = new HashMap<Integer,Integer>();
		array = new int[n];
		marked = new boolean[n];
		
		for( int i = 0 ; i < n ; ++i )
		{
			array[i] = sc.nextInt();
			hm.put( array[i] , i );
		}
		
		if( a == b)
		{
			boolean flag = true ;
			for( int i = 0 ; i < n ; ++i )
				if( !hm.containsKey( a - array[i]))
					flag = false; 
			
			if( !flag) 
				System.out.println( ""NO"");
			else
			{
				System.out.println(""YES"");
				for( int i = 0 ; i < n ; ++i)
					System.out.print(""0 "");
			}
		}
		
		else
		{
			
			ans = new int[n];
			
			for( int i = 0 ; i < n ; ++i )
			if( marked[i] ) continue; 
			
			else  // hadle odd , even and single self loops
			{
				if( hm.containsKey(a - array[i]) && !hm.containsKey(b - array[i]))
				{
					propagateA(i);
				}
				
				else if( !hm.containsKey(a - array[i]) && hm.containsKey(b - array[i]))
				{
					// propagate b
					propagateB(i);
				}
				
				else if(!hm.containsKey(a - array[i]) && !hm.containsKey(b - array[i]))
				{
					System.out.println(""NO"");
					System.exit(0);
				}
			}
			
			
			
			for( int i = 0 ; i < n ; ++i )
				if( marked[i] ) continue; 
				
				else  // handle doule self loops , cycles
				{
						start(i);
				}
			
			System.out.println(""YES"");
			for( int i = 0 ; i < n; ++i)
				System.out.print(ans[i] + "" "");
			System.exit(0);
		}
		
		
		
		
	}
	
	static void propagateA(int index)
	{
		
		int i = index;
		
		while( !marked[i])
		{
			
			
					if( hm.containsKey( a - array[i]) && !marked[ hm.get( a - array[i])])
					{
						marked[i] = true ; 
						ans [i] = 0 ; 
						
						
						i = hm.get( a - array[i]);
						marked[i] = true ; 
						ans [i] = 0 ; 
						
						
						if( hm.containsKey( b - array[i]) && !marked[ hm.get( b - array[i])])
						{
							i = hm.get( b - array[i]);
						}

					}
					
					else
					{
						System.out.println(""NO"");
						System.exit(0);
					}
				
		}
			
	}
	
	static void propagateB(int index)
	{
		
		int i = index;
		
		while( !marked[i])
		{
			
			
					if( hm.containsKey( b - array[i]) && !marked[ hm.get( b - array[i])])
					{
						marked[i] = true ; 
						ans [i] = 1 ;
						
				
						
						i = hm.get( b - array[i]);
						marked[i] = true ; 
						ans [i] = 1 ; 
						
						
						if( hm.containsKey( a - array[i]) && !marked[ hm.get( a - array[i])])
						{
							i = hm.get( a - array[i]);
						}

					}
					
					else
					{
						System.out.println(""NO"");
						System.exit(0);
					}
				
		}
			
	}
	
	static void start(int index)
	{
		 
		int i = index ; 
		
		while( !marked[i] )
		{
			//System.out.println( a - array[i]);
			if(!marked[ hm.get( a - array[i])])
			{
				marked[i] = true ; 
				ans [i] = 0 ; 
				
				
				
				i = hm.get( a - array[i]);
				marked[i] = true ; 
				ans [i] = 0 ; 
				
				
				i = hm.get( b - array[i]);
			

			}
			
			
		}
	}
		
}",3,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.stream.LongStream;

public class Solution{
	
	
    public static void main(String[] args) throws IOException {
    	
		
    	FastScanner fs = new FastScanner();
    	PrintWriter out = new PrintWriter(System.out);
    		
    	int tt = 1;
    	while(tt-->0) {
    		
    		int n = fs.nextInt(), a = fs.nextInt(), b = fs.nextInt();
    		
    		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    		int[] v = new int[n];
    		
    		
    		for(int i=0;i<n;i++) {
    			v[i] = fs.nextInt();
    			map.put(v[i], 1);
    		}
    		
    		ArrayList<Integer> temp = new ArrayList<Integer>();
    		
    		for(int i=0;i<n;i++) {
    			if(!map.containsKey(a-v[i])) {
    				temp.add(v[i]);
    			}
    		}
    		
    		for(int i=0;i<temp.size();i++) {
    			int cur = temp.get(i);
    			map.put(cur, 2);
    			if(!map.containsKey(b-cur)) {
    				out.println(""NO"");
    				out.flush();
    				return;
    			}
    			if(map.get(b-cur)==2) {
    				continue;
    			}
    			map.put(b-cur, 2);
    			if(map.getOrDefault(a-(b-cur), 0)==1) {
    				map.put(a-(b-cur), 2);
    				temp.add(a-(b-cur));
    			}
    		}
    		
    		out.println(""YES"");
    		for(int i=0;i<n;i++	) {
    			out.print(map.get(v[i])-1+"" "");
    		}
    		out.println();
    		
    			
    			
    			
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    		
    	
    		
    		
    		
    	}
    	
    	out.close();
    		
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    static final Random random=new Random();
    
    static <T> void shuffle(T[] arr) {
    	int n = arr.length;
    	for(int i=0;i<n;i++	) {
    		int k = random.nextInt(n);
    		T temp = arr[k]; arr[k] = arr[i]; arr[i] = temp;
    	}
    }
    
    	
    static void ruffleSort(int[] a) {
    	int n=a.length;//shuffle, then sort 
    	for (int i=0; i<n; i++) {
    		int oi=random.nextInt(n); int temp=a[oi];
    		a[oi]=a[i]; a[i]=temp;
    	}
    	Arrays.sort(a);
    }
    
    static void ruffleSort(long[] a) {
    	int n=a.length;//shuffle, then sort 
    	for (int i=0; i<n; i++) {
    		int oi=random.nextInt(n); long temp=a[oi];
    		a[oi]=a[i]; a[i]=temp;
    	}
    	Arrays.sort(a);
    }
   
  
    
    static void reverse(int[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++){
    		int temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    
    static void reverse(long[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++){
    		long temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    
    
    static <T> void reverse(T[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++) {
    		T temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    	
    	
    static class FastScanner{
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer st = new StringTokenizer("""");
     
    	public String next(){
    		while(!st.hasMoreElements()){
    			try{
    				st = new StringTokenizer(br.readLine());
    			} catch(IOException e){
    				e.printStackTrace();
    			}
    		}
    		return st.nextToken();
    	}
    		
    	public String nextLine() throws IOException {
    		return br.readLine();
    	}
    		
    	public int nextInt(){
    		return Integer.parseInt(next());
    	}
     
    	public int[] readArray(int n){
    		int[] a = new int[n];
    		for(int i=0;i<n;i++)
    			a[i] = nextInt();
    		return a;
    	}
    		
    	public long nextLong() {
    		return Long.parseLong(next());
    	}
    		
    	public char nextChar() {
    		return next().toCharArray()[0];
    	}
    }
   	
}
",3,3
"import java.io.*;
import java.util.*;

public class Main {

	static BufferedReader reader;
	static StringTokenizer tokenizer;
	static PrintWriter writer;

	static int nextInt() throws NumberFormatException, IOException {
		return Integer.parseInt(nextToken());
	}

	static long nextLong() throws NumberFormatException, IOException {
		return Long.parseLong(nextToken());
	}

	static double nextDouble() throws NumberFormatException, IOException {
		return Double.parseDouble(nextToken());
	}

	static String nextToken() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens()) {
			tokenizer = new StringTokenizer(reader.readLine());
		}
		return tokenizer.nextToken();
	}

	public static void main(String[] args) throws IOException {
		reader = new BufferedReader(new InputStreamReader(System.in));
		writer = new PrintWriter(System.out);
		pineapple();
		reader.close();
		writer.close();
	}

	static void pineapple() throws NumberFormatException, IOException {
		int n = nextInt();
		int a = nextInt();
		int b = nextInt();
		TreeSet<Integer> al = new TreeSet<Integer>();
		TreeMap<Integer, Integer> mp = new TreeMap<Integer, Integer>();
		int[] ans = new int[n];
		Arrays.fill(ans, -1);
		TreeSet<Integer> used = new TreeSet<Integer>();
		int[] mas = new int[n];

		for (int i = 0; i < n; i++) {
			int t = nextInt();
			al.add(t);
			mas[i] = t;
			mp.put(t, i);
		}

		for (int st : al) {
			if (used.contains(st))
				continue;

			{
				int pr = st;
				int cc = -1;
				TreeSet<Integer> u2 = new TreeSet<Integer>();
				u2.add(pr);
				if (al.contains(a - pr) && !u2.contains(a - pr))
					cc = a - pr;
				else if (al.contains(b - pr) && !u2.contains(a - pr))
					cc = b - pr;
				if (cc != -1) {
					u2.add(cc);
					boolean bGo = true;
					while (bGo) {
						bGo = false;
						int nxt = -1;
						if (al.contains(a - cc) && !u2.contains(a - cc))
							nxt = a - cc;
						else if (al.contains(b - cc) && !u2.contains(b - cc))
							nxt = b - cc;
						if (nxt != -1) {
							bGo = true;
							u2.add(nxt);
							cc = nxt;
							pr = cc;
						}
					}
					st = cc;
				}
			}

			int x = st;
			while (x != -1) {
				int curr = x;
				used.add(curr);
				x = -1;
				int next1 = a - curr;
				if (al.contains(next1)) {
					if (!used.contains(next1)) {
						x = next1;
						int ci = mp.get(curr);
						int ni = mp.get(next1);
						if (ans[ci] == -1 && ans[ni] == -1) {
							ans[ni] = 0;
							ans[ci] = 0;
						}
					}
				}
				int next2 = b - curr;
				if (al.contains(next2)) {
					if (!used.contains(next2)) {
						x = next2;
						int ci = mp.get(curr);
						int ni = mp.get(next2);
						if (ans[ci] == -1 && ans[ni] == -1) {
							ans[ni] = 1;
							ans[ci] = 1;
						}
					}
				}
			}
		}

		for (int i = 0; i < n; i++) {
			if (ans[i] == -1) {
				if (2 * mas[i] == a) {
					ans[i] = 0;
					continue;
				}
				if (2 * mas[i] == b) {
					ans[i] = 1;
					continue;
				}
				writer.println(""NO"");
				return;
			}
		}

		writer.println(""YES"");
		for (int i = 0; i < n; i++) {
			writer.print(ans[i] + "" "");
		}
	}
}",3,3
"import java.util.List;
import java.util.Map;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.HashMap;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		FastScanner in = new FastScanner(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
	public void solve(int testNumber, FastScanner in, PrintWriter out) {
		int n = in.nextInt();
		int a = in.nextInt();
		int b = in.nextInt();
		List<Clause> clauses = new ArrayList<Clause>();
		int[] p = new int[n];
		Map<Integer, Integer> id = new HashMap<>();
		for (int i = 0; i < n; i++) {
			p[i] = in.nextInt();
			id.put(p[i], i);
		}
		// var[i] = true means p[i] \in A
		for (int i = 0; i < n; i++) {
			int x = p[i];
			Integer j = id.get(a - x);
			if (j == null) {
				// var[i] is false
				clauses.add(new Clause(i, i, true, false));
			} else {
				clauses.add(new Clause(i, j, true, true));
				clauses.add(new Clause(j, i, false, false));
			}

			j = id.get(b - x);
			if (j == null) {
				// var[i] is true
				clauses.add(new Clause(i, i, false, true));
			} else {
				clauses.add(new Clause(i, j, false, false));
				clauses.add(new Clause(j, i, true, true));
			}
		}
		SAT2Solver solver = new SAT2Solver(n);
		if (!solver.solve(clauses)) {
			out.println(""NO"");
			return;
		}
		out.println(""YES"");
		for (int i = 0; i < n; i++) {
			if (i > 0) {
				out.print("" "");
			}
			if (solver.isTrue[i]) {
				out.print(0);
			} else {
				out.print(1);
			}
		}
		out.println();
	}

	class Clause {
		int v1, v2;
		boolean neg1, neg2;

		// Example: (x=>!y) is translated to Clause(x, y, true, false)
		Clause(int v1, int v2, boolean pos1, boolean pos2) {
			this.v1 = v1;
			this.v2 = v2;
			this.neg1 = !pos1;
			this.neg2 = !pos2;
		}
	}

	class SAT2Solver {
		List<Integer>[] g;
		boolean[] isTrue;
		int n;

		int numComps;
		int[] low;
		int[] vis;
		int[] comp;
		boolean[] onStack;
		int[] stack;
		int sp;
		int globalTime;

		SAT2Solver(int n) {
			this.n = n;
			isTrue = new boolean[2 * n];
			vis = new int[2 * n];
			low = new int[2 * n];
			stack = new int[2 * n];
			comp = new int[2 * n];
			onStack = new boolean[2 * n];
			g = new List[2 * n];
		}

		public boolean solve(List<Clause> clauses) {
			for (int i = 0; i < 2 * n; i++) {
				g[i] = new ArrayList<Integer>();
			}
			for (Clause clause : clauses) {
				int v1 = clause.v1;
				int v2 = clause.v2;
				boolean neg1 = clause.neg1;
				boolean neg2 = clause.neg2;
				if (neg1) {
					v1 = negate(v1);
				}
				if (neg2) {
					v2 = negate(v2);
				}
				//g[negate(v1, n)].add(v2);
				//g[negate(v2, n)].add(v1);
				g[v1].add(v2);
			}
			Arrays.fill(vis, -1);
			Arrays.fill(onStack, false);
			sp = 0;
			globalTime = 0;
			numComps = 0;
			for (int i = 0; i < 2 * n; i++) {
				if (vis[i] < 0) {
					dfsTarjan(i);
				}
			}
			int[] firstInComp = new int[numComps];
			Arrays.fill(firstInComp, -1);
			int[] nextSameComp = new int[2 * n];
			for (int i = 0; i < 2 * n; i++) {
				int c = comp[i];
				nextSameComp[i] = firstInComp[c];
				firstInComp[c] = i;
			}
			List<Integer>[] invertedCompEdges = new List[numComps];
			for (int i = 0; i < numComps; i++) {
				invertedCompEdges[i] = new ArrayList<Integer>();
			}
			for (int i = 0; i < 2*n; i++) {
				for (int j : g[i]) {
					invertedCompEdges[comp[j]].add(comp[i]);
				}
			}
			boolean[] compIsTrue = new boolean[numComps];
			Arrays.fill(compIsTrue, true);
			for (int c = 0; c < numComps; c++) {
				if (!compIsTrue[c]) {
					continue;
				}
				for (int i = firstInComp[c]; i >= 0; i = nextSameComp[i]) {
					int nc = comp[negate(i)];
					if (c == nc) {
						return false;
					}
				}
				for (int i = firstInComp[c]; i >= 0; i = nextSameComp[i]) {
					int nc = comp[negate(i)];
					dfsReject(nc, invertedCompEdges, compIsTrue);
				}
			}
			for (int i = 0; i < 2 * n; i++) {
				isTrue[i] = compIsTrue[comp[i]];
			}
			for (int i = 0; i < n; i++) {
				if (isTrue[i] && isTrue[negate(i)]) {
					throw new AssertionError();
				}
				if (!isTrue[i] && !isTrue[negate(i)]) {
					return false;
				}
			}
			return true;
		}

		private int negate(int i) {
			return i + (i < n ? n : -n);
		}

		private void dfsReject(int c, List<Integer>[] invertedCompEdges, boolean[] compIsTrue) {
			if (!compIsTrue[c]) {
				return;
			}
			compIsTrue[c] = false;
			for (int p : invertedCompEdges[c]) {
				dfsReject(p, invertedCompEdges, compIsTrue);
			}
		}

		void dfsTarjan(int v) {
			vis[v] = globalTime;
			low[v] = globalTime;
			++globalTime;
			stack[sp++] = v;
			onStack[v] = true;
			for (int u : g[v]) {
				if (vis[u] < 0) {
					dfsTarjan(u);
					if (low[v] > low[u]) {
						low[v] = low[u];
					}
				} else if (onStack[u] && low[v] > vis[u]) {
					low[v] = vis[u];
				}
			}
			if (low[v] == vis[v]) {
				while (true) {
					int u = stack[--sp];
					onStack[u] = false;
					comp[u] = numComps;
					if (u == v) {
						break;
					}
				}
				++numComps;
			}
		}

	}



}

class FastScanner {

	private BufferedReader in;
	private StringTokenizer st;

	public FastScanner(InputStream stream) {
		in = new BufferedReader(new InputStreamReader(stream));
	}

	public String next() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				String rl = in.readLine();
				if (rl == null) {
					return null;
				}
				st = new StringTokenizer(rl);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
		return st.nextToken();
	}

	public int nextInt() {
		return Integer.parseInt(next());
	}

}

",3,3
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;


public class B {
	static Set<Integer> A;
	static Set<Integer> B;
	static TreeSet<Integer> ts;
	static int a;
	static int b;
	static boolean noAns;
	public static void main(String[] args) throws Exception{
		int n = readInt();
		a = readInt();
		b = readInt();
		ts = new TreeSet<Integer>();
		int[] table = new int[n];
		for(int i = 0; i<n; i++){
			table[i] = readInt();
			ts.add(table[i]);
		}
		A = new HashSet<Integer>();
		B = new HashSet<Integer>();
		noAns = false;
		for(Integer cur:ts){
			boolean fitsA = false;
			boolean fitsB = false;
			if(A.contains(cur) || B.contains(cur)){
				continue;
			}
			if(ts.contains(a-cur)){
				fitsA = true;
			}
			if(ts.contains(b-cur)){
				fitsB = true;
			}
			if(fitsA && fitsB){
				continue;
			}
			else if(!(fitsA || fitsB)){
				noAns = true;
			}
			else if(fitsA){
				tour(cur, false);
			}
			else if(fitsB){
				tour(cur, true);
			}
		}
		for(Integer cur:ts){
			if(A.contains(cur) || B.contains(cur)){
				continue;
			}
			else{
				A.add(cur);
			}
		}
		if(!noAns){
			System.out.println(""YES"");
			StringBuilder sb = new StringBuilder();
			for(int i = 0; i< n; i++){
				if(A.contains(table[i])){
					sb.append(""0"");
				}
				else{
					sb.append(""1"");
				}
				sb.append("" "");
			}
			System.out.println(sb);
		}
		else{
			System.out.println(""NO"");
		}
	}

	static void tour(Integer cur, boolean bb){
		if(A.contains(cur) || B.contains(cur)){
			return;
		}
		if(bb){
			B.add(cur);
			B.add(b-cur);
			
			if(ts.contains(a-cur)){
				B.add(a-cur);
				if(ts.contains(b-(a-cur))){
					tour(b-(a-cur), true);
				}
				else{
					noAns = true;
				}
			}			
			if(ts.contains(a-(b-cur))){
				B.add(a-(b-cur));
				if(ts.contains(b-(a-(b-cur)))){
					tour(b-(a-(b-cur)), true);
				}
				else{
					noAns = true;
				}
			}
		}
		else{
			A.add(cur);
			A.add(a-cur);
			if(ts.contains(b-cur)){
				A.add(b-cur);
				if(ts.contains(a-(b-cur))){
					tour(a-(b-cur), false);
				}
				else{
					noAns = true;
				}
			}
			if(ts.contains(b-(a-cur))){
				A.add(b-(a-cur));
				if(ts.contains(a-(b-(a-cur)))){
					tour(a-(b-(a-cur)), false);
				}
				else{
					noAns = true;
				}
			}
		}
	}

	static BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st = new StringTokenizer("" "");
	static String readString() throws Exception{
		while(!st.hasMoreTokens()){
			st = new StringTokenizer(stdin.readLine());
		}
		return st.nextToken();
	}
	static int readInt() throws Exception {
		return Integer.parseInt(readString());
	}
	static long readLong() throws Exception {
		return Long.parseLong(readString());
	}
}
",3,3
"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Stack;
import java.util.StringTokenizer;

public class TwoSets {
    static int n, a, b;
    static HashSet<Integer> arr = new HashSet<Integer>();
    static HashSet<Integer> visited = new HashSet<Integer>();
    static HashMap<Integer, Integer> result = new HashMap<Integer, Integer>();

    static void dfs(int x, int parent, int len) {
        stack.push(x);
        visited.add(x);
        int children = 0;
        if (a - x > 0) {
            if (a - x != parent && arr.contains(a - x)) {
                dfs(a - x, x, len + 1);
                children++;
            }
        }
        if (b - x > 0) {
            if (b - x != parent && arr.contains(b - x)) {
                dfs(b - x, x, len + 1);
                children++;
            }
        }
        if (children == 0) {
            if (len % 2 == 1) {
                System.out.println(""NO"");
                System.exit(0);
            } else {
                while (!stack.isEmpty()) {
                    int first = stack.pop();
                    int second = stack.pop();
                    if (first == a - second) {
                        result.put(first, 0);
                        result.put(second, 0);
                    } else {
                        result.put(first, 1);
                        result.put(second, 1);
                    }

                }
            }
        }
    }

    static Stack<Integer> stack = new Stack<Integer>();

    public static void main(String[] args) {
        InputReader r = new InputReader(System.in);
        n = r.nextInt();
        a = r.nextInt();
        b = r.nextInt();
        int[] list = new int[n];
        for (int i = 0; i < n; i++) {
            list[i] = r.nextInt();
            arr.add(list[i]);
        }
        for (int x : arr) {
            if (!visited.contains(x)) {
                if (arr.contains(a - x) && arr.contains(b - x))
                    continue;
                if (arr.contains(a - x) || arr.contains(b - x)) {
                    dfs(x, -1, 1);
                } else {
                    System.out.println(""NO"");
                    System.exit(0);
                }
            }
        }
        PrintWriter out = new PrintWriter(System.out);
        out.println(""YES"");
        for (int i = 0; i < list.length; i++) {
            if (result.get(list[i]) == null)
                out.println(0);
            else
                out.println(result.get(list[i]));
        }
        out.close();

    }

    static class InputReader {
        private BufferedReader reader;
        private StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream));
            tokenizer = null;
        }

        public InputReader(FileReader stream) {
            reader = new BufferedReader(stream);
            tokenizer = null;
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                return null;
            }
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }
    }
}
",3,3
"import java.util.Map;
import java.io.OutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.util.TreeMap;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int n = in.readInt();
        int a = in.readInt();
        int b = in.readInt();
        TreeMap<Integer, Integer> mp = new TreeMap<Integer, Integer>();
        for (int i = 0; i < n; ++i) {
            mp.put(in.readInt(), i);
        }
        int aname = 0;
        int bname = 1;
        if (a > b) {
            int t = a;
            a = b;
            b = t;
            aname = 1;
            bname = 0;
        }
        int[] res = new int[n];
        while (mp.size() > 0) {
            Map.Entry<Integer, Integer> e = mp.firstEntry();
            int val = e.getKey();
            if (mp.containsKey(b - val)) {
                res[mp.get(val)] = res[mp.get(b - val)] = bname;
                mp.remove(val);
                mp.remove(b - val);
            } else if (mp.containsKey(a - val)) {
                res[mp.get(val)] = res[mp.get(a - val)] = aname;
                mp.remove(val);
                mp.remove(a - val);
            } else {
                break;
            }
        }
        if (mp.size() > 0) {
            out.println(""NO"");
        } else {
            out.println(""YES"");
            for (int i = 0; i < n; ++i) {
                if (i > 0) out.print("" "");
                out.print(res[i]);
            }
            out.println();
        }
    }
}

class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        // InputMismatchException -> UnknownError
        if (numChars == -1)
            throw new UnknownError();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new UnknownError();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        } else if (c == '+') {
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public static boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

}

",3,3
"import java.util.Map;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Set;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.util.HashSet;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

class TaskB {
    public void solve(int testNumber, InputReader in, PrintWriter out) {
        int n = in.nextInt();
        int a = in.nextInt();
        int b = in.nextInt();
        int[] p = new int[n];
        for (int i = 0; i < n; ++i)
            p[i] = in.nextInt();
        Map<Integer, Integer> position = new HashMap<>(n);
        for (int i = 0; i < n; ++i)
            position.put(p[i], i);
        DisjointSet sets = new DisjointSet(n);
        for (int i = 0; i < n; ++i) {
            if (position.containsKey(a - p[i]))
                sets.joinSet(i, position.get(a - p[i]));
            if (position.containsKey(b - p[i]))
                sets.joinSet(i, position.get(b - p[i]));
        }
        Group[] groups = new Group[n];
        for (int i = 0; i < n; ++i)
            if (sets.getSet(i) == i)
                groups[i] = new Group();
        for (int i = 0; i < n; ++i)
            groups[sets.getSet(i)].value.add(p[i]);
        int[] answer = new int[n];
        for (Group group : groups) if (group != null) {
            if (group.check(a)) {
                for (int key : group.value)
                    answer[position.get(key)] = 0;
            } else if (group.check(b)) {
                for (int key : group.value)
                    answer[position.get(key)] = 1;
            } else {
                out.println(""NO"");
                return;
            }
        }
        out.println(""YES"");
        for (int i = 0; i < n; ++i) {
            if (i > 0) out.print(' ');
            out.print(answer[i]);
        }
        out.println();
    }

    class Group {
        Set<Integer> value = new HashSet<>();

        boolean check(int sum) {
            for (int key : value)
                if (!value.contains(sum - key))
                    return false;
            return true;
        }
    }
}

class InputReader {
    private BufferedReader reader;
    private StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream), 32768);
        tokenizer = null;
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens())
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        return tokenizer.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

}

class DisjointSet {
    private final int[] label;
    private int numSets;
    private Listener listener;

    public DisjointSet(int n, Listener listener) {
        label = new int[n];
        Arrays.fill(label, -1);
        numSets = n;
        this.listener = listener;
    }

    public DisjointSet(int n) {
        this(n, null);
    }

    public int getSet(int at) {
        if (label[at] < 0) return at;
        return label[at] = getSet(label[at]);
    }

    public boolean sameSet(int u, int v) {
        return getSet(u) == getSet(v);
    }

    public boolean joinSet(int u, int v) {
        if (sameSet(u, v)) return false;
        u = getSet(u);
        v = getSet(v);
        if (label[u] < label[v]) {
            int tmp = u;
            u = v;
            v = tmp;
        }
        label[v] += label[u];
        label[u] = v;
        --numSets;
        if (listener != null) listener.joined(u, v);
        return true;
    }

    public static interface Listener {
        public void joined(int joinedRoot, int root);
    }
}

",3,3
"import java.util.*;
import java.io.*;
import java.awt.Point;
import java.math.BigDecimal;
import java.math.BigInteger;

import static java.lang.Math.*;

// Solution is at the bottom of code

public class B implements Runnable{
	
	final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;
	
	BufferedReader in;
	OutputWriter out;
	StringTokenizer tok = new StringTokenizer("""");
	
	public static void main(String[] args){
		new Thread(null, new B(), """", 128 * (1L << 20)).start();
	}
	
	/////////////////////////////////////////////////////////////////////
	
	void init() throws FileNotFoundException{
		Locale.setDefault(Locale.US);
		
		if (ONLINE_JUDGE){
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new OutputWriter(System.out);
		}else{
			in = new BufferedReader(new FileReader(""input.txt""));
			out = new OutputWriter(""output.txt"");
		}
	}
	
	////////////////////////////////////////////////////////////////
	
	long timeBegin, timeEnd;

	void time(){
		timeEnd = System.currentTimeMillis();
		System.err.println(""Time = "" + (timeEnd - timeBegin));
	}
	
	void debug(Object... objects){
		if (ONLINE_JUDGE){
			for (Object o: objects){
				System.err.println(o.toString());
			}
		}
	}
	
	/////////////////////////////////////////////////////////////////////
	
	public void run(){
		try{
			timeBegin = System.currentTimeMillis();
			Locale.setDefault(Locale.US);
			
			init();
			solve();
			
			out.close();
			time();
		}catch (Exception e){
			e.printStackTrace(System.err);
			System.exit(-1);
		}
	}
	
	/////////////////////////////////////////////////////////////////////
	
	String delim = "" "";
	
	String readString() throws IOException{
		while(!tok.hasMoreTokens()){
			try{
				tok = new StringTokenizer(in.readLine());
			}catch (Exception e){
				return null;
			}
		}
		
		return tok.nextToken(delim);
	}
	
	String readLine() throws IOException{
		return in.readLine();
	}
	
	/////////////////////////////////////////////////////////////////
	
	final char NOT_A_SYMBOL = '\0';
	
	char readChar() throws IOException{
		int intValue = in.read();
		
		if (intValue == -1){
			return NOT_A_SYMBOL;
		}
		
		return (char) intValue;
	}
	
	char[] readCharArray() throws IOException{
		return readLine().toCharArray();
	}
	
	/////////////////////////////////////////////////////////////////
	
	int readInt() throws IOException {
		return Integer.parseInt(readString());
	}
	
	int[] readIntArray(int size) throws IOException {
		int[] array = new int[size];
		
		for (int index = 0; index < size; ++index){
			try {
				array[index] = readInt();
			} catch (Exception e) {
				System.err.println(index);
				return null;
			}
		}
		
		return array;
	}
	
	int[] readSortedIntArray(int size) throws IOException {
		Integer[] array = new Integer[size];
		
		for (int index = 0; index < size; ++index) {
			array[index] = readInt();
		}
		Arrays.sort(array);
		
		int[] sortedArray = new int[size];
		for (int index = 0; index < size; ++index) {
			sortedArray[index] = array[index];
		}
		
		return sortedArray;
	}
	
	int[] readIntArrayWithDecrease(int size) throws IOException {
		int[] array = readIntArray(size);
		
		for (int i = 0; i < size; ++i) {
			array[i]--;
		}
		
		return array;
	}
	
	///////////////////////////////////////////////////////////////////
	
	int[][] readIntMatrix(int rowsCount, int columnsCount) throws IOException {
		int[][] matrix = new int[rowsCount][];
		
		for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {
			matrix[rowIndex] = readIntArray(columnsCount);
		}
		
		return matrix;
	}
	
	int[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) throws IOException {
		int[][] matrix = new int[rowsCount][];
		
		for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {
			matrix[rowIndex] = readIntArrayWithDecrease(columnsCount);
		}
		
		return matrix;
	}
	
	///////////////////////////////////////////////////////////////////
	
	long readLong() throws IOException{
		return Long.parseLong(readString());
	}
	
	long[] readLongArray(int size) throws IOException{
		long[] array = new long[size];
		
		for (int index = 0; index < size; ++index){
			array[index] = readLong();
		}
		
		return array;
	}
	
	////////////////////////////////////////////////////////////////////
	
	double readDouble() throws IOException{
		return Double.parseDouble(readString());
	}
	
	double[] readDoubleArray(int size) throws IOException{
		double[] array = new double[size];
		
		for (int index = 0; index < size; ++index){
			array[index] = readDouble();
		}
		
		return array;
	}
	
	////////////////////////////////////////////////////////////////////
		
	BigInteger readBigInteger() throws IOException {
		return new BigInteger(readString());
	}
	
	BigDecimal readBigDecimal() throws IOException {
		return new BigDecimal(readString());
	}
	
	/////////////////////////////////////////////////////////////////////
	
	Point readPoint() throws IOException{
		int x = readInt();
		int y = readInt();
		return new Point(x, y);
	}
	
	Point[] readPointArray(int size) throws IOException{
		Point[] array = new Point[size];
		
		for (int index = 0; index < size; ++index){
			array[index] = readPoint();
		}
		
		return array;
	}
	
	/////////////////////////////////////////////////////////////////////
	
	List<Integer>[] readGraph(int vertexNumber, int edgeNumber)
	throws IOException{
		@SuppressWarnings(""unchecked"")
		List<Integer>[] graph = new List[vertexNumber];
		
		for (int index = 0; index < vertexNumber; ++index){
			graph[index] = new ArrayList<Integer>();
		}
		
		while (edgeNumber-- > 0){
			int from = readInt() - 1;
			int to = readInt() - 1;
			
			graph[from].add(to);
			graph[to].add(from);
		}
		
		return graph;
	}
	
	/////////////////////////////////////////////////////////////////////
	
	static class IntIndexPair {
		
		static Comparator<IntIndexPair> increaseComparator = new Comparator<B.IntIndexPair>() {
			
			@Override
			public int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {
				int value1 = indexPair1.value;
				int value2 = indexPair2.value;
				
				if (value1 != value2) return value1 - value2;
				
				int index1 = indexPair1.index;
				int index2 = indexPair2.index;
				
				return index1 - index2;
			}
		};
		
		static Comparator<IntIndexPair> decreaseComparator = new Comparator<B.IntIndexPair>() {
			
			@Override
			public int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {
				int value1 = indexPair1.value;
				int value2 = indexPair2.value;
				
				if (value1 != value2) return -(value1 - value2);
				
				int index1 = indexPair1.index;
				int index2 = indexPair2.index;
				
				return index1 - index2;
			}
		};
		
		int value, index;

		public IntIndexPair(int value, int index) {
			super();
			this.value = value;
			this.index = index;
		}		
		
		public int getRealIndex() {
			return index + 1;
		}
	}
	
	IntIndexPair[] readIntIndexArray(int size) throws IOException {
		IntIndexPair[] array = new IntIndexPair[size];
		
		for (int index = 0; index < size; ++index) {
			array[index] = new IntIndexPair(readInt(), index);
		}
		
		return array;
	}
	
	/////////////////////////////////////////////////////////////////////
	
	static class OutputWriter extends PrintWriter {

		final int DEFAULT_PRECISION = 12;
		
		protected int precision;
		protected String format, formatWithSpace;
		
		{
			precision = DEFAULT_PRECISION;
			
			format = createFormat(precision);
			formatWithSpace = format + "" "";
		}
		
		public OutputWriter(OutputStream out) {
			super(out);
		}

		public OutputWriter(String fileName) throws FileNotFoundException {
			super(fileName);
		}
		
		public int getPrecision() {
			return precision;
		}

		public void setPrecision(int precision) {
			precision = max(0, precision);
			this.precision = precision;
			
			format = createFormat(precision);
			formatWithSpace = format + "" "";
		}
		
		private String createFormat(int precision){
			return ""%."" + precision + ""f"";
		}
		
		@Override
		public void print(double d){
			printf(format, d);
		}
		
		public void printWithSpace(double d){
			printf(formatWithSpace, d);
		}

		public void printAll(double...d){
			for (int i = 0; i < d.length - 1; ++i){
				printWithSpace(d[i]);
			}
			
			print(d[d.length - 1]);
		}
		
		@Override
		public void println(double d){
			printlnAll(d);
		}
		
		public void printlnAll(double... d){
			printAll(d);
			println();
		}
	}
	
	/////////////////////////////////////////////////////////////////////
	
	static final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; 
	static final int[][] steps8 = {
			{-1, 0}, {1, 0}, {0, -1}, {0, 1},
			{-1, -1}, {1, 1}, {1, -1}, {-1, 1}
	};
	
	static final boolean check(int index, int lim){
		return (0 <= index && index < lim);
	}
	
	/////////////////////////////////////////////////////////////////////
	
	static final boolean checkBit(int mask, int bit){
		return (mask & (1 << bit)) != 0;
	}
	
	/////////////////////////////////////////////////////////////////////
	
	static final long getSum(int[] array) {
		long sum = 0;
		for (int value: array) {
			sum += value;
		}
		
		return sum;
	}
	
	static final Point getMinMax(int[] array) {
		int min = array[0];
		int max = array[0];
		
		for (int index = 0, size = array.length; index < size; ++index, ++index) {
			int value = array[index];
			
			if (index == size - 1) {
				min = min(min, value);
				max = max(max, value);
			} else {
				int otherValue = array[index + 1];
				
				if (value <= otherValue) {
					min = min(min, value);
					max = max(max, otherValue);
				} else {
					min = min(min, otherValue);
					max = max(max, value);
				}
			}
		}
		
		return new Point(min, max);
	}
	
	/////////////////////////////////////////////////////////////////////
	
	void solve() throws IOException {
		int n = readInt();
		
		int a = readInt();
		int b = readInt();
		
		Map<Integer, Integer> numbers = new HashMap<>();
		int[] p = readIntArray(n);
		for (int index = 0; index < n; ++index) {
			numbers.put(p[index], index);
		}
		
		Set<Integer> used = new HashSet<Integer>();
		Deque<Integer> q = new ArrayDeque<Integer>();
		
		int[] answers = new int[n];
		for (int i = 0; i < n; ++i) {
			if (used.contains(p[i])) continue;
			
			int leftSize = 0;
			for (int number = p[i], cur = a, next = b;
					numbers.containsKey(number) && !used.contains(number);
					number = cur - number, cur = (a ^ b ^ cur), next = (a ^ b ^ next)) {
				q.addFirst(number);
				used.add(number);
				
				++leftSize;
			}
			
			for (int number = b - p[i], cur = a, next = b;
					numbers.containsKey(number) && !used.contains(number);
					number = cur - number, cur = (a ^ b ^ cur), next = (a ^ b ^ next)) {
				q.addLast(number);
				used.add(number);
			}
			
			int curColor = (leftSize & 1);
			if ((q.size() & 1) == 1) {
				int first = q.peekFirst();
				
				// 0 - a, 1 - b
				if (curColor == 0 && (first << 1) == b
						||
					curColor == 1 && (first << 1) == a) {
					q.poll();
					
					curColor ^= 1;
					
					int firstIndex = numbers.get(first);
					answers[firstIndex] = curColor;
				} else {
					int last = q.peekLast();
					
					// 0 - b, 1 - a
					if (curColor == 0 && (last << 1) == a
							||
						curColor == 1 && (first << 1) == b) {
						q.poll();
						
						int firstIndex = numbers.get(first);
						answers[firstIndex] = curColor;
					} else {
						out.println(""NO"");
						return;
					}
				}
			}
			
			while (q.size() > 0) {
				int first = q.poll();
				int second = q.poll();
				
				int firstIndex = numbers.get(first);
				int secondIndex = numbers.get(second);
				
				answers[firstIndex] = curColor;
				answers[secondIndex] = curColor;
			}
		}
		
		out.println(""YES"");
		for (int answer : answers) {
			out.print(answer + "" "");
		}
		out.println();
	}
}

",3,3
"import java.util.*;

public class B {

	public B () {
		int N = sc.nextInt();
		int a = sc.nextInt();
		int b = sc.nextInt();
		int [] P = sc.nextInts();

		TreeSet<Integer> S = new TreeSet<>();
		Set<Integer> A = new HashSet<>();
		Set<Integer> B = new HashSet<>();

		for (int p : P) S.add(p);
		while (!S.isEmpty()) {
			int q = S.first();
			int x = a - q, y = b - q;
			if (S.contains(x) && S.contains(y)) {
				if (x > y) {
					S.remove(q); S.remove(x);
					A.add(q); A.add(x);
				} else {
					S.remove(q); S.remove(y);
					B.add(q); B.add(y);
				}
			}
			else if (S.contains(x)) {
				S.remove(q); S.remove(x);
				A.add(q); A.add(x);
			}
			else if (S.contains(y)) {
				S.remove(q); S.remove(y);
				B.add(q); B.add(y);
			}
			else
				exit(""NO"");
		}

		int [] res = new int[N];
		for (int i : rep(N))
			if (B.contains(P[i]))
				res[i] = 1;

		print(""YES"");
		exit(res);
	}

	private static int [] rep(int N) { return rep(0, N); }
	private static int [] rep(int S, int T) { if (T <= S) return new int [0]; int [] res = new int [T-S]; for (int i = S; i < T; ++i) res[i-S] = i; return res; }
	////////////////////////////////////////////////////////////////////////////////////
	private final static IOUtils.MyScanner sc = new IOUtils.MyScanner();
	private static void print (Object o, Object ... A) { IOUtils.print(o, A); }
	private static void exit (Object o, Object ... A) { IOUtils.print(o, A); IOUtils.exit(); }
	private static class IOUtils {
		public static class MyScanner {
			public String next() { newLine(); return line[index++]; }
			public int nextInt() { return Integer.parseInt(next()); }
			public String nextLine() { line = null; return readLine(); }
			public String [] nextStrings() { return split(nextLine()); }
			public int [] nextInts() {
				String [] L = nextStrings();
				int [] res = new int [L.length];
				for (int i = 0; i < L.length; ++i)
					res[i] = Integer.parseInt(L[i]);
				return res;
			}
			//////////////////////////////////////////////
			private boolean eol() { return index == line.length; }
			private String readLine() {
				try {
					return r.readLine();
				} catch (Exception e) {
					throw new Error (e);
				}
			}
			private final java.io.BufferedReader r;
			private MyScanner () { this(new java.io.BufferedReader(new java.io.InputStreamReader(System.in))); }
			private MyScanner (java.io.BufferedReader r) {
				try {
					this.r = r;
					while (!r.ready())
						Thread.sleep(1);
					start();
				} catch (Exception e) {
					throw new Error(e);
				}
			}
			private String [] line;
			private int index;
			private void newLine() {
				if (line == null || eol()) {
					line = split(readLine());
					index = 0;
				}
			}
			private String [] split(String s) { return s.length() > 0 ? s.split("" "") : new String [0]; }
		}
		private static String build(Object o, Object ... A) { return buildDelim("" "", o, A); }
		private static String buildDelim(String delim, Object o, Object ... A) {
			StringBuilder b = new StringBuilder();
			append(b, o, delim);
			for (Object p : A)
				append(b, p, delim);
			return b.substring(delim.length());
		}
		//////////////////////////////////////////////////////////////////////////////////
		private static void start() { if (t == 0) t = millis(); }
		private static void append(StringBuilder b, Object o, String delim) {
			if (o.getClass().isArray()) {
				int len = java.lang.reflect.Array.getLength(o);
				for (int i = 0; i < len; ++i)
					append(b, java.lang.reflect.Array.get(o, i), delim);
			} else if (o instanceof Iterable<?>)
				for (Object p : (Iterable<?>) o)
					append(b, p, delim);
			else {
				if (o instanceof Double)
					o = new java.text.DecimalFormat(""#.############"").format(o);
				b.append(delim).append(o);
			}
		}
		private static java.io.PrintWriter pw = new java.io.PrintWriter(System.out);
		private static void print(Object o, Object ... A) { pw.println(build(o, A)); }
		private static void err(Object o, Object ... A) { System.err.println(build(o, A)); }
		private static void exit() {
			IOUtils.pw.close();
			System.out.flush();
			err(""------------------"");
			err(IOUtils.time());
			System.exit(0);
		}
		private static long t;
		private static long millis() { return System.currentTimeMillis(); }
		private static String time() { return ""Time: "" + (millis() - t) / 1000.0; }
	}
	public static void main (String[] args) { new B(); IOUtils.exit(); }
}
",3,3
"import java.io.*;
import java.util.*;

public class Main {

    static BufferedReader reader;
    static StringTokenizer tokenizer;
    static PrintWriter writer;

    static int nextInt() throws NumberFormatException, IOException {
        return Integer.parseInt(nextToken());
    }

    static long nextLong() throws NumberFormatException, IOException {
        return Long.parseLong(nextToken());
    }

    static double nextDouble() throws NumberFormatException, IOException {
        return Double.parseDouble(nextToken());
    }

    static String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }

    public static void main(String[] args) throws IOException {
        reader = new BufferedReader(new InputStreamReader(System.in));
        writer = new PrintWriter(System.out);
        pineapple();
        reader.close();
        writer.close();
    }

    static void pineapple() throws NumberFormatException, IOException {
        int n = nextInt();
        int a = nextInt();
        int b = nextInt();
        HashSet<Integer> al = new HashSet<Integer>();
        HashMap<Integer, Integer> mp = new HashMap<Integer, Integer>();
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        HashSet<Integer> used = new HashSet<Integer>();
        int[] mas = new int[n];

        for (int i = 0; i < n; i++) {
            int t = nextInt();
            al.add(t);
            mas[i] = t;
            mp.put(t, i);
        }

        for (int st : al) {
            if (used.contains(st))
                continue;

            {
                int pr = st;
                int cc = -1;
                HashSet<Integer> u2 = new HashSet<Integer>();
                u2.add(pr);
                if (!u2.contains(a - pr) && al.contains(a - pr))
                    cc = a - pr;
                if (!u2.contains(a - pr) && al.contains(b - pr))
                    cc = b - pr;
                if (cc != -1) {
                    u2.add(cc);
                    boolean bGo = true;
                    while (bGo) {
                        bGo = false;
                        int nxt = -1;
                        if (!u2.contains(a - cc) && al.contains(a - cc))
                            nxt = a - cc;
                        if (!u2.contains(b - cc) && al.contains(b - cc))
                            nxt = b - cc;
                        if (nxt != -1) {
                            bGo = true;
                            u2.add(nxt);
                            cc = nxt;
                            pr = cc;
                        }
                    }
                    st = cc;
                }
            }

            LinkedList<Integer> ll = new LinkedList<Integer>();
            ll.add(st);
            while (!ll.isEmpty()) {
                int curr = ll.pollFirst();
                used.add(curr);
                int next1 = a - curr;
                if (al.contains(next1)) {
                    if (!used.contains(next1)) {
                        ll.addLast(next1);
                        if (ans[mp.get(curr)] == -1 && ans[mp.get(next1)] == -1) {
                            ans[mp.get(next1)] = 0;
                            ans[mp.get(curr)] = 0;
                        }
                    }
                }
                int next2 = b - curr;
                if (al.contains(next2)) {
                    if (!used.contains(next2)) {
                        ll.addLast(next2);
                        if (ans[mp.get(curr)] == -1 && ans[mp.get(next2)] == -1) {
                            ans[mp.get(next2)] = 1;
                            ans[mp.get(curr)] = 1;
                        }
                    }
                }
            }
        }

        for (int i = 0; i < n; i++) {
            if (ans[i] == -1) {
                if (2 * mas[i] == a) {
                    ans[i] = 0;
                    continue;
                }
                if (2 * mas[i] == b) {
                    ans[i] = 1;
                    continue;
                }
                writer.println(""NO"");
                return;
            }
        }

        writer.println(""YES"");
        for (int i = 0; i < n; i++) {
            writer.print(ans[i] + "" "");
        }
    }
    }",3,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;


public class B {	
	BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter out;
    
	public void solve() throws IOException {				
		int N = nextInt();
        int A = nextInt();
        int B = nextInt();

        int[] nsA = new int[N];
        int[] nsB = new int[N];
        char[] ans = new char[N];

        Arrays.fill(nsA, -1);
        Arrays.fill(nsB, -1);
        Arrays.fill(ans, 'C');

        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        int[] P = new int[N];
		for (int i = 0; i < N; i++) {
            P[i] = nextInt();
            map.put(P[i], i);
        }

        // if A == B
        if (A == B) {
            for (int i = 0; i < N; i++) {
                if (!map.containsKey(A - P[i])) {
                    out.println(""NO""); return;
                }
            }

            out.println(""YES"");
            for (int i = 0; i < N; i++) {
                out.print(0 + "" "");
            }
            out.println();
            return;
        }


        for (int i = 0; i < N; i++) {
            int oppA = A - P[i];
            int oppB = B - P[i];

            if (map.containsKey(oppA)) {
                nsA[i] = map.get(oppA);
            }

            if (map.containsKey(oppB)) {
                nsB[i] = map.get(oppB);
            }
        }

        for (int i = 0; i < N; i++) {
            if (nsA[i] == -1 && nsB[i] == -1) {
                out.println(""NO"");
                return;
            }
        }

        for (int i = 0; i < N; i++) {
            if (ans[i] != 'C') continue;

            if (nsA[i] == -1) {
                if (!go(i, 'B', ans, nsA, nsB) ){
                    out.println(""NO""); return;
                }
            } else if (nsB[i] == -1) {
                if (!go(i, 'A', ans, nsA, nsB) ){
                    out.println(""NO""); return;
                }
            }
        }

        for (int i = 0; i < N; i++) {
            if (ans[i] != 'C') continue;

            if (nsA[i] == i || nsB[i] == i) {
                if (nsA[i] == i) {
                    if (!go(i, 'B', ans, nsA, nsB) ){
                        out.println(""NO""); return;
                    }
                } else {
                    if (!go(i, 'A', ans, nsA, nsB) ){
                        out.println(""NO""); return;
                    }
                }
            }
        }

        for (int i = 0; i < N; i++) {
            if (ans[i] != 'C') continue;

            if (!go(i, 'A', ans, nsA, nsB) ){
                out.println(""NO""); return;
            }
        }

        for (int i = 0; i < N; i++) {
            if (ans[i] == 'C') {
                out.println(""NO"");
                return;
            }
        }

        out.println(""YES"");
        for (int i = 0; i < N; i++) {
            out.print(ans[i] == 'A'? 0: 1);
            out.print("" "");
        }
        out.println();
	}

    public boolean go(int cur, char link, char[] ans, int[] nsA, int[] nsB) {
        while (ans[cur] == 'C') {
            int next = link == 'A'? nsA[cur]: nsB[cur];

            if (next == -1) return false;
            if (ans[next] != 'C') return false;
            ans[cur] = link;
            ans[next] = link;


            int nextNext = link == 'A'? nsB[next]: nsA[next];
            cur = nextNext;

            if (cur == -1) return true;

        }

        return true;
    }
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		new B().run();
	}
	
	public void run() {
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            out = new PrintWriter(System.out);
            solve();
            reader.close();
            out.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            tokenizer = new StringTokenizer(reader.readLine());
        }
        return tokenizer.nextToken();
    }

}
",3,3
"/*
 * Hopefully this is AC :D
 */

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.StringTokenizer;
import java.util.Arrays;

public class TwoSets {

	static ArrayList<Integer> g[];
	static boolean visited[];
	static int ans[],p[],orig[];
	static int n,a,b;
	
	@SuppressWarnings(""unchecked"")
	public static void main(String args[] ) throws Exception {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	    PrintWriter w = new PrintWriter(System.out);
	        
	    StringTokenizer st1 = new StringTokenizer(br.readLine());
	    n = ip(st1.nextToken());
	    a = ip(st1.nextToken());
	    b = ip(st1.nextToken());
	    
	    g = new ArrayList[n];
	    visited = new boolean[n];
	    ans = new int[n];
	    p = new int[n];
	    orig = new int[n];
	    
	    StringTokenizer st2 = new StringTokenizer(br.readLine());
	    for(int i=0;i<n;i++){
	    	p[i] = ip(st2.nextToken());
	    	orig[i] = p[i];
	    	g[i] = new ArrayList<Integer>();
	    }
	    
	    Arrays.sort(p);
	    
	    boolean impossible = false;
	    
	    for(int i=0;i<n;i++){
	    	int i1 = Arrays.binarySearch(p, a-p[i]);
	    	int i2 = Arrays.binarySearch(p, b-p[i]);
	    	if(i1 < 0 || i1 >= n)	i1 = -1;
	    	if(i2 < 0 || i2 >= n)	i2 = -1;
	    	
	    	if(i1 == -1 && i2 != -1) //if only (b-x) present then both must belong to set 1
	    		g[i].add(i2);
	    	
	    	else if(i1 != -1 && i2 == -1) //if only (a-x) present then both must belong to set 0
	    		g[i].add(i1);
	    	
	    	else if(i1 != -1 && i2 != -1){ //both present hence all 3 should be in same set,doesn't matter which
	    		g[i].add(i1);
	    		g[i].add(i2);
	    	}
	    	else{ //if none present then not possible to be in any set
	    		impossible = true;
	    		break;
	    	}
	    }
	   
	    if(impossible){//if any element without both a-x and b-x found
	    	System.out.println(""NO"");
	    	return;
	    }
	    
	    //Edge between a and b means they must be present in same set
	    //ans[i] =0 or ans[i] =1 means it must be compulsory be present in that set
	    //ans[i] = -1 means no restrictions on it's set number
	    
	    LinkedList<Integer>	q = new LinkedList();//Queue
	    for(int i=0;i<n;i++){
	    	
	    	if(visited[i] == false){
	    		
	    		ArrayList<Integer>	curq = new ArrayList<Integer>();      //contains indices of all nodes in this connected component
	    		
	    		curq.add(i);
	    		q.add(i);
	    		visited[i] = true;
	    
	    		while(!q.isEmpty()){
	    			int curr = q.remove();
	    			int s = g[curr].size();
	    			for(int j=0;j<s;j++){
	    				if(!visited[g[curr].get(j)]){
	    					visited[g[curr].get(j)] = true;
	    					curq.add(g[curr].get(j));
	    					q.add(g[curr].get(j));
	    				}
	    			}
	    		}
	    
	    		boolean  found = true;
	    		
    			int s = curq.size();
	    		int temp[] = new int[s];
    			for(int j=0;j<s;j++)
    				temp[j] = p[curq.get(j)];
    			Arrays.sort(temp);
    			
    			int anss = -1;
    			
	    		for(int j=0;j<s;j++){
	    			int i3 = Arrays.binarySearch(temp, a - temp[j]);
	    			if(i3 < 0 || i3 >= n){
	   					found = false;
	   					break;
	   				}
	   			}
	    			
	    		if(!found){
	    			found = true;
	    				
	    			for(int j=0;j<s;j++){
		    			int i3 = Arrays.binarySearch(temp, b - temp[j]);
		   				if(i3 < 0 || i3 >= n){
		   					found = false;
		   					break;
		   				}
	    			}
	    			
	    			if(found)
	    				anss = 1;
	    			else{
	    				impossible = true;
	    				break;
	    			}
	    				    			
	    		}
	    		else
	    			anss = 0;
	    		
	    		for(int j=0;j<s;j++)
	    			ans[curq.get(j)] = anss;
	    	
	    	}
	    	
	    	
	    }
	    
	    if(!impossible){
	    	w.println(""YES"");
    		for(int i=0;i<n;i++){
    			int i1 = Arrays.binarySearch(p, orig[i]);
    			if(ans[i1] == -1)	ans[i1] = 1;
    			w.print(ans[i1] + "" "");
    		}
    		w.println();
    	}
	    else
	    	w.println(""NO"");
	    
	    w.close(); 
	}
	
	public static int ip(String s){
		return Integer.parseInt(s);
	}
}
",3,3
"
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * 4 4
 * 1 5 3 4
 * 1 2
 * 1 3
 * 2 3
 * 3 3
 *
 *
 * @author pttrung
 */
public class A {

    public static long Mod = (long) (1e9 + 7);
    public static long[][] dp;

    public static void main(String[] args) throws FileNotFoundException {

        PrintWriter out = new PrintWriter(System.out);
        Scanner in = new Scanner();
        int n = in.nextInt();
        int a = in.nextInt();
        int b = in.nextInt();
        int[] data = new int[n];
        int[]u = new int[n];
        int[]s = new int[n];
        HashMap<Integer, Integer> map = new HashMap();
        
        for(int i = 0; i < n; i++){
            u[i] = i;
            data[i] = in.nextInt();
            map.put(data[i], i);
        }        
        boolean ok = true;
        boolean[]check = new boolean[n];
        for(int i = 0; i < n; i++){
            if(map.containsKey(a - data[i])){
                u[find(i, u)]= u[find(map.get(a- data[i]), u)];
                s[i] |= 1;
            }
            if(map.containsKey(b - data[i])){
                u[find(i, u)]= u[find(map.get(b- data[i]), u)];
                s[i] |= 2;
            }
            
        }
        int[]g = new int[n];
        Arrays.fill(g,3);
        for(int i = 0;  i< n; i++){
            if(s[i] == 0){
                ok = false;
                break;
            }
            g[find(i, u)] &= s[i];
            if(g[find(i,u)] == 0){
                ok = false;
                break;
            }
        }
        //System.out.println(Arrays.toString(g));
        if(ok){
            out.println(""YES"");
            for(int i = 0; i < n; i++){
                if((g[find(i,u)] & 1) == 0){
                    out.print(1 + "" "");
                }else{
                    out.print(0 + "" "");
                }
            }
        }else{
            out.println(""NO"");
        }

        out.close();
    }
    
    static int find(int index, int[]u){
        if(index != u[index]){
            return u[index] = find(u[index], u);
        }
        return index;
    }

    public static long pow(int a, int b, long mod) {
        if (b == 0) {
            return 1;
        }
        if (b == 1) {
            return a;
        }
        long v = pow(a, b / 2, mod);
        if (b % 2 == 0) {
            return (v * v) % mod;
        } else {
            return (((v * v) % mod) * a) % mod;
        }
    }

    public static int[][] powSquareMatrix(int[][] A, long p) {
        int[][] unit = new int[A.length][A.length];
        for (int i = 0; i < unit.length; i++) {
            unit[i][i] = 1;
        }
        if (p == 0) {
            return unit;
        }
        int[][] val = powSquareMatrix(A, p / 2);
        if (p % 2 == 0) {
            return mulMatrix(val, val);
        } else {
            return mulMatrix(A, mulMatrix(val, val));
        }

    }

    public static int[][] mulMatrix(int[][] A, int[][] B) {
        int[][] result = new int[A.length][B[0].length];
        for (int i = 0; i < result.length; i++) {
            for (int j = 0; j < result[0].length; j++) {
                long temp = 0;
                for (int k = 0; k < A[0].length; k++) {

                    temp += ((long) A[i][k] * B[k][j] % Mod);
                    temp %= Mod;
                }
                temp %= Mod;
                result[i][j] = (int) temp;
            }
        }

        return result;
    }

    public static boolean nextPer(int[] data) {
        int i = data.length - 1;
        while (i > 0 && data[i] < data[i - 1]) {
            i--;
        }
        if (i == 0) {
            return false;
        }
        int j = data.length - 1;
        while (data[j] < data[i - 1]) {
            j--;
        }
        int temp = data[i - 1];
        data[i - 1] = data[j];
        data[j] = temp;
        Arrays.sort(data, i, data.length);
        return true;




    }

    static class FT {

        int[] data;

        FT(int n) {
            data = new int[n];
        }

        void update(int index, int val) {
            // System.out.println(""UPDATE INDEX "" + index);
            while (index < data.length) {
                data[index] += val;
                index += index & (-index);

                //    System.out.println(""NEXT "" +index);
            }
        }

        int get(int index) {
            //  System.out.println(""GET INDEX "" + index);
            int result = 0;
            while (index > 0) {
                result += data[index];
                index -= index & (-index);
                // System.out.println(""BACK "" + index);
            }
            return result;
        }
    }

    static long gcd(long a, long b) {
        if (b == 0) {
            return a;
        } else {
            return gcd(b, a % b);
        }
    }

    static long pow(long a, int b) {
        if (b == 0) {
            return 1;
        }
        if (b == 1) {
            return a;
        }
        long val = pow(a, b / 2);
        if (b % 2 == 0) {

            return val * val % Mod;
        } else {
            return (val * val % Mod) * a % Mod;
        }
    }

//    static Point intersect(Point a, Point b, Point c) {
//        double D = cross(a, b);
//        if (D != 0) {
//            return new Point(cross(c, b) / D, cross(a, c) / D);
//        }
//        return null;
//    }
//
//    static Point convert(Point a, double angle) {
//        double x = a.x * cos(angle) - a.y * sin(angle);
//        double y = a.x * sin(angle) + a.y * cos(angle);
//        return new Point(x, y);
//    }
    static Point minus(Point a, Point b) {
        return new Point(a.x - b.x, a.y - b.y);
    }
//
//    static Point add(Point a, Point b) {
//        return new Point(a.x + b.x, a.y + b.y);
//    }
//

    /**
     * Cross product ab*ac
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    static double cross(Point a, Point b, Point c) {
        Point ab = new Point(b.x - a.x, b.y - a.y);
        Point ac = new Point(c.x - a.x, c.y - a.y);
        return cross(ab, ac);
    }

    static double cross(Point a, Point b) {
        return a.x * b.y - a.y * b.x;
    }

    /**
     * Dot product ab*ac;
     *
     * @param a
     * @param b
     * @param c
     * @return
     */
    static long dot(Point a, Point b, Point c) {
        Point ab = new Point(b.x - a.x, b.y - a.y);
        Point ac = new Point(c.x - a.x, c.y - a.y);
        return dot(ab, ac);
    }

    static long dot(Point a, Point b) {
        long total = a.x * b.x;
        total += a.y * b.y;
        return total;
    }

    static double dist(Point a, Point b) {
        long total = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
        return Math.sqrt(total);
    }

    static long norm(Point a) {
        long result = a.x * a.x;
        result += a.y * a.y;
        return result;
    }

    static double dist(Point a, Point b, Point x, boolean isSegment) {
        double dist = cross(a, b, x) / dist(a, b);
        // System.out.println(""DIST "" + dist);

        if (isSegment) {
            Point ab = new Point(b.x - a.x, b.y - a.y);

            long dot1 = dot(a, b, x);
            long norm = norm(ab);
            double u = (double) dot1 / norm;
            if (u < 0) {
                return dist(a, x);
            }

            if (u > 1) {
                return dist(b, x);
            }
        }
        return Math.abs(dist);




    }

    static long squareDist(Point a, Point b) {
        long x = a.x - b.x;
        long y = a.y - b.y;
        return x * x + y * y;
    }

    static class Point {

        int x, y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public String toString() {
            return ""Point{"" + ""x="" + x + "", y="" + y + '}';
        }
    }

    static class Scanner {

        BufferedReader br;
        StringTokenizer st;

        public Scanner() throws FileNotFoundException {
            //System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));
            br = new BufferedReader(new InputStreamReader(System.in));
            //br = new BufferedReader(new FileReader(new File(""A-large (2).in"")));
        }

        public String next() {


            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (Exception e) {
                    throw new RuntimeException();
                }
            }
            return st.nextToken();
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            st = null;
            try {
                return br.readLine();
            } catch (Exception e) {
                throw new RuntimeException();
            }
        }

        public boolean endLine() {
            try {
                String next = br.readLine();
                while (next != null && next.trim().isEmpty()) {
                    next = br.readLine();
                }
                if (next == null) {
                    return true;
                }
                st = new StringTokenizer(next);
                return st.hasMoreTokens();
            } catch (Exception e) {
                throw new RuntimeException();
            }
        }
    }
}
",3,5
"import java.util.Map;
import java.io.IOException;
import java.util.InputMismatchException;
import java.util.TreeMap;
import java.io.PrintStream;
import java.io.OutputStream;
import java.util.ArrayDeque;
import java.io.PrintWriter;
import java.util.Deque;
import java.math.BigInteger;
import java.util.Queue;
import java.util.Collection;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author karan173
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskB
{
    int val[];
    int p[];
    int aneigh[], bneight[], deg[];
    Deque<Integer> mycycle;
    boolean loops = false;
    public void solve(int testNumber, FastReader in, PrintWriter out)
    {
        int n = in.ni ();
        val = new int[n];
        int a = in.ni ();
        int b = in.ni ();
        Map<Integer, Integer> set = new TreeMap<Integer, Integer> ();
        p = in.iArr (n);
        for (int i = 0; i < n; i++)
        {
            set.put (p[i], i);
        }
        aneigh = new int[n];
        bneight = new int[n];
        deg = new int[n];
        for (int i = 0; i < n; i++)
        {
            aneigh[i] = val[i] = bneight[i] = -1;
            deg[i] = 0;
        }
        Queue<Integer> queue = new ArrayDeque<Integer> ();
        for (int i = 0; i < n; i++)
        {
            Integer x1 = set.get (a - p[i]);
            Integer x2 = set.get (b - p[i]);
            if (x1 != null)
            {
                aneigh[i] = x1;
                deg[i]++;
            }
            if (x2 != null && a != b)
            {
                bneight[i] = x2;
                deg[i]++;
            }
            if (deg[i] == 1)
            {
                queue.add (i);
            }
        }

        while (!queue.isEmpty ())
        {
            int idx = queue.remove ();
            if (deg[idx] != 1)
            {
                continue;
            }
            int aa = aneigh[idx];
            int bb = bneight[idx];
            if (aa != -1)
            {
                val[idx] = val[aa] = 0;
                deg[aa]--;
                deg[idx]--;
                aneigh[aa] = -1;
                aneigh[idx] = -1;
                if (deg[aa] == 1)
                {
                    int zz = bneight[aa];
                    bneight[zz] = -1;
                    deg[zz]--;
                    if(deg[zz] == 1)
                    queue.add (zz);
                }
            }
            else
            {
                val[idx] = val[bb] = 1;
                deg[bb]--;
                deg[idx]--;
                bneight[idx] = bneight[bb] = -1;
                if (deg[bb] == 1)
                {
                    //queue.add (bb);
                    int zz = aneigh[bb];
                    aneigh[zz] = -1;
                    deg[zz]--;
                    if(deg[zz] == 1)
                        queue.add (zz);
                }
            }
        }

        for (int i = 0; i < n; i++)
        {
            if (val[i] == -1 && cantBePaired(i))
            {
                out.println (""NO"");
                return;
            }
        }

        //every person has two neighbours

        //cases => either cycles or linear path with loops end points
        for (int i = 0; i < n; i++)
        {
            if (val[i] == -1)
            {
                mycycle = new ArrayDeque<Integer> ();
                loops = false;
                cycle (i);
                if (loops || mycycle.size () % 2 == 0)
                {
                    doEvenCycle ();
                    continue;
                }

                out.println (""NO"");
                return;
            }
        }
        out.println (""YES"");
        for (int i = 0; i < n; i++)
        {
            out.print (val[i] + "" "");
        }
        out.println ();
    }

    private boolean cantBePaired(int i)
    {
        int aa = aneigh[i];
        int bb = bneight[i];
        if (aa != -1 && val[aa] == -1)
        {
            return false;
        }
        if (bb != -1 && val[bb] == -1)
        {
            return false;
        }
        return true;
    }


    private void doEvenCycle()
    {
        for (int x : mycycle)
        {
            val[x] = 0;
        }
    }

    private void cycle(int i)
    {
        boolean aa = false;
        int prev = i;
        mycycle.addLast (i);
        System.out.println (i);
        int j = aneigh[i];
        while (j != i)
        {
            if (j == prev)
            {
                loops = true;
                break;
            }
            mycycle.addLast (j);
            System.out.println (j);
            prev = j;
            j = aa ? aneigh[j] : bneight[j];
//            if (j == -1)
//            {
//                System.out.println (prev + "" "" + aneigh[prev] + bneight[prev] + "" "" + deg[prev] + "" "" + val[prev] + "" "" + val[64] + "" "" + deg[64]);
//            }
            aa = !aa;
        }

        if (loops)
        {
            j = bneight[i];
            prev = i;
            aa = true;
            while (prev != j)
            {
                mycycle.addFirst (j);

                prev = j;
                j = aa ? aneigh[j] : bneight[j];
                aa = !aa;
            }
        }
        System.out.println (""XXX"");
    }
}

class FastReader
{

    public InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public FastReader(InputStream stream)
    {
        this.stream = stream;
    }

    public FastReader()
    {

    }

    public int read()
    {
        if (numChars == -1)
        {
            throw new InputMismatchException ();
        }
        if (curChar >= numChars)
        {
            curChar = 0;
            try
            {
                numChars = stream.read (buf);
            } catch (IOException e)
            {
                throw new InputMismatchException ();
            }
            if (numChars <= 0)
            {
                return -1;
            }
        }
        return buf[curChar++];
    }

    public int ni()
    {
        int c = read ();
        while (isSpaceChar (c))
            c = read ();
        int sgn = 1;
        if (c == '-')
        {
            sgn = -1;
            c = read ();
        }
        int res = 0;
        do
        {
            if (c < '0' || c > '9')
            {
                throw new InputMismatchException ();
            }
            res *= 10;
            res += c - '0';
            c = read ();
        } while (!isSpaceChar (c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c)
    {
        if (filter != null)
        {
            return filter.isSpaceChar (c);
        }
        return isWhitespace (c);
    }

    public static boolean isWhitespace(int c)
    {
        return c==' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public int[] iArr(int n)
    {
        int a[] = new int[n];
        for (int i = 0; i < n; i++)
        {
            a[i] = ni ();
        }
        return a;
    }

    public interface SpaceCharFilter
    {
        public boolean isSpaceChar(int ch);
    }
}
",3,3
"import java.util.Map;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.TreeMap;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 * @author Hamed Valizadeh (havaliza@gmail.com)
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastInputReader in = new FastInputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskB {
    int n, a, b;
    Map<Integer, Integer> position;
    int[] p;
    int[] group;

    public void solve(int testNumber, FastInputReader in, PrintWriter out) {
        n = in.nextInt();
        a = in.nextInt();
        b = in.nextInt();

        position = new TreeMap<Integer, Integer>();
        p = new int[n];
        group = new int[n];

        for (int i = 0; i < n; i++) {
            p[i] = in.nextInt();
            group[i] = -1;
            position.put(p[i], i);
        }

        for (int i = 0; i < n; i++) {
            if (getMate(i) != -1)
                continue;
            out.println(""NO"");
            return;
        }

        for (int i = 0; i < n; i++) {
            boolean aMate = position.containsKey(a - p[i]);
            boolean bMate = position.containsKey(b - p[i]);
            if (aMate && bMate)
                continue;
            if (group[i] != -1)
                continue;
            if (!solve(i)) {
                out.println(""NO"");
                return;
            }
        }

        for (int i = 0; i < n; i++) {
            if (group[i] != -1)
                continue;
            if (!solve(i)) {
                out.println(""NO"");
                return;
            }
        }

        out.println(""YES"");
        for (int i = 0; i < n; i++) {
            out.print(group[i]);
            out.print("" "");
        }
        out.println();
    }

    private boolean solve(int index) {
        int mate = getMate(index);
        if (mate == -1)
            return false;
        assign(index, mate);
        if (getMate(index) != -1)
            return solve(getMate(index));
        else
            return getMate(mate) == -1 || solve(getMate(mate));
    }

    private void assign(int index, int mate) {
        int sum = p[index] + p[mate];
        if (sum == a) {
            group[index] = group[mate] = 0;
            return;
        }
        if (sum == b) {
            group[index] = group[mate] = 1;
            return;
        }
        throw new RuntimeException(""Wrong assignment :("");
    }

    private int getMate(int index) {
        int[] possibleMates = new int[] {a - p[index], b - p[index]};
        for (int mate: possibleMates) {
            if (position.containsKey(mate)) {
                int mateIndex = position.get(mate);
                if (group[mateIndex] == -1)
                    return mateIndex;
            }
        }
        return -1;
    }
}

class FastInputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public FastInputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream), 32768);
        tokenizer = null;
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }
}

",3,3
"import java.util.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class Main{
	
	// ArrayList<Integer> lis = new ArrayList<Integer>();
	// ArrayList<String> lis = new ArrayList<String>();
	//  PriorityQueue<P> que = new PriorityQueue<P>();
	// PriorityQueue<Integer> que = new PriorityQueue<Integer>();
	//  Stack<Integer> que = new Stack<Integer>();
	//HashMap<Long,Long> map = new HashMap<Long,Long>();
    //	static long sum=0;
	// 1000000007 (10^9+7)
	static int mod = 1000000007;
	//static int mod = 1000000009,r=0; ArrayList<Integer> l[]= new ArrayList[n];
   // static int dx[]={1,-1,0,0};
//	static int dy[]={0,0,1,-1};
//	static int dx[]={1,-1,0,0,1,1,-1,-1};
//  static int dy[]={0,0,1,-1,1,-1,1,-1};
	//static Set<Integer> set = new HashSet<Integer>();p
	
	static ArrayList<Integer> cd[];
	static int K=0;
	
public  static void main(String[] args)   throws Exception, IOException{
   //String line=""""; throws Exception, IOException
   //(line=br.readLine())!=null
	//Scanner sc =new Scanner(System.in);
	// !!caution!! int long //  
	Reader sc = new Reader(System.in);


 //,a=sc.nextInt(),b=sc.nextInt();
 	// int n=sc.nextInt(),p[]=new int[n],q[]=new int[n];
	//int n=sc.nextInt(),a[]=new int[n],b[]=new int[n];
 // int n=sc.nextInt(),m=sc.nextInt(),a=sc.nextInt(),b=sc.nextInt();
	// int r=1<<28;
	
	int n=sc.nextInt();//,k=sc.nextInt();
    int a=sc.nextInt(),b=sc.nextInt(),d[]=new int[n];
    HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
    ArrayList<Integer> A = new ArrayList<Integer>();
    
    
    for (int i = 0; i < n ; i++) {
    
    	d[i]=sc.nextInt();
    	map.put(d[i],i );
    	
    }
    
    int c=1;
	 if( a>b ){c--; int x=a; a=b; b=x;}
	 
	 int r[]=new int[n];
	 
	 if(a==b){
		
		  for (int i = 0; i < n; i++) {
			  if(d[i]>a || !map.containsKey(a-d[i]) ){System.out.println(""NO""); return;}
		  }
System.out.println(""YES"");
		  for (int i = 0; i < n; i++) {System.out.print(""1 "");}
		  System.out.println();
		 return;
	 }
	 
       sort(d);

    for (int j = 0; j < n; j++) {
         int i=n-j-1;
    	int id=map.get(d[i]),idd=-1;
    	if(  id<0)continue;
    	
    //	db(id,d[i]);
    	
    	if( d[i]<=a ){
    		 if( map.containsKey(a-d[i]) && 0<=(idd=map.get(a-d[i]))  ){   
    		r[id]=r[idd]=(c+1)%2;  
    		map.put(a-d[i], -1);
    		 }
    		 else if( map.containsKey(b-d[i]) && 0<=(idd=map.get(b-d[i])) ){ 
    	    		r[id]=r[idd]=c;
    	    		map.put(b-d[i], -1); }
    		else{ System.out.println(""NO""); return; }
    		 
    	}
     
    	else{
    		
    		if( map.containsKey(b-d[i]) && 0<=(idd=map.get(b-d[i]))   ){ 
    			r[id]=r[idd]=c;
    		map.put(b-d[i], -1); }
    		else{ System.out.println(""NO""); return; }
    		
    	}
    	map.put(d[i], -1);
		
    
    }
    	System.out.println(""YES"");
         for (int j = 0; j < n; j++) {
			System.out.print(r[j]+"" "");
		}
    	System.out.println();
    
    
    
    
    
}


  static class P implements Comparable<P>{
//	implements Comparable<Pair>
	int id; long  d; ;
	P(int id,long d){
		this.id=id;
		this.d=d;
	} 
	
	public int compareTo(P x){
		return  (-x.d+d)>=0?1:-1  ; // ascend long
	//	return   -x.d+d  ; // ascend
	//	 return   x.d-d  ; //descend
	   }
 
}
  

static void db(Object... os){
    System.err.println(Arrays.deepToString(os));

}


}



class Reader
{ 
	private BufferedReader x;
	private StringTokenizer st;
	
	public Reader(InputStream in)
	{
		x = new BufferedReader(new InputStreamReader(in));
		st = null;
	}
	public String nextString() throws IOException
	{
		while( st==null || !st.hasMoreTokens() )
			st = new StringTokenizer(x.readLine());
		return st.nextToken();
	}
	public int nextInt() throws IOException
	{
		return Integer.parseInt(nextString());
	}
	public long nextLong() throws IOException
	{
		return Long.parseLong(nextString());
	}
	public double nextDouble() throws IOException
	{
		return Double.parseDouble(nextString());
	}
}",3,3
"import java.io.*;
import java.util.*;

public class Pr468B {
	public static void main(String[] args) throws IOException {
		new Pr468B().run();
	}

	BufferedReader in;
	PrintWriter out;
	StringTokenizer st;

	String nextToken() throws IOException {
		while (st == null || !st.hasMoreTokens()) {
			st = new StringTokenizer(in.readLine());
		}
		return st.nextToken();
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	void run() throws IOException {
		in = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out, true);
		solve();
		out.flush();
	}

	int[] which;
	boolean[] was;
	int[] pa;
	int[] pb;

	void dfs(int i, boolean fa) {
		was[i] = true;
		if (fa) {
			if (pa[i] == -1) {
				out.println(""NO"");
				out.flush();
				System.exit(0);
			}
			which[i] = 0;
			which[pa[i]] = 0;
			if (pb[pa[i]] != -1 && !was[pb[pa[i]]]) {
				dfs(pb[pa[i]], fa);
			}
		} else {
			if (pb[i] == -1) {
				out.println(""NO"");
				out.flush();
				System.exit(0);
			}
			which[i] = 1;
			which[pb[i]] = 1;
			if (pa[pb[i]] != -1 && !was[pa[pb[i]]]) {
				dfs(pa[pb[i]], fa);
			}
		}
	}

	void solve() throws IOException {
		int n = nextInt();
		int a = nextInt();
		int b = nextInt();
		int[] p = new int[n];
		HashMap<Integer, Integer> allNums = new HashMap<Integer, Integer>();
		for (int i = 0; i < n; i++) {
			p[i] = nextInt();
			if (p[i] >= Math.max(a, b)) {
				out.println(""NO"");
				return;
			}
			allNums.put(p[i], i);
		}
		pa = new int[n];
		pb = new int[n];
		Arrays.fill(pa, -1);
		Arrays.fill(pb, -1);
		which = new int[n];
		Arrays.fill(which, -1);
		for (int i = 0; i < n; i++) {
			if (pa[i] == -1 && allNums.containsKey(a - p[i])) {
				pa[i] = allNums.get(a - p[i]);
				pa[pa[i]] = i;
			}
			if (pb[i] == -1 && allNums.containsKey(b - p[i])) {
				pb[i] = allNums.get(b - p[i]);
				pb[pb[i]] = i;
			}
			if (pa[i] == -1 && pb[i] == -1) {
				out.println(""NO"");
				return;
			}
		}
		was = new boolean[n];
		for (int i = 0; i < n; i++) {
			if (!was[i] && pa[i] == -1) {
				dfs(i, false);
			} else if (!was[i] && pb[i] == -1) {
				dfs(i, true);
			}
		}
		for (int i = 0; i < n; i++) {
			if (!was[i]) {
				dfs(i, true);
			}
		}
		out.println(""YES"");
		for (int i = 0; i < n; i++) {
			out.print(which[i] + "" "");
		}
	}
}
",3,3
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class Main {
	public static void main(String[] args) throws Exception {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);

		Task task = new Task();
		task.solve(in, out);
		out.close();

	}
	
	static class Rectangle {
		int x1, y1;
		int x2, y2;
	}
	
	static class Task {
		/**
		 * BEFORE SUBMITTING!!!
		 * MAKE SURE IT IS RIGHT!!!!!
		 * LONG!!
		 * Check if m,n aren't misused
		 * Make sure the output format is right (YES/NO vs Yes/No, newlines vs spaces)
		 * Run with n = 1 or n = 0
		 * Make sure two ints aren't multiplied to get a long

		 *
		 */
		public void solve(InputReader in, PrintWriter out) {
			int n = in.nextInt();
			
			//ideas: procurar linha que os divide e procurar dentro desses sub-retangulos
			// procurar atÃ© ser 1
			
			//corner cases: se procurar atÃ© ser 1 e nÃ£o verificar se tem 1 do outro lado posso chegar a 1,2...not good
			// tenho que procurar 1,1
			
			int l = 1;
			int r = n;
			
			int ans = 0;
			
			
			while(r >= l) {
				int mid = (r + l) / 2;
				if(ask(in,out,1,1,mid, n) == 0) {
					l = mid + 1;
				} else {
					ans = mid;
					r = mid - 1;
				}
			}
			//par 1,1
			//FDS ISTO
			if(ans < n && ask(in,out,ans + 1, 1,n,n) == 1) {
				Rectangle r1 = find(in,out,1,1,ans,n,n);
				Rectangle r2 = find(in,out,ans + 1,1,n,n,n);
				System.out.printf(""! %d %d %d %d %d %d %d %d\n"", r1.x1, r1.y1, r1.x2, r1.y2, r2.x1, r2.y1, r2.x2, r2.y2);
			} else {
				l = 1;
				r = n;
				
				ans = 0;
				
				
				while(r >= l) {
					int mid = (r + l) / 2;
					if(ask(in,out,1,1,n, mid) == 0) {
						l = mid + 1;
					} else {
						ans = mid;
						r = mid - 1;
					}
				}
				
				Rectangle r1 = find(in,out,1,1,n,ans,n);
				Rectangle r2 = find(in,out,1,ans + 1,n,n,n);
				System.out.printf(""! %d %d %d %d %d %d %d %d\n"", r1.x1, r1.y1, r1.x2, r1.y2, r2.x1, r2.y1, r2.x2, r2.y2);
				
			}
			
			
		}
		//HASDFDSJGHDFJKSGDFJSGJDFSGJDSFGJF
		//FKING WORK
		public Rectangle find(InputReader in, PrintWriter out,int x1, int y1, int x2, int y2, int n) {
			Rectangle rec = new Rectangle();
			
			int ansx1 = x1;
			int ansx2 = x2;
			int ansy1 = y1;
			int ansy2 = y2;

			int l = x1;
			int r = x2;
			

			// quero o minimo v >= x2 
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,y1,mid,y2) == 1) {
					ansx2 = mid;
					r = mid - 1;
				} else {
					l = mid + 1;
				}

			}
									
			//out.printf(""x2 = %d"", ansx2);
			
			

			r = x2;
			l = x1;
			
			// quero o maximo v <= x1
			
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,mid,y1,x2,y2) == 1) {
					ansx1 = mid;
					l = mid + 1;
				} else {
					r = mid - 1;
				}

			}
									
			//out.printf(""x1 = %d"", ansx1);
			
			
			l = y1;
			r = y2;
			
			// quero o minimo v >= y2 
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,y1,x2,mid) == 1) {
					ansy2 = mid;
					r = mid - 1;
				} else {
					l = mid + 1;
				}

			}
									
			//out.printf(""y2 = %d"", ansy2);
			

			
			

			r = y2;
			l = y1;
			

			// quero o maximo v <= y1
			
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,mid,x2,y2) == 1) {
					ansy1 = mid;
					l = mid + 1;
				} else {
					r = mid - 1;
				}

			}
									
			//out.printf(""y1 = %d"", ansy1);
			


			
			rec.x1 = ansx1;
			rec.x2 = ansx2;
			rec.y1 = ansy1;
			rec.y2 = ansy2;

			
			
			return rec;
		}
		
		public int ask(InputReader in, PrintWriter out, int x1, int y1, int x2, int y2) {
			System.out.printf(""? %d %d %d %d\n"",x1,y1,x2,y2);
			System.out.flush();
			return in.nextInt();
		}
	}

	static class InputReader {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public InputReader(InputStream stream) {
			reader = new BufferedReader(new InputStreamReader(stream), 32768);
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}
		
		public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            try {
                return reader.readLine();
               
            } catch (IOException e) {
            }
            return null;
        }


	}
}

     		   	 	 			  	  			   			",2,1
"import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Solution {
	static BufferedReader br;
	static int[] ans;
	public static void main(String[] args) throws Exception{
		br = new BufferedReader(new InputStreamReader(System.in));
		ans = new int[8];
		int n = Integer.parseInt(br.readLine());
		System.out.println(""?""+""1 1 ""+n+"" ""+n);
		System.out.flush();
		int q = Integer.parseInt(br.readLine());
		cut(n);
		System.out.print(""! "");
		for(int i=0 ; i<8 ; i++)	System.out.print(ans[i]+"" "");
		System.out.println();
	}
	
	public static void solve(int x1, int y1, int x2, int y2, int t) throws Exception{
		int l=x1, r=x2;
		int xx1,yy1,xx2,yy2;
		while(l<r){
			int mid = (l+r)/2;
			if(query(x1,y1,mid,y2)==1)	r=mid;
			else	l=mid+1;
		}
		xx2 = l;
		l=x1; r=x2;
		while(r>l){
			int mid = (l+r+1)/2;
			if(query(mid,y1,x2,y2)==1)	l = mid;
			else r=mid-1;
		}
		xx1 = l;
		l=y1; r=y2;
		while(l<r){
			int mid = (l+r)/2;
			if(query(x1,y1,x2,mid)==1)	r=mid;
			else	l=mid+1;
		}
		yy2=l;
		l=y1;r=y2;
		while(r>l){
			int mid = (l+r+1)/2;
			if(query(x1,mid,x2,y2)==1)	l=mid;
			else	r=mid-1;
		}
		yy1 = l;
		ans[t] = xx1;	ans[t+1] = yy1 ; ans[t+2] = xx2;	ans[t+3] = yy2;
	//	System.out.println(""!""+xx1+"" ""+yy1+"" ""+xx2+"" ""+yy2);
	}
	public static void cut(int n) throws Exception{
		int l=1, r=n;
		while(l<r){
			int mid = (l+r)/2;
			if(query(1,1,n,mid)==0)	l=mid+1;
			else	r = mid;
		}
		if(query(1,1,n,l)==1 && query(1,l+1,n,n)==1){
			solve(1,1,n,l,0);
			solve(1,l+1,n,n,4);
			return;
		}
		l=1;r=n;
		while(l<r){
			int mid = (l+r)/2;
			if(query(1,1,mid,n)==0)	l=mid+1;
			else	r=mid;
		}
		solve(1,1,l,n,0);
		solve(l+1,1,n,n,4);
	}
	public static int query(int x1, int y1, int x2, int y2) throws Exception{
		System.out.println(""?""+x1+"" ""+y1+"" ""+x2+"" ""+y2);
		System.out.flush();
		int q = Integer.parseInt(br.readLine());
		return q;
	}
}",2,1
"//package round371;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;

public class BT {
	Scanner in;
	PrintWriter out;
	String INPUT = """";
	
	
	int q(int r1, int c1, int r2, int c2)
	{
		out.printf(""? %d %d %d %d\n"", r1+1, c1+1, r2+1, c2+1);
		out.flush();
		return ni();
	}
	
	void e(int r1, int c1, int r2, int c2, int r3, int c3, int r4, int c4)
	{
		out.printf(""! %d %d %d %d %d %d %d %d\n"", 
				r1+1, c1+1, r2+1, c2+1,
				r3+1, c3+1, r4+1, c4+1
				);
		out.flush();
	}
	
	void solve()
	{
		int n = ni();
		int cu = -1, cv = -1;
		{
			int low = -1, high = n-1;
			while(high - low > 1){
				int h = high+low>>1;
				if(q(0, 0, n-1, h) >= 2){
					high = h;
				}else{
					low = h;
				}
			}
			cu = high;
		}
		{
			int low = -1, high = n-1;
			while(high - low > 1){
				int h = high+low>>1;
				if(q(0, 0, n-1, h) >= 1){
					high = h;
				}else{
					low = h;
				}
			}
			cv = high;
		}
		
		int du = -1, dv = -1;
		{
			int low = 0, high = n;
			while(high - low > 1){
				int h = high+low>>1;
				if(q(0, h, n-1, n-1) >= 2){
					low = h;
				}else{
					high = h;
				}
			}
			du = low;
		}
		{
			int low = 0, high = n;
			while(high - low > 1){
				int h = high+low>>1;
				if(q(0, h, n-1, n-1) >= 1){
					low = h;
				}else{
					high = h;
				}
			}
			dv= low;
		}
		
		int eu = -1, ev = -1;
		{
			int low = -1, high = n-1;
			while(high - low > 1){
				int h = high+low>>1;
				if(q(0, 0, h, n-1) >= 2){
					high = h;
				}else{
					low = h;
				}
			}
			eu = high;
		}
		{
			int low = -1, high = n-1;
			while(high - low > 1){
				int h = high+low>>1;
				if(q(0, 0, h, n-1) >= 1){
					high = h;
				}else{
					low = h;
				}
			}
			ev = high;
		}
		
		int fu = -1, fv = -1;
		{
			int low = 0, high = n;
			while(high - low > 1){
				int h = high+low>>1;
				if(q(h, 0, n-1, n-1) >= 2){
					low = h;
				}else{
					high = h;
				}
			}
			fu = low;
		}
		{
			int low = 0, high = n;
			while(high - low > 1){
				int h = high+low>>1;
				if(q(h, 0, n-1, n-1) >= 1){
					low = h;
				}else{
					high = h;
				}
			}
			fv= low;
		}
		
		// cv <= cu
		// du <= dv
		int[][][] canc = {
				{{du, cu}, {dv, cv}},
				{{du, cv}, {dv, cu}}
		};
		int[][][] canr = {
				{{fu, eu}, {fv, ev}},
				{{fu, ev}, {fv, eu}}
		};
		for(int[][] cr : canr){
			if(cr[0][0] > cr[0][1])continue;
			if(cr[1][0] > cr[1][1])continue;
			for(int[][] cc : canc){
				if(cc[0][0] > cc[0][1])continue;
				if(cc[1][0] > cc[1][1])continue;
				for(int z = 0;z < 2;z++){
					if(
							q(cr[0][0], cc[0^z][0], cr[0][1], cc[0^z][1]) == 1 &&
							q(cr[1][0], cc[1^z][0], cr[1][1], cc[1^z][1]) == 1){
						e(cr[0][0], cc[0^z][0], cr[0][1], cc[0^z][1], cr[1][0], cc[1^z][0], cr[1][1], cc[1^z][1]);
						return;
					}
				}
			}
		}
		throw new RuntimeException();
	}
	
	void run() throws Exception
	{
		in = oj ? new Scanner(System.in) : new Scanner(INPUT);
		out = new PrintWriter(System.out);

		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception
	{
		new BT().run();
	}
	
	int ni() { return Integer.parseInt(in.next()); }
	long nl() { return Long.parseLong(in.next()); }
	double nd() { return Double.parseDouble(in.next()); }
	boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",2,1
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            BSearchingRectangles solver = new BSearchingRectangles();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class BSearchingRectangles {
        FastInput in;
        FastOutput out;
        int n;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            this.in = in;
            this.out = out;
            n = in.readInt();

            IntBinarySearch upDown = new IntBinarySearch() {

                public boolean check(int mid) {
                    return query(1, n, 1, mid) >= 1;
                }
            };

            IntBinarySearch leftRight = new IntBinarySearch() {

                public boolean check(int mid) {
                    return query(1, mid, 1, n) >= 1;
                }
            };
            int threshold = upDown.binarySearch(1, n);
            int[] r1;
            int[] r2;
            if (query(1, n, 1, threshold) == 1 &&
                    query(1, n, threshold + 1, n) == 1) {
                r1 = find(1, n, 1, threshold);
                r2 = find(1, n, threshold + 1, n);
            } else {
                threshold = leftRight.binarySearch(1, n);
                r1 = find(1, threshold, 1, n);
                r2 = find(threshold + 1, n, 1, n);
            }

            out.append(""! "");
            output(r1);
            output(r2);
            out.flush();
        }

        public void output(int[] ans) {
            for (int x : ans) {
                out.append(x).append(' ');
            }
        }

        public int[] find(int l, int r, int d, int u) {
            IntBinarySearch downIBS = new IntBinarySearch() {

                public boolean check(int mid) {
                    return query(l, r, mid, u) == 0;
                }
            };
            int y1 = downIBS.binarySearch(d, u);
            if (query(l, r, y1, u) == 0) {
                y1--;
            }

            IntBinarySearch upIBS = new IntBinarySearch() {

                public boolean check(int mid) {
                    return query(l, r, d, mid) >= 1;
                }
            };
            int y2 = upIBS.binarySearch(d, u);

            IntBinarySearch leftIBS = new IntBinarySearch() {

                public boolean check(int mid) {
                    return query(mid, r, d, u) == 0;
                }
            };
            int x1 = leftIBS.binarySearch(l, r);
            if (query(x1, r, d, u) == 0) {
                x1--;
            }

            IntBinarySearch rightIBS = new IntBinarySearch() {

                public boolean check(int mid) {
                    return query(l, mid, d, u) >= 1;
                }
            };
            int x2 = rightIBS.binarySearch(l, r);

            return new int[]{x1, y1, x2, y2};
        }

        public int query(int l, int r, int d, int u) {
            if (l > r || d > u) {
                return 0;
            }
            out.printf(""? %d %d %d %d"", l, d, r, u).println().flush();
            return in.readInt();
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static int floorAverage(int x, int y) {
            return (x & y) + ((x ^ y) >> 1);
        }

    }

    static abstract class IntBinarySearch {
        public abstract boolean check(int mid);

        public int binarySearch(int l, int r) {
            if (l > r) {
                throw new IllegalArgumentException();
            }
            while (l < r) {
                int mid = DigitUtils.floorAverage(l, r);
                if (check(mid)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            return l;
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(String c) {
            cache.append(c);
            return this;
        }

        public FastOutput printf(String format, Object... args) {
            cache.append(String.format(format, args));
            return this;
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}

",2,1
"import java.util.*;

public class B {
	
	public static void main(String[] args) {
		Scanner qwe = new Scanner(System.in);
		
		int n = qwe.nextInt();
		
		//! x11 y11 x12 y12 x21 y21 x22 y22"" 
		
		
		
		int x11 = bins(true,1,2,n,qwe,true);
		int y11 = bins(true,1,2,n,qwe,false);
		int x12 = bins(false,0,1,n,qwe,true);
		int y12 = bins(false,0,1,n,qwe,false);
		int x21 = bins(true,0,1,n,qwe,true);
		int y21 = bins(true,0,1,n,qwe,false);
		int x22 = bins(false,1,2,n,qwe,true);
		int y22 = bins(false,1,2,n,qwe,false);
		
		int[] xsl = {x11,x21};
		int[] xsr = {x12,x22};
		int[] ysl = {y11,y21};
		int[] ysr = {y12,y22};
		
		
		int[] ans = new int[8];
		
		for(int xpl = 0; xpl < 2; xpl++){
			for(int xpr = 0; xpr < 2; xpr++)
				for(int ypl = 0; ypl < 2; ypl++){
					for(int ypr = 0; ypr < 2; ypr++){
						
						if(xsl[xpl] <= xsr[xpr] && xsl[1-xpl] <= xsr[1-xpr] && ysl[ypl] <= ysr[ypr] && ysl[1-ypl] <= ysr[1-ypr]){
							System.out.printf(""? %d %d %d %d"",xsl[xpl],ysl[ypl],xsr[xpr],ysr[ypr]);
							System.out.println();
							System.out.flush();
							int response1 = qwe.nextInt();
							
							System.out.printf(""? %d %d %d %d"",xsl[1-xpl],ysl[1-ypl],xsr[1-xpr],ysr[1-ypr]);
							System.out.println();
							System.out.flush();
							int response2 = qwe.nextInt();
							
							if(response1 == 1 && response2 == 1){
								ans = new int[]{xsl[xpl],ysl[ypl],xsr[xpr],ysr[ypr],xsl[1-xpl],ysl[1-ypl],xsr[1-xpr],ysr[1-ypr]};
							}
							
						}
						
						
					}
				
				
				
			}
		}
		
		
		System.out.printf(""! %d %d %d %d %d %d %d %d"",ans[0],ans[1],ans[2],ans[3],ans[4],ans[5],ans[6],ans[7]);
		System.out.println();
		System.out.flush();
		
		qwe.close();
	}
	
	static int bins(boolean leftbound, int small, int big, int n, Scanner qwe, boolean isx){
		
		int min = 0;
		int max = n;
		
		if(leftbound){
			min++;
			max++;
		}
		
		int y1 = 1;
		int y2 = n;
		int x1 = 1;
		int x2 = n;
		//""? x1 y1 x2 y2""
		while(min+1 < max){
			
			int med = (min+max)/2;
			if(isx){
				if(!leftbound) x2 = med;
				else x1 = med;
			}
			else{
				if(!leftbound) y2 = med;
				else y1 = med;
			}
			
			System.out.printf(""? %d %d %d %d"",x1,y1,x2,y2);
			System.out.println();
			System.out.flush();
			
			int response = qwe.nextInt();
			if(leftbound){
				if(response >= big) min = med;
				else max= med;
			}
			else{
				if(response < big){
					min = med;
				}
				else{
					max = med;
				}
			}
		}
		
		if(leftbound) max--;
		
		return max;
		
	}

}",2,1
"import java.io.*;
import java.util.*;
import java.math.*;

public class B {
	public static void main(String[] args) throws IOException {

		/**/
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		/*/
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(""src/b.in""))));
		/**/
		
		int n = sc.nextInt();
		int l1 = 1;
		int r1 = n;
		int b1 = 1;
		int t1 = n;
		int min = b1;
		int max = t1;
		while (min != max) {
			int mid = (min+max)/2;
			System.out.println(""? ""+l1+"" ""+b1+"" ""+r1+"" ""+mid);
			System.out.flush();
			if (sc.nextInt() >= 1)
				max = mid;
			else
				min = mid+1;
		}
		t1 = min;
		min = l1;
		max = r1;
		while (min != max) {
			int mid = (min+max)/2;
			System.out.println(""? ""+l1+"" ""+b1+"" ""+mid+"" ""+t1);
			System.out.flush();
			if (sc.nextInt() >= 1)
				max = mid;
			else
				min = mid+1;
		}
		r1 = min;
		min = b1;
		max = t1;
		while (min != max) {
			int mid = (min+max+1)/2;
			System.out.println(""? ""+l1+"" ""+mid+"" ""+r1+"" ""+t1);
			System.out.flush();
			if (sc.nextInt() >= 1)
				min = mid;
			else
				max = mid-1;
		}
		b1 = min;
		min = l1;
		max = r1;
		while (min != max) {
			int mid = (min+max+1)/2;
			System.out.println(""? ""+mid+"" ""+b1+"" ""+r1+"" ""+t1);
			System.out.flush();
			if (sc.nextInt() >= 1)
				min = mid;
			else
				max = mid-1;
		}
		l1 = min;
		int l2 = 1;
		int r2 = n;
		int b2 = 1;
		int t2 = n;
		min = b2;
		max = t2;
		while (min != max) {
			int mid = (min+max+1)/2;
			System.out.println(""? ""+l2+"" ""+mid+"" ""+r2+"" ""+t2);
			System.out.flush();
			if (sc.nextInt() >= 1)
				min = mid;
			else
				max = mid-1;
		}
		b2 = min;
		min = l2;
		max = r2;
		while (min != max) {
			int mid = (min+max+1)/2;
			System.out.println(""? ""+mid+"" ""+b2+"" ""+r2+"" ""+t2);
			System.out.flush();
			if (sc.nextInt() >= 1)
				min = mid;
			else
				max = mid-1;
		}
		l2 = min;
		min = b2;
		max = t2;
		while (min != max) {
			int mid = (min+max)/2;
			System.out.println(""? ""+l2+"" ""+b2+"" ""+r2+"" ""+mid);
			System.out.flush();
			if (sc.nextInt() >= 1)
				max = mid;
			else
				min = mid+1;
		}
		t2 = min;
		min = l2;
		max = r2;
		while (min != max) {
			int mid = (min+max)/2;
			System.out.println(""? ""+l2+"" ""+b2+"" ""+mid+"" ""+t2);
			System.out.flush();
			if (sc.nextInt() >= 1)
				max = mid;
			else
				min = mid+1;
		}
		r2 = min;
		System.out.println(""! ""+l1+"" ""+b1+"" ""+r1+"" ""+t1+"" ""+l2+"" ""+b2+"" ""+r2+"" ""+t2);
		System.out.flush();
	}
}",2,1
"import java.io.*;
import java.util.Locale;
import java.util.StringTokenizer;

public class B implements Runnable {

    private static final boolean ONLINE_JUDGE = true;//System.getProperty(""ONLINE_JUDGE"") != null;

    private BufferedReader in;
    private PrintWriter out;
    private StringTokenizer tok = new StringTokenizer("""");

    private void init() throws FileNotFoundException {
        Locale.setDefault(Locale.US);
        String fileName = """";
        if (ONLINE_JUDGE && fileName.isEmpty()) {
            in = new BufferedReader(new InputStreamReader(System.in));
            out = new PrintWriter(System.out);
        } else {
            if (fileName.isEmpty()) {
                in = new BufferedReader(new FileReader(""input.txt""));
                out = new PrintWriter(""output.txt"");
            } else {
                in = new BufferedReader(new FileReader(fileName + "".in""));
                out = new PrintWriter(fileName + "".out"");
            }
        }
    }

    String readString() {
        while (!tok.hasMoreTokens()) {
            try {
                tok = new StringTokenizer(in.readLine());
            } catch (Exception e) {
                return null;
            }
        }
        return tok.nextToken();
    }

    int readInt() {
        return Integer.parseInt(readString());
    }

    long readLong() {
        return Long.parseLong(readString());
    }

    double readDouble() {
        return Double.parseDouble(readString());
    }

    int[] readIntArray(int size) {
        int[] a = new int[size];
        for (int i = 0; i < size; i++) {
            a[i] = readInt();
        }
        return a;
    }

    public static void main(String[] args) {
        //new Thread(null, new _Solution(), """", 128 * (1L << 20)).start();
        new B().run();
    }

    long timeBegin, timeEnd;

    void time() {
        timeEnd = System.currentTimeMillis();
        System.err.println(""Time = "" + (timeEnd - timeBegin));
    }

    @Override
    public void run() {
        try {
            timeBegin = System.currentTimeMillis();
            init();
            int n = readInt();
            int[] rect1 = solve1(n);
            int[] rect2 = solve2(n, rect1);

            out.printf(""! %s %s %s %s %s %s %s %s\n"", rect1[0], rect1[1], rect1[2], rect1[3],
                    rect2[0], rect2[1], rect2[2], rect2[3]);
            out.flush();
            out.close();
            time();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(-1);
        }
    }

    int ask(int x1, int y1, int x2, int y2) {
        out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);
        out.flush();
        return readInt();
    }

    int ask(int x1, int y1, int x2, int y2, int[] rect) {
        out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);
        out.flush();
        int res = readInt();
        if (rect[0] >= x1 && rect[2] <= x2 && rect[1] >= y1 && rect[3] <= y2) {
            res--;
        }
        return res;
    }

    int[] dropTopAndLeft1(int x2, int y2) {
        int x1 = x2, y1 = y2;
        int left = 1, right = x2;
        while (left <= right) {
            int mid = (left + right) >> 1;
            int count = ask(mid, 1, x2, y2);
            if (count >= 1) {
                x1 = mid;
                left = mid + 1;
            }
            if (count == 0) {
                right = mid - 1;
            }
        }
        left = 1;
        right = y2;
        while (left <= right) {
            int mid = (left + right) >> 1;
            int count = ask(x1, mid, x2, y2);
            if (count >= 1) {
                y1 = mid;
                left = mid + 1;
            }
            if (count == 0) {
                right = mid - 1;
            }
        }
        return new int[]{x1, y1, x2, y2};
    }

    private int[] solve1(int n) {

        int x = -1;
        int left = 1, right = n;
        while (left <= right) {
            int mid = (left + right) >> 1;
            int count = ask(1, 1, mid, n);
            if (count >= 1) {
                x = mid;
                right = mid - 1;
            }
            if (count == 0) {
                left = mid + 1;
            }
        }

        left = 1;
        right = n;
        int y = -1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            int count = ask(1, 1, x, mid);
            if (count >= 1) {
                y = mid;
                right = mid - 1;
            }
            if (count == 0) {
                left = mid + 1;
            }
        }

        return dropTopAndLeft1(x, y);
    }

    private int[] solve2(int n, int[] rect) {

        int x = -1;
        int left = 1, right = n;
        while (left <= right) {
            int mid = (left + right) >> 1;
            int count = ask(mid, 1, n, n, rect);
            if (count >= 1) {
                x = mid;
                left = mid + 1;
            }
            if (count == 0) {
                right = mid - 1;
            }
        }

        left = 1;
        right = n;
        int y = -1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            int count = ask(x, mid, n, n, rect);
            if (count >= 1) {
                y = mid;
                left = mid + 1;
            }
            if (count == 0) {
                right = mid - 1;
            }
        }

        return dropTopAndLeft2(x, y, n, rect);
    }

    int[] dropTopAndLeft2(int x1, int y1, int n, int[] rect) {
        int x2 = x1, y2 = y1;
        int left = x1, right = n;
        while (left <= right) {
            int mid = (left + right) >> 1;
            int count = ask(x1, y1, mid, n, rect);
            if (count >= 1) {
                x2 = mid;
                right = mid - 1;
            }
            if (count == 0) {
                left = mid + 1;
            }
        }
        left = y1;
        right = n;
        while (left <= right) {
            int mid = (left + right) >> 1;
            int count = ask(x1, y1, x2, mid, rect);
            if (count == 1) {
                y2 = mid;
                right = mid - 1;
            }
            if (count == 0) {
                left = mid + 1;
            }
        }
        return new int[]{x1, y1, x2, y2};
    }
}
",2,3
"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;


public class B {

	static StringTokenizer st;
	static BufferedReader br;
	static PrintWriter pw;
	public static void main(String[] args) throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
		int n = nextInt();
		int left = 0, right = n;
		int x1 = 0, y1 = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0, x4 = 0, y4 = 0;
		while (right-left > 1) {
			int mid = (left+right) >> 1;
			System.out.println(""? ""+1+"" ""+1+"" ""+mid+"" ""+n);
			int ans = nextInt();
			if (ans==2)
				right = mid;
			else
				left = mid;
		}
		x4 = right;
		left = 0;
		right = n;
		while (right-left > 1) {
			int mid = (left+right) >> 1;
			System.out.println(""? ""+1+"" ""+1+"" ""+mid+"" ""+n);
			int ans = nextInt();
			if (ans >= 1)
				right = mid;
			else
				left = mid;
		}
		x2 = right;
		left = 1;
		right = n+1;
		while (right-left > 1) {
			int mid = (left+right) >> 1;
			System.out.println(""? ""+mid+"" ""+1+"" ""+n+"" ""+n);
			int ans = nextInt();
			if (ans >= 1)
				left = mid;
			else
				right = mid;
		}
		x3 = left;
		left = 1;
		right = n+1;
		while (right-left > 1) {
			int mid = (left+right) >> 1;
			System.out.println(""? ""+mid+"" ""+1+"" ""+n+"" ""+n);
			int ans = nextInt();
			if (ans >= 2)
				left = mid;
			else
				right = mid;
		}
		x1 = left;
		
		left = 0;
		right = n;
		while (right-left > 1) {
			int mid = (left+right) >> 1;
			System.out.println(""? ""+1+"" ""+1+"" ""+n+"" ""+mid);
			int ans = nextInt();
			if (ans>=2)
				right = mid;
			else
				left = mid;
		}
		y4 = right;
		left = 0;
		right = n;
		while (right-left > 1) {
			int mid = (left+right) >> 1;
			System.out.println(""? ""+1+"" ""+1+"" ""+n+"" ""+mid);
			int ans = nextInt();
			if (ans >= 1)
				right = mid;
			else
				left = mid;
		}
		y2 = right;
		left = 1;
		right = n+1;
		while (right-left > 1) {
			int mid = (left+right) >> 1;
			System.out.println(""? ""+1+"" ""+mid+"" ""+n+"" ""+n);
			int ans = nextInt();
			if (ans >= 1)
				left = mid;
			else
				right = mid;
		}
		y3 = left;
		left = 1;
		right = n+1;
		while (right-left > 1) {
			int mid = (left+right) >> 1;
			System.out.println(""? ""+1+"" ""+mid+"" ""+n+"" ""+n);
			int ans = nextInt();
			if (ans >= 2)
				left = mid;
			else
				right = mid;
		}
		y1 = left;
		if (y3 <= y2 && x3 <= x2) {
			System.out.println(""! ""+x3+"" ""+y3+"" ""+x2+"" ""+y2+"" ""+x1+"" ""+y1+"" ""+x4+"" ""+y4);
			return;
		}

		System.out.println(""? ""+x1+"" ""+y1+"" ""+x2+"" ""+y2);
		int ans1 = nextInt();
		System.out.println(""? ""+x3+"" ""+y3+"" ""+x4+"" ""+y4);
		int ans2 = nextInt();
		if (ans1==1 && ans2==1) {
			System.out.println(""! ""+x1+"" ""+y1+"" ""+x2+"" ""+y2+"" ""+x3+"" ""+y3+"" ""+x4+"" ""+y4);
			return;
		}
		
		System.out.println(""? ""+x1+"" ""+y3+"" ""+x2+"" ""+y4);
		ans1 = nextInt();
		System.out.println(""? ""+x3+"" ""+y1+"" ""+x4+"" ""+y2);
		ans2 = nextInt();
		if (ans1==1 && ans2==1) {
			System.out.println(""! ""+x1+"" ""+y3+"" ""+x2+"" ""+y4+"" ""+x3+"" ""+y1+"" ""+x4+"" ""+y2);
			return;
		}
		
		System.out.println(""? ""+x1+"" ""+y1+"" ""+x4+"" ""+y2);
		ans1 = nextInt();
		System.out.println(""? ""+x3+"" ""+y3+"" ""+x2+"" ""+y4);
		ans2 = nextInt();
		if (ans1==1 && ans2==1) {
			System.out.println(""! ""+x1+"" ""+y1+"" ""+x4+"" ""+y2+"" ""+x3+"" ""+y3+"" ""+x2+"" ""+y4);
			return;
		}
		
		System.out.println(""? ""+x1+"" ""+y3+"" ""+x2+"" ""+y2);
		ans1 = nextInt();
		System.out.println(""? ""+x3+"" ""+y1+"" ""+x4+"" ""+y4);
		ans2 = nextInt();
		if (ans1==1 && ans2==1) {
			System.out.println(""! ""+x1+"" ""+y3+"" ""+x2+"" ""+y2+"" ""+x3+"" ""+y1+"" ""+x4+"" ""+y4);
			return;
		}
		
		
		pw.close();
	}
	private static int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
	private static long nextLong() throws IOException {
		return Long.parseLong(next());
	}
	private static double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}
	private static String next() throws IOException {
		while (st==null || !st.hasMoreTokens())
			st = new StringTokenizer(br.readLine());
		return st.nextToken();
	}
}",2,1
"import java.awt.*;
import java.io.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;
import java.util.List;

import static java.lang.Math.max;
import static java.lang.Math.min;


public class B implements Runnable{

    private final static Random rnd = new Random();

    // SOLUTION!!!
    // HACK ME PLEASE IF YOU CAN!!!
    // PLEASE!!!
    // PLEASE!!!
    // PLEASE!!!

    int n;

    private void solve() {
        this.query = 0;

        this.n = readInt();

        int left1 = 0;

        int l = 1, r = n;
        while (l <= r) {
            int m = (l + r) / 2;
            int answer = getAnswer(m, 1, n, n);

            if (answer < 2) {
                r = m - 1;
            } else {
                left1 = m;
                l = m + 1;
            }
        }

        int left2 = left1;

        l = left1 + 1;
        r = n;
        while (l <= r) {
            int m = (l + r) / 2;
            int answer = getAnswer(m, 1, n, n);

            if (answer < 1) {
                r = m - 1;
            } else {
                left2 = m;
                l = m + 1;
            }
        }

        int right2 = n + 1;

        l = 1;
        r = n;
        while (l <= r) {
            int m = (l + r) / 2;
            int answer = getAnswer(1, 1, m, n);

            if (answer < 2) {
                l = m + 1;
            } else {
                right2 = m;
                r = m - 1;
            }
        }

        int right1 = right2;

        l = 1;
        r = right2 - 1;
        while (l <= r) {
            int m = (l + r) / 2;
            int answer = getAnswer(1, 1, m, n);

            if (answer < 1) {
                l = m + 1;
            } else {
                right1 = m;
                r = m - 1;
            }
        }

        int bottom1 = 0;

        l = 1;
        r = n;
        while (l <= r) {
            int m = (l + r) / 2;
            int answer = getAnswer(1, m, n, n);

            if (answer < 2) {
                r = m - 1;
            } else {
                bottom1 = m;
                l = m + 1;
            }
        }

        int bottom2 = bottom1;

        l = bottom1 + 1;
        r = n;
        while (l <= r) {
            int m = (l + r) / 2;
            int answer = getAnswer(1, m, n, n);

            if (answer < 1) {
                r = m - 1;
            } else {
                bottom2 = m;
                l = m + 1;
            }
        }

        int top2 = n + 1;

        l = 1;
        r = n;
        while (l <= r) {
            int m = (l + r) / 2;
            int answer = getAnswer(1, 1, n, m);

            if (answer < 2) {
                l = m + 1;
            } else {
                top2 = m;
                r = m - 1;
            }
        }

        int top1 = top2;

        l = 1;
        r = top2 - 1;
        while (l <= r) {
            int m = (l + r) / 2;
            int answer = getAnswer(1, 1, n, m);

            if (answer < 1) {
                l = m + 1;
            } else {
                top1 = m;
                r = m - 1;
            }
        }

        int ansLeftRightMask = -1, ansBottomTopMask = -1;
        long answerS = 2L * n * n;

        for (int leftRightMask = 0; leftRightMask < 4; ++leftRightMask) {
            int left = (checkBit(leftRightMask, 0) ? left1 : left2);
            int right = (checkBit(leftRightMask, 1) ? right1 : right2);

            for (int bottomTopMask = 0; bottomTopMask < 4; ++bottomTopMask) {
                int bottom = (checkBit(bottomTopMask, 0) ? bottom1 : bottom2);
                int top = (checkBit(bottomTopMask, 1) ? top1 : top2);

                int curTry = getAnswer(left, bottom, right, top);
                if (curTry == 1) {
                    long s = (right - left + 1L) * (top - bottom + 1L);
                    if (s < answerS) {
                        answerS = s;
                        ansLeftRightMask = leftRightMask;
                        ansBottomTopMask = bottomTopMask;
                    }
                }
            }
        }

        int left = (checkBit(ansLeftRightMask, 0) ? left1 : left2);
        int right = (checkBit(ansLeftRightMask, 1) ? right1 : right2);
        int bottom = (checkBit(ansBottomTopMask, 0) ? bottom1 : bottom2);
        int top = (checkBit(ansBottomTopMask, 1) ? top1 : top2);

        printAnswer(left, bottom, right, top,
                left1 + left2 - left, bottom1 + bottom2 - bottom,
                right1 + right2 - right, top1 + top2 - top);
    }

    private void printAnswer(int... values) {
        printQuery(""!"", values);
    }

    private void printQuery(String sign, int... values) {
        out.print(sign);
        for (int value : values) {
            out.print("" "" + value);
        }
        out.println();
        out.flush();
    }

    int query = 0;
    final int MAX_QUERY = 200;

    private int getAnswer(int left, int bottom, int right, int top) {
        if (left < 1 || right > n) {
            while (true);
        }

        if (bottom < 1 || top > n) {
            throw new RuntimeException();
        }

        if (left > right || bottom > top) {
            return 0;
        }

        if (query == MAX_QUERY) {
            throw new RuntimeException();
        }

        ++query;

        printQuery(""?"",  left, bottom, right, top);

        int answer = readInt();
        return answer;
    }

    /////////////////////////////////////////////////////////////////////

    private final static boolean FIRST_INPUT_STRING = false;
    private final static boolean MULTIPLE_TESTS = true;
    private final static boolean INTERACTIVE = true;
    private final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;

    private final static int MAX_STACK_SIZE = 128;

    private final static boolean OPTIMIZE_READ_NUMBERS = false;

    /////////////////////////////////////////////////////////////////////

    public void run(){
        try{
            timeInit();
            Locale.setDefault(Locale.US);

            init();

            if (ONLINE_JUDGE) {
                solve();
            } else {
                do {
                    try {
                        timeInit();
                        solve();
                        time();

                        out.println();
                    } catch (NumberFormatException e) {
                        break;
                    } catch (NullPointerException e) {
                        if (FIRST_INPUT_STRING) break;
                        else throw e;
                    }
                } while (MULTIPLE_TESTS);
            }

            out.close();
            time();
        }catch (Exception e){
            e.printStackTrace(System.err);
            System.exit(-1);
        }
    }

    /////////////////////////////////////////////////////////////////////

    private BufferedReader in;
    private OutputWriter out;
    private StringTokenizer tok = new StringTokenizer("""");

    public static void main(String[] args){
        new Thread(null, new B(), """", MAX_STACK_SIZE * (1L << 20)).start();
    }

    /////////////////////////////////////////////////////////////////////

    private void init() throws FileNotFoundException{
        Locale.setDefault(Locale.US);

        if (INTERACTIVE || ONLINE_JUDGE){
            in = new BufferedReader(new InputStreamReader(System.in));
            out = new OutputWriter(System.out);
        }else{
            in = new BufferedReader(new FileReader(""input.txt""));
            out = new OutputWriter(""output.txt"");
        }
    }

    ////////////////////////////////////////////////////////////////

    private long timeBegin;

    private void timeInit() {
        this.timeBegin = System.currentTimeMillis();
    }

    private void time(){
        long timeEnd = System.currentTimeMillis();
        System.err.println(""Time = "" + (timeEnd - timeBegin));
    }

    private void debug(Object... objects){
        if (ONLINE_JUDGE){
            for (Object o: objects){
                System.err.println(o.toString());
            }
        }
    }

    /////////////////////////////////////////////////////////////////////

    private String delim = "" "";

    private String readLine() {
        try {
            return in.readLine();
        } catch (IOException e) {
            throw new RuntimeIOException(e);
        }
    }

    private String readString() {
        try {
            while(!tok.hasMoreTokens()){
                tok = new StringTokenizer(readLine());
            }

            return tok.nextToken(delim);
        } catch (NullPointerException e) {
            return null;
        }
    }

    /////////////////////////////////////////////////////////////////

    private final char NOT_A_SYMBOL = '\0';

    private char readChar() {
        try {
            int intValue = in.read();

            if (intValue == -1){
                return NOT_A_SYMBOL;
            }

            return (char) intValue;
        } catch (IOException e) {
            throw new RuntimeIOException(e);
        }
    }

    private char[] readCharArray() {
        return readLine().toCharArray();
    }

    private char[][] readCharField(int rowsCount) {
        char[][] field = new char[rowsCount][];
        for (int row = 0; row < rowsCount; ++row) {
            field[row] = readCharArray();
        }

        return field;
    }

    /////////////////////////////////////////////////////////////////

    private long optimizedReadLong() {
        long result = 0;
        boolean started = false;
        while (true) {
            try {
                int j = in.read();
                if (-1 == j) {
                    if (started) return result;
                    throw new NumberFormatException();
                }

                if ('0' <= j && j <= '9') {
                    result = result * 10 + j - '0';
                    started = true;
                } else if (started) {
                    return result;
                }
            } catch (IOException e) {
                throw new RuntimeIOException(e);
            }
        }
    }

    private int readInt() {

        if (!OPTIMIZE_READ_NUMBERS) {
            return Integer.parseInt(readString());
        } else {
            return (int) optimizedReadLong();
        }
    }

    private int[] readIntArray(int size) {
        int[] array = new int[size];

        for (int index = 0; index < size; ++index){
            array[index] = readInt();
        }

        return array;
    }

    private int[] readSortedIntArray(int size) {
        Integer[] array = new Integer[size];

        for (int index = 0; index < size; ++index) {
            array[index] = readInt();
        }
        Arrays.sort(array);

        int[] sortedArray = new int[size];
        for (int index = 0; index < size; ++index) {
            sortedArray[index] = array[index];
        }

        return sortedArray;
    }

    private int[] readIntArrayWithDecrease(int size) {
        int[] array = readIntArray(size);

        for (int i = 0; i < size; ++i) {
            array[i]--;
        }

        return array;
    }

    ///////////////////////////////////////////////////////////////////

    private int[][] readIntMatrix(int rowsCount, int columnsCount) {
        int[][] matrix = new int[rowsCount][];

        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {
            matrix[rowIndex] = readIntArray(columnsCount);
        }

        return matrix;
    }

    private int[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) {
        int[][] matrix = new int[rowsCount][];

        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {
            matrix[rowIndex] = readIntArrayWithDecrease(columnsCount);
        }

        return matrix;
    }

    ///////////////////////////////////////////////////////////////////

    private long readLong() {
        if (!OPTIMIZE_READ_NUMBERS) {
            return Long.parseLong(readString());
        } else {
            return optimizedReadLong();
        }
    }

    private long[] readLongArray(int size) {
        long[] array = new long[size];

        for (int index = 0; index < size; ++index){
            array[index] = readLong();
        }

        return array;
    }

    ////////////////////////////////////////////////////////////////////

    private double readDouble() {
        return Double.parseDouble(readString());
    }

    private double[] readDoubleArray(int size) {
        double[] array = new double[size];

        for (int index = 0; index < size; ++index){
            array[index] = readDouble();
        }

        return array;
    }

    ////////////////////////////////////////////////////////////////////

    private BigInteger readBigInteger() {
        return new BigInteger(readString());
    }

    private BigDecimal readBigDecimal() {
        return new BigDecimal(readString());
    }

    /////////////////////////////////////////////////////////////////////

    private Point readPoint() {
        int x = readInt();
        int y = readInt();
        return new Point(x, y);
    }

    private Point[] readPointArray(int size) {
        Point[] array = new Point[size];

        for (int index = 0; index < size; ++index){
            array[index] = readPoint();
        }

        return array;
    }

    /////////////////////////////////////////////////////////////////////

    private List<Integer>[] readGraph(int vertexNumber, int edgeNumber) {
        @SuppressWarnings(""unchecked"")
        List<Integer>[] graph = new List[vertexNumber];

        for (int index = 0; index < vertexNumber; ++index){
            graph[index] = new ArrayList<Integer>();
        }

        while (edgeNumber-- > 0){
            int from = readInt() - 1;
            int to = readInt() - 1;

            graph[from].add(to);
            graph[to].add(from);
        }

        return graph;
    }

    /////////////////////////////////////////////////////////////////////

    private static class IntIndexPair {

        static Comparator<IntIndexPair> increaseComparator = new Comparator<B.IntIndexPair>() {

            @Override
            public int compare(B.IntIndexPair indexPair1, B.IntIndexPair indexPair2) {
                int value1 = indexPair1.value;
                int value2 = indexPair2.value;

                if (value1 != value2) return value1 - value2;

                int index1 = indexPair1.index;
                int index2 = indexPair2.index;

                return index1 - index2;
            }
        };

        static Comparator<IntIndexPair> decreaseComparator = new Comparator<B.IntIndexPair>() {

            @Override
            public int compare(B.IntIndexPair indexPair1, B.IntIndexPair indexPair2) {
                int value1 = indexPair1.value;
                int value2 = indexPair2.value;

                if (value1 != value2) return -(value1 - value2);

                int index1 = indexPair1.index;
                int index2 = indexPair2.index;

                return index1 - index2;
            }
        };

        int value, index;

        IntIndexPair(int value, int index) {
            super();
            this.value = value;
            this.index = index;
        }

        int getRealIndex() {
            return index + 1;
        }
    }

    private IntIndexPair[] readIntIndexArray(int size) {
        IntIndexPair[] array = new IntIndexPair[size];

        for (int index = 0; index < size; ++index) {
            array[index] = new IntIndexPair(readInt(), index);
        }

        return array;
    }

    /////////////////////////////////////////////////////////////////////

    private static class OutputWriter extends PrintWriter {

        final int DEFAULT_PRECISION = 12;

        private int precision;
        private String format, formatWithSpace;

        {
            precision = DEFAULT_PRECISION;

            format = createFormat(precision);
            formatWithSpace = format + "" "";
        }

        OutputWriter(OutputStream out) {
            super(out);
        }

        OutputWriter(String fileName) throws FileNotFoundException {
            super(fileName);
        }

        int getPrecision() {
            return precision;
        }

        void setPrecision(int precision) {
            precision = max(0, precision);
            this.precision = precision;

            format = createFormat(precision);
            formatWithSpace = format + "" "";
        }

        String createFormat(int precision){
            return ""%."" + precision + ""f"";
        }

        @Override
        public void print(double d){
            printf(format, d);
        }

        void printWithSpace(double d){
            printf(formatWithSpace, d);
        }

        void printAll(double...d){
            for (int i = 0; i < d.length - 1; ++i){
                printWithSpace(d[i]);
            }

            print(d[d.length - 1]);
        }

        @Override
        public void println(double d){
            printlnAll(d);
        }

        void printlnAll(double... d){
            printAll(d);
            println();
        }
    }

    /////////////////////////////////////////////////////////////////////

    private static class RuntimeIOException extends RuntimeException {

        /**
         *
         */
        private static final long serialVersionUID = -6463830523020118289L;

        RuntimeIOException(Throwable cause) {
            super(cause);
        }
    }

    /////////////////////////////////////////////////////////////////////
    //////////////// Some useful constants and functions ////////////////
    /////////////////////////////////////////////////////////////////////

    private static final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    private static final int[][] steps8 = {
            {-1, 0}, {1, 0}, {0, -1}, {0, 1},
            {-1, -1}, {1, 1}, {1, -1}, {-1, 1}
    };

    private static boolean checkCell(int row, int rowsCount, int column, int columnsCount) {
        return checkIndex(row, rowsCount) && checkIndex(column, columnsCount);
    }

    private static boolean checkIndex(int index, int lim){
        return (0 <= index && index < lim);
    }

    /////////////////////////////////////////////////////////////////////

    private static boolean checkBit(int mask, int bit){
        return (mask & (1 << bit)) != 0;
    }
    private static boolean checkBit(long mask, int bit){
        return (mask & (1L << bit)) != 0;
    }

    /////////////////////////////////////////////////////////////////////

    private static long getSum(int[] array) {
        long sum = 0;
        for (int value: array) {
            sum += value;
        }

        return sum;
    }

    private static Point getMinMax(int[] array) {
        int min = array[0];
        int max = array[0];

        for (int index = 0, size = array.length; index < size; ++index, ++index) {
            int value = array[index];

            if (index == size - 1) {
                min = min(min, value);
                max = max(max, value);
            } else {
                int otherValue = array[index + 1];

                if (value <= otherValue) {
                    min = min(min, value);
                    max = max(max, otherValue);
                } else {
                    min = min(min, otherValue);
                    max = max(max, value);
                }
            }
        }

        return new Point(min, max);
    }

    /////////////////////////////////////////////////////////////////////

    private static int[] getPrimes(int n) {
        boolean[] used = new boolean[n];
        used[0] = used[1] = true;

        int size = 0;
        for (int i = 2; i < n; ++i) {
            if (!used[i]) {
                ++size;
                for (int j = 2 * i; j < n; j += i) {
                    used[j] = true;
                }
            }
        }

        int[] primes = new int[size];
        for (int i = 0, cur = 0; i < n; ++i) {
            if (!used[i]) {
                primes[cur++] = i;
            }
        }

        return primes;
    }

    /////////////////////////////////////////////////////////////////////

    private static long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }

    private static long gcd(long a, long b) {
        return (a == 0 ? b : gcd(b % a, a));
    }

    /////////////////////////////////////////////////////////////////////

    private static class IdMap<KeyType> extends HashMap<KeyType, Integer> {

        /**
         *
         */
        private static final long serialVersionUID = -3793737771950984481L;

        public IdMap() {
            super();
        }

        int getId(KeyType key) {
            Integer id = super.get(key);
            if (id == null) {
                super.put(key, id = size());
            }

            return id;
        }
    }
}

",2,3
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Hieu Le
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        private int n;
        private InputReader in;
        private PrintWriter out;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            n = in.nextInt();
            this.in = in;
            this.out = out;
            query(new Point(1, 1), new Point(n, n), new Rectangle());
        }

        private boolean query(Point bottomLeft, Point topRight, Rectangle rectangle) {
            if (bottomLeft.r > topRight.r || bottomLeft.c > topRight.c)
                return false;

            // Find the column of the right edge.
            int low = bottomLeft.c, high = topRight.c;
            while (low < high) {
                int mid = low + (high - low) / 2;
                int answer = ask(bottomLeft.r, bottomLeft.c, topRight.r, mid);
                if (answer > 0)
                    high = mid;
                else
                    low = mid + 1;
            }
            int rightCol = low;

            // Find the column of the left edge.
            low = bottomLeft.c;
            high = topRight.c;
            while (low < high) {
                int mid = low + (high - low + 1) / 2;
                int answer = ask(bottomLeft.r, mid, topRight.r, topRight.c);
                if (answer > 0)
                    low = mid;
                else
                    high = mid - 1;
            }
            int leftCol = low;

            // Find the topmost row.
            low = bottomLeft.r;
            high = topRight.r;
            while (low < high) {
                int mid = low + (high - low) / 2;
                int answer = ask(bottomLeft.r, bottomLeft.c, mid, topRight.c);
                if (answer > 0)
                    high = mid;
                else
                    low = mid + 1;
            }
            int topRow = low;

            // Find the bottommost row.
            low = bottomLeft.r;
            high = topRight.r;
            while (low < high) {
                int mid = low + (high - low + 1) / 2;
                int answer = ask(mid, bottomLeft.c, topRight.r, topRight.c);
                if (answer > 0)
                    low = mid;
                else
                    high = mid - 1;
            }
            int bottomRow = low;

            if (leftCol > rightCol) {
                Rectangle first = new Rectangle();
                query(new Point(1, leftCol), new Point(n, n), first);
                Rectangle second = new Rectangle();
                query(new Point(1, 1), new Point(n, rightCol), second);
                out.printf(""! %d %d %d %d %d %d %d %d\n"",
                        first.bottomLeft.r, first.bottomLeft.c, first.topRight.r, first.topRight.c,
                        second.bottomLeft.r, second.bottomLeft.c, second.topRight.r, second.topRight.c);
                return true;
            }

            if (bottomRow > topRow) {
                Rectangle first = new Rectangle();
                query(new Point(bottomRow, 1), new Point(n, n), first);
                Rectangle second = new Rectangle();
                query(new Point(1, 1), new Point(topRow, n), second);
                out.printf(""! %d %d %d %d %d %d %d %d\n"",
                        first.bottomLeft.r, first.bottomLeft.c, first.topRight.r, first.topRight.c,
                        second.bottomLeft.r, second.bottomLeft.c, second.topRight.r, second.topRight.c);
                return true;
            }

            rectangle.bottomLeft.r = bottomRow;
            rectangle.bottomLeft.c = leftCol;
            rectangle.topRight.r = topRow;
            rectangle.topRight.c = rightCol;
            return true;
        }

        private int ask(int r1, int c1, int r2, int c2) {
            out.printf(""? %d %d %d %d\n"", r1, c1, r2, c2);
            out.flush();
            return in.nextInt();
        }

        private class Point {
            private int r;
            private int c;

            public Point(int r, int c) {
                this.r = r;
                this.c = c;
            }

        }

        private class Rectangle {
            private Point bottomLeft;
            private Point topRight;

            public Rectangle() {
                bottomLeft = new Point(-1, -1);
                topRight = new Point(-1, -1);
            }

        }

    }

    static class InputReader {
        private BufferedReader reader;
        private StringTokenizer tokenizer;
        private static final int BUFFER_SIZE = 32768;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), BUFFER_SIZE);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",2,1
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Egor Kulikov (egor@egork.net)
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        int stage;
        int n;
        OutputWriter out;
        InputReader in;

        void query(int end) {
            switch (stage) {
            case 0:
                out.printLine('?', 1, 1, end, n);
                break;
            case 1:
                out.printLine('?', 1, 1, n, end);
                break;
            case 2:
                out.printLine('?', n + 1 - end, 1, n, n);
                break;
            case 3:
                out.printLine('?', 1, n + 1 - end, n, n);
                break;
            }
            out.flush();
        }

        public void solve(int testNumber, InputReader in, OutputWriter out) {
            this.out = out = new OutputWriter(System.out);
            this.in = in = new InputReader(System.in);
            n = in.readInt();
            int[] endx = new int[2];
            int[] endy = new int[2];
            int[] stx = new int[2];
            int[] sty = new int[2];
            find(endx);
            stage++;
            find(endy);
            stage++;
            find(stx);
            for (int i = 0; i < 2; i++) {
                stx[i] = n + 1 - stx[i];
            }
            stage++;
            find(sty);
            for (int i = 0; i < 2; i++) {
                sty[i] = n + 1 - sty[i];
            }
            for (int i = 0; i < 8; i++) {
                if (stx[i & 1] > endx[i >> 2 & 1] || sty[i >> 1 & 1] > endy[0]) {
                    continue;
                }
                if (stx[1 - (i & 1)] > endx[1 - (i >> 2 & 1)] || sty[1 - (i >> 1 & 1)] > endy[1]) {
                    continue;
                }
                out.printLine('?', stx[i & 1], sty[i >> 1 & 1], endx[i >> 2 & 1], endy[0]);
                out.flush();
                if (in.readInt() == 0) {
                    continue;
                }
                out.printLine('?', stx[1 - (i & 1)], sty[1 - (i >> 1 & 1)], endx[1 - (i >> 2 & 1)], endy[1]);
                out.flush();
                if (in.readInt() != 0) {
                    out.printLine(""!"", stx[i & 1], sty[i >> 1 & 1], endx[i >> 2 & 1], endy[0], stx[1 - (i & 1)],
                            sty[1 - (i >> 1 & 1)], endx[1 - (i >> 2 & 1)], endy[1]);
                    out.flush();
                    return;
                }
            }
        }

        private void find(int[] endx) {
            int left = 1;
            int right = n;
            while (left < right) {
                int middle = (left + right) >> 1;
                query(middle);
                if (in.readInt() == 2) {
                    right = middle;
                } else {
                    left = middle + 1;
                }
            }
            endx[0] = left;
            left = 0;
            right--;
            while (left < right) {
                int middle = (left + right + 1) >> 1;
                query(middle);
                if (in.readInt() == 0) {
                    left = middle;
                } else {
                    right = middle - 1;
                }
            }
            endx[1] = left + 1;
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
        }

        public void printLine(Object... objects) {
            print(objects);
            writer.println();
        }

        public void close() {
            writer.close();
        }

        public void flush() {
            writer.flush();
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",2,3
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.HashMap;
import java.io.IOException;
import java.util.ArrayList;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author ilyakor
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        ArrayList<PointInt[]> al;
        TaskB.Interactor interactor;

        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.nextInt();
            //for (int itt = 0; itt < 100; ++itt) {
            interactor = new TaskB.IOInteractor(new Scanner(in.getStream()), out.getWriter());//new TestInteractor(n);
            Assert.assertTrue(interactor.query(1, 1, n, n) == 2);
            int lx = 1, rx = n, ly = 1, ry = n;
            for (int it = 0; it < 20; ++it) {
                int tx = (lx + rx) / 2;
                if (interactor.query(1, 1, tx, n) >= 1)
                    rx = tx;
                else
                    lx = tx;
                int ty = (ly + ry) / 2;
                if (interactor.query(1, 1, n, ty) >= 1)
                    ry = ty;
                else
                    ly = ty;
            }
            al = new ArrayList<>();
            if (interactor.query(1, 1, lx, n) == 1 && interactor.query(lx + 1, 1, n, n) == 1) {
                dfs(1, 1, lx, n);
                dfs(lx + 1, 1, n, n);
            } else if (interactor.query(1, 1, rx, n) == 1 && interactor.query(rx + 1, 1, n, n) == 1) {
                dfs(1, 1, rx, n);
                dfs(rx + 1, 1, n, n);
            } else if (interactor.query(1, 1, n, ly) == 1 && interactor.query(1, ly + 1, n, n) == 1) {
                dfs(1, 1, n, ly);
                dfs(1, ly + 1, n, n);
            } else if (interactor.query(1, 1, n, ry) == 1 && interactor.query(1, ry + 1, n, n) == 1) {
                dfs(1, 1, n, ry);
                dfs(1, ry + 1, n, n);
            } else {
                throw new RuntimeException(""WTF"");
            }
            Assert.assertTrue(al.size() == 2);
            interactor.answer(al.get(0)[0].x, al.get(0)[0].y, al.get(0)[1].x, al.get(0)[1].y, al.get(1)[0].x, al.get(1)[0].y, al.get(1)[1].x, al.get(1)[1].y);
            //}
        }

        private void dfs(int x1, int y1, int x2, int y2) {
            int t;
            t = x1;
            for (int i = 0; i < 20; ++i) {
                int x = (t + x2) / 2;
                if (interactor.query(x1, y1, x, y2) == 1)
                    x2 = x;
                else
                    t = x;
            }
            if (interactor.query(x1, y1, t, y2) == 1)
                x2 = t;
            t = x2;
            for (int i = 0; i < 20; ++i) {
                int x = (t + x1) / 2;
                if (interactor.query(x, y1, x2, y2) == 1)
                    x1 = x;
                else
                    t = x;
            }
            if (interactor.query(t, y1, x2, y2) == 1)
                x1 = t;
            t = y1;
            for (int i = 0; i < 20; ++i) {
                int y = (t + y2) / 2;
                if (interactor.query(x1, y1, x2, y) == 1)
                    y2 = y;
                else
                    t = y;
            }
            if (interactor.query(x1, y1, x2, t) == 1)
                y2 = t;
            t = y2;
            for (int i = 0; i < 20; ++i) {
                int y = (t + y1) / 2;
                if (interactor.query(x1, y, x2, y2) == 1)
                    y1 = y;
                else
                    t = y;
            }
            if (interactor.query(x1, t, x2, y2) == 1)
                y1 = t;

            al.add(new PointInt[]{new PointInt(x1, y1), new PointInt(x2, y2)});
        }

        interface Interactor {
            int query(int x1, int y1, int x2, int y2);

            void answer(int x11, int y11, int x12, int y12,
                        int x21, int y21, int x22, int y22);

        }

        static class Query {
            int x1;
            int y1;
            int x2;
            int y2;

            public Query(int x1, int y1, int x2, int y2) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
            }


            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;

                TaskB.Query query = (TaskB.Query) o;

                if (x1 != query.x1) return false;
                if (y1 != query.y1) return false;
                if (x2 != query.x2) return false;
                return y2 == query.y2;

            }


            public int hashCode() {
                int result = x1;
                result = 31 * result + y1;
                result = 31 * result + x2;
                result = 31 * result + y2;
                return result;
            }

        }

        static class IOInteractor implements TaskB.Interactor {
            Scanner in;
            PrintWriter out;
            HashMap<TaskB.Query, Integer> cache;

            public IOInteractor(Scanner in, PrintWriter out) {
                this.in = in;
                this.out = out;
                cache = new HashMap<>();
            }


            public int query(int x1, int y1, int x2, int y2) {
                TaskB.Query q = new TaskB.Query(x1, y1, x2, y2);
                if (cache.containsKey(q))
                    return cache.get(q);
                if (x1 > x2 || y1 > y2)
                    return 0;
                Assert.assertTrue(x1 >= 1 && y1 >= 1);
                out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);
                out.flush();
                int res = in.nextInt();
                cache.put(q, res);
                return res;
            }


            public void answer(int x11, int y11, int x12, int y12, int x21, int y21, int x22, int y22) {
                out.println(""! "" + x11 + "" "" + y11 + "" "" + x12 + "" "" + y12 + "" "" + x21 + "" "" + y21 + "" "" + x22 + "" "" + y22);
                out.flush();
            }

        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buffer = new byte[10000];
        private int cur;
        private int count;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public static boolean isSpace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public int read() {
            if (count == -1) {
                throw new InputMismatchException();
            }
            try {
                if (cur >= count) {
                    cur = 0;
                    count = stream.read(buffer);
                    if (count <= 0)
                        return -1;
                }
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            return buffer[cur++];
        }

        public int readSkipSpace() {
            int c;
            do {
                c = read();
            } while (isSpace(c));
            return c;
        }

        public int nextInt() {
            int sgn = 1;
            int c = readSkipSpace();
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res = res * 10 + c - '0';
                c = read();
            } while (!isSpace(c));
            res *= sgn;
            return res;
        }

        public InputStream getStream() {
            return stream;
        }

    }

    static class PointInt {
        public int x;
        public int y;

        public PointInt(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public PointInt() {
            x = 0;
            y = 0;
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public PrintWriter getWriter() {
            return writer;
        }

        public void close() {
            writer.close();
        }

    }

    static class Assert {
        public static void assertTrue(boolean flag) {
//        if (!flag)
//        while (true);
            if (!flag)
                throw new AssertionError();
        }

    }
}

",2,1
"import java.io.*;
import java.util.*;

public class Template implements Runnable {

    BufferedReader in;
    PrintWriter out;
    StringTokenizer tok = new StringTokenizer("""");

    void init() throws FileNotFoundException {
        in = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(System.out);
    }

    String readString() throws IOException {
        while (!tok.hasMoreTokens()) {
            try {
                tok = new StringTokenizer(in.readLine(), "" :"");
            } catch (Exception e) {
                return null;
            }
        }
        return tok.nextToken();
    }

    int readInt() throws IOException {
        return Integer.parseInt(readString());
    }

    int[] readIntArray(int size) throws IOException {
        int[] res = new int[size];
        for (int i = 0; i < size; i++) {
            res[i] = readInt();
        }
        return res;
    }

    long readLong() throws IOException {
        return Long.parseLong(readString());
    }

    double readDouble() throws IOException {
        return Double.parseDouble(readString());
    }

    <T> List<T>[] createGraphList(int size) {
        List<T>[] list = new List[size];
        for (int i = 0; i < size; i++) {
            list[i] = new ArrayList<>();
        }
        return list;
    }

    public static void main(String[] args) {
        new Thread(null, new Template(), """", 1l * 200 * 1024 * 1024).start();
    }

    long timeBegin, timeEnd;

    void time() {
        timeEnd = System.currentTimeMillis();
        System.err.println(""Time = "" + (timeEnd - timeBegin));
    }

    long memoryTotal, memoryFree;

    void memory() {
        memoryFree = Runtime.getRuntime().freeMemory();
        System.err.println(""Memory = "" + ((memoryTotal - memoryFree) >> 10)
                + "" KB"");
    }

    public void run() {
        try {
            timeBegin = System.currentTimeMillis();
            memoryTotal = Runtime.getRuntime().freeMemory();
            init();
            solve();
            out.close();
            if (System.getProperty(""ONLINE_JUDGE"") == null) {
                time();
                memory();
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(-1);
        }
    }

    int fx = -1;
    int sx = -1;
    int fy = -1;
    int sy = -1;

    int query(int x1, int y1, int x2, int y2) throws IOException {
        out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);
        out.flush();
        int res = readInt();
        if (fx >= x1 && sx <= x2 && fy >= y1 && sy <= y2) res--;
        return res;
    }

    int[] bs(int n) throws IOException {
        int l = 1;
        int r = n;

        int lx = 0, rx = 0, ly = 0, ry = 0;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (query(1, 1, mid, n) > 0) {
                rx = mid;
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }

        l = 1;
        r = rx;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (query(mid, 1, rx, n) > 0) {
                lx = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }

        l = 1;
        r = n;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (query(lx, mid, rx, n) > 0) {
                ly = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }

        l = ly;
        r = n;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (query(lx, ly, rx, mid) > 0) {
                ry = mid;
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        fx = lx;
        sx = rx;
        fy = ly;
        sy = ry;
        return new int[] {lx, ly, rx, ry};
    }

    void solve() throws IOException {
        int n = readInt();
        int[] a = bs(n);
        int[] b = bs(n);

        out.print(""! "");
        for (int i : a) out.print(i + "" "");
        for (int i : b) out.print(i + "" "");
    }


}",2,3
"
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.SortedSet;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * #
 * @author pttrung
 */
public class B_Round_371_Div1 {

    public static long MOD = 1000000007;
    static int c = 0;

    public static void main(String[] args) throws FileNotFoundException {
        // PrintWriter out = new PrintWriter(new FileOutputStream(new File(
        // ""output.txt"")));

        Scanner in = new Scanner();
        int n = in.nextInt();
        int minX = -1;
        int start = 1;
        int end = n;
        c = 0;
        while (start <= end) {
            int mid = (start + end) >> 1;
            c = increaseC(c);
            System.out.println(""? "" + mid + "" 1 "" + n + "" "" + n);
            System.out.flush();

            int v = in.nextInt();
            if (v == 2) {
                minX = mid;
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        //System.out.println(""Minx "" + minX);
        int maxX = -1;
        start = minX;
        end = n;
        while (start <= end) {
            int mid = (start + end) >> 1;
            c = increaseC(c);
            System.out.println(""? "" + minX + "" 1 "" + mid + "" "" + n);
            System.out.flush();
            int v = in.nextInt();
            if (v == 2) {
                maxX = mid;
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        // System.out.println(""Maxx "" + maxX);
        int minY = -1;
        start = 1;
        end = n;
        while (start <= end) {
            int mid = (start + end) >> 1;
            c = increaseC(c);
            System.out.println(""? "" + minX + "" "" + mid + "" "" + maxX + "" "" + n);
            System.out.flush();

            int v = in.nextInt();
            if (v == 2) {
                minY = mid;
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        // System.out.println(""MinY "" + minY);
        int maxY = -1;
        start = minY;
        end = n;
        while (start <= end) {
            int mid = (start + end) >> 1;
            c = increaseC(c);
            System.out.println(""? "" + minX + "" "" + minY + "" "" + maxX + "" "" + mid);
            System.out.flush();

            int v = in.nextInt();
            if (v == 2) {
                maxY = mid;
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        // System.out.println(""MaxY "" + maxY);
        int middleMinX = maxX;
        start = minX;
        end = maxX;
        while (start <= end) {
            int mid = (start + end) >> 1;
            c = increaseC(c);
            System.out.println(""? "" + minX + "" "" + minY + "" "" + mid + "" "" + maxY);
            System.out.flush();

            int v = in.nextInt();
            if (v == 1) {
                middleMinX = mid;
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        //System.out.println(""MiddleMinX "" + middleMinX);
        int middleMaxX = -1;
        start = middleMinX + 1;
        end = maxX;
        while (start <= end) {
            int mid = (start + end) >> 1;
            c = increaseC(c);
            System.out.println(""? "" + mid + "" "" + minY + "" "" + maxX + "" "" + maxY);
            System.out.flush();

            int v = in.nextInt();
            if (v == 1) {
                middleMaxX = mid;
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }

        // System.out.println(""MiddleMaxX "" + middleMaxX);
        if (middleMaxX == -1) {
            int middleMinY = -1;
            start = minY;
            end = maxY;
            while (start <= end) {
                int mid = (start + end) >> 1;
                c = increaseC(c);
                System.out.println(""? "" + minX + "" "" + minY + "" "" + maxX + "" "" + mid);
                System.out.flush();

                int v = in.nextInt();
                if (v == 1) {
                    middleMinY = mid;
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }
            }
            //System.out.println(""MiddleMinY "" + middleMinY);
            int middleMaxY = -1;
            start = middleMinY + 1;
            end = maxY;
            while (start <= end) {
                int mid = (start + end) >> 1;
                c = increaseC(c);
                System.out.println(""? "" + minX + "" "" + mid + "" "" + maxX + "" "" + maxY);
                System.out.flush();

                int v = in.nextInt();
                if (v == 1) {
                    middleMaxY = mid;
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
            //System.out.println(""MiddleMaxY "" + middleMaxY);
            if (minX == maxX) {
                System.out.println(""! "" + minX + "" "" + minY + "" "" + maxX + "" "" + middleMinY + "" "" + minX + "" "" + middleMaxY + "" "" + maxX + "" "" + maxY);
                System.out.flush();
            } else {
                int[] a = calX(minX, maxX, minY, middleMinY, in);
                int[] b = calX(minX, maxX, middleMaxY, maxY, in);
                check(a);
                check(b);
                System.out.println(""! "" + a[0] + "" "" + minY + "" "" + a[1] + "" "" + middleMinY + "" "" + b[0] + "" "" + middleMaxY + "" "" + b[1] + "" "" + maxY);
                System.out.flush();
            }
        } else if (minY == maxY) {
            System.out.println(""! "" + minX + "" "" + minY + "" "" + middleMinX + "" "" + maxY + "" "" + middleMaxX + "" "" + minY + "" "" + maxX + "" "" + maxY);
            System.out.flush();
        } else {
            int[] a = calY(minX, middleMinX, minY, maxY, in);
            int[] b = calY(middleMaxX, maxX, minY, maxY, in);
            check(a);
            check(b);
            System.out.println(""! "" + minX + "" "" + a[0] + "" "" + middleMinX + "" "" + a[1] + "" "" + middleMaxX + "" "" + b[0] + "" "" + maxX + "" "" + b[1]);
            System.out.flush();
        }

    }

    static void check(int[] v) {
        if (v[0] == -1 || v[1] == -1) {
            throw new NullPointerException();
        }
    }

    static int increaseC(int c) {
        if (c == 200) {
            throw new NullPointerException();
        }
        return c + 1;
    }

    public static int[] calY(int minX, int maxX, int minY, int maxY, Scanner in) {
        c = increaseC(c);
        System.out.println(""? "" + minX + "" "" + minY + "" "" + maxX + "" "" + (maxY - 1));
        System.out.flush();
        int v = in.nextInt();
        c = increaseC(c);
        System.out.println(""? "" + minX + "" "" + (minY + 1) + "" "" + maxX + "" "" + maxY);
        System.out.flush();
        int o = in.nextInt();
        if (v == 1 && o == 1) {
            int a = -1;
            int start = minY;
            int end = maxY;
            while (start <= end) {
                int mid = (start + end) >> 1;
                c = increaseC(c);
                System.out.println(""? "" + minX + "" "" + minY + "" "" + maxX + "" "" + mid);
                System.out.flush();
                if (in.nextInt() == 1) {
                    a = mid;
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }
            }
            int b = -1;
            start = minY;
            end = a;
            while (start <= end) {
                int mid = (start + end) >> 1;
                c = increaseC(c);
                System.out.println(""? "" + minX + "" "" + mid + "" "" + maxX + "" "" + a);
                System.out.flush();
                if (in.nextInt() == 1) {
                    b = mid;
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
            return new int[]{b, a};
        } else if (v == 1) {
            int a = -1;
            int start = minY;
            int end = maxY;
            while (start <= end) {
                int mid = (start + end) >> 1;
                c = increaseC(c);
                System.out.println(""? "" + minX + "" "" + minY + "" "" + maxX + "" "" + mid);
                System.out.flush();
                if (in.nextInt() == 1) {
                    a = mid;
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }
            }
            return new int[]{minY, a};
        } else if (o == 1) {
            int b = -1;
            int start = minY;
            int end = maxY;
            while (start <= end) {
                int mid = (start + end) >> 1;
                c = increaseC(c);
                System.out.println(""? "" + minX + "" "" + mid + "" "" + maxX + "" "" + maxY);
                System.out.flush();
                if (in.nextInt() == 1) {
                    b = mid;
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
            return new int[]{b, maxY};
        } else {
            return new int[]{minY, maxY};
        }
    }

    public static int[] calX(int minX, int maxX, int minY, int maxY, Scanner in) {
        c = increaseC(c);
        System.out.println(""? "" + minX + "" "" + minY + "" "" + (maxX - 1) + "" "" + maxY);
        System.out.flush();
        int v = in.nextInt();
        c = increaseC(c);
        System.out.println(""? "" + (minX + 1) + "" "" + minY + "" "" + maxX + "" "" + maxY);
        System.out.flush();
        int o = in.nextInt();
        if (v == 1 && o == 1) {
            int a = -1;
            int start = minX;
            int end = maxX;
            while (start <= end) {
                int mid = (start + end) >> 1;
                c = increaseC(c);
                System.out.println(""? "" + minX + "" "" + minY + "" "" + mid + "" "" + maxY);
                System.out.flush();
                if (in.nextInt() == 1) {
                    a = mid;
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }
            }
            int b = -1;
            start = minX;
            end = a;
            while (start <= end) {
                int mid = (start + end) >> 1;
                c = increaseC(c);
                System.out.println(""? "" + mid + "" "" + minY + "" "" + a + "" "" + maxY);
                System.out.flush();
                if (in.nextInt() == 1) {
                    b = mid;
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
            return new int[]{b, a};
        } else if (v == 1) {
            int a = -1;
            int start = minX;
            int end = maxX;
            while (start <= end) {
                int mid = (start + end) >> 1;
                c = increaseC(c);
                System.out.println(""? "" + minX + "" "" + minY + "" "" + mid + "" "" + maxY);
                System.out.flush();
                if (in.nextInt() == 1) {
                    a = mid;
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }
            }
            return new int[]{minX, a};
        } else if (o == 1) {
            int b = -1;
            int start = minX;
            int end = maxX;
            while (start <= end) {
                int mid = (start + end) >> 1;
                c = increaseC(c);
                System.out.println(""? "" + mid + "" "" + minY + "" "" + maxX + "" "" + maxY);
                System.out.flush();
                if (in.nextInt() == 1) {
                    b = mid;
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
            return new int[]{b, maxX};
        } else {
            return new int[]{minX, maxX};
        }
    }

    public static int[] KMP(String val) {
        int i = 0;
        int j = -1;
        int[] result = new int[val.length() + 1];
        result[0] = -1;
        while (i < val.length()) {
            while (j >= 0 && val.charAt(j) != val.charAt(i)) {
                j = result[j];
            }
            j++;
            i++;
            result[i] = j;
        }
        return result;

    }

    public static boolean nextPer(int[] data) {
        int i = data.length - 1;
        while (i > 0 && data[i] < data[i - 1]) {
            i--;
        }
        if (i == 0) {
            return false;
        }
        int j = data.length - 1;
        while (data[j] < data[i - 1]) {
            j--;
        }
        int temp = data[i - 1];
        data[i - 1] = data[j];
        data[j] = temp;
        Arrays.sort(data, i, data.length);
        return true;
    }

    public static int digit(long n) {
        int result = 0;
        while (n > 0) {
            n /= 10;
            result++;
        }
        return result;
    }

    public static double dist(long a, long b, long x, long y) {
        double val = (b - a) * (b - a) + (x - y) * (x - y);
        val = Math.sqrt(val);
        double other = x * x + a * a;
        other = Math.sqrt(other);
        return val + other;

    }

    public static class Point implements Comparable<Point> {

        int x, y;

        public Point(int start, int end) {
            this.x = start;
            this.y = end;
        }

        @Override
        public int hashCode() {
            int hash = 5;
            hash = 47 * hash + this.x;
            hash = 47 * hash + this.y;
            return hash;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            final Point other = (Point) obj;
            if (this.x != other.x) {
                return false;
            }
            if (this.y != other.y) {
                return false;
            }
            return true;
        }

        @Override
        public int compareTo(Point o) {
            return Integer.compare(x, o.x);
        }
    }

    public static class FT {

        long[] data;

        FT(int n) {
            data = new long[n];
        }

        public void update(int index, long value) {
            while (index < data.length) {
                data[index] += value;
                index += (index & (-index));
            }
        }

        public long get(int index) {
            long result = 0;
            while (index > 0) {
                result += data[index];
                index -= (index & (-index));
            }
            return result;

        }
    }

    public static long gcd(long a, long b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }

    public static long pow(long a, long b, long MOD) {
        if (b == 0) {
            return 1;
        }
        if (b == 1) {
            return a;
        }
        long val = pow(a, b / 2, MOD);
        if (b % 2 == 0) {
            return val * val % MOD;
        } else {
            return val * (val * a % MOD) % MOD;

        }
    }

    static class Scanner {

        BufferedReader br;
        StringTokenizer st;

        public Scanner() throws FileNotFoundException {
            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));
            br = new BufferedReader(new InputStreamReader(System.in));
            //  br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(""input.txt""))));
        }

        public String next() {

            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (Exception e) {
                    throw new RuntimeException();
                }
            }
            return st.nextToken();
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            st = null;
            try {
                return br.readLine();
            } catch (Exception e) {
                throw new RuntimeException();
            }
        }

        public boolean endLine() {
            try {
                String next = br.readLine();
                while (next != null && next.trim().isEmpty()) {
                    next = br.readLine();
                }
                if (next == null) {
                    return true;
                }
                st = new StringTokenizer(next);
                return st.hasMoreTokens();
            } catch (Exception e) {
                throw new RuntimeException();
            }
        }
    }
}",2,1
"//make sure to make new file!
import java.io.*;
import java.util.*;

public class B713{
   
   public static BufferedReader f;
   public static PrintWriter out; 
   
   public static void main(String[] args)throws IOException{
      f = new BufferedReader(new InputStreamReader(System.in));
      out = new PrintWriter(System.out);
      
      int n = Integer.parseInt(f.readLine());
      
      
      int l;
      int r;
      int mid;
      int ans;
      
      
      l = 1;
      r = n;
      ans = -1;
      //see if you can draw vertical line between them
      
      while(l <= r){
         mid = l + (r-l)/2;
         if(mid == n) break;
         
         int il = query(1,1,n,mid);
         int ir = query(1,mid+1,n,n);
         
         if(il == 1 && ir == 1){
            ans = mid;
            break;
         }
         
         if(il > ir){
            r = mid-1;
         } else {
            l = mid+1;
         }
      }
      
      int x11 = -1;
      int y11 = -1;
      int x12 = -1;
      int y12 = -1;
      int x21 = -1;
      int y21 = -1;
      int x22 = -1;
      int y22 = -1;
      if(ans == -1){
         //find horizontal line
         l = 1;
         r = n;
         ans = -1;
      
         while(l <= r){
            mid = l + (r-l)/2;
         
         
            int il = query(1,1,mid,n);
            int ir = query(mid+1,1,n,n);
         
            if(il == 1 && ir == 1){
               ans = mid;
               break;
            }
         
            if(il > ir){
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
      
         int bar = ans;
         
                  //find top line of top block
         l = 1;
         r = bar;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(mid,1,bar,n);
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         x11 = ans;
         
         //find bottom line of top block
         l = 1;
         r = bar;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,1,mid,n);
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         x12 = ans;
         
         //find left of top block
         
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,mid,bar,n);
            
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         y11 = ans;
         
         //find right of top block
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,1,bar,mid);
            
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         y12 = ans;
         
         
         
         
         
         //find top line of bottom block
         l = bar+1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(mid,1,n,n);
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         x21 = ans;
         
         //find bottom line of bottom block
         l = bar+1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(bar+1,1,mid,n);
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         x22 = ans;
         
         //find left of bottom block
         
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(bar+1,mid,n,n);
            
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         y21 = ans;
         
         //find right of bottom block
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(bar+1,1,n,mid);
            
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         y22 = ans;
         
         
         
         
         
       
      } else {
         //ans is the vertical line between
         int bar = ans;
         //find left line of left block
         l = 1;
         r = bar;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,mid,n,bar);
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         y11 = ans;
         
         //find right line of left block
         l = 1;
         r = bar;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,1,n,mid);
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         y12 = ans;
         
         //find top of left block
         
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(mid,1,n,bar);
            
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         x11 = ans;
         
         //find bottom of left block
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,1,mid,bar);
            
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         x12 = ans;
         
         
         
         
         
         //find left line of right block
         l = bar+1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,mid,n,n);
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         y21 = ans;
         
         //find right line of right block
         l = bar+1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,bar+1,n,mid);
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         y22 = ans;
         
         //find top of right block
         
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(mid,bar+1,n,n);
            
            if(i == 1){
               ans = mid;
               l = mid+1;
            } else {
               r = mid-1;
            }
         }
         
         x21 = ans;
         
         //find bottom of right block
         l = 1;
         r = n;
         ans = -1;
         while(l <= r){
            mid = l + (r-l)/2;
            
            int i = query(1,bar+1,mid,n);
            
            if(i == 1){
               ans = mid;
               r = mid-1;
            } else {
               l = mid+1;
            }
         }
         
         x22 = ans;
         
      
      }
      
      out.println(""! "" + x11 + "" "" + y11 + "" "" + x12 + "" "" + y12 + "" "" + x21 + "" "" + y21 + "" "" + x22 + "" "" + y22);
      
      
      
      
      out.close();
   }
   
   public static int query(int a,int b, int c, int d)throws IOException{
      out.println(""? "" + a + "" "" + b + "" "" + c + "" "" + d);
      out.flush();
      
      return Integer.parseInt(f.readLine());
   }
   
      
}",2,1
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.PrintStream;
import java.io.BufferedWriter;
import java.util.Random;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Jialin Ouyang (Jialin.Ouyang@gmail.com)
 */
public class Main {
  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    QuickScanner in = new QuickScanner(inputStream);
    QuickWriter out = new QuickWriter(outputStream);
    TaskB solver = new TaskB();
    solver.solve(1, in, out);
    out.close();
  }

  static class TaskB {
    static boolean LOCAL = false;
    static int TEST_CASE = 10000;
    QuickScanner in;
    QuickWriter out;
    int n;
    Server server;

    public void solve(int testNumber, QuickScanner in, QuickWriter out) {
      this.in = in;
      this.out = out;
      n = LOCAL ? 1 << 16 : in.nextInt();
      server = new Server();
      for (int remCases = LOCAL ? TEST_CASE : 1; remCases > 0; --remCases) {
        server.init(n);
        Rect[] rects = split(0);
        if (rects == null) {
          rects = split(1);
        }
        rects[0] = shrink(rects[0]);
        rects[1] = shrink(rects[1]);
        server.answer(rects[0], rects[1]);
      }
    }

    Rect[] split(int dim) {
      int lower = 1, upper = n - 1, res = 0;
      Rect fullRect = new Rect(1, 1, n, n);
      while (lower <= upper) {
        int medium = (lower + upper) >> 1;
        if (server.ask(fullRect.update(1, dim, medium)) == 0) {
          res = medium;
          lower = medium + 1;
        } else {
          upper = medium - 1;
        }
      }
      Rect[] rects = new Rect[]{
          fullRect.update(1, dim, res + 1),
          fullRect.update(0, dim, res + 2)};
      return server.ask(rects[0]) == 1
          && server.ask(rects[1]) == 1
          ? rects : null;
    }

    Rect shrink(Rect rect) {
      rect = shrink(rect, 0);
      rect = shrink(rect, 1);
      return rect;
    }

    Rect shrink(Rect rect, int dim) {
      int lower, upper, res;
      // lower
      lower = rect.getValue(0, dim) + 1;
      upper = rect.getValue(1, dim);
      res = lower - 1;
      while (lower <= upper) {
        int medium = (lower + upper) >> 1;
        if (server.ask(rect.update(0, dim, medium)) == 1) {
          res = medium;
          lower = medium + 1;
        } else {
          upper = medium - 1;
        }
      }
      rect = rect.update(0, dim, res);
      // upper
      lower = rect.getValue(0, dim);
      upper = rect.getValue(1, dim) - 1;
      res = upper + 1;
      while (lower <= upper) {
        int medium = (lower + upper) >> 1;
        if (server.ask(rect.update(1, dim, medium)) == 1) {
          res = medium;
          upper = medium - 1;
        } else {
          lower = medium + 1;
        }
      }
      return rect.update(1, dim, res);
    }

    class Server {
      Rect rect1;
      Rect rect2;

      Server() {
        rect1 = new Rect();
        rect2 = new Rect();
      }

      void init(int n) {
        if (LOCAL) {
          do {
            rect1.initRandom(n);
            rect2.initRandom(n);
          } while (!rect1.valid(rect2));
          //rect1 = new Rect(2, 2, 2, 2);
          //rect2 = new Rect(3, 4, 3, 5);
        }
      }

      int ask(Rect rect) {
        out.print(""? "");
        rect.print();
        out.println();
        out.flush();
        if (LOCAL) {
          return (rect1.in(rect) ? 1 : 0)
              + (rect2.in(rect) ? 1 : 0);
        } else {
          return in.nextInt();
        }
      }

      void answer(Rect rect1, Rect rect2) {
        out.print(""! "");
        rect1.print();
        out.print(' ');
        rect2.print();
        out.println();
        out.flush();
        if (LOCAL) {
          if ((rect1.equals(this.rect1) && rect2.equals(this.rect2))
              || (rect2.equals(this.rect1) && rect1.equals(this.rect2))) {
            System.out.println(""AC!"");
          } else {
            System.out.println(""WA!"");
            throw new IllegalArgumentException();
          }
        }
      }

    }

    class Rect {
      final Random random = new Random();
      int x1;
      int y1;
      int x2;
      int y2;

      Rect() {
      }

      Rect(int x1, int y1, int x2, int y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
      }

      void initRandom(int n) {
        x1 = random.nextInt(n);
        x2 = random.nextInt(n - x1) + x1 + 1;
        ++x1;
        y1 = random.nextInt(n);
        y2 = random.nextInt(n - y1) + y1 + 1;
        ++y1;
      }

      int getValue(int idx1, int idx2) {
        switch ((idx1 << 1) | idx2) {
          case 0:
            return x1;
          case 1:
            return y1;
          case 2:
            return x2;
          case 3:
            return y2;
        }
        throw new IllegalArgumentException();
      }

      Rect update(int idx1, int idx2, int value) {
        switch ((idx1 << 1) | idx2) {
          case 0:
            return new Rect(value, y1, x2, y2);
          case 1:
            return new Rect(x1, value, x2, y2);
          case 2:
            return new Rect(x1, y1, value, y2);
          case 3:
            return new Rect(x1, y1, x2, value);
        }
        return null;
      }

      boolean valid(Rect o) {
        if (x2 < o.x1) return true;
        if (y2 < o.y1) return true;
        if (o.x2 < x1) return true;
        if (o.y2 < y1) return true;
        return false;
      }

      boolean in(Rect o) {
        return o.x1 <= x1 && x2 <= o.x2
            && o.y1 <= y1 && y2 <= o.y2;
      }

      boolean equals(Rect o) {
        return x1 == o.x1 && y1 == o.y1
            && x2 == o.x2 && y2 == o.y2;
      }

      void print() {
        out.printf(""%d %d %d %d"", x1, y1, x2, y2);
      }

    }

  }

  static class QuickScanner {
    private static final int BUFFER_SIZE = 1024;
    private InputStream stream;
    private byte[] buffer;
    private int currentPostion;
    private int numberOfChars;

    public QuickScanner(InputStream stream) {
      this.stream = stream;
      this.buffer = new byte[BUFFER_SIZE];
      this.currentPostion = 0;
      this.numberOfChars = 0;
    }

    public int nextInt() {
      int c = nextNonSpaceChar();
      boolean positive = true;
      if (c == '-') {
        positive = false;
        c = nextChar();
      }
      int res = 0;
      do {
        if (c < '0' || '9' < c) throw new RuntimeException();
        res = res * 10 + c - '0';
        c = nextChar();
      } while (!isSpaceChar(c));
      return positive ? res : -res;
    }

    public int nextNonSpaceChar() {
      int res = nextChar();
      for (; isSpaceChar(res) || res < 0; res = nextChar()) ;
      return res;
    }

    public int nextChar() {
      if (numberOfChars == -1) {
        throw new RuntimeException();
      }
      if (currentPostion >= numberOfChars) {
        currentPostion = 0;
        try {
          numberOfChars = stream.read(buffer);
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
        if (numberOfChars <= 0) {
          return -1;
        }
      }
      return buffer[currentPostion++];
    }

    public boolean isSpaceChar(int c) {
      return c == ' '
          || c == '\n'
          || c == '\r'
          || c == '\t'
          || c < 0;
    }

  }

  static class QuickWriter {
    private final PrintWriter writer;

    public QuickWriter(OutputStream outputStream) {
      this.writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public QuickWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
      for (int i = 0; i < objects.length; ++i) {
        if (i > 0) {
          writer.print(' ');
        }
        writer.print(objects[i]);
      }
    }

    public void println(Object... objects) {
      print(objects);
      writer.print('\n');
    }

    public void printf(String format, Object... objects) {
      writer.printf(format, objects);
    }

    public void close() {
      writer.close();
    }

    public void flush() {
      writer.flush();
    }

  }
}

",2,3
"import java.io.*;
import java.math.*;
import java.util.*;

public class Main {
	static int mod = (int) 1e9 + 7;

	public static void main(String[] args) throws FileNotFoundException {
		FasterScanner s = new FasterScanner();
		int test = 1;
		testloop: while (test-- > 0) {
			int n = s.nextInt();
			int left = 1;
			int right = n;
			int x[][] = new int[2][2];
			int y[][] = new int[2][2];
			while (left < right) {
				int mid = (left + right) / 2;
				query(1, mid, 1, n);
				int ans = s.nextInt();
				if (ans < 2) {
					left = mid + 1;
				} else {
					right = mid;
				}
			}
			x[0][0] = left;
			left = 1;
			right = n;
			while (left < right) {
				int mid = (left + right) / 2;
				query(1, mid, 1, n);
				int ans = s.nextInt();
				if (ans < 1) {
					left = mid + 1;
				} else {
					right = mid;
				}
			}
			x[0][1] = left;
			left = 1;
			right = n;
			while (left < right) {
				int mid = (left + right + 1) / 2;
				query(mid, n, 1, n);
				int ans = s.nextInt();
				if (ans < 2) {
					right = mid - 1;
				} else {
					left = mid;
				}
			}
			x[1][0] = left;
			left = 1;
			right = n;
			while (left < right) {
				int mid = (left + right + 1) / 2;
				query(mid, n, 1, n);
				int ans = s.nextInt();
				if (ans < 1) {
					right = mid - 1;
				} else {
					left = mid;
				}
			}
			x[1][1] = left;
			// System.out.println(Arrays.deepToString(x));

			left = 1;
			right = n;
			while (left < right) {
				int mid = (left + right) / 2;
				query(1, n, 1, mid);
				int ans = s.nextInt();
				if (ans < 2) {
					left = mid + 1;
				} else {
					right = mid;
				}
			}
			y[0][0] = left;
			left = 1;
			right = n;
			while (left < right) {
				int mid = (left + right) / 2;
				query(1, n, 1, mid);
				int ans = s.nextInt();
				if (ans < 1) {
					left = mid + 1;
				} else {
					right = mid;
				}
			}
			y[0][1] = left;
			left = 1;
			right = n;
			while (left < right) {
				int mid = (left + right + 1) / 2;
				query(1, n, mid, n);
				int ans = s.nextInt();
				if (ans < 2) {
					right = mid - 1;
				} else {
					left = mid;
				}
			}
			y[1][0] = left;
			left = 1;
			right = n;
			while (left < right) {
				int mid = (left + right + 1) / 2;
				query(1, n, mid, n);
				int ans = s.nextInt();
				if (ans < 1) {
					right = mid - 1;
				} else {
					left = mid;
				}
			}
			y[1][1] = left;
//			System.out.println(Arrays.deepToString(x));
//			System.out.println(Arrays.deepToString(y));
			
			int x11 = 0, x12 = 0, y11 = 0, y12 = 0;
			int x21 = 0, x22 = 0, y21 = 0, y22 = 0;
			for (int x1 = 0; x1 < 2; x1++) {
				x11 = x[1][x1];
				x21 = x[1][1 - x1];
				for (int x2 = 0; x2 < 2; x2++) {
					x12 = x[0][x2];
					x22 = x[0][1 - x2];
					if (x11 > x12)
						continue;
					if (x21 > x22)
						continue;
					for (int y1 = 0; y1 < 2; y1++) {
						y11 = y[1][y1];
						y21 = y[1][1 - y1];
						for (int y2 = 0; y2 < 2; y2++) {
							y12 = y[0][y2];
							y22 = y[0][1 - y2];
							if (y11 > y12)
								continue;
							if (y21 > y22)
								continue;
							query(x11, x12, y11, y12);
							int ans1 = s.nextInt();

							query(x21, x22, y21, y22);
							int ans2 = s.nextInt();
							if (ans1 == 1 && ans2 == 1) {
								System.out.println(""! "" + x11 + "" "" + y11 + "" "" + x12 + "" "" + y12 + "" "" + x21 + "" ""
										+ y21 + "" "" + x22 + "" "" + y22);
								System.out.flush();
								break testloop;
							}
						}
					}
				}
			}

		}
	}

	public static void query(int x1, int x2, int y1, int y2) {
		 System.out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);
		 System.out.flush();
//		int count = 0;
//		if (x1 <= 2 && y1 <= 2 && x2 >= 2 && y2 >= 2)
//			count++;
//
//		if (x1 <= 3 && y1 <= 4 && x2 >= 3 && y2 >= 5)
//			count++;
//		System.out.println(count);
	}

	public static void set(int[] t, int i, int value) {
		i += t.length / 2;
		t[i] = value;
		for (; i > 1; i >>= 1)
			t[i >> 1] = Math.max(t[i], t[i ^ 1]);
	}

	// max[a, b]
	public static int max(int[] t, int a, int b) {
		int res = 0;
		for (a += t.length / 2, b += t.length / 2; a <= b; a = (a + 1) >> 1, b = (b - 1) >> 1) {
			if ((a & 1) != 0)
				res = Math.max(res, t[a]);
			if ((b & 1) == 0)
				res = Math.max(res, t[b]);
		}
		return res;
	}

	public static int[] generateDivisorTable(int n) {
		int[] divisor = new int[n + 1];
		for (int i = 1; i <= n; i++)
			divisor[i] = i;
		for (int i = 2; i * i <= n; i++)
			if (divisor[i] == i)
				for (int j = i * i; j <= n; j += i)
					if (divisor[j] == j)
						divisor[j] = i;
		return divisor;
	}

	public static long pow(long x, long n, long mod) {
		long res = 1;
		for (long p = x; n > 0; n >>= 1, p = (p * p) % mod) {
			if ((n & 1) != 0) {
				res = (res * p % mod);
			}
		}
		return res;
	}

	static long gcd(long n1, long n2) {
		long r;
		while (n2 != 0) {
			r = n1 % n2;
			n1 = n2;
			n2 = r;
		}
		return n1;
	}

	static class FasterScanner {
		private byte[] buf = new byte[1024];
		private int curChar;
		private int snumChars;

		public int read() {
			if (snumChars == -1)
				throw new InputMismatchException();
			if (curChar >= snumChars) {
				curChar = 0;
				try {
					snumChars = System.in.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (snumChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		public String nextLine() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndOfLine(c));
			return res.toString();
		}

		public String nextString() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public long nextLong() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-') {
				sgn = -1;
				c = read();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			return res * sgn;
		}

		public int nextInt() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-') {
				sgn = -1;
				c = read();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			return res * sgn;
		}

		public int[] nextIntArray(int n) {
			int[] arr = new int[n];
			for (int i = 0; i < n; i++) {
				arr[i] = nextInt();
			}
			return arr;
		}

		public long[] nextLongArray(int n) {
			long[] arr = new long[n];
			for (int i = 0; i < n; i++) {
				arr[i] = nextLong();
			}
			return arr;
		}

		private boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		private boolean isEndOfLine(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}
	}
}",2,3
"import java.io.*;
import java.util.*;
import java.math.*;
public class Main {
    InputStream is;
    PrintWriter out;
    String INPUT = """" ;
    boolean local = false;
    int inf=0x7FFFFFFF;
    int MOD=(int)(1e9+7);
    double eps=1e-5;
    double PI=Math.acos(-1);
    void solve() {
        long maxn=nl();
        long L=1,R=maxn,ans=-1;
        while (L<=R){
            long mid=(L+R)/2;
            if(ask(1,1,mid,maxn)<1)L=mid+1;
            else{
                R=mid-1;
                ans=mid;
            }
        }
        if(ask(1,1,ans,maxn)==1 && ask(ans+1,1,maxn,maxn)==1){
            Yts1999 a1=gao(1,1,ans,maxn);
            Yts1999 a2=gao(ans+1,1,maxn,maxn);
            answer(a1,a2);
        }else{
            L=1;R=maxn;ans=-1;
            while (L<=R){
                long mid=(L+R)/2;
                if(ask(1,1,maxn,mid)<1)L=mid+1;
                else{
                    R=mid-1;
                    ans=mid;
                }
            }
            Yts1999 a1=gao(1,1,maxn,ans);
            Yts1999 a2=gao(1,ans+1,maxn,maxn);
            answer(a1,a2);
        }
    }
    void answer(Yts1999 a1,Yts1999 a2){
        out.print(""!"");
        a1.print();
        a2.print();
        out.flush();
    }
    int ask(long a,long b,long c,long d){
        out.printf(""? %d %d %d %d"",a,b,c,d);
        out.println();
        out.flush();
        return ni();
    }
    Yts1999 gao(long x1,long x2,long y1,long y2){
        long a1=0,a2=0,a3=0,a4=0;
        long L,R;
        L=x1;R=y1;
        while(L<=R){
            long mid=(L+R)/2;
            if(ask(mid,x2,y1,y2)==1){
                a1=mid;
                L=mid+1;
            }else R=mid-1;
        }
        L=x1;R=y1;
        while(L<=R){
            long mid=(L+R)/2;
            if(ask(x1,x2,mid,y2)==1){
                a3=mid;
                R=mid-1;
            }else L=mid+1;
        }
        L=x2;R=y2;
        while(L<=R){
            long mid=(L+R)/2;
            if(ask(x1,mid,y1,y2)==1){
                a2=mid;
                L=mid+1;
            }else R=mid-1;
        }
        L=x2;R=y2;
        while(L<=R){
            long mid=(L+R)/2;
            if(ask(x1,x2,y1,mid)==1){
                a4=mid;
                R=mid-1;
            }else L=mid+1;
        }
        return new Yts1999(a1,a2,a3,a4);
    }
    public class Yts1999 implements Comparable{
        public long a,b,c,d;
        public Yts1999(long a,long b,long c,long d){
            this.a=a;
            this.b=b;
            this.c=c;
            this.d=d;
        }
        public int compareTo(Object o) {
            Yts1999 to=(Yts1999)o;
            if(this.d<to.d) return 1;
            else if(this.d==to.d) return 0;
            else return -1;
        }
        public void print(){
            out.printf("" %d %d %d %d"",a,b,c,d);
        }
    }
    long[] exgcd(long a, long b) {
        if (b == 0) return new long[]{1,0,a};
        long[] res = exgcd(b, a%b);
        long t = res[0]; res[0] = res[1]; res[1] = t;
        res[1] -= a/b*res[0];
        return res;
    }
    long gcd(long a,long b){
        return b==0?a:gcd(b,a%b);
    }
    long lcm(long a,long b){
        return a*b/gcd(a,b);
    }
    private void run() {
        is = local? new ByteArrayInputStream(INPUT.getBytes()):System.in;
        out = new PrintWriter(System.out);
        long s = System.currentTimeMillis();
        solve();
        out.flush();
        tr(System.currentTimeMillis()-s+""ms"");
    }
    public static void main(String[] args) throws Exception { new Main().run(); }
    private byte[] inbuf = new byte[1024];
    public int lenbuf = 0, ptrbuf = 0;
    private int readByte(){
        if(lenbuf == -1)throw new InputMismatchException();
        if(ptrbuf >= lenbuf){
            ptrbuf = 0;
            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
            if(lenbuf <= 0)return -1;
        }
        return inbuf[ptrbuf++];
    }
    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
    private double nd() { return Double.parseDouble(ns()); }
    private char nc() { return (char)skip(); }
    private String ns(){
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    private char[] ns(int n){
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while(p < n && !(isSpaceChar(b))){
            buf[p++] = (char)b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }
    private char[][] nm(int n, int m){
        char[][] map = new char[n][];
        for(int i = 0;i < n;i++)map[i] = ns(m);
        return map;
    }
    private int[] na(int n){
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
        return a;
    }
    private int ni(){
        int num = 0, b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }
        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }
    private long nl(){
        long num = 0;
        int b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }
        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }
    private void tr(Object... o) { if(local)System.out.println(Arrays.deepToString(o)); }
}",2,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    private static StringTokenizer st;
    private static BufferedReader br;
    public static long MOD = 1000000007;

    public static void print(Object x) {
        System.out.println(x + """");
    }
    public static String join(Collection<?> x, String space) {
        if (x.size() == 0) return """";
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (Object elt : x) {
            if (first) first = false;
            else sb.append(space);
            sb.append(elt);
        }
        return sb.toString();
    }

    public static String nextToken() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            String line = br.readLine();
            st = new StringTokenizer(line.trim());
        }
        return st.nextToken();
    }
    public static int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }
    public static long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    // Finds smallest rectangle containing something along 1 dimension.
    public static long[] search(long[] none, long[] some) throws IOException {
        long[] med = new long[4];
        for (int i = 0; i < 4; i++) {
            if (Math.abs(none[i] - some[i]) == 1) {
                return some;
            }
            med[i] = (none[i] + some[i]) / 2;
        }

        int ans = query(med);

        if (ans > 0) return search(none, med);
        else return search(med, some);
    }

    public static int query(long[] query) throws IOException {
        print(""? "" + arr(query));
        System.out.flush();

        int ans = nextInt();
        if (contains(query)) ans -= 1;

        return ans;
    }

    public static boolean contains(long[] search) {
        if (rect1 == null) return false;
        if (search[0] > rect1[0]) return false;
        if (search[1] > rect1[1]) return false;
        if (search[2] < rect1[2]) return false;
        if (search[3] < rect1[3]) return false;
        return true;
    }

    public static String arr(long[] x) {
        return x[0] + "" "" + x[1] + "" "" + x[2] + "" "" + x[3];
    }
    public static long[] find() throws IOException {
        long[] d0 = {1, 1, 1, 1};
        long[] some = {1, 1, n, n};
        if (query(d0) > 0) {
            return d0;
        }
//        print(""   "" + arr(some));
        long[] none = {1, 1, n, 1};
        if (query(none) > 0) some = none;
        else some = search(none, some);

//        print(""   "" + arr(some));
        none = new long[] {1, 1, 1, some[3]};
        if (query(none) > 0) some = none;
        else some = search(none, some);

//        print(""   "" + arr(some));
        none = new long[] {1, some[3], some[2], some[3]};
        if (query(none) > 0) some = none;
        else some = search(none, some);

//        print(""   "" + arr(some));
        none = new long[] {some[2], some[1], some[2], some[3]};
        if (query(none) > 0) some = none;
        else some = search(none, some);
        return some;
    }

    public static long[] rect1 = null;
    public static long[] rect2 = null;
    public static long n;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));

        n = nextLong();

        rect1 = find();
        rect2 = find();
        print(""! "" + arr(rect1) + "" ""
                   + arr(rect2));
        System.out.flush();
    }
}
",2,1
"import java.io.*;
import java.util.*;
import java.util.function.IntPredicate;

import static java.lang.Math.*;

public class Main {
    FastScanner in;
    PrintWriter out;

    static final String FILE = """";

    public static final int TEST = 0;

    class Interact {
        Rect a, b;

        public Interact(int x11, int y11, int x12, int y12, int x21, int y21, int x22, int y22) {
            a = new Rect(x11, y11, x12, y12);
            b = new Rect(x21, y21, x22, y22);
        }

        int query(int x1, int y1, int x2, int y2) {
            int ans = 0;
            if (x1 <= a.x1 && x2 >= a.x2 && y1 <= a.y1 && y2 >= a.y2)
                ans++;
            if (x1 <= b.x1 && x2 >= b.x2 && y1 <= b.y1 && y2 >= b.y2)
                ans++;
            return ans;
        }
    }
    Interact interact;

    class Rect {
        int x1, y1, x2, y2;

        public Rect() {
        }

        public Rect(int x1, int y1, int x2, int y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        }

        @Override
        public String toString() {
            return x1 + "" "" + y1 + "" "" + x2 + "" "" + y2;
        }
    }

    int calls;

    int query(int x1, int y1, int x2, int y2, Rect rect) {
        calls++;
        if (calls >= 190)
            throw new RuntimeException();

        if (TEST == 0) {
            out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);
            out.flush();
            int ans = in.nextInt();
            if (x1 <= rect.x1 && x2 >= rect.x2 && y1 <= rect.y1 && y2 >= rect.y2)
                ans--;
            return ans;
        } else {
            int ans = interact.query(x1, y1, x2, y2);
            if (x1 <= rect.x1 && x2 >= rect.x2 && y1 <= rect.y1 && y2 >= rect.y2)
                ans--;
            return ans;
        }
    }

    static int binarySearchFirstTrue(IntPredicate predicate, int fromInclusive, int toInclusive) {
        int a = fromInclusive, b = toInclusive;
        while (a != b) {
            int la = a, lb = b;
            int mid = (a + b) / 2;
            if (predicate.test(mid))
                b = mid;
            else
                a = mid;
            if (la == a && lb == b) {
                if (predicate.test(a))
                    b = a;
                else
                    a = b;
            }
        }
        return a;
    }

    static int binarySearchLastTrue(IntPredicate predicate, int fromInclusive, int toInclusive) {
        int a = fromInclusive, b = toInclusive;
        while (a != b) {
            int la = a, lb = b;
            int mid = (a + b) / 2;
            if (predicate.test(mid))
                a = mid;
            else
                b = mid;
            if (la == a && lb == b) {
                if (predicate.test(b))
                    a = b;
                else
                    b = a;
            }
        }
        return a;
    }

    static Rect rect;

    void test() {
        Random random = new Random(13);
        for (int test = 0; test < 1000; test++) {

        }
    }

    void solve() {
        rect = new Rect();

        if (TEST == 0) {
            int n = in.nextInt();
            List<Rect> list = new ArrayList<>();
            for (int r = 0; r < 2; r++) {
                int x2 = binarySearchFirstTrue(i -> query(1, 1, i, n, rect) >= 1, 1, n);
                int x1 = binarySearchLastTrue(i -> query(i, 1, x2, n, rect) >= 1, 1, x2);
                int y2 = binarySearchFirstTrue(i -> query(x1, 1, x2, i, rect) >= 1, 1, n);
                int y1 = binarySearchLastTrue(i -> query(x1, i, x2, y2, rect) >= 1, 1, y2);
                rect = new Rect(x1, y1, x2, y2);
                list.add(rect);
            }
            out.println(""! "" + list.get(0) + "" "" + list.get(1));
            out.flush();
        } else {
            int n = in.nextInt();
            int x11 = in.nextInt(), y11 = in.nextInt(), x12 = in.nextInt(), y12 = in.nextInt();
            int x21 = in.nextInt(), y21 = in.nextInt(), x22 = in.nextInt(), y22 = in.nextInt();
            interact = new Interact(x11, y11, x12, y12, x21, y21, x22, y22);
            List<Rect> list = new ArrayList<>();
            for (int r = 0; r < 2; r++) {
                int x2 = binarySearchFirstTrue(i -> query(1, 1, i, n, rect) >= 1, 1, n);
                int x1 = binarySearchLastTrue(i -> query(i, 1, x2, n, rect) >= 1, 1, x2);
                int y2 = binarySearchFirstTrue(i -> query(x1, 1, x2, i, rect) >= 1, 1, n);
                int y1 = binarySearchLastTrue(i -> query(x1, i, x2, y2, rect) >= 1, 1, y2);
                rect = new Rect(x1, y1, x2, y2);
                list.add(rect);
            }
            out.println(""! "" + list.get(0) + "" "" + list.get(1));
            out.flush();
        }
    }

    public void run() {
        if (FILE.equals("""")) {
            in = new FastScanner(System.in);
            out = new PrintWriter(System.out);
        } else {
            try {
                in = new FastScanner(new FileInputStream(FILE +
                        "".in""));
                out = new PrintWriter(new FileOutputStream(FILE +
                        "".out""));
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }
        solve();
        out.close();
    }

    public static void main(String[] args) {
        (new Main()).run();
    }

    class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));
        }

        public String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        public String nextLine() {
            st = null;
            try {
                return br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public float nextFloat() {
            return Float.parseFloat(next());
        }
    }

}",2,1
"import java.io.*;
import java.util.*;

public class B {

	BufferedReader br;
	PrintWriter out;
	StringTokenizer st;
	boolean eof;
	
//	int X1, Y1, X2, Y2;
//	int X3, Y3, X4, Y4;
//	{
//		X1 = 1;
//		Y1 = 2;
//		X2 = 3;
//		Y2 = 4;
//		
//		X3 = 5;
//		Y3 = 1;
//		X4 = 5;
//		Y4 = 5;
//	}

	int ask(int x1, int y1, int x2, int y2) throws IOException {
		out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);
		out.flush();
		return nextInt();
	}
	
	int inside(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {
		return inside(x1, x2, x3, x4) & inside(y1, y2, y3, y4);
	}
	
	int inside(int x1, int x2, int y1, int y2) {
		return (x1 <= y1 && y2 <= x2) ? 1 : 0;
	}
	
//	int ask(int x1, int y1, int x2, int y2) throws IOException {
//		return inside(x1, y1, x2, y2, X1, Y1, X2, Y2) + inside(x1, y1, x2, y2, X3, Y3, X4, Y4); 
//	}

	int askFlipped(int x1, int y1, int x2, int y2) throws IOException {
		return ask(y1, x1, y2, x2);
	}
	
	boolean check(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) throws IOException {
		if (x1 > x2 || y1 > y2 || x3 > x4 || y3 > y4) {
			return false;
		}
		
		if (Math.max(x1, x3) <= Math.min(x2, x4) && Math.max(y1, y3) <= Math.min(y2, y4)) {
			return false;
		}
		
		return check(x1, y1, x2, y2) && check(x3, y3, x4, y4);
	}
	
	boolean check(int x1, int y1, int x2, int y2) throws IOException {
		if (ask(x1, y1, x2, y2) != 1) {
			return false;
		}
		if (x1 != x2) {
			if (ask(x1 + 1, y1, x2, y2) != 0 || ask(x1, y1, x2 - 1, y2) != 0) {
				return false;
			}
		}
		
		if (y1 != y2) {
			if (ask(x1, y1 + 1, x2, y2) != 0 || ask(x1, y1, x2, y2 - 1) != 0) {
				return false;
			}
		}
		return true;
	}

	void solve() throws IOException {
		int n = nextInt();

		int low = 0; // 0
		int high = n; // >0
		while (high - low > 1) {
			int mid = (low + high) >> 1;
			int ret = ask(1, 1, mid, n);
			if (ret == 0) {
				low = mid;
			} else {
				high = mid;
			}
		}

		int minX2 = high;

		low = 0; // <2
		high = n; // 2
		while (high - low > 1) {
			int mid = (low + high) >> 1;
			int ret = ask(1, 1, mid, n);
			if (ret == 2) {
				high = mid;
			} else {
				low = mid;
			}
		}

		int maxX2 = high;

		low = 1; // >0
		high = n + 1; // 0
		while (high - low > 1) {
			int mid = (low + high) >> 1;
			int ret = ask(mid, 1, n, n);
			if (ret == 0) {
				high = mid;
			} else {
				low = mid;
			}
		}

		int maxX1 = low;

		low = 1; // 2
		high = n + 1; // <2
		while (high - low > 1) {
			int mid = (low + high) >> 1;
			int ret = ask(mid, 1, n, n);
			if (ret == 2) {
				low = mid;
			} else {
				high = mid;
			}
		}
		int minX1 = low;

		// / NOW Y

		low = 0; // 0
		high = n; // >0
		while (high - low > 1) {
			int mid = (low + high) >> 1;
			int ret = askFlipped(1, 1, mid, n);
			if (ret == 0) {
				low = mid;
			} else {
				high = mid;
			}
		}

		int minY2 = high;

		low = 0; // <2
		high = n; // 2
		while (high - low > 1) {
			int mid = (low + high) >> 1;
			int ret = askFlipped(1, 1, mid, n);
			if (ret == 2) {
				high = mid;
			} else {
				low = mid;
			}
		}

		int maxY2 = high;

		low = 1; // >0
		high = n + 1; // 0
		while (high - low > 1) {
			int mid = (low + high) >> 1;
			int ret = askFlipped(mid, 1, n, n);
			if (ret == 0) {
				high = mid;
			} else {
				low = mid;
			}
		}

		int maxY1 = low;

		low = 1; // 2
		high = n + 1; // <2
		while (high - low > 1) {
			int mid = (low + high) >> 1;
			int ret = askFlipped(mid, 1, n, n);
			if (ret == 2) {
				low = mid;
			} else {
				high = mid;
			}
		}
		int minY1 = low;

		int[] x1s = { minX1, maxX1 };
		int[] x2s = { minX2, maxX2 };
		int[] y1s = { minY1, maxY1 };
		int[] y2s = { minY2, maxY2 };
		
		for (int mask = 0; mask < 8; mask++) {
			int x1 = x1s[0];
			int x3 = x1s[1];
			
			int x2 = x2s[get(mask, 0)];
			int x4 = x2s[get(mask, 0) ^ 1];
			
			int y1 = y1s[get(mask, 1)];
			int y3 = y1s[get(mask, 1) ^ 1];
			
			int y2 = y2s[get(mask, 2)];
			int y4 = y2s[get(mask, 2) ^ 1];
			
			if (check(x1, y1, x2, y2, x3, y3, x4, y4)) {
				out.printf(""! %d %d %d %d %d %d %d %d\n"", x1, y1, x2, y2, x3, y3, x4, y4);
				out.flush();
				return;
			}
		}
	}
	
	int get(int mask, int i) {
		return (mask >> i) & 1;
	}

	B() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		solve();
		out.close();
	}

	public static void main(String[] args) throws IOException {
		new B();
	}

	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception e) {
				eof = true;
				return null;
			}
		}
		return st.nextToken();
	}

	String nextString() {
		try {
			return br.readLine();
		} catch (IOException e) {
			eof = true;
			return null;
		}
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}",2,1
"import java.io.*;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class DTask {

    static Scanner in;
    static int[] first = new int[4];
    static int[] second = new int[4];
    static PrintWriter out;
    static int n;

    public static void main(String[] args) throws IOException {
        in = new Scanner(System.in);
        out = new PrintWriter(System.out);
        n = in.nextInt() + 1;
        first = new int[]{0, 0, n, n};
        second = new int[]{0, 0, n, n};
        for (int i = 0; i < first.length; i++) {
            boolean inc = i < 2;
            search(first, i, inc, false);
            if (!inc) {
                first[i] += 1;
            }
        }

        for (int i = 0; i < second.length; i++) {
            boolean inc = i < 2;
            search(second, i, inc, true);
            if (!inc) {
                second[i] += 1;
            }
        }
        String s = ""!"";
        for (int i = 0; i < 4; i++) {
            s += "" "" + second[i];
        }
        for (int i = 0; i < 4; i++) {
            s += "" "" + first[i];
        }
        out.println(s);
        out.flush();
    }

    static void search(int arr[], int i, boolean inc, boolean cond) {
        int start = 0;
        int end = n;
        while (true) {
            if (end - start <= 1) {
                arr[i] = start;
                return;
            }
            int mid = (start + end) / 2;
            arr[i] = mid;
            int n = ask(arr, cond);
            if (n > 0) {
                if (inc) {
                    start = mid;
                } else {
                    end = mid;
                }
            } else {
                if (inc) {
                    end = mid;
                } else {
                    start = mid;
                }
            }
        }
    }

    static int ask(int arr[], boolean cond) {
        if (arr[1] > arr[3] || arr[0] > arr[2]) {
            return 0;
        }
        arr = Arrays.copyOf(arr, 4);
        String q = """";
        q += ""?"";
        for (int i = 0; i < arr.length; i++) {
            int x = Math.min(arr[i], n - 1);
            x = Math.max(x, 1);
            q += "" "" + x;
        }
        out.println(q);
        out.flush();
        int x = in.nextInt();
        if (cond) {
            x -= within(arr, first) ? 1 : 0;
        }
        return x;
        /*if (arr[1] > arr[3] || arr[0] > arr[2]) {
            return 0;
        }
        int[] check = new int[]{1, 1, 10, 1};
        int[] check1 = new int[]{5, 5, 5, 10};
        int result = within(arr, check) ? 1 : 0;
        result += within(arr, check1) ? 1 : 0;
        if (cond) {
            result -= within(arr, first) ? 1 : 0;
        }
        return result;*/


    }

    static boolean within(int outer[], int inner[]) {
        return (outer[0] <= inner[0] && outer[1] <= inner[1] && outer[2] >= inner[2] && outer[3] >= inner[3]);
    }

    static class MyInputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public MyInputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
    }


}

",2,3
"import javax.crypto.AEADBadTagException;
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.List;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author AlexFetisov
 */
public class TaskB_AF {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB_cf371 solver = new TaskB_cf371();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB_cf371 {
        List<Rectangle> rects;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();

            int xLeft = 1, xRight = n;
            int xSeparate = -1;
            while (xLeft <= xRight) {
                int e = (xLeft + xRight) / 2;
                int t = makeRequest(in, out, 1, 1, e, n);
                if (t == 1) {
                    xSeparate = e;
                    xRight = e - 1;
                } else if (t == 0) {
                    xLeft = e + 1;
                } else {
                    xRight = e - 1;
                }
            }
            rects = new ArrayList<Rectangle>();
            if (xSeparate != -1 && makeRequest(in, out, xSeparate + 1, 1, n, n) == 1) {
                detectRectangle(in, out, 1, 1, xSeparate, n);
                detectRectangle(in, out, xSeparate + 1, 1, n, n);

                out.print(""! "");
                for (Rectangle r : rects) {
                    out.print(r.toString() + "" "");
                }
                out.println();
                out.flush();
                return;
            }

            int yLeft = 1, yRight = n;
            int ySeparate = -1;
            while (yLeft <= yRight) {
                int e = (yLeft + yRight) / 2;
                int t = makeRequest(in, out, 1, 1, n, e);
                if (t == 1) {
                    ySeparate = e;
                    yRight = e - 1;
                } else if (t == 0) {
                    yLeft = e + 1;
                } else {
                    yRight = e - 1;
                }
            }

            if (ySeparate != -1) {
                detectRectangle(in, out, 1, 1, n, ySeparate);
                detectRectangle(in, out, 1, ySeparate + 1, n, n);

                out.print(""! "");
                for (Rectangle r : rects) {
                    out.print(r.toString() + "" "");
                }
                out.println();
                out.flush();
                return;
            }
            throw new AssertionError(""!"");
        }

        private void detectRectangle(InputReader in, PrintWriter out, int xMin, int yMin, int xMax, int yMax) {
            int xLeft = -1, xRight = -1, yLeft = -1, yRight = -1;

            int left = xMin, right = xMax;
            while (left <= right) {
                int e = (left + right) / 2;
                if (makeRequest(in, out, xMin, yMin, e, yMax) == 1) {
                    xRight = e;
                    right = e - 1;
                } else {
                    left = e + 1;
                }
            }

            left = xMin;
            right = xRight;
            while (left <= right) {
                int e = (left + right) / 2;
                if (makeRequest(in, out, e, yMin, xRight, yMax) == 1) {
                    xLeft = e;
                    left = e + 1;
                } else {
                    right = e - 1;
                }
            }

            left = yMin;
            right = yMax;
            while (left <= right) {
                int e = (left + right) / 2;
                if (makeRequest(in, out, xLeft, yMin, xRight, e) == 1) {
                    yRight = e;
                    right = e - 1;
                } else {
                    left = e + 1;
                }
            }

            left = yMin;
            right = yRight;
            while (left <= right) {
                int e = (left + right) / 2;
                if (makeRequest(in, out, xLeft, e, xRight, yRight) == 1) {
                    yLeft = e;
                    left = e + 1;
                } else {
                    right = e - 1;
                }
            }
            rects.add(new Rectangle(xLeft, yLeft, xRight, yRight));
        }

        private int makeRequest(InputReader in, PrintWriter out, int x1, int y1, int x2, int y2) {
            out.print(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);
            out.println();
            out.flush();
            return in.nextInt();
        }

        class Rectangle {
            int x1;
            int x2;
            int y1;
            int y2;

            public Rectangle(int x1, int y1, int x2, int y2) {
                this.x1 = x1;
                this.x2 = x2;
                this.y1 = y1;
                this.y2 = y2;
            }


            public String toString() {
                StringBuilder b = new StringBuilder("""");
                b.append(x1).append(' ');
                b.append(y1).append(' ');
                b.append(x2).append(' ');
                b.append(y2);
                return b.toString();
            }

        }

    }

    static class InputReader {
        private BufferedReader reader;
        private StringTokenizer stt;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream));
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                return null;
            }
        }

        public String nextString() {
            while (stt == null || !stt.hasMoreTokens()) {
                stt = new StringTokenizer(nextLine());
            }
            return stt.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(nextString());
        }

    }
}
",2,1
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        int[][] dr = new int[][]{{0, 0, 0, -1}, {0, 0, -1, 0}, {0, 1, 0, 0}, {1, 0, 0, 0}};
        int[][] dd = new int[][]{{1, 3}, {0, 2}, {1, 3}, {0, 2}};
        PrintWriter out;
        InputReader in;
        int[] re1;
        int[] re2;
        int N;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            N = in.nextInt();
            int r[] = new int[]{1, 1, N, N};

            this.out = out;
            this.in = in;

            re1 = new int[]{1, 1, 1, 1};
            re2 = new int[]{2, 1, 2, 1};

            //probuje najpierw lewa sciane

            int fr[] = moveSide(r, dr[2], dd[2]);
            int sr[] = subtract(r, fr);
            if (!validSeparation(sr)) {
                fr = moveSide(r, dr[1], dd[1]);
                sr = subtract(r, fr);
            }

            fr = boundary(fr);
            sr = boundary(sr);

            out.println(String.format(""! %d %d %d %d %d %d %d %d"", fr[0], fr[1], fr[2], fr[3], sr[0], sr[1], sr[2], sr[3]));
        }

        private boolean validSeparation(int[] sr) {
            if (!validRectangle(sr)) return false;
            out.println(String.format(""? %d %d %d %d"", sr[0], sr[1], sr[2], sr[3]));
            out.flush();
            return in.nextInt() == 1;
        }

        private boolean validRectangle(int[] sr) {
            for (int i = 0; i < 4; i++) {
                if (sr[i] < 1 || sr[i] > N) return false;
            }
            return true;
        }

        private int[] boundary(int[] r) {
            for (int d = 0; d < 4; d++) {
                r = moveSide(r, dr[d], dd[d]);
            }
            return r;
        }

        private int[] subtract(final int[] r, final int[] fr) {
            if (r[1] == fr[1]) {
                //jesli lewy dolny taki sam to ucieto horyzontalnie od gory
                return new int[]{fr[2] + 1, r[1], r[2], r[3]};
            }
            //else ucieto wertykalnie od lewej
            return new int[]{r[0], r[1], r[2], fr[1] - 1};
        }

        private int[] moveSide(final int[] rect, final int[] factors, final int[] widths) {
            int width = Math.abs(rect[widths[0]] - rect[widths[1]]);

            int lo = -1, hi = width + 1;

            while (lo + 1 < hi) {
                int m = lo + (hi - lo) / 2;
                int qr[] = new int[4];
                for (int d = 0; d < 4; d++) qr[d] = rect[d] + factors[d] * m;
                int ans = query(qr);
                if (ans != 0) {
                    lo = m;
                } else {
                    hi = m;
                }
            }

            int ans_rect[] = new int[4];
            for (int d = 0; d < 4; d++) ans_rect[d] = rect[d] + factors[d] * lo;

            return ans_rect;
        }

        private int query(final int[] qr) {
            int ans = 0;
            out.println(String.format(""? %d %d %d %d"", qr[0], qr[1], qr[2], qr[3]));
            out.flush();

            ans = in.nextInt();

//        if (contains(qr, re1)) ans++;
//        if (contains(qr, re2)) ans++;
            return ans;
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",2,1
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		FastScanner in = new FastScanner(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskB solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}

	static class TaskB {
		int n;
		int sepX;
		int sepY;
		int x1;
		int y1;
		int x2;
		int y2;
		FastScanner in;
		PrintWriter out;

		public void solve(int testNumber, FastScanner in, PrintWriter out) {
			this.in = in;
			this.out = out;
			n = in.nextInt();

			int x11, x12, y11, y12;
			int x21, x22, y21, y22;
			findSeparatingX();
			findSeparatingY();

			if (sepX >= 0) {
				locate(0, 0, sepX, n);
				x11 = x1;
				y11 = y1;
				x12 = x2;
				y12 = y2;
				locate(sepX, 0, n, n);
				x21 = x1;
				y21 = y1;
				x22 = x2;
				y22 = y2;
			} else {
				locate(0, 0, n, sepY);
				x11 = x1;
				y11 = y1;
				x12 = x2;
				y12 = y2;
				locate(0, sepY, n, n);
				x21 = x1;
				y21 = y1;
				x22 = x2;
				y22 = y2;
			}

			++x11;
			++x21;
			++y11;
			++y21;
			out.println(""! "" + x11 + "" "" + y11 + "" "" + x12 + "" "" + y12 + "" "" + +x21 + "" "" + y21 + "" "" + x22 + "" "" + y22);
			out.flush();
		}

		void locate(int x1, int y1, int x2, int y2) {
			for (int step = 15; step >= 0; step--) {
				int h = 1 << step;
				if (query(x1 + h, y1, x2, y2) > 0) {
					x1 += h;
				}
				if (query(x1, y1, x2 - h, y2) > 0) {
					x2 -= h;
				}
				if (query(x1, y1 + h, x2, y2) > 0) {
					y1 += h;
				}
				if (query(x1, y1, x2, y2 - h) > 0) {
					y2 -= h;
				}
			}
			this.x1 = x1;
			this.y1 = y1;
			this.x2 = x2;
			this.y2 = y2;
		}

		private void findSeparatingX() {
			int l = 0;
			int r = n;
			while (r - l > 1) {
				int m = (l + r) / 2;
				if (query(0, 0, m, n) == 0) {
					l = m;
				} else {
					r = m;
				}
			}
			sepX = -1;
			if (query(0, 0, r, n) == 1 && query(r, 0, n, n) == 1) {
				sepX = r;
			}
		}

		private void findSeparatingY() {
			int l = 0;
			int r = n;
			while (r - l > 1) {
				int m = (l + r) / 2;
				if (query(0, 0, n, m) == 0) {
					l = m;
				} else {
					r = m;
				}
			}
			sepY = -1;
			if (query(0, 0, n, r) == 1 && query(0, r, n, n) == 1) {
				sepY = r;
			}
		}

		int query(int x1, int y1, int x2, int y2) {
			if (x1 >= x2 || y1 >= y2) {
				return 0;
			}
			++x1;
			++y1;
			out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);
			out.flush();
			return in.nextInt();
		}

	}

	static class FastScanner {
		private BufferedReader in;
		private StringTokenizer st;

		public FastScanner(InputStream stream) {
			in = new BufferedReader(new InputStreamReader(stream));
		}

		public String next() {
			while (st == null || !st.hasMoreTokens()) {
				try {
					String rl = in.readLine();
					if (rl == null) {
						return null;
					}
					st = new StringTokenizer(rl);
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return st.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

	}
}

",2,1
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.PrintStream;
import java.util.StringTokenizer;
import java.util.Scanner;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Wolfgang Beyer
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        int found = 0;
        int queryCount = 0;
        int[] result = new int[8];

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            //int n = 100;
            //int n = 65536;


            int left = 1;
            int right = n + 1;
            while (left + 1 < right) {
                int middle = (left + right) / 2;
                int res = query(middle, 1, n, n);
                if (res == 2) left = middle;
                else if (res == 1) {
                    //System.out.println(""Searching single: "");
                    findSingle(middle, 1, n, n);
                    found++;
                    break;
                } else {
                    right = middle;
                }
            }

            int top = 1;
            int bottom = n + 1;
            while (top + 1 < bottom) {
                int middle = (top + bottom) / 2;
                int res = query(1, middle, n, n);
                if (res == 2) top = middle;
                else if (res == 1) {
                    if ((found == 0) || (!containsRect(1, middle, n, n, result[0], result[1], result[2], result[3]))) {
                        //System.out.println(""Searching single: "");
                        findSingle(1, middle, n, n);
                        found++;
                    }
                    break;
                } else {
                    bottom = middle;
                }
            }

            if (found < 2) {
                //System.out.println(""Dia 3: "");
                left = 0;
                right = n;
                while (left + 1 < right) {
                    int middle = (left + right) / 2;
                    int res = query(1, 1, middle, n);
                    if (res == 2) right = middle;
                    else if (res == 1) {
                        if ((found == 0) || (!containsRect(1, 1, middle, n, result[0], result[1], result[2], result[3]))) {
                            //System.out.println(""Searching single: "");
                            findSingle(1, 1, middle, n);
                            found++;
                        }
                        break;
                    } else {
                        left = middle;
                    }
                }
            }

            if (found < 2) {
                //System.out.println(""Dia 4:"");
                top = 0;
                bottom = n;
                while (top + 1 < bottom) {
                    int middle = (top + bottom) / 2;
                    int res = query(1, 1, n, middle);
                    if (res == 2) bottom = middle;
                    else if (res == 1) {
                        if ((found == 0) || (!containsRect(1, 1, n, middle, result[0], result[1], result[2], result[3]))) {
                            //System.out.println(""Searching single: "");
                            findSingle(1, 1, n, middle);
                            found++;
                        }
                        break;
                    } else {
                        top = middle;
                    }
                }
            }

            System.out.print(""! "");
            for (int i = 0; i < 8; i++) System.out.print(result[i] + "" "");
            //System.out.println(""\n"" + queryCount + "" queries used"");
        }

        public boolean containsRect(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {
            if ((x1 <= x3) && (y1 <= y3) && (x2 >= x4) && (y2 >= y4)) return true;
            return false;
        }

        public void findSingle(int x1, int y1, int x2, int y2) {
            x1 = findTopX(x1, y1, x2, y2);
            y1 = findTopY(x1, y1, x2, y2);
            x2 = findBottomX(x1, y1, x2, y2);
            y2 = findBottomY(x1, y1, x2, y2);
            //System.out.println(""x1: "" + x1 + "", y1: "" + y1 + "", x2: "" + x2 + "", y2: "" + y2);
            result[0 + 4 * found] = x1;
            result[1 + 4 * found] = y1;
            result[2 + 4 * found] = x2;
            result[3 + 4 * found] = y2;
        }

        public int findTopX(int x1, int y1, int x2, int y2) {
            int left = x1;
            int right = x2;
            while (left + 1 < right) {
                int mid = (left + right) / 2;
                if (query(mid, y1, x2, y2) == 1) {
                    left = mid;
                } else {
                    right = mid;
                }
            }
            while (query(right, y1, x2, y2) == 0) right--;
            return right;
        }

        public int findTopY(int x1, int y1, int x2, int y2) {
            int left = y1;
            int right = y2;
            while (left + 1 < right) {
                int mid = (left + right) / 2;
                if (query(x1, mid, x2, y2) == 1) {
                    left = mid;
                } else {
                    right = mid;
                }
            }
            while (query(x1, right, x2, y2) == 0) right--;
            return right;
        }

        public int findBottomX(int x1, int y1, int x2, int y2) {
            int left = x1;
            int right = x2;
            while (left + 1 < right) {
                int mid = (left + right) / 2;
                if (query(x1, y1, mid, y2) == 1) {
                    right = mid;
                } else {
                    left = mid;
                }
            }
            while (query(x1, y1, left, y2) == 0) left++;
            return left;
        }

        public int findBottomY(int x1, int y1, int x2, int y2) {
            int left = y1;
            int right = y2;
            while (left + 1 < right) {
                int mid = (left + right) / 2;
                if (query(x1, y1, x2, mid) == 1) {
                    right = mid;
                } else {
                    left = mid;
                }
            }
            while (query(x1, y1, x2, left) == 0) left++;
            return left;
        }

        public int query(int x1, int y1, int x2, int y2) {
            queryCount++;

            System.out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);
            System.out.flush();
            Scanner sc = new Scanner(System.in);
            return sc.nextInt();


        /*int ret = 0;
        //if(x1 <= 17 && 57 <= x2 && y1 <= 80 && 80 <= y2) ++ret;
	    //if(x1 <= 25 && 88 <= x2 && y1 <= 51 && 61 <= y2) ++ret;
        if(x1 <= 10 && 10 <= x2 && y1 <= 11 && 11 <= y2) ++ret;
        //if(x1 <= 11 && 11 <= x2 && y1 <= 10 && 10 <= y2) ++ret;
        if(x1 <= 10 && 10 <= x2 && y1 <= 15 && 15 <= y2) ++ret;
        //System.out.println(x1 + "", "" + y1 + "", "" + x2 + "", "" + y2 + "": "" + ret);
	    return ret;*/
        }

    }

    static class InputReader {
        private static BufferedReader in;
        private static StringTokenizer tok;

        public InputReader(InputStream in) {
            this.in = new BufferedReader(new InputStreamReader(in));
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public String next() {
            try {
                while (tok == null || !tok.hasMoreTokens()) {
                    tok = new StringTokenizer(in.readLine());
                }
            } catch (IOException ex) {
                System.err.println(""An IOException was caught :"" + ex.getMessage());
            }
            return tok.nextToken();
        }

    }
}

",2,1
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class Main {
	public static void main(String[] args) throws Exception {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);

		Task task = new Task();
		task.solve(in, out);
		out.close();

	}
	
	static class Rectangle {
		int x1, y1;
		int x2, y2;
	}
	
	static class Task {
		/**
		 * BEFORE SUBMITTING!!!
		 * MAKE SURE IT IS RIGHT!!!!!
		 * LONG!!
		 * Check if m,n aren't misused
		 * Make sure the output format is right (YES/NO vs Yes/No, newlines vs spaces)
		 * Run with n = 1 or n = 0
		 * Make sure two ints aren't multiplied to get a long

		 *
		 */
		public void solve(InputReader in, PrintWriter out) {
			int n = in.nextInt();
			
			//ideas: procurar linha que os divide e procurar dentro desses sub-retangulos
			// procurar atÃ© ser 1
			
			//corner cases: se procurar atÃ© ser 1 e nÃ£o verificar se tem 1 do outro lado posso chegar a 1,2...not good
			// tenho que procurar 1,1
			
			int l = 1;
			int r = n;
			
			int ans = 0;
			
			
			while(r >= l) {
				int mid = (r + l) / 2;
				if(ask(in,out,1,1,mid, n) == 0) {
					l = mid + 1;
				} else {
					ans = mid;
					r = mid - 1;
				}
			}
			//par 1,1
			//FDS ISTO
			if(ans < n && ask(in,out,ans + 1, 1,n,n) == 1) {
				Rectangle r1 = find(in,out,1,1,ans,n,n);
				Rectangle r2 = find(in,out,ans + 1,1,n,n,n);
				System.out.printf(""! %d %d %d %d %d %d %d %d\n"", r1.x1, r1.y1, r1.x2, r1.y2, r2.x1, r2.y1, r2.x2, r2.y2);
			} else {
				l = 1;
				r = n;
				
				ans = 0;
				
				
				while(r >= l) {
					int mid = (r + l) / 2;
					if(ask(in,out,1,1,n, mid) == 0) {
						l = mid + 1;
					} else {
						ans = mid;
						r = mid - 1;
					}
				}
				
				Rectangle r1 = find(in,out,1,1,n,ans,n);
				Rectangle r2 = find(in,out,1,ans + 1,n,n,n);
				System.out.printf(""! %d %d %d %d %d %d %d %d\n"", r1.x1, r1.y1, r1.x2, r1.y2, r2.x1, r2.y1, r2.x2, r2.y2);
				
			}
			
			
		}
		//HASDFDSJGHDFJKSGDFJSGJDFSGJDSFGJF
		//FKING WORK
		public Rectangle find(InputReader in, PrintWriter out,int x1, int y1, int x2, int y2, int n) {
			Rectangle rec = new Rectangle();
			
			int ansx1 = x1;
			int ansx2 = x2;
			int ansy1 = y1;
			int ansy2 = y2;

			int l = x1;
			int r = x2;
			

			// quero o minimo v >= x2 
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,y1,mid,y2) == 1) {
					ansx2 = mid;
					r = mid - 1;
				} else {
					l = mid + 1;
				}

			}
									
			//out.printf(""x2 = %d"", ansx2);
			
			

			r = x2;
			l = x1;
			
			// quero o maximo v <= x1
			
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,mid,y1,x2,y2) == 1) {
					ansx1 = mid;
					l = mid + 1;
				} else {
					r = mid - 1;
				}

			}
									
			//out.printf(""x1 = %d"", ansx1);
			
			
			l = y1;
			r = y2;
			
			// quero o minimo v >= y2 
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,y1,x2,mid) == 1) {
					ansy2 = mid;
					r = mid - 1;
				} else {
					l = mid + 1;
				}

			}
									
			//out.printf(""y2 = %d"", ansy2);
			

			
			

			r = y2;
			l = y1;
			

			// quero o maximo v <= y1
			
			while(r >= l) {
				int mid = (r + l) / 2;
				
				if(ask(in,out,x1,mid,x2,y2) == 1) {
					ansy1 = mid;
					l = mid + 1;
				} else {
					r = mid - 1;
				}

			}
									
			//out.printf(""y1 = %d"", ansy1);
			


			
			rec.x1 = ansx1;
			rec.x2 = ansx2;
			rec.y1 = ansy1;
			rec.y2 = ansy2;

			
			
			return rec;
		}
		
		public int ask(InputReader in, PrintWriter out, int x1, int y1, int x2, int y2) {
			System.out.printf(""? %d %d %d %d\n"",x1,y1,x2,y2);
			System.out.flush();
			return in.nextInt();
		}
	}

	static class InputReader {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public InputReader(InputStream stream) {
			reader = new BufferedReader(new InputStreamReader(stream), 32768);
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}
		
		public long nextLong() {
            return Long.parseLong(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

        public String nextLine() {
            try {
                return reader.readLine();
               
            } catch (IOException e) {
            }
            return null;
        }


	}
}

",2,1
"import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class C {

	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);

		int n = sc.nextInt();
		int r = sc.nextInt();
		
		double ans[] = new double[n];
		
		int[] x = new int[n];
		
		for (int i = 0; i < n; i++) {
			x[i] = sc.nextInt();
		}
		
		for (int i = 0; i < n; i++) {
			ans[i] = r;
			for (int j = 0; j < i; j++) {
				int d = Math.abs(x[i] - x[j]);
				if(d <= 2 * r) {
					ans[i] = Math.max(ans[i], ans[j] + Math.sqrt(4 * r * r - d * d));
				}
			}
			
			out.print(ans[i] + "" "");
		}
		out.println();
		
		out.flush();
		out.close();
	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}

		public Scanner(String file) throws FileNotFoundException {
			br = new BufferedReader(new FileReader(file));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public double nextDouble() throws IOException {
			String x = next();
			StringBuilder sb = new StringBuilder(""0"");
			double res = 0, f = 1;
			boolean dec = false, neg = false;
			int start = 0;
			if (x.charAt(0) == '-') {
				neg = true;
				start++;
			}
			for (int i = start; i < x.length(); i++)
				if (x.charAt(i) == '.') {
					res = Long.parseLong(sb.toString());
					sb = new StringBuilder(""0"");
					dec = true;
				} else {
					sb.append(x.charAt(i));
					if (dec)
						f *= 10;
				}
			res += Long.parseLong(sb.toString()) / f;
			return res * (neg ? -1 : 1);
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

	}
}",5,5
"//package info.stochastic;

import java.io.*;
import java.util.*;

public class C {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            int r = in.nextInt();

            int x[] = new int[n];
            for (int i = 0; i < n; i++) {
                x[i] = in.nextInt();
            }

            double ans[] = new double[n];
            ans[0] = r;
            int index = 1;

            for (int i = 1; i < n; i++) {
                double maxY = r;
                for (int j = 0; j < index; j++) {
                    int xDist = Math.abs(x[i] - x[j]);
                    if (xDist <= r * 2) {
                        double cur = Math.sqrt((r * 2)*(r * 2) - xDist * xDist) + ans[j];
                        //out.println(cur);
                        maxY = Math.max(maxY, cur);
                    }
                }
                //out.println();
                ans[i] = maxY;
                index++;
            }

            for (int i = 0; i < n; i++) {
                out.print(ans[i] + "" "");
            }

        }
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
    }
}
",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.PrintStream;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Wolfgang Beyer
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            int r = in.nextInt();
            int[] x = in.readIntArray(n);
            double[] y = new double[n];
            for (int i = 0; i < n; i++) {
                y[i] = r;
                for (int j = 0; j < i; j++) {
                    double d = Math.abs(x[j] - x[i]);
                    if (d <= 2 * r) {
                        double yy = Math.sqrt(4.0 * r * r - d * d);
                        y[i] = Math.max(y[i], y[j] + yy);
                    }
                }
            }
            for (int i = 0; i < n; i++) {
                out.print(y[i] + "" "");
            }
        }

    }

    static class InputReader {
        private static BufferedReader in;
        private static StringTokenizer tok;

        public InputReader(InputStream in) {
            this.in = new BufferedReader(new InputStreamReader(in));
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public int[] readIntArray(int n) {
            int[] ar = new int[n];
            for (int i = 0; i < n; i++) {
                ar[i] = nextInt();
            }
            return ar;
        }

        public String next() {
            try {
                while (tok == null || !tok.hasMoreTokens()) {
                    tok = new StringTokenizer(in.readLine());
                    //tok = new StringTokenizer(in.readLine(), "", \t\n\r\f""); //adds commas as delimeter
                }
            } catch (IOException ex) {
                System.err.println(""An IOException was caught :"" + ex.getMessage());
            }
            return tok.nextToken();
        }

    }
}

",5,5
"
import java.util.Scanner;

/**
 *
 * @author msagimbekov
 */
public class Codeforces908C {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int r = sc.nextInt();
        int[] x = new int[n];
        double[] res = new double[n];
        for (int i = 0; i < n; i++) {
            x[i] = sc.nextInt();
            res[i] = (double)r;
            for (int j = i - 1; j >= 0; j--) {
                int diff = x[j] - x[i];
                if (Math.abs(x[j] - x[i]) <= 2 * r) {
                    res[i] = Math.max(res[i], res[j] + Math.sqrt(4 * r * r - diff * diff));
                }
            }
        }
        
        for (int i = 0; i < n; i++) {
            System.out.print(res[i] + "" "");
        }
        System.out.println("""");
    }
}
",5,3
"import java.io.*;
import java.util.*;

public class ProblemA {
	public static void main(String[] args) throws Exception{
			BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
			StringTokenizer st = new StringTokenizer(bf.readLine());
			StringTokenizer st1 = new StringTokenizer(bf.readLine());
			int n = Integer.parseInt(st.nextToken());
			int r = Integer.parseInt(st.nextToken());
			int[] xcoords = new int[n];
			for(int i = 0;i<n;i++){
				xcoords[i] = Integer.parseInt(st1.nextToken());
			}
			double[] ycoords = new double[n];
			
			for(int i = 0;i<n;i++){
				ArrayList<Integer> nodes = new ArrayList<Integer>();
				for(int j = 0;j<i;j++){
					if (Math.abs(xcoords[j] - xcoords[i]+0.0) <= 2*r)
						nodes.add(j);
				}
				if (nodes.isEmpty()){
					ycoords[i] = r;
					continue;
				}
				else{
					double min = -1;
					for(int k = 0;k<nodes.size();k++){
						double tmp = ycoords[nodes.get(k)] + Math.sqrt(4*r*r - (xcoords[i] - xcoords[nodes.get(k)])*(xcoords[i] - xcoords[nodes.get(k)]));
						if (tmp > min){
							min = tmp;
						}
					}
					ycoords[i] = min;
				}
			}
			for(int i = 0;i<ycoords.length;i++){
				System.out.print(ycoords[i] + "" "");
			}
			
	}
}",5,6
"
import java.util.*;

public class Main {
    public static void main(String[] args) {
    	Scanner in=new Scanner(System.in);  
    	int n=in.nextInt(),r=in.nextInt();
    	double[] x=new double[n];
    	for(int i=0; i<n; i++)
    		x[i]=in.nextInt();
    	double[] y=new double[n];
    	for(int i=0; i<n; i++)
    	{
    		y[i]=r;
    		for(int j=0; j<i; j++)
    		{
    			
    			if(Math.abs(x[j]-x[i])<=2*r)
    			{
    				y[i]=Math.max(y[i], y[j]+Math.sqrt(4*r*r-(x[i]-x[j])*(x[i]-x[j])));
    			}
    		}
    	}
    	for(int i=0; i<n; i++)
    		System.out.print(y[i]+"" "");
    }    
}",5,5
"/*
 * code together
 * code better
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.HashMap;
import java.util.Scanner;

public class Main {
	
	
	static int x[]=new int[1005];
	static double ans[]=new double[1005];
	static int nn,r;
	public static void main(String[] args) throws IOException {
		StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		Scanner sc=new Scanner(System.in);
		int huiwoqingchun=0;
		nn=sc.nextInt();
		r=sc.nextInt();
		for(int i=1;i<=nn;i++) {
			x[i]=sc.nextInt();
		}
		//HashMap<, V>
		ans[1]=r;
		int lajitimu=0;
		for(int i=2;i<=nn;i++) {
			ans[i]=r;
			for(int j=1;j<i;j++) {
				if(Math.abs(x[j]-x[i])>2*r)
					continue;
				ans[i]=Math.max(ans[i], ans[j]+Math.sqrt(4*r*r-(x[j]-x[i])*(x[j]-x[i])));
			}
		}
		double buzhidaoganma=0;
		for(int c=1;c<=nn;c++)
			System.out.printf(""%.12f "",ans[c]);
	}
}

",5,5
"import java.util.Scanner;

public class C {
  public static void main (String args[]) {
    Scanner in = new Scanner(System.in);
    
    int n = in.nextInt();
    int r = in.nextInt();
    
    double pos[][] = new double[n][2];
    
    for(int i = 0; i < n; i++) {
    	
    	pos[i][0] = in.nextInt();
    	
    	double y = r;
    	
    	for(int j = 0; j < i; j++) {
    		if(Math.abs(pos[i][0] - pos[j][0]) <= 2*r) {
    			
    			double tempy = pos[j][1] + Math.sqrt(Math.pow(2*r, 2) - Math.pow(Math.abs(pos[i][0] - pos[j][0]), 2));
    			
    			if(tempy > y) y = tempy;
    		}
    	}
    	
    	pos[i][1] = y;
    	System.out.print(y + "" "");
    }
  }
}",5,5
"

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


public class Codeforces {
            
    public static void main(String[] args) throws IOException{
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        final double eps = 1e-7;
        String toks[] = in.readLine().split("" "");
        int n = Integer.parseInt(toks[0]);
        double r = Double.parseDouble(toks[1]);
        double x[] = new double[n];
        toks = in.readLine().split("" "");
        for (int i = 0; i < n; i++) {
            x[i] = Double.parseDouble(toks[i]);
        }
        double lo, hi, mid;
        double y[] = new double[n];
        y[0] = r;
        for (int i = 1; i < n; i++) {
            y[i] = r;
            for(int j=0; j<i; j++) {
                lo = y[j]; hi = 2000*2000;
                while( Math.abs(hi-lo) >= eps ) {
                    mid = (hi+lo)/2;
                    if( Math.sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[j]-mid)*(y[j]-mid) ) + eps > 2*r ) {
                        hi = mid;
                    } else {
                        lo = mid;
                    }
                }
                if(Math.sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[j]-lo)*(y[j]-lo) ) < 2*r + eps) {
                    y[i] = Math.max(y[i], lo);
                }
            }
        }
        for (double z : y) {
            System.out.printf(Locale.US, ""%.7f "", z);
        }
    }
}

",5,5
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.*;
import java.util.*;

/**
 *
 * @author kamranmaharov
 */
public class Main {

    
    public static void main(String[] args) throws Exception {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
        
        String[] line = in.readLine().split("" "");
        int n = Integer.parseInt(line[0]);
        int r = Integer.parseInt(line[1]);
        
        line = in.readLine().split("" "");
        int[] x = new int[n+1];
        double[] y = new double[n+1];
        
        for (int i=1; i<=n; ++i) {
            x[i] = Integer.parseInt(line[i-1]);
            double maxy = -1.0;
            for (int j=1; j<i; ++j) {
                double x2 = x[i];
                double x1 = x[j];
                double y1 = y[j];
                
                double a = 1;
                double b = -2 * y1;
                double c = x1 * x1 + x2 * x2 - 2 * x1 * x2 + y1 * y1 - 4.0 * r * r;
                
                double D = b * b - 4 * a * c;
                //System.out.println(i + "" "" + j + "" "" + D);
                if (D >= 0) {
                    double y2 = (-b + Math.sqrt(D)) / (2 * a);
                    maxy = Math.max(maxy, y2);
                }
            }
            if (maxy < 0) {
                maxy = r;
            }
            y[i] = maxy;
            if (i>1) {System.out.print("" "");}
            System.out.printf(""%.13f"", y[i]);
        }
        System.out.println();
    }
}
",5,5
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class C {
	static int n,r,x[];
	static double ans[];
	public static void main(String args[]) throws IOException
	{
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		n = sc.nextInt();
		r = sc.nextInt();
		x = new int[n];
		ans = new double[n];
		for (int i=0;i<n;i++)
			x[i] = sc.nextInt();
		for (int i=0;i<n;i++)
		{
			ans[i] = r;
			for (int j=0;j<i;j++)
			{
				if (Math.abs(x[i]-x[j])>2*r)
					continue;
				int deltaxsq = (x[i]-x[j])*(x[i]-x[j]);
				int deltaysq = 4 * r * r - deltaxsq;
				double deltay = Math.sqrt(deltaysq);
				ans[i] = Math.max(ans[i], ans[j]+deltay);
			}
			pw.print(ans[i]+"" "");
		}
		pw.flush();
		pw.close();
	}
	static class Scanner 
	{
		StringTokenizer st;
		BufferedReader br;
	
		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}
	
		public String next() throws IOException 
		{
			while (st == null || !st.hasMoreTokens()) 
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}
	
		public int nextInt() throws IOException {return Integer.parseInt(next());}
		
		public long nextLong() throws IOException {return Long.parseLong(next());}
	
		public String nextLine() throws IOException {return br.readLine();}
		
		public boolean ready() throws IOException {return br.ready();}
	
	
	}
}
",5,5
"
import java.util.*;
import java.io.*; 
import java.util.*;
import java.io.*; 
public class MM {
	static Scanner scanner=new Scanner(System.in);
	public static void main(String[] args) {
		int n=scanner.nextInt();
		int r=scanner.nextInt();
		int a[]=new int [n];
		for(int i=0;i<n;i++)a[i]=scanner.nextInt();
		double d[]=new double[n];
		for(int i=0;i<n;i++) {
			for(int j=i-1;j>=0;j--) {
				int x=Math.abs(a[i]-a[j]);//è®¡ç®—è·ç¦»
				if(x<=2*r)d[i]=Math.max(d[i], d[j]+Math.sqrt(4*r*r-x*x));
			}
			if(d[i]==0)d[i]=r;
		}
		StringBuilder sb=new StringBuilder();
		for(int i=0;i<n;i++)sb.append(d[i]+"" "");
		System.out.println(sb);
	}
}











",5,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.*;

public class C {

    public static void main(String[] args) {

        MyScanner in = new MyScanner();
        PrintWriter out = new PrintWriter(System.out);
        int n = in.nextInt();
        int r = in.nextInt();

        double[] y = new double[n];
        int[] x = new int[n];

        for(int i=0;i<n;++i){
            x[i] = in.nextInt();
            double bestY = r;
            for(int j=0;j<i;++j){
                if(Math.abs(x[i]-x[j]) <= 2*r){
                    double ny = y[j] + Math.sqrt(4*r*r - (x[i]-x[j])*(x[i]-x[j]));
                    if(ny > bestY){
                        bestY = ny;
                    }
                }
            }
            y[i] = bestY;
        }

        for(int i=0;i<n;++i){
            out.println(y[i]);
        }

        out.close();

    }


    // -----------MyScanner class for faster input----------
    public static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

    }
    // --------------------------------------------------------

}",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputScanner in = new InputScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, InputScanner in, PrintWriter out) {
            int[] arr = in.readIntArr();
            int n = arr[0];
            int r = arr[1];

            int[] x = in.readIntArr();
            for (int i = 0; i < n; i++) {
                x[i] += 999;
            }

            double[] h = new double[n];
            int dsk[] = new int[3000];
            Arrays.fill(dsk, -1);

            for (int i = 0; i < r; i++) {
                dsk[x[0] + i] = 0;
                dsk[x[0] - i - 1] = 0;
            }
            int rs = 4 * r * r;

            h[0] = r;


            for (int i = 1; i < n; i++) {
                double ch = r;
                for (int j = 0; j < r; j++) {

                    if (dsk[x[i] + j] != -1) {
                        int ind = dsk[x[i] + j];
                        int diff = x[ind] - x[i];
                        int diffs = diff * diff;
                        int hs = rs - diffs;
                        ch = Math.max(ch, h[ind] + Math.sqrt(hs));
                    }

                    if (dsk[x[i] - j - 1] != -1) {
                        int ind = dsk[x[i] - j - 1];
                        int diff = x[ind] - x[i];
                        int diffs = diff * diff;
                        int hs = rs - diffs;
                        ch = Math.max(ch, h[ind] + Math.sqrt(hs));
                    }


                }
                if (x[i] + r < 3000) {
                    if (dsk[x[i] + r] != -1) {
                        ch = Math.max(ch, h[dsk[x[i] + r]]);
                    }
                }
                if (x[i] - r - 1 > 0) {
                    if (dsk[x[i] - r - 1] != -1) {
                        ch = Math.max(ch, h[dsk[x[i] - r - 1]]);
                    }
                }
                for (int j = 0; j < r; j++) {
                    dsk[x[i] + j] = i;
                    dsk[x[i] - j - 1] = i;
                }
                h[i] = ch;

            }

            for (int i = 0; i < n; i++) {
                out.print(h[i] + "" "");
            }
            out.println();

        }

    }

    static class InputScanner {
        BufferedReader br;

        public InputScanner(InputStream is) {
            br = new BufferedReader(new InputStreamReader(is));

        }

        String readLine() {
            String line = null;
            try {
                line = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return line;

        }

        public String[] readStringArr() {

            return readLine().split("" "");

        }

        public int[] readIntArr() {
            String[] str = readStringArr();
            int arr[] = new int[str.length];
            for (int i = 0; i < arr.length; i++)
                arr[i] = Integer.parseInt(str[i]);
            return arr;
        }

    }
}

",5,6
"import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;

	static void solve() {
		int n=ir.nextInt();
		int r=ir.nextInt();
		int[] x=ir.nextIntArray(n);
		double[] ret=new double[n];
		for(int i=0;i<n;i++){
			double ma=r;
			for(int j=0;j<i;j++){
				if(Math.abs(x[i]-x[j])<=2*r){
					ma=Math.max(ma,ret[j]+Math.sqrt(4*(double)Math.pow(r, 2)-Math.pow(x[i]-x[j],2)));
				}
			}
			ret[i]=ma;
		}
		for(int i=0;i<n;i++){
			out.print(ret[i]+(i==n-1?""\n"":"" ""));
		}
	}

	public static void main(String[] args) throws Exception {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}
}",5,5
"import java.io.*;
import java.util.StringTokenizer;

public class Main {
    static double [] res;
    static double r;
    static double solve (int xMe, int xHim, int idxHim) {
        if (Math.abs(xMe - xHim) > 2 * r) return r;
        double hisY = res[idxHim];
        double lo = hisY, hi = hisY + 2 * r, best = hi;
        for (int cnt = 0; cnt <= 50; cnt++) {
            double myY = (lo) + ((hi - lo) / 2);
            if (notIntersect(xMe, myY, xHim, hisY)) {
                best = Math.min(best, myY);
                hi = Math.max(lo, myY);
            } else
                lo = Math.min(hi, myY);
        }
        return best;
    }
    static boolean notIntersect (double x1, double y1, double x2, double y2) {
        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) >= 2 * r  * 2 * r;
    }
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        int n = sc.nextInt();
        res = new double[n];
        r = sc.nextInt();
        int[] x = new int[n];
        for (int i = 0; i < n; i++)
            x[i] = sc.nextInt();

        for (int i = 0; i < n; i++) {
            double max = r;
            for (int j = 0; j < i; j++) {
                max = Math.max(max, solve(x[i], x[j], j));
            }
            if (i > 0) out.print("" "");
            res[i] = max;
            out.printf(""%.10f"", max);
        }
        out.println();

        out.flush();
        out.close();
    }
    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

        public Scanner(FileReader s) throws FileNotFoundException {	br = new BufferedReader(s);}

        public String next() throws IOException
        {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {return Integer.parseInt(next());}

        public long nextLong() throws IOException {return Long.parseLong(next());}

        public String nextLine() throws IOException {return br.readLine();}

        public double nextDouble() throws IOException { return Double.parseDouble(next()); }

        public boolean ready() throws IOException {return br.ready();}
    }
}
",5,5
"/*
 * 
 * @Author  Ajudiya_13(Bhargav Girdharbhai Ajudiya)
 * Dhirubhai Ambani Institute of Information And Communication Technology 
 * 
 */


import java.util.*;
import java.io.*;
import java.lang.*;

public class Code3
{
	
	public static void main(String[] args)
	{
		InputReader in = new InputReader(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		
		int n = in.nextInt();
		double r = (double)in.nextInt();
		double [] a = new double[n];
		for(int i=0;i<n;i++)
			a[i] = (double)in.nextInt();
		double[] ans = new double[n];
		ans[0] = r;

		for(int i=1;i<n;i++)
		{
			double max = Double.MIN_VALUE;
			for(int j=0;j<i;j++)
			{
				if(Math.abs(a[i]-a[j])<=2*r)
				{
					//System.out.println(j);
					double cur = 4*r*r;
					cur -= ((a[i]-a[j])*(a[i]-a[j]));
					cur = Math.sqrt(cur);
					cur += ans[j];
					//System.out.println(r);
					max = Math.max(max, cur);
				}
			}
			
			if(max == Double.MIN_VALUE)
				ans[i] = r;
			else 
				ans[i] = max;
		}
		
		for(int i=0;i<n;i++)
			pw.print(ans[i] + "" "");
		pw.flush();
		pw.close();
	}
	
	static class InputReader 
	{
		 
		private final InputStream stream;
		private final byte[] buf = new byte[8192];
		private int curChar, snumChars;
		private SpaceCharFilter filter;
 
		public InputReader(InputStream stream) 
		{
			this.stream = stream;
		}
 
		public int snext() 
		{
			if (snumChars == -1)
				throw new InputMismatchException();
			if (curChar >= snumChars) 
			{
				curChar = 0;
				try 
				{
					snumChars = stream.read(buf);
				} 
				catch (IOException e) 
				{
					throw new InputMismatchException();
				}
				if (snumChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}
 
		public int nextInt() 
	    {
			int c = snext();
			while (isSpaceChar(c)) 
			{
				c = snext();
			}
			int sgn = 1;
			if (c == '-')
		    {
				sgn = -1;
				c = snext();
			}
			int res = 0;
			do 
			{
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = snext();
			} while (!isSpaceChar(c));
			return res * sgn;
		}
 
		public long nextLong()
	    {
			int c = snext();
			while (isSpaceChar(c)) 
			{
				c = snext();
			}
			int sgn = 1;
			if (c == '-') 
			{
				sgn = -1;
				c = snext();
			}
			long res = 0;
			do 
			{
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = snext();
			} while (!isSpaceChar(c));
			return res * sgn;
		}
 
		public int[] nextIntArray(int n) 
		{
			int a[] = new int[n];
			for (int i = 0; i < n; i++) 
			{
				a[i] = nextInt();
			}
			return a;
		}
 
		public String readString()
	    {
			int c = snext();
			while (isSpaceChar(c)) 
			{
				c = snext();
			}
			StringBuilder res = new StringBuilder();
			do 
			{
				res.appendCodePoint(c);
				c = snext();
			} while (!isSpaceChar(c));
			return res.toString();
		}
 
		public String nextLine() 
		{
			int c = snext();
			while (isSpaceChar(c))
				c = snext();
			StringBuilder res = new StringBuilder();
			do 
			{
				res.appendCodePoint(c);
				c = snext();
			} while (!isEndOfLine(c));
			return res.toString();
		}
 
		public boolean isSpaceChar(int c) 
		{
			if (filter != null)
				return filter.isSpaceChar(c);
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}
 
		private boolean isEndOfLine(int c) 
		{
			return c == '\n' || c == '\r' || c == -1;
		}
 
		public interface SpaceCharFilter
	    {
			public boolean isSpaceChar(int ch);
		}
	}
	
	public static long mod = 1000000007;
	public static int d;
	public static int p;
	public static int q;
	
	public static int[] suffle(int[] a,Random gen)
	{
		int n = a.length;
		for(int i=0;i<n;i++)
		{
			int ind = gen.nextInt(n-i)+i;
			int temp = a[ind];
			a[ind] = a[i];
			a[i] = temp;
		}
		return a;
	}
	
	public static void swap(int a, int b){
		int temp = a;
		a = b;
		b = temp;
	}
	
	public static HashSet<Integer> primeFactorization(int n)
	{
		HashSet<Integer> a =new HashSet<Integer>();
		for(int i=2;i*i<=n;i++)
		{
			while(n%i==0)
			{
				a.add(i);
				n/=i;
			}
		}
		if(n!=1)
			a.add(n);
		return a;
	}
	
	public static void sieve(boolean[] isPrime,int n)
	{
		for(int i=1;i<n;i++)
			isPrime[i] = true;
		
		isPrime[0] = false;
		isPrime[1] = false;
		
		for(int i=2;i*i<n;i++)
		{
			if(isPrime[i] == true)
			{
				for(int j=(2*i);j<n;j+=i)
					isPrime[j] = false;
			}
		}
	}
	
	public static int GCD(int a,int b)
	{
		if(b==0)
			return a;
		else
			return GCD(b,a%b);
	}
	
	public static long GCD(long a,long b)
	{
		if(b==0)
			return a;
		else
			return GCD(b,a%b);
	}
	
	public static void extendedEuclid(int A,int B)
	{
		if(B==0)
		{
			d = A;
			p = 1 ;
			q = 0;
		}
		else
		{
			extendedEuclid(B, A%B);
			int temp = p;
			p = q;
			q = temp - (A/B)*q;
		}
	}
	
	public static long LCM(long a,long b)
	{
		return (a*b)/GCD(a,b);
	}
	
	public static int LCM(int a,int b)
	{
		return (a*b)/GCD(a,b);
	}
	
	public static int binaryExponentiation(int x,int n)
	{
	    int result=1;
	    while(n>0)
	    {
	        if(n % 2 ==1)
	            result=result * x;
	        x=x*x;
	        n=n/2;
	    }
	    return result;
	}
	
	public static long binaryExponentiation(long x,long n)
	{
	    long result=1;
	    while(n>0)
	    {
	        if(n % 2 ==1)
	            result=result * x;
	        x=x*x;
	        n=n/2;
	    }
	    return result;
	}
	
	public static int modularExponentiation(int x,int n,int M)
	{
	    int result=1;
	    while(n>0)
	    {
	        if(n % 2 ==1)
	            result=(result * x)%M;
	        x=(x*x)%M;
	        n=n/2;
	    }
	    return result;
	}
	
	public static long modularExponentiation(long x,long n,long M)
	{
	    long result=1;
	    while(n>0)
	    {
	        if(n % 2 ==1)
	            result=(result * x)%M;
	        x=(x*x)%M;
	        n=n/2;
	    }
	    return result;
	}
	
	public static int modInverse(int A,int M)
	{
	    return modularExponentiation(A,M-2,M);
	}
	
	public static long modInverse(long A,long M)
	{
	    return modularExponentiation(A,M-2,M);
	}
	
	public static boolean isPrime(int n)
	{
	    
	    if (n <= 1)  return false;
	    if (n <= 3)  return true;
	    
	    if (n%2 == 0 || n%3 == 0) 
	    	return false;
	 
	    for (int i=5; i*i<=n; i=i+6)
	    {
	        if (n%i == 0 || n%(i+2) == 0)
	           return false;
	    }
	    
	    return true;
	}
	
	static class pair implements Comparable<pair>
	{
		Integer x, y;
		pair(int x,int y)
		{
			this.x=x;
			this.y=y;
		}
		
		public int compareTo(pair o) {
			int result = x.compareTo(o.x);
			if(result==0)
				result = y.compareTo(o.y);
			
			return result;
		}  
		
		public String toString()
		{
			return x+"" ""+y;
		}
		
		public boolean equals(Object o)
		{
			if (o instanceof pair)
		    {
				pair p = (pair)o;
				return p.x == x && p.y == y ;
			}
			return false;
		}
		
		public int hashCode()
		{
			return new Long(x).hashCode()*31 + new Long(y).hashCode();
		}
	}
}",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.readInt();
            int r = in.readInt();
            int[] x = in.readIntArray(n);
            double[] y = new double[n];
            y[0] = r;
            for (int i = 1; i < n; i++) {
                double max = r;
                for (int j = 0; j < i; j++) {
                    double pow = Math.pow(x[i] - x[j], 2);
                    if (pow <= 4 * r * r) {
                        double ty = y[j] + Math.sqrt(4 * r * r - pow);
                        max = Math.max(max, ty);
                    }
                }
                y[i] = max;
            }
            for (double i : y) out.print(i + "" "");

        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1)
                throw new InputMismatchException();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public int[] readIntArray(int size) {
            int[] ans = new int[size];
            for (int i = 0; i < size; i++) ans[i] = readInt();
            return ans;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}

",5,5
"import java.util.*;
import java.io.*;
import java.math.*;
public class Solution{
    public static void main(String[] args) throws Exception {
        int n=nextInt();
        int r=nextInt();
        int x[]=new int[n];
        double y[]=new double[n];
        for(int i=0;i<n;i++)
            x[i]=nextInt();
        for(int i=0;i<n;i++){
            //(x1-x2)2+(y1-y2)2=r2
            y[i]=r;
            for(int j=0;j<i;j++){
                int d=sq(2*r)-sq(x[i]-x[j]);
                if(d>=0){
                    double y1=Math.sqrt(d)+y[j];
                    y[i]=Math.max(y1,y[i]);
                }
            }
        }
        for(int i=0;i<n;i++)
            System.out.printf(""%.12g "",y[i]);
    }
    static int sq(int a){
        return a*a;
    }
    static int nextInt()throws IOException{
        InputStream in=System.in;
        int ans=0;
        boolean flag=true;
        byte b=0;
        while ((b>47 && b<58) || flag){
            if(b>=48 && b<58){
                ans=ans*10+(b-48);
                flag=false;
            }
            b=(byte)in.read();
        }
        return ans;
    }
    static String next()throws Exception{
        StringBuilder sb=new StringBuilder(1<<16);
        InputStream in=System.in;
        byte b=0;
        do{
            if(!isWhiteSpace(b))
                sb.append((char)b);
            b=(byte)in.read();
        }while(!isWhiteSpace(b) || sb.length()==0);
        return sb.toString();
    }
    static boolean isWhiteSpace(byte b){
        char ch=(char)b;
        return ch=='\0' || ch==' ' || ch=='\n';
    }
}",5,5
"
import java.util.*;
import java.io.*;

public class Solution2 {


    private void solve() throws IOException {
        int n = in.nextInt();
        double r = in.nextDouble();
        List<Double> xes = new ArrayList<>(n);
        List<Double> yes = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            xes.add(in.nextDouble());
        }
        for (int i = 0; i < n; i++) {
            double max = r;
            for (int j = 0; j < i; j++) {
                double x = xes.get(j);
                double y = yes.get(j);
                if (xes.get(i) <= x + 2 * r && xes.get(i) >= x - 2 * r) {
                    max = Math.max(max, y + Math.sqrt(4 * r * r - Math.abs(x - xes.get(i))* Math.abs(x - xes.get(i))));
                }
            }
            yes.add(max);
        }
        for (double y : yes) {
            System.out.print(y + "" "");
        }
        System.out.println();
        System.out.flush();
    }

    private static String filename = """";
    private PrintWriter out;
    private MyScanner in;

    private void run() throws IOException {
        in = new MyScanner();
        out = new PrintWriter(System.out);
        solve();
        in.close();
        out.close();
    }

    private class MyScanner {
        private BufferedReader br;
        private StringTokenizer st;

        MyScanner() throws IOException {
            this.br = new BufferedReader(new InputStreamReader(System.in));
        }

        public MyScanner(String fileTitle) throws IOException {
            this.br = new BufferedReader(new FileReader(fileTitle));
        }

        public String nextLine() throws IOException {
            String s = br.readLine();
            return s == null ? ""-1"" : s;
        }

        String next() throws IOException {
            while (st == null || !st.hasMoreTokens()) {
                String s = br.readLine();
                if (s == null) {
                    return ""-1"";
                }
                st = new StringTokenizer(s);
            }
            return st.nextToken();
        }

        public Integer nextInt() throws IOException {
            return Integer.parseInt(this.next());
        }

        public Long nextLong() throws IOException {
            return Long.parseLong(this.next());
        }

        public Double nextDouble() throws IOException {
            return Double.parseDouble(this.next());
        }

        void close() throws IOException {
            this.br.close();
        }
    }

    public static void main(String[] args) throws IOException {
        Locale.setDefault(Locale.US);
        new Solution2().run();
    }
}


",5,5
"import java.util.*;
import java.io.*;

public class ProblemD
{

    static int mod = (int) (1e9+7);
    static InputReader in;
    static PrintWriter out;
    
    static void solve()
    {
        in = new InputReader(System.in);
        out = new PrintWriter(System.out);            
        
        int n = in.nextInt();
        int r = in.nextInt();
        double[] x = new double[n];
        double[] y = new double[n];
        
        for(int i = 0; i < n; i++){
            int xx = in.nextInt();
            x[i] = xx;
            y[i] = r;
            for(int j = 0; j < i; j++){
                double delx = Math.abs(x[i] - x[j]);
                //debug(delx);
                if(delx <= 2 * r){
                    double tmp = 4 * r * r - delx * delx;
                    tmp = Math.sqrt(tmp);
                    tmp = y[j] + tmp;
                    y[i] = Math.max(y[i], tmp);
                }
            }
            out.print(y[i] + "" "");
        }
        
        out.close();
    }
    
    public static void main(String[] args)
    {
        new Thread(null ,new Runnable(){
            public void run(){
                try{
                    solve();
                } catch(Exception e){
                    e.printStackTrace();
                }
            }
        },""1"",1<<26).start();
        
    }

    static class Pair implements Comparable<Pair>
    {

        long x,y;

        Pair (long x,long y)
        {
                this.x = x;
                this.y = y;
        }
        public int compareTo(Pair o)
        {
            return Long.compare(this.x,o.x);
                //return 0;
        }

        public boolean equals(Object o)
        {
            if (o instanceof Pair)
            {
                Pair p = (Pair)o;
                return p.x == x && p.y==y;
            }
            return false;
        }

        @Override
        public String toString()
        {
            return x + "" ""+ y ;
        }

        /*public int hashCode()
        {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }*/

    } 

    static long add(long a,long b){
        long x=(a+b);
        while(x>=mod) x-=mod;
        return x;
    }

    static long sub(long a,long b){
        long x=(a-b);
        while(x<0) x+=mod;
        return x;
    }
    
    static long mul(long a,long b){
        long x=(a*b);
        while(x>=mod) x-=mod;
        return x;
    }
    
    static String rev(String s){
        StringBuilder sb=new StringBuilder(s);
        sb.reverse();
        return sb.toString();
    }
    
    static long gcd(long x,long y)
    {
        if(y==0)
                return x;
        else
                return gcd(y,x%y);
    }

    static int gcd(int x,int y)
    {
        if(y==0)
                return x;
        else 
                return gcd(y,x%y);
    }

    static long pow(long n,long p,long m)
    {
         long  result = 1;
          if(p==0){
            return 1;
          }
          
        while(p!=0)
        {
            if(p%2==1)
                result *= n;
            if(result >= m)
               result %= m;
            p >>=1;
            n*=n;
            if(n >= m)
                n%=m;
        }
        
        return result;
    }

    static long pow(long n,long p)
    {
        long  result = 1;
          if(p==0)
            return 1;

        while(p!=0)
        {
            if(p%2==1)
                result *= n;	    
            p >>=1;
            n*=n;	    
        }
        return result;
    }

    static void debug(Object... o)
    {
            System.out.println(Arrays.deepToString(o));
    }

    static class InputReader
    {

        private final InputStream stream;
        private final byte[] buf = new byte[8192];
        private int curChar, snumChars;
        private SpaceCharFilter filter;

        public InputReader(InputStream stream)
        {
                this.stream = stream;
        }

        public int snext()
        {
                if (snumChars == -1)
                        throw new InputMismatchException();
                if (curChar >= snumChars)
                {
                        curChar = 0;
                        try
                        {
                                snumChars = stream.read(buf);
                        } catch (IOException e)
                        {
                                throw new InputMismatchException();
                        }
                        if (snumChars <= 0)
                                return -1;
                }
                return buf[curChar++];
        }

        public int nextInt()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                int sgn = 1;
                if (c == '-')
                {
                        sgn = -1;
                        c = snext();
                }
                int res = 0;
                do
                {
                        if (c < '0' || c > '9')
                                throw new InputMismatchException();
                        res *= 10;
                        res += c - '0';
                        c = snext();
                } while (!isSpaceChar(c));
                return res * sgn;
        }

        public long nextLong()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                int sgn = 1;
                if (c == '-')
                {
                        sgn = -1;
                        c = snext();
                }
                long res = 0;
                do
                {
                        if (c < '0' || c > '9')
                                throw new InputMismatchException();
                        res *= 10;
                        res += c - '0';
                        c = snext();
                } while (!isSpaceChar(c));
                return res * sgn;
        }

        public int[] nextIntArray(int n)
        {
                int a[] = new int[n];
                for (int i = 0; i < n; i++)
                {
                        a[i] = nextInt();
                }
                return a;
        }

        public long[] nextLongArray(int n)
        {
                long a[] = new long[n];
                for (int i = 0; i < n; i++)
                {
                        a[i] = nextLong();
                }
                return a;
        }

        public String readString()
        {
                int c = snext();
                while (isSpaceChar(c))
                {
                        c = snext();
                }
                StringBuilder res = new StringBuilder();
                do
                {
                        res.appendCodePoint(c);
                        c = snext();
                } while (!isSpaceChar(c));
                return res.toString();
        }

        public String nextLine()
        {
                int c = snext();
                while (isSpaceChar(c))
                        c = snext();
                StringBuilder res = new StringBuilder();
                do
                {
                        res.appendCodePoint(c);
                        c = snext();
                } while (!isEndOfLine(c));
                return res.toString();
        }

        public boolean isSpaceChar(int c)
        {
                if (filter != null)
                        return filter.isSpaceChar(c);
                return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        private boolean isEndOfLine(int c)
        {
                return c == '\n' || c == '\r' || c == -1;
        }

        public interface SpaceCharFilter
        {
                public boolean isSpaceChar(int ch);
        }

    }
}    
",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        C908 solver = new C908();
        solver.solve(1, in, out);
        out.close();
    }

    static class C908 {
        int N;
        int R;
        int[] x;
        double[] ans;

        public void solve(int testNumber, FastScanner s, PrintWriter out) {

            N = s.nextInt();
            R = s.nextInt();
            x = s.nextIntArray(N);

            ans = new double[N];
            Arrays.fill(ans, R);

            for (int i = 0; i < N; i++) {
                // placing circle i
                for (int j = 0; j < i; j++) {
                    // testing collision with placed circles
                    if (Math.abs(x[i] - x[j]) <= 2 * R) {
                        // they will collide
                        // compute the increase in y that will be had
                        double dy = Math.sqrt(Math.pow(2 * R, 2) - Math.pow(x[i] - x[j], 2));
                        ans[i] = Math.max(ans[i], ans[j] + dy);
                    }
                }
            }

            for (double d : ans)
                out.print(d + "" "");
            out.println();

        }

    }

    static class FastScanner {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;

        public FastScanner(InputStream stream) {
            this.stream = stream;
        }

        int read() {
            if (numChars == -1)
                throw new InputMismatchException();
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public String next() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }

        public int[] nextIntArray(int N) {
            int[] ret = new int[N];
            for (int i = 0; i < N; i++)
                ret[i] = this.nextInt();
            return ret;
        }

    }
}

",5,5
"import java.util.*;
import java.io.*;

public class NewYearsCurling {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);

		StringTokenizer st = new StringTokenizer(sc.nextLine());
		int n = Integer.parseInt(st.nextToken());
		int r = Integer.parseInt(st.nextToken());

		ArrayList<Integer> centers = new ArrayList<Integer>();
		st = new StringTokenizer(sc.nextLine());
		for (int i = 0; i < n; i++) {
			centers.add(Integer.parseInt(st.nextToken()));
		}
		sc.close();
		ArrayList<Point> finalpoints = new ArrayList<Point>();
		for (int i = 0; i < n; i++) {
			double maxy = r;
			for (int j = 0; j < finalpoints.size(); j++) {
				if (finalpoints.get(j).x - centers.get(i) > 2 * r || centers.get(i) - finalpoints.get(j).x > 2 * r)
					continue;
				double dist = Math.sqrt(
						4 * r * r - (finalpoints.get(j).x - centers.get(i)) * (finalpoints.get(j).x - centers.get(i)))
						+ finalpoints.get(j).y;
				if(dist > maxy)
					maxy = dist;
			}
			
			pw.print(maxy + "" "");
			finalpoints.add(new Point(centers.get(i), maxy));
		}
		
		pw.close();
	}

	public static class Point {
		double x;
		double y;

		public Point(double x, double y) {
			this.x = x;
			this.y = y;
		}
	}
}
",5,5
"import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.TreeMap;

import static java.lang.Math.abs;
import static java.lang.Math.max;
import static java.lang.Math.min;
import static java.lang.Math.sqrt;
import static java.util.Arrays.copyOf;
import static java.util.Arrays.fill;
import static java.util.Arrays.sort;
import static java.util.Collections.reverse;
import static java.util.Collections.reverseOrder;
import static java.util.Collections.sort;

public class Main {
    private FastScanner in;
    private PrintWriter out;

    private void solve() throws IOException {
        solveC();
    }

    private void solveA() throws IOException {
        HashSet<Character> set = new HashSet<>();
        for (char c : new char[]{'a', 'e', 'i', 'o', 'u', '1', '3', '5', '7', '9'})
            set.add(c);
        int cnt = 0;
        for (char c : in.nextLine().toCharArray())
            if (set.contains(c))
                cnt++;
        out.println(cnt);
    }

    int n, m, cl;
    char a[][];
    int[] b;
    int fromi, fromj, toi, toj;

    private void solveB() throws IOException {
        n = in.nextInt();
        m = in.nextInt();
        char[] c;
        a = new char[n][m];
        for (int i = 0; i < n; i++) {
            a[i] = in.next().toCharArray();
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (a[i][j] == 'S') {
                    fromi = i;
                    fromj = j;
                }
                if (a[i][j] == 'E') {
                    toi = i;
                    toj = j;
                }
            }
        }

        c = in.next().toCharArray();
        cl = c.length;
        b = new int[cl];
        for (int i = 0; i < cl; i++) {
            b[i] = c[i] - '0';
        }

        ArrayList<Long> ar1 = new ArrayList<>(), ar2 = new ArrayList<>(), ar3 = new ArrayList<>(), ar4 = new ArrayList<>();
        ar1.add((long) 12);
        ar1.add((long) 10);
        ar1.add((long) 01);
        ar1.add((long) 21);
        long[] str = new long[4];
        int ans = 0;
        for (long i : ar1) {
            str[0] = i;
            ar2.clear();
            ar2.addAll(ar1);
            ar2.remove(i);

            for (long j : ar2) {
                str[1] = j;
                ar3.clear();
                ar3.addAll(ar2);
                ar3.remove(j);

                for (long k : ar3) {
                    str[2] = k;
                    ar4.clear();
                    ar4.addAll(ar3);
                    ar4.remove(k);

                    str[3] = ar4.get(0);
                    if (bfs(str))
                        ans++;
                }
            }
        }
        out.println(ans);
    }

    private boolean bfs(long[] str) {
        int[][] steps = {{(int) str[0] / 10 - 1, (int) str[0] % 10 - 1},
                {(int) str[1] / 10 - 1, (int) str[1] % 10 - 1},
                {(int) str[2] / 10 - 1, (int) str[2] % 10 - 1},
                {(int) str[3] / 10 - 1, (int) str[3] % 10 - 1}};

        for (int i = 0, ci = fromi, cj = fromj; i < cl; i++) {
            ci += steps[b[i]][0];
            cj += steps[b[i]][1];

            if (ci >= n || ci < 0 || cj >= m || cj < 0 || a[ci][cj] == '#')
                return false;

            if (a[ci][cj] == 'E')
                return true;
        }

        return false;
    }

    private void solveC() throws IOException {
        int n = in.nextInt();
        int r = in.nextInt();
        int[] x = new int[n];
        for (int i = 0; i < n; i++) {
            x[i] = in.nextInt();
        }

        double[] y = new double[n];
        for (int i = 0; i < n; i++) {
            y[i] = r;
            for (int j = 0; j < i; j++) {
                if (abs(x[i] - x[j]) <= 2 * r) {
                    y[i] = max(y[i], y[j] + sqrt(4.0 * r * r - (x[i] - x[j]) * (x[i] - x[j])));
                }
            }
        }

        for (double ty : y)
            out.print(ty + "" "");
        out.println();

    }

    private void solveD() throws IOException {

    }

    private void solveE() throws IOException {

    }

    private void solveF() throws IOException {

    }

    class FastScanner {
        StringTokenizer st;
        BufferedReader br;

        FastScanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        boolean hasNext() throws IOException {
            return br.ready() || (st != null && st.hasMoreTokens());
        }

        int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        String nextLine() throws IOException {
            return br.readLine();
        }

        boolean hasNextLine() throws IOException {
            return br.ready();
        }
    }

    private void run() throws IOException {
        in = new FastScanner(System.in); // new FastScanner(new FileInputStream("".in""));
        out = new PrintWriter(System.out); // new PrintWriter(new FileOutputStream("".out""));

        solve();

        out.flush();
        out.close();
    }

    public static void main(String[] args) throws IOException {
        new Main().run();
    }
}
",5,5
"import java.math.BigInteger;
import java.util.Scanner;

public class c {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		
		int num = in.nextInt();
		int rad = in.nextInt();
		
		int[] start = new int[num];
		for(int i=0; i<num; i++)
			start[i] = in.nextInt();
		
		// If you can hack doubles that's dumb
		double[] finalY = new double[num];
		double hyp = rad*2;
		
		for(int cur=0; cur<num; cur++){
			
			double stopAt = rad;
			for(int comp=0; comp<cur; comp++){
				if(Math.abs(start[comp]-start[cur]) > rad*2) continue;
				
				double base = Math.abs(start[comp]-start[cur]);
				double ny = Math.sqrt(hyp*hyp - base*base) + finalY[comp];
				
				stopAt = Math.max(ny, stopAt);
			}
			
			finalY[cur] = stopAt;
		}
		
		for(int i=0; i<num; i++)
			System.out.print(finalY[i]+"" "");
		System.out.println();
	}

}
",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;
/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.readInt();
            int r = in.readInt();
            int[] x = IOUtils.readIntArray(in, n);
            double[] y = new double[n];
            for (int idx = 0; idx < x.length; idx++) {
                double yRes = r;
                for (int prev = 0; prev < idx; prev++) {
                    int xDelta = Math.abs(x[idx] - x[prev]);
                    if (xDelta <= 2 * r) {
                        // then we intersect with prev
                        double yDelta = calcDelta(xDelta, r);
                        yRes = Math.max(yRes, y[prev] + yDelta);
                    }
                }
                y[idx] = yRes;
            }
            out.printLine(y);
        }

        private double calcDelta(int xDelta, int r) {
            return Math.sqrt(4 * r * r - xDelta * xDelta);
        }
    }
    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(double[] array) {
            for (int i = 0; i < array.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(array[i]);
            }
        }

        public void printLine(double[] array) {
            print(array);
            writer.println();
        }

        public void close() {
            writer.close();
        }
    }
    static class IOUtils {
        public static int[] readIntArray(InputReader in, int size) {
            int[] array = new int[size];
            for (int i = 0; i < size; i++) {
                array[i] = in.readInt();
            }
            return array;
        }
    }
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
}

",5,5
"import java.io.*;
import java.util.*;
public class Main {
    public static void main(String[] args) {
        FastScanner sc=new FastScanner();
        PrintWriter pw=new PrintWriter(System.out);
        double eps=1e-12;
        while(sc.hasNext()){
            int n=sc.nextInt();
            int r=sc.nextInt();
            double[]shu=new double[n];
            for(int i=0;i<n;i++)shu[i]=sc.nextDouble();
            double[]res=new double[n];
            for(int i=0;i<n;i++){
                for(int j=0;j<i;j++){
                    double temp=Math.abs(shu[i]-shu[j]);
                    if(temp<2*r||Math.abs(temp-2*r)<eps){
                        res[i]=Math.max(res[i],res[j]+Math.sqrt(4*r*r-temp*temp));
                    }
                }
                res[i]=Math.max(res[i],r);
            }
            for(int i=0;i<n;i++){
                pw.print(res[i]+"" "");
            }
            pw.flush();
        }
    }
}
class FastScanner{
    BufferedReader br;
    StringTokenizer st;
    FastScanner(){
        br=new BufferedReader(new InputStreamReader(System.in));
        st=new StringTokenizer("""");
    }

    String nextLine(){
        String s="""";
        try {
            s=br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return s;
    }
    boolean hasNext(){
        String s="""";
        while(!st.hasMoreTokens()){
            s=nextLine();
            if(s==null)return false;
            st=new StringTokenizer(s);
        }
        return true;
    }
    String next(){
        String s="""";
        while(!st.hasMoreTokens()){
            s=nextLine();
            st=new StringTokenizer(s);
        }
        return st.nextToken();
    }
    int nextInt(){
        return Integer.valueOf(next());
    }
    long nextLong(){
        return Long.valueOf(next());
    }
    double nextDouble(){
        return Double.valueOf(next());
    }
}

",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            int n = in.nextInt();
            int r = in.nextInt();
            int[] xs = new int[n];
            for (int i = 0; i < n; i++) xs[i] = in.nextInt();
            double[] ys = new double[n];
            for (int i = 0; i < n; i++) {
                int x = xs[i];
                double y = r;
                for (int j = 0; j < i; j++) {
                    y = Math.max(y, calc(xs[j], ys[j], x, r));
                }
                ys[i] = y;
            }
            for (int i = 0; i < n; i++) {
                out.printf(""%.10f "", ys[i]);
            }
            out.println();
        }

        private double calc(int x, double y, int x1, int r) {
            int dx = Math.abs(x - x1);
            if (dx > 2 * r) return 0;
            double dy = Math.sqrt(4 * r * r - dx * dx);
            return y + dy;
        }

    }

    static class Scanner {
        BufferedReader br;
        StringTokenizer st;

        public Scanner(InputStream in) {
            br = new BufferedReader(new InputStreamReader(in), 32768);
        }

        public String nextLine() {
            try {
                return br.readLine();
            } catch (IOException e) {
                return null;
            }
        }

        public boolean hasNext() {
            while (st == null || !st.hasMoreTokens()) {
                String s = nextLine();
                if (s == null)
                    return false;
                st = new StringTokenizer(s);
            }
            return true;
        }

        public String next() {
            hasNext();
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}

",5,5
"import java.io.*;
import java.util.HashSet;
import java.util.StringTokenizer;


public class GB_A {
    FastScanner in;
    PrintWriter out;

    public static void main(String[] arg) {
        new GB_A().run();
    }

    public void solve() throws IOException {
        int n = in.nextInt();
        int r = in.nextInt();
        int[] a = new int[n];
        double[] ans = new double[n];
        a[0] = in.nextInt();
        ans[0] = r;
        for (int i = 1; i < n; i++) {
            a[i] = in.nextInt();
            double max = r;
            for (int j = i - 1; j >= 0; j--) {
                if (Math.abs(a[i] - a[j]) <= 2 * r) {
                    double d = Math.sqrt(4 * r * r - (a[i]- a[j]) * (a[i] - a[j])) + ans[j];
                    max = Math.max(max, d);
                }

            }
            ans[i] = max;
        }
        for (int i = 0; i < n; i++) {
            out.println(ans[i]);
        }
    }


    public void run() {
        try {
            in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));
            out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

            solve();

            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        FastScanner(BufferedReader bufferedReader) {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }



    }
}
",5,3
"
import java.io.*;
import java.util.*;

public class C {

	public static void main(String[] args) throws IOException {
		FastScanner in = new FastScanner(System.in);
		PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

		int n = in.nextInt();
		double r = in.nextInt();
		double[] x = new double[n+1];
		double[] y = new double[n+1];
		for (int i = 1; i <= n; i++) {
			x[i] = in.nextInt();
		}
		
		int[] lastx = new int[1001];
		for (int i = 1; i <= n; i++) {
			double s = x[i] - r, e = x[i] + r;
			for (int j = (int)Math.max(0, s); j <= (int)Math.min(1000, e); j++) {
				if (lastx[j] == 0) {
					y[i] = Math.max(y[i], findY(x[i], x[i], 0 - r, 2 * r));
				}
				else {
					y[i] = Math.max(y[i], findY(x[lastx[j]], x[i], y[lastx[j]], 2 * r));
				}
				lastx[j] = i;
			}
		}
		
		for (int i = 1; i <= n; i++) {
			out.println(y[i]);
		}
		out.close();
	}
	
	public static double findY(double x1, double x2, double y1, double d) {
		return Math.max(y1 + Math.sqrt(-1 * Math.pow(x1, 2) + 2 * x1 * x2 + Math.pow(d, 2) - Math.pow(x2, 2)),
				y1 - Math.sqrt(-1 * Math.pow(x1, 2) + 2 * x1 * x2 + Math.pow(d, 2) - Math.pow(x2, 2)));
	}

	static class FastScanner {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public FastScanner(InputStream stream) {
			this.stream = stream;
		}

		int read() {
			if (numChars == -1)
				throw new InputMismatchException();
			if (curChar >= numChars) {
				curChar = 0;
				try {
					numChars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (numChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public String next() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public String nextLine() {
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}
	}

}
",5,3
"/**
 * Created by Ariana Herbst on 12/29/17.
 */

import java.util.*;
import java.io.*;

/**
 * Created by Ariana Herbst on 12/29/17
 */
public class GB2017C {
    static int n, r;
    static int[] x;
    static Map<Integer, Double> horo;
    public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        StringBuilder sb = new StringBuilder();
        n = sc.nextInt();
        r = sc.nextInt();
        x = new int[n];
        horo = new HashMap<Integer, Double>();
        for (int x = 0; x <= r*2; x++) {
            double y = 2.0 *Math.sqrt(r * r - (r - x/2.0) * (r - x/2.0));
            horo.put(x, y);
        }
        for (int i = 0; i < n; i++) {
            x[i] = sc.nextInt();
        }
        List<Double> y = new ArrayList<Double>();
        for (int i = 0; i < n; i++) {
            double max = r;
            for (int j = 0; j < y.size(); j++) {
                int dx = intersects(i, j);
                if (dx >= 0) {
                    double dy = horo.get(dx);
                    max = Math.max(max, dy + y.get(j));
                }
            }
            y.add(max);
        }
        for (int i = 0; i < n; i++) {
            sb.append(y.get(i) + "" "");
        }
        System.out.println(sb);
    }

    static int intersects(int i, int j) {
        if (Math.abs(x[i] - x[j]) <= 2*r) {
            return 2*r - Math.abs(x[i] - x[j]);
        } else
            return -1;
    }


    public static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(Reader in) {
            br = new BufferedReader(in);
        }

        public FastScanner() {
            this(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String readNextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        int[] readIntArray(int n) {
            int[] a = new int[n];
            for (int idx = 0; idx < n; idx++) {
                a[idx] = nextInt();
            }
            return a;
        }

        long[] readLongArray(int n) {
            long[] a = new long[n];
            for (int idx = 0; idx < n; idx++) {
                a[idx] = nextLong();
            }
            return a;
        }
    }
}
",5,5
"import java.util.*;
public class C {
	
	public static void main(String[] args) {
		Scanner qwe = new Scanner(System.in);
		int n = qwe.nextInt();
		double r = qwe.nextDouble();
		
		double[] fy = new double[n];
		Arrays.fill(fy, r);
		
		double[] xs = new double[n];
		for (int i = 0; i < xs.length; i++) {
			xs[i] = qwe.nextDouble();
		}
		
		for(int i =0; i < n; i++){
			
			for(int j = i+1; j < n; j++){
				double dx = xs[j]-xs[i];
				if(Math.abs(dx) > 2*r) continue;
				fy[j] = Math.max(fy[j], Math.sqrt(4*r*r-dx*dx)+fy[i]);
			}
			
		}
		
		StringBuilder stb = new StringBuilder();
		for (int i = 0; i < xs.length; i++) {
			stb.append(fy[i]+"" "");
		}
		System.out.println(stb);
	}

}
",5,3
"import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int r = sc.nextInt();
		int d = 2 * r;
		int[] xCoordinates = new int[n];
		double[] yCoordinates = new double[n];
		for (int i = 0; i < n; i++)
			yCoordinates[i] = r;
		for (int i = 0; i < n; i++)
			xCoordinates[i] = sc.nextInt();
		double y = 0;
		for (int i = 0; i < n; i++) {
			y = r;
			for (int j = 0; j < i; j++) {
				if (Math.abs(xCoordinates[i] - xCoordinates[j]) <= 2 * r) {
					int dx = Math.abs(xCoordinates[i] - xCoordinates[j]);
					double dy = Math.sqrt(d * d - dx * dx);
					if (dy + yCoordinates[j] > y)
						y = dy + yCoordinates[j];
				}
			}
			yCoordinates[i]=y;
		}
		for (int i = 0; i < n; i++)
			System.out.print(yCoordinates[i] + "" "");
		sc.close();
	}

}
",5,5
"import java.io.*;
import java.util.*;
import java.lang.*;
import java.math.*;
public class USACO {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(reader.readLine(),"" "");
        int n= Integer.parseInt(st.nextToken());
        int r= Integer.parseInt(st.nextToken());
        StringTokenizer st2 = new StringTokenizer(reader.readLine(),"" "");
        double[][] coord = new double[n][2];
        for (int i=0;i<n;i++) {
            coord[i][0] = Integer.parseInt(st2.nextToken());
            double y=r;
            for (int j=0;j<i;j++) {
                if (coord[j][0]<=coord[i][0]+2*r&&coord[j][0]>=coord[i][0]-2*r) {
                    if (coord[j][1]+Math.sqrt(4*r*r-(coord[i][0]-coord[j][0])*(coord[i][0]-coord[j][0]))>y) {
                        y=coord[j][1]+Math.sqrt(4*r*r-(coord[i][0]-coord[j][0])*(coord[i][0]-coord[j][0]));
                    }
                }
            }
            coord[i][1]=y;
        }
        for (int i=0;i<n;i++) {
            System.out.print(coord[i][1]);
            if (i<n-1) {
                System.out.print("" "");
            } else {
                System.out.print(""\n"");
            }
        }
        reader.close();
    }
}",5,5
"//>>>BaZ<<<//
import java.util.*;
import java.io.*;
import static java.lang.Math.*;
public class Main
{  
    static int dx[] = {-1,1,0,0};
    static int dy[] = {0,0,1,-1};
    static long MOD = 1000000007;
    static int INF = Integer.MAX_VALUE/10;
    static PrintWriter pw;
    static InputReader scan;
    //static MyFileReader1 ss;
    //static MyFileReader scan;
    static int ni() throws IOException{return scan.nextInt();}
    static long nl() throws IOException{return scan.nextLong();}
    static double nd() throws IOException{return scan.nextDouble();}
    static String ne() throws IOException{return scan.next();}
    static void pl() throws IOException {pw.println();}
    static void pl(Object o) throws IOException {pw.println(o);}
    static void p(Object o) throws IOException {pw.print(o+"" "");}
    static void psb(StringBuilder sb) throws IOException {pw.print(sb);}
    public static void main(String[] args) {
        new Thread(null,null,""BaZ"",99999999)
        {
            public void run()
            {
                try
                {
                    solve();
                }
                catch(Exception e)
                {  
                    e.printStackTrace();
                    System.exit(1);
                }
            }
        }.start();
    }
    static void solve() throws IOException
    {  
        Calendar CAL1 = Calendar.getInstance();
        CAL1.setTime(new Date());
        scan = new InputReader(System.in);
        pw = new PrintWriter(System.out,true);
        //pw = new PrintWriter(new File(""C://Users/Aman deep/Desktop/output.txt""));  
        //ss = new MyFileReader1();
        //scan = new MyFileReader();
        StringBuilder sb = new StringBuilder();
        int n = ni();
        double r = ni();
        double x[] = new double[n];
        for(int i=0;i<n;++i)
            x[i] = nd();
        double y[] = new double[n];
        y[0] = r;
        for(int i=1;i<n;++i)
        {  
            double max = -1;
            for(int j=0;j<i;++j)
            {
                double xx = 4*r*r-(x[i]-x[j])*(x[i]-x[j]);
                if(xx>=0)
                    max = max(max,sqrt(xx)+y[j]);
            }
            if(max==-1)
                max = r;
            y[i] = max;
        }
        for(int i=0;i<n;++i)
            p(y[i]);
        pl();
        Calendar CAL2 = Calendar.getInstance();
        CAL2.setTime(new Date());
        double Execution_Time = (double)(CAL2.getTimeInMillis()-CAL1.getTimeInMillis())/1000.000;
        //System.out.println(""Execution time : ""+Execution_Time+"" seconds"");
        pw.flush();
        pw.close();
    }
    static class InputReader     //NoSuchElementException -> EOF
	{
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;
		private SpaceCharFilter filter;
		
		public InputReader(InputStream stream)
		{
			this.stream = stream;
		}
		
		public int read()
		{
			if (numChars==-1) 
				throw new InputMismatchException();
			
			if (curChar >= numChars)
			{
				curChar = 0;
				try 
				{
					numChars = stream.read(buf);
				}
				catch (IOException e)
				{
					throw new InputMismatchException();
				}
				
				if(numChars <= 0)				
					return -1;
			}
			return buf[curChar++];
		}
	 
		public String nextLine()
		{
			BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
			String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
		}
		public int nextInt()
		{
			int c = read();
			
			while(isSpaceChar(c)) 
				c = read();
			
			int sgn = 1;
			
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			
			int res = 0;
			do 
			{
				if(c<'0'||c>'9') 
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			while (!isSpaceChar(c)); 
			
			return res * sgn;
		}
		
		public long nextLong() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			long res = 0;
			
			do 
			{
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			while (!isSpaceChar(c));
				return res * sgn;
		}
		
		public double nextDouble() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			double res = 0;
			while (!isSpaceChar(c) && c != '.') 
			{
				if (c == 'e' || c == 'E')
					return res * Math.pow(10, nextInt());
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			if (c == '.') 
			{
				c = read();
				double m = 1;
				while (!isSpaceChar(c)) 
				{
					if (c == 'e' || c == 'E')
						return res * Math.pow(10, nextInt());
					if (c < '0' || c > '9')
						throw new InputMismatchException();
					m /= 10;
					res += (c - '0') * m;
					c = read();
				}
			}
			return res * sgn;
		}
		
		public String readString() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do 
			{
				res.appendCodePoint(c);
				c = read();
			} 
			while (!isSpaceChar(c));
			
			return res.toString();
		}
	 
		public boolean isSpaceChar(int c) 
		{
			if (filter != null)
				return filter.isSpaceChar(c);
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}
	 
		public String next() 
		{
			return readString();
		}
		
		public interface SpaceCharFilter 
		{
			public boolean isSpaceChar(int ch);
		}
	}
    static class MyFileReader                                          //File input template
    {
        StringTokenizer st;
        BufferedReader br;
        MyFileReader() throws IOException
        {
            br = new BufferedReader(new FileReader(""C://Users/Aman deep/Desktop/input.txt""));
        }
        String nextLine() throws IOException
        {
            return br.readLine();
        }
        String next() throws IOException
        {
            if(st==null || !st.hasMoreTokens())
                st = new StringTokenizer(nextLine());
            return st.nextToken();
        }
        int nextInt() throws IOException
        {
            return Integer.parseInt(next());
        }
        long nextLong() throws IOException
        {
            return Long.parseLong(next());
        }
        double nextDouble() throws IOException
        {
            return Double.parseDouble(next());
        }
    }
    static class MyFileReader1                                          //File input template
    {
        StringTokenizer st;
        BufferedReader br;
        MyFileReader1() throws IOException
        {
            br = new BufferedReader(new FileReader(""C://Users/Aman deep/Desktop/output.txt""));
        }
        String nextLine() throws IOException
        {
            return br.readLine();
        }
        String next() throws IOException
        {
            if(st==null || !st.hasMoreTokens())
                st = new StringTokenizer(nextLine());
            return st.nextToken();
        }
        int nextInt() throws IOException
        {
            return Integer.parseInt(next());
        }
        long nextLong() throws IOException
        {
            return Long.parseLong(next());
        }
        double nextDouble() throws IOException
        {
            return Double.parseDouble(next());
        }
    }
}
",5,5
"import java.io.*;
import java.util.StringTokenizer;


public class Main {
	public static String taskName = """";

	public class Task {
		public void solve(int testNumber, InputReader in, PrintWriter out) {
			int n = in.nextInt();
			int r = in.nextInt();
			int[] x = new int[n];
			for(int i = 0; i < n; i++)
				x[i] = in.nextInt();

			double[] y = new double[n];
			for(int i = 0; i < n; i++) {
				y[i] = r;
				for(int j = 0; j < i; j++) {
					int dx = Math.abs(x[i] - x[j]);
					if(dx <= 2 * r)
						y[i] = Math.max(y[i], y[j] + Math.abs(Math.sqrt(4 * r * r - dx * dx)));
				}
				System.out.print(y[i] + "" "");
			}

			System.out.println();
		}
	}

	public static void main(String[] args) throws FileNotFoundException {
		if(!taskName.isEmpty()) {
			System.setIn(new BufferedInputStream(new FileInputStream(taskName + "".in"")));
			System.setOut(new PrintStream(new BufferedOutputStream(new FileOutputStream(taskName + "".out""))));
		}
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		Main main = new Main();
		main.run(in, out);
		out.close();
	}

	public void run(InputReader in, PrintWriter out) {
		Task solver = new Task();
		solver.solve(1, in, out);
	}

	static class InputReader {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public InputReader(InputStream stream) {
			reader = new BufferedReader(new InputStreamReader(stream), 32768);
			tokenizer = null;
		}

		public String next() {
			while(tokenizer == null || !tokenizer.hasMoreTokens())
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch(IOException e) {
					throw new RuntimeException(e);
				}
			return tokenizer.nextToken();
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public double nextShort() {
			return Short.parseShort(next());
		}

		public double nextByte() {
			return Byte.parseByte(next());
		}

		public double nextFloat() {
			return Float.parseFloat(next());
		}
	}
}
",5,5
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;

public class C {
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int r = sc.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < n; i++)
			arr[i] = sc.nextInt();

		double[] ans = new double[n];

		for (int i = 0; i < n; i++) {
			double max = 0;
			for (int j = 0; j < i; j++) {
				int difx = Math.abs(arr[i] - arr[j]);
				if (difx <= 2 * r) {
					max = Math.max(max, ans[j] + Math.sqrt(4 * r * r - difx * difx));
				}
			}
			ans[i] = max;
		}
		PrintWriter pw = new PrintWriter(System.out);
		for (int i = 0; i < n; i++)
			pw.print(ans[i] + r + "" "");
		pw.flush();
	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream s) {
			br = new BufferedReader(new InputStreamReader(s));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public boolean ready() throws IOException {
			return br.ready();
		}
	}
}
",5,5
"import java.io.*;
import java.util.*;
public class CC {
	public static void main(String[] args)throws Throwable {
		MyScanner sc=new MyScanner();
		PrintWriter pw=new PrintWriter(System.out);
		
		int n=sc.nextInt();
		int r=sc.nextInt();
		int [] x=new int [n];
		for(int i=0;i<n;i++)
			x[i]=sc.nextInt();
		double [] ans=new double [n];
		ans[0]=r;
		for(int i=1;i<n;i++){
			ans[i]=r;
			for(int j=0;j<i;j++){
				double dx=Math.abs(x[i]-x[j]);
				if(dx>2*r)
					continue;
				double y=Math.sqrt((4*r*r)-(dx*dx));
				ans[i]=Math.max(ans[i], ans[j]+y);
			}
		}
		
		
		for(double z : ans)
			pw.print(z+"" "");
		pw.flush();
		pw.close();
	}
	
	static class MyScanner {
		BufferedReader br;
		StringTokenizer st;
		public MyScanner() {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		String next() {while (st == null || !st.hasMoreElements()) {
			try {st = new StringTokenizer(br.readLine());}
			catch (IOException e) {e.printStackTrace();}}
		return st.nextToken();}
		int nextInt() {return Integer.parseInt(next());}
		long nextLong() {return Long.parseLong(next());}
		double nextDouble() {return Double.parseDouble(next());}
		String nextLine(){String str = """";
		try {str = br.readLine();}
		catch (IOException e) {e.printStackTrace();}
		return str;}
	}
}",5,5
"import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class C {
	public static void main(String[] args) throws IOException{
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		String[] line = in.readLine().split("" "");
		int n = Integer.parseInt(line[0]);
		int r=  Integer.parseInt(line[1]);
		line = in.readLine().split("" "");
		double[] x = new double[n];
		double[] y= new double[n];
		for(int i = 0; i<n; i++) {
			y[i] = r;
			x[i] = Integer.parseInt(line[i]);
		}
		for(int i = 1; i<n; i++) {
			for(int j = 0; j<i; j++) {
				if(Math.abs(x[i]-x[j])>r*2) {
					continue;
				}
				double low = y[j];
				double high = y[j]+(double)r*2.0;
				for(int k = 0; k<85 && low<high; k++) {
					double mid = (low+high)/2.0;
					if(Point2D.distance(x[j], y[j], x[i], mid)<(double)r*2.0) {
						low = mid;
					}
					else {
						high = mid;
					}
				}
				y[i] = Math.max(y[i], low);
			}
		}
		System.out.printf(""%.15f"",y[0]);
		for(int i = 1; i<n; i++) {
			System.out.printf("" %.15f"",y[i]);
		}
		System.out.print(""\n"");
	}
}",5,5
"import java.util.Optional;
import java.util.Scanner;
import java.util.StringJoiner;

public class Main {
	public static void main(String[] args) {
		Main main = new Main();
		main.solveC();
	}

	private void solveA() {
		Scanner sc = new Scanner(System.in);
		String str = sc.next();
		long answer = str.chars().filter(
				asc -> asc == 'a'
					|| asc == 'i'
					|| asc == 'u'
					|| asc == 'e'
					|| asc == 'o'
					|| asc == '1'
					|| asc == '3'
					|| asc == '5'
					|| asc == '7'
					|| asc == '9').count();
		System.out.println(answer);
	}

	private void solveB() {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int M = sc.nextInt();
		sc.nextLine();
		char[][] map = new char[N + 2][M + 2];
		map[0] = new char[M + 2];
		map[N + 1] = new char[M + 2];
		int s_r = -1;
		int s_c = -1;
		for (int c = 0; c < M + 2; c++) {
			map[0][c] = '#';
			map[N + 1][c] = '#';
		}
		for (int r = 1; r <= N; r++) {
			map[r][0] = '#';
			String line = sc.nextLine();
			for (int c = 1; c <= M; c++) {
				map[r][c] = line.charAt(c - 1);
				if (map[r][c] == 'S') {
					s_r = r;
					s_c = c;
				}
			}
			map[r][M + 1] = '#';
		}
		String inst = sc.next();
		long ans = 0L;
		for (int left = 0; left < 4; left++) {
			for (int up = 0; up < 4; up++) {
				for (int right = 0; right < 4; right++) {
					for (int down = 0; down < 4; down++) {
						if (left == up || left == right || left == down || up == right || up == down || right == down) {
							continue;
						}
						int r_r = s_r;
						int r_c = s_c;
						for (int i = 0; i < inst.length(); i++) {
							char asc = inst.charAt(i);
							if (asc == '0' + left) {
								r_c--;
							}
							if (asc == '0' + up) {
								r_r--;
							}
							if (asc == '0' + right) {
								r_c++;
							}
							if (asc == '0' + down) {
								r_r++;
							}
							if (map[r_r][r_c] == '#') {
								break;
							}
							if (map[r_r][r_c] == 'E') {
								ans++;
								break;
							}
						}
					}
				}
			}
		}
		System.out.println(ans);
	}

	private void solveC() {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		double R = 0.0 + sc.nextInt();
		double[] x = new double[N];
		double[] y = new double[N];
		for (int i = 0; i < N; i++) {
			x[i] = 0.0 + sc.nextInt();
			double max_y = R;
			for (int j = 0; j < i; j++) {
				double dy = 4 * R * R - (x[i] - x[j]) * (x[i] - x[j]);
				if (dy >= 0) {
					double tmp_y = y[j] + Math.sqrt(dy);
					if (max_y < tmp_y) {
						max_y = tmp_y;
					}
				}
			}
			y[i] = max_y;
		}
		StringJoiner sj = new StringJoiner("" "");
		for (int i = 0; i < N; i++) {
			sj.add(String.valueOf(y[i]));
		}
		System.out.println(sj.toString());
	}

	private void solveD() {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		System.out.println(N);
	}

	private void solveE() {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		System.out.println(N);
	}

	private void solveF() {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		System.out.println(N);
	}

	interface Graph {
		void link(int from, int to, long cost);
		Optional<Long> getCost(int from, int to);
		int getVertexNum();
	}

	interface FlowResolver {
		long maxFlow(int from, int to);
	}

	/**
	 * ã‚°ãƒ©ãƒ•ã®è¡Œåˆ—ã«ã‚ˆã‚‹å®Ÿè£…
	 * æŽ¥ç‚¹æ•°ã®å¤§ãã„ã‚°ãƒ©ãƒ•ã§ä½¿ã†ã¨MLEã§æ­»ã«ãã†
	 */
	class ArrayGraph implements Graph {
		private Long[][] costArray;
		private int vertexNum;

		public ArrayGraph(int n) {
			costArray = new Long[n][];
			for (int i = 0; i < n; i++) {
				costArray[i] = new Long[n];
			}
			vertexNum = n;
		}

		@Override
		public void link(int from, int to, long cost) {
			costArray[from][to] = new Long(cost);
		}

		@Override
		public Optional<Long> getCost(int from, int to) {
			return Optional.ofNullable(costArray[from][to]);
		}

		@Override
		public int getVertexNum() {
			return vertexNum;
		}
	}

	/**
	 * DFS(æ·±ã•å„ªå…ˆæŽ¢ç´¢)ã«ã‚ˆã‚‹å®Ÿè£…
	 * è¨ˆç®—é‡ã¯O(E*MaxFlow)ã®ã¯ãš (E:è¾ºã®æ•°, MaxFlow:æœ€å¤§ãƒ•ãƒ­ãƒ¼)
	 */
	class DfsFlowResolver implements FlowResolver {
		private Graph graph;
		public DfsFlowResolver(Graph graph) {
			this.graph = graph;
		}

		/**
		 * æœ€å¤§ãƒ•ãƒ­ãƒ¼(æœ€å°ã‚«ãƒƒãƒˆ)ã‚’æ±‚ã‚ã‚‹
		 * @param from å§‹ç‚¹(source)ã®ID
		 * @param to çµ‚ç‚¹(target)ã®ID
		 * @return æœ€å¤§ãƒ•ãƒ­ãƒ¼(æœ€å°ã‚«ãƒƒãƒˆ)
		 */
		public long maxFlow(int from, int to) {
			long sum = 0L;
			long currentFlow;
			do {
				currentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);
				sum += currentFlow;
			} while (currentFlow > 0);
			return sum;
		}

		/**
		 * ãƒ•ãƒ­ãƒ¼ã®å®Ÿè¡Œ ã‚°ãƒ©ãƒ•ã®æ›´æ–°ã‚‚è¡Œã†
		 * @param from ç¾åœ¨ã„ã‚‹ç¯€ç‚¹ã®ID
		 * @param to çµ‚ç‚¹(target)ã®ID
		 * @param current_flow ã“ã“ã¾ã§ã®æµé‡
		 * @param passed æ—¢ã«é€šã£ãŸç¯€ç‚¹ã‹å¦ã‹ã‚’æ ¼ç´ã—ãŸé…åˆ—
		 * @return çµ‚ç‚¹(target)ã«æµã—ãŸæµé‡/æˆ»ã‚Šã®ã‚°ãƒ©ãƒ•ã®æµé‡
		 */
		private long flow(int from, int to, long current_flow, boolean[] passed) {
			passed[from] = true;
			if (from == to) {
				return current_flow;
			}
			for (int id = 0; id < graph.getVertexNum(); id++) {
				if (passed[id]) {
					continue;
				}
				Optional<Long> cost = graph.getCost(from, id);
				if (cost.orElse(0L) > 0) {
					long nextFlow = current_flow < cost.get() ? current_flow : cost.get();
					long returnFlow = flow(id, to, nextFlow, passed);
					if (returnFlow > 0) {
						graph.link(from, id, cost.get() - returnFlow);
						graph.link(id, from, graph.getCost(id, from).orElse(0L) + returnFlow);
						return returnFlow;
					}
				}
			}
			return 0L;
		}
	}

	/**
	 * 1-indexedã®BITé…åˆ—
	 */
	class BinaryIndexedTree {
		private long[] array;

		public BinaryIndexedTree(int size) {
			this.array = new long[size + 1];
		}

		/**
		 * æŒ‡å®šã—ãŸè¦ç´ ã«å€¤ã‚’åŠ ç®—ã™ã‚‹
		 * è¨ˆç®—é‡ã¯O(logN)
		 * @param index åŠ ç®—ã™ã‚‹è¦ç´ ã®æ·»å­—
		 * @param value åŠ ç®—ã™ã‚‹é‡
		 */
		public void add(int index, long value) {
			for (int i = index; i < array.length; i += (i & -i)) {
				array[i] += value;
			}
		}

		/**
		 * 1ã€œæŒ‡å®šã—ãŸè¦ç´ ã¾ã§ã®å’Œã‚’å–å¾—ã™ã‚‹
		 * è¨ˆç®—é‡ã¯O(logN)
		 * @param index å’Œã®çµ‚ç«¯
		 * @return 1ã€œindexã¾ã§ã®å’Œ
		 */
		public long getSum(int index) {
			long sum = 0L;
			for (int i = index; i > 0; i -= (i & -i)) {
				sum += array[i];
			}
			return sum;
		}
	}
}",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;


public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        TaskC.InputReader in = new TaskC.InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.Solve(in, out);
        out.close();
    }


    static class TaskC {

        void Solve(InputReader in, PrintWriter out) {
            int n = in.NextInt();
            double r = in.NextInt();
            double[] x = new double[n];
            for (int i = 0; i < n; i++) x[i] = in.NextInt();
            double[] y = new double[n];
            for (int i = 0; i < n; i++) {
                double maxY = r;
                for (int j = 0; j < i; j++) {
                    if (Math.abs(x[i] - x[j]) <= 2 * r) {
                        double currentY = Math.sqrt((2 * r) * (2 * r) - (x[i] - x[j]) * (x[i] - x[j])) + y[j];
                        maxY = Math.max(maxY, currentY);
                    }
                }
                y[i] = maxY;
            }
            out.print(y[0]);
            for (int i = 1; i < n; i++) {
                out.print("" "" + y[i]);
            }
            out.println();
        }

        static int GetMax(int[] ar) {
            int max = Integer.MIN_VALUE;
            for (int a : ar) {
                max = Math.max(max, a);
            }
            return max;
        }

        static int GetMin(int[] ar) {
            int min = Integer.MAX_VALUE;
            for (int a : ar) {
                min = Math.min(min, a);
            }
            return min;
        }

        static long GetSum(int[] ar) {
            long s = 0;
            for (int a : ar) s += a;
            return s;
        }

        static int[] GetCount(int[] ar) {
            return GetCount(ar, GetMax(ar));
        }

        static int[] GetCount(int[] ar, int maxValue) {
            int[] dp = new int[maxValue + 1];
            for (int a : ar) {
                dp[a]++;
            }
            return dp;
        }

        static class InputReader {
            BufferedReader reader;
            StringTokenizer tokenizer;

            InputReader(InputStream stream) {
                reader = new BufferedReader(new InputStreamReader(stream), 32768);
                tokenizer = null;
            }

            String Next() {
                while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                    try {
                        tokenizer = new StringTokenizer(reader.readLine(), "" \t\n\r\f,"");
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }
                return tokenizer.nextToken();
            }

            int NextInt() {
                return Integer.parseInt(Next());
            }

            long NextLong() {
                return Long.parseLong(Next());
            }

            double NextDouble() {
                return Double.parseDouble(Next());
            }

            int[] NextIntArray(int n) {
                return NextIntArray(n, 0);
            }

            int[] NextIntArray(int n, int offset) {
                int[] a = new int[n];
                for (int i = 0; i < n; i++) {
                    a[i] = NextInt() - offset;
                }
                return a;
            }

            int[][] NextIntMatrix(int n, int m) {
                return NextIntMatrix(n, m, 0);
            }

            int[][] NextIntMatrix(int n, int m, int offset) {
                int[][] a = new int[n][m];
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < m; j++) {
                        a[i][j] = NextInt() - offset;
                    }
                }
                return a;
            }
        }
    }
}
",5,5
"import java.util.*;

public class PC1229 {

	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int r = sc.nextInt();
		int[] x = new int[n];
		for(int i = 0; i < n; i++){
			x[i] = sc.nextInt();
		}
		double[] ans = new double[n];
		for(int i = 0; i < n; i++){
			double maxY = r;
			for(int j = 0; j < i; j++){
				if(x[j] <= x[i] + 2*r && x[j] >= x[i] - 2*r){
					maxY = Math.max(maxY, ans[j] + Math.sqrt(4 * r * r - (Math.abs(x[i] - x[j])) * (Math.abs(x[i] - x[j]))));
				}
			}
			ans[i] = maxY;
		}
		for(int i = 0; i < n; i++){
			System.out.println(ans[i]);
		}
		sc.close();
	}
	
}
",5,5
"//package GoodBye2017;

import java.io.*;
import java.util.*;

public class c {
	public static void main(String[] args) throws Exception{ new c(new Reader()); }
	public c(Reader rr) throws IOException{
		int n=rr.ni();
		double r=rr.nd();
		HashMap<Integer, Double> disk=new HashMap<Integer, Double>();
		for(int i=0; i<n; i++){
			int next=rr.ni();
			if(disk.isEmpty()){
				disk.put(next, r);
				System.out.print(r+"" "");
			}
			else{
				double high=r;
				for(Map.Entry<Integer, Double> it: disk.entrySet()){
					if(2*r<next-it.getKey()) continue;
					double tempHigh=pyth(Math.abs(next-it.getKey()),r*2)+it.getValue();
					if(tempHigh>high){
						high=tempHigh;
					}
				}
				disk.put(next, high);
				System.out.print(high+"" "");
			}
		}
	}
	public double pyth(double a, double c){
		return Math.sqrt(Math.pow(c, 2)-Math.pow(a, 2));
	}
	static class Reader{
		private DataInputStream din;
		private byte[] buffer=new byte[1024];
		private int bufP, bytR;
		public Reader() throws IOException{
			din=new DataInputStream(System.in);
			bufP=bytR=0;
		}
		public Reader(String file) throws IOException{
			din=new DataInputStream(new FileInputStream(file));
			bufP=bytR=0;
		}
		private String rl() throws IOException{
			byte[] buf=new byte[1024];
			int cnt=0, c;
			while((c=read())!=-1){
				if(c=='\n') break;
				buf[cnt++]=(byte)c;
			}
			return new String(buf, 0, cnt);
		}
		private int ni() throws IOException{
			int num=0;
			byte c=read();
			while(c<=' ') c=read();
			boolean neg=(c=='-');
			if(neg) c=read();
			do{
				num=num*10+c-'0';
			} while((c=read())>='0'&&c<='9');
			if(neg) return -num;
			return num;
		}
		private long nl() throws IOException{
			long num=0;
			byte c=read();
			while(c<=' ') c=read();
			boolean neg=(c=='-');
			if(neg) c=read();
			do{
				num=num*10+c-'0';
			} while((c=read())>='0'&&c<='9');
			if(neg) return -num;
			return num;
		}
		private double nd() throws IOException{ return Double.parseDouble(ns()); }
		private char nc() throws IOException{ return (char)next(); }
		private String ns() throws IOException{
			int c=next();
			StringBuilder sb=new StringBuilder();
			while(!(isChar(c))){
				sb.appendCodePoint(c);
				c=read();
			}
			return sb.toString();
		}
		private char[] ns(int n) throws IOException{
			char[] buf=new char[n];
			int c=next(), r=0;
			while(r<n&&!(isChar(c))){
				buf[r++]=(char)c;
				c=next();
			}
			return n==r?buf:Arrays.copyOf(buf, r);
		}
		private char[][] nm(int n, int m) throws IOException{
			char[][] map=new char[n][];
			for(int i=0; i<n; i++) map[i]=ns(m);
			return map;
		}
		private int[] na(int n) throws IOException{
			int[] a=new int[n];
			for(int i=0; i<n; i++) a[i]=ni();
			return a;
		}
		private boolean isChar(int c) throws IOException{ return !(c>=33&&c<=126); }
		private int next() throws IOException{ int c; while((c=read())!=-1&&isChar(c)); return c; }
		private byte read() throws IOException{
			if(bufP==bytR){
				bytR=din.read(buffer, bufP=0, 1024);
				if(bytR==-1) buffer[0]=-1;
			}
			return buffer[bufP++];
		}
		public void close() throws IOException{
			if(din==null) return;
			din.close();
		}
	}
}
",5,3
"import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.*;

public class C {

	public static void main(String[] args) {
		FastScanner in = new FastScanner();
		int n = in.nextInt();
		double r = in.nextInt();
		double x[] = new double[n];
		for(int i = 0; i < n; i++)
			x[i] = in.nextDouble();
		
		double y[] = new double[n];
		y[0] = r;
		
		for(int i = 1; i < n; i++){
			double miny = r;
			for(int j = 0; j < i; j++){
				double dx = Math.abs(x[i]-x[j]);
				if(dx > r*2) continue;
				double yy = Math.sqrt(4*r*r-dx*dx);
				miny = Math.max(miny, yy+y[j]);
			}
			y[i] = miny;
		}
		for(int i = 0; i < n; i++){
			System.out.print(y[i]+"" "");
		}
		

	}

	
	
	static class FastScanner{
		BufferedReader br;
		StringTokenizer st;
		public FastScanner(String s) {
			try{
				br = new BufferedReader(new FileReader(s));
			}
			catch(FileNotFoundException e) {
				e.printStackTrace();
			}
		}
		public FastScanner(){
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		String nextToken()	{
			while(st == null ||!st.hasMoreElements()){
				try {
				st = new StringTokenizer(br.readLine());}
				catch(IOException e) {
					e.printStackTrace();
				}			
			}
			return st.nextToken();
		}
		
		int nextInt() {
			return Integer.parseInt(nextToken());
		}
		long nextLong() {
			return Long.parseLong(nextToken());
		}
		double nextDouble() {
			return Double.parseDouble(nextToken());
		}
		String next() {
			return nextToken();
		}
		
	}
}
",5,5
"import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class C908 {
	
	public static class mPoint implements Comparable<mPoint> {
		public double a, b;
		public mPoint(int a, double b) {
			this.a = a; this.b = b;
		}
		public int compareTo(mPoint p) {
			return b < p.b ? 1 : (b > p.b) ? -1 : 0;
		}
	}

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt(), r = in.nextInt();
		int[] ar = new int[n];
		ArrayList<mPoint> disks = new ArrayList<>();
		double[] ans = new double[n];
		for (int i = 0; i < n; i++) {
			ar[i] = in.nextInt();
			double max = -1;
			for (int j = 0; j < disks.size(); j++) {
				if (inRange(ar[i], disks.get(j).a, r)) {
					double h = 4*r*r - (ar[i]-disks.get(j).a) * (ar[i]-disks.get(j).a);
					max = Math.max(max, Math.sqrt(h) + disks.get(j).b);
				}
			}
			mPoint p = null;
			if (max == -1) {
				p = new mPoint(ar[i], r);
			} else {
				p = new mPoint(ar[i], max);
			}
			disks.add(p);
			ans[i] = p.b;
		}
		for (int i = 0; i < ans.length - 1; i++) {
			System.out.print(ans[i] + "" "");
		}
		System.out.println(ans[ans.length - 1]);
	}
	
	public static boolean inRange(int a, double b, int r) {
		if (Math.abs(b - a) <= 2*r) return true; return false;
	}
	
}
",5,5
"import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class C {
	public static Scanner sc = new Scanner(System.in);
	public static StringTokenizer st;
	public static PrintWriter pw = new PrintWriter(System.out);
	final static boolean debugmode = true;
	public static int k = 7; // for 10^9 + k mods.
	public static long STMOD = 1000000000 + k; // 10^9 + k
	public static void main(String[] args) {
		int disks = getInt();
		int radii = getInt();
		if(disks == 1){
			System.out.println(radii);
		}
		else{
			double[][] diskcenters = new double[disks][2];
			for(int i = 0;i<disks;i++){
				diskcenters[i][0] = getInt();
			}
			diskcenters[0][1] = radii;
			for(int i = 1;i<disks;i++){
				double cmax = 0;
				for(int prev = 0;prev < i;prev++){
					cmax = Math.max(cmax, calcintersection(diskcenters[prev][0],diskcenters[prev][1],radii,diskcenters[i][0],radii));
				}
				diskcenters[i][1] = cmax;
			}
			for(int i = 0;i<diskcenters.length;i++){
				System.out.print(Double.toString(diskcenters[i][1]) + "" "");
			}
			System.out.print(""\n"");
		}
		
	}
	public static double calcintersection(double x1,double y1, double r1,double x2, double r2){
		// x1,y1 must be stationary.
		if(!intersects(x1-r1,x1+r1,x2-r1,x2+r2)){
			return r2;
		}
		else if(x1 == x2){
			return y1 + r1 + r2;
		}
		double lo = y1;
		double hi = y1 +  2 * r2;
		
		while(Math.abs(lo-hi) > 0.0000001){
			double mid = (lo+hi)/2.0;
			int u = colide(x1,y1,r1,x2,mid,r2);
			if(u == 1){
				lo = mid;
			}
			else if(u == 0)
			{
				hi = mid;
			}
			else{
				return mid;
			}
		}
		return (lo+hi)/2.0;
	}
	public static boolean intersects(double l1, double r1,double l2, double r2 ){
		if(l2  <= l1 && r2 >= l1){
			return true;
		}
		if(l2 <= r1 && r2 >= r1){
			return true;
		}
		if(l1 <= l2 && r2 <= r1){
			return true;
		}
		else if(l2 <= l1 && r1 <= r2){
			return true;
		}
		return false;
	}
	public static int colide(double x1,double y1,double r1,double x2,double y2,double r2){
		double dist = Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y2-y1, 2));
		if (dist > r1 + r2){
			return 0;
		}
		else if(dist == r1+r2){
			return 2;
		}
		else{
			return 1;
		}
		
	}
	public static void debug(String toPrint){
		if(!debugmode) {return;}
		pw.println(""[DEBUG]: ""+toPrint);
	}
	public static void  submit(int[] k){
		pw.println(Arrays.toString(k));
		pw.close();
	}
	public static void submit(int p){
		pw.println(Integer.toString(p));
		pw.close();
	}
	public static void submit(String k){
		pw.println(k);
		pw.close();
	}
	public static void submit(double u){
		pw.println(Double.toString(u));
		pw.close();
	}
	public static void submit(long lng){
		pw.println(Long.toString(lng));
		pw.close();
		
	}
	public static int getInt(){
		if (st != null && st.hasMoreTokens()){
			return Integer.parseInt(st.nextToken());
		}
		st = new StringTokenizer(sc.nextLine());
		return Integer.parseInt(st.nextToken());
	}
	public static long getLong(){
		if (st != null && st.hasMoreTokens()){
			return Long.parseLong(st.nextToken());
		}
		st = new StringTokenizer(sc.nextLine());
		return Long.parseLong(st.nextToken());
	}
	public static double getDouble(){
		if (st != null && st.hasMoreTokens()){
			return Double.parseDouble(st.nextToken());
		}
		st = new StringTokenizer(sc.nextLine());
		return Double.parseDouble(st.nextToken());
	}
	public static String getString(){
		if(st != null && st.hasMoreTokens()){
			return st.nextToken();
		}
		st = new StringTokenizer(sc.nextLine());
		return st.nextToken();
	}
	public static String getLine(){
		return sc.nextLine();
	}
	public static int[][] readMatrix(int lines,int cols){
		int[][] matrr = new int[lines][cols];
		for (int i = 0;i < lines;i++){
			for(int j = 0;j < cols;j++){
				matrr[i][j] = getInt();
			}
		}
		return matrr;
	}
	public static int[] readArray(int lines){
		int[] ar = new int[lines];		
		for (int i = 0;i<lines;i++) ar[i] =getInt();
		return ar;
	}
	
}
",5,5
"import java.util.*;
import java.io.*;

public class NewYearAndCurling {
	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(System.out);
		StringTokenizer t = new StringTokenizer(in.readLine());
		int N = Integer.parseInt(t.nextToken());
		int R = Integer.parseInt(t.nextToken());
		int[] x = new int[N];
		t = new StringTokenizer(in.readLine());
		for(int i = 0; i < N; ++i)
			x[i] = Integer.parseInt(t.nextToken());
		double[] y = new double[N];
		for(int i = 0; i < N; ++i) {
			double max = R;
			for(int j = 0; j < i; ++j ) {
				int xDiff = Math.abs(x[i] - x[j]);
				if(xDiff <= 2 * R)
					max = Math.max(max, y[j] + Math.sqrt(4*R*R - xDiff*xDiff));
			}
			y[i] = max;
		}
		out.print(y[0]);
		for(int i = 1; i < N; ++i)
			out.print("" "" + y[i]);
		out.println();
		in.close();
		out.close();
	}
}",5,5
"import java.io.*;
import java.util.*;
import java.math.*;

public class utkarsh {

    InputStream is;
    PrintWriter out;
    
    double x[], y[], R;
    
    boolean game(double x1, double y1, double x2, double y2){
        double dis = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
        //if(x2 == 12 && x1 == 8 && y1 > 13 && y1 < 14)    out.println(dis +"" ""+ y2);
        return dis <= 4.0 * R * R;
    }
    
    void play(int n){
        double l, r, m;
        double a[] = new double[n];
        for(int i = 0; i < n; i++){ 
            l = 0.0;
            r = 1000000.0;
            for(int j = 0; j < 50; j++){
                m = (l + r) / 2;
                if(game(x[i], 0, x[n], m))  l = m;
                else    r = m;
            }
            a[i] = l;
        }
        for(int i = 0; i < n; i++){
            //if(n == 4)  out.println(a[i] +"" ""+ y[i]);
            if(a[i] > 0.0 && (y[i] + a[i]) > y[n])    y[n] = y[i] + a[i];
        }
    }
    
    void solve(){
        //Enter code here utkarsh
        int i, j, n;
        n = ni();
        R = nd();
        x = new double[n];
        y = new double[n];
        for(i = 0; i < n; i++)  x[i] = nd();
        for(i = 0; i < n; i++){
            play(i);
        }
        for(i = 0; i < n; i++)  out.print((R + y[i]) +"" "");
    }
    
    public static void main(String[] args) { new utkarsh().run();
    }
    void run(){ is = System.in; out = new PrintWriter(System.out); solve(); out.flush();
    }
    
    byte input[] = new byte[1024];
    int len = 0, ptr = 0;
    
    int readByte(){ if(ptr >= len){ ptr = 0; try{ len = is.read(input); }catch(IOException e){ throw new InputMismatchException(); } if(len <= 0){ return -1; } } return input[ptr++];
    }
    boolean isSpaceChar(int c){ return !( c >= 33 && c <= 126 ); 
    }
    int skip(){ int b = readByte(); while(b != -1 && isSpaceChar(b)){ b = readByte(); } return b;
    }
    
    char nc(){ return (char)skip();
    }
    String ns(){ int b = skip(); StringBuilder sb = new StringBuilder(); while(!isSpaceChar(b)){ sb.appendCodePoint(b); b=readByte(); } return sb.toString();
    }
    int ni(){ int n = 0,b = readByte(); boolean minus = false; while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')){ b = readByte(); } if(b == '-'){ minus = true; b = readByte(); } if(b == -1){ return -1; } while(b >= '0' && b <= '9'){ n = n * 10 + (b - '0'); b = readByte(); } return minus ? -n : n;
    }
    long nl(){ long n = 0L; int b = readByte(); boolean minus = false; while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')){ b = readByte(); } if(b == '-'){ minus = true; b = readByte(); } while(b >= '0' && b <= '9'){ n = n * 10 + (b - '0'); b = readByte(); } return minus ? -n : n;
    }
    double nd(){ return Double.parseDouble(ns());
    }
    float nf(){ return Float.parseFloat(ns());
    }
    int[] na(int n){ int a[] = new int[n]; for(int i = 0; i < n; i++){ a[i] = ni(); } return a;
    }
    char[] ns(int n){ char c[] = new char[n]; int i,b = skip(); for(i = 0; i < n; i++){ if(isSpaceChar(b)){ break; } c[i] = (char)b; b = readByte(); } return i == n ? c : Arrays.copyOf(c,i);
    }
}",5,3
"import java.io.*;
import java.util.*;
import java.math.BigInteger;
import java.util.Map.Entry;

import static java.lang.Math.*;

public class C extends PrintWriter {

    void run() {

        int n = nextInt();
        int r = nextInt();
        int[] x = nextArray(n);

        double[] y = new double[n];
        Arrays.fill(y, r);

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                int dx = abs(x[i] - x[j]);
                int sdy = 4 * r * r - dx * dx;

                if (sdy >= 0) {
                    double dy = sqrt(sdy);
                    y[i] = max(y[i], y[j] + dy);
                }
            }
        }

        for (double v : y) {
            printf(Locale.ENGLISH, ""%.10f "", v);
        }

    }

    boolean skip() {
        while (hasNext()) {
            next();
        }
        return true;
    }

    int[][] nextMatrix(int n, int m) {
        int[][] matrix = new int[n][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                matrix[i][j] = nextInt();
        return matrix;
    }

    String next() {
        while (!tokenizer.hasMoreTokens())
            tokenizer = new StringTokenizer(nextLine());
        return tokenizer.nextToken();
    }

    boolean hasNext() {
        while (!tokenizer.hasMoreTokens()) {
            String line = nextLine();
            if (line == null) {
                return false;
            }
            tokenizer = new StringTokenizer(line);
        }
        return true;
    }

    int[] nextArray(int n) {
        int[] array = new int[n];
        for (int i = 0; i < n; i++) {
            array[i] = nextInt();
        }
        return array;
    }

    int nextInt() {
        return Integer.parseInt(next());
    }

    long nextLong() {
        return Long.parseLong(next());
    }

    double nextDouble() {
        return Double.parseDouble(next());
    }

    String nextLine() {
        try {
            return reader.readLine();
        } catch (IOException err) {
            return null;
        }
    }

    public C(OutputStream outputStream) {
        super(outputStream);
    }

    static BufferedReader reader;
    static StringTokenizer tokenizer = new StringTokenizer("""");
    static Random rnd = new Random();
    static boolean OJ;

    public static void main(String[] args) throws IOException {
        OJ = System.getProperty(""ONLINE_JUDGE"") != null;
        C solution = new C(System.out);
        if (OJ) {
            reader = new BufferedReader(new InputStreamReader(System.in));
            solution.run();
        } else {
            reader = new BufferedReader(new FileReader(new File(C.class.getName() + "".txt"")));
            long timeout = System.currentTimeMillis();
            while (solution.hasNext()) {
                solution.run();
                solution.println();
                solution.println(""----------------------------------"");
            }
            solution.println(""time: "" + (System.currentTimeMillis() - timeout));
        }
        solution.close();
        reader.close();
    }
}",5,5
"import static java.lang.Integer.parseInt;
import static java.lang.Long.parseLong;
import static java.lang.Math.abs;
import static java.lang.Math.max;
import static java.lang.Math.sqrt;
import static java.lang.System.exit;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Locale;
import java.util.StringTokenizer;

public class C {

	static int sqr(int x) {
		return x * x;
	}

	static void solve() throws Exception {
		int n = scanInt();
		int r = scanInt();
		int x[] = new int[n];
		double y[] = new double[n];
		for (int i = 0; i < n; i++) {
			int cx = x[i] = scanInt();
			double cy = r;
			for (int j = 0; j < i; j++) {
				if (abs(cx - x[j]) <= 2 * r) {
					cy = max(cy, y[j] + sqrt(sqr(2 * r) - sqr(cx - x[j])));
				}
			}
			y[i] = cy;
			if (i > 0) {
				out.print(' ');
			}
			out.printf(Locale.US, ""%.9f"", cy);
		}
	}

	static int scanInt() throws IOException {
		return parseInt(scanString());
	}

	static long scanLong() throws IOException {
		return parseLong(scanString());
	}

	static String scanString() throws IOException {
		while (tok == null || !tok.hasMoreTokens()) {
			tok = new StringTokenizer(in.readLine());
		}
		return tok.nextToken();
	}

	static BufferedReader in;
	static PrintWriter out;
	static StringTokenizer tok;

	public static void main(String[] args) {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			solve();
			in.close();
			out.close();
		} catch (Throwable e) {
			e.printStackTrace();
			exit(1);
		}
	}
}",5,5
"import java.io.*;
import java.util.*;
	
public class Codeforces908C {
	public static void main(String[] args) throws IOException {
		BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(f.readLine());
		int n = Integer.parseInt(st.nextToken());
		int r = Integer.parseInt(st.nextToken());
		int[] x = new int[n];
		st = new StringTokenizer(f.readLine());
		for(int i = 0; i < n; i++) {
			x[i] = Integer.parseInt(st.nextToken());
		}
		double[] y = new double[n];
		y[0] = r;
		double hypSq = 4*r*r;
		for(int i = 1; i < n; i++) {
			boolean hit = false;
			double maxY = 0;
			for(int j = 0; j < i; j++) {
				int dx = Math.abs(x[i] - x[j]);
				if(dx == 2*r) {
					if(y[j] > maxY) {
						maxY = y[j];
						hit = true;
					}
				} else if(dx < 2*r) {
					double newY = y[j] + Math.sqrt(hypSq - dx*dx);
					if(newY > maxY) {
						maxY = newY;
						hit = true;
					}
				}
			}
			if(!hit) {
				y[i] = r;
			} else {
				y[i] = maxY;
			}
		}
		StringBuffer s = new StringBuffer("""");
		for(int i = 0; i < n; i++) {
			s.append(y[i] + "" "");
		}
		System.out.println(s.toString().trim());
	}
}
",5,5
"import java.lang.*;
import java.io.*;
import java.util.*;

public class Main {


    public void solve() throws IOException {
        int n = nextInt(), r = nextInt();
        int x[] = new int[n];
        for (int i = 0; i < n; i++) {
            x[i] = nextInt();
        }
        double res[] = new double[n];
        res[0] = r;
        for (int i = 1; i < n; i++) {
            double max = r;
            for (int j = 0; j < i; j++) {
                int d = Math.abs(x[i] - x[j]);
                if(d <= 2 * r){
                    double yy = Math.sqrt(4 * r * r - d * d);
                    max = Math.max(max, yy + res[j]);
                }
            }
            res[i] = max;
        }
        for (int i = 0; i < n; i++) {
            out.print(res[i] + "" "");
        }
    }

    BufferedReader br;
    StringTokenizer sc;
    PrintWriter out;

    public static void main(String[] args) throws IOException {
        Locale.setDefault(Locale.US);
        new Main().run();
    }

    void run() throws IOException {
        try {
            br = new BufferedReader(new InputStreamReader(System.in));
            out = new PrintWriter(System.out);
//            br = new BufferedReader(new FileReader(""pnumbers.in""));
//            out = new PrintWriter(new File(""out.txt""));
            solve();
            out.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    String nextToken() throws IOException {
        while (sc == null || !sc.hasMoreTokens()) {
            try {
                sc = new StringTokenizer(br.readLine());
            } catch (Exception e) {
                return null;
            }
        }
        return sc.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

}",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.io.InputStreamReader;
import java.io.FileNotFoundException;
import java.io.File;
import java.util.StringTokenizer;
import java.io.Writer;
import java.io.BufferedReader;
import java.io.UnsupportedEncodingException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author MaxHeap
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, FastReader in, OutputWriter out) {
            int n = in.nextInt();
            double r = in.nextInt();
            double[] x = new double[n];
            for (int i = 0; i < n; i++) {
                x[i] = in.nextDouble();
            }
            double[] ans = new double[n];
            ans[0] = r;
            for (int i = 1; i < n; i++) {
                ans[i] = r;
                double maxY = 0;
                for (int j = 0; j < i; j++) {
                    if (Math.abs(x[j] - x[i]) <= 2.0 * r) {
                        double y = ans[j] + Math.sqrt(4 * r * r - (x[j] - x[i]) * (x[j] - x[i]));
                        ans[i] = Math.max(ans[i], y);
                    }
                }
            }
            for (int i = 0; i < n; i++) {
                if (i > 0) out.print("" "");
                out.printf(""%.8f"", ans[i]);
            }
        }

    }

    static class FastReader {
        BufferedReader reader;
        StringTokenizer st;

        public FastReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream));
            st = null;
        }

        public String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    String line = reader.readLine();
                    if (line == null) {
                        return null;
                    }
                    st = new StringTokenizer(line);
                } catch (Exception e) {
                    throw new RuntimeException();
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }

    }

    static class OutputWriter extends PrintWriter {
        public OutputWriter(OutputStream os, boolean autoFlush) {
            super(os, autoFlush);
        }

        public OutputWriter(Writer out) {
            super(out);
        }

        public OutputWriter(Writer out, boolean autoFlush) {
            super(out, autoFlush);
        }

        public OutputWriter(String fileName) throws FileNotFoundException {
            super(fileName);
        }

        public OutputWriter(String fileName, String csn) throws FileNotFoundException, UnsupportedEncodingException {
            super(fileName, csn);
        }

        public OutputWriter(File file) throws FileNotFoundException {
            super(file);
        }

        public OutputWriter(File file, String csn) throws FileNotFoundException, UnsupportedEncodingException {
            super(file, csn);
        }

        public OutputWriter(OutputStream out) {
            super(out);
        }


        public void flush() {
            super.flush();
        }


        public void close() {
            super.close();
        }

    }
}

",5,5
"import java.util.*;

public class C {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        int n, r;
        n = scan.nextInt();
        r = scan.nextInt();

        int[] locs = new int[n];

        for (int i = 0; i < n; i++) {
            locs[i] = scan.nextInt();
        }

        double[] yPos = new double[n];
        Arrays.fill(yPos, 10e100);

        yPos[0] = r;
        for (int i = 1; i < n; i++) {
            double pos = r;
            for (int j = 0; j < i; j++) {
                int xDist = Math.abs(locs[i] - locs[j]);
                if (xDist <= 2 * r) {
                    double y = (2.0 * r) * (2.0 * r) - (xDist * xDist);
                    if (Math.abs(y - 0.0) < 0.0000000001) {
                        y = 0;
                    } else {
                        y = Math.sqrt(y);
                    }
                    y += yPos[j];
                    pos = Math.max(pos, y);

                } else {
                    continue;
                }
            }
            yPos[i] = pos;
        }
        String[] ans = new String[n];

        for (int i = 0; i < n; i++) {
            ans[i] = """" + yPos[i];
        }

        System.out.println(String.join("" "", ans));

    }
}",5,5
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Scanner;
import java.util.*;


public class Main {


    public static void main(String[] args) throws IOException{
        Scanner sc = new Scanner();
        PrintWriter out = new PrintWriter(System.out);

        int N = sc.nextInt(), R = sc.nextInt();
        double answer[] = new double[N];
        int[] x = new int[N];

        for (int i = 0; i < N; i++)
            x[i] = sc.nextInt();

        for (int i = 0; i < N; i++) {
            answer[i] = R;
            for (int j = 0; j < i; j++) {
                int dist = Math.abs(x[i] - x[j]);
                if(dist <= 2 * R) {
                    double t = answer[j] + Math.sqrt(4 * R * R - dist * dist);
                    answer[i] = Math.max(answer[i], t);
                }
            }
        }
        for(int i = 0; i < N; ++i)
            out.print(answer[i] + "" "");

        out.println();

        out.flush();
        out.close();
    }


    static class Scanner {
        BufferedReader br;
        StringTokenizer st;

        Scanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() throws IOException {
            while (st == null || !st.hasMoreTokens()) {
                st = new StringTokenizer(br.readLine());
            }
            return st.nextToken();
        }

        int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        String nextLine() throws IOException {
            return br.readLine();
        }

    }
    }
",5,5
"import java.util.*;
import java.io.*;
import java.math.*;

public class C{
	
	static int n;
	static double sqr(double v) {return (v*v);}
	static double sqrt(double v) {return Math.sqrt(v);}
	static double r,x[],res[];
	static void MainMethod()throws Exception{
		n=reader.nextInt();
		r=reader.nextDouble();
		int i,j;
		x=new double[n];
		res=new double[n];
		for (i=0;i<n;i++)x[i]=reader.nextDouble();
		res[0]=r;
		for (i=1;i<n;i++) {
			res[i]=r;
			for (j=0;j<i;j++) {
				if (Math.abs(x[i]-x[j])<=(2*r)) {
					res[i]=Math.max(res[i], 
							sqrt(sqr(2*r)-sqr(x[i]-x[j]))+res[j]
							);
				}
			}
		}
		for (i=0;i<n;i++)
			printer.print(res[i]+"" "");
	}
	public static void main(String[] args)throws Exception{
		MainMethod();
		printer.close();
	}
	static void halt(){
		printer.close();
		System.exit(0);
	}
	static PrintWriter printer=new PrintWriter(new OutputStreamWriter(System.out));
	static class reader{
		static BufferedReader bReader=new BufferedReader(new InputStreamReader(System.in));
		static StringTokenizer token=new StringTokenizer("""");
		static String readNextLine() throws Exception{
			return bReader.readLine();
		}
		static String next() throws Exception{
			while (token.hasMoreTokens()==false){
				token=new StringTokenizer(bReader.readLine());
			}
			return token.nextToken();
		}
		static int nextInt()throws Exception{
			while (token.hasMoreTokens()==false){
				token=new StringTokenizer(bReader.readLine());
			}
			return Integer.parseInt(token.nextToken());
		}
		static long nextLong()throws Exception{
			while (token.hasMoreTokens()==false){
				token=new StringTokenizer(bReader.readLine());
			}
			return Long.parseLong(token.nextToken());
		}
		static double nextDouble()throws Exception{
			while (token.hasMoreTokens()==false){
				token=new StringTokenizer(bReader.readLine());
			}
			return Double.parseDouble(token.nextToken());
		}
	}
	static class MyMathCompute{
		static long [][] MatrixMultiplyMatrix(long [][] A, long [][] B, long mod) throws Exception{
			int n=A.length, m=B[0].length; 
			int p=A[0].length;
			int i,j,k;
			if (B.length!=p) throw new Exception(""invalid matrix input"");
			long [][] res=new long [n][m];
			for (i=0;i<n;i++) for (j=0;j<m;j++){
				if (A[i].length!=p) throw new Exception(""invalid matrix input"");
				res[i][j]=0;
				for (k=0;k<p;k++)
					res[i][j]=(res[i][j]+((A[i][k]*B[k][j])% mod))% mod;
			}
			return res;
		}
		static double [][] MatrixMultiplyMatrix(double [][] A, double [][] B ) throws Exception{
			int n=A.length, m=B[0].length; 
			int p=A[0].length;
			int i,j,k;
			if (B.length!=p) throw new Exception(""invalid matrix input"");
			double [][] res=new double [n][m];
			for (i=0;i<n;i++) for (j=0;j<m;j++){
				if (A[i].length!=p) throw new Exception(""invalid matrix input"");
				res[i][j]=0;
				for (k=0;k<p;k++)
					res[i][j]=res[i][j]+(A[i][k]*B[k][j]);
			}
			return res;
		}
		static long [][] MatrixPow(long [][] A,long n, long mod) throws Exception{
			if (n==1) return A;
			long [][] res=MatrixPow(A, n/2, mod);
			res=MatrixMultiplyMatrix(res, res, mod);
			if ((n % 2) == 1) res=MatrixMultiplyMatrix(A,res, mod);		
			return res;
		}
		static double [][] MatrixPow(double [][] A,long n) throws Exception{
			if (n==1) return A;
			double[][] res=MatrixPow(A, n/2);
			res=MatrixMultiplyMatrix(res, res);
			if ((n % 2) == 1) res=MatrixMultiplyMatrix(A,res);		
			return res;
		}
		static long pow(long a,long n,long mod){
			a= a % mod;
			if (n==0) return 1;
			long k=pow(a,n/2,mod);
			if ((n % 2)==0) return ((k*k)%mod);
			else return (((k*k) % mod)*a) % mod;
		}
		static double pow(double a,long n){
			if (n==0) return 1;
			double k=pow(a,n/2);
			if ((n % 2)==0) return (k*k);
			else return (((k*k) )*a) ;
		}
	}
}
",5,1
"import java.util.*;
import java.io.*;
public class C
{
   static long time = System.currentTimeMillis();
   public static void main(String[] args) throws IOException
   {
      //FastReader infile = new FastReader(""test.txt"");
      FastReader infile = new FastReader(System.in);
      int N = infile.nextInt();
      int R = infile.nextInt();
      double[] xPos = new double[N];
      for(int x = 0; x < N; x++)
         xPos[x] = infile.nextDouble();
      double[] yPos = new double[N];
      Arrays.fill(yPos, R);
      for(int x = 1; x < N; x++)
      {
         for(int y = 0; y < x; y++)
            if(Math.abs(xPos[x]-xPos[y])<=2*R)
            {
               yPos[x] = Math.max(yPos[x], yPos[y]+Math.sqrt((2*R)*(2*R)-Math.abs(xPos[x]-xPos[y])*Math.abs(xPos[x]-xPos[y])));
            }
      }
      System.out.print(yPos[0]);
      for(int x = 1; x < N; x++)
         System.out.print("" ""+yPos[x]);
      //System.out.println(System.currentTimeMillis()-time);
   }
}
class FastReader
{
   BufferedReader br;
   StringTokenizer st;

   public FastReader(String file) throws IOException
   {
      br = new BufferedReader(new FileReader(file));
   }
 
   public FastReader(InputStream i) throws IOException
   {
      br = new BufferedReader(new InputStreamReader(System.in));
   }
   boolean hasNext()
   {
      while (st == null || !st.hasMoreElements())
      {
         try
         {
            st = new StringTokenizer(br.readLine());
         }
         catch (Exception  e)
         {
            return false;
         }
      }
      return true;
   }
 
   String next()
   {
      while (st == null || !st.hasMoreElements())
      {
         try
         {
            st = new StringTokenizer(br.readLine());
         }
         catch (IOException  e)
         {
            e.printStackTrace();
         }
      }
      return st.nextToken();
   }
 
   int nextInt()
   {
      return Integer.parseInt(next());
   }
 
   long nextLong()
   {
      return Long.parseLong(next());
   }
 
   double nextDouble()
   {
      return Double.parseDouble(next());
   }
 
   String nextLine()
   {
      String str = """";
      try
      {
         str = br.readLine();
      }
      catch (IOException e)
      {
         e.printStackTrace();
      }
      return str;
   }
}",5,5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Scanner;
import java.util.StringTokenizer;

import java.util.*;
import static java.lang.Math.*;

public class ProblemC {
	public static void main(String[] args) {
		FastScanner input = new FastScanner();
		int n = input.nextInt();
		int radius = input.nextInt();
		ArrayList<Integer> diskXToFall = new ArrayList<Integer>();
		for (int a = 0; a < n; a++) {
			diskXToFall.add(input.nextInt());
		}
		ArrayList<P> stationaryDisks = new ArrayList<P>();
		for (int a = 0; a < n; a++) {
			double highCollision = radius;
			for (P i : stationaryDisks) {
				if (Math.abs(diskXToFall.get(a) - i.x) - 1e-8 <= 2 * radius) {
					double hypot = 2 * radius;
					double leg = Math.abs(diskXToFall.get(a) - i.x);
					double yOffset = Math.sqrt(Math.abs(hypot * hypot - leg * leg));
					highCollision = Math.max(highCollision, yOffset + i.y);
				}
			}
			stationaryDisks.add(new P(diskXToFall.get(a), highCollision));
		}
		for(int a = 0; a < n; a++) {
			System.out.print(stationaryDisks.get(a).y + "" "");
		}
		

	}

	static class P implements Comparable<P> {
		final double x, y;

		P(double x, double y) {
			this.x = x;
			this.y = y;
		}

		P sub(P that) {
			return new P(x - that.x, y - that.y);
		}

		P add(P that) {
			return new P(x + that.x, y + that.y);
		}

		double dot(P that) {
			return x * that.x + y * that.y;
		}

		P scale(double s) {
			return new P(x * s, y * s);
		}

		// Use hypot() only if intermediate overflow must be avoided; very slow
		double length() {
			return sqrt(x * x + y * y);
		}

		double length2() {
			return x * x + y * y;
		}

		P leftNormal() {
			return new P(-y, x);
		} // rotateCCW(90deg)

		P rightNormal() {
			return new P(y, -x);
		} // rotateCW(90deg)

		P normalize() {
			double n = length();
			return n > 0 ? new P(x / n, y / n) : origin();
		}

		P scaleToLength(double l) {
			return normalize().scale(l);
		}

		P project(P a) {
			return scale(a.dot(this) / length2());
		}

		P reflect(P a) {
			return project(a).scale(2.0).sub(a);
		}

		// use if sin, cos are known
		P rotateCCW(double sinT, double cosT) {
			return new P(x * cosT - y * sinT, x * sinT + y * cosT);
		}

		P rotateCW(double sinT, double cosT) {
			return rotateCCW(-sinT, cosT);
		}

		P rotate(double theta) {
			return rotateCCW(sin(theta), cos(theta));
		}

		// angle to horizontal (1, 0); result is in [-pi, pi] rad or (-180-180) deg
		double theta() {
			return atan2(y, x);
		}

		// angle between two vectors, result is in [0, pi] rad (0-180 deg)
		double angleTo(P a) {
			return acos(this.dot(a) / this.length() / a.length());
		}

		boolean isOrigin() {
			return x == 0 && y == 0;
		}

		public String toString() {
			return String.format(""(%f,%f)"", this.x, this.y);
		}

		static P read(Scanner s) {
			return new P(s.nextDouble(), s.nextDouble());
		}

		static P origin() {
			return new P(0, 0);
		}

		double det(P that) {
			return this.x * that.y - this.y * that.x;
		}

		double crossproduct(P that) {
			return this.det(that);
		}

		P half(P q) {
			return normalize().add(q.normalize());
		}

		double dist(P to) {
			return sub(to).length();
		}

		double signedParallelogramArea(P b, P c) {
			return (b.sub(this).crossproduct(c.sub(this)));
		}

		boolean isCollinearWith(P b, P c) {
			return abs(signedParallelogramArea(b, c)) <= EPS;
		}

		// is going from this to b to c a CCW turn? Do not use if points may be
		// collinear
		boolean isCCW(P b, P c) {
			return signedParallelogramArea(b, c) > 0;
		}

		double signedTriangleArea(P b, P c) {
			return signedParallelogramArea(b, c) / 2.0;
		}

		// memory-optimized version of this.sub(to).length2() that avoids an
		// intermediate object
		double dist2(P to) {
			double dx = this.x - to.x;
			double dy = this.y - to.y;
			return dx * dx + dy * dy;
		}

		/**
		 * Compute x for a * x + b = 0 and ||x|| = C where 'this' is a. Care must be
		 * taken to handle the case where either a.x or a.y is near zero.
		 */
		P[] solveDotProductConstrainedByNorm(double b, double C) {
			P a = this;
			if (a.isOrigin())
				throw new Error(""degenerate case"");

			boolean transpose = abs(a.x) > abs(a.y);
			a = transpose ? new P(a.y, a.x) : a;

			Double[] x = solvequadratic(a.length2(), 2.0 * b * a.x, b * b - a.y * a.y * C * C);
			P[] p = new P[x.length];
			for (int i = 0; i < x.length; i++) {
				double x1 = x[i];
				double x2 = ((-b - a.x * x1) / a.y);
				p[i] = transpose ? new P(x2, x1) : new P(x1, x2);
			}
			return p;
		}

		@Override
		public int compareTo(P that) {
			if (abs(this.x - that.x) > EPS)
				return Double.compare(this.x, that.x);
			return Double.compare(this.y, that.y);
		}
	}

	static class HP extends P { // Hashable Point
		HP(double x, double y) {
			super(x, y);
		}

		@Override
		public int hashCode() {
			return Double.hashCode(x + 32768 * y);
		}

		@Override
		public boolean equals(Object _that) {
			HP that = (HP) _that;
			return this.x == that.x && this.y == that.y;
		}
	}

	/**
	 * Sort points by polar angle relative to center, using trig. This is a
	 * counter-clockwise sort with zero at 3 o'clock.
	 */
	static Comparator<P> makePolarAngleComparatorTrig(final P center) {
		return new Comparator<P>() {
			public int compare(P a, P b) {
				double thetaa = a.sub(center).theta();
				double thetab = b.sub(center).theta();
				if (thetaa < 0)
					thetaa += 2 * PI;
				if (thetab < 0)
					thetab += 2 * PI;
				int c = Double.compare(thetaa, thetab);
				if (c != 0)
					return c;
				return Double.compare(b.x, a.x); // arbitrary tie-breaker
			}
		};
	}

	/**
	 * Sort points by polar angle relative to center, w/o trig. This is a
	 * counter-clockwise sort with zero at 3 o'clock.
	 */
	static Comparator<P> makePolarAngleComparator(final P center) {
		return new Comparator<P>() {
			public int compare(P a, P b) {
				// orientation() requires that a and b lie in the same half-plane
				if (a.y >= center.y && b.y < center.y)
					return -1;
				if (b.y >= center.y && a.y < center.y)
					return 1;
				int orientation = (int) Math.signum(center.signedParallelogramArea(b, a));
				if (orientation != 0)
					return orientation;
				return Double.compare(b.x, a.x); // arbitrary tie-breaker
			}
		};
	}

	/*
	 * Solve a * x^2 + b * x + c == 0 Returns 0, 1, or 2 solutions. If 2 solutions
	 * x1, x2, guarantees that x1 < x2
	 */
	static Double[] solvequadratic(double a, double b, double c) {
		double D = b * b - 4 * a * c;
		if (D < -EPS)
			return new Double[] {};
		D = max(D, 0);
		if (D == 0)
			return new Double[] { -b / 2.0 / a };
		double d = sqrt(D);
		// Numerically more stable, see
		// XXXX
		if (signum(b) == 0)
			return new Double[] { d / 2.0 / a, -d / 2.0 / a };
		double x1 = (-b - signum(b) * d) / (2 * a);
		double x2 = c / (a * x1);
		return new Double[] { Math.min(x1, x2), Math.max(x1, x2) };
	}

	/*
	 * The Line/Circle classes provide a number of methods that require dealing with
	 * floating point precision issues. Default EPS to a suitable value, such as
	 * 1e-6, which should work for many problems in which the input coordinates are
	 * in integers and subsequently inexact floating point values are being
	 * computed.
	 */
	static double EPS = 1e-6;

	/*
	 * A line denoted by two points p and q. For internal computations, we use the
	 * parametric representation of the line as p + t d where d = q - p. For
	 * convenience, we compute and store d in the constructor. Most methods hide the
	 * parametric representation of the line, but it is exposed via
	 * getPointFromParameter and intersectionParameters for those problems that need
	 * it.
	 *
	 * The line may be interpreted either as a line segment denoted by the two end
	 * points, or as the infinite line determined by these two points. Intersection
	 * methods are provided for both cases.
	 */
	static class Line {
		P p, q, d;

		Line(P p, P q) {
			this.p = p;
			this.q = q;
			d = q.sub(p);
		}

		P getPointFromParameter(double t) {
			return p.add(d.scale(t));
		}

		// reflect vector across vector (as if line originated at (0, 0))
		P reflect(P d2) {
			return d.reflect(d2);
		}

		// reflect point across (infinite) line
		P reflectPoint(P r) {
			return reflect(r.sub(p)).add(p);
		}

		// project p onto this (infinite) line. Returns point on line
		P project(P a) {
			return p.add(d.project(a.sub(p)));
		}

		// return distance of point P from this (infinite) line.
		double distance(P a) {
			return project(a).dist(a);
		}

		@Override
		public String toString() {
			return String.format(""[%s => %s]"", p, q);
		}

		/*
		 * Point of intersection of this line segment with another line segment. Returns
		 * only points that lie inside both line segments, else null.
		 *
		 * Result may include points ""just outside"" the bounds, given EPS.
		 */
		P intersectsInBounds(Line l) {
			double[] st = intersectionParameters(l);
			if (st == null)
				return null;

			// check that point of intersection is in direction 'd'
			// and within segment bounds
			double s = st[0];
			double t = st[1];
			if (s >= -EPS && s <= 1 + EPS && -EPS <= t && t <= 1 + EPS)
				return getPointFromParameter(s);

			return null;
		}

		/*
		 * Point of intersection of this (infinite) line with other (infinite) line.
		 * Return null if collinear.
		 */
		P intersects(Line l) {
			double[] st = intersectionParameters(l);
			if (st != null)
				return getPointFromParameter(st[0]);
			return null;
		}

		/*
		 * Intersect this line with that line Solves: this.p + s * this.d == l.p + t l.d
		 * Return null if lines are collinear Else returns [s, t].
		 */
		double[] intersectionParameters(Line l) {
			P dneg = p.sub(q);
			double D = l.d.det(dneg);
			// Use Cramer's rule; see text
			if (D == 0.0)
				return null;

			P rp = p.sub(l.p);
			return new double[] { l.d.det(rp) / D, rp.det(dneg) / D };
		}

		/*
		 * Compute points of intersection of this infinite line with a circle. Computes
		 * projection 'x' of c.c onto line, then computes x +/- d.scaleToLength(h) where
		 * h is computed via Pythagoras. Sorted by decreasing 't' (as would be used in
		 * getPointFromParameter)
		 *
		 * May return two points even if line is a tangent.
		 */
		P[] intersectsCircle(Circle c) {
			P x = project(c.c);
			double D = x.dist(c.c);
			// outside by more than EPS
			if (D > c.R + EPS)
				return new P[0];
			double h = sqrt(max(0, c.R * c.R - D * D));
			if (h == 0)
				return new P[] { x }; // EPS (!?)
			return new P[] { x.add(d.scaleToLength(h)), x.add(d.scaleToLength(-h)) };
		}

		/*
		 * Compute points of intersection of this infinite line with a circle.
		 *
		 * Solves a + t * b = c + r subject to ||r|| = R Returns zero, one, or two
		 * points on the periphery, e.g. c + r[0,1], sorted by decreasing 't'.
		 * Alternative version which requires solving quadratic equation.
		 *
		 * Careful: set EPS if you need to handle round-off error in discriminant.
		 */
		P[] intersectsCircleAlternative(Circle c) {
			P ca = c.c.sub(p);
			P d = q.sub(p);
			Double[] t = solvequadratic(d.length2(), -2 * d.dot(ca), ca.length2() - c.R * c.R);
			P[] r = new P[t.length];
			for (int i = 0; i < t.length; i++)
				r[i] = p.add(d.scale(t[i]));
			return r;
		}

		/**
		 * Is r contained within the line segment spanned by p/q, including their
		 * endpoints?
		 */
		boolean isInBounds(P r) {
			return abs(p.dist(q) - p.dist(r) - q.dist(r)) <= EPS;
		}

		/**
		 * Is r on the infinite line?
		 */
		boolean isOnLine(P r) {
			return r.isCollinearWith(p, q);
		}
	}

	/**
	 * Alternative line implementation using the ""general form"" equation.
	 *
	 * a * x + b * y + c = 0
	 *
	 * This is provided for problems in which a line may be given in general form in
	 * the input. Compared to class Line, GLine: - is shorter, particularly when
	 * only line/line and line/circle intersections are required. - does not support
	 * those functions of Line that relate to LineSegment.
	 */
	static class GLine {
		// we represent a, b as a vector to benefit from the available dot/det routines.
		P n; // n = new P(a, b) --- this is the (right) normal vector to the line
		double c;

		GLine(double a, double b, double c) {
			this.n = new P(a, b);
			if (a == 0 && b == 0)
				throw new Error(""a and b cannot both be zero"");
			this.c = c;
		}

		GLine(P p, P q) {
			this(p.y - q.y, q.x - p.x, p.det(q));
		}

		P intersects(GLine that) {
			double D = n.det(that.n);
			if (D == 0.0)
				return null;
			return new P((this.n.y * that.c - that.n.y * this.c) / D, (that.n.x * this.c - this.n.x * that.c) / D);
		}

		double signedDistance(P p) {
			return (n.dot(p) + c) / n.length();
		}

		double distance(P p) {
			return abs(signedDistance(p));
		}

		// checks if on (infinite) line.
		boolean isOnLine(P p) {
			return signedDistance(p) <= EPS;
		}

		// checks if on the same side, no EPS
		boolean onSameSide(P p, P q) {
			return signum(signedDistance(p)) == signum(signedDistance(q));
		}

		// angle of inclination to horizontal; result is in [0, pi] rad
		// XXX untested
		double theta() {
			double angle = atan2(n.x, -n.y);
			return angle < 0 ? (angle + PI) : angle;
		}

		// XXX untested
		boolean parallelWith(GLine that) {
			return n.det(that.n) <= EPS;
		}

		// XXX untested
		boolean perpendicularTo(GLine that) {
			return n.dot(that.n) <= EPS;
		}

		// circle-line intersection, refactored from
		// XXXX
		P[] intersectsCircle(Circle C) {
			// shift line to center, this is undone by adding C.c before returning.
			double c = n.dot(C.c) + this.c;
			double n2 = n.length2();
			double r = C.R;

			P p = n.scale(-c / n2).add(C.c); // undo shift to center
			if (c * c > r * r * n2 + EPS) {
				return new P[] {};
			} else if (abs(c * c - r * r * n2) < EPS) {
				return new P[] { p };
			} else {
				double d = r * r - c * c / n2;
				double m = sqrt(d / n2);
				P q = n.rightNormal().scale(m);
				return new P[] { p.add(q), p.sub(q) };
			}
		}

		@Override
		public String toString() {
			return String.format(""Line:(n=%s C=%f)"", n, c);
		}
	}

	static class Circle {
		P c;
		double R;

		Circle(P c, double R) {
			this.c = c;
			this.R = R;
		}

		@Override
		public String toString() {
			return String.format(""{%s, %.03f}"", c, R);
		}

		/* Is this point inside the circle */
		boolean isInside(P p) {
			return R > p.dist(c) - EPS;
		}

		/* Is this point on the circle's periphery */
		boolean isOnCircle(P p) {
			return abs(p.dist(c) - R) <= EPS;
		}

		/*
		 * a line segment is outside a circle if both end points are outside and if any
		 * intersection points are outside the bounds of the line segment.
		 */
		boolean isOutside(Line l) {
			if (isInside(l.p) || isInside(l.q))
				return false;
			P[] _is = l.intersectsCircle(this);
			if (_is.length > 1)
				for (P is : _is)
					if (l.isInBounds(is))
						return false;
			return true;
		}

		/* Returns the tangent lines that the point p makes with this circle, if any. */
		Line[] tangentLines(P p) {
			// Let c +/- r be the tangent points. Then there's a 'd' such that
			// p + d - r = c
			// Since d r = 0, we multiply by r and get
			// (p - c) r - ||r|| = 0 subject to ||r|| = R
			P[] r = p.sub(c).solveDotProductConstrainedByNorm(-R * R, R);
			Line[] tangents = new Line[r.length];
			for (int i = 0; i < tangents.length; i++)
				tangents[i] = new Line(p, c.add(r[i]));
			return tangents;
		}

		/*
		 * Compute points of intersection of this circle (c1, r1) with that circle (c2,
		 * r2). Model as triangle equation m = c2 - c1 = r1 - r2 m = r1 - r2 -> m^2 =
		 * r1^2 + r2^2 - 2 r1 r2 (squaring) -> r1 r2 = (r1^2 + r2^2 - m^2)/2 and by
		 * multiplying by r1 we obtain m = r1 - r2 -> m r1 = r1^2 - r1 r2 -> m r1 = r1^2
		 * - (r1^2 + r2^2 - m^2)/2 -> m r1 + (r2^2 - r1^2 - m^2)/2 = 0 and ready for
		 * solveDotProductConstrainedByNorm
		 *
		 * Note that if the circles are (apprx) touching, this function may return 0, 1,
		 * or 2 intersection points, depending on which side of 0 the discriminant
		 * falls. You will not get NaN.
		 *
		 * If the circles coincidence (same center and radius) this will throw an
		 * 'degenerate case' error in solveDotProductConstrainedByNorm !!!
		 */
		P[] intersectsCircle(Circle that) {
			double r1 = this.R;
			double r2 = that.R;
			P m = that.c.sub(this.c);
			P[] r1sol = m.solveDotProductConstrainedByNorm((r2 * r2 - r1 * r1 - m.length2()) / 2, r1);
			// compute [c +/- r1] to obtain intersection points
			P[] is = new P[r1sol.length];
			for (int i = 0; i < r1sol.length; i++)
				is[i] = this.c.add(r1sol[i]);
			return is;
		}

		/*
		 * Shorter version of intersectsCircle that solves quadratic equation inline.
		 * Assumes there are 2 intersection points. The vector 'mid' is where the
		 * altitude of the triangle formed by the centers and the intersection point
		 * hits the line connecting the centers. Its length is e. midn is normal to it
		 * and its length is f.
		 */
		P[] intersectsCircleAlternative(Circle that) {
			P m = that.c.sub(this.c);
			double b = this.R * this.R;
			// div-by-zero if circles share center
			double e = (m.length2() + b - that.R * that.R) / 2 / m.length();
			double f = sqrt(b - e * e); // NaN if circles don't intersect
			P[] is = new P[2];
			P mid = this.c.add(m.scaleToLength(e));
			P midn = m.rightNormal();
			for (int i = 0; i < is.length; i++) {
				is[i] = mid.add(midn.scaleToLength(f));
				f *= -1;
			}
			return is;
		}

		// returns true if this circle is outside that circle
		boolean isOutside(Circle that) {
			return this.c.dist(that.c) > (this.R + that.R);
		}

		// returns true if this circle is entirely contained inside that circle
		boolean isContainedIn(Circle that) {
			// extend line from that.c to this.c by radius R
			P m = this.c.sub(that.c);
			return that.isInside(this.c.add(m.scaleToLength(this.R)));
		}

		/* Construct smallest circle that circumscribes 2 points a and b. */
		static Circle getCircumCircle(P a, P b) {
			P c = a.add(b).scale(.5);
			return new Circle(c, c.dist(a));
		}

		/* Construct circle circumscribed by 3 points a, b, c */
		static Circle getCircumCircle(P a, P b, P c) {
			P B = b.sub(a);
			P C = c.sub(a);
			double d = 2 * B.crossproduct(C);
			if (abs(d) < EPS) // points are collinear
				return getCircumCircle(new P(min(a.x, min(b.x, c.x)), min(a.y, min(b.y, c.y))),
						new P(max(a.x, max(b.x, c.x)), max(a.y, max(b.y, c.y))));

			double z1 = B.length2();
			double z2 = C.length2();
			P cc = new P(C.y * z1 - B.y * z2, B.x * z2 - C.x * z1).scale(1.0 / d);
			return new Circle(cc.add(a), cc.length());
		}

		/*
		 * Find minimum enclosing circle for a set of points. Peter, we need a source
		 * for this algorithm and its expected complexity.
		 */
		static Circle minEnclosingCircle(P[] p) {
			if (p.length == 0)
				return new Circle(new P(0, 0), 0);
			if (p.length == 1)
				return new Circle(p[0], 0);
			Collections.shuffle(Arrays.asList(p));
			Circle circle = getCircumCircle(p[0], p[1]);
			for (int i = 2; i < p.length; i++) {
				if (!circle.isInside(p[i])) {
					circle = getCircumCircle(p[0], p[i]);
					for (int j = 1; j < i; j++) {
						if (!circle.isInside(p[j])) {
							circle = getCircumCircle(p[j], p[i]);
							for (int k = 0; k < j; k++) {
								if (!circle.isInside(p[k])) {
									circle = getCircumCircle(p[i], p[j], p[k]);
								}
							}
						}
					}
				}
			}
			return circle;
		}
	}

	/**
	 * Some basic operations on Polygons.
	 */
	static class Polygon {
		P[] p; // open form, p[0] connects to p[n-1]

		// Constructors clone original array/collection
		Polygon(Collection<P> c) {
			this.p = c.toArray(new P[c.size()]);
		}

		Polygon(P[] p) {
			this.p = (P[]) p.clone();
		}

		/* Absolute of signed triangle areas */
		double signedArea() {
			double area = 0.0;
			for (int i = 0; i < p.length; i++) {
				area += p[i].det(p[(i + 1) % p.length]);
			}
			return area / 2.0;
		}

		double absoluteArea() {
			return abs(signedArea());
		}

		/*
		 * Returns an P[] array representing an open shape that is the convex hull of
		 * the given array of points, or null if less than 2 points were given.
		 */
		public Polygon convexHull() {
			if (p.length < 2)
				return null;

			// (0) find the lowest point, breaking ties to the right
			final P min = Collections.min(Arrays.asList(p), new Comparator<P>() {
				public int compare(P p1, P p2) {
					int y = Double.valueOf(p1.y).compareTo(p2.y);
					return y != 0 ? y : Double.valueOf(p1.x).compareTo(p2.x);
				}
			});

			// (1) sort points by angle from pivot
			Arrays.sort(p, new Comparator<P>() {
				public int compare(P p1, P p2) {
					double o = min.signedParallelogramArea(p1, p2); // crossproduct
					if (o != 0)
						return -(int) Math.signum(o);

					// if collinear, use distance to break tie
					return Double.valueOf(min.dist(p1)).compareTo(min.dist(p2));
				}
			});

			// (3) create stack
			Stack<P> hull = new Stack<P>();
			assert p[0] == min;
			hull.push(p[0]);
			hull.push(p[1]);

			// (4) select points that maintain left turns
			for (int i = 2; i < p.length; i++) {
				P next = p[i];
				while (hull.size() >= 2) {
					P snd = hull.get(hull.size() - 2);
					P top = hull.peek();
					if (snd.isCCW(top, next)) // keep
						break;

					hull.pop(); // discard
				}
				// keep current point
				hull.push(next);
			}
			return new Polygon(hull);
		}

		/*
		 * ""Point-in-Polygon"" PIP tests. Return true if point is contained in this
		 * polygon
		 *
		 * All of these tests may return 0 or 1 for points on the boundary. A separate
		 * test is required to determine if a point is on the boundary.
		 */
		public boolean contains(P q) {
			return contains_WN(q);
		}

		/*
		 * Crossing-number based algorith due to Wm. Randolph Franklin. Works only for
		 * simple polygons.
		 */
		private boolean contains_CN(P q) {
			boolean c = false;
			for (int i = 0, j = p.length - 1; i < p.length; j = i++) {
				if ((((p[i].y <= q.y) && (q.y < p[j].y)) || ((p[j].y <= q.y) && (q.y < p[i].y)))
						&& (q.x < (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y) + p[i].x))
					c = !c;
			}
			return c;
		}

		/*
		 * Winding numbers based algorithm, which also works for self-intersecting
		 * polygons. XXXX describes this as the
		 * always preferred algorithm.
		 *
		 * Return: wn = the winding number (=0 only when P is outside)
		 */
		public boolean contains_WN(P q) {
			int wn = 0; // the winding number counter

			// loop through all edges of the polygon
			int n = p.length;
			for (int i = 0; i < n; i++) { // edge from V[i] to V[i+1]
				P p = this.p[i], pn = this.p[(i + 1) % n];
				if (p.y <= q.y) { // start y <= P.y
					if (pn.y > q.y) // an upward crossing
						if (p.isCCW(pn, q)) // P left of edge
							++wn; // have a valid up intersect
				} else { // start y > P.y (no test needed)
					if (pn.y <= q.y) // a downward crossing
						if (!p.isCCW(pn, q)) // P right of edge
							--wn; // have a valid down intersect
				}
			}
			return wn != 0;
		}

		/**
		 * Is q on the boundary of this polygon?
		 */
		public boolean onBoundary(P q) {
			int n = p.length;
			for (int i = 0; i < n; i++) {
				P pi = this.p[i], pj = this.p[(i + 1) % n];
				if (new Line(pi, pj).isInBounds(q))
					return true;
			}
			return false;
		}

		@Override
		public String toString() {
			return Arrays.toString(p);
		}
	}

	public static class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		public FastScanner(Reader in) {
			br = new BufferedReader(in);
		}

		public FastScanner() {
			this(new InputStreamReader(System.in));
		}

		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		String readNextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}

		int[] readIntArray(int n) {
			int[] a = new int[n];
			for (int idx = 0; idx < n; idx++) {
				a[idx] = nextInt();
			}
			return a;
		}

		long[] readLongArray(int n) {
			long[] a = new long[n];
			for (int idx = 0; idx < n; idx++) {
				a[idx] = nextLong();
			}
			return a;
		}
	}
}
",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskC solver = new TaskC();
		solver.solve(1, in, out);
		out.close();
	}

	static class TaskC {
		public void solve(int testNumber, InputReader in, PrintWriter out) {
			int n = in.nextInt();
			int r = in.nextInt();
			int[] x = new int[n];
			for (int i = 0; i < n; i++) {
				x[i] = in.nextInt();
			}
			double res = 0;
			double[] y = new double[n];

			for (int i = 0; i < n; i++) {
				double curY = r;
				for (int j = 0; j < i; j++) {
					int d = Math.abs(x[i] - x[j]);
					if (d <= 2 * r) {
						int a2 = 4 * r * r - d * d;
						curY = Math.max(curY, y[j] + Math.sqrt(a2));
					}
				}
				y[i] = curY;
				out.printf(""%.14f"", y[i]);
				if (i < n - 1) {
					out.print("" "");
				} else {
					out.println();
				}
			}
		}

	}

	static class InputReader {
		final InputStream is;
		final byte[] buf = new byte[1024];
		int pos;
		int size;

		public InputReader(InputStream is) {
			this.is = is;
		}

		public int nextInt() {
			int c = read();
			while (isWhitespace(c))
				c = read();
			int sign = 1;
			if (c == '-') {
				sign = -1;
				c = read();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = read();
			} while (!isWhitespace(c));
			return res * sign;
		}

		int read() {
			if (size == -1)
				throw new InputMismatchException();
			if (pos >= size) {
				pos = 0;
				try {
					size = is.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (size <= 0)
					return -1;
			}
			return buf[pos++] & 255;
		}

		static boolean isWhitespace(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

	}
}

",5,5
"

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class C {

	private static double r, EPS=1e-10;
	
	public static void solve(FastScanner fs) {	
		int n=fs.nextInt();
		r=fs.nextInt();
		int[] xCoords=fs.readArray(n);
		
		ArrayList<Point> placed=new ArrayList<>();
		for (int x:xCoords) {
			double maxY=r;
			for (Point p:placed)
				maxY=Math.max(maxY, getNewY(p, x));
			placed.add(new Point(x, maxY));
		}
		for (Point p:placed) {
			System.out.printf(""%.9f "", p.y);
		}
		
	}
	
	private static double getNewY(Point circleCenter, int x) {
		double dx=Math.abs(x-circleCenter.x);
		if (dx>r+r)
			return 0;
		if (dx<EPS)
			return circleCenter.y+r+r;
		double hypot=r+r;
		return circleCenter.y+Math.sqrt(hypot*hypot-(double)dx*dx);
	}

	
	static class Point {
		double x;
		double y;
		public Point(double x, double y) {
			this.x=x;
			this.y=y;
		}
 	}
	
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		FastScanner scanner = new FastScanner(System.in);
		solve(scanner);
	}
	

	private static class FastScanner {
		BufferedReader br;
		StringTokenizer st;
		public FastScanner(InputStream in) {
			br = new BufferedReader(new InputStreamReader(in));
		}
		String next() {
			while (st == null || !st.hasMoreElements()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}
		int nextInt() {
			return Integer.parseInt(next());
		}
		long nextLong() {
			return Long.parseLong(next());
		}
		double nextDouble() {
			return Double.parseDouble(next());
		}
		String nextLine() {
			String str = """";
			try {
				str = br.readLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return str;
		}
		int[] readArray(int n) {
			int[] a=new int[n];
			for (int i=0; i<n; i++)
				a[i]=nextInt();
			return a;
		}
		long[] readLongArray(int n) {
			long[] a=new long[n];
			for (int i=0; i<n; i++)
				a[i]=nextLong();
			return a;
		}
	}
}


",5,3
"import java.util.*;
import java.io.*;
import java.lang.*;
import java.math.*;

public class C {
	static double ycoord(double xi, double yi, double xj, double r) {
		if(Math.abs(xi-xj) > 2*r) return r;
		double dist = Math.sqrt((4*r*r)-((xi-xj)*(xi-xj)));
		//System.out.println(""dist"" + dist);
		return Math.max(yi+dist, r); //yi - dist?
	}
	public static void main(String[] args) throws Exception {
		FastScanner sc = new FastScanner();
		PrintWriter out = new PrintWriter(System.out);
		int n = sc.nextInt();
		double r = sc.nextInt();
		double[] xcoords = new double[n];
		double[] ycoords = new double[n];
		Arrays.fill(ycoords, Integer.MIN_VALUE);
		ycoords[0] = r;
		for(int i = 0; i < n; i++) {
			xcoords[i] = sc.nextDouble();
		}
		System.out.print(r + "" "");
		for(int i = 1; i < n; ++i) {
			for(int j = 0; j < i; j++) {
				ycoords[i] = Math.max(ycoord(xcoords[j], ycoords[j],xcoords[i],r),ycoords[i]);
			}
			System.out.print(ycoords[i] + "" "");
		}
		out.flush();
	}

	static class FastScanner {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public FastScanner() {
			reader = new BufferedReader(new InputStreamReader(System.in), 32768);
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public String nextLine() {
			try {
				return reader.readLine();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}

	}
}",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.Reader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        MyInput in = new MyInput(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, MyInput in, PrintWriter out) {
            int n = in.nextInt();
            int r = in.nextInt();
            int[] x = in.nextIntArray(n);
            double[] py = new double[n];
            for (int i = 0; i < n; i++) {
                double y = r;
                for (int j = 0; j < i; j++) {
                    int dx = Math.abs(x[i] - x[j]);
                    if (dx > 2 * r) continue;
                    y = Math.max(y, Math.sqrt(4 * r * r - dx * dx) + py[j]);
                }
                py[i] = y;
            }
            for (int i = 0; i < n; i++) {
                out.printf(""%.10f%s"", py[i], i == n - 1 ? ""\n"" : "" "");
            }
        }

    }

    static class MyInput {
        private final BufferedReader in;
        private static int pos;
        private static int readLen;
        private static final char[] buffer = new char[1024 * 8];
        private static char[] str = new char[500 * 8 * 2];
        private static boolean[] isDigit = new boolean[256];
        private static boolean[] isSpace = new boolean[256];
        private static boolean[] isLineSep = new boolean[256];

        static {
            for (int i = 0; i < 10; i++) {
                isDigit['0' + i] = true;
            }
            isDigit['-'] = true;
            isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;
            isLineSep['\r'] = isLineSep['\n'] = true;
        }

        public MyInput(InputStream is) {
            in = new BufferedReader(new InputStreamReader(is));
        }

        public int read() {
            if (pos >= readLen) {
                pos = 0;
                try {
                    readLen = in.read(buffer);
                } catch (IOException e) {
                    throw new RuntimeException();
                }
                if (readLen <= 0) {
                    throw new MyInput.EndOfFileRuntimeException();
                }
            }
            return buffer[pos++];
        }

        public int nextInt() {
            int len = 0;
            str[len++] = nextChar();
            len = reads(len, isSpace);
            int i = 0;
            int ret = 0;
            if (str[0] == '-') {
                i = 1;
            }
            for (; i < len; i++) ret = ret * 10 + str[i] - '0';
            if (str[0] == '-') {
                ret = -ret;
            }
            return ret;
        }

        public char nextChar() {
            while (true) {
                final int c = read();
                if (!isSpace[c]) {
                    return (char) c;
                }
            }
        }

        int reads(int len, boolean[] accept) {
            try {
                while (true) {
                    final int c = read();
                    if (accept[c]) {
                        break;
                    }
                    if (str.length == len) {
                        char[] rep = new char[str.length * 3 / 2];
                        System.arraycopy(str, 0, rep, 0, str.length);
                        str = rep;
                    }
                    str[len++] = (char) c;
                }
            } catch (MyInput.EndOfFileRuntimeException e) {
            }
            return len;
        }

        public int[] nextIntArray(final int n) {
            final int[] res = new int[n];
            for (int i = 0; i < n; i++) {
                res[i] = nextInt();
            }
            return res;
        }

        static class EndOfFileRuntimeException extends RuntimeException {
        }

    }
}

",5,5
"import java.util.*;
import java.io.*;
import java.math.*;
public class A{

    void solve(){
        int n=ni();
        long r=ni();
        int x[]=new int[n+1];
        for(int i=1;i<=n;i++) x[i]=ni();

        double ans[]=new double[n+1];
        ans[1]=r;
        for(int i=2;i<=n;i++){
            double mx=0;
            for(int j=1;j<i;j++) {
                double xx = Math.abs(x[i] - x[j]);
                if (xx > 2*r) {
                    mx = Math.max(mx,r);
                } else {
                    xx *= xx;
                     mx=Math.max(mx,ans[j] + Math.sqrt(4 * r * r - xx));
                    // if(i==5) pw.println(j);
                }
                //if(i==4) pw.println(mx);
            }
            ans[i]=mx;
        }
        for(int i=1;i<=n;i++) pw.print(ans[i]+"" "");
    }


    long M=(long)1e9+7;
    InputStream is;
    PrintWriter pw;
    String INPUT = """";
    void run() throws Exception {
        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
        pw = new PrintWriter(System.out);
        long s = System.currentTimeMillis();
        solve();
        pw.flush();
        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");
    }

    public static void main(String[] args) throws Exception { new A().run(); }

    private byte[] inbuf = new byte[1024];
    public int lenbuf = 0, ptrbuf = 0;

    private int readByte() {
        if(lenbuf == -1)throw new InputMismatchException();
        if(ptrbuf >= lenbuf){
            ptrbuf = 0;
            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
            if(lenbuf <= 0)return -1;
        }
        return inbuf[ptrbuf++];
    }

    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }

    private double nd() { return Double.parseDouble(ns()); }
    private char nc() { return (char)skip(); }

    private String ns() {
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    private char[] ns(int n) {
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while(p < n && !(isSpaceChar(b))){
            buf[p++] = (char)b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }

    private char[][] nm(int n, int m) {
        char[][] map = new char[n][];
        for(int i = 0;i < n;i++)map[i] = ns(m);
        return map;
    }

    private int[] na(int n) {
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
        return a;
    }

    private int ni() {
        int num = 0, b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }

        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }

    private long nl() {
        long num = 0;
        int b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }

        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }

    private void tr(Object... o) { if(INPUT.length() > 0)System.out.println(Arrays.deepToString(o)); }
}",5,5
"import java.io.*;
import java.util.*;
import java.math.*;
// import java.awt.Point;
 
public class Main {
    InputStream is;
    PrintWriter out;
    String INPUT = """";
 
    long MOD = 1_000_000_007;
    int inf = Integer.MAX_VALUE;

    void solve(){
        int n = ni();
        int r = ni();
        int[] x = new int[n];
        for(int i = 0; i < n; i++){
            x[i] = ni();
        }
        double[] y = new double[n];
        Arrays.fill(y,-1);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < i; j++){
                double res = 4*r*r - (x[i]-x[j])*(x[i]-x[j]);
                if(res < 0) continue;
                else{
                    double tmp = Math.sqrt(res) + y[j];
                    if(tmp > y[i]){
                        y[i] = tmp;
                    }
                }
            }
            if(y[i]==-1) y[i] = r;
        }
        for(int i = 0; i < n; i++){
            out.print(y[i]+"" "");
        }
    }  

    class Permutation{
    // max=10
    // n=10: 160ms
    // n=11: 1600-1700ms
    int n;
    int max;
    BitSet used;
    int[] p;
    public Permutation(int n, int max){
        this.n = n;
        this.max = max;
        used = new BitSet(n);
        p = new int[n];
    }
    
    public boolean next(){
        if(used.cardinality() == 0){
            for(int i=0; i<n; i++){
                p[i] = i;
            }
            used.set(0, n);
            return true;
        }
        int i;
        for(i=n-1; i>=0; i--){
            used.clear(p[i]);
            if((used.nextClearBit(p[i]+1)) < max) break;
        }
        if(i<0) return false;
        p[i] = used.nextClearBit(p[i]+1);
        used.set(p[i]);
        int idx = i+1;
        for(i=used.nextClearBit(0); i<max && idx<n; i=used.nextClearBit(i+1)){
            p[idx++] = i;
            used.set(i);
        }
        return true;
    }
    
    public String toString(){
        StringBuilder sb = new StringBuilder();
        for(int i=0; i<n; i++){
            sb.append(p[i]+"" "");
        }
        return sb.toString();
    }
}  
    void run() throws Exception
    {
        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
        out = new PrintWriter(System.out);
        
        long s = System.currentTimeMillis();
        solve();
        out.flush();
        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+""ms"");
    }
    
    public static void main(String[] args) throws Exception { new Main().run(); }
    
    private byte[] inbuf = new byte[1024];
    private int lenbuf = 0, ptrbuf = 0;
    
    private int readByte()
    {
        if(lenbuf == -1)throw new InputMismatchException();
        if(ptrbuf >= lenbuf){
            ptrbuf = 0;
            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
            if(lenbuf <= 0)return -1;
        }
        return inbuf[ptrbuf++];
    }
    
    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
    
    private double nd() { return Double.parseDouble(ns()); }
    private char nc() { return (char)skip(); }
    
    private String ns()
    {
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while(!(isSpaceChar(b) && b != ' ')){
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    
    private char[] ns(int n)
    {
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while(p < n && !(isSpaceChar(b))){
            buf[p++] = (char)b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }
    
    private char[][] nm(int n, int m)
    {
        char[][] map = new char[n][];
        for(int i = 0;i < n;i++)map[i] = ns(m);
        return map;
    }
    
    private int[] na(int n)
    {
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
        return a;
    }
    
    private int ni()
    {
        int num = 0, b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }
        
        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }
    
    private long nl()
    {
        long num = 0;
        int b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }
        
        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }
    
    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }
 
}",5,5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.*;

public class C {
  public static void main(String[] args) {
    FastScanner sc = new FastScanner();

    int n = sc.nextInt();
    long r = sc.nextInt();
    double d = 2 * r;
    long[] xs = sc.readLongArray(n);
    P[] points = new P[n];
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < n; i++) {
      if (i > 0) sb.append(' ');
      double y = r;
      for (int j = 0; j < i; j++) {
        long diff = Math.abs(xs[i] - points[j].x);
        if (diff <= 2 * r) {
          double dy = Math.sqrt(d * d - diff * diff);
          double testY = points[j].y + dy;
          y = Math.max(y, testY);
        }
      }

      sb.append(y);
      points[i] = new P(xs[i], y);
    }
    System.out.println(sb);
  }

  static class P {
    final long x;
    final double y;

    public P(long x, double y) {
      this.x = x;
      this.y = y;
    }
  }

  static void shuffle(int[] arr) {
    Random rng = new Random();
    int length = arr.length;
    for (int idx = 0; idx < arr.length; idx++) {
      int toSwap = idx + rng.nextInt(length - idx);
      int tmp = arr[idx];
      arr[idx] = arr[toSwap];
      arr[toSwap] = tmp;
    }
  }

  public static class FastScanner {
    BufferedReader br;
    StringTokenizer st;

    public FastScanner(Reader in) {
      br = new BufferedReader(in);
    }

    public FastScanner() {
      this(new InputStreamReader(System.in));
    }

    String next() {
      while (st == null || !st.hasMoreElements()) {
        try {
          st = new StringTokenizer(br.readLine());
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
      return st.nextToken();
    }

    int nextInt() {
      return Integer.parseInt(next());
    }

    long nextLong() {
      return Long.parseLong(next());
    }

    double nextDouble() {
      return Double.parseDouble(next());
    }

    String readNextLine() {
      String str = """";
      try {
        str = br.readLine();
      } catch (IOException e) {
        e.printStackTrace();
      }
      return str;
    }

    int[] readIntArray(int n) {
      int[] a = new int[n];
      for (int idx = 0; idx < n; idx++) {
        a[idx] = nextInt();
      }
      return a;
    }

    long[] readLongArray(int n) {
      long[] a = new long[n];
      for (int idx = 0; idx < n; idx++) {
        a[idx] = nextLong();
      }
      return a;
    }
  }
}
",5,5
" import java.util.Scanner;
    public class New_Year_and_Curling {
        static final double E = 0.00001;
 
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
 
            int n = sc.nextInt();
            int r = sc.nextInt();
            double[] y = new double[n];
            int arr[] = new int[n];
 
            for (int i = 0; i < n; i++) {
                arr[i] =sc.nextInt();
                double top = r; // if we make it 0 and subtract from the result will get WA (do not know why!!!)
                int x = arr[i];
                for(int  j =0 ;j<i;j++)
                {
                    if(Math.abs(arr[j] -x )<=2*r) {
 
                            top = Math.max(top  , y[j] + Math.sqrt((4 * r * r) - ((arr[j] - x) * (arr[j] - x))));
 
                    }
                }
                y[i] = top ;
                double res = y[i] ;
                System.out.print(res+"" "");
            }
 
        }
 
    }",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.FilterInputStream;
import java.io.BufferedInputStream;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author khokharnikunj8
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        ScanReader in = new ScanReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, ScanReader in, PrintWriter out) {
            int n = in.scanInt();
            int r = in.scanInt(), temp;
            double max1;
            double high[] = new double[1002];
            for (int i = 0; i < n; i++) {
                temp = in.scanInt();
                max1 = high[temp] + ((high[temp] == 0) ? r : +(2 * r));
                for (int j = temp - 1; j > temp - (2 * r) && j > 0; j--) {
                    if (high[j] == 0) continue;
                    max1 = Math.max(max1, high[j] + Math.sqrt((4 * r * r) - ((temp - j) * (temp - j))));
                }
                for (int j = temp + 1; j <= 1000 && j < temp + (2 * r); j++) {
                    if (high[j] == 0) continue;
                    max1 = Math.max(max1, high[j] + Math.sqrt((4d * r * r) - (((j - temp) * (j - temp)))));
                }
                if (temp - (2 * r) > 0) max1 = Math.max(high[temp - (2 * r)], max1);
                if (temp + (2 * r) <= 1000) max1 = Math.max(high[temp + (2 * r)], max1);
                high[temp] = max1;
                out.print(max1 + "" "");

            }
        }

    }

    static class ScanReader {
        private byte[] buf = new byte[4 * 1024];
        private int index;
        private BufferedInputStream in;
        private int total;

        public ScanReader(InputStream inputStream) {
            in = new BufferedInputStream(inputStream);
        }

        private int scan() {
            if (index >= total) {
                index = 0;
                try {
                    total = in.read(buf);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (total <= 0) return -1;
            }
            return buf[index++];
        }

        public int scanInt() {
            int integer = 0;
            int n = scan();
            while (isWhiteSpace(n)) n = scan();
            int neg = 1;
            if (n == '-') {
                neg = -1;
                n = scan();
            }
            while (!isWhiteSpace(n)) {
                if (n >= '0' && n <= '9') {
                    integer *= 10;
                    integer += n - '0';
                    n = scan();
                }
            }
            return neg * integer;
        }

        private boolean isWhiteSpace(int n) {
            if (n == ' ' || n == '\n' || n == '\r' || n == '\t' || n == -1) return true;
            else return false;
        }

    }
}

",5,3
"import java.util.*;
import java.io.*;
public class probC {
	static int r;
	static ArrayList<Circ> curr = new ArrayList<Circ>();
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		r = sc.nextInt();
		int[] xC = new int[n];
		for(int i = 0; i < n; i++)
			xC[i] = sc.nextInt();
		double ans[] = new double[n];
		ans[0] = r;
		curr.add(new Circ(xC[0], r));
		for(int i = 1; i < n; i++) {
			double max = r;
			for(int k = 0; k < curr.size(); k++) {
				double cur = curr.get(k).y+ Math.sqrt(4 * r*r - (xC[i]-curr.get(k).x)*(xC[i]-curr.get(k).x));
				//System.out.println(cur + "" "" + max);
				if(4 * r*r - (xC[i]-curr.get(k).x)*(xC[i]-curr.get(k).x) >= 0)
					max = Math.max(cur,  max);
			}
			ans[i] = max;
			curr.add(new Circ(xC[i], max));
			//System.out.println();
		}
		for(int i = 0; i < n; i++)
			System.out.print(ans[i] + "" "");
		sc.close();
	}
	static class Circ {
		double x, y;
		public Circ(double a, double b) {
			x=a;
			y=b;
		}
		public boolean isNT(Circ b) {
			double dist = Math.sqrt((x-b.x)*(x-b.x)+(y-b.y)*(y-b.y));
			return dist > 2*r;
		}
	}
}
",5,5
"import static java.lang.Math.*;

public class C {

	public C () {
		int N = sc.nextInt(); int R = sc.nextInt();
		int [] X = sc.nextInts();

		double [] res = new double [N];
		for (int i : rep(N)) {
			res[i] = R;
			for (int j : rep(i)) {
				int D = abs(X[i] - X[j]);
				if (D <= 2*R) {
					double H = sqrt(4.0*R*R - 1.0*D*D);
					res [i] = max(res[i], res[j] + H);
				}
			}
		}
		exit(res);
	}

	private static int [] rep(int N) { return rep(0, N); }
	private static int [] rep(int S, int T) { if (T <= S) return new int [0]; int [] res = new int [T-S]; for (int i = S; i < T; ++i) res[i-S] = i; return res; }
	////////////////////////////////////////////////////////////////////////////////////
	private final static IOUtils.MyScanner sc = new IOUtils.MyScanner();
	private static void exit (Object o, Object ... A) { IOUtils.print(o, A); IOUtils.exit(); }
	private static class IOUtils {
		public static class MyScanner {
			public String next() { newLine(); return line[index++]; }
			public int nextInt() { return Integer.parseInt(next()); }
			public String nextLine() { line = null; return readLine(); }
			public String [] nextStrings() { return split(nextLine()); }
			public int [] nextInts() {
				String [] L = nextStrings();
				int [] res = new int [L.length];
				for (int i = 0; i < L.length; ++i)
					res[i] = Integer.parseInt(L[i]);
				return res;
			}
			//////////////////////////////////////////////
			private boolean eol() { return index == line.length; }
			private String readLine() {
				try {
					return r.readLine();
				} catch (Exception e) {
					throw new Error (e);
				}
			}
			private final java.io.BufferedReader r;
			private MyScanner () { this(new java.io.BufferedReader(new java.io.InputStreamReader(System.in))); }
			private MyScanner (java.io.BufferedReader r) {
				try {
					this.r = r;
					while (!r.ready())
						Thread.sleep(1);
					start();
				} catch (Exception e) {
					throw new Error(e);
				}
			}
			private String [] line;
			private int index;
			private void newLine() {
				if (line == null || eol()) {
					line = split(readLine());
					index = 0;
				}
			}
			private String [] split(String s) { return s.length() > 0 ? s.split("" "") : new String [0]; }
		}
		private static String build(Object o, Object ... A) { return buildDelim("" "", o, A); }
		private static String buildDelim(String delim, Object o, Object ... A) {
			StringBuilder b = new StringBuilder();
			append(b, o, delim);
			for (Object p : A)
				append(b, p, delim);
			return b.substring(delim.length());
		}
		//////////////////////////////////////////////////////////////////////////////////
		private static void start() { if (t == 0) t = millis(); }
		private static void append(StringBuilder b, Object o, String delim) {
			if (o.getClass().isArray()) {
				int len = java.lang.reflect.Array.getLength(o);
				for (int i = 0; i < len; ++i)
					append(b, java.lang.reflect.Array.get(o, i), delim);
			} else if (o instanceof Iterable<?>)
				for (Object p : (Iterable<?>) o)
					append(b, p, delim);
			else {
				if (o instanceof Double)
					o = new java.text.DecimalFormat(""#.############"").format(o);
				b.append(delim).append(o);
			}
		}
		private static java.io.PrintWriter pw = new java.io.PrintWriter(System.out);
		private static void print(Object o, Object ... A) { pw.println(build(o, A)); }
		private static void err(Object o, Object ... A) { System.err.println(build(o, A)); }
		private static void exit() {
			IOUtils.pw.close();
			System.out.flush();
			err(""------------------"");
			err(IOUtils.time());
			System.exit(0);
		}
		private static long t;
		private static long millis() { return System.currentTimeMillis(); }
		private static String time() { return ""Time: "" + (millis() - t) / 1000.0; }
	}
	public static void main (String[] args) { new C(); IOUtils.exit(); }
}
",5,3
"import java.io.*;
import java.util.*;

public class Solution {
    static MyScanner sc;
    private static PrintWriter out;
    static long M2 = 1_000_000_000L + 7;

    public static void main(String[] s) throws Exception {
        StringBuilder stringBuilder = new StringBuilder();
        if (stringBuilder.length() == 0) {
            sc = new MyScanner(System.in);
        } else {
            sc = new MyScanner(new BufferedReader(new StringReader(stringBuilder.toString())));
        }

        out = new PrintWriter(new OutputStreamWriter(System.out));
        initData();
        solve();
        out.flush();
    }


    private static void initData() {
    }


    private static void solve() throws IOException {
        int n = sc.nextInt();
        int q = sc.nextInt();
        int[] vv = sc.na(n);

        double[] ans = new double[n];

        for (int i = 0; i < n; i++) {
            ans[i] = q;
            for (int s = 0; s < i; s++) {
                if (Math.abs(vv[i] - vv[s]) > q * 2) continue;
                double diff = 4 * q * q - Math.abs(vv[i] - vv[s]) * Math.abs(vv[i] - vv[s]);
                diff = Math.sqrt(diff);
                ans[i] = Math.max(ans[i], diff + ans[s]);
            }
            out.print(ans[i] + "" "");
        }
    }


    private static void solveT() throws IOException {
        int t = sc.nextInt();
        while (t-- > 0) {
            solve();
        }
    }

    private static long gcd(long l, long l1) {
        if (l > l1) return gcd(l1, l);
        if (l == 0) return l1;
        return gcd(l1 % l, l);
    }

    private static long pow(long a, long b, long m) {
        if (b == 0) return 1;
        if (b == 1) return a;
        long pp = pow(a, b / 2, m);
        pp *= pp;
        pp %= m;
        return (pp * (b % 2 == 0 ? 1 : a)) % m;
    }


    static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        MyScanner(BufferedReader br) {
            this.br = br;
        }

        public MyScanner(InputStream in) {
            this(new BufferedReader(new InputStreamReader(in)));
        }

        void findToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        String next() {
            findToken();
            return st.nextToken();
        }

        Integer[] nab(int n) {
            Integer[] k = new Integer[n];
            for (int i = 0; i < n; i++) {
                k[i] = sc.fi();
            }
            return k;
        }

        int[] na(int n) {
            int[] k = new int[n];
            for (int i = 0; i < n; i++) {
                k[i] = sc.fi();
            }
            return k;
        }

        long[] nl(int n) {
            long[] k = new long[n];
            for (int i = 0; i < n; i++) {
                k[i] = sc.nextLong();
            }
            return k;
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        int fi() {
            String t = next();
            int cur = 0;
            boolean n = t.charAt(0) == '-';
            for (int a = n ? 1 : 0; a < t.length(); a++) {
                cur = cur * 10 + t.charAt(a) - '0';
            }
            return n ? -cur : cur;
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }
    }


}",5,5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.Vector;
public class naloga1{
	static BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
	static PrintWriter out=new PrintWriter(System.out);
	public static void main(String[] args) throws Exception{
		StringTokenizer st=new StringTokenizer(in.readLine());
		int n=Integer.parseInt(st.nextToken());
		int r=Integer.parseInt(st.nextToken());
		int[] x=new int[n];
		st=new StringTokenizer(in.readLine());
		for(int i=0;i < n;i++){
			x[i]=Integer.parseInt(st.nextToken());
		}
		sim a=new sim(n,r);
		for(int i:x) {
			a.add(i);
		}
		for(double d:a.cy) {
			out.print(d+"" "");
		}
		out.println();
		out.close();
	}
}
class sim{
	double[]cx;
	int[]ccx;
	double[]cy;
	int count;
	int n;
	int r;
	sim(int nn,int rr){
		r=rr;
		n=nn;
		cx=new double[n];
		ccx=new int[n];
		cy=new double[n];
		count=0;
	}
	void add(int x) {
		double lowest=r;
		for(int i=0;i<count;i++) {
			if(Math.abs(ccx[i]-x)<=2*r) {
				double dy=Math.sqrt(4*r*r-(ccx[i]-x)*(ccx[i]-x));
				lowest=Math.max(lowest,cy[i]+dy);
			}
		}
		ccx[count]=x;
		cy[count]=lowest;
		cx[count++]=x;
	}
}",5,3
"
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

/**
 * Created by mostafa on 12/29/17.
 */
public class C {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner();
        PrintWriter out = new PrintWriter(System.out);
        int n = sc.nextInt(), r = sc.nextInt();
        int[] x = new int[n];
        for(int i = 0; i < n; i++)
            x[i] = sc.nextInt();
        double[] ans = new double[n];
        for(int i = 0; i < n; i++) {
            ans[i] = r;
            for(int j = 0; j < i; j++) {
                int d = Math.abs(x[i] - x[j]);
                if(d > 2 * r)
                    continue;
                int h = 2 * r;
                double yd = Math.sqrt(h * h - d * d);
                ans[i] = Math.max(ans[i], ans[j] + yd);
            }

            out.print(ans[i]);
            if(i == n - 1)
                out.println();
            else
                out.print("" "");
        }

        out.flush();
        out.close();

    }

    static class Scanner {
        BufferedReader br; StringTokenizer st;
        Scanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() throws IOException {
            while(st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

    }
}
",5,5
"import com.sun.org.apache.regexp.internal.RE;

import java.io.*;
import java.nio.file.ClosedWatchServiceException;
import java.nio.file.OpenOption;
import java.security.SecureRandom;
import java.util.*;

public class Main {
    public static void main(String[] args) throws FileNotFoundException {
        ConsoleIO io = new ConsoleIO(new InputStreamReader(System.in), new PrintWriter(System.out));
        //String test = ""C-large"";
        //ConsoleIO io = new ConsoleIO(new FileReader(""D:\\Dropbox\\code\\practice\\jb\\src\\"" + test + "".in""), new PrintWriter(new File(""D:\\Dropbox\\code\\practice\\jb\\src\\"" + test + ""-out.txt"")));

       new Main(io).solve();

        io.close();
    }

    ConsoleIO io;
    Main(ConsoleIO io) {
        this.io = io;
    }

    List<List<Integer>> gr = new ArrayList<>();
    long MOD = 1_000_000_007;


    public void solve() {
        int n = io.ri(), r = io.ri();

        double[] res = new double[n];
        int[] xs = new int[n];
        for(int i = 0;i<n;i++){
            int x = io.ri();
            xs[i] = x;
            double max = r;
            for(int j = 0;j<i;j++){
                int dx = Math.abs(xs[j] - x);
                int dx2 = dx*dx;
                if(dx <= 2*r){
                    max = Math.max(max, Math.sqrt(4*r*r - dx2) + res[j]);
                }
            }
            res[i] = max;
        }

        StringBuilder sb = new StringBuilder();
        for(int i = 0;i<res.length;i++){
            if(i>0)sb.append(' ');
            sb.append(res[i]);
        }

        io.writeLine(sb.toString());
    }


}

class ConsoleIO {

    BufferedReader br;
    PrintWriter out;
    public ConsoleIO(Reader reader, PrintWriter writer){br = new BufferedReader(reader);out = writer;}
    public void flush(){this.out.flush();}
    public void close(){this.out.close();}
    public void writeLine(String s) {this.out.println(s);}
    public void writeInt(int a) {this.out.print(a);this.out.print(' ');}
    public void writeWord(String s){
        this.out.print(s);
    }
    public void writeIntArray(int[] a, int k, String separator) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < k; i++) {
            if (i > 0) sb.append(separator);
            sb.append(a[i]);
        }
        this.writeLine(sb.toString());
    }
    public int read(char[] buf, int len){try {return br.read(buf,0,len);}catch (Exception ex){ return -1; }}
    public String readLine() {try {return br.readLine();}catch (Exception ex){ return """";}}
    public long[] readLongArray() {
        String[]n=this.readLine().trim().split(""\\s+"");long[]r=new long[n.length];
        for(int i=0;i<n.length;i++)r[i]=Long.parseLong(n[i]);
        return r;
    }
    public int[] readIntArray() {
        String[]n=this.readLine().trim().split(""\\s+"");int[]r=new int[n.length];
        for(int i=0;i<n.length;i++)r[i]=Integer.parseInt(n[i]);
        return r;
    }
    public int[] readIntArray(int n) {
        int[] res = new int[n];
        char[] all = this.readLine().toCharArray();
        int cur = 0;boolean have = false;
        int k = 0;
        boolean neg = false;
        for(int i = 0;i<all.length;i++){
            if(all[i]>='0' && all[i]<='9'){
                cur = cur*10+all[i]-'0';
                have = true;
            }else if(all[i]=='-') {
                neg = true;
            }
            else if(have){
                res[k++] = neg?-cur:cur;
                cur = 0;
                have = false;
                neg = false;
            }
        }
        if(have)res[k++] = neg?-cur:cur;
        return res;
    }
    public int ri() {
        try {
            int r = 0;
            boolean start = false;
            boolean neg = false;
            while (true) {
                int c = br.read();
                if (c >= '0' && c <= '9') {
                    r = r * 10 + c - '0';
                    start = true;
                } else if (!start && c == '-') {
                    start = true;
                    neg = true;
                } else if (start || c == -1) return neg ? -r : r;
            }
        } catch (Exception ex) {
            return -1;
        }
    }
    public long readLong() {
        try {
            long r = 0;
            boolean start = false;
            boolean neg = false;
            while (true) {
                int c = br.read();
                if (c >= '0' && c <= '9') {
                    r = r * 10 + c - '0';
                    start = true;
                } else if (!start && c == '-') {
                    start = true;
                    neg = true;
                } else if (start || c == -1) return neg ? -r : r;
            }
        } catch (Exception ex) {
            return -1;
        }
    }
    public String readWord() {
        try {
            boolean start = false;
            StringBuilder sb = new StringBuilder();
            while (true) {
                int c = br.read();
                if (c!= ' ' && c!= '\r' && c!='\n' && c!='\t') {
                    sb.append((char)c);
                    start = true;
                } else if (start || c == -1) return sb.toString();
            }
        } catch (Exception ex) {
            return """";
        }
    }
    public char readSymbol() {
        try {
            while (true) {
                int c = br.read();
                if (c != ' ' && c != '\r' && c != '\n' && c != '\t') {
                    return (char) c;
                }
            }
        } catch (Exception ex) {
            return 0;
        }
    }
    //public char readChar(){try {return (char)br.read();}catch (Exception ex){ return 0; }}
}
class Pair {
    public Pair(int a, int b) {this.a = a;this.b = b;}
    public int a;
    public int b;
}
class PairLL {
    public PairLL(long a, long b) {this.a = a;this.b = b;}
    public long a;
    public long b;
}
class Triple {
    public Triple(int a, int b, int c) {this.a = a;this.b = b;this.c = c;}
    public int a;
    public int b;
    public int c;
}",5,5
"import java.util.*;

import java.io.*;
import java.lang.reflect.Array;

public class C {
	FastScanner in;
	PrintWriter out;
	boolean systemIO = true;

	public static class Pair {
		int x;
		int y;

		public Pair(int x, int y) {
			this.x = x;
			this.y = y;
		}
	}

	public void solve() {
		int n = in.nextInt();
		int r = 2 * in.nextInt();
		int[] x = new int[n];
		for (int i = 0; i < x.length; i++) {
			x[i] = in.nextInt();
		}
		double[] y = new double[n];
		for (int i = 0; i < y.length; i++) {
			y[i] = r / 2;
		}
		for (int i = 0; i < y.length; i++) {
			for (int j = 0; j < i; j++) {
				if (Math.abs(x[i] - x[j]) == r) {
					y[i] = Math.max(y[i], y[j]);
				} else if (Math.abs(x[i] - x[j]) < r) {
					y[i] = Math.max(y[i], y[j] + Math.sqrt(r * r - (x[j] - x[i]) * (x[j] - x[i])));
				}
			}
		}
		for (int i = 0; i < y.length; i++) {
			out.print(y[i] + "" "");
		}
	}

	public void run() {
		try {
			if (systemIO) {
				in = new FastScanner(System.in);
				out = new PrintWriter(System.out);
			} else {
				in = new FastScanner(new File(""segments.in""));
				out = new PrintWriter(new File(""segments.out""));
			}
			solve();

			out.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		FastScanner(File f) {
			try {
				br = new BufferedReader(new FileReader(f));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		FastScanner(InputStream f) {
			br = new BufferedReader(new InputStreamReader(f));
		}

		String nextLine() {
			try {
				return br.readLine();
			} catch (IOException e) {
				return null;
			}
		}

		String next() {
			while (st == null || !st.hasMoreTokens()) {
				try {
					st = new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

	}

	// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	public static void main(String[] arg) {
		new C().run();
	}
}",5,5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;

public class C {

	public static void main(String[] args){
		FastScanner scan = new FastScanner();
		PrintWriter out = new PrintWriter(System.out);
		int n = scan.nextInt(), r = scan.nextInt();
		int[] x = scan.nextIntArray(n);
		double[] y = new double[n];
		for(int i = 0; i < n; i++) {
			double best = 0;
			for(int j = 0; j < i; j++) {
				if(Math.abs(dist(x[i], y[j], x[j], y[j])-2*r) <= 1e-7) {
					best = Math.max(best, y[j]);
					continue;
				}
				double lo = y[j]-r-r, hi = y[j]+r+r;
				for(int bs = 0; bs < 200; bs++) {
					double mid = (lo+hi)/2.0;
					if(dist(x[i], mid, x[j], y[j])-2*r <= 1e-7) lo = mid;
					else hi = mid;
				}
				if(dist(x[i], lo, x[j], y[j])-2*r <= 1e-7) best = Math.max(best, lo);
			}
			if(best == 0) y[i] = r;
			else y[i] = best;
		}
		for(int i = 0; i < n; i++) out.printf(""%.6f "", y[i]);
		out.close();
	}

	static double dist(double x, double y, double xx, double yy) {return Math.sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy));}

	static class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		public FastScanner() {
			try	{
				br = new BufferedReader(new InputStreamReader(System.in));
				st = new StringTokenizer(br.readLine());
			} catch (Exception e){e.printStackTrace();}
		}

		public String next() {
			if (st.hasMoreTokens())	return st.nextToken();
			try {st = new StringTokenizer(br.readLine());}
			catch (Exception e) {e.printStackTrace();}
			return st.nextToken();
		}

		public int nextInt() {return Integer.parseInt(next());}

		public long nextLong() {return Long.parseLong(next());}

		public double nextDouble() {return Double.parseDouble(next());}

		public String nextLine() {
			String line = """";
			if(st.hasMoreTokens()) line = st.nextToken();
			else try {return br.readLine();}catch(IOException e){e.printStackTrace();}
			while(st.hasMoreTokens()) line += "" ""+st.nextToken();
			return line;
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for(int i = 0; i < n; i++) a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n){
			long[] a = new long[n];
			for(int i = 0; i < n; i++) a[i] = nextLong();
			return a;
		}

		public double[] nextDoubleArray(int n){
			double[] a = new double[n];
			for(int i = 0; i < n; i++) a[i] = nextDouble();
			return a;
		}

		public char[][] nextGrid(int n, int m){
			char[][] grid = new char[n][m];
			for(int i = 0; i < n; i++) grid[i] = next().toCharArray();
			return grid;
		}
	}


}",5,5
"import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;
/* Name of the class has to be ""Main"" only if the class is public. */
public class Codechef
{
    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	static ArrayList<ArrayList<Integer>> list;
    static HashSet<Integer> hs;
    static ArrayList<Integer> tmp;
    //int n=Integer.parseInt(br.readLine());
    //int n=Integer.parseInt(st.nextToken());
    //StringTokenizer st = new StringTokenizer(br.readLine());
    public static double cal(int a,double b,int x,int r)
    {
        r*=2;
        double dis=(r*r) - Math.pow(Math.abs(a-x),2);
        
        dis=Math.sqrt(dis);
        
        dis+=b;
        
        return dis;
        
    }
	public static void main (String[] args) throws java.lang.Exception
	{
	    int n,r;
	    StringTokenizer st = new StringTokenizer(br.readLine());
	    n=Integer.parseInt(st.nextToken());
	    r=Integer.parseInt(st.nextToken());
	    
	    int arr[] = new int[n+1];
	    double cen[] = new double[n+1];
	    
	    int i,j;
	    
	    for(i=1;i<=n;i++)
	    cen[i]=-1.0;
	    
	    st = new StringTokenizer(br.readLine());
	    for(i=1;i<=n;i++)arr[i]=Integer.parseInt(st.nextToken());
	    
	    for(i=1;i<=n;i++)
	    {
	        int f=0;
	        double max=-1.0;
	        for(j=1;j<=n;j++)
	        {
	            if(i!=j && cen[j]!=-1.0 && (Math.abs(arr[i]-arr[j])<=2*r))
	            {
	                max=Math.max(max,cal(arr[j],cen[j],arr[i],r));
	                f=1;
	                
	            }
	        }
	       // System.out.println(i+"" ""+max);
	        if(f==1)
	        cen[i]=max;
	        else
	        cen[i]=r*1.0;
	    }
	    for(i=1;i<=n;i++)
	    System.out.print(cen[i]+"" "");
	}
}
",5,1
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

public class c {
	

	public static void main(String args[]) throws IOException {
		FastScanner in = new FastScanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		//BEGIN HERE
		int n = in.nextInt();
		int r = in.nextInt();
		int xs[] = new int[n];
		for(int i = 0; i < n; i++) xs[i] = in.nextInt();
		double ys[] = new double[n];
		ys[0] = r;
		for(int i = 1; i < n; i++) {
			double worst = r;
			for(int j = 0; j < i; j++) {
				if(xs[i] == xs[j]) {
					worst = Math.max(worst, ys[j] + r + r);
				}else if((xs[i] - xs[j]) * (xs[i] - xs[j]) <= 4*r*r ) {

					double hypot = r + r;
					double adj = Math.abs((xs[i] - xs[j]));
					double theta = Math.acos(adj/hypot);
					worst = Math.max(hypot * Math.sin(theta) + ys[j], worst);
				}
			}
			ys[i] = worst;
		}
		for(int i = 0; i < n; i++)
			out.printf(""%.10f "",ys[i]);
		out.close();
	}

	static class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		public FastScanner(InputStream i) {
			br = new BufferedReader(new InputStreamReader(i));
			st = null;
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public String nextLine() throws IOException {
			if (st == null) {
				st = new StringTokenizer(br.readLine());
			}
			String line = st.nextToken(""\n"");
			st = null;
			return line;
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}
	}

	public static class combinatorics {
		static long modInv(long a, long b) {
			return 1 < a ? b - modInv(b % a, a) * b / a : 1;
		}

		static long factorial[], mod;

		combinatorics(int n, long MOD) {
			mod = MOD;
			factorial = new long[n + 1];
			factorial[0] = 1;
			for (int i = 1; i <= n; i++) {
				factorial[i] = i * factorial[i - 1];
				factorial[i] %= mod;
			}
		}

		static long nCr(int n, int r) {
			if (r > n)
				return 0;
			return (factorial[n] * modInv((factorial[n - r] * factorial[r]) % mod, mod)) % mod;
		}

		static long gcd(long a, long b) {
			return b == 0 ? a : gcd(b, a % b);
		}

		static long lcm(long a, long b) {
			return a * (b / gcd(a, b));
		}
	}

	public static class DisjointSet {
		int p[], r[], s[];
		int numDisjoint;

		DisjointSet(int N) {
			numDisjoint = N;
			r = new int[N];
			s = new int[N];
			p = new int[N];
			for (int i = 0; i < N; i++)
				p[i] = i;
		}

		int findSet(int i) {
			return (p[i] == i) ? i : (p[i] = findSet(p[i]));
		}

		boolean isSameSet(int i, int j) {
			return findSet(i) == findSet(j);
		}

		void unionSet(int i, int j) {
			if (!isSameSet(i, j)) // if from different set
			{
				numDisjoint--;
				int x = findSet(i), y = findSet(j);
				if (r[x] > r[y]) {
					p[y] = x; // rank keeps the tree short
					s[x] += s[y];
				} else {
					p[x] = y;
					if (r[x] == r[y])
						r[y]++;
					s[y] += s[x];
				}
			}
		}

		int sizeOfSet(int i) {
			return s[findSet(i)];
		}
	};

}
",5,5
"import java.io.*;
import java.util.*;

public class Codeforces
{
    public static void main(String args[])throws Exception
    {
        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb=new StringBuilder();
        String s[]=bu.readLine().split("" "");
        int n=Integer.parseInt(s[0]),r=Integer.parseInt(s[1]);
        double ans[]=new double[n];
        int i,x[]=new int[n],j;
        s=bu.readLine().split("" "");
        for(i=0;i<n;i++)
        {
            x[i]=Integer.parseInt(s[i]);
            ans[i]=r;
            for(j=0;j<i;j++)
            {
                int t=x[i]-x[j];
                if(t*t<=4*r*r) ans[i]=Math.max(ans[i],ans[j]+Math.sqrt(4*r*r-t*t));
            }
            sb.append(ans[i]+"" "");
        }
        System.out.print(sb);
    }
}
",5,1
"import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/*
 public class _908C {

 }

 */
public class _908C {
  public void solve() throws FileNotFoundException {
    InputStream inputStream = System.in;

    InputHelper in = new InputHelper(inputStream);

    // actual solution
    int n = in.readInteger();
    double r = in.readInteger();

    double[] x = new double[n];

    for (int i = 0; i < n; i++) {
      x[i] = in.readInteger();
    }

    double[] ans = new double[n];

    ans[0] = r;

    for (int i = 1; i < n; i++) {
      double cans = r;
      for (int j = 0; j < i; j++) {
        double dis = Math.abs(x[j] - x[i]);

        if (dis <= 2 * r) {

          if (dis == 2 * r) {
            cans = Math.max(cans, ans[j]);
            continue;
          } else if (x[i] == x[j]) {
            cans = Math.max(cans, ans[j] + 2 * r);
            continue;
          }
          cans = Math.max(cans, ans[j] + Math.sqrt((4 * (r * r)) - dis * dis));
        }
      }

      ans[i] = cans;
    }

    for (int i = 0; i < n; i++) {
      System.out.print(ans[i] + "" "");
    }

    // end here
  }

  public static void main(String[] args) throws FileNotFoundException {
    (new _908C()).solve();
  }

  class InputHelper {
    StringTokenizer tokenizer = null;
    private BufferedReader bufferedReader;

    public InputHelper(InputStream inputStream) {
      InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
      bufferedReader = new BufferedReader(inputStreamReader, 16384);
    }

    public String read() {
      while (tokenizer == null || !tokenizer.hasMoreTokens()) {
        try {
          String line = bufferedReader.readLine();
          if (line == null) {
            return null;
          }
          tokenizer = new StringTokenizer(line);
        } catch (IOException e) {
          e.printStackTrace();
        }
      }

      return tokenizer.nextToken();
    }

    public Integer readInteger() {
      return Integer.parseInt(read());
    }

    public Long readLong() {
      return Long.parseLong(read());
    }
  }
}
",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.util.StringTokenizer;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.BufferedReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author phantom11
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int N = in.nextInt();
            int r = in.nextInt();
            int i, j;
            BigDecimal initial = new BigDecimal(10);
            initial = initial.pow(100);
            int x[] = new int[N];
            BigDecimal y[] = new BigDecimal[N];
            Arrays.fill(y, initial);
            for (i = 0; i < N; i++) {
                x[i] = in.nextInt();
            }
            for (i = 0; i < N; i++) {
                BigDecimal y2 = new BigDecimal(r);
                for (j = 0; j < i; j++) {
                    if (Math.abs(x[i] - x[j]) <= 2 * r) {
                        double xDiff = x[i] - x[j];
                        xDiff *= xDiff;
                        xDiff = 4 * r * r - xDiff;
                        xDiff = Math.sqrt(xDiff);
                        BigDecimal yNew = new BigDecimal(xDiff);
                        yNew = yNew.add(y[j]);
                        if (yNew.compareTo(y2) > 0) {
                            y2 = yNew;
                        }
                    }
                }
                y[i] = y2;
            }
            for (i = 0; i < N; i++) {
                out.print(y[i] + "" "");
            }
        }

    }

    static class InputReader {
        BufferedReader in;
        StringTokenizer tokenizer = null;

        public InputReader(InputStream inputStream) {
            in = new BufferedReader(new InputStreamReader(inputStream));
        }

        public String next() {
            try {
                while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                    tokenizer = new StringTokenizer(in.readLine());
                }
                return tokenizer.nextToken();
            } catch (IOException e) {
                return null;
            }
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0)
                    writer.print(' ');
                writer.print(objects[i]);
            }
        }

        public void close() {
            writer.close();
        }

    }
}

",5,3
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.ArrayList;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author ilyakor
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int n = in.nextInt();
            int r = in.nextInt();
            ArrayList<PointDouble> centers = new ArrayList<>();
            ArrayList<Integer> xs = new ArrayList<>();
            for (int i = 0; i < n; ++i) {
                int x = in.nextInt();
                double y = r;
                for (int j = 0; j < centers.size(); j++) {
                    int ox = xs.get(j);
                    if (Math.abs(ox - x) > 2 * r) continue;
                    PointDouble c = centers.get(j);
                    double t = Math.abs(ox - x);
                    double h = Math.sqrt(Math.abs(4.0 * r * r - t * t));
                    double val = c.y + h;
                    if (y < val) y = val;
                }
                out.print(String.format(""%.20f "", y));
                centers.add(new PointDouble(x, y));
                xs.add(x);
            }
            out.printLine();
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
        }

        public void printLine(Object... objects) {
            print(objects);
            writer.println();
        }

        public void close() {
            writer.close();
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buffer = new byte[10000];
        private int cur;
        private int count;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public static boolean isSpace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public int read() {
            if (count == -1) {
                throw new InputMismatchException();
            }
            try {
                if (cur >= count) {
                    cur = 0;
                    count = stream.read(buffer);
                    if (count <= 0)
                        return -1;
                }
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            return buffer[cur++];
        }

        public int readSkipSpace() {
            int c;
            do {
                c = read();
            } while (isSpace(c));
            return c;
        }

        public int nextInt() {
            int sgn = 1;
            int c = readSkipSpace();
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res = res * 10 + c - '0';
                c = read();
            } while (!isSpace(c));
            res *= sgn;
            return res;
        }

    }

    static class PointDouble {
        public double x;
        public double y;

        public PointDouble(double x, double y) {
            this.x = x;
            this.y = y;
        }

        public PointDouble() {
            x = 0;
            y = 0;
        }

    }
}

",5,5
"import java.io.*;
import java.util.*;

public class Main {

	public static class InputReader {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public InputReader() {
			reader = new BufferedReader(new InputStreamReader(System.in), 32768);
			tokenizer = null;
		}

		public InputReader(InputStream stream) {
			reader = new BufferedReader(new InputStreamReader(System.in), 32768);
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public char nextChar() {
			return next().charAt(0);
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}
	}

	public static void main(String[] args) {
		// InputStream inputStream = System.in; // Useful when taking input other than
		// console eg file handling // check ctor of inputReader
		InputReader scn = new InputReader();
		
		int n = scn.nextInt(), r = scn.nextInt();
		double[] y = new double[n];
		int[] x = new int[n];
		boolean[] mark = new boolean[n];
		for(int i = 0; i < n; i++) {
			x[i] = scn.nextInt();
		}
		for(int i = 0; i < n; i++) {
			double yc = r;
			for(int j = 0; j < n; j++) {
				if(i == j || !mark[j]) {
					continue;
				}
				if(x[i] + r < x[j] - r || x[i] - r > x[j] + r) {
					continue;
				}
				
				yc = Math.max(yc, y[j] + Math.sqrt(Math.abs(Math.pow(x[i] - x[j], 2) - 4 * r * r)));
			}
			y[i] = yc;
			mark[i] = true;
		}
		
		for(int i = 0; i < n; i++) {
			System.out.print(y[i] + "" "");
		}
		System.out.println();
	}
}",5,5
"import java.util.*;
import java.io.*;

public class test {
	public static void main(String[] args) throws IOException {
		Scanner s = new Scanner(System.in);
		StringTokenizer st = new StringTokenizer(s.nextLine());
		int n = Integer.parseInt(st.nextToken());
		int r = Integer.parseInt(st.nextToken());
		st = new StringTokenizer(s.nextLine());
		int[] array = new int[n];
		for (int i = 0; i < n; i++) {
			array[i] = Integer.parseInt(st.nextToken());
		}
		ArrayList<State> list = new ArrayList<State>();
		for (int i = 0; i < n; i++) {
			double currY = r;
			for (int j = 0; j < list.size(); j++) {
				double xDiff = Math.abs(list.get(j).getX() - array[i]);
				if (xDiff <= 2 * r) {
					if (currY < list.get(j).getY() + Math.sqrt(4 * r * r - xDiff * xDiff)) {
						currY = list.get(j).getY() + Math.sqrt(4 * r * r - xDiff * xDiff);
					}
				}
			}
			list.add(new State(array[i], currY));
			System.out.print(currY + "" "");
		}
		s.close();
	}

	static class State {
		double x;
		double y;

		public State(double a, double b) {
			x = a;
			y = b;
		}

		public double getX() {
			return x;
		}

		public double getY() {
			return y;
		}
	}
}
",5,5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class GB17C {
	public static void main(String[] args) throws NumberFormatException, IOException {
			
			BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));
			
			String[] dir = sc.readLine().split("" "");
			int n = Integer.parseInt(dir[0]);
			int r = Integer.parseInt(dir[1]);
			
			String[] t = sc.readLine().split("" "");
			int[] list = new int[n];
			for(int x=0; x<n; x++){
				list[x] = Integer.parseInt(t[x]);
			}
			
			double[] yCoords = new double[n];
			
			for(int x=0; x<n; x++){
				double stop = (double)r;
				int dist = 2*r;
				int xCoordNew = list[x];
				
				
				for(int y=0; y<x; y++){
					
					int xCoordOld = list[y];
					if(Math.abs(xCoordNew - xCoordOld) == dist){
						stop = Math.max(stop, yCoords[y]);
					}
					else if(Math.abs(xCoordNew - xCoordOld) < dist){
						double extra = Math.pow((double)(dist*dist) - (double)((xCoordNew - xCoordOld)*(xCoordNew - xCoordOld)), 0.5);  
						
						stop = Math.max(stop, yCoords[y] + extra);
					}
				}
				
				yCoords[x] = stop;
				System.out.print(stop+"" "");
			}
			
			
	}
}


/* 

BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));

int n = Integer.parseInt(sc.readLine());
String[] t = sc.readLine().split("" "");
int[] list = new int[n];
for(int x=0; x<n; x++){
	list[x] = Integer.parseInt(t[x]);
}
		
String[] dir = sc.readLine().split("" "");
int a = Integer.parseInt(dir[0]);
int b = Integer.parseInt(dir[1]);
int c = Integer.parseInt(dir[2]);
int d = Integer.parseInt(dir[3]);
int e = Integer.parseInt(dir[4]);

int n = Integer.parseInt(sc.readLine());

*/",5,5
"import java.io.*;
import java.math.*;
import java.util.*;
public class Main{
  public static void main(String[] args){
    InputReader reader = new InputReader(System.in);
    PrintWriter pw = new PrintWriter(System.out);
    int n = reader.nextInt();
    int r = reader.nextInt();
    int[] x = new int[n];
    double[] y = new double[n];
    
    for(int i=0;i<n;++i){
      int iniX = reader.nextInt();
      double bestY = (double)r;
      for(int j=0;j<i;++j){
//         pw.printf(""testing %d %d\n"", i, j);
        if(Math.abs(iniX - x[j]) < 2*r){
//           pw.printf(""on colision %d %d\n"", i, j);
          bestY = Math.max(bestY, collisionY((double)x[j], y[j], (double)iniX, r));
        }
        if(Math.abs(iniX - x[j]) == 2*r){
//           pw.printf(""touvhing %d %d\n"", i, j);
          bestY = Math.max(bestY, y[j]);
        }
      }
      x[i] = iniX;
      y[i] = bestY;
    }
    for(int i=0;i<n;++i){
      pw.printf(""%.9f "", y[i]);
    }   
    pw.flush();
    pw.close();
  }
  
  public static double collisionY(double x1, double y1, double x2, double r){
    double dhsq = r*r*4-(x1-x2)*(x1-x2);
    return y1+Math.sqrt(dhsq);
  }
  
  public static class InputReader {
    BufferedReader reader;
    StringTokenizer tokenizer;
    
    public InputReader (InputStream stream){
      reader = new BufferedReader(new InputStreamReader(stream));
    }
    

    public String next(){
      while(tokenizer == null || !tokenizer.hasMoreTokens()){
        try{
          String line = reader.readLine();
          if(line == null){
            return ""0"";
          }
          tokenizer = new StringTokenizer(line);
        } catch(IOException ioe){
          throw new RuntimeException(ioe);
        }
      }
      return tokenizer.nextToken();
    }
    
    public int nextInt(){
      return Integer.parseInt(next());
    }
    
    public double nextDouble(){
      return Double.parseDouble(next());
    }
    
    public Long nextLong(){
      return Long.parseLong(next());
    }
    
    public BigInteger nextBigInteger(){
      return new BigInteger(next());
    }
    
    public String nextLine(){
      String line = """";
      try{
        while(line.equals("""")){
          line = reader.readLine();
        }
      } catch(IOException ioe){
        throw new RuntimeException(ioe);
      }
      return line;
    }
  }
  
  public static class MultiSet<E> {
    HashMap<E, Integer> map = new HashMap<E, Integer>();
    int multiSize = 0;
    public int add(E key){
      multiSize ++;
      Integer amount = map.get(key);
      if(amount == null){
        map.put(key, 1);
        return 1;
      }
      map.put(key, amount+1);
      return amount+1;
    }
    
    public int remove(E key){
      Integer amount = map.get(key);
      if(amount == null){
        return -1;
      }
      multiSize --;
      if(amount == 1){
        map.remove(key);
      } else {
        map.put(key, amount-1);
      }
      return amount-1;
    }
    
    public ArrayList<E> elems(){
      ArrayList<E> ret = new ArrayList<E>(multiSize);
      for(Map.Entry<E, Integer> e : map.entrySet()){
        E key = e.getKey();
        int v = e.getValue();
        while(v-->0){
          ret.add(key);
        }
      }
      return ret;
    }
    
    public int getMultiSize(){
      return multiSize;
    }
  
  }
  
  
   public static class MaxBIT{
    int n;
    int[]t;
    
    public MaxBIT(int n){
      this.n = Integer.highestOneBit(n)<<1;
      this.t = new int[this.n<<1];
      for(int i=0;i<2*this.n;++i){
        t[i] = -1;
      }
    }
  
    public void setMax(int p, int val){
      p+=n;
      while(p>1){
        t[p] = Math.max(t[p], val);
        p>>=1;
      }
    }
    
    public int getMax(int p, int q){
      p+=n;
      q+=n;
      int ret = -1;
      while(p<q){
        if((p&1)==1){
          ret=Math.max(t[p++], ret);
        }
        if((q&1)==1){
          ret=Math.max(t[--q], ret);
        }
        p = p>>1;
        q = q>>1;
      }
      return ret;
    }
  }
  
}",5,5
"/*
ID: andrew42
LANG: JAVA
TASK: 
PROG: 
*/

import java.io.*;
import java.util.*;
import java.lang.*;

public class curling {
	public static void main(String[] args) throws IOException {
		Scanner input = new Scanner(System.in);
		int numD = input.nextInt();
		double rad = input.nextInt();
		int[] xC = new int[numD];
		for (int i = 0; i < numD; i++){
			xC[i] = input.nextInt();
		}
		double[] maxY = new double[1001];
		for (int i = 0; i < numD; i++){
			double h = rad;
			for (int j = Math.max(1, xC[i]-(int)(2*rad)); j <= Math.min(1000, xC[i]+2*rad); j++){
				if (maxY[j] > 0){
					h = Math.max(h, Math.sqrt(4*rad*rad-(j-xC[i])*(j-xC[i]))+maxY[j]);
				}
			}
			System.out.print(h + "" "");
			maxY[xC[i]] = h;
		}
	}
}
",5,3
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.ArrayList;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Pradyumn
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastReader in = new FastReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, FastReader in, PrintWriter out) {
            Debug debug = new Debug(out);
            int n = in.nextInt();
            TaskC.Circle[] c = new TaskC.Circle[n];
            double rr = in.nextInt();
            for (int i = 0; i < n; ++i) {
                c[i] = new TaskC.Circle();
                c[i].x = in.nextInt();
            }
            ArrayList<TaskC.Circle> done = new ArrayList<>();
            for (int i = 0; i < n; ++i) {
                TaskC.Circle cur = c[i];
                double ans = Double.MIN_VALUE;
                for (int j = 0; j < done.size(); ++j) {
                    TaskC.Circle dd = done.get(j);
                    if (Double.compare(2 * rr, Math.abs(dd.x - cur.x)) < 0) continue;
                    double temp = Math.sqrt(4 * rr * rr - (cur.x - dd.x) * (cur.x - dd.x)) + dd.y;
                    ans = Math.max(ans, temp);
                }
                if (ans == Double.MIN_VALUE)
                    ans = rr;
                cur.y = ans;
                done.add(cur);
            }
            for (TaskC.Circle cc : done) {
                out.printf(""%.12f "", cc.y);
            }
        }

        static class Circle implements Comparable<TaskC.Circle> {
            double x;
            double y;


            public boolean equals(Object o) {
                if (o == null) return false;
                if (o == this) return true;
                if (o.getClass() != this.getClass()) return false;

                TaskC.Circle c = (TaskC.Circle) o;
                return Double.compare(x, c.x) == 0 && Double.compare(y, c.y) == 0;
            }


            public int compareTo(TaskC.Circle o) {
                if (Double.compare(o.x, x) != 0) {
                    return Double.compare(x, o.x);
                }
                return Double.compare(y, o.y);
            }

        }

    }

    static class Debug {
        PrintWriter out;
        boolean oj;
        long timeBegin;
        Runtime runtime;

        public Debug(PrintWriter out) {
            oj = System.getProperty(""ONLINE_JUDGE"") != null;
            this.out = out;
            this.timeBegin = System.currentTimeMillis();
            this.runtime = Runtime.getRuntime();
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[8192];
        private int curChar;
        private int pnumChars;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        private int pread() {
            if (pnumChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= pnumChars) {
                curChar = 0;
                try {
                    pnumChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (pnumChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = pread();
            while (isSpaceChar(c))
                c = pread();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = pread();
            }
            int res = 0;
            do {
                if (c == ',') {
                    c = pread();
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = pread();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        private boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

    }
}

",5,5
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeSet;
import java.io.BufferedOutputStream;
import java.util.StringTokenizer;
import java.io.BufferedReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author Aeroui
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Kattio in = new Kattio(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, Kattio in, PrintWriter out) {
            int n = in.nextInt();
            int r = in.nextInt();

            double[] xs = new double[n];
            double[] ys = new double[n];
            TreeSet<TaskC.Pair> set = new TreeSet<>();
            for (int i = 0; i < n; ++i) {
                xs[i] = in.nextDouble();
                ys[i] = (double) Integer.MIN_VALUE;

                if (i == 0) { // the first one
                    out.printf(""%f"", (double) r);
                    ys[i] = (double) r;
                    set.add(new TaskC.Pair(xs[i], ys[i]));
                } else {
                    for (TaskC.Pair p : set) {
                        double maximum = p.x;
                        double diffX = (xs[i] - maximum) * (xs[i] - maximum);

                        if (diffX <= r * r * 4.0) {
                            ys[i] = Math.max(ys[i], p.y + Math.sqrt(r * r * 4.0 - diffX));
                            continue;
                        }
                    }

                    if (ys[i] < 0)
                        ys[i] = (double) r;

                    set.add(new TaskC.Pair(xs[i], ys[i]));
                    out.printf("" %f"", ys[i]);
                }
            }

        }

        private static class Pair implements Comparable<TaskC.Pair> {
            double x;
            double y;

            public Pair(double x, double y) {
                this.x = x;
                this.y = y;
            }


            public int compareTo(TaskC.Pair p) {
                if (this.y - p.y < 0)
                    return 1;

                return -1;
            }

        }

    }

    static class Kattio extends PrintWriter {
        private BufferedReader r;
        private String line;
        private StringTokenizer st;
        private String token;

        public Kattio(InputStream i) {
            super(new BufferedOutputStream(System.out));
            r = new BufferedReader(new InputStreamReader(i));
        }

        public Kattio(InputStream i, OutputStream o) {
            super(new BufferedOutputStream(o));
            r = new BufferedReader(new InputStreamReader(i));
        }

        public int nextInt() {
            return Integer.parseInt(nextToken());
        }

        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }

        private String peekToken() {
            if (token == null)
                try {
                    while (st == null || !st.hasMoreTokens()) {
                        line = r.readLine();
                        if (line == null) return null;
                        st = new StringTokenizer(line);
                    }
                    token = st.nextToken();
                } catch (IOException e) {
                }
            return token;
        }

        private String nextToken() {
            String ans = peekToken();
            token = null;
            return ans;
        }

    }
}

",5,3
"
public class Main {

	private static void solve() {
		int n = ni();
		double r = ni();

		double[][] p = new double[n][2];
		double EPS = 0.0000000000001;

		for (int i = 0; i < n; i ++) {
			double x = ni();
			double y = r;
			for (int j = 0; j < i; j ++) {
				double dx = Math.abs(p[j][0] - x);
				if (dx <= r * 2 + EPS) {
					double dy = Math.sqrt(4.0 * r * r - dx * dx);
					y = Math.max(y, p[j][1] + dy);
				}
			}
			out.printf(""%.12f "", y);
			p[i][0] = x;
			p[i][1] = y;
		}
		out.println();
	}

	public static void main(String[] args) {
		new Thread(null, new Runnable() {
			@Override
			public void run() {
				long start = System.currentTimeMillis();
				String debug = args.length > 0 ? args[0] : null;
				if (debug != null) {
					try {
						is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));
					} catch (Exception e) {
						throw new RuntimeException(e);
					}
				}
				reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);
				solve();
				out.flush();
				tr((System.currentTimeMillis() - start) + ""ms"");
			}
		}, """", 64000000).start();
	}

	private static java.io.InputStream is = System.in;
	private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);
	private static java.util.StringTokenizer tokenizer = null;
	private static java.io.BufferedReader reader;

	public static String next() {
		while (tokenizer == null || !tokenizer.hasMoreTokens()) {
			try {
				tokenizer = new java.util.StringTokenizer(reader.readLine());
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}
		return tokenizer.nextToken();
	}

	private static double nd() {
		return Double.parseDouble(next());
	}

	private static long nl() {
		return Long.parseLong(next());
	}

	private static int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = ni();
		return a;
	}

	private static char[] ns() {
		return next().toCharArray();
	}

	private static long[] nal(int n) {
		long[] a = new long[n];
		for (int i = 0; i < n; i++)
			a[i] = nl();
		return a;
	}

	private static int[][] ntable(int n, int m) {
		int[][] table = new int[n][m];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				table[i][j] = ni();
			}
		}
		return table;
	}

	private static int[][] nlist(int n, int m) {
		int[][] table = new int[m][n];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				table[j][i] = ni();
			}
		}
		return table;
	}

	private static int ni() {
		return Integer.parseInt(next());
	}

	private static void tr(Object... o) {
		if (is != System.in)
			System.out.println(java.util.Arrays.deepToString(o));
	}
}
",5,5
"import java.util.Scanner;

public class TaskC {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt(), r = sc.nextInt();
		int[] xcords = new int[n];
		double[] ycords = new double[n];
		double y = r, x = 0, px = 0, ty = 0;
		for(int i = 0; i < n; i++) {
			xcords[i] = sc.nextInt();
			x = xcords[i];
			y = r;
			for(int j = 0; j < i; j++) {
				px = xcords[j];
				if(Math.abs(px - x) > r*2) continue;	
				ty = Math.sqrt(4*r*r - (x-px)*(x-px)) + ycords[j];
				y = Math.max(y, ty);
			}
			ycords[i] = y;
		}
		for(int i = 0; i < n; i++) {
			System.out.print(ycords[i] + "" "");
		}
	}

}
",5,5
"					import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.InputMismatchException;
public class Solution1 implements Runnable
{
	static final int MAX = 1000000007;
	static class InputReader
	{
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;
		private SpaceCharFilter filter;
		private BufferedReader br=new BufferedReader(new InputStreamReader(System.in));

		public InputReader(InputStream stream)
		{
			this.stream = stream;
		}
		
		public int read()
		{
			if (numChars==-1) 
				throw new InputMismatchException();
			
			if (curChar >= numChars)
			{
				curChar = 0;
				try 
				{
					numChars = stream.read(buf);
				}
				catch (IOException e)
				{
					throw new InputMismatchException();
				}
				
				if(numChars <= 0)				
					return -1;
			}
			return buf[curChar++];
		}
	 
		public String nextLine()
		{
			String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
		}
		public int nextInt()
		{
			int c = read();
			
			while(isSpaceChar(c)) 
				c = read();
			
			int sgn = 1;
			
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			
			int res = 0;
			do 
			{
				if(c<'0'||c>'9') 
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			while (!isSpaceChar(c)); 
			
			return res * sgn;
		}
		
		public long nextLong() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			long res = 0;
			
			do 
			{
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			while (!isSpaceChar(c));
				return res * sgn;
		}
		
		public double nextDouble() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-') 
			{
				sgn = -1;
				c = read();
			}
			double res = 0;
			while (!isSpaceChar(c) && c != '.') 
			{
				if (c == 'e' || c == 'E')
					return res * Math.pow(10, nextInt());
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			}
			if (c == '.') 
			{
				c = read();
				double m = 1;
				while (!isSpaceChar(c)) 
				{
					if (c == 'e' || c == 'E')
						return res * Math.pow(10, nextInt());
					if (c < '0' || c > '9')
						throw new InputMismatchException();
					m /= 10;
					res += (c - '0') * m;
					c = read();
				}
			}
			return res * sgn;
		}
		
		public String readString() 
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do 
			{
				res.appendCodePoint(c);
				c = read();
			} 
			while (!isSpaceChar(c));
			
			return res.toString();
		}
	 
		public boolean isSpaceChar(int c) 
		{
			if (filter != null)
				return filter.isSpaceChar(c);
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}
	 
		public String next() 
		{
			return readString();
		}
		
		public interface SpaceCharFilter 
		{
			public boolean isSpaceChar(int ch);
		}
	}
 	
	public static void main(String args[]) throws Exception
	{
		new Thread(null, new Solution1(),""Solution1"",1<<26).start();
	}
	public static int gcd(int a, int b)
    {
        if (a == 0)
            return b;
         
        return gcd(b%a, a);
    }
	 
	  static int lcm(int a, int b)
	    {
	        return (a*b)/gcd(a, b);
	    }
	static int max=  -1;
	public void run()
	{
		InputReader sc= new InputReader(System.in);
		PrintWriter w= new PrintWriter(System.out);
		int n = sc.nextInt();
		int r = sc.nextInt();
		int[] arr=  new int[n];
		for(int i = 0;i < n;i++){
			arr[i] = sc.nextInt();
		}
		double sqr = 2*r*2*r;
		double[] ans=  new double[n];
		for(int i = 0;i < arr.length;i++){
			ans[i] = r*1.0;
			for(int j = 0;j < i;j++){
				if(Math.abs(arr[i] - arr[j]) < 2*r){
					ans[i] = Math.max(ans[i],Math.sqrt(sqr - Math.abs(arr[i] - arr[j])*Math.abs(arr[i]-arr[j])) + ans[j]); 
				}else if(Math.abs(arr[i]-arr[j]) == 2*r){
					ans[i] = Math.max(ans[i],ans[j]);
				}
			}
		}
		for(int i = 0;i < ans.length;i++){
			System.out.printf(""%.7f "",ans[i]);
		}
		w.close();
	}

}",5,5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.StringTokenizer;

public class C {
	public static void main(String[] args) throws IOException {
		FastScanner in= new FastScanner(System.in);
		PrintWriter out= new PrintWriter(System.out);
		
		int n= in.nextInt();
		int r= in.nextInt();
		int [] x= new int[n];
		for (int i = 0; i < x.length; i++) {
			x[i]= in.nextInt();
		}
		double [] res= new double[n];
		res[0]= r;
		for (int i = 1; i < x.length; i++) {
			boolean found = false;
			for (int j = 0; j < i; j++) {
				double dis= Math.abs(x[i]-x[j]);
				double rr= 4.0*r*r-1.0*dis*dis;
				if(rr>=0) {
					double del= Math.sqrt(rr);
					res[i]= Math.max(res[i], res[j]+del);
					found= true;
				}
			}
			if(!found) {
				res[i]= r;
			}
		}
		for (int i = 0; i < res.length; i++) {
			out.print(res[i]+"" "");
		}
		out.close();
		
	}
	static class FastScanner {
		BufferedReader br;
		StringTokenizer st;

		public FastScanner(InputStream in) {
			br = new BufferedReader(new InputStreamReader(in));
			st = new StringTokenizer("""");
		}

		public String next() throws IOException {
			if (!st.hasMoreTokens()) {
				st = new StringTokenizer(br.readLine());
				return next();
			}
			return st.nextToken();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}
		public double nextDouble() throws NumberFormatException, IOException {
			return Double.parseDouble(next());
		}
		public long nextLong() throws IOException {
			return Long.parseLong(next());
		}
	}
}
",5,5
"
/**
 * @author: Mehul Raheja
 */

import java.util.*;
import java.io.*;

public class p3{

    /*
        Runtime = O()
     */
    static int N, M, K;
    static String s;
    static StringTokenizer st;
    static int[] d;
    
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int R = Integer.parseInt(st.nextToken());
        double[] x = new double[N];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            x[i] = Double.parseDouble(st.nextToken());
        }
        double[] y = new double[N];
        for (int i = 0; i < N; i++) {
          //  int found = -1;
            double maxy = R;
            for (int j = i-1; j >= 0; j--) {
                if(Math.abs(x[j] - x[i]) <= 2 * R){
                    maxy = Math.max(y[j] + inc(x[j] - x[i],R), maxy);
                }
            }
            
            y[i] = maxy;
        }
        
        for (int i = 0; i < y.length-1; i++) {
            System.out.print(y[i] + "" "");
        }
        System.out.println(y[y.length-1]);
       // System.out.println(Arrays.toString(y));
    }  
    
    public static  double inc(double x, double R){
        return Math.sqrt((4*R*R)-(x*x));
    }
}
",5,3
"
import java.io.*;
import java.util.StringTokenizer;

public class NewYearCurling908C {
    public static void main(String[] args) throws IOException {
        FastScanner in = new FastScanner();
        int n = in.nextInt();
        
        double r = (double) in.nextInt();
        double[] answers = new double[n];
        double[] xCoords = new double[n];
        for (int i = 0; i < n; i++) xCoords[i] = (double) in.nextInt();
        
        answers[0] = r;
        for (int i = 1; i < n; i++) {
            double bound = r;
            for (int j = 0; j < i; j++) {
                double xDif = xCoords[i] - xCoords[j];
                double y = answers[j];
                double yNew = y + Math.sqrt(4 * r * r - xDif * xDif);
                if (yNew > bound) bound = yNew;
            }
            answers[i] = bound;
        }
        for (int i = 0; i < n; i++) System.out.print(answers[i] + "" "");
        System.out.println();
    }

    public static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(String s) {
            try {
                br = new BufferedReader(new FileReader(s));
            } catch (FileNotFoundException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

        public FastScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String nextToken() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        String nextLine() {
            st = null;
            try {
                return br.readLine();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            return null;
        }

        int nextInt() {
            return Integer.parseInt(nextToken());
        }

        long nextLong() {
            return Long.parseLong(nextToken());
        }

        double nextDouble() {
            return Double.parseDouble(nextToken());
        }
    }
}
",5,5
"import java.io.* ;
import java.util.* ;
import java.text.* ;
import java.math.* ;
import static java.lang.Math.min ;
import static java.lang.Math.max ;
import static java.lang.Math.sqrt ;
public class Codeshefcode{
	public static void main(String[] args) throws IOException{
		Solver Machine = new Solver() ;
		Machine.Solve() ;
		Machine.Finish() ;
		// new Thread(null,new Runnable(){
		// 	public void run(){
		// 		Solver Machine = new Solver() ;
		// 		try{
		// 			Machine.Solve() ;
		// 			Machine.Finish() ;
		// 		}catch(Exception e){
		// 			e.printStackTrace() ;
		// 			System.out.flush() ;
		// 			System.exit(-1) ;
		// 		}catch(Error e){
		// 			e.printStackTrace() ;
		// 			System.out.flush() ;
		// 			System.exit(-1) ;
		// 		}
		// 	}
		// },""Solver"",1l<<27).start() ;
	}
}
class Mod{
	static long mod=1000000007 ;
	static long d(long a,long b){ return (a*MI(b))%mod ; }
	static long m(long a,long b){ return (a*b)%mod ; }
	static private long MI(long a){ return pow(a,mod-2) ; }
	static long pow(long a,long b){
		if(b<0) return pow(MI(a),-b) ;
		long val=a ; long ans=1 ;
		while(b!=0){
			if((b&1)==1) ans = (ans*val)%mod ; 
			val = (val*val)%mod ; 
			b/=2 ;
		}
		return ans ;
	}	
}
class pair implements Comparable<pair>{
	int x ; int y ; 
	pair(int x,int y){ this.x=x ; this.y=y ;} 
	public int compareTo(pair p){
		return (this.x<p.x ? -1 : (this.x>p.x ? 1 : (this.y<p.y ? -1 : (this.y>p.y ? 1 : 0)))) ;
	}
}
class Solver{
	Reader ip = new Reader(System.in) ;	  
	PrintWriter op = new PrintWriter(System.out) ;
	public void Solve() throws IOException{
		int n = ip.i() ; int r = ip.i() ;
		double x[] = new double[n] ;
		double y[] = new double[n] ;
		for(int i=0 ; i<n ; i++) x[i] = ip.i() ;
		for(int i=0 ; i<n ; i++){
			double my = 0 ;
			for(int j=0 ; j<i ; j++)
				my = max(my,func(x[j],y[j],r,x[i])) ;
			y[i] = my ;
		}
		for(int i=0 ; i<n ; i++) p((y[i]+r)+"" "") ;
		pln("""") ; 
	}
	double abd(double x,double y){
		return x>y ? x-y : y-x ;
	}
	double func(double x1,double y1,double r,double x2){
		if(abd(x1,x2)>(2*r)) return 0 ;
		if(abd(x1,x2)==(2*r)) return y1 ;
		double dx = x1-x2 ; 
		double dx2 = dx*dx ; 
		double val = sqrt(4*r*r-dx2) ;
		return y1+val ;
	}
	void Finish(){
		op.flush();
		op.close();
	}
	void p(Object o){
		op.print(o) ;
	}
	void pln(Object o){
		op.println(o) ;
	}		
}
class mylist extends ArrayList<Integer>{}
class myset extends TreeSet<Integer>{}
class mystack extends Stack<Integer>{}
class mymap extends TreeMap<Long,Integer>{}
class Reader{
	BufferedReader reader;
	StringTokenizer tokenizer;
	Reader(InputStream input) {
		reader = new BufferedReader(
					new InputStreamReader(input) );
		tokenizer = new StringTokenizer("""") ;
	}
	String s() throws IOException {
		while (!tokenizer.hasMoreTokens()){
			tokenizer = new StringTokenizer(
			reader.readLine()) ;
		}
		return tokenizer.nextToken();
	}
	int i() throws IOException {
		return Integer.parseInt(s()) ;
	}
	long l() throws IOException{
		return Long.parseLong(s()) ;
	}
	double d() throws IOException {
		return Double.parseDouble(s()) ;
	}
}
",5,5
"import java.util.*;
import java.io.*;

import static java.lang.Math.*;

public class Main {
    static int n;
     static long TotalTime;
    static Problem[] problems;
    static StringBuilder sb;
    public static void main(String[] args) {
        FastScanner sc = new FastScanner();
        sb = new StringBuilder();
        n = sc.nextInt();
        TotalTime = sc.nextLong();
        problems = new Problem[n];
        for (int i = 0; i < n; i++) {
            problems[i] = new Problem (sc.nextInt(), sc.nextLong(), i);
        }
        Arrays.sort(problems);
        long num = -1;
        long high = n;
        long low = 0;
        int iter = 0;
        while (high - low > 1) {
            num = (high + low) / 2;
            if (test(num, false)) {
                low = num;
            }
            else {
                high = num;
            }
        }
        if (test(high, false))
            num = high;
        else
            num = low;
        test(num, true);
        System.out.print(sb);
    }

    public static boolean test (long num, boolean print) {
        int count = 0;
        long sum = 0L;
        if (print) sb.append(num + ""\n"" + num + ""\n"");
        for (int i = 0; i < n && count < num; i++) {
            if (problems[i].a >= num) {
                count++;
                sum += problems[i].t;
                if (print) sb.append((problems[i].index + 1) + "" "");
            }
        }
        return (count == num) && (sum <= TotalTime);
    }

    public static class Problem implements Comparable<Problem>  {
        int a;
        long t;
        int index;
        
        public int compareTo(Problem o) {
          return Long.compare(t, o.t);
        }
        public Problem (int a, long t, int index) {
            this.a = a;
            this.t = t;
            this.index = index;
        }
    }


    public static class FastScanner {
        BufferedReader br;
        StringTokenizer st;

        public FastScanner(Reader in) {
            br = new BufferedReader(in);
        }

        public FastScanner() {
            this(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String readNextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        int[] readIntArray(int n) {
            int[] a = new int[n];
            for (int idx = 0; idx < n; idx++) {
                a[idx] = nextInt();
            }
            return a;
        }

        long[] readLongArray(int n) {
            long[] a = new long[n];
            for (int idx = 0; idx < n; idx++) {
                a[idx] = nextLong();
            }
            return a;
        }
    }
}",4,3
"import java.util.*;

import java.io.*;
import java.math.*;
import java.awt.geom.*;

import static java.lang.Math.*;

public class Solution implements Runnable {

	long mod1 = (long) 1e9 + 7;
	int mod2 = 998244353;

	public void solve() throws Exception {
		int n=sc.nextInt();
		int t=sc.nextInt();
		Pair arr[]=new Pair[n];
		int another[]=new int[n];
		for(int i=0;i<n;i++) {
			int ai=sc.nextInt();
			int time=sc.nextInt();
			arr[i]=new Pair(ai, time, i+1);
		}
		sort(arr);
		for(int i=0;i<n;i++) {
			another[i]=arr[i].a;
		}
		int maxscore=0;
		int maxai=n+1;
		int start=1;
		int end=n;
		while(start<=end) {
			int mid=start+(end-start)/2;
			int index=LowerBound(another, mid);
			PriorityQueue<Integer> pq=new PriorityQueue<Integer>((a,b)->(a-b));
			for(int i=index;i<n;i++) {
				pq.add(arr[i].time);
			}
			int maxtime=t;
			int score=0;
			while(maxtime>0 && !pq.isEmpty()) {
				maxtime -= pq.poll();
				if(maxtime>=0) score++;
			}
			if(score>=mid) {
				if(mid>=maxscore) {
					maxscore=mid;
					maxai=mid;
				}
				start=mid+1;
			}
			else {
				end=mid-1;
			}
			
		}
		
		int index=LowerBound(another, maxai);
		PriorityQueue<Integer> pq=new PriorityQueue<Integer>((a,b)->(arr[a].time-arr[b].time));
		for(int i=index;i<n;i++) {
			pq.add(i);
		}
		int maxtime=t;
		out.println(maxscore);
		out.println(maxscore);
		while(maxscore!=0 && !pq.isEmpty()) {
			out.print(arr[pq.poll()].index+"" "");
			maxscore--;
		}
		out.println();
		
		
		
		

	}
	
	class Pair implements Comparable<Pair>{
		int a;
		int time;
		int index;
		Pair(int a, int time, int index) {
			this.a=a;
			this.time=time;
			this.index=index;
		}
		
		public int compareTo(Pair x) {
			return this.a-x.a;
		}
	}

	static long gcd(long a, long b) {
		if (a == 0)
			return b;
		return gcd(b % a, a);
	}

	static void sort(Pair[] a) {
		ArrayList<Pair> l = new ArrayList<>();
		for (Pair i : a)
			l.add(i);
		Collections.sort(l);
		for (int i = 0; i < a.length; i++)
			a[i] = l.get(i);
	}

	static long ncr(int n, int r, long p) {
		if (r > n)
			return 0l;
		if (r > n - r)
			r = n - r;

		long C[] = new long[r + 1];

		C[0] = 1;

		for (int i = 1; i <= n; i++) {

			for (int j = Math.min(i, r); j > 0; j--)
				C[j] = (C[j] + C[j - 1]) % p;
		}
		return C[r] % p;
	}

	void sieveOfEratosthenes(boolean prime[], int size) {
		for (int i = 0; i < size; i++)
			prime[i] = true;

		for (int p = 2; p * p < size; p++) {
			if (prime[p] == true) {
				for (int i = p * p; i < size; i += p)
					prime[i] = false;
			}
		}
	}

	static int LowerBound(int a[], int x) { // smallest index having value >= x; returns 0-based index
		int l = -1, r = a.length;
		while (l + 1 < r) {
			int m = (l + r) >>> 1;
			if (a[m] >= x)
				r = m;
			else
				l = m;
		}
		return r;
	}

	static int UpperBound(int a[], int x) {// biggest index having value <= x; returns 1-based index
		int l = -1, r = a.length;
		while (l + 1 < r) {
			int m = (l + r) >>> 1;
			if (a[m] <= x)
				l = m;
			else
				r = m;
		}
		return l + 1;
	}

	public long power(long x, long y, long p) {
		long res = 1;
		// out.println(x+"" ""+y);
		x = x % p;
		if (x == 0)
			return 0;

		while (y > 0) {
			if ((y & 1) == 1)
				res = (res * x) % p;
			y = y >> 1;
			x = (x * x) % p;
		}
		return res;
	}

	static Throwable uncaught;

	BufferedReader in;
	FastScanner sc;
	PrintWriter out;

	@Override
	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			sc = new FastScanner(in);
			solve();
		} catch (Throwable uncaught) {
			Solution.uncaught = uncaught;
		} finally {
			out.close();
		}
	}

	public static void main(String[] args) throws Throwable {
		Thread thread = new Thread(null, new Solution(), """", (1 << 26));
		thread.start();
		thread.join();
		if (Solution.uncaught != null) {
			throw Solution.uncaught;
		}
	}

}

class FastScanner {

	BufferedReader in;
	StringTokenizer st;

	public FastScanner(BufferedReader in) {
		this.in = in;
	}

	public String nextToken() throws Exception {
		while (st == null || !st.hasMoreTokens()) {
			st = new StringTokenizer(in.readLine());
		}
		return st.nextToken();
	}

	public int nextInt() throws Exception {
		return Integer.parseInt(nextToken());
	}

	public int[] readArray(int n) throws Exception {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public long nextLong() throws Exception {
		return Long.parseLong(nextToken());
	}

	public double nextDouble() throws Exception {
		return Double.parseDouble(nextToken());
	}

}",4,3
"import java.util.*;

import java.io.*;
import java.math.*;
import java.awt.geom.*;

import static java.lang.Math.*;

public class Solution implements Runnable {

	long mod1 = (long) 1e9 + 7;
	int mod2 = 998244353;

	public void solve() throws Exception {
		int n=sc.nextInt();
		int t=sc.nextInt();
		Pair arr[]=new Pair[n];
		int another[]=new int[n];
		for(int i=0;i<n;i++) {
			int ai=sc.nextInt();
			int time=sc.nextInt();
			arr[i]=new Pair(ai, time, i+1);
		}
		sort(arr);
		for(int i=0;i<n;i++) {
			another[i]=arr[i].a;
		}
		int maxscore=0;
		int maxai=n+1;
		int start=1;
		int end=n;
		while(start<=end) {
			int mid=start+(end-start)/2;
			int index=LowerBound(another, mid);
			if(n-index<mid) {
				end=mid-1;
				continue;
			}
			PriorityQueue<Integer> pq=new PriorityQueue<Integer>((a,b)->(a-b));
			for(int i=index;i<n;i++) {
				pq.add(arr[i].time);
			}
			int maxtime=t;
			int score=0;
			while(maxtime>0 && !pq.isEmpty()) {
				maxtime -= pq.poll();
				if(maxtime>=0) score++;
			}
			if(score>=mid) {
				if(mid>=maxscore) {
					maxscore=mid;
					maxai=mid;
				}
				start=mid+1;
			}
			else {
				end=mid-1;
			}
			
		}
		
		int index=LowerBound(another, maxai);
		PriorityQueue<Integer> pq=new PriorityQueue<Integer>((a,b)->(arr[a].time-arr[b].time));
		for(int i=index;i<n;i++) {
			pq.add(i);
		}
		int maxtime=t;
		out.println(maxscore);
		out.println(maxscore);
		while(maxscore!=0 && !pq.isEmpty()) {
			out.print(arr[pq.poll()].index+"" "");
			maxscore--;
		}
		out.println();
		
		
		
		

	}
	
	class Pair implements Comparable<Pair>{
		int a;
		int time;
		int index;
		Pair(int a, int time, int index) {
			this.a=a;
			this.time=time;
			this.index=index;
		}
		
		public int compareTo(Pair x) {
			return this.a-x.a;
		}
	}

	static long gcd(long a, long b) {
		if (a == 0)
			return b;
		return gcd(b % a, a);
	}

	static void sort(Pair[] a) {
		ArrayList<Pair> l = new ArrayList<>();
		for (Pair i : a)
			l.add(i);
		Collections.sort(l);
		for (int i = 0; i < a.length; i++)
			a[i] = l.get(i);
	}

	static long ncr(int n, int r, long p) {
		if (r > n)
			return 0l;
		if (r > n - r)
			r = n - r;

		long C[] = new long[r + 1];

		C[0] = 1;

		for (int i = 1; i <= n; i++) {

			for (int j = Math.min(i, r); j > 0; j--)
				C[j] = (C[j] + C[j - 1]) % p;
		}
		return C[r] % p;
	}

	void sieveOfEratosthenes(boolean prime[], int size) {
		for (int i = 0; i < size; i++)
			prime[i] = true;

		for (int p = 2; p * p < size; p++) {
			if (prime[p] == true) {
				for (int i = p * p; i < size; i += p)
					prime[i] = false;
			}
		}
	}

	static int LowerBound(int a[], int x) { // smallest index having value >= x; returns 0-based index
		int l = -1, r = a.length;
		while (l + 1 < r) {
			int m = (l + r) >>> 1;
			if (a[m] >= x)
				r = m;
			else
				l = m;
		}
		return r;
	}

	static int UpperBound(int a[], int x) {// biggest index having value <= x; returns 1-based index
		int l = -1, r = a.length;
		while (l + 1 < r) {
			int m = (l + r) >>> 1;
			if (a[m] <= x)
				l = m;
			else
				r = m;
		}
		return l + 1;
	}

	public long power(long x, long y, long p) {
		long res = 1;
		// out.println(x+"" ""+y);
		x = x % p;
		if (x == 0)
			return 0;

		while (y > 0) {
			if ((y & 1) == 1)
				res = (res * x) % p;
			y = y >> 1;
			x = (x * x) % p;
		}
		return res;
	}

	static Throwable uncaught;

	BufferedReader in;
	FastScanner sc;
	PrintWriter out;

	@Override
	public void run() {
		try {
			in = new BufferedReader(new InputStreamReader(System.in));
			out = new PrintWriter(System.out);
			sc = new FastScanner(in);
			solve();
		} catch (Throwable uncaught) {
			Solution.uncaught = uncaught;
		} finally {
			out.close();
		}
	}

	public static void main(String[] args) throws Throwable {
		Thread thread = new Thread(null, new Solution(), """", (1 << 26));
		thread.start();
		thread.join();
		if (Solution.uncaught != null) {
			throw Solution.uncaught;
		}
	}

}

class FastScanner {

	BufferedReader in;
	StringTokenizer st;

	public FastScanner(BufferedReader in) {
		this.in = in;
	}

	public String nextToken() throws Exception {
		while (st == null || !st.hasMoreTokens()) {
			st = new StringTokenizer(in.readLine());
		}
		return st.nextToken();
	}

	public int nextInt() throws Exception {
		return Integer.parseInt(nextToken());
	}

	public int[] readArray(int n) throws Exception {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = nextInt();
		return a;
	}

	public long nextLong() throws Exception {
		return Long.parseLong(nextToken());
	}

	public double nextDouble() throws Exception {
		return Double.parseDouble(nextToken());
	}

}",4,3
"//package hello2018;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;

public class E3 {
	InputStream is;
	PrintWriter out;
	String INPUT = """";
	
	void solve()
	{
		String[] cs = ""!x&x, !(x|y|z), !x&!y&z, !x&!y, !x&!z&y, !x&!z, !(!y&!z|x|y&z), !(x|y&z), !x&y&z, !(!y&z|!z&y|x), !x&z, !(!z&y|x), !x&y, !(!y&z|x), !x&(y|z), !x, !y&!z&x, !y&!z, !(!x&!z|x&z|y), !(x&z|y), !(!x&!y|x&y|z), !(x&y|z), !(!x&!y|x&y|z)|!x&!y&z, !((x|y)&z|x&y), !x&y&z|!y&!z&x, !x&y&z|!y&!z, !x&z|!y&!z&x, !x&z|!y&!z, !x&y|!y&!z&x, !x&y|!y&!z, !x&(y|z)|!y&!z&x, !x|!y&!z, !y&x&z, !(!x&z|!z&x|y), !y&z, !(!z&x|y), !x&!z&y|!y&x&z, !x&!z|!y&x&z, !x&!z&y|!y&z, !x&!z|!y&z, !x&y&z|!y&x&z, !(!x&z|!z&x|y)|!x&y&z, !(x&y)&z, !(!z&x|y)|!x&z, !x&y|!y&x&z, !(!y&z|x)|!y&x&z, !x&y|!y&z, !x|!y&z, !y&x, !(!x&z|y), !y&(x|z), !y, !x&!z&y|!y&x, !x&!z|!y&x, !x&!z&y|!y&(x|z), !x&!z|!y, !x&y&z|!y&x, !(!x&z|y)|!x&y&z, !x&z|!y&x, !x&z|!y, !x&y|!y&x, !(!x&!y&z|x&y), !x&(y|z)|!y&x, !x|!y, !z&x&y, !(!x&y|!y&x|z), !x&!y&z|!z&x&y, !x&!y|!z&x&y, !z&y, !(!y&x|z), !x&!y&z|!z&y, !x&!y|!z&y, !x&y&z|!z&x&y, !(!x&y|!y&x|z)|!x&y&z, !x&z|!z&x&y, !(!z&y|x)|!z&x&y, !(x&z)&y, !(!y&x|z)|!x&y, !x&z|!z&y, !x|!z&y, !z&x, !(!x&y|z), !x&!y&z|!z&x, !x&!y|!z&x, !z&(x|y), !z, !x&!y&z|!z&(x|y), !x&!y|!z, !x&y&z|!z&x, !(!x&y|z)|!x&y&z, !x&z|!z&x, !(!x&!z&y|x&z), !x&y|!z&x, !x&y|!z, !x&(y|z)|!z&x, !x|!z, !y&x&z|!z&x&y, !(!x&y|!y&x|z)|!y&x&z, !y&z|!z&x&y, !(!z&x|y)|!z&x&y, !y&x&z|!z&y, !(!y&x|z)|!y&x&z, !y&z|!z&y, !(!y&!z&x|y&z), !x&y&z|!y&x&z|!z&x&y, !(!x&y|!y&x|z)|!x&y&z|!y&x&z, !(x&y)&z|!z&x&y, !(!z&x|y)|!x&z|!z&x&y, !(x&z)&y|!y&x&z, !(!y&x|z)|!x&y|!y&x&z, !(x&y)&z|!z&y, !x|!y&z|!z&y, !(y&z)&x, !(!x&y|z)|!y&x, !y&z|!z&x, !y|!z&x, !y&x|!z&y, !y&x|!z, !y&(x|z)|!z&y, !y|!z, !(y&z)&x|!x&y&z, !(!x&y|z)|!x&y&z|!y&x, !(x&y)&z|!z&x, !x&z|!y|!z&x, !(x&z)&y|!y&x, !x&y|!y&x|!z, !x&y|!y&z|!z&x, !(x&y&z), x&y&z, !(x|y|z)|x&y&z, !x&!y&z|x&y&z, !x&!y|x&y&z, !x&!z&y|x&y&z, !x&!z|x&y&z, !(!y&!z|x|y&z)|x&y&z, !(x|y&z)|x&y&z, y&z, !(x|y|z)|y&z, !x&z|y&z, !x&!y|y&z, !x&y|y&z, !x&!z|y&z, !x&(y|z)|y&z, !x|y&z, !y&!z&x|x&y&z, !y&!z|x&y&z, !(!x&!z|x&z|y)|x&y&z, !(x&z|y)|x&y&z, !(!x&!y|x&y|z)|x&y&z, !(x&y|z)|x&y&z, !(!x&!y|x&y|z)|!x&!y&z|x&y&z, !((x|y)&z|x&y)|x&y&z, !y&!z&x|y&z, !y&!z|y&z, !x&z|!y&!z&x|y&z, !(x&z|y)|y&z, !x&y|!y&!z&x|y&z, !(x&y|z)|y&z, !x&(y|z)|!y&!z&x|y&z, !x|!y&!z|y&z, x&z, !(x|y|z)|x&z, !y&z|x&z, !x&!y|x&z, !x&!z&y|x&z, !x&!z|x&z, !x&!z&y|!y&z|x&z, !(x|y&z)|x&z, (x|y)&z, !(x|y|z)|(x|y)&z, z, !x&!y|z, !x&y|x&z, !(!y&z|x)|x&z, !x&y|z, !x|z, !y&x|x&z, !y&!z|x&z, !y&(x|z)|x&z, !y|x&z, !x&!z&y|!y&x|x&z, !(x&y|z)|x&z, !x&!z&y|!y&(x|z)|x&z, !x&!z|!y|x&z, !y&x|y&z, !(!x&z|y)|y&z, !y&x|z, !y|z, !x&y|!y&x|x&z, !x&!z|!y&x|y&z, !x&y|!y&x|z, !x|!y|z, x&y, !(x|y|z)|x&y, !x&!y&z|x&y, !x&!y|x&y, !z&y|x&y, !x&!z|x&y, !x&!y&z|!z&y|x&y, !(x|y&z)|x&y, (x|z)&y, !(x|y|z)|(x|z)&y, !x&z|x&y, !(!z&y|x)|x&y, y, !x&!z|y, !x&z|y, !x|y, !z&x|x&y, !y&!z|x&y, !x&!y&z|!z&x|x&y, !(x&z|y)|x&y, !z&(x|y)|x&y, !z|x&y, !x&!y&z|!z&(x|y)|x&y, !x&!y|!z|x&y, !z&x|y&z, !(!x&y|z)|y&z, !x&z|!z&x|x&y, !x&!y|!z&x|y&z, !z&x|y, !z|y, !x&z|!z&x|y, !x|!z|y, (y|z)&x, !(x|y|z)|(y|z)&x, !y&z|x&y, !(!z&x|y)|x&y, !z&y|x&z, !(!y&x|z)|x&z, !y&z|!z&y|x&y, !x&!y|!z&y|x&z, (x|y)&z|x&y, !(x|y|z)|(x|y)&z|x&y, x&y|z, !x&!y|x&y|z, x&z|y, !x&!z|x&z|y, y|z, !x|y|z, x, !y&!z|x, !y&z|x, !y|x, !z&y|x, !z|x, !y&z|!z&y|x, !y|!z|x, x|y&z, !y&!z|x|y&z, x|z, !y|x|z, x|y, !z|x|y, x|y|z, !x|x"".split("", "");
		
		for(int Q = ni();Q > 0;Q--){
			char[] s = ns().toCharArray();
			int x = 0;
			for(int i = 0;i < 8;i++){
				x = x | s[i]-'0'<<i;
			}
			out.println(cs[x]);
		}
	}
	
	void run() throws Exception
	{
		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception { new E3().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}
	
	private char[][] nm(int n, int m)
	{
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}
	
	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}
	
	private int ni()
	{
		int num = 0, b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}
		
		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}
	
	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",5,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

/**
 * @author Don Li
 */
public class LogicalExpression {
    
    int N = 256;
    
    void solve() {
        Expression[] E = new Expression[N];
        for (int i = 0; i < N; i++) E[i] = new Expression();
        
        E[Integer.parseInt(""00001111"", 2)].update_f(""x"");
        E[Integer.parseInt(""00110011"", 2)].update_f(""y"");
        E[Integer.parseInt(""01010101"", 2)].update_f(""z"");
        
        for (int l = 2; l < 40; l++) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (E[i].e != null && E[j].t != null && E[i].e.length() + E[j].t.length() + 1 == l) {
                        E[i | j].update_e(E[i].e + '|' + E[j].t);
                    }
                    if (E[i].t != null && E[j].f != null && E[i].t.length() + E[j].f.length() + 1 == l) {
                        E[i & j].update_t(E[i].t + '&' + E[j].f);
                    }
                }
                if (E[i].f != null) E[i ^ (N - 1)].update_f('!' + E[i].f);
            }
        }
        
        String[] res = new String[N];
        for (int i = 0; i < N; i++) res[i] = E[i].calc_best();
        
        int n = in.nextInt();
        for (int i = 0; i < n; i++) {
            int x = Integer.parseInt(in.nextToken(), 2);
            out.println(res[x]);
        }
    }
    
    static class Expression {
        String e, t, f;
        
        Expression() {
        }
        
        public Expression(String e, String t, String f) {
            this.e = e;
            this.t = t;
            this.f = f;
        }
        
        String calc_best() {
            String best = e;
            if (compare(best, t) > 0) best = t;
            if (compare(best, f) > 0) best = f;
            return best;
        }
        
        void update_e(String ne) {
            if (e == null || compare(e, ne) > 0) {
                e = ne;
                update_f('(' + e + ')');
            }
        }
        
        void update_t(String nt) {
            if (t == null || compare(t, nt) > 0) {
                t = nt;
                update_e(t);
            }
        }
        
        void update_f(String nf) {
            if (f == null || compare(f, nf) > 0) {
                f = nf;
                update_t(f);
            }
        }
        
        int compare(String a, String b) {
            if (a.length() != b.length()) return Integer.compare(a.length(), b.length());
            return a.compareTo(b);
        }
    }
    
    public static void main(String[] args) {
        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));
        out = new PrintWriter(System.out);
        new LogicalExpression().solve();
        out.close();
    }
    
    static FastScanner in;
    static PrintWriter out;
    
    static class FastScanner {
        BufferedReader in;
        StringTokenizer st;
        
        public FastScanner(BufferedReader in) {
            this.in = in;
        }
        
        public String nextToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        
        public int nextInt() {
            return Integer.parseInt(nextToken());
        }
        
        public long nextLong() {
            return Long.parseLong(nextToken());
        }
        
        public double nextDouble() {
            return Double.parseDouble(nextToken());
        }
    }
}
",5,6
"//package contests.c913;

import java.io.*;
import java.util.*;

public class C913E implements Runnable {

    private void solve() throws Exception {
        String[][] m = new String[256][3];
        m[0b00001111][0] = ""x"";
        m[0b00110011][0] = ""y"";
        m[0b01010101][0] = ""z"";

        boolean changed;
        String s;
        int r;
        int tt = 0;
        do {
            tt++;
            changed = false;

            for (int i = 0; i < 256; i++) {
                for (int j = 0; j < 3; j++) {
                    if (m[i][j] == null) continue;

                    if (j > 0) {
                        s = ""("" + m[i][j] + "")"";
                        if (shouldReplace(m[i][0], s)) {
                            m[i][0] = s;
                            changed = true;
                        }
                    }

                    if (j == 0) {
                        r = (~i) & 0b11111111;
                        s = ""!"" + m[i][j];
                        if (shouldReplace(m[r][0], s)) {
                            m[r][0] = s;
                            changed = true;
                        }
                    }

                    for (int x = 0; x < 256; x++) {
                        for (int y = 0; y < 3; y++) {
                            if (m[x][y] == null) continue;

                            if (j < 2 && y < 2) {
                                r = i & x;
                                s = m[i][j] + ""&"" + m[x][y];
                                if (shouldReplace(m[r][1], s)) {
                                    m[r][1] = s;
                                    changed = true;
                                }
                            }

                            r = i | x;
                            s = m[i][j] + ""|"" + m[x][y];
                            if (shouldReplace(m[r][2], s)) {
                                m[r][2] = s;
                                changed = true;
                            }
                        }
                    }
                }
            }

        } while (changed);

        int n = i();
        for (int i = 0; i < n; i++) {
            int a = Integer.parseInt(s(), 2);
            System.out.println(get(m, a));
        }
    }

    boolean shouldReplace(String current, String candidate) {
        return current == null ||
                current.length() > candidate.length() ||
                current.length() == candidate.length() && current.compareTo(candidate) > 0;
    }

    String get(String[][] m, int n) {
        String s = m[n][0];
        if (shouldReplace(s, m[n][1])) s = m[n][1];
        if (shouldReplace(s, m[n][2])) s = m[n][2];
        return s;
    }

    public void run() {
        long start = System.currentTimeMillis();

        try {
            solve();
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            out.close();
        }

        if (!isOj)
            System.out.println(System.currentTimeMillis() - start + ""ms"");
    }

    public static void main(String[] args) throws Exception {
        new C913E().run();
    }

    InputStream inputStream;
    FastWriter out;

    private C913E() {
        this(System.in, System.out);
    }

    public C913E(InputStream inputStream, OutputStream outputStream) {
        this.inputStream = inputStream;
        this.out = new FastWriter(outputStream);
    }

    //@formatter:off
    private final byte[] inbuf = new byte[1024];
    private int lenbuf = 0, ptrbuf = 0;

    private int readByte() {
        if (lenbuf == -1) throw new InputMismatchException();
        if (ptrbuf >= lenbuf) {
            ptrbuf = 0;
            try {
                lenbuf = inputStream.read(inbuf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (lenbuf <= 0) return -1;
        }
        return inbuf[ptrbuf++];
    }

    private boolean isSpaceChar(int c) {
        return !(c >= 33 && c <= 126);
    }

    private int skip() {
        int b;
        while ((b = readByte()) != -1 && isSpaceChar(b)) ;
        return b;
    }

    private char c() { return (char) skip(); }
    private char[] ca(int n) {
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while (p < n && !(isSpaceChar(b))) {
            buf[p++] = (char) b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }
    private char[][] caa(int n, int m) {
        char[][] map = new char[n][];
        for (int i = 0; i < n; i++) map[i] = ca(m);
        return map;
    }

    private int i() { return (int) l(); }
    private int[] ia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = i();
        return a;
    }
    private int[][] iaa(int n, int m) {
        int[][] map = new int[n][];
        for (int i = 0; i < n; i++) map[i] = ia(m);
        return map;
    }
    private int[][] iaaT(int n, int m) {
        int[][] map = new int[m][];
        for (int i = 0; i < m; i++) map[i] = new int[n];
        for (int i = 0; i < n; i++) {
            int[] t = ia(m);
            for (int j = 0; j < m; j++) map[j][i] = t[j];
        }
        return map;
    }

    private long l() {
        long num = 0;
        int b;
        boolean minus = false;
        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;
        if (b == '-') {
            minus = true;
            b = readByte();
        }

        while (true) {
            if (b >= '0' && b <= '9') {
                num = num * 10 + (b - '0');
            } else {
                return minus ? -num : num;
            }
            b = readByte();
        }
    }
    private long[] la(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = l();
        return a;
    }

    private double d() { return Double.parseDouble(s()); }

    private String s() {
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    //@formatter:on

    public static class FastWriter {
        private static final int BUF_SIZE = 1 << 13;
        private final byte[] buf = new byte[BUF_SIZE];
        private final OutputStream out;
        private int ptr = 0;
        private boolean isFirst = true;

        public FastWriter(OutputStream os) {
            this.out = os;
        }

        private FastWriter write(byte b) {
            buf[ptr++] = b;
            if (ptr == BUF_SIZE)
                innerflush();
            return this;
        }

        private FastWriter write(char c) {
            return write((byte) c);
        }

        private FastWriter write(char[] s) {
            for (char c : s) {
                buf[ptr++] = (byte) c;
                if (ptr == BUF_SIZE) innerflush();
            }
            return this;
        }

        private FastWriter write(String s) {
            s.chars().forEach(c -> {
                buf[ptr++] = (byte) c;
                if (ptr == BUF_SIZE) innerflush();
            });
            return this;
        }

        public static int countDigits(int l) {
            if (l >= 1000000000) return 10;
            if (l >= 100000000) return 9;
            if (l >= 10000000) return 8;
            if (l >= 1000000) return 7;
            if (l >= 100000) return 6;
            if (l >= 10000) return 5;
            if (l >= 1000) return 4;
            if (l >= 100) return 3;
            if (l >= 10) return 2;
            return 1;
        }

        private FastWriter write(int x) {
            if (x == Integer.MIN_VALUE) {
                return write((long) x);
            }
            if (ptr + 12 >= BUF_SIZE) innerflush();
            if (x < 0) {
                write((byte) '-');
                x = -x;
            }
            int d = countDigits(x);
            for (int i = ptr + d - 1; i >= ptr; i--) {
                buf[i] = (byte) ('0' + x % 10);
                x /= 10;
            }
            ptr += d;
            return this;
        }

        public static int countDigits(long l) {
            if (l >= 1000000000000000000L) return 19;
            if (l >= 100000000000000000L) return 18;
            if (l >= 10000000000000000L) return 17;
            if (l >= 1000000000000000L) return 16;
            if (l >= 100000000000000L) return 15;
            if (l >= 10000000000000L) return 14;
            if (l >= 1000000000000L) return 13;
            if (l >= 100000000000L) return 12;
            if (l >= 10000000000L) return 11;
            if (l >= 1000000000L) return 10;
            if (l >= 100000000L) return 9;
            if (l >= 10000000L) return 8;
            if (l >= 1000000L) return 7;
            if (l >= 100000L) return 6;
            if (l >= 10000L) return 5;
            if (l >= 1000L) return 4;
            if (l >= 100L) return 3;
            if (l >= 10L) return 2;
            return 1;
        }

        private FastWriter write(long x) {
            if (x == Long.MIN_VALUE) {
                return write("""" + x);
            }
            if (ptr + 21 >= BUF_SIZE) innerflush();
            if (x < 0) {
                write((byte) '-');
                x = -x;
            }
            int d = countDigits(x);
            for (int i = ptr + d - 1; i >= ptr; i--) {
                buf[i] = (byte) ('0' + x % 10);
                x /= 10;
            }
            ptr += d;
            return this;
        }

        private FastWriter write(double x, int precision) {
            if (x < 0) {
                write('-');
                x = -x;
            }
            x += Math.pow(10, -precision) / 2;
            //		if(x < 0){ x = 0; }
            write((long) x).write(""."");
            x -= (long) x;
            for (int i = 0; i < precision; i++) {
                x *= 10;
                write((char) ('0' + (int) x));
                x -= (int) x;
            }
            return this;
        }

        public FastWriter writeDelimeter() {
            if (isFirst) {
                isFirst = false;
            } else {
                write(' ');
            }
            return this;
        }

        public FastWriter writeNewline() {
            write('\n');
            isFirst = true;
            return this;
        }

        private void innerflush() {
            try {
                out.write(buf, 0, ptr);
                ptr = 0;
            } catch (IOException e) {
                throw new RuntimeException(""innerflush"");
            }
        }

        public void flush() {
            innerflush();
            try {
                out.flush();
            } catch (IOException e) {
                throw new RuntimeException(""flush"");
            }
        }

        public void close() {
            writeNewline();
            flush();
        }
    }

    //@formatter:off
    private void w(int x) { out.writeDelimeter().write(x); }
    private void w(long x) { out.writeDelimeter().write(x); }
    private void w(double x) { out.writeDelimeter().write(x, 16); }
    private void lnw(int x) { out.writeNewline().write(x); }
    private void lnw(long x) { out.writeNewline().write(x); }

    private static int log(int a) {
        if (a <= 0) throw new RuntimeException(""log(a): a <= 0"");
        return Integer.SIZE - 1 - Integer.numberOfLeadingZeros(a);
    }
    private static int log(long a) {
        if(a <= 0) throw new RuntimeException(""log(a): a <= 0"");
        return Long.SIZE - 1 - Long.numberOfLeadingZeros(a);
    }
    private static int max(int a, int b) {return Math.max(a, b);}
    private static long max(long a, long b) {return Math.max(a, b);}
    private static int min(int a, int b) {return Math.min(a, b);}
    private static int min(int a, int b, int c) {return min(a, min(b, c));}
    private static int min(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}
    private static long min(long a, long b) {return Math.min(a, b);}
    private static long min(long a, long b, long c) {return min(a, min(b, c));}
    private static long min(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}
    private static int pow(int a, int b) {if (a == 0) return 0; int r = 1; while (b > 0) {if ((b & 1) > 0) r *= a; a *= a; b >>= 1;} return r;}
    private static long pow(long a, int b) {if (a == 0) return 0; long r = 1; while (b > 0) {if ((b & 1) > 0) r *= a; a *= a; b >>= 1;} return r;}
    //@formatter:on

    private final boolean isOj = System.getProperty(""ONLINE_JUDGE"") != null;
}
",5,5
"import java.io.*;
import java.util.*;
import java.math.*;
import java.lang.*;
 
import static java.lang.Math.*;

public class Main implements Runnable {
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }
        
        public int read() {
            if (numChars==-1) 
                throw new InputMismatchException();
            
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                }
                catch (IOException e) {
                    throw new InputMismatchException();
                }
                
                if(numChars <= 0)               
                    return -1;
            }
            return buf[curChar++];
        }
     
        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        public int nextInt() {
            int c = read();
            
            while(isSpaceChar(c)) 
                c = read();
            
            int sgn = 1;
            
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            
            int res = 0;
            do {
                if(c<'0'||c>'9') 
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c)); 
            
            return res * sgn;
        }
        
        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));
                return res * sgn;
        }
        
        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }
        
        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } 
            while (!isSpaceChar(c));
            
            return res.toString();
        }
     
        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
     
        public String next() {
            return readString();
        }
        
        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }
    public static void main(String args[]) throws Exception {
        new Thread(null, new Main(),""Main"",1<<26).start();
    }
    PriorityQueue<Integer> dfs(int i, int par) {
        ArrayList<PriorityQueue<Integer>> list = new ArrayList<>();
        PriorityQueue<Integer> largestQueue = new PriorityQueue<>();
        int largestSize = 0;
        for(int j : adj[i]) {
            if(j != par) {
                PriorityQueue<Integer> cur = dfs(j, i);
                if(cur.size() > largestSize) {
                    if(largestSize != 0)
                        list.add(largestQueue);
                    largestQueue = cur;
                    largestSize = cur.size();
                }
                else {
                    list.add(cur);
                }
            }
        }

        if(largestSize == 0) {
            PriorityQueue<Integer> queue = new PriorityQueue<>(new Comparator<Integer>() {
                public int compare(Integer i1, Integer i2) {
                    if(i1 > i2)
                        return -1;
                    if(i1 < i2)
                        return 1;
                    return 0;
                }
            });
            queue.add(1);
            cntLeaf++;
            return queue;
        }

        PriorityQueue<Integer> queue = largestQueue;
        for(int j = 0; j < list.size(); ++j) {
            PriorityQueue<Integer> cur = list.get(j);
            while(cur.size() != 0)
                queue.add(cur.poll());
        } 
        int maxV = queue.poll();
        queue.add(maxV + 1);
        return queue;
    }
    void dfsFindLevel(int i, int par, int level) {
        if(level > maxLevel) {
            maxLevel = level;
            maxNode = i;
        }
        for(int j : adj[i]) {
            if(j != par)
                dfsFindLevel(j, i, level + 1);
        }
    }
    ArrayList<Integer> adj[];
    int cntLeaf = 0;
    int maxLevel = -1, maxNode = -1;
    public void run() {
        InputReader sc = new InputReader(System.in);
        PrintWriter w = new PrintWriter(System.out);
        
        int n = sc.nextInt();

        adj = new ArrayList[n];
        for(int i = 0; i < n; ++i)
            adj[i] = new ArrayList<>();

        for(int i = 0; i < n - 1; ++i) {
            int u = sc.nextInt() - 1;
            int v = sc.nextInt() - 1;
            adj[u].add(v);
            adj[v].add(u);
        }

        dfsFindLevel(0, -1, 0);

        PriorityQueue<Integer> queue = dfs(maxNode, -1);
        int maxV = queue.poll();
        queue.add(maxV - 1);

        int cans = 1;
        for(int i = 0; i < cntLeaf; ++i) {
            w.print(cans + "" "");
            cans += queue.poll();
        }

        for(int i = cntLeaf; i < n; ++i)
            w.print(cans + "" "");

        w.close();      
    }
}",4,3
"import java.util.*;
import java.io.*;
import java.math.*;
 
public class Main {
    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        //Scanner sc = new Scanner();
        Reader in = new Reader();
        Main solver = new Main();
        solver.solve(out, in);
        out.flush();
        out.close();
 
    }
 
    static int INF = (int)1e5*4*4+5;
    static int maxn = (int)1e5*2+1;
    static int mod=(int)1e9+7 ;
    static int n,m,k,t,q,x,a,b,y;
    
    static ArrayList<Integer> adj[];
    static int[] dist,parent,back;
    static boolean[] vis,vist;
    static int root=0,ans=1;
    
    
    void solve(PrintWriter out, Reader in) throws IOException{
        n = in.nextInt();


        if(n==1) {out.println(1);return;}
        adj = new ArrayList[n+1];
        for(int i=1;i<=n;i++) 
            adj[i] = new ArrayList<Integer>();
        
        int u,v;
        for(int i=0;i<n-1;i++){
            u = in.nextInt();
            v = in.nextInt();
             
            adj[u].add(v);
            adj[v].add(u);
        }
        
        vist = new boolean[n+1];
        vis = new boolean[n+1];
        vist[1] =true;
        makeroot(1);
        
        parent = new int[n+1];
        dist = new int[n+1];
        back = new int[n+1];
        
        dfs(root,0);
        calcdist(root);
        
        vist = new boolean[n+1];
        vis = new boolean[n+1];
        vist[root] =true;
        
        

        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        for(int i=1;i<=n;i++){
            if(i!=root) pq.add(new Node(i,dist[i]));
        }
        
        Node elm;
        int rt = root;
        out.print(1);
        
        makeroot(root);
        removeNodes(root,rt);
        ans+=dist[rt];
        out.print("" ""+ans);
        int itr=2;
        for(int i=2;i<=n;i++){
            
            elm = pq.remove();
            if(vis[elm.idx]) continue;
            removeNodes(back[elm.idx],elm.idx);
            ans += elm.dist+1;
            out.print("" ""+ans);
            itr++;
        }
        for(int i=itr;i<n;i++)
            out.print("" ""+ans);
        out.println();
    }
    
    //<>
    
    static class Node implements Comparable<Node>{
        int dist,idx;
        
        Node(int idx,int dist){
            this.idx = idx;
            this.dist = dist;
        }
        
        public int compareTo(Node o) {
            return o.dist-this.dist;
        }
    }
    
    static void removeNodes(int s,int e){
        vis[s]=true;
        while(s!=e){
            vis[s] = true;
            s = parent[s];
        }
        vis[s]=true;
        return;
    }
    
    static int calcdist(int s){
        int res=0;
        int tmp=0;
        for(int e:adj[s]){
            if(e!=parent[s]){
                tmp= calcdist(e);
                if(1+tmp>res){
                    res = 1+tmp;
                    back[s] = back[e];
                }
            }
        }
        
        if(res==0) back[s]=s;
        return dist[s] = res;
    }
    
    static void dfs(int s,int p){
        for(int e:adj[s]){
            if(e!=p){
                parent[e]=s;
                dfs(e,s);
            }
        }
        return;
    }
    
    static void makeroot(int s){
        Queue<Integer> q = new LinkedList<>();
        q.add(s);
        
        int elm=0;
        while(q.size()!=0){
            elm = q.remove();
            for(int e:adj[elm]){
                if(!vist[e]){
                    vist[e]=true;
                    q.add(e);
                    root = e;
                }
            }
        }
        return;
    }
    
    
    static class Reader {

    private InputStream mIs;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public Reader() {
        this(System.in);
    }

    public Reader(InputStream is) {
        mIs = is;
    }

    public int read() {
        if (numChars == -1) {
            throw new InputMismatchException();

    }
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = mIs.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0) {
                return -1;
            }
        }
        return buf[curChar++];
    }

    public String nextLine() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isEndOfLine(c));
        return res.toString();
    }

    public String next() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        StringBuilder res = new StringBuilder();
        do {
            res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    double nextDouble()
    {
        return Double.parseDouble(next());
    }

    public long nextLong() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public int nextInt() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public boolean isEndOfLine(int c) {
        return c == '\n' || c == '\r' || c == -1;
    }

    }
}",4,3
"import java.io.*;
import java.util.*;

public class MainB {
	static final StdIn in = new StdIn();
	static final PrintWriter out = new PrintWriter(System.out);
	
	public static void main(String[] args) {
		int n=in.nextInt();
		List<Integer>[] adj = new List[n];
		for(int i=0; i<n; ++i)
			adj[i] = new ArrayList<Integer>();
		for(int i=0; i<n-1; ++i) {
			int u=in.nextInt()-1, v=in.nextInt()-1;
			adj[u].add(v);
			adj[v].add(u);
		}
		int[] qu = new int[n], dist = new int[n], ans = new int[n], par = new int[n];
		int qt=0, qh=0, u=-1;
		qu[qt++]=0;
		Arrays.fill(dist, n);
		dist[0]=0;
		while(qh<qt) {
			u=qu[qh++];
			for(int v : adj[u]) {
				if(dist[v]>=n) {
					qu[qt++]=v;
					dist[v]=dist[u]+1;
				}
			}
		}
		qt=0;
		qh=0;
		qu[qt++]=u;
		Arrays.fill(dist, n);
		dist[u]=0;
		while(qh<qt) {
			u=qu[qh++];
			for(int v : adj[u]) {
				if(dist[v]>=n) {
					qu[qt++]=v;
					par[v]=u;
					dist[v]=dist[u]+1;
				}
			}
		}
		for(int i=n-1; i>=0; --i) {
			dist[qu[i]]=Math.max(-dist[qu[i]], 0);
			if(i>0)
				dist[par[qu[i]]]=Math.min(-(dist[qu[i]]+1), dist[par[qu[i]]]);
		}
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>(new Comparator<Integer>() {
			public int compare(Integer a, Integer b) {
				return -(dist[a]-dist[b]);
			}
		});
		pq.add(qu[0]);
		for(int i=1; i<n; ++i) {
			if(pq.isEmpty()) {
				ans[i]=ans[i-1];
				continue;
			}
			u=pq.poll();
			ans[i]=ans[i-1]+dist[u]+1;
			while(dist[u]>0) {
				int mv=-1;
				for(int v : adj[u])
					if(v!=par[u]&&(mv==-1||dist[v]>dist[mv]))
						mv=v;
				for(int v : adj[u])
					if(v!=par[u]&&v!=mv)
						pq.add(v);
				u=mv;
			}
		}
		ans[0]=1;
		for(int i=0; i<n; ++i)
			out.print(ans[i]+"" "");
		out.close();
	}
	
	static class StdIn {
		final private int BUFFER_SIZE = 1 << 16;
		private DataInputStream din;
		private byte[] buffer;
		private int bufferPointer, bytesRead;
		public StdIn() {
			din = new DataInputStream(System.in);
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public StdIn(InputStream in) {
			try{
				din = new DataInputStream(in);
			} catch(Exception e) {
				throw new RuntimeException();
			}
			buffer = new byte[BUFFER_SIZE];
			bufferPointer = bytesRead = 0;
		}
		public String next() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == ' ' || c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c=read();
			}
			return s.toString();
		}
		public String nextLine() {
			int c;
			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));
			StringBuilder s = new StringBuilder();
			while (c != -1)
			{
				if (c == '\n'||c=='\r')
					break;
				s.append((char)c);
				c = read();
			}
			return s.toString();
		}
		public int nextInt() {
			int ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');

			if (neg)
				return -ret;
			return ret;
		}
		public int[] readIntArray(int n, int os) {
			int[] ar = new int[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextInt()+os;
			return ar;
		}
		public long nextLong() {
			long ret = 0;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (neg)
				return -ret;
			return ret;
		}
		public long[] readLongArray(int n, long os) {
			long[] ar = new long[n];
			for(int i=0; i<n; ++i)
				ar[i]=nextLong()+os;
			return ar;
		}
		public double nextDouble() {
			double ret = 0, div = 1;
			byte c = read();
			while (c <= ' ')
				c = read();
			boolean neg = (c == '-');
			if (neg)
				c = read();
			do
				ret = ret * 10 + c - '0';
			while ((c = read()) >= '0' && c <= '9');
			if (c == '.')
				while ((c = read()) >= '0' && c <= '9')
					ret += (c - '0') / (div *= 10);
			if (neg)
				return -ret;
			return ret;
		}
		private void fillBuffer() throws IOException {
			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
			if (bytesRead == -1)
				buffer[0] = -1;
		}
		private byte read() {
			try{
				if (bufferPointer == bytesRead)
					fillBuffer();
				return buffer[bufferPointer++];
			} catch(IOException e) {
				throw new RuntimeException();
			}
		}
		public void close() throws IOException {
			if (din == null)
				return;
			din.close();
		}
	}
}",4,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.StringTokenizer;

public class Solution{
	
	static final long N = (long)1e9+10;
	
	
	
    public static void main(String[] args) throws IOException {
    	
		
    	FastScanner fs = new FastScanner();
    	PrintWriter out = new PrintWriter(System.out);
    		
    	int tt = 1;
    	while(tt-->0) {
    		
    		int n = fs.nextInt();
    		long a = fs.nextLong(), b = fs.nextLong();
    		
    		HashMap<Long, Integer> map = new HashMap<>();
    		HashMap<Long, Integer> col = new HashMap<>();
    		
    		long ans = 0;
    		
    		for(int i=0;i<n;i++) {
    			fs.next();
    			long x = fs.nextLong();
    			long y = fs.nextLong();
    			long k = a*x - y;
    			ans += 2*map.getOrDefault(k, 0);
    			long nx = x + N, ny = y + N;
    			long concat = (nx<<32)|ny;
    			ans -= 2*col.getOrDefault(concat, 0);
    			map.put(k, map.getOrDefault(k, 0)+1);
    			col.put(concat, col.getOrDefault(concat, 0)+1);
    		}
    		
    		
    		out.println(ans);
    		
    		
    		
    		
    		
    		
    		
    		
    		
    	}
    	
    	out.close();
    		
    }
    
    
   
    
    
    
    static final Random random=new Random();
    
    static <T> void shuffle(T[] arr) {
    	int n = arr.length;
    	for(int i=0;i<n;i++	) {
    		int k = random.nextInt(n);
    		T temp = arr[k]; arr[k] = arr[i]; arr[i] = temp;
    	}
    }
    
    	
    static void ruffleSort(int[] a) {
    	int n=a.length;//shuffle, then sort 
    	for (int i=0; i<n; i++) {
    		int oi=random.nextInt(n); int temp=a[oi];
    		a[oi]=a[i]; a[i]=temp;
    	}
    	Arrays.sort(a);
    }
    
    static void ruffleSort(long[] a) {
    	int n=a.length;//shuffle, then sort 
    	for (int i=0; i<n; i++) {
    		int oi=random.nextInt(n); long temp=a[oi];
    		a[oi]=a[i]; a[i]=temp;
    	}
    	Arrays.sort(a);
    }
   
  
    
    static void reverse(int[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++){
    		int temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    
    static void reverse(long[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++){
    		long temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    
    
    static <T> void reverse(T[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++) {
    		T temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    	
    	
    static class FastScanner{
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer st = new StringTokenizer("""");
     
    	public String next(){
    		while(!st.hasMoreElements()){
    			try{
    				st = new StringTokenizer(br.readLine());
    			} catch(IOException e){
    				e.printStackTrace();
    			}
    		}
    		return st.nextToken();
    	}
    		
    	public String nextLine() throws IOException {
    		return br.readLine();
    	}
    		
    	public int nextInt(){
    		return Integer.parseInt(next());
    	}
     
    	public int[] readArray(int n){
    		int[] a = new int[n];
    		for(int i=0;i<n;i++)
    			a[i] = nextInt();
    		return a;
    	}
    		
    	public long nextLong() {
    		return Long.parseLong(next());
    	}
    		
    	public char nextChar() {
    		return next().toCharArray()[0];
    	}
    }
   	
}
",3,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Objects;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.StringTokenizer;

public class Solution{
	
	static final long N = (long)1e9+10;
	
	
	
    public static void main(String[] args) throws IOException {
    	
		
    	FastScanner fs = new FastScanner();
    	PrintWriter out = new PrintWriter(System.out);
    		
    	int tt = 1;
    	while(tt-->0) {
    		
    		int n = fs.nextInt();
    		long a = fs.nextLong(), b = fs.nextLong();
    		
    		HashMap<Long, Integer> map = new HashMap<>();
    		HashMap<Pair, Integer> col = new HashMap<>();
    		
    		long ans = 0;
    		
    		for(int i=0;i<n;i++) {
    			fs.next();
    			Pair p = new Pair(fs.nextLong(), fs.nextLong());
    			long k = a*p.x - p.y;
    			ans += 2*map.getOrDefault(k, 0);
    			ans -= 2*col.getOrDefault(p, 0);
    			map.put(k, map.getOrDefault(k, 0)+1);
    			col.put(p, col.getOrDefault(p, 0)+1);
    		}
    		
    		
    		out.println(ans);
    		
    		
    		
    		
    		
    		
    		
    		
    		
    	}
    	
    	out.close();
    		
    }
    
    
    static class Pair{
    	long x, y;
    	
    	Pair(long x, long y){
    		this.x = x; this.y = y;
    	}
    	
    	@Override
    	public boolean equals(Object obj) {
    		if(obj==this) return true;
    		if(!(obj instanceof Pair)) return true;
    		Pair p = (Pair)obj;
    		return p.x==x && p.y==y;
    	}
    	
    	
    	@Override
    	public int hashCode() {
    		return Objects.hash(this.x, this.y);
    	}
    	
    }
   
    
    
    
    static final Random random=new Random();
    
    static <T> void shuffle(T[] arr) {
    	int n = arr.length;
    	for(int i=0;i<n;i++	) {
    		int k = random.nextInt(n);
    		T temp = arr[k]; arr[k] = arr[i]; arr[i] = temp;
    	}
    }
    
    	
    static void ruffleSort(int[] a) {
    	int n=a.length;//shuffle, then sort 
    	for (int i=0; i<n; i++) {
    		int oi=random.nextInt(n); int temp=a[oi];
    		a[oi]=a[i]; a[i]=temp;
    	}
    	Arrays.sort(a);
    }
    
    static void ruffleSort(long[] a) {
    	int n=a.length;//shuffle, then sort 
    	for (int i=0; i<n; i++) {
    		int oi=random.nextInt(n); long temp=a[oi];
    		a[oi]=a[i]; a[i]=temp;
    	}
    	Arrays.sort(a);
    }
   
  
    
    static void reverse(int[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++){
    		int temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    
    static void reverse(long[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++){
    		long temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    
    
    static <T> void reverse(T[] arr, int l, int r) {
    	for(int i=l;i<l+(r-l)/2;i++) {
    		T temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;
    	}
    }
    	
    	
    static class FastScanner{
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer st = new StringTokenizer("""");
     
    	public String next(){
    		while(!st.hasMoreElements()){
    			try{
    				st = new StringTokenizer(br.readLine());
    			} catch(IOException e){
    				e.printStackTrace();
    			}
    		}
    		return st.nextToken();
    	}
    		
    	public String nextLine() throws IOException {
    		return br.readLine();
    	}
    		
    	public int nextInt(){
    		return Integer.parseInt(next());
    	}
     
    	public int[] readArray(int n){
    		int[] a = new int[n];
    		for(int i=0;i<n;i++)
    			a[i] = nextInt();
    		return a;
    	}
    		
    	public long nextLong() {
    		return Long.parseLong(next());
    	}
    		
    	public char nextChar() {
    		return next().toCharArray()[0];
    	}
    }
   	
}
",3,3
"import java.io.*;
import java.util.*;

public class Main {
    public void solve() {
        int n = ni();
        int a = ni();
        int b = ni();

        long ans = 0;
        HashMap<Long, Long> m = new HashMap<>();
        HashMap<String, Long> s = new HashMap<>();

        for (int i = 0; i < n; i++) {
            ni();
            long vx = ni();
            long vy = ni();
            long v = (long) a * vx - vy;
            String k = vx + ""|"" + vy;
            long cs = s.getOrDefault(k, 0L);
            long c = m.getOrDefault(v, 0L);
            ans += c - cs;
            m.put(v, c + 1);
            s.put(k, cs + 1);
        }
        write (ans * 2 + ""\n"");
    }



    public static void main(String[] args) {
        Main m = new Main();
        m.solve();
        try {
            m.out.close();
        } catch (IOException e) {}
    }

    BufferedReader in;
    BufferedWriter out;
    StringTokenizer tokenizer;
    public Main() {
        in = new BufferedReader(new InputStreamReader(System.in));
        out = new BufferedWriter(new OutputStreamWriter(System.out));
    }
    public String n() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(in.readLine());
            } catch (IOException e) {}
        }
        return tokenizer.nextToken();
    }
    public int ni() {
        return Integer.parseInt(n());
    }
    public long nl() {
        return Long.parseLong(n());
    }
    public void write(String s) {
        try {
            out.write(s);
        } catch (IOException e) {}
    }
}",3,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class CoveredPointsCount {
	
	//UPSOLVE
	
	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
	        
		int n = Integer.parseInt(st.nextToken());
	     
		long[] myArray = new long[2 * n];
	        
			for (int i = 0; i < n; i++)  {
	        	StringTokenizer st1 = new StringTokenizer(br.readLine());
	        	myArray[2 * i] = Long.parseLong(st1.nextToken()) * 2;
	        	myArray[2 * i + 1] = Long.parseLong(st1.nextToken()) * 2 + 1;
	        }  
	        
	        Arrays.sort(myArray);
	        long[] ans = new long[n + 1];
	        int cnt = 0;
	       
	        for (int i = 0; i < 2 * n - 1; i++)   {
	            if (myArray[i] % 2 == 0) cnt++; else cnt--;
	            ans[cnt] += (myArray[i + 1] + 1) / 2 - (myArray[i] + 1) / 2;
	        }   
	        
	        StringBuilder answer = new StringBuilder();
	        
	        for (int i = 1; i < n + 1; i++) {
	        	answer.append(ans[i]);
	        	answer.append("" "");
	        }  
	        
	        System.out.println(answer);

	}

}
",4,3
"    import java.util.*;
    import java.io.*;
    //import java.lang.*;

    public class ranjan{

        public static Read cin;
        //public static InputReader cin;
        public static PrintWriter cout;
        public static int[] visited;
        public static final long bil = (long)1e9+7;
        public static int fileread = 0; 
        
        public static void main(String ...arg) throws IOException
        {
            /*console writer*/
            cout = new PrintWriter(new BufferedOutputStream(System.out));
            /*Debug Reader*/
            //Scan cin =new Scan();clear
            
            if(fileread == 1)
            {
                try
                {
                cin = new Read(new FileInputStream(new File(""in3.txt"")));
                //cin = new InputReader(new FileInputStream(new File(""in1.txt"")));
                }
                catch (IOException error){}
            }
            else{
                cin = new Read(System.in);
                //cin = new InputReader(System.in);
            }

            //input
            int n = cin.nextInt();
            HashSet<Long> ls = new HashSet<>();
            long[] q1 = new long[n];
            long[] q2 = new long[n];

            for(int i=0;i<n;i++){
                q1[i] = cin.nextLong();
                q2[i] = cin.nextLong()+1;
                ls.add(q1[i]);
                ls.add(q2[i]);
            }
            long[] compress = new long[ls.size()];
            int index = 0;
            for(Long x:ls)
                compress[index++] = x;
            Arrays.sort(compress);

            //process
            int[] prefix = new int[compress.length];
            for(int i=0;i<n;i++){
                prefix[Arrays.binarySearch(compress, q1[i])]++;
                prefix[Arrays.binarySearch(compress, q2[i])]--;
            }

            for(int i=1;i<compress.length;i++)
                prefix[i] += prefix[i-1];

            long[] ans = new long[n];
            for(int i=0;i<compress.length-1;i++){
                if(prefix[i] != 0)
                    ans[prefix[i]-1] +=  compress[i+1]-compress[i];
            }

            //output
            for(long x:ans)
                cout.print(x+"" "");


            cout.print(""\n"");
            cout.close();
        }


        private static class Pair{
            public int a,b;
            public Pair(int a,int b)
            {
                this.a = a;
                this.b = b;
            }	
        }


        /*public static void seive(int size)
        {
            prime[0] = prime[1] = false;
            int p = 2;
            while(p*p<= size)
            {
                if(prime[p])
                {
                    for(int i=p*p;i<size;i += p)

                        prime[i] = false;
                }
                p++;
            }
        }*/


        public static <K, V> V getOrDefault(HashMap<K,V> map, K key, V defaultValue) {
            return map.containsKey(key) ? map.get(key) : defaultValue;
        }
        
        static void reverseArray(int intArray[], int size) 
        { 
            int i, temp; 
            for (i = 0; i < size / 2; i++) { 
                temp = intArray[i]; 
                intArray[i] = intArray[size - i - 1]; 
                intArray[size - i - 1] = temp; 
            }  
        } 

        public static long mod_pow(long x,long n,long mod) {
            long res=1;
            while(n>0) {
                if((n&1)==1)res=res*x%mod;
                x=x*x%mod;
                n>>=1;
            }
            return res;
        }
        public static int gcd(int n1, int n2) 
        {
            int r;
            while (n2 != 0) 
            {
                r = n1 % n2;
                n1 = n2;
                n2 = r;
            }
            return n1;
        }
    
        /*public static int lcm(int n1, int n2) 
        {
            int answer = (n1 * n2) / (gcd(n1, n2));
            return answer;
        }*/


        static class InputReader {
            final InputStream is;
            final byte[] buf = new byte[1024];
            int pos;
            int size;
    
            public InputReader(InputStream is) {
                this.is = is;
            }
    
            public int nextInt() {
                int c = read();
                while (isWhitespace(c))
                    c = read();
                int sign = 1;
                if (c == '-') {
                    sign = -1;
                    c = read();
                }
                int res = 0;
                do {
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    res = res * 10 + c - '0';
                    c = read();
                } while (!isWhitespace(c));
                return res * sign;
            }
    
            int read() {
                if (size == -1)
                    throw new InputMismatchException();
                if (pos >= size) {
                    pos = 0;
                    try {
                        size = is.read(buf);
                    } catch (IOException e) {
                        throw new InputMismatchException();
                    }
                    if (size <= 0)
                        return -1;
                }
                return buf[pos++] & 255;
            }
    
            static boolean isWhitespace(int c) {
                return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
            }
    
        }

}


    
class Read
{
    private BufferedReader br;
    private StringTokenizer st;

    public Read(InputStream is)
    { br = new BufferedReader(new InputStreamReader(is)); }

    String next()
    {
        while (st == null || !st.hasMoreElements())
        {
            try {st = new StringTokenizer(br.readLine());}
            catch(IOException e)
                {e.printStackTrace();}
        }
        return st.nextToken();
    }

    int nextInt()
    { return Integer.parseInt(next()); }

    long nextLong()
    { return Long.parseLong(next()); }

    double nextDouble()
    { return Double.parseDouble(next()); }

    String nextLine()
    {
        String str = """";
        try {str = br.readLine();}
        catch(IOException e)
            {e.printStackTrace();}
        return str;
    }
}

",4,3
"import java.io.*;
import java.util.*;
public class Main {
    public static void main(String args[])
    {
        FastReader input=new FastReader();
        PrintWriter out=new PrintWriter(System.out);
        int T=1;
        while(T-->0)
        {
            int n=input.nextInt();
            TreeMap<Long,Integer> map=new TreeMap<>();
            for(int i=0;i<n;i++)
            {
                long l=input.nextLong();
                long r=input.nextLong();
                if(map.containsKey(l))
                {
                    map.put(l,map.get(l)+1);
                }
                else
                {
                    map.put(l,1);
                }
                if(map.containsKey(r+1))
                {
                    map.put(r+1,map.get(r+1)-1);
                }
                else
                {
                    map.put(r+1,-1);
                }
            }
            ArrayList<ArrayList<Long>> list=new ArrayList<>();
            Iterator it=map.entrySet().iterator();
            while(it.hasNext())
            {
                Map.Entry e=(Map.Entry)it.next();
                long v=(long)e.getKey();
                long r=(int)e.getValue();
                ArrayList<Long> l=new ArrayList<>();
                l.add(v);
                l.add(r);
                list.add(l);
            }
            for(int i=0;i<list.size();i++)
            {
                if(i!=0)
                {
                    list.get(i).set(1,list.get(i-1).get(1)+list.get(i).get(1));
                }
            }

            long arr[]=new long[n+1];
            for(int i=0;i<list.size()-1;i++)
            {
                long v=list.get(i+1).get(0)-1-list.get(i).get(0)+1;
                long c=list.get(i).get(1);
                arr[(int)c]+=v;
            }
            for(int i=1;i<=n;i++)
            {
                out.print(arr[i]+"" "");
            }
            out.println();
        }
        out.close();
    }
    static class FastReader
    {
        BufferedReader br;
        StringTokenizer st;

        public FastReader()
        {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }

        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt()
        {
            return Integer.parseInt(next());
        }

        long nextLong()
        {

            return Long.parseLong(next());
        }

        double nextDouble()
        {

            return Double.parseDouble(next());
        }

        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }
}",4,3
"import java.util.Scanner;

public class Main {
	public static void main(String args[]) {
		Scanner in=new Scanner(System.in);
		String str=in.next();
		int cnt=0;
		for(int i=0;i<str.length();++i) {
			if(str.charAt(i)=='1') {
				++cnt;
			}
		}
		int i=0;
		for(;i<str.length();++i) {
			if(str.charAt(i)=='0') {
				System.out.print(""0"");
			}
			else if(str.charAt(i)=='2') {
				while(cnt-->0) {//
					System.out.print(""1"");
				}
				System.out.print(""2"");
			}
		}
		while(cnt-->0) {
			System.out.print(""1"");
		}
		in.close();
	}
}",3,3
"//    A Computer is Like a mischievous genie.
//    It will give you exactly what you ask for,
//    but not always what you want
//    A code by Rahul Verma


import java.util.*;
import java.io.*;


public class Main {


    static class Clock {

        protected long start, stop;

        public void start() {
            start = System.currentTimeMillis();
        }

        public void stop() {
            stop = System.currentTimeMillis();
        }

        public String getTime() {
            return ((stop - start) + "" ms"");
        }
    }


    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));

    static class FastReader {

        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String[] nextSArray() {
            String sr[] = null;
            try {
                sr = br.readLine().trim().split("" "");
            } catch (IOException e) {
                e.printStackTrace();
            }
            return sr;
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }

            return str;
        }
    }


    static long powmodulo(long a, long p) {
        if (p == 0) {
            return 1 % mod;
        }
        if (p == 1) {
            return a % mod;
        }
        long ans = 1;
        while (p > 0) {
            if ((p & 1) > 0) {
                ans = (ans * a) % mod;
            }
            a = (a * a) % mod;
            p = p >> 1;
        }
        return ans % mod;
    }


    static long mod = 1000000007;

    static long gcd(long a, long b) {
        if (a == 0) {
            return b;
        }
        return gcd(b % a, a);
    }

    static long fast_powerNumbers(long a, long n) {
        if (n == 1) {
            return a;
        }
        long ans = fast_powerNumbers(a, n / 2);
        if (n % 2 == 0) {
            return (ans * ans);
        } else {
            return ((ans * ans) * (a));
        }
    }


    static void dfs_helper(int[][] arr, int i, int j, int team, int n, int m) {
        arr[i][j] = team;
        if (i - 1 >= 0 && arr[i - 1][j] == 1) {
            dfs(arr, i - 1, j, team, n, m);
        }
        if (j - 1 >= 0 && arr[i][j - 1] == 1) {
            dfs(arr, i, j - 1, team, n, m);
        }
        if (i + 1 < n && arr[i + 1][j] == 1) {
            dfs(arr, i + 1, j, team, n, m);
        }
        if (j + 1 < m && arr[i][j + 1] == 1) {
            dfs(arr, i, j + 1, team, n, m);
        }

    }

    static void dfs(int[][] arr, int i, int j, int team, int n, int m) {
        dfs_helper(arr, i, j, team, n, m);

    }



    static int arr[];

    static void seive(int n) {
        arr = new int[n + 1];
        arr[0] = arr[1] = 1;
        for (int i = 4; i <= n; i = i + 2) {
            arr[i] = 1;
        }
        for (int i = 3; i * i <= n; i = i + 2) {
            if (arr[i] == 0) {
                for (int j = i * i; j <= n; j = j + i) {
                    arr[j] = 1;
                }

            }
        }


    }
    static HashMap<Integer, ArrayList<Integer>>hm;
    static int vis[];
    static boolean cycle;
    static ArrayList<Integer>all=new ArrayList<>();
    static ArrayList<Integer>bll=new ArrayList<>();
    static ArrayList<Integer>cll=new ArrayList<>();

    public static void main(String[] args) throws Exception {
        FastReader sc = new FastReader();

        Clock clock = new Clock();
        clock.start();

        String s=sc.nextLine();
        int n=s.length();
        StringBuilder k=new StringBuilder();
        //String k="""";
        int one=0;
        int zero=0;
        int firstTwo=-1;

        for (int i = 0; i <n ; i++) {
            if(s.charAt(i)=='1')
                ++one;
            if(s.charAt(i)=='0')
                ++zero;

            if(firstTwo==-1&&s.charAt(i)=='2')
            {
                firstTwo=i;
            }
        }
        if(firstTwo!=-1)
        {
           int oo=0,zz=0;

            for (int i = 0; i <firstTwo ; i++) {
                if(s.charAt(i)=='0')
                    ++zz;
                else
                    ++oo;
            }
            StringBuilder first=new StringBuilder();
            while(zz!=0)
            {
                first.append('0');
                --zz;
            }
            while(oo!=0)
            {
                first.append('1');
                --oo;
            }
            oo=0;
            for (int i = firstTwo+1; i <n ; i++) {
                if(s.charAt(i)=='1')
                    ++oo;
            }
            StringBuilder mid=new StringBuilder();
            while(oo!=0)
            {
                mid.append('1');
                --oo;
            }
            for (int i = firstTwo; i <n ; i++) {

                if(s.charAt(i)=='1')
                    continue;
                mid.append(s.charAt(i));
            }
            System.out.println(first.toString()+mid.toString());
        }
        else
        {
            while(zero!=0)
            {
                k.append('0');
                --zero;
            }
            while(one!=0)
            {
                k.append('1');
                --one;
            }
            System.out.println(k);

        }



    }
}


class Pair {

    int a;
    int b;

    Pair(int a, int b) {
        this.a = a;
        this.b = b;
    }
}


class Graph {

    HashMap<Integer, ArrayList<Integer>> hm;

    Graph() {
        hm = new HashMap<>();
    }

    Graph(int n) {

        hm = new HashMap<>();
        for (int i = 0; i < n; i++) {
            hm.put(i, new ArrayList<Integer>());
        }
    }

    // function for adding an edge.................................................
    public void addEdge(int a, int b, boolean isDir) {
        if (isDir) {
            if (hm.containsKey(a)) {
                hm.get(a).add(b);
            } else {
                hm.put(a, new ArrayList<>(Arrays.asList(b)));
            }
        } else {
            if (hm.containsKey(a)) {
                hm.get(a).add(b);
            } else if (!hm.containsKey(a)) {
                hm.put(a, new ArrayList<>(Arrays.asList(b)));
            }

            if (hm.containsKey(b)) {
                hm.get(b).add(a);
            } else if (!hm.containsKey(b)) {
                hm.put(b, new ArrayList<>(Arrays.asList(a)));
            }
        }
    }


}


class DSU
{
    int parent[], rank[];
    DSU(int n)
    {
        parent=new int[n];
        rank=new int[n];
        for (int i = 0; i <n ; i++) {
            parent[i]=-1;
            rank[i]=1;
        }
    }

   int find(int s1)
    {
        if(parent[s1]==-1)
            return s1;

        parent[s1]=find(parent[s1]);
        return parent[s1];
    }

    void unite(int s1,int s2)
    {
        int p1 =find(s1);
        int p2 =find(s2);

        if(p1!=p2)
        {
           if(rank[p1]>rank[p2])
           {
               parent[p2] = find(p1);
               rank[p1]+=rank[p2];
           }
           else
           {
               parent[p1] =find(p2);
               rank[p2]+=rank[p1];
           }
        }
    }
}

// out.println(al.toString().replaceAll(""[\\[|\\]|,]"",""""));

",3,3
"
import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.StringTokenizer;

public class MinimumTernaryString implements Closeable {

    private InputReader in = new InputReader(System.in);
    private PrintWriter out = new PrintWriter(System.out);

    public void solve() {
        char[] x = in.next().toCharArray();
        int n = x.length;
        boolean twoFound = false;
        StringBuilder a = new StringBuilder(), b = new StringBuilder(), c = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if (x[i] == '2') {
                twoFound = true;
            }
            if (x[i] == '0' || x[i] == '2') {
                if (twoFound) c.append(x[i]);
                else a.append(x[i]);
            } else {
                b.append(x[i]);
            }
        }
        out.println(a.append(b).append(c));
    }

    @Override
    public void close() throws IOException {
        in.close();
        out.close();
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int ni() {
            return Integer.parseInt(next());
        }

        public long nl() {
            return Long.parseLong(next());
        }

        public void close() throws IOException {
            reader.close();
        }
    }

    public static void main(String[] args) throws IOException {
        try (MinimumTernaryString instance = new MinimumTernaryString()) {
            instance.solve();
        }
    }
}
",3,3
"import java.io.*;
import java.util.*;

public class Solution{
    
    static class FastReader
    {
        BufferedReader br;
        StringTokenizer st;

        public FastReader()
        {
            br = new BufferedReader(new
                     InputStreamReader(System.in));
        }

        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt()
        {
            return Integer.parseInt(next());
        }

        long nextLong()
        {
            return Long.parseLong(next());
        }

        double nextDouble()
        {
            return Double.parseDouble(next());
        }

        String nextLine()
        {
            String str = """";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }
    
    public static void main(String args[] ) {
        
        FastReader sc = new FastReader();
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] arr = new int[105];
        
        for(int i=0;i<m;i++){
            int a = sc.nextInt();
            arr[a]++;
        }
        
        for(int i=1;i<=1000;i++){
            int sum=0;
            
            for(int a:arr){
                if(a!=0){
                    sum+=(a/i);
                }
            }
            
            
            if(sum<n){
                System.out.println(i-1);
                return;
            }
            
        }
    }

}
",5,3
"import java.util.Arrays;
import java.util.Scanner;

public class Solution {

    private static int[] a;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt(), m = sc.nextInt();

        a = new int[101];
        for (int i = 0; i < m; i++) {
            int type = sc.nextInt();
            a[type] = a[type] + 1;
        }

        int lo=1, hi=100, max=0;

        while (lo <= hi) {
            int mid = lo + (hi - lo)/2;
            if (check(n, mid)) {
                max = mid;
                lo = mid+1;
            } else {
                hi = mid -1;
            }
        }
        System.out.println(max);
    }

    public static boolean check(int n, int target) {
        int result = 0;
        for (int i=0; i <a.length; i++) {
            result = result + (a[i] / target);
        }
        if (result >= n) {return true;}
        return false;
    }
}",4,3
"import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

public class Solution {
	public static void main(String[] args) {
		Solution solution = new Solution();
		System.out.println(solution.solve());
	}

	private int solve() {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int m = in.nextInt();

		int[] a = new int[m];
		for (int i = 0; i < m; ++i) a[i] = in.nextInt();

		if (n > m) return 0;

		Map<Integer, Integer> map = new HashMap<>();
		for (int k: a) map.put(k, map.getOrDefault(k, 0) + 1);

		List<Integer> keySet = new ArrayList<>(map.keySet());
		int end = m / n;

		keySet.sort((u, v) -> -Integer.compare(u, v));
		do {
			int count = 0;
			for (int k: keySet) {
				count += map.get(k) / end;
				if (count >= n) return end;
			}
		} while (--end > 0);

		return 0;
	}
}
",4,3
"/* package codechef; // don't place package name! */

import java.util.Arrays;
import java.util.Map;
import java.util.Scanner;
import java.util.function.Function;
import java.util.stream.Collectors;

/* Name of the class has to be ""Main"" only if the class is public. */
public class Codechef
{
	public static void main (String[] args) throws java.lang.Exception
	{
		// your code goes here
		Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[] a = new int[m];
        int max = m/n;
        for (int i = 0; i < m; i++) {
            a[i] = sc.nextInt();
        }
        if (n > m)
        {
            System.out.println(0);
            return;
        }
        Map<Integer, Long> map = Arrays.stream(a)
                                    .boxed().collect(Collectors.groupingBy(Function.identity(),
                                    Collectors.counting()));
        int ans = 0;
        while (max > 0) {
            ans = 0;
            for (Map.Entry<Integer, Long> entry : map.entrySet()) {
                ans += entry.getValue()/max;
            }
            if (ans >= n) {
                break;
            }
            max--;
        }
        System.out.println(max);
	}
}

     			   			 	 	 					 					",4,3
"import java.util.*;
import java.math.*;
import java.io.*; 
 public class A{

static FastReader scan=new FastReader();
 public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));
  static LinkedList<Edge>edges[];
  static boolean stdin = true;
    static String filein = ""input"";
    static String fileout = ""output"";
static int dx[] = { -1, 0, 1, 0 };
static int dy[] = { 0, 1, 0, -1 };
int dx_8[]={1,1,1,0,0,-1,-1,-1};
int dy_8[]={-1,0,1,-1,1,-1,0,1};
static char sts[]={'U','R','D','L'};
static boolean prime[];
static long LCM(long a,long b){
    return (Math.abs(a*b))/gcd(a,b);
   }
    public static int upperBound(long[] array, int length, long value) {
        int low = 0;
        int high = length;
        while (low < high) {
            final int mid = low+(high-low) / 2;
            if ( array[mid]>value) {
                high = mid ;
            } else {
                low = mid+1;
            }
        }
        return low;
    }
   static long gcd(long a, long b) {
    if(a!=0&&b!=0)
        while((a%=b)!=0&&(b%=a)!=0);
    return a^b;
}
static int countSetBits(int n) 
    { 
        int count = 0; 
        while (n > 0) { 
            count += n & 1; 
            n >>= 1; 
        } 
        return count; 
    } 
 static void sieve(long n) 
    { 
        
        prime = new boolean[(int)n+1]; 
        for(int i=0;i<n;i++) 
            prime[i] = true; 
          
        for(int p = 2; p*p <=n; p++) 
        { 
           
            if(prime[p] == true) 
            { 
                
                for(int i = p*p; i <= n; i += p) 
                    prime[i] = false; 
            } 
        } 
    }  
  
 
 
           static boolean isprime(long x)
           {
            for(long i=2;i*i<=x;i++)
                if(x%i==0)
                    return false;
                return true;
           }
           static int perm=0,FOR=0;
           
     

static boolean flag=false;
static int len=100000000;

static ArrayList<Pair>inters=new ArrayList<Pair>();





static StringBuilder sb;
static void swap(int i,int j,StringBuilder st)
{
    char tmp=st.charAt(i);
    st.setCharAt(i,st.charAt(j));
    st.setCharAt(j,tmp);
}


 private static int next(int[] arr, int target)  
    {  
        int start = 0, end = arr.length - 1;  
    
        int ans = -1;  
        while (start <= end) {  
            int mid = (start + end) / 2;  
    
            // Move to right side if target is  
            // greater.  
            if(arr[mid]==target)
                return mid;
            if (arr[mid] <target) {  
                start = mid + 1;  
            }  
    
            // Move left side.  
            else {  
                ans = mid;  
                end = mid - 1;  
            }  
        }  
        return ans;  
    }  
//static boolean vis[][];
    static long solve(int h,long n,int cur)
    {
        if(h==0)
            return 0;
        long half=1L<<(h-1);
        if(n<=half)
        {
            if((cur^1)==0)
                return 1+solve(h-1,n,0);
            else 
                return 2*half+solve(h-1,n,0);
        }
        else 
        {
              if((cur^1)==0)
             return 2*half+solve(h-1,n-half,1);
            else 
                return 1+solve(h-1,n-half,1);
        }
    }
static int dist[][];
public static String removeLeadingZeroes(String str) {
      String strPattern = ""^0+(?!$)"";
      str = str.replaceAll(strPattern, """");
      return str;
   }

    static String gcd(String str1, String str2)
    {
        // If str1 length is less than
        // that of str2 then recur
        // with gcd(str2, str1)
        if (str1.length() < str2.length()) {
            return gcd(str2, str1);
        }
 
        // If str1 is not the
        // concatenation of str2
        else if (!str1.startsWith(str2)) {
            return """";
        }
 
        else if (str2.isEmpty()) {
 
            // GCD string is found
            return str1;
        }
        else {
 
            // Cut off the common prefix
            // part of str1 & then recur
            return gcd(str1.substring(str2.length()),
                       str2);
        }
    }
   static ArrayList<Long>luckies=new ArrayList<Long>();
  static int n;
  static long cnt=0;
static void d(long x)
{
    if(String.valueOf(x).length()>n)
        return;
    cnt++;
    luckies.add(x);
     d(x*10+7);
     d(x*10+8);
}

public static class comp1 implements Comparator<String>{  
public int compare(String o1,String o2){
return o1.length()-o2.length(); 
}
  }
  public static class comp2 implements Comparator<String>{  
public int compare(String o1,String o2){
return o1.compareTo(o2); 
}
  }

public static void main(String[] args)  throws Exception 
{
//SUCK IT UP AND DO IT ALRIGHT
//scan=new FastReader(""input.txt"");
//out = new PrintWriter (""output.txt"");
   // System.out.println(pow((long)1e9,(long)1e9));
    //int elem[]={1,2,3,4,5};
  //  System.out.println(2%1);
int tt=1;
//tt=scan.nextInt();
outer:while(tt-->0)
{
int n=scan.nextInt(),m=scan.nextInt();
int arr[]=new int[m];
int count[]=new int[101];
Set<Integer>set=new HashSet<Integer>();
if(n>m){
out.println(0);
out.close();
return;
}
for(int i=0;i<m;i++){
    arr[i]=scan.nextInt();
    set.add(arr[i]);
    count[arr[i]]++;
}
int k=0,kk=0;
int ans=0;
for(int i=1;i<=100;i++)
{
    int cnt=0;
    int tmp[]=new int[101];
    for(int j=0;j<101;j++)
        tmp[j]=count[j];
    for(int l=1;l<=100;)
    {
     //   out.println(i);
        if(tmp[l]==0)
            l++;
        else 
        {
            if(tmp[l]<i)
            {
                l++;
                continue;
            }
            else 
            {

                tmp[l]-=i;
                cnt++;
            }
        }
    }
    //if(i==2)
      //  out.println(cnt);
    if(cnt>=n)
    {
        ans=i;
            }
}
out.println(ans);
}
out.close();

//SEE UP 

}
static long binexp(long a,long n)
{
    if(n==0)
        return 1;
    long res=binexp(a,n/2);
    if(n%2==1)
        return res*res*a;
    else 
        return res*res;
}
static long powMod(long base, long exp, long mod) {
       if (base == 0 || base == 1) return base;
       if (exp == 0) return 1;
       if (exp == 1) return base % mod;
       long R = powMod(base, exp/2, mod) % mod;
       R *= R;
       R %= mod;
       if ((exp & 1) == 1) {
           return base * R % mod;
       }
       else return R % mod;
   }
static double dis(double x1,double y1,double x2,double y2)
{
    return Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
static long mod(long x,long y)
    {
        if(x<0)
            x=x+(-x/y+1)*y;
        return x%y;
    }
 public static  long pow(long b, long e) {
            long r = 1;
            while (e > 0) {
                if (e % 2 == 1) r = r * b ;
                b = b * b;
                e >>= 1;
            }
            return r;
        }
private static void sort(long[] arr) {
        List<Long> list = new ArrayList<>();
        for (long object : arr) list.add(object);
        Collections.sort(list);
        for (int i = 0; i < list.size(); ++i) arr[i] = list.get(i);
    }
 public static class FastReader {
        BufferedReader br;
        StringTokenizer root;
        
 
        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        FastReader(String filename)throws Exception
        {

            br=new BufferedReader(new FileReader(filename));
        }

        boolean hasNext(){
            String line;
            while(root.hasMoreTokens())
                return true;
            return false;
        }
 
        String next() {
            while (root == null || !root.hasMoreTokens()) {
                try {
                    root = new StringTokenizer(br.readLine());
                } catch (Exception addd) {
                    addd.printStackTrace();
                }
            }
            return root.nextToken();
        }
 
        int nextInt() {
            return Integer.parseInt(next());
        }
 
        double nextDouble() {
            return Double.parseDouble(next());
        }
 
        long nextLong() {
            return Long.parseLong(next());
        }
 
        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (Exception addd) {
                addd.printStackTrace();
            }
            return str;
        }
         public int[] nextIntArray(int arraySize) {
            int array[] = new int[arraySize];
 
            for (int i = 0; i < arraySize; i++) {
                array[i] = nextInt();
            }
 
            return array;
        }
}
 static class Pair implements Comparable<Pair>{
        public int x, y;
        public Pair(int x1, int y1) {
            x=x1;
            y=y1;
        }
        @Override
        public int hashCode() {
            return (int)(x + 31 * y);
        }
        public String toString() {
            return x + "" "" + y;
        }
        @Override
        public boolean equals(Object o){
            if (o == this) return true;
            if (o.getClass() != getClass()) return false;
            Pair t = (Pair)o;
            return t.x == x && t.y == y;
        }
public int compareTo(Pair o)
{
    return (x-o.x);

    }

static class pair{
    int i;
    int j;
pair(int i,int j){
    this.i=i;
    this.j=j;
}}}
 static class tuple{
        int x,y,z;
        tuple(int a,int b,int c){
            x=a;
            y=b;
            z=c;
        }
    }
    static class Edge{
        int d,w;
        Edge(int d,int w)
        {
            this.d=d;
            this.w=w;
        }
    }
}









",4,3
"import java.util.*;

public class vas2 {
    public static void main( String[] args ) {
	Scanner in = new Scanner( System.in );
	int n = in.nextInt();
	String st = in.next();
	int[] a = new int[n];
	for ( int i = 0; i < n; i++ )
	    a[i] = st.charAt( i ) - 48;
	boolean c = false;
	for ( int i = 1; !c && i < n; i++ ) {
	    int s = 0;
	    for ( int j = 0; j < i; j++ )
		s += a[j];
	    int t = 0;
	    for ( int j = i; j < n; j++ ) {
		t += a[j];
		if ( t > s )
		    if ( t - a[j] != s )
			break;
		    else
			t = a[j];
	    }
	    if ( t == s )
		c = true;
	}
	System.out.println( c ? ""YES"" : ""NO"" );
    }
}
",5,3
"import java.io.*;
import java.util.*;

/*

 */
public class A {
	static FastReader sc=null;
	
	public static void main(String[] args) {
		sc=new FastReader();
		int n=sc.nextInt();
		char line[]=sc.next().toCharArray();
		int sum=0;
		for(char e:line)sum+=(e-'0');
		boolean po=false;
		outer:for(int i=1;i<=sum;i++) {
			if(sum%i==0) {
				int ans=sum/i;
				int j=0,curr=0,c=0;
				//System.out.println(""ans ""+ans);
				while(j<n) {
					curr+=line[j]-'0';
					if(curr==ans) {
						curr=0;
						c++;
					}
					else if(curr>ans)continue outer;
					j++;
				}
				//System.out.println(""curr ""+curr);
				if(curr==0 && c>1) {
					po=true;
					break;
				}
				
			}
		}
		System.out.println((po || (sum==0 && line.length>1))?""YES"":""NO"");
		
		
		
	}
	
	
	
	

	
	
	
	
	
	
	static int[] reverse(int a[]) {
		ArrayList<Integer> al=new ArrayList<>();
		for(int i:a)al.add(i);
		Collections.sort(al,Collections.reverseOrder());
		for(int i=0;i<a.length;i++)a[i]=al.get(i);
		return a;
	}
	static int gcd(int a,int b) {
		if(b==0)return a;
		else return gcd(b,a%b);
	}
	static long gcd(long a,long b) {
		if(b==0)return a;
		else return gcd(b,a%b);
	}
	
	static void ruffleSort(int a[]) {
		ArrayList<Integer> al=new ArrayList<>();
		for(int i:a)al.add(i);
		Collections.sort(al);
		for(int i=0;i<a.length;i++)a[i]=al.get(i);
	}
	
	
	static void print(long a[]) {
		for(long e:a) {
			System.out.print(e+"" "");
		}
		System.out.println();
	}
	static void print(char a[]) {
		for(char e:a) {
			System.out.print(e+"" "");
		}
		System.out.println();
	}
	
	
	static void print(int a[]) {
		for(int e:a) {
			System.out.print(e+"" "");
		}
		System.out.println();
	}
	static void print(double a[]) {
		for(double e:a) {
			System.out.print(e+"" "");
		}
		System.out.println();
	}
	
	static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader() 
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next() 
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = """"; 
            try
            { 
                str = br.readLine(); 
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
        int[] readArray(int n) {
    		int a[]=new int [n];
    		for(int i=0;i<n;i++) {
    			a[i]=sc.nextInt();
    		}
    		return a;
    	}
    } 
}






",5,3
"
// template : secondThread

import java.io.*;
import java.util.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;



public   class main2 {

        static String solver(int n , String s){

            int ct = 0 ;
            int prev = 0 ;
            int count = 1 ;

            for (int i = 0; i <n-1 ; i++) {
                count = 1;
                 ct = 0 ;
                prev += Integer.parseInt(s.charAt(i)+"""") ;
                for (int j = i+1; j <n ; j++) {
                    if (ct == -1 && Integer.parseInt(s.charAt(j)+"""") != 0)
                        ct = 0 ;
                    ct+= Integer.parseInt(s.charAt(j)+"""") ;
                    if (ct == prev) {
                        count++ ;
                        ct = -1  ; }
                    else if (ct > prev)
                        break;
                }
                if (ct == -1 && count >=2)
                    return ""YES"" ;
            }

            return ""NO"" ;
        }


      public static void main(String[] args) {
          try {


              PrintWriter fop = new PrintWriter(System.out);
              FastScanner fsca = new FastScanner();

            fop.println(solver(fsca.nextInt(),   fsca.next()));



























              fop.flush();
              fop.close();
          } catch (Exception e) {
              return;
          }


      }
      /*-----------------------------------------------------------------------------------------------------------------------------------------------*/


      static void sieve(int n) {
          boolean[] flag = new boolean[n];

          for (int i = 2; i * i < n; i++) {
              if (flag[i])
                  continue;
              else
                  for (int j = i * i; j <= n; j += i) {
                      flag[j] = true;
                  }
          }
      }


      static int gcd(int a, int b) {
          if (b > a) {
              int tenp = b;
              b = a;
              a = tenp;
          }
          int temp = 0;
          while (b != 0) {
              a %= b;
              temp = b;
              b = a;
              a = temp;
          }
          return a;
      }

      static long gcd_long(long a, long b) {
          if (b > a) {
              long tenp = b;
              b = a;
              a = tenp;
          }
          long temp = 0;
          while (b != 0) {
              a %= b;
              temp = b;
              b = a;
              a = temp;
          }
          return a;
      }


      static final Random random = new Random();

      static void ruffleSort(int[] a) {
          int n = a.length;//shuffle, then sort
          for (int i = 0; i < n; i++) {
              int oi = random.nextInt(n), temp = a[oi];
              a[oi] = a[i];
              a[i] = temp;
          }
          Arrays.sort(a);
      }


      static class FastScanner {
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          StringTokenizer st = new StringTokenizer("""");

          String next() {
              while (!st.hasMoreTokens())
                  try {
                      st = new StringTokenizer(br.readLine());
                  } catch (IOException e) {
                      e.printStackTrace();
                  }
              return st.nextToken();
          }

          int nextInt() {
              return Integer.parseInt(next());
          }

          int[] readArray(int n) {
              int[] a = new int[n];
              for (int i = 0; i < n; i++) a[i] = nextInt();
              return a;
          }

          long[] readLongArray(int n) {
              long[] a = new long[n];
              for (int i = 0; i < n; i++)
                  a[i] = nextLong();
              return a;
          }

          long nextLong() {
              return Long.parseLong(next());
          }
      }


  }








",5,3
"import java.util.*;

public class helloWorld 
{
	public static void main(String[] args) 
	{		
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int m = in.nextInt();
		int[] ar = new int[200];
		
		String str = in.next();
		for(int i = 0; i < str.length(); i++)
			ar[ str.charAt(i) ]++;
			
		int ans = 100000;
		
		for(int i = 'A'; i < 'A' + m; i++)
			ans = Math.min(ans, ar[i]);
		ans *= m;
		
		System.out.println(ans);
		
		in.close();
	}
}

",3,3
"import java.util.ArrayList;
 import java.util.*;
public class Main {
    public static void main(String[] args) {
       
        Scanner sc = new Scanner(System.in);
        int ar[] = new int[26];
        int n = sc.nextInt(), k = sc.nextInt();
        String s = sc.next();
        for(char c : s.toCharArray()){
            int z = c - 'A';
            ar[z]++;
        }
        int m = n;
        for(int i = 0;i<k;i++){
            m = Math.min(m,ar[i]);
        }
        System.out.println(m*k);
       
        
        
        
    }
}
    

",3,3
"import java.util.Scanner;
import java.util.ArrayList;
 import java.util.*;
public class Main {
    public static void main(String[] args) {
       
        Scanner sc = new Scanner(System.in);
        int ar[] = new int[26];
        int n = sc.nextInt(), k = sc.nextInt();
        String s = sc.next();
        for(char c : s.toCharArray()){
            int z = c - 'A';
            ar[z]++;
        }
        int m = n;
        for(int i = 0;i<k;i++){
            m = Math.min(m,ar[i]);
        }
        System.out.println(m*k);
       
        
        
        
    }
}
    


	 	 	  	  				   	  	 		   	  	",3,3
"import java.util.*;
import java.math.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------

public class a{ 
     static int[] count,count1,count2;
     static Node[] nodes;
     static long[] arr;
     static int[] dp;
     static char[] ch,ch1;
     static long[] darr,farr;
     static char[][] mat,mat1;
     static boolean[][] vis;
     static long x,h;
     static long maxl;
     static double dec;
     static long mx = (long)1e9;
     static String s;
     static long minl;
     static int start_row;
     static int start_col;     
     static int end_row;     
     static int end_col;     
     static long mod = 998244353;
     // static int minl = -1;
     // static long n;
     static int n,n1,n2,q,r1,c1,r2,c2;
     static long a;
     static long b;
     static long c;
     static long d;
     static long y,z;
     static int m;
     static long k;
     static FastScanner sc;
     static String[] str,str1;
     static Set<String> set,set1,set2;
     static SortedSet<Long> ss;
     static List<Long> list,list1,list2,list3;
     static PriorityQueue<Long> pq,pq1;
     static LinkedList<Node> ll;
     static Map<Integer,Integer> map;
     static Map<Integer,Integer> map1;
     static StringBuilder sb,sb1,sb2;
     static int index;
     static long ans;
     static int[] dx = {0,-1,0,1,-1,1,-1,1};
     static int[] dy = {-1,0,1,0,-1,-1,1,1};

     // public static void solve(){

     //    FastScanner sc = new FastScanner();
     //    // int t = sc.nextInt();
     //    int t = 1;
     //    for(int tt = 0 ; tt < t ; tt++){
     //        int n = sc.nextInt();
     //        // int m = sc.nextInt();
     //        // int prev = 0;
     //        int l = 0;
     //        int r = 0;
     //        boolean flag = false;
     //        map = new HashMap<>();
     //        sb = new StringBuilder(); 
     //        for(int i = 0 ; i < n ; i++){
     //            char s = sc.next().charAt(0);
     //            if(s == 'L'){
     //                int index = sc.nextInt();
     //                map.put(index,l);
     //                if(!flag){
     //                    flag = !flag;
     //                    r += 1;
     //                }
     //                l -= 1;
     //            }
     //            else if(s == 'R'){
     //                int index = sc.nextInt();
     //                map.put(index,r);
     //                if(!flag){
     //                    flag = !flag;
     //                    l -= 1;
     //                }
     //                r += 1;
     //            }
     //            else{
     //                int index = sc.nextInt();
     //                int pos = map.get(index);
     //                int ans = Math.min(r-pos-1,pos-l-1);
     //                sb.append(ans+""\n"");
     //            }
     //        }

     //        System.out.print(sb);
     //    }
        
        
     // }

     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------

     public static void solve(){

        ruffleSort(arr);

        long right = arr[n-1];
        long need = 1;
        long taken = 0;
        long total = 0;
        for(int i = 0 ; i < n ; i++){
            total += arr[i];
            if(arr[i] == need){
                taken += 1;
                need += 1;
                continue;
            }
            if(need > arr[i])
                taken += 1;
            else{
                if(i == n-1)
                    taken += (arr[i] - need + 1);
                else{
                    taken += 1;
                    need += 1;
                }
            }
        }

        System.out.println(total-taken);

     }

     public static void main(String[] args) {

            sc = new FastScanner();
            // Scanner sc = new Scanner(System.in);
            // int t = sc.nextInt();
            int t = 1;
            // int l = 1;
            while(t > 0){
                
                // n = sc.nextInt();
                // n = sc.nextLong();
                // a = sc.nextLong();
                // b = sc.nextLong();
                // c = sc.nextLong();
                // d = sc.nextLong();

                // x = sc.nextLong();
                // y = sc.nextLong();
                
                // n = sc.nextLong();
                n = sc.nextInt();
                // n1 = sc.nextInt();

                m = sc.nextInt();
                // q = sc.nextInt();

                // k = sc.nextLong();
                // s = sc.next();

                // ch = sc.next().toCharArray();
                // ch1 = sc.next().toCharArray();

                arr = new long[n];
                for(int i = 0 ; i < n ; i++){
                    arr[i] = sc.nextLong();
                }
                // ch = sc.next().toCharArray();
                // m = n;
                // darr = new long[m];
                // for(int i = 0 ; i < m ; i++){
                //     darr[i] = sc.nextLong();
                // }

                // farr = new int[n];
                // for(int i = 0; i < n ; i++){
                //     farr[i] = sc.nextInt();
                // }

                // mat = new int[n][n];
                // for(int i = 0 ; i < n ; i++){
                //     for(int j = 0 ;  j < n ; j++){
                //         mat[i][j] = sc.nextInt();
                //     }
                // }

                // m = n;
                // mat = new char[n][m];
                // for(int i = 0 ; i < n ; i++){
                //     String s = sc.next();
                //     for(int j = 0 ; j < m ; j++){
                //         mat[i][j] = s.charAt(j);
                //     }
                // }

                // str = new String[n];
                // for(int i = 0 ; i < n ; i++)
                //     str[i] = sc.next();

                // nodes = new Node[n];
                // for(int i = 0 ; i < n ;i++)
                //     nodes[i] = new Node(sc.nextInt(),sc.nextInt());

                // System.out.println(solve()?""YES"":""NO"");
                 solve();       
                 // System.out.println(solve());
                 t -= 1;
            }

     }

    public static int log(long n,long base){

         if(n == 0 || n == 1)
             return 0;

         if(n == base)
             return 1;

         double num = Math.log(n);
         double den = Math.log(base);

         if(den == 0)
             return 0;

         return (int)(num/den);
     }

    public static boolean isPrime(long n) { 
    // Corner cases 
        if (n <= 1)  
            return false; 

        if (n <= 3)  
            return true; 
      
        // This is checked so that we can skip  
        // middle five numbers in below loop 
        if (n%2 == 0 || n%3 == 0) 
            return false; 
      
        for (int i=5; i*i<=n; i=i+6) 
            if (n%i == 0 || n%(i+2) == 0) 
               return false; 
      
        return true; 
    } 

     public static long gcd(long a,long b){

        if(b%a == 0){
            return a;
        }
        return gcd(b%a,a);

     }

     // public static void swap(int i,int j){
     //     long temp = arr[j];
     //     arr[j] = arr[i];
     //     arr[i] = temp;
     // } 

    static final Random random=new Random();
    
    static void ruffleSort(long[] a) {
        int n=a.length;//shuffle, then sort 
        for (int i=0; i<n; i++) {
            int oi=random.nextInt(n);
            long temp=a[oi];
            a[oi]=a[i]; a[i]=temp;
        }
        Arrays.sort(a);
    }

    static class Node{
        Integer first;
        Integer second;
        Node(Integer f,Integer s){
            this.first = f;
            this.second = s;
        }
    }

     static class FastScanner {

                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
                StringTokenizer st=new StringTokenizer("""");
                String next() {
                        while (!st.hasMoreTokens())
                                try {
                                        st=new StringTokenizer(br.readLine());
                                } catch (IOException e) {
                                        e.printStackTrace();
                                }
                        return st.nextToken();
                }
                
                int nextInt() {
                        return Integer.parseInt(next());
                }
                int[] readArray(int n) {
                        int[] a=new int[n];
                        for (int i=0; i<n; i++) a[i]=nextInt();
                        return a;
                }
                long nextLong() {
                        return Long.parseLong(next());
                }
        }

}",4,3
"import java.util.*;

public class Main {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int m = sc.nextInt();

        long totalBlocks = 0;
        long a[] = new long[n];
        for(int i = 0; i < n; ++i) {
            a[i] = sc.nextLong();
            totalBlocks += a[i];
        }

        Arrays.sort(a);

        long selected = 0;
        for(int i = 0; i < n; ++i) {
            if(a[i] > selected)
                selected++;
        }

        long leftCols = a[n - 1] - selected;
        long remBlocks = totalBlocks - leftCols - n;

        System.out.print(remBlocks);
    }
}",4,3
"import java.util.*;
import java.io.*;
public class A
{
      public static void main(String ar[]) throws Exception
      {
            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
            String s1[]=br.readLine().split("" "");
            int n=Integer.parseInt(s1[0]);
            int m=Integer.parseInt(s1[1]);
            int a[]=new int[n];
            String s2[]=br.readLine().split("" "");
            long S=0;
            for(int i=0;i<n;i++)
            { a[i]=Integer.parseInt(s2[i]);  S+=(long)a[i]; }
            
            Arrays.sort(a);
            m=a[n-1];
            int last=1;
            int t=1;
            for(int i=1;i<n-1;i++)
            {
                  if(a[i]==last)
                   t++;
                  else
                  {
                        t++;
                        last=last+1;
                  }
            }
            if(last<m)
            { t+=m-last; }
            else
             t++;
            System.out.println(S-t);
      }
}",4,3
"//    A Computer is Like a mischievous genie.
//    It will give you exactly what you ask for,
//    but not always what you want
//    A code by Rahul Verma


import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;
import java.util.Spliterator.OfPrimitive;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.TreeMap;


public class Main {


    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));

    static class FastReader {

        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String[] nextSArray() {
            String sr[] = null;
            try {
                sr = br.readLine().trim().split("" "");
            } catch (IOException e) {
                e.printStackTrace();
            }
            return sr;
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }

            return str;
        }
    }


    static long powmodulo(long a, long p) {
        if (p == 0) {
            return 1 % mod;
        }
        if (p == 1) {
            return a % mod;
        }
        long ans = 1;
        while (p > 0) {
            if ((p & 1) > 0) {
                ans = (ans * a) % mod;
            }
            a = (a * a) % mod;
            p = p >> 1;
        }
        return ans % mod;
    }


    static long mod = 1000000007;

    static long gcd(long a, long b) {
        if (a == 0) {
            return b;
        }
        return gcd(b % a, a);
    }

    static long fast_powerNumbers(long a, long n) {
        if (n == 1) {
            return a;
        }
        long ans = fast_powerNumbers(a, n / 2);
        if (n % 2 == 0) {
            return (ans * ans);
        } else {
            return ((ans * ans) * (a));
        }
    }


    static void dfs_helper(int[][] arr, int i, int j, int team, int n, int m) {
        arr[i][j] = team;
        if (i - 1 >= 0 && arr[i - 1][j] == 1) {
            dfs(arr, i - 1, j, team, n, m);
        }
        if (j - 1 >= 0 && arr[i][j - 1] == 1) {
            dfs(arr, i, j - 1, team, n, m);
        }
        if (i + 1 < n && arr[i + 1][j] == 1) {
            dfs(arr, i + 1, j, team, n, m);
        }
        if (j + 1 < m && arr[i][j + 1] == 1) {
            dfs(arr, i, j + 1, team, n, m);
        }

    }

    static void dfs(int[][] arr, int i, int j, int team, int n, int m) {
        dfs_helper(arr, i, j, team, n, m);

    }

    static int parent[];
    static int rank[];

    static int find(int i) {
        if (parent[i] == -1) {
            parent[i] = i;
            return i;
        }

        if (parent[i] == i) {
            return i;
        } else {
            parent[i] = find(parent[i]);
        }
        return parent[i];

    }

    static void unite(int s1, int s2) {

        if (rank[s1] > rank[s2]) {
            parent[s2] = s1;
            rank[s1] += rank[s2];
        } else {
            parent[s1] = s2;
            rank[s2] += rank[s1];
        }
    }


    static int arr[];

    static void seive(int n) {
        arr = new int[n + 1];
        arr[0] = arr[1] = 1;
        for (int i = 4; i <= n; i = i + 2) {
            arr[i] = 1;
        }
        for (int i = 3; i * i <= n; i = i + 2) {
            if (arr[i] == 0) {
                for (int j = i * i; j <= n; j = j + i) {
                    arr[j] = 1;
                }

            }
        }
    }

    public static void main(String[] args) throws Exception {
        FastReader sc = new FastReader();

//        int t = sc.nextInt();
//        for (int t1 = 0; t1 < t; t1++) {
//
//        }
//        out.close();

        int n=sc.nextInt();
        long m=sc.nextLong();
        long arr[]=new long[n];
        long max=0;
        long sum=0;
        for (int i = 0; i <n ; i++) {
            arr[i]=sc.nextLong();
            max=Math.max(arr[i],max);

        }
        Arrays.sort(arr);
        long h=0;
        long rem=0;
        for (int i = 0; i <n-1; i++) {

            if(arr[i]>=h+1)
            {
                ++h;
            }
            rem+=arr[i]-1;

        }
        rem+=arr[n-1]-Math.max(1,arr[n-1]-h);
        System.out.println(rem);

    }
}


class Pair {

    int a;
    int b;

    Pair(int a, int b) {
        this.a = a;
        this.b = b;
    }
}


class Graph {

    HashMap<Integer, ArrayList<Integer>> hm;

    Graph() {
        hm = new HashMap<>();
    }

    Graph(int n) {

        hm = new HashMap<>();
        for (int i = 0; i < n; i++) {
            hm.put(i, new ArrayList<Integer>());
        }
    }

    // function for adding an edge.................................................
    public void addEdge(int a, int b, boolean isDir) {
        if (isDir) {
            if (hm.containsKey(a)) {
                hm.get(a).add(b);
            } else {
                hm.put(a, new ArrayList<>(Arrays.asList(b)));
            }
        } else {
            if (hm.containsKey(a)) {
                hm.get(a).add(b);
            } else if (!hm.containsKey(a)) {
                hm.put(a, new ArrayList<>(Arrays.asList(b)));
            }

            if (hm.containsKey(b)) {
                hm.get(b).add(a);
            } else if (!hm.containsKey(b)) {
                hm.put(b, new ArrayList<>(Arrays.asList(a)));
            }
        }
    }


}

// out.println(al.toString().replaceAll(""[\\[|\\]|,]"",""""));

",4,3
"import java.util.*;
public class test{
public static void main(String args[])
{
Scanner s=new Scanner(System.in);
int n=s.nextInt();
int m=s.nextInt();
int arr[]=new int[n];
int max = Integer.MIN_VALUE;
        long sum = 0;
        for(int i=0;i<n;i++)
        {
            arr[i] = s.nextInt();
            sum = sum + arr[i];
            max = Math.max(max,arr[i]);
        }
        Arrays.sort(arr);
        int i = 0;
        int count = 0;
        int d = 0;
        for(i=0; i<n; i++)
        {
            if(arr[i] > d)
            {
                count++;
                d++;
            }
            else if(arr[i] == d && arr[i] > 0)
            {
                count++;
            }
        }
        //System.out.println(count + "" "" + max);
        if(max - d > 0)
        {
            count = count + max - d;
        }
        System.out.println(sum - count);}}",4,3
"import java.util.*;
import java.io.*;
import java.awt.Point;
import java.math.BigInteger;

public class stacks {

	public static void main(String[] args) throws Exception {
		FastIO sc = new FastIO(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		
		int n = sc.nextInt();
		int m = sc.nextInt();
		
		long remove = 0;
		
		int[] heights = new int[n+1];
		
		for(int i = 0; i < n; i++) {
			heights[i] = sc.nextInt();
			remove += heights[i];
		}
		
		Arrays.sort(heights);
		//System.out.println(Arrays.toString(heights));
		long keep = 0;
		for(int i = n; i> 0; i--) {
			if(heights[i-1] >= heights[i]) {
				heights[i-1] = heights[i]-1;
			}
			keep += heights[i] - heights[i-1];
		}
		//System.out.println(Arrays.toString(heights));
		
		pw.println(remove - keep);
		pw.close();
	}

	static class FastIO {

		//Is your Fast I/O being bad?

		InputStream dis;
		byte[] buffer = new byte[1 << 17];
		int pointer = 0;

		public FastIO(String fileName) throws Exception {
			dis = new FileInputStream(fileName);
		}

		public FastIO(InputStream is) throws Exception {
			dis = is;
		}

		int nextInt() throws Exception {
			int ret = 0;

			byte b;
			do {
				b = nextByte();
			} while (b <= ' ');
			boolean negative = false;
			if (b == '-') {
				negative = true;
				b = nextByte();
			}
			while (b >= '0' && b <= '9') {
				ret = 10 * ret + b - '0';
				b = nextByte();
			}

			return (negative) ? -ret : ret;
		}

		long nextLong() throws Exception {
			long ret = 0;

			byte b;
			do {
				b = nextByte();
			} while (b <= ' ');
			boolean negative = false;
			if (b == '-') {
				negative = true;
				b = nextByte();
			}
			while (b >= '0' && b <= '9') {
				ret = 10 * ret + b - '0';
				b = nextByte();
			}

			return (negative) ? -ret : ret;
		}

		byte nextByte() throws Exception {
			if (pointer == buffer.length) {
				dis.read(buffer, 0, buffer.length);
				pointer = 0;
			}
			return buffer[pointer++];
		}

		String next() throws Exception {
			StringBuffer ret = new StringBuffer();

			byte b;
			do {
				b = nextByte();
			} while (b <= ' ');
			while (b > ' ') {
				ret.appendCodePoint(b);
				b = nextByte();
			}

			return ret.toString();
		}

	}
}
",4,3
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.io.InputStream;

/**
 * Built using CHelper plug-in Actual solution is at the top
 *
 * @author @Ziklon
 */
public class Main {
  public static void main(String[] args) {
    InputStream inputStream = System.in;
    OutputStream outputStream = System.out;
    InputReader in = new InputReader(inputStream);
    OutputWriter out = new OutputWriter(outputStream);
    ABirthday solver = new ABirthday();
    solver.solve(1, in, out);
    out.close();
  }

  static class ABirthday {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
      long N = in.readLong(), M = in.readLong(), K = in.readLong(), L = in.readLong();

      long ans = ((L + K) - 1) / M + 1;
      if (ans * M > N || ans * M - K < L) out.printLine(-1);
      else out.printLine(ans);
    }
  }

  static class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void close() {
      writer.close();
    }

    public void printLine(long i) {
      writer.println(i);
    }

    public void printLine(int i) {
      writer.println(i);
    }
  }

  static class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private InputReader.SpaceCharFilter filter;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (numChars == -1) {
        throw new InputMismatchException();
      }
      if (curChar >= numChars) {
        curChar = 0;
        try {
          numChars = stream.read(buf);
        } catch (IOException e) {
          throw new InputMismatchException();
        }
        if (numChars <= 0) {
          return -1;
        }
      }
      return buf[curChar++];
    }

    public long readLong() {
      int c = read();
      while (isSpaceChar(c)) {
        c = read();
      }
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      long res = 0;
      do {
        if (c < '0' || c > '9') {
          throw new InputMismatchException();
        }
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public boolean isSpaceChar(int c) {
      if (filter != null) {
        return filter.isSpaceChar(c);
      }
      return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
      return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public interface SpaceCharFilter {
      public boolean isSpaceChar(int ch);
    }
  }
}
",1,1
"//    A Computer is Like a mischievous genie.
//    It will give you exactly what you ask for,
//    but not always what you want
//    A code by Rahul Verma


import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;
import java.util.Spliterator.OfPrimitive;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.TreeMap;


public class Main {


    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));

    static class FastReader {

        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String[] nextSArray() {
            String sr[] = null;
            try {
                sr = br.readLine().trim().split("" "");
            } catch (IOException e) {
                e.printStackTrace();
            }
            return sr;
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }

            return str;
        }
    }


    static long powmodulo(long a, long p) {
        if (p == 0) {
            return 1 % mod;
        }
        if (p == 1) {
            return a % mod;
        }
        long ans = 1;
        while (p > 0) {
            if ((p & 1) > 0) {
                ans = (ans * a) % mod;
            }
            a = (a * a) % mod;
            p = p >> 1;
        }
        return ans % mod;
    }


    static long mod = 1000000007;

    static long gcd(long a, long b) {
        if (a == 0) {
            return b;
        }
        return gcd(b % a, a);
    }

    static long fast_powerNumbers(long a, long n) {
        if (n == 1) {
            return a;
        }
        long ans = fast_powerNumbers(a, n / 2);
        if (n % 2 == 0) {
            return (ans * ans);
        } else {
            return ((ans * ans) * (a));
        }
    }


    static void dfs_helper(int[][] arr, int i, int j, int team, int n, int m) {
        arr[i][j] = team;
        if (i - 1 >= 0 && arr[i - 1][j] == 1) {
            dfs(arr, i - 1, j, team, n, m);
        }
        if (j - 1 >= 0 && arr[i][j - 1] == 1) {
            dfs(arr, i, j - 1, team, n, m);
        }
        if (i + 1 < n && arr[i + 1][j] == 1) {
            dfs(arr, i + 1, j, team, n, m);
        }
        if (j + 1 < m && arr[i][j + 1] == 1) {
            dfs(arr, i, j + 1, team, n, m);
        }

    }

    static void dfs(int[][] arr, int i, int j, int team, int n, int m) {
        dfs_helper(arr, i, j, team, n, m);

    }

    static int parent[];
    static int rank[];

    static int find(int i) {
        if (parent[i] == -1) {
            parent[i] = i;
            return i;
        }

        if (parent[i] == i) {
            return i;
        } else {
            parent[i] = find(parent[i]);
        }
        return parent[i];

    }

    static void unite(int s1, int s2) {

        if (rank[s1] > rank[s2]) {
            parent[s2] = s1;
            rank[s1] += rank[s2];
        } else {
            parent[s1] = s2;
            rank[s2] += rank[s1];
        }
    }


    static int arr[];

    static void seive(int n) {
        arr = new int[n + 1];
        arr[0] = arr[1] = 1;
        for (int i = 4; i <= n; i = i + 2) {
            arr[i] = 1;
        }
        for (int i = 3; i * i <= n; i = i + 2) {
            if (arr[i] == 0) {
                for (int j = i * i; j <= n; j = j + i) {
                    arr[j] = 1;
                }

            }
        }
    }


    public static void main(String[] args) throws Exception {
        FastReader sc = new FastReader();

//        int t1=sc.nextInt();
//        while(t1-->0)
//        {
        long n=sc.nextLong();
        long m=sc.nextLong();
        long k=sc.nextLong();
        long l=sc.nextLong();

            if (n < m || n - k < l) {
                System.out.println(-1);
            } else {
                long ans=(l+k)/m;
                if((l+k)%m!=0)
                   ans= ans+1;

                if (ans * m > n) {
                   // System.out.println(ans);
                    System.out.println(-1);
                    return;
                }
                System.out.println(ans);
            }





    }
}





class Pair {

    int a;
    int b;

    Pair(int a, int b) {
        this.a = a;
        this.b = b;
    }
}


class Graph {

    HashMap<Integer, ArrayList<Integer>> hm;

    Graph() {
        hm = new HashMap<>();
    }

    Graph(int n) {

        hm = new HashMap<>();
        for (int i = 0; i < n; i++) {
            hm.put(i, new ArrayList<Integer>());
        }
    }

    // function for adding an edge.................................................
    public void addEdge(int a, int b, boolean isDir) {
        if (isDir) {
            if (hm.containsKey(a)) {
                hm.get(a).add(b);
            } else {
                hm.put(a, new ArrayList<>(Arrays.asList(b)));
            }
        } else {
            if (hm.containsKey(a)) {
                hm.get(a).add(b);
            } else if (!hm.containsKey(a)) {
                hm.put(a, new ArrayList<>(Arrays.asList(b)));
            }

            if (hm.containsKey(b)) {
                hm.get(b).add(a);
            } else if (!hm.containsKey(b)) {
                hm.put(b, new ArrayList<>(Arrays.asList(a)));
            }
        }
    }


}

// out.println(al.toString().replaceAll(""[\\[|\\]|,]"",""""));

",1,3
"import java.io.*;
import java.util.*;
public class Codechef{
	

    public static void main(String []args){
    			Scanner in = new Scanner(System.in);

    long n=in.nextLong();
		long m=in.nextLong();
		long k=in.nextLong();
		long l=in.nextLong();
 
		long j=((k+l)/m);
		if((k+l)%m!=0)j++;
		if((k+l>n) || j*m>n) {
			System.out.println(-1);
		}else {
			
			System.out.println(j);
		}


    }

}",1,1
"import java.util.*;
import java.math.*;
import java.io.*;

public class CF1068A {
	public CF1068A() {
		FS scan = new FS();
		long n = scan.nextLong(), m = scan.nextLong(), k = scan.nextLong(), l = scan.nextLong();
		long ceil = (k + l + m - 1) / m;
		if(k + l <= n && ceil * m <= n) System.out.println(ceil);
		else System.out.println(-1);
	}
	class FS {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer("""");
		public String next() {
			while(!st.hasMoreTokens()) {
				try { st = new StringTokenizer(br.readLine()); }
				catch(Exception e) { e.printStackTrace(); }
			}
			return st.nextToken();
		}
		public int nextInt() { return Integer.parseInt(next()); }
		public long nextLong() { return Long.parseLong(next()); }
	}
	public static void main(String[] args) { new CF1068A(); }
}
",1,1
"import java.util.*;
import java.math.*;
import java.io.*; 
 public class B{
static int[] dx={-1,1,0,0};
static int[] dy={0,0,1,-1};
    static FastReader scan=new FastReader();
   public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));
  static ArrayList<Pair>es;
  static LinkedList<Integer>edges[];
   static boolean prime[];
   static void sieve(int n) 
    { 
        
        prime = new boolean[n+1]; 
        for(int i=0;i<n;i++) 
            prime[i] = true; 
          
        for(int p = 2; p*p <=n; p++) 
        { 
           
            if(prime[p] == true) 
            { 
                
                for(int i = p*p; i <= n; i += p) 
                    prime[i] = false; 
            } 
        } 
          
        
    }      
     public static int lowerBound(long[] array, int length, long value) {
        int low = 0;
        int high = length;
        while (low < high) {
            final int mid = (low + high) / 2;
            //checks if the value is less than middle element of the array
            if (value <= array[mid]) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
    public static int upperBound(long[] array, int length, long value) {
        int low = 0;
        int high = length;
        while (low < high) {
            final int mid = low+(high-low) / 2;
            if ( array[mid]>value) {
                high = mid ;
            } else {
                low = mid+1;
            }
        }
        return low;
    }
static long mod(long x,long y)
    {
        if(x<0)
            x=x+(-x/y+1)*y;
        return x%y;
    }    
     static boolean isPowerOfTwo(long n) 
    { 
        if (n == 0) 
            return false; 
  
        while (n != 1) { 
            if (n % 2 != 0) 
                return false; 
            n = n / 2; 
        } 
        return true; 
    } 

  
   
static boolean isprime(long x)
           {
            for(long i=2;i*i<=x;i++)
                if(x%i==0)
                    return false;
                return true;
           }


static int dist(int x1,int y1,int x2,int y2){
return Math.abs(x1-x2)+Math.abs(y1-y2);
}


    static long cuberoot(long x)
    {
        long lo = 0, hi = 1000005;
        while(lo<hi)
        {
            long m = (lo+hi+1)/2;
            if(m*m*m>x)
                hi = m-1;
            else
                lo = m;
        }
        return lo;
    }
     public static int log2(int N) 
    { 
  
        // calculate log2 N indirectly 
        // using log() method 
        int result = (int)(Math.log(N) / Math.log(2)); 
  
        return result; 
    } 
  
    
   
       static long gcd(long a, long b) {
    if(a!=0&&b!=0)
        while((a%=b)!=0&&(b%=a)!=0);
    return a^b;
}
    static long LCM(long a,long b){
    return (Math.abs(a*b))/gcd(a,b);
   }
   public static class comp1 implements Comparator<Pair>{  
public int compare(Pair o1,Pair o2){
   if(o2.x==o1.x)
    return (o2.y-o1.y)>0?1:-1;
return (o2.x-o1.x)>0?1:-1;
}
  }
     public static class comp2 implements Comparator<Pair>{  
public int compare(Pair o1,Pair o2){
 
return (o2.ab-o1.ab)>0?1:-1;
}
  }
 static boolean can(int m,int s)
 {
    return (s>=0&&s<=m*9);
 }
   static boolean collinear(long x1, long y1, long x2,  
                          long y2, long x3, long y3) 
{
    long a = x1 * (y2 - y3) +  
                x2 * (y3 - y1) +  
                x3 * (y1 - y2); 
                if(a==0)
                    return true;
                return false;
}
static boolean vis[]=new boolean[51];
static int cnt=0;
static void dfs(int x)
{
    vis[x]=true;
    cnt++;
    for(int k:edges[x])
    {
        if(!vis[k])
            dfs(k);
                }

}
public static void main(String[] args)  throws Exception 
{
//java.util.Scanner scan=new java.util.Scanner(new File(""mootube.in""));
 //PrintWriter out = new PrintWriter (new FileWriter(""mootube.out""));
//scan=new FastReader(""equal.in"");
//out = new PrintWriter (""output.txt"");
//System.out.println(3^2);
//System.out.println(19%4);
   //StringBuilder news=new StringBuilder(""ab"");
   //news.deleteCharAt(1);
   //news.insert(0,'c');
   //news.deleteCharAt(0);
   //System.out.println(news);
   //System.out.println(can(2,15));
    //System.out.println(LCM(2,2));
  // System.out.println(31^15);
 //System.out.println(""bbabbbabbbabbbabbbabbbabbbabbbabbbabbbab"".length());
int tt=1;
//tt=scan.nextInt();
//System.out.println(gcd(519,437));
  outer:while(tt-->0)
 {
    long n=scan.nextLong(),m=scan.nextLong(),l=scan.nextLong(),k=scan.nextLong();
    long res=0;
    if((l+k)%m!=0)
        res=((l+k)/m)+1;
    else res=(l+k)/m;
    if(m*res<=n)
        out.println(res);
    else out.println(-1);
    
  

}

out.close();
}    



static long binexp(long a,long n,long mod)
{
    if(n==0)
       return 1;
    long res=binexp(a,n/2,mod)%mod;
    res=res*res;
    if(n%2==1)
        return (res*a)%mod;
    else 
        return res%mod;
}
static class special implements Comparable<special> {
    char x;
    int id;
    special(char x,int id)
    {
        this.id=id;
       this.x=x;
    }
    public int compareTo(special o)
    {
        return o.id-id;
    }
   
}
static long powMod(long base, long exp, long mod) {
       if (base == 0 || base == 1) return base;
       if (exp == 0) return 1;
       if (exp == 1) return base % mod;
       long R = powMod(base, exp/2, mod) % mod;
       R *= R;
       R %= mod;
       if ((exp & 1) == 1) {
           return base * R % mod;
       }
       else return R % mod;
   }
 public static  long pow(long b, long e) {
            long r = 1;
            while (e > 0) {
                if (e % 2 == 1) r = r * b ;
                b = b * b;
                e >>= 1;
            }
            return r;
        }

private static void sort(int[] arr) {
        List<Integer> list = new ArrayList<>();
        for (int object : arr) list.add(object);
        Collections.sort(list);
        for (int i = 0; i < list.size(); ++i) arr[i] = list.get(i);
    }
 public static class FastReader {
        BufferedReader br;
        StringTokenizer root;
        
 
        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        FastReader(String filename)throws Exception
        {

            br=new BufferedReader(new FileReader(filename));
        }
 
        String next() {
            while (root == null || !root.hasMoreTokens()) {
                try {
                    root = new StringTokenizer(br.readLine());
                } catch (Exception addd) {
                    addd.printStackTrace();
                }
            }
            return root.nextToken();
        }
 
        int nextInt() {
            return Integer.parseInt(next());
        }
 
        double nextDouble() {
            return Double.parseDouble(next());
        }
 
        long nextLong() {
            return Long.parseLong(next());
        }
 
        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (Exception addd) {
                addd.printStackTrace();
            }
            return str;
        }
         public int[] nextIntArray(int arraySize) {
            int array[] = new int[arraySize];
 
            for (int i = 0; i < arraySize; i++) {
                array[i] = nextInt();
            }
 
            return array;
        }
}
public static class Pair implements Comparable<Pair>{
         int x;
         int y;
         long ab;
        
        int z;
        public Pair(){}
        public Pair(int x1, int y1,int z) {
            x=x1;
            y=y1;
            this.z=z;
        }
        public Pair(int x1, int y1) {
            x=x1;
            y=y1;
            this.ab=x+y;
        
        }
        @Override
        public int hashCode() {
            return (int)(x + 31 * y);
        }
        public String toString() {
            return x + "" "" + y;
        }
        @Override
        public boolean equals(Object o){
            if (o == this) return true;
            if (o.getClass() != getClass()) return false;
            Pair t = (Pair)o;
            return t.x == x && t.y == y;
        }
        public  int compareTo(Pair o)
        {
            return (int) (o.x-x);    
        }
}

}







",1,3
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class a1113 {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] strings = reader.readLine().split("" "");
        int lastCity = Integer.parseInt(strings[0]);
        int tankSize = Integer.parseInt(strings[1]);
        int money = 0, oil = 0;

        for (int currentCity = 1; currentCity < lastCity; ) {
            if (lastCity - currentCity <= oil) {
                break;
            } else {
                int needOil = tankSize > lastCity - currentCity ? lastCity - currentCity - oil : tankSize - oil;
                money += needOil * currentCity;
                oil += needOil;
                currentCity++;
                oil--;
            }
        }
        System.out.println(money);
        reader.close();
    }
}
",1,3
"
import java.util.*;

public class Main {

    public static void main(String[] args) {

        Scanner scan=new Scanner(System.in);

        int n,v;

        n=scan.nextInt();

        v=scan.nextInt();

        int[]dp=new int[n];

        if(v<n){

            dp[0]=v;

        }

        else{

            dp[0]=n-1;

        }

        for(int i=1;i<n;i++){

            if(v-1<n-i-1){

                dp[i]=dp[i-1]+i+1;

            }

            else{

                dp[i]=dp[i-1];

            }

        }

        System.out.println(dp[n-1]);

    }
}
",1,3
"    import java.util.Scanner;

    public class Sasha1113A {

        static int solution(int n, int v){
            int count;
            if(v>=n)
                return n-1;
            else{
                count = (v-1) + ((n-v)*(n-v+1))/2;
            }
            return count;
        }

        public static void main(String[] args){
            Scanner scan = new Scanner(System.in);
            int n = scan.nextInt();
            int v = scan.nextInt();

            System.out.print(solution(n, v));
        }
    }
",1,1
"    import jdk.nashorn.internal.objects.NativeArray;

    import javax.swing.JOptionPane ;
    import javax.swing.plaf.basic.BasicInternalFrameTitlePane;
    import java.sql.SQLSyntaxErrorException;
    import java.util.Arrays;
    import java.util.Scanner;
    import java.util.Vector;


    import static jdk.nashorn.internal.objects.NativeArray.sort;
    import static jdk.nashorn.internal.runtime.ScriptObject.toPropertyDescriptor;

    public class Dialog1 {
        private static int n ;
        private static String s ;
        private static char[] a;
        public static void main(String[] args) {
            Scanner input = new Scanner(System.in);
            n = input.nextInt() ;
            s = input.next() ;
            a = s.toCharArray();
            for(int i = 0 ; i < 200 ; ++i) {
                int cur = i ;
                boolean fl = true ;
                for(int j = 0 ; j < n ; ++j) {
                    if(a[j] == '+')
                        ++cur ;
                    else
                        --cur ;
                    if(cur < 0)
                        fl = false ;
                }
                if(fl) {
                    System.out.print(cur);
                    return ;
                }
            }
        }
    }",3,3
"import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		while(sc.hasNext()) {
			int n=sc.nextInt();
			String s=sc.next();
			int sum=0;
			for(int i=0;i<s.length();i++) {
				if(s.charAt(i)=='+') {
					sum++;
				}
				if(s.charAt(i)=='-'&&sum!=0) {
					sum--;
				}
			}
			System.out.println(sum);
		}
	}
}",3,3
"import java.util.*;
import java.math.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------

public class a{ 
     static int[] count,count1,count2;
     static Node[] nodes;
     static long[] arr;
     static int[] dp,arrInt,darrInt;
     static char[] ch,ch1;
     static long[] darr,farr;
     static char[][] mat,mat1;
     static int[][] space;
     static boolean[][] vis;
     static long x,h;
     static long maxl;
     static double dec;
     static long mx = (long)1e10;
     static String s,s1,s2,s3,s4;
     static long minl;
     static int start_row;
     static int start_col;     
     static int end_row;     
     static int end_col;     
     static long mod = 998244353;
     // static int minl = -1;
     // static long n;
     static int n,n1,n2,q,r1,c1,r2,c2;
     static long a;
     static long b;
     static long c;
     static long d;
     static long y,z;
     static int m;
     static long k;
     static FastScanner sc;
     static String[] str,str1;
     static Set<Integer> set,set1,set2;
     static SortedSet<Long> ss;
     static List<Long> list,list1,list2,list3;
     static PriorityQueue<Integer> pq,pq1;
     static LinkedList<Node> ll;
     static Map<Integer,List<Integer>> map1;
     static Map<Long,Integer> map;
     static StringBuilder sb,sb1,sb2;
     static int index;
     static long[] sum;
     static int[] dx = {0,-1,0,1,-1,1,-1,1};
     static int[] dy = {-1,0,1,0,-1,-1,1,1};

     // public static void solve(){

     //    FastScanner sc = new FastScanner();
     //    // int t = sc.nextInt();
     //    int t = 1;
     //    for(int tt = 0 ; tt < t ; tt++){

     //        // s = sc.next();
     //        // s1 = sc.next();

     //        n = sc.nextInt();
     //        // m = sc.nextInt();
     //        // sb = new StringBuilder();
     //        // map = new HashMap<>();
     //        // q = sc.nextInt();
     //        k = sc.nextLong();
     //        // ch = sc.next().toCharArray();
     //        // boolean ans = false;
     //        // int charge = n;
     //        // int prev = 0;

     //        // count = new int[8];
           
     //        m = sc.nextInt();
     //        long ans = 0;
     //        long added = 0;
     //        for(int j = 0 ; j < m ; j++){

     //            int l = sc.nextInt();
     //            int r = sc.nextInt();
     //            long a = sc.nextLong();
     //            added += (r-l+1);
     //            ans += (r-l+1)*(a*a);

     //        }

     //        ans += (n-added)*(k*k);
     //        System.out.println(ans);
     //    }
        
     // }

     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------
  
     public static void solve(){

        long stones =0 ;
        for(int i = 0 ;  i < n ; i++){
            if(ch[i] == '+'){
                stones += 1;
            }
            else{
                stones -= 1;
            }
            if(stones < 0)
                stones = 0;
        }

        System.out.println(stones);

     }
        
     public static void main(String[] args) {

            sc = new FastScanner();
            // Scanner sc = new Scanner(System.in);
            // int t = sc.nextInt();
            int t = 1;
            // int l = 1;
            while(t > 0){
                
                // n = sc.nextInt();
                // n = sc.nextLong();
                // k = sc.nextLong();
                // a = sc.nextLong();
                // b = sc.nextLong();
                // c = sc.nextLong();
                // d = sc.nextLong();

                // x = sc.nextLong();
                // y = sc.nextLong();
                
                // n = sc.nextLong();
                n = sc.nextInt();
                // n = 3;
                // n1 = sc.nextInt();

                // m = sc.nextInt();
                // q = sc.nextInt();

                // k = sc.nextLong();
                // s = sc.next();

                ch = sc.next().toCharArray();
                // ch1 = sc.next().toCharArray();

                // arr = new long[n];
                // for(int i = 0 ; i < n ; i++){
                //     arr[i] = sc.nextLong();
                // }

                // arrInt = new int[n];
                // for(int i = 0 ; i < n ; i++){
                //     arrInt[i] = sc.nextInt();
                // }
                // x = sc.nextLong();
                // y = sc.nextLong();
                // ch = sc.next().toCharArray();
                // m = n;
                // darr = new long[m];
                // for(int i = 0 ; i < m ; i++){
                //     darr[i] = sc.nextLong();
                // }

                // m = n;
                // darrInt = new int[m];
                // for(int i = 0 ; i < m ; i++){
                //     darrInt[i] = sc.nextInt();
                // }

                // farr = new int[n];
                // for(int i = 0; i < n ; i++){
                //     farr[i] = sc.nextInt();
                // }

                // mat = new int[n][n];
                // for(int i = 0 ; i < n ; i++){
                //     for(int j = 0 ;  j < n ; j++){
                //         mat[i][j] = sc.nextInt();
                //     }
                // }

                // m = n;
                // mat = new char[n][m];
                // for(int i = 0 ; i < n ; i++){
                //     String s = sc.next();
                //     for(int j = 0 ; j < m ; j++){
                //         mat[i][j] = s.charAt(j);
                //     }
                // }

                // m = n;
                // mat1 = new char[n][m];
                // for(int i = 0 ; i < n ; i++){
                //     String s = sc.next();
                //     for(int j = 0 ; j < m ; j++){
                //         mat1[i][j] = s.charAt(j);
                //     }
                // }

                // str = new String[n];
                // for(int i = 0 ; i < n ; i++)
                //     str[i] = sc.next();

                // nodes = new Node[n];
                // for(int i = 0 ; i < n ;i++)
                //     nodes[i] = new Node(sc.nextInt(),(i));

                // System.out.println(solve()?""YES"":""NO"");
                 solve();       
                 // System.out.println(solve());
                 t -= 1;
            }

     }

     // public static dfs(int i){

     //    if(count[i] == 1)
     //        return;
     //    list = map.get(i);
     //    for(Integer j : list){
     //        if(j == i)
     //            continue;
     //        dfs(j);
     //    }
     // }

    public static int log(long n,long base){

         if(n == 0 || n == 1)
             return 0;

         if(n == base)
             return 1;

         double num = Math.log(n);
         double den = Math.log(base);

         if(den == 0)
             return 0;

         return (int)(num/den);
     }

    public static boolean isPrime(long n) { 
    // Corner cases 
        if (n <= 1)  
            return false; 

        if (n <= 3)  
            return true; 
      
        // This is checked so that we can skip  
        // middle five numbers in below loop 
        if (n%2 == 0 || n%3 == 0) 
            return false; 
      
        for (int i=5; i*i<=n; i=i+6) 
            if (n%i == 0 || n%(i+2) == 0) 
               return false; 
      
        return true; 
    } 

     public static long gcd(long a,long b){

        if(b%a == 0){
            return a;
        }
        return gcd(b%a,a);

     }

     public static void swap(int i,int j){
         long temp = arr[j];
         arr[j] = arr[i];
         arr[i] = temp;
     } 

    static final Random random=new Random();

    static void ruffleSortLong(long[] a) {
        int n=a.length;//shuffle, then sort 
        for (int i=0; i<n; i++) {
            int oi=random.nextInt(n);
            long temp=a[oi];
            a[oi]=a[i]; a[i]=temp;
        }
        Arrays.sort(a);
    }

    static void ruffleSortInt(int[] a) {
        int n=a.length;//shuffle, then sort 
        for (int i=0; i<n; i++) {
            int oi=random.nextInt(n);
            int temp=a[oi];
            a[oi]=a[i]; a[i]=temp;
        }
        Arrays.sort(a);
    }
    
    static void ruffleSortChar(char[] a) {
        int n=a.length;//shuffle, then sort 
        for (int i=0; i<n; i++) {
            int oi=random.nextInt(n);
            char temp=a[oi];
            a[oi]=a[i]; a[i]=temp;
        }
        Arrays.sort(a);
    }

    static class Node{
        Integer first;
        Integer second;
        Node(Integer f,Integer s){
            this.first = f;
            this.second = s;
        }
    }

     static class FastScanner {

                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
                StringTokenizer st=new StringTokenizer("""");
                String next() {
                        while (!st.hasMoreTokens())
                                try {
                                        st=new StringTokenizer(br.readLine());
                                } catch (IOException e) {
                                        e.printStackTrace();
                                }
                        return st.nextToken();
                }
                
                int nextInt() {
                        return Integer.parseInt(next());
                }
                int[] readArray(int n) {
                        int[] a=new int[n];
                        for (int i=0; i<n; i++) a[i]=nextInt();
                        return a;
                }
                long nextLong() {
                        return Long.parseLong(next());
                }
        }

}",3,3
"import java.util.Scanner;

public class _0310Apileofstones {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		int n=sc.nextInt();
		sc.nextLine();
		String input =sc.nextLine();
		boolean flag=false;
		int count=0;
		for(int i=0;i<n;i++) {
			if(input.charAt(i)=='+') {
				flag=true;
				count++;
			}
			if(flag) {
				if(input.charAt(i)=='-') {
					if(count!=0) {
					count--;
					}
				}
			}
		}
		System.out.println(count);
	}

}
",3,3
"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package newpackage;
import java.util.*;
/**
 *
 * @author parpaorsa
 */
public class NewClass {
    static Scanner in=new Scanner(System.in);
    public static void main(String[] args) {
        int n = in.nextInt(),ans=Integer.MAX_VALUE,t=0;
        String x = in.next();
        for (int i = 0; i < n; i++) {
            if(x.charAt(i)=='-')t--;
            else t++;
            ans=Math.min(ans,t);
        }
           if(ans <= 0) 
               System.out.println(Math.abs(ans)+t);
           else 
               System.out.println(t);
    }
 
}
",3,3
"import java.io.*;
import java.util.*;
 
 
 
public class Main {
	
	static InputReader in = new InputReader(System.in);
	static PrintWriter out = new PrintWriter(System.out);

	static long oo = 1000000000000L;
	
	public static void main(String[] args) throws IOException {
 
		int n = in.nextInt();
		int q = in.nextInt();
		
		ArrayDeque<Integer> dq = new ArrayDeque<>();
		int max = -1;
		for(int i = 0; i < n; ++i) {
			int x = in.nextInt();
			dq.add(x);
			max = Math.max(max, x);
		}
		ArrayList<Pair> ans = new ArrayList<>();
		while(dq.peekFirst() != max) {
			int a = dq.pollFirst();
			int b = dq.pollFirst();
			ans.add(new Pair(a, b));
			if(a > b) {
				dq.addFirst(a);
				dq.addLast(b);
			}
			else {
				dq.addFirst(b);
				dq.addLast(a);
			}
		}
		ArrayList<Integer> a = new ArrayList<>();
		dq.pollFirst();
		for(int x : dq)
			a.add(x);
		while(q --> 0) {
			long m = in.nextLong() - 1;
			if(m < ans.size()) {
				System.out.println(ans.get((int)m).first + "" "" + ans.get((int)m).second);
			}
			else {
				int idx = (int)((m - ans.size()) % a.size());
				System.out.println(max + "" "" + a.get(idx));
			}
		}
		
		out.close();
	}
	
	
	
	static long lcm(long a, long b) {
		return a * b / gcd(a, b);
	}
	
	static boolean nextPermutation(int[] a) {
		for(int i = a.length - 2; i >= 0; --i) {
			if(a[i] < a[i+1]) {
				for(int j = a.length - 1; ; --j) {
					if(a[i] < a[j]) {
						int t = a[i];
						a[i] = a[j];
						a[j] = t;
						for(i++, j = a.length - 1; i < j; ++i, --j) {
							t = a[i];
							a[i] = a[j];
							a[j] = t;
						}
						return true;
					}
				}
			}
		}
		return false;
	}
	
	
	static void shuffle(int[] a) {
		Random r = new Random();
		for(int i = a.length - 1; i > 0; --i) {
			int si = r.nextInt(i);
			int t = a[si];
			a[si] = a[i];
			a[i] = t;
		}
	}
	
	static void shuffle(long[] a) {
		Random r = new Random();
		for(int i = a.length - 1; i > 0; --i) {
			int si = r.nextInt(i);
			long t = a[si];
			a[si] = a[i];
			a[i] = t;
		}
	}
	
	static int lower_bound(int[] a, int n, int k) {
		int s = 0;
		int e = n;
		int m;
		while (e - s > 0) {
			m = (s + e) / 2;
			if (a[m] < k)
				s = m + 1;
			else
				e = m;
		}
		return e;
	}
	static int lower_bound(long[] a, int n, long k) {
		int s = 0;
		int e = n;
		int m;
		while (e - s > 0) {
			m = (s + e) / 2;
			if (a[m] < k)
				s = m + 1;
			else
				e = m;
		}
		return e;
	}
	
	static int gcd(int a, int b) {
		return b == 0 ? a : gcd(b, a % b);
	}
	static long gcd(long a, long b) {
		return b == 0 ? a : gcd(b, a % b);
	}
	
	static class Pair implements Comparable<Pair> {
		int first, second;
 
		public Pair(int first, int second) {
			super();
			this.first = first;
			this.second = second;
		}
 
		@Override
		public int compareTo(Pair o) {
			return this.first != o.first ? this.first - o.first : this.second - o.second;
		}
 
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + first;
			result = prime * result + second;
			return result;
		}
 
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Pair other = (Pair) obj;
			if (first != other.first)
				return false;
			if (second != other.second)
				return false;
			return true;
		}
	}
	
	
}
 
 
 
class InputReader {
 
	private final InputStream stream;
	private final byte[] buf = new byte[8192];
	private int curChar, snumChars;
 
	public InputReader(InputStream st) {
		this.stream = st;
	}
 
	public int read() {
		if (snumChars == -1)
			throw new InputMismatchException();
		if (curChar >= snumChars) {
			curChar = 0;
			try {
				snumChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (snumChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}
 
	public int nextInt() {
		int c = read();
		while (isSpaceChar(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}
 
	public long nextLong() {
		int c = read();
		while (isSpaceChar(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}
 
	public int[] nextIntArray(int n) {
		int a[] = new int[n];
		for (int i = 0; i < n; i++) {
			a[i] = nextInt();
		}
		return a;
	}
 
	public String readString() {
		int c = read();
		while (isSpaceChar(c)) {
			c = read();
		}
		StringBuilder res = new StringBuilder();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}
 
	public String nextLine() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isEndOfLine(c));
		return res.toString();
	}
 
	public boolean isSpaceChar(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
 
	private boolean isEndOfLine(int c) {
		return c == '\n' || c == '\r' || c == -1;
	}
 
}",3,3
"import java.io.*;
import java.util.*;
import java.math.*;
import java.lang.*;

public class Main implements Runnable {
    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private SpaceCharFilter filter;
        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1)
                throw new InputMismatchException();

            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }

                if (numChars <= 0)
                    return -1;
            }
            return buf[curChar++];
        }

        public String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }

        public int nextInt() {
            int c = read();

            while (isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));

            return res * sgn;
        }

        public long nextLong() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public double nextDouble() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            double res = 0;
            while (!isSpaceChar(c) && c != '.') {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, nextInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            }
            if (c == '.') {
                c = read();
                double m = 1;
                while (!isSpaceChar(c)) {
                    if (c == 'e' || c == 'E')
                        return res * Math.pow(10, nextInt());
                    if (c < '0' || c > '9')
                        throw new InputMismatchException();
                    m /= 10;
                    res += (c - '0') * m;
                    c = read();
                }
            }
            return res * sgn;
        }

        public String readString() {
            int c = read();
            while (isSpaceChar(c))
                c = read();
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {
            if (filter != null)
                return filter.isSpaceChar(c);
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public String next() {
            return readString();
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);
        }
    }

    public static void main(String args[]) throws Exception {
        new Thread(null, new Main(), ""Main"", 1 << 27).start();
    }

    static class Pair {
        int f;
        int s;
        int p;
        PrintWriter w;

        // int t;

        Pair(int f, int s) {
            // Pair(int f,int s, PrintWriter w){
            this.f = f;
            this.s = s;
            // this.p = p;
            // this.w = w;
            // this.t = t;

        }

        public static Comparator<Pair> wc = new Comparator<Pair>() {
            public int compare(Pair e1, Pair e2) {

                // 1 for swap
                if (Math.abs(e1.f) - Math.abs(e2.f) != 0) {
                    // e1.w.println(""**""+e1.f+"" ""+e2.f);
                    return -1 * (Math.abs(e1.f) - Math.abs(e2.f));
                } else {
                    // e1.w.println(""##""+e1.f+"" ""+e2.f);
                    return (Math.abs(e1.s) - Math.abs(e2.s));
                }

            }
        };
    }

    public Integer[] sort(Integer[] a) {
        Arrays.sort(a);
        return a;
    }

    public Long[] sort(Long[] a) {
        Arrays.sort(a);
        return a;
    }

    public void yesOrNo(boolean f) {
        if (f) {
            w.println(""YES"");
        } else {
            w.println(""NO"");
        }
    }

    public static ArrayList<Integer> sieve(int N) {
        int i, j, flag;

        ArrayList<Integer> p = new ArrayList<Integer>();

        for (i = 1; i < N; i++) {

            if (i == 1 || i == 0)
                continue;

            flag = 1;

            for (j = 2; j <= i / 2; ++j) {
                if (i % j == 0) {
                    flag = 0;
                    break;
                }
            }
            if (flag == 1) {
                p.add(i);
            }
        }
        return p;
    }

    public static long gcd(long a, long b) {
        if (b == 0)
            return a;
        else
            return gcd(b, a % b);
    }

    //// recursive dfs
    public int dfs(int s, ArrayList<Integer>[] g, long[] dist, boolean[] v, int p) {
        v[s] = true;
        int ans = 1;
        // int n = dist.length - 1;
        int t = g[s].size();
        // int max = 1;
        for (int i = 0; i < t; i++) {
            int x = g[s].get(i);
            if (!v[x]) {
                // dist[x] = dist[s] + 1;
                ans = Math.min(ans, dfs(x, g, dist, v, s));
            } else if (x != p) {
                // w.println(""* "" + s + "" "" + x + "" "" + p);
                ans = 0;
            }
        }
        // max = Math.max(max,(n-p));
        return ans;
    }

    //// iterative BFS
    public int bfs(int s, ArrayList<Integer>[] g, long[] dist, boolean[] b, int p) {
        b[s] = true;
        int siz = 1;
        // dist--;
        Queue<Integer> q = new LinkedList<>();
        q.add(s);
        while (q.size() != 0) {
            int i = q.poll();
            Iterator<Integer> it = g[i].listIterator();
            int z = 0;
            while (it.hasNext()) {
                z = it.next();
                if (!b[z]) {
                    b[z] = true;
                    // dist--;
                    dist[z] = dist[i] + 1;
                    // siz++;
                    q.add(z);
                } else if (z != p) {
                    siz = 0;
                }
            }

        }
        return siz;
    }

    public static int lower(int a[], int x) { // x is the target value or key
        int l = -1, r = a.length;
        while (l + 1 < r) {
            int m = (l + r) >>> 1;
            if (a[m] >= x)
                r = m;
            else
                l = m;
        }
        return r;
    }

    public static int upper(int a[], int x) {// x is the key or target value
        int l = -1, r = a.length;
        while (l + 1 < r) {
            int m = (l + r) >>> 1;
            if (a[m] <= x)
                l = m;
            else
                r = m;
        }
        return l + 1;
    }

    public static int lower(ArrayList<Integer> a, int x) { // x is the target value or key
        int l = -1, r = a.size();
        while (l + 1 < r) {
            int m = (l + r) >>> 1;
            if (a.get(m) >= x)
                r = m;
            else
                l = m;
        }
        return r;
    }

    public static int upper(ArrayList<Integer> a, int x) {// x is the key or target value
        int l = -1, r = a.size();
        while (l + 1 < r) {
            int m = (l + r) >>> 1;
            if (a.get(m) <= x)
                l = m;
            else
                r = m;
        }
        return l + 1;
    }

    public static long power(long x, long y, long m) {
        if (y == 0)
            return 1;

        long p = power(x, y / 2, m) % m;
        p = (p * p) % m;

        if (y % 2 == 0)
            return p;
        else
            return (x * p) % m;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    // code here
    int oo = (int) 1e9;
    int[] parent;
    int[] dist;
    int[] height;
    boolean[][][][] vis;
    // ArrayList<Integer>[] g;
    int[] col;
    long[][] dp;
    char[][] g;
    // boolean[][] v;
    int[] a;
    // ArrayList<Integer[]> a;
    // int[][] ans;
    long mod;
    int n;
    int m;
    // StringBuilder[] a;
    // StringBuilder[] b;
    PrintWriter w = new PrintWriter(System.out);

    public void run() {

        InputReader sc = new InputReader(System.in);

        int defaultValue = 0;
        mod = 1000000007;

        int test = 1;
        // test = sc.nextInt();
        while (test-- > 0) {
            n = sc.nextInt();
            int q = sc.nextInt();
            int[][] ans = new int[n][2];
            ArrayList<Integer> a = new ArrayList<Integer>();
            for (int i = 0; i < n; i++) {
                a.add(sc.nextInt());
            }
            int f = a.get(0);
            a.remove(0);
            for (int i = 1; i < n; i++) {
                int z = a.get(0);
                a.remove(0);
                ans[i - 1][0] = f;
                ans[i - 1][1] = z;
                a.add(Math.min(f, z));
                f = Math.max(f, z);

            }
            // Arrays . so r t (a);
            // for (int i = 0; i < a.size(); i++) {
            // w.println(a.get(i));
            // }
            for (int i = 0; i < q; i++) {
                long x = sc.nextLong() - 1;
                if (x > n - 2) {
                    x = x % (n - 1);
                    w.println(f + "" "" + a.get((int) x));
                } else {
                    w.println(ans[(int) x][0] + "" "" + ans[(int) x][1]);
                }
            }

        }

        w.flush();
        w.close();

    }

}
",3,6
"

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;

public class C {

    void solve(){
       int n = readInt();
       int q = readInt();
       int max = 0;
       int[] a = new int[n];
       Deque<Integer> deque = new ArrayDeque<>();
       for(int i = 0;i<n;i++){
           a[i] = readInt();
           deque.addLast(a[i]);
           max = Math.max(max, a[i]);
       }
        List<String> ans = new ArrayList<>();
        while(deque.peekFirst() != max){
           int one = deque.pollFirst();
           int two = deque.pollFirst();
           ans.add(one + "" "" + two);
           deque.addFirst(one > two ? one : two);
           deque.addLast(one > two ? two : one);
           if(one == max) break;
       }

       for(int i = 0;i<n;i++){
           a[i] = deque.pollFirst();
       }

       for(int i = 0;i<q;i++){
          long x = readLong();
           if(x <= ans.size()){
               out.println(ans.get((int)x - 1));
               continue;
           }
           x -= ans.size();
           int y =(int) (x%(n - 1) - 1%(n - 1) + (n - 1)) % (n - 1) + 1;
           out.println(max + "" "" + a[y]);
       }
    }

    public static void main(String[] args) {
        new C().run();
    }

    void run(){
        init();
        solve();
        out.close();
    }

    BufferedReader in;
    PrintWriter out;

    StringTokenizer tok = new StringTokenizer("""");

    void init(){
        in = new BufferedReader(new InputStreamReader(System.in));
        out  = new PrintWriter(System.out);
    }

    String readLine(){
        try{
            return in.readLine();
        }catch(Exception ex){
            throw new RuntimeException(ex);
        }
    }
    String readString(){
        while(!tok.hasMoreTokens()){
            String nextLine = readLine();
            if(nextLine == null) return null;
            tok = new StringTokenizer(nextLine);
        }
        return tok.nextToken();
    }

    int readInt(){
        return Integer.parseInt(readString());
    }

    long readLong(){
        return Long.parseLong(readString());
    }

    double readDouble(){
        return Double.parseDouble(readString());
    }
}
",3,3
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class First {

    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskA solver = new TaskA();
        //int a = 1;
        int t;
        //t = in.nextInt();
        t = 1;
        while (t > 0) {
            //out.print(""Case #""+(a++)+"": "");
            solver.call(in,out);
            t--;
        }
        out.close();

    }

    static class TaskA {
        public void call(InputReader in, PrintWriter out) {
            int n, q;
            n = in.nextInt();
            q = in.nextInt();

            ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();
            Map<Integer, answer> map = new HashMap<>();

            int a, b, c = 0, max = Integer.MIN_VALUE;

            for (int i = 0; i < n; i++) {
                a = in.nextInt();
                arrayDeque.add(a);
                max = Math.max(max, a);
            }

            for (int i = 0; i < n; i++) {
                if(arrayDeque.getFirst() == max){
                    break;
                }

                a = arrayDeque.removeFirst();
                b = arrayDeque.removeFirst();

                map.put(i+1,new answer(a,b));
                c = i+1;

                if(a>b){
                    arrayDeque.addFirst(a);
                    arrayDeque.addLast(b);
                }
                else{
                    arrayDeque.addFirst(b);
                    arrayDeque.addLast(a);
                }

            }

            int[] arr = new int[n];

            for (int i = 0; i < n; i++) {
                arr[i] = arrayDeque.removeFirst();
            }

            long m;
            for (int i = 0; i < q; i++) {
                m = in.nextLong();

                if(m<=c){
                    out.println(map.get((int)m).a +"" ""+map.get((int)m).b);
                }
                else{
                    m-=c;
                    m = m%(n-1);
                    if(m==0){
                        m = n-1;
                    }
                    out.println(max+"" ""+arr[(int)m]);
                }


            }

        }
    }

    static int gcd(int a, int b)
    {
        if (a == 0)
            return b;
        return gcd(b % a, a);
    }

    static int lcm(int a, int b)
    {
        return (a / gcd(a, b)) * b;
    }

    static class answer implements Comparable<answer>{
        int a;
        int b;

        public answer(int a, int b) {
            this.a = a;
            this.b = b;
        }

        @Override
        public int compareTo(answer o) {
            return this.a - o.a;
        }
    }

    static class answer1 implements Comparable<answer1>{
        int a, b, c;

        public answer1(int a, int b, int c) {
            this.a = a;
            this.b = b;
            this.c = c;

        }

        @Override
        public int compareTo(answer1 o) {
            return this.a - o.a;
        }
    }

    static long gcd(long a, long b)
    {
        if (b == 0)
            return a;
        return gcd(b, a % b);
    }

    static void sort(long[] a) {
        ArrayList<Long> l=new ArrayList<>();
        for (long i:a) l.add(i);
        Collections.sort(l);
        for (int i=0; i<a.length; i++) a[i]=l.get(i);
    }

    static final Random random=new Random();

    static void shuffleSort(int[] a) {
        int n=a.length;
        for (int i=0; i<n; i++) {
            int oi=random.nextInt(n), temp=a[oi];
            a[oi]=a[i]; a[i]=temp;
        }
        Arrays.sort(a);
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
        public long nextLong(){
            return Long.parseLong(next());
        }
        public double nextDouble() {
            return Double.parseDouble(next());
        }

    }
}",3,3
"import java.util.*;
import java.io.*;
public class EdE {
	static long[] mods = {1000000007, 998244353, 1000000009};
	static long mod = mods[0];
	public static MyScanner sc;
    public static PrintWriter out;
    static ArrayList<Integer> primes;
	public static void main(String[] omkar) throws Exception{
		// TODO Auto-generated method stub
 		sc = new MyScanner();
 		out = new PrintWriter(System.out);
 		int t = sc.nextInt();
 		primes = new ArrayList<>();
 		prime(3165);
 		int[] freq = new int[10000001];
 		while(t--> 0){
 			int n = sc.nextInt();
 			int k = sc.nextInt();
 			int[] arr = readArrayInt(n);
 			for(int j = 0;j<n;j++){
 				arr[j] = factorize(arr[j]);
 			}
 			int[][] left = new int[n][k+1];
 			for(int m = 0;m<=k;m++){
 				int l = 0;
 				int count = 0;
 				for(int i = 0;i<n;i++){
 					if (freq[arr[i]] > 0){
 						count++;
 					}
 					freq[arr[i]]++;
 					while(count > m){
 						freq[arr[l]]--;
 						if (freq[arr[l]] > 0){
 							count--;
 						}
 						l++;
 					}
 					left[i][m] = l;
 				}
 				while(l < n){
 					freq[arr[l]]--;
 					l++;
 				}
 				
 			}
 			long[][] dp = new long[n][k+1];
 			for(int i=0;i<n;i++){
 				Arrays.fill(dp[i],  Integer.MAX_VALUE);
 			}
 			for(int i = 0;i<n;i++){
 				for(int j = 0;j<=k;j++){
 					for(int s = 0;s<=j;s++){
 						if (left[i][s] == 0){
 							dp[i][j] = 1;
 							continue;
 						}
 						dp[i][j] = Math.min(dp[i][j],  dp[left[i][s]-1][j-s]+1);

 					}
 				}
 				
 			}
 			out.println(dp[n-1][k]);
 			
 		}
	 		
 		out.close();
 	}
	static class MS{
//      TreeSet<Long> set;
      HashMap<Long, Integer> map;
      public MS() {
//          set = new TreeSet<Long>();
          map = new HashMap<Long, Integer>();
      }
      public void add(long x) {
          if(map.containsKey(x)){
              map.put(x, map.get(x)+1);
          }
          else{
              map.put(x, 1);
//              set.add(x);
          }
      }
      public void remove(long x) {
          if(!map.containsKey(x))
              return;
          if(map.get(x)==1){
              map.remove(x);
//              set.remove(x);
          }
          else 
              map.put(x, map.get(x)-1);
      }
//      public long getFirst() {
//          return set.first();
//      }
//      public long getLast() {
//          return set.last();
//      }
      public int size() {
          return map.keySet().size();
      }
      public void removeAll(int x) {
          map.remove(x);
      }
      public int getFreq(long x){
      	if (map.containsKey(x))
      		return map.get(x);
      	return 0;
      }
  }
	public static void prime(int n){
		int[] isPrime = new int[n+1];
		Arrays.fill(isPrime, 1);
		for(long i = 2;i<=n;i++){
			if (isPrime[(int)i] == 1){
				for(long j = i*i;j<=n;j+=i){
					isPrime[(int)j] = 0;
				}
			}
		}
		for(int j = 3;j<=n;j++){
			if (isPrime[j] == 1){
				primes.add(j);
			}
		}
	}
	public static int factorize(long n) { 
	 	
	 	long prod = 1;
        int count = 0; 
        while (n%2 == 0){
            n >>= 1; 
            count++; 
        } 
        if (count > 0 && count%2 == 1)
            prod *= 2L;
        for (long i : primes) { 
        	if (i*i > n)
        		break;
            count = 0; 
            while (n % i == 0) { 
                count++; 
                n = n / i; 
            } 
            if (count > 0 && count%2 == 1)
                prod *= i;
        }  
        if (n > 2)
        	prod *= n;
        return (int)prod;
    }
	public static void sort(int[] array){
		ArrayList<Integer> copy = new ArrayList<>();
		for (int i : array)
			copy.add(i);
		Collections.sort(copy);
		for(int i = 0;i<array.length;i++)
			array[i] = copy.get(i);
	}
	static String[] readArrayString(int n){
		String[] array = new String[n];
		for(int j =0 ;j<n;j++)
			array[j] = sc.next();
		return array;
	}
	static int[] readArrayInt(int n){
    	int[] array = new int[n];
    	for(int j = 0;j<n;j++)
    		array[j] = sc.nextInt();
    	return array;
    }
	static int[] readArrayInt1(int n){
		int[] array = new int[n+1];
		for(int j = 1;j<=n;j++){
			array[j] = sc.nextInt();
		}
		return array;
	}
	static long[] readArrayLong(int n){
		long[] array = new long[n];
		for(int j =0 ;j<n;j++)
			array[j] = sc.nextLong();
		return array;
	}
	static double[] readArrayDouble(int n){
		double[] array = new double[n];
		for(int j =0 ;j<n;j++)
			array[j] = sc.nextDouble();
		return array;
	}
	static int minIndex(int[] array){
		int minValue = Integer.MAX_VALUE;
		int minIndex = -1;
		for(int j = 0;j<array.length;j++){
			if (array[j] < minValue){
				minValue = array[j];
				minIndex = j;
			}
		}
		return minIndex;
	}
	static int minIndex(long[] array){
		long minValue = Long.MAX_VALUE;
		int minIndex = -1;
		for(int j = 0;j<array.length;j++){
			if (array[j] < minValue){
				minValue = array[j];
				minIndex = j;
			}
		}
		return minIndex;
	}
	static int minIndex(double[] array){
		double minValue = Double.MAX_VALUE;
		int minIndex = -1;
		for(int j = 0;j<array.length;j++){
			if (array[j] < minValue){
				minValue = array[j];
				minIndex = j;
			}
		}
		return minIndex;
	}
	static long power(long x, long y){
		if (y == 0)
			return 1;
		if (y%2 == 1)
			return (x*power(x, y-1))%mod;
		return power((x*x)%mod, y/2)%mod;
	}
	static void verdict(boolean a){
        out.println(a ? ""YES"" : ""NO"");
    }
    public static class MyScanner {
        BufferedReader br;
        StringTokenizer st;
        public MyScanner() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } 
                catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
        int nextInt() {
            return Integer.parseInt(next());
        }
        long nextLong() {
            return Long.parseLong(next());
        }
        double nextDouble() {
            return Double.parseDouble(next());
        }
        String nextLine() {
            String str = """";
            try{
                str = br.readLine();
            } 
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
        
    }	
}

//StringJoiner sj = new StringJoiner("" ""); 
//sj.add(strings)
//sj.toString() gives string of those stuff w spaces or whatever that sequence is",6,5
"import java.util.*;
import java.io.*;

public class Solve{
    public static void main(String[] args) throws Exception{
        Scanner sc=new Scanner(System.in);
        PrintWriter out =new PrintWriter(System.out);
        int size=(int)1e7+1;
        int[] pr=new int[size];
        for(int i=0;i<size;i++){
            pr[i]=i;
        }
        for(int i=2;i*i<size;i++){
          int val=i*i;
            for(int j=val;j<=size;j+=val){
                 pr[j]=j/val;
            }
        }
        int t=sc.nextInt();
        int[] dp=new int[size];
        Arrays.fill(dp,-1);
        while(t-->0){
            int n=sc.nextInt();
            int k=sc.nextInt();
            int[] ar=new int[n];
            for(int i=0;i<n;i++){
                int a=sc.nextInt();
                ar[i]=pr[a];
            }
            int[] ans=new int[k+1];
            int[] ind=new int[k+1];
            for(int i=0;i<n;i++){
                for(int h=k;h>=0;h--){
                    if(dp[ar[i]]>=ind[h]){
                        ans[h]++;
                        ind[h]=i;
                    }
                    if(h>0 && (ans[h-1]<ans[h] ||(ans[h-1]==ans[h] && ind[h-1]>ind[h])))
                    {
                        ans[h]=ans[h-1];
                        ind[h]=ind[h-1];
                    }
                }
                dp[ar[i]]=i;
            }
            out.println(ans[k]+1);
            for(int i=0;i<n;i++)dp[ar[i]]=-1;
        }
        out.close();
    }
}",6,6
"/**
 * author: derrick20
 * created: 3/19/21 11:57 PM
 */
import java.io.*;
import java.util.*;
import static java.lang.Math.*;

public class E2_SquareFreeDivision2 {
    static FastScanner sc = new FastScanner();
    static PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) {
//        generate();
        int MAX = (int) 1e7;
        int[] spf = new int[MAX + 1];
        for (int i = 2; i <= MAX; i++) {
            if (spf[i] == 0) {
                spf[i] = i;
                for (int j = i + i; j <= MAX; j += i) {
                    if (spf[j] == 0) {
                        spf[j] = i;
                    }
                }
            }
        }
        int[] freq = new int[MAX + 1];
        int T = sc.nextInt();
        while (T-->0) {
            int N = sc.nextInt();
            int K = sc.nextInt();
            int[] a = new int[N + 1];
            for (int i = 1; i <= N; i++) {
                a[i] = sc.nextInt();
                int canonical = 1;
                while (a[i] > 1) {
                    int factor = spf[a[i]];
                    int parity = 0;
                    while (a[i] % factor == 0) {
                        a[i] /= factor;
                        parity ^= 1;
                    }
                    if (parity == 1) {
                        canonical *= factor;
                    }
                }
                a[i] = canonical;
            }
            int[][] transition = new int[K + 1][N + 1];
//            HashMap<Integer, Integer> freq = new HashMap<>();
            for (int k = 0; k <= K; k++) {
                int l = N + 1;
                int duplicates = 0;
                for (int r = N; r >= 1; r--) {
                    while (l - 1 >= 1) {
                        int nextDuplicates = duplicates;
                        if (freq[a[l - 1]] >= 1) {
                            nextDuplicates++;
                        }
                        if (nextDuplicates <= k) {
                            duplicates = nextDuplicates;
                            freq[a[l - 1]]++;
                            l--;
                        } else {
                            break;
                        }
                    }
                    transition[k][r] = l;
                    if (--freq[a[r]] >= 1) {
                        duplicates--;
                    }
                }
            }
            int[][] dp = new int[K + 1][N + 1];
            int oo = (int) 1e9;
            for (int[] row : dp) {
                Arrays.fill(row, oo);
            }
            for (int k = 0; k <= K; k++) {
                dp[k][0] = 0;
            }
            for (int r = 1; r <= N; r++) {
                for (int k = 0; k <= K; k++) {
                    for (int delta = 0; delta <= k; delta++) {
                        dp[k][r] = min(dp[k][r], dp[k - delta][transition[delta][r] - 1] + 1);
                    }
                }
            }
            out.println(dp[K][N]);
        }
        out.close();
    }

    static class FastScanner {
        private int BS = 1 << 16;
        private char NC = (char) 0;
        private byte[] buf = new byte[BS];
        private int bId = 0, size = 0;
        private char c = NC;
        private double cnt = 1;
        private BufferedInputStream in;
    
        public FastScanner() {
            in = new BufferedInputStream(System.in, BS);
        }
    
        public FastScanner(String s) {
            try {
                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);
            } catch (Exception e) {
                in = new BufferedInputStream(System.in, BS);
            }
        }
    
        char getChar() {
            while (bId == size) {
                try {
                    size = in.read(buf);
                } catch (Exception e) {
                    return NC;
                }
                if (size == -1) return NC;
                bId = 0;
            }
            return (char) buf[bId++];
        }
    
        int nextInt() {
            return (int) nextLong();
        }
    
        long nextLong() {
            cnt = 1;
            boolean neg = false;
            if (c == NC) c = getChar();
            for (; (c < '0' || c > '9'); c = getChar()) {
                if (c == '-') neg = true;
            }
            long res = 0;
            for (; c >= '0' && c <= '9'; c = getChar()) {
                res = (res << 3) + (res << 1) + c - '0';
                cnt *= 10;
            }
            return neg ? -res : res;
        }
    
        double nextDouble() {
            boolean neg = false;
            if (c == NC) c = getChar();
            for (; (c < '0' || c > '9'); c = getChar()) {
                if (c == '-') neg = true;
            }
            double cur = nextLong();
            if (c != '.') {
                return neg ? -cur : cur;
            } else {
                double frac = nextLong() / cnt;
                return neg ? -cur - frac : cur + frac;
            }
        }
    
        String next() {
            StringBuilder res = new StringBuilder();
            while (c <= 32) c = getChar();
            while (c > 32) {
                res.append(c);
                c = getChar();
            }
            return res.toString();
        }
    
        String nextLine() {
            StringBuilder res = new StringBuilder();
            while (c <= 32) c = getChar();
            while (c != '\n') {
                res.append(c);
                c = getChar();
            }
            return res.toString();
        }
    
        boolean hasNext() {
            if (c > 32) return true;
            while (true) {
                c = getChar();
                if (c == NC) return false;
                else if (c > 32) return true;
            }
        }
    }
    
    static void ASSERT(boolean assertion, String message) {
        if (!assertion) throw new AssertionError(message);
    }
    
    static void ASSERT(boolean assertion) {
        if (!assertion) throw new AssertionError();
    }
}",6,5
"//stan hu tao
//join nct ridin by first year culture reps
import static java.lang.Math.max;
import static java.lang.Math.min;
import static java.lang.Math.abs;
import static java.lang.System.out;
import java.util.*;
import java.io.*;
import java.math.*;

public class x1497E
{
    static final int MAX = 10000000;
    public static void main(String hi[]) throws Exception
    {
        int[] prime = new int[MAX+1];
        for(int d=2; d <= MAX; d++)
            if(prime[d] == 0)
                for(int v=d; v <= MAX; v+=d)
                    if(prime[v] == 0)
                        prime[v] = d;
        FastScanner infile = new FastScanner();
        int T = infile.nextInt();
        StringBuilder sb = new StringBuilder();
        int[] freq = new int[MAX+1];
        int[] ts = new int[MAX+1];
        int time = 0;
        while(T-->0)
        {
            int N = infile.nextInt();
            int K = infile.nextInt();
            int[] arr = infile.nextInts(N);
            for(int i=0; i < N; i++)
            {
                int key = 1;
                while(arr[i] > 1)
                {
                    int p = prime[arr[i]];
                    int cnt = 0;
                    while(arr[i]%p == 0)
                    {
                        arr[i] /= p;
                        cnt ^= 1;
                    }
                    if(cnt == 1)
                        key *= p;
                }
                arr[i] = key;
            }
            int[][] right = new int[N][K+1];
            for(int k=0; k <= K; k++)
            {
                int dex = 0;
                int cnt = 0;
                for(int i=0; i < N; i++)
                {
                    while(dex < N && cnt <= k)
                    {
                        if(ts[arr[dex]] == time && freq[arr[dex]] >= 1 && cnt+1 > k)
                            break;
                        if(ts[arr[dex]] == time && freq[arr[dex]] >= 1)
                            cnt++;
                        if(ts[arr[dex]] < time)
                        {
                            ts[arr[dex]] = time;
                            freq[arr[dex]] = 0;
                        }
                        freq[arr[dex]]++;
                        dex++;
                    }
                    right[i][k] = dex;
                    if(freq[arr[i]] >= 2)
                        cnt--;
                    freq[arr[i]]--;
                }
                time++;
            }
            int[][] dp = new int[N+1][K+1];
            for(int i=1; i <= N; i++)
                Arrays.fill(dp[i], N);
            for(int i=0; i < N; i++)
                for(int a=0; a <= K; a++)
                {
                    dp[i+1][a] = min(dp[i+1][a], dp[i][a]+1);
                    for(int b=0; b <= K-a; b++)
                        dp[right[i][b]][a+b] = min(dp[right[i][b]][a+b], dp[i][a]+1);
                }
            int res = dp[N][0];
            for(int k=1; k <= K; k++)
                res = min(res, dp[N][k]);
            sb.append(res+""\n"");
        }
        System.out.print(sb);
    }
}
class FastScanner
{
    private int BS = 1 << 16;
    private char NC = (char) 0;
    private byte[] buf = new byte[BS];
    private int bId = 0, size = 0;
    private char c = NC;
    private double cnt = 1;
    private BufferedInputStream in;

    public FastScanner() {
        in = new BufferedInputStream(System.in, BS);
    }

    public FastScanner(String s) {
        try {
            in = new BufferedInputStream(new FileInputStream(new File(s)), BS);
        } catch (Exception e) {
            in = new BufferedInputStream(System.in, BS);
        }
    }

    private char getChar() {
        while (bId == size) {
            try {
                size = in.read(buf);
            } catch (Exception e) {
                return NC;
            }
            if (size == -1) return NC;
            bId = 0;
        }
        return (char) buf[bId++];
    }

    public int nextInt() {
        return (int) nextLong();
    }

    public int[] nextInts(int N) {
        int[] res = new int[N];
        for (int i = 0; i < N; i++) {
            res[i] = (int) nextLong();
        }
        return res;
    }

    public long[] nextLongs(int N) {
        long[] res = new long[N];
        for (int i = 0; i < N; i++) {
            res[i] = nextLong();
        }
        return res;
    }

    public long nextLong() {
        cnt = 1;
        boolean neg = false;
        if (c == NC) c = getChar();
        for (; (c < '0' || c > '9'); c = getChar()) {
            if (c == '-') neg = true;
        }
        long res = 0;
        for (; c >= '0' && c <= '9'; c = getChar()) {
            res = (res << 3) + (res << 1) + c - '0';
            cnt *= 10;
        }
        return neg ? -res : res;
    }

    public double nextDouble() {
        double cur = nextLong();
        return c != '.' ? cur : cur + nextLong() / cnt;
    }

    public double[] nextDoubles(int N) {
        double[] res = new double[N];
        for (int i = 0; i < N; i++) {
            res[i] = nextDouble();
        }
        return res;
    }

    public String next() {
        StringBuilder res = new StringBuilder();
        while (c <= 32) c = getChar();
        while (c > 32) {
            res.append(c);
            c = getChar();
        }
        return res.toString();
    }

    public String nextLine() {
        StringBuilder res = new StringBuilder();
        while (c <= 32) c = getChar();
        while (c != '\n') {
            res.append(c);
            c = getChar();
        }
        return res.toString();
    }

    public boolean hasNext() {
        if (c > 32) return true;
        while (true) {
            c = getChar();
            if (c == NC) return false;
            else if (c > 32) return true;
        }
    }
}",6,5
"/**
 * author: derrick20
 * created: 3/20/21 7:13 PM
 */
import java.io.*;
import java.util.*;
import static java.lang.Math.*;

public class E2_SquareFreeFast {
    static FastScanner sc = new FastScanner();
    static PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) {
//        generate();
        int T = sc.nextInt();
        int MAX = (int) 1e7;
        int[] canonical = new int[MAX + 1];
        canonical[1] = 1;
        for (int factor = 2; factor <= MAX; factor++) {
            if (canonical[factor] == 0) {
                for (int mult = factor; mult <= MAX; mult += factor) {
                    int prev = canonical[mult / factor];
                    if (prev % factor == 0) {
                        canonical[mult] = prev / factor;
                    } else {
                        canonical[mult] = prev * factor;
                    }
                }
            }
        }
        int[] last = new int[MAX + 1];
        while (T-->0) {
            int N = sc.nextInt();
            int K = sc.nextInt();
            int[] a = new int[N + 1];
            int[][] dp = new int[2][K + 1];
            int[][] start = new int[2][K + 1];
            int ptr = 0;
            for (int i = 1; i <= N; i++) {
                int nxt = 1 ^ ptr;
                a[i] = canonical[sc.nextInt()];
                for (int k = 0; k <= K; k++) {
                    if (start[ptr][k] > last[a[i]]) {
                        // extend it for free (unique)
                        dp[nxt][k] = dp[ptr][k];
                        start[nxt][k] = start[ptr][k];
                    } else {
                        // start anew
                        dp[nxt][k] = dp[ptr][k] + 1;
                        start[nxt][k] = i;
                    }
                    // Use a change (only if existing segment)
                    if (i > 1 && k > 0 && start[ptr][k - 1] <= last[a[i]]) {
                        // if this cost beats the old cost, or if it has a later start point, it's better.
                        if (dp[ptr][k - 1] < dp[nxt][k] || (dp[ptr][k - 1] == dp[nxt][k] && start[ptr][k - 1] > start[nxt][k])) {
                            dp[nxt][k] = dp[ptr][k - 1];
                            start[nxt][k] = start[ptr][k - 1];
                        }
                    }
                }
//                System.out.println(Arrays.toString(start[nxt]));
//                System.out.println(Arrays.toString(dp[nxt]));
                last[a[i]] = i;
                ptr = nxt;
            }
            for (int v : a) {
                last[v] = 0;
            }
            // always allowed to waste initial changes by starting offset, so mono decr
            out.println(dp[ptr][K]);
        }
        out.close();
    }

    static class FastScanner {
        private int BS = 1 << 16;
        private char NC = (char) 0;
        private byte[] buf = new byte[BS];
        private int bId = 0, size = 0;
        private char c = NC;
        private double cnt = 1;
        private BufferedInputStream in;

        public FastScanner() {
            in = new BufferedInputStream(System.in, BS);
        }

        public FastScanner(String s) {
            try {
                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);
            } catch (Exception e) {
                in = new BufferedInputStream(System.in, BS);
            }
        }

        char getChar() {
            while (bId == size) {
                try {
                    size = in.read(buf);
                } catch (Exception e) {
                    return NC;
                }
                if (size == -1) return NC;
                bId = 0;
            }
            return (char) buf[bId++];
        }

        int nextInt() {
            return (int) nextLong();
        }

        long nextLong() {
            cnt = 1;
            boolean neg = false;
            if (c == NC) c = getChar();
            for (; (c < '0' || c > '9'); c = getChar()) {
                if (c == '-') neg = true;
            }
            long res = 0;
            for (; c >= '0' && c <= '9'; c = getChar()) {
                res = (res << 3) + (res << 1) + c - '0';
                cnt *= 10;
            }
            return neg ? -res : res;
        }

        double nextDouble() {
            boolean neg = false;
            if (c == NC) c = getChar();
            for (; (c < '0' || c > '9'); c = getChar()) {
                if (c == '-') neg = true;
            }
            double cur = nextLong();
            if (c != '.') {
                return neg ? -cur : cur;
            } else {
                double frac = nextLong() / cnt;
                return neg ? -cur - frac : cur + frac;
            }
        }

        String next() {
            StringBuilder res = new StringBuilder();
            while (c <= 32) c = getChar();
            while (c > 32) {
                res.append(c);
                c = getChar();
            }
            return res.toString();
        }

        String nextLine() {
            StringBuilder res = new StringBuilder();
            while (c <= 32) c = getChar();
            while (c != '\n') {
                res.append(c);
                c = getChar();
            }
            return res.toString();
        }

        boolean hasNext() {
            if (c > 32) return true;
            while (true) {
                c = getChar();
                if (c == NC) return false;
                else if (c > 32) return true;
            }
        }
    }

    static void ASSERT(boolean assertion, String message) {
        if (!assertion) throw new AssertionError(message);
    }

    static void ASSERT(boolean assertion) {
        if (!assertion) throw new AssertionError();
    }
}",6,6
"import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.stream.IntStream;
import java.util.Arrays;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.TreeSet;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        SquareFreeDivisionHardVersion solver = new SquareFreeDivisionHardVersion();
        solver.solve(1, in, out);
        out.close();
    }

    static class SquareFreeDivisionHardVersion {
        static final int MAX = 10000001;

        public void solve(int testNumber, InputReader in, OutputWriter out) {
            int t = in.nextInt();
            int[] d = PrimesAndDivisors.generateDivisors(MAX);
            int[] reduced = new int[MAX];
            for (int i = 1; i < MAX; i++) {
                int val = i;
                reduced[i] = 1;
                while (val != 1) {
                    int prime = d[val], exponent = 0;
                    while (val % prime == 0) {
                        val /= prime;
                        exponent ^= 1;
                    }
                    if (exponent > 0) reduced[i] *= prime;
                }
            }
            int counter = 0;
            int[] seen = new int[MAX];
            for (int jjjj = 0; jjjj < t; jjjj++) {
                int n = in.nextInt(), k = in.nextInt();

                int[] a = in.readIntArray(n);
                for (int x : a) seen[reduced[x]] = -1;
                int[][] dp = new int[n + 1][k + 1];
                TreeSet<Integer> ts = new TreeSet<>();
                int num = 0;
                for (int i = 0; i < n; i++) {
                    int R = reduced[a[i]];
                    if (seen[R] != -1) {
                        ts.add(-seen[R]);
                        if (ts.size() > k + 1) ts.remove(ts.last());
                        num++;
                    }
                    Arrays.fill(dp[i], n + 1);
                    for (int j = num; j <= k; j++) dp[i][j] = 1;
                    seen[R] = i;
                    int u = 0;
                    for (int r : ts) {
                        for (int j = u; j <= k; j++) dp[i][j] = Integer.min(dp[i][j], dp[-r][j - u] + 1);
                        u++;
                    }
//                System.out.println(i + "" ""  + Arrays.toString(dp[i]));
//                System.out.println(""Treeset : "" + ts);
                }
                out.println(dp[n - 1][k]);
            }
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int[] readIntArray(int size) {
            int[] array = new int[size];
            for (int i = 0; i < size; i++) {
                array[i] = readInt();
            }
            return array;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) c = read();
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class PrimesAndDivisors {
        public static int[] generateDivisors(int n) {
            int[] divisors = IntStream.range(0, n + 1).toArray();
            for (int i = 2; i * i <= n; i++)
                if (divisors[i] == i)
                    for (int j = i * i; j <= n; j += i) divisors[j] = i;
            return divisors;
        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void println(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
            writer.print('\n');
        }

        public void close() {
            writer.close();
        }

    }
}

",6,5
"import java.io.*;
import java.util.*;

public class Main {

    static final int primeCount = 452;
    static final int[] prime = new int[primeCount];

    static void build_prime() {
        boolean[] notPrime = new boolean[3200];
        for (int i = 2; i < 3200; i++) {
            if (notPrime[i]) continue;
            for (int j = i * i; j < 3200; j += i) {
                notPrime[j] = true;
            }
        }

        int count = 0;
        for (int i = 2; i < 3200; i++) {
            if (notPrime[i]) continue;

            prime[count++] = i;
        }
    }

    private static void run(Reader in, PrintWriter out) throws IOException {
        int n = in.nextInt();
        int m = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = getReal(in.nextInt());
        }

        int[] pre = new int[n];
        for (int i = 0; i < n; i++) pre[i] = -1;

        TreeMap<Integer, Integer> exist = new TreeMap<>();
        for (int i = 0; i < n; i++) {
            Integer result = exist.get(a[i]);
            if (result != null) {
                pre[i] = result;
            }
            exist.put(a[i], i);
        }

        int[][] left = new int[m + 1][n];
        for (int i = 0; i <= m; i++) {
            int start = 0;
            PriorityQueue<Integer> inSame = new PriorityQueue<>();
            for (int j = 0; j < n; j++) {
                if (pre[j] >= start) {
                    inSame.add(pre[j]);

                    if (inSame.size() > i) {
                        start = inSame.poll() + 1;
                    }
                }
                left[i][j] = start;
            }
        }

        int[][] dp = new int[n][m + 1];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= m; j++) {
                if (j == 0) dp[i][0] = Integer.MAX_VALUE;
                else dp[i][j] = dp[i][j - 1];

                for (int k = 0; k <= j; k++) {
                    if (left[k][i] == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = Math.min(dp[i][j], dp[left[k][i] - 1][j - k] + 1);
                    }
                }
            }
        }

        out.println(dp[n - 1][m]);
    }

    static int getReal(int x) {
        int result = 1;
        for (int i = 0; i < primeCount; i++) {
            if (x % prime[i] == 0) {
                int count = 0;
                while (x % prime[i] == 0) {
                    count++;
                    x /= prime[i];
                }
                if (count % 2 == 1) {
                    result *= prime[i];
                }
            }
        }
        result *= x;
        return result;
    }

    public static void main(String[] args) throws IOException {
        Reader in = new Reader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));

        build_prime();
        int t = in.nextInt();
        for (int i = 0; i < t; i++) {
            run(in, out);
        }

        out.flush();
        in.close();
        out.close();
    }

    static class Reader {
        BufferedReader reader;
        StringTokenizer st;

        Reader(InputStreamReader stream) {
            reader = new BufferedReader(stream, 32768);
            st = null;
        }

        void close() throws IOException {
            reader.close();
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        String nextLine() throws IOException {
            return reader.readLine();
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

    }
}",6,5
"import java.util.*;
import java.io.*;
 

 public class SolutionC{
       public static void main(String[] args) throws Exception{
               Scanner sc=new Scanner(System.in);
        PrintWriter out=new PrintWriter(System.out);
       int t=sc.nextInt();
       int[] arr=new int[10000002];
       for(int i=0;i<arr.length;i++){
           arr[i]=i;
       }
       for(int i=2;i*i<arr.length;i++){
           int b=i*i;
          for(int j=b;j<arr.length;j+=b){
              arr[j]=j/b;
          }
       }
      int[] pp = new int[10000001]; Arrays.fill(pp, -1);
       while(t-->0){
           
        int n=sc.nextInt();
        int k=sc.nextInt();
        int[] aa=new int[n];
         for(int i=0;i<n;i++){
             int a=sc.nextInt();
             aa[i]=arr[a];
         }
        
         int[] mp = new int[k + 1];
			int[] ip = new int[k + 1];
			for (int i = 0; i < n; i++) {
				int a = aa[i];
				for (int h = k; h >= 0; h--) {
					if (pp[a] >= ip[h]) {
						mp[h]++;
						ip[h] = i;
					}
					if (h > 0 && (mp[h - 1] < mp[h] || mp[h - 1] == mp[h] && ip[h - 1] > ip[h])) {
						mp[h] = mp[h - 1];
						ip[h] = ip[h - 1];
					}
				}
				pp[a] = i;
			}
         
       
        out.println(mp[k]+1);
        
       for (int i = 0; i < n; i++) {
				pp[aa[i]] = -1;
			}
        
       }
           
           out.close();
}

}",6,6
"import java.io.*;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.Queue;

public class E3 {
	InputStream is;
	FastWriter out;
	String INPUT = """";
	
	void solve()
	{
		for(int T = ni();T > 0;T--)go();
	}

	int[] lpf = enumLowestPrimeFactors(10000000);

	void go()
	{
		int n = ni(), K = ni();
		int[] a = na(n);
		for(int i = 0;i < n;i++){
			a[i] = factorFast(a[i], lpf);
		}
		a = shrink(a);

		int[][] dp = new int[K+1][n+1];
		for(int i = 0;i <= K;i++){
			Arrays.fill(dp[i], 999999999);
		}
		for(int i = 0;i <= K;i++)dp[i][0] = 0;

		int[] prev = makePrev(a, n+1);

		int[] imos = new int[n+5];
		int[] pp = new int[K+1];
		int[] vs = new int[K+1];
		for(int i = 0;i < n;i++){
			int p = prev[i];
			imos[p+1]--;

			for(int j = 0;j <= K;j++){
				vs[j]++;
				if(pp[j] >= p+1){
					vs[j]--;
				}
				while(vs[j] > j){
					pp[j]++;
					vs[j] += imos[pp[j]];
				}
				for(int k = 0;k+j <= K;k++){
					dp[k+j][i+1] = Math.min(dp[k+j][i+1], dp[k][pp[j]] + 1);
				}
			}
		}
		out.println(dp[K][n]);
	}

	public static int[] shrink(int[] a) {
		int n = a.length;
		long[] b = new long[n];
		for (int i = 0; i < n; i++) b[i] = (long) a[i] << 32 | i;
		Arrays.sort(b);
		int[] ret = new int[n];
		int p = 0;
		for (int i = 0; i < n; i++) {
			if (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0) p++;
			ret[(int) b[i]] = p;
		}
		return ret;
	}


	public static int[] makePrev(int[] a, int sup)
	{
		int n = a.length;
		int[] mnext = new int[sup];
		Arrays.fill(mnext, -1);
		int[] next = new int[n];
		for(int i = 0;i < n;i++){
			next[i] = mnext[a[i]];
			mnext[a[i]] = i;
		}
		return next;
	}

	public static int factorFast(int n, int[] lpf)
	{
		int ret = 1;
		int e = 0;
		int last = -1;
		while(lpf[n] > 0) {
			int p = lpf[n];
			if (last != p) {
				if (last > 0 && e % 2 == 1) {
					ret = ret * last;
				}

				last = p;
				e = 1;
			} else {
				e++;
			}
			n /= p;
		}

		if(last > 0 && e % 2 == 1){
			ret *= last;
		}
		return ret;
	}


	public static int[] enumLowestPrimeFactors(int n)
	{
		int tot = 0;
		int[] lpf = new int[n+1];
		int u = n+32;
		double lu = Math.log(u);
		int[] primes = new int[(int)(u/lu+u/lu/lu*1.5)];
		for(int i = 2;i <= n;i++)lpf[i] = i;
		for(int p = 2;p <= n;p++){
			if(lpf[p] == p)primes[tot++] = p;
			int tmp;
			for(int i = 0;i < tot && primes[i] <= lpf[p] && (tmp = primes[i]*p) <= n;i++){
				lpf[tmp] = primes[i];
			}
		}
		return lpf;
	}


	void run() throws Exception
	{
		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new FastWriter(System.out);
		
		long s = System.currentTimeMillis();
		solve();
		out.flush();
		tr(System.currentTimeMillis()-s+""ms"");
	}
	
	public static void main(String[] args) throws Exception { new E3().run(); }
	
	private byte[] inbuf = new byte[1024];
	public int lenbuf = 0, ptrbuf = 0;
	
	private int readByte()
	{
		if(lenbuf == -1)throw new InputMismatchException();
		if(ptrbuf >= lenbuf){
			ptrbuf = 0;
			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
			if(lenbuf <= 0)return -1;
		}
		return inbuf[ptrbuf++];
	}
	
	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }
	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }
	
	private double nd() { return Double.parseDouble(ns()); }
	private char nc() { return (char)skip(); }
	
	private String ns()
	{
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}
	
	private char[] ns(int n)
	{
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while(p < n && !(isSpaceChar(b))){
			buf[p++] = (char)b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}

	private int[] na(int n)
	{
		int[] a = new int[n];
		for(int i = 0;i < n;i++)a[i] = ni();
		return a;
	}

	private long[] nal(int n)
	{
		long[] a = new long[n];
		for(int i = 0;i < n;i++)a[i] = nl();
		return a;
	}

	private char[][] nm(int n, int m) {
		char[][] map = new char[n][];
		for(int i = 0;i < n;i++)map[i] = ns(m);
		return map;
	}

	private int[][] nmi(int n, int m) {
		int[][] map = new int[n][];
		for(int i = 0;i < n;i++)map[i] = na(m);
		return map;
	}

	private int ni() { return (int)nl(); }

	private long nl()
	{
		long num = 0;
		int b;
		boolean minus = false;
		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
		if(b == '-'){
			minus = true;
			b = readByte();
		}

		while(true){
			if(b >= '0' && b <= '9'){
				num = num * 10 + (b - '0');
			}else{
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

	public static class FastWriter
	{
		private static final int BUF_SIZE = 1<<13;
		private final byte[] buf = new byte[BUF_SIZE];
		private final OutputStream out;
		private int ptr = 0;

		private FastWriter(){out = null;}

		public FastWriter(OutputStream os)
		{
			this.out = os;
		}

		public FastWriter(String path)
		{
			try {
				this.out = new FileOutputStream(path);
			} catch (FileNotFoundException e) {
				throw new RuntimeException(""FastWriter"");
			}
		}

		public FastWriter write(byte b)
		{
			buf[ptr++] = b;
			if(ptr == BUF_SIZE)innerflush();
			return this;
		}

		public FastWriter write(char c)
		{
			return write((byte)c);
		}

		public FastWriter write(char[] s)
		{
			for(char c : s){
				buf[ptr++] = (byte)c;
				if(ptr == BUF_SIZE)innerflush();
			}
			return this;
		}

		public FastWriter write(String s)
		{
			s.chars().forEach(c -> {
				buf[ptr++] = (byte)c;
				if(ptr == BUF_SIZE)innerflush();
			});
			return this;
		}

		private static int countDigits(int l) {
			if (l >= 1000000000) return 10;
			if (l >= 100000000) return 9;
			if (l >= 10000000) return 8;
			if (l >= 1000000) return 7;
			if (l >= 100000) return 6;
			if (l >= 10000) return 5;
			if (l >= 1000) return 4;
			if (l >= 100) return 3;
			if (l >= 10) return 2;
			return 1;
		}

		public FastWriter write(int x)
		{
			if(x == Integer.MIN_VALUE){
				return write((long)x);
			}
			if(ptr + 12 >= BUF_SIZE)innerflush();
			if(x < 0){
				write((byte)'-');
				x = -x;
			}
			int d = countDigits(x);
			for(int i = ptr + d - 1;i >= ptr;i--){
				buf[i] = (byte)('0'+x%10);
				x /= 10;
			}
			ptr += d;
			return this;
		}

		private static int countDigits(long l) {
			if (l >= 1000000000000000000L) return 19;
			if (l >= 100000000000000000L) return 18;
			if (l >= 10000000000000000L) return 17;
			if (l >= 1000000000000000L) return 16;
			if (l >= 100000000000000L) return 15;
			if (l >= 10000000000000L) return 14;
			if (l >= 1000000000000L) return 13;
			if (l >= 100000000000L) return 12;
			if (l >= 10000000000L) return 11;
			if (l >= 1000000000L) return 10;
			if (l >= 100000000L) return 9;
			if (l >= 10000000L) return 8;
			if (l >= 1000000L) return 7;
			if (l >= 100000L) return 6;
			if (l >= 10000L) return 5;
			if (l >= 1000L) return 4;
			if (l >= 100L) return 3;
			if (l >= 10L) return 2;
			return 1;
		}

		public FastWriter write(long x)
		{
			if(x == Long.MIN_VALUE){
				return write("""" + x);
			}
			if(ptr + 21 >= BUF_SIZE)innerflush();
			if(x < 0){
				write((byte)'-');
				x = -x;
			}
			int d = countDigits(x);
			for(int i = ptr + d - 1;i >= ptr;i--){
				buf[i] = (byte)('0'+x%10);
				x /= 10;
			}
			ptr += d;
			return this;
		}

		public FastWriter write(double x, int precision)
		{
			if(x < 0){
				write('-');
				x = -x;
			}
			x += Math.pow(10, -precision)/2;
			//		if(x < 0){ x = 0; }
			write((long)x).write(""."");
			x -= (long)x;
			for(int i = 0;i < precision;i++){
				x *= 10;
				write((char)('0'+(int)x));
				x -= (int)x;
			}
			return this;
		}

		public FastWriter writeln(char c){
			return write(c).writeln();
		}

		public FastWriter writeln(int x){
			return write(x).writeln();
		}

		public FastWriter writeln(long x){
			return write(x).writeln();
		}

		public FastWriter writeln(double x, int precision){
			return write(x, precision).writeln();
		}

		public FastWriter write(int... xs)
		{
			boolean first = true;
			for(int x : xs) {
				if (!first) write(' ');
				first = false;
				write(x);
			}
			return this;
		}

		public FastWriter write(long... xs)
		{
			boolean first = true;
			for(long x : xs) {
				if (!first) write(' ');
				first = false;
				write(x);
			}
			return this;
		}

		public FastWriter writeln()
		{
			return write((byte)'\n');
		}

		public FastWriter writeln(int... xs)
		{
			return write(xs).writeln();
		}

		public FastWriter writeln(long... xs)
		{
			return write(xs).writeln();
		}

		public FastWriter writeln(char[] line)
		{
			return write(line).writeln();
		}

		public FastWriter writeln(char[]... map)
		{
			for(char[] line : map)write(line).writeln();
			return this;
		}

		public FastWriter writeln(String s)
		{
			return write(s).writeln();
		}

		private void innerflush()
		{
			try {
				out.write(buf, 0, ptr);
				ptr = 0;
			} catch (IOException e) {
				throw new RuntimeException(""innerflush"");
			}
		}

		public void flush()
		{
			innerflush();
			try {
				out.flush();
			} catch (IOException e) {
				throw new RuntimeException(""flush"");
			}
		}

		public FastWriter print(byte b) { return write(b); }
		public FastWriter print(char c) { return write(c); }
		public FastWriter print(char[] s) { return write(s); }
		public FastWriter print(String s) { return write(s); }
		public FastWriter print(int x) { return write(x); }
		public FastWriter print(long x) { return write(x); }
		public FastWriter print(double x, int precision) { return write(x, precision); }
		public FastWriter println(char c){ return writeln(c); }
		public FastWriter println(int x){ return writeln(x); }
		public FastWriter println(long x){ return writeln(x); }
		public FastWriter println(double x, int precision){ return writeln(x, precision); }
		public FastWriter print(int... xs) { return write(xs); }
		public FastWriter print(long... xs) { return write(xs); }
		public FastWriter println(int... xs) { return writeln(xs); }
		public FastWriter println(long... xs) { return writeln(xs); }
		public FastWriter println(char[] line) { return writeln(line); }
		public FastWriter println(char[]... map) { return writeln(map); }
		public FastWriter println(String s) { return writeln(s); }
		public FastWriter println() { return writeln(); }
	}

	public void trnz(int... o)
	{
		for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");
		System.out.println();
	}

	// print ids which are 1
	public void trt(long... o)
	{
		Queue<Integer> stands = new ArrayDeque<>();
		for(int i = 0;i < o.length;i++){
			for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));
		}
		System.out.println(stands);
	}

	public void tf(boolean... r)
	{
		for(boolean x : r)System.out.print(x?'#':'.');
		System.out.println();
	}

	public void tf(boolean[]... b)
	{
		for(boolean[] r : b) {
			for(boolean x : r)System.out.print(x?'#':'.');
			System.out.println();
		}
		System.out.println();
	}

	public void tf(long[]... b)
	{
		if(INPUT.length() != 0) {
			for (long[] r : b) {
				for (long x : r) {
					for (int i = 0; i < 64; i++) {
						System.out.print(x << ~i < 0 ? '#' : '.');
					}
				}
				System.out.println();
			}
			System.out.println();
		}
	}

	public void tf(long... b)
	{
		if(INPUT.length() != 0) {
			for (long x : b) {
				for (int i = 0; i < 64; i++) {
					System.out.print(x << ~i < 0 ? '#' : '.');
				}
			}
			System.out.println();
		}
	}

	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;
	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }
}
",6,5
"import java.util.*;
import java.io.*;
import java.math.*;
import java.text.*;

public class Main {
    static PrintWriter out;
    static Reader in;
    public static void main(String[] args) throws IOException {
        input_output();
        Main solver = new Main();
        solver.solve();
        out.close(); 
        out.flush(); 
    }

    static long INF = (long)1e18;
    static int MAXN = (int)1e7+5;
    static int mod = 998_244_353;
    static int n, m, q, t;
    static double pi = Math.PI;

    void solve() throws IOException{
    	t = in.nextInt();

    	int[] div = new int[MAXN];
    	Arrays.fill(div, 1);
    	for (int i = 2; i < MAXN; i++) {
    		if (div[i] == 1) {
    			for (int j = i; j < MAXN; j+=i) {
    				div[j] = i;
    			}
    		}
    	}

    	while (t --> 0) {
    		n = in.nextInt();
			int k = in.nextInt();

			int[] arr = new int[n+1];
			for (int i = 1; i <= n; i++) {
				arr[i] = in.nextInt();
				int tmp = arr[i], newn = 1;

				while (div[arr[i]] != 1) {
					int elm = div[arr[i]],
						cnt = 0;
					while (div[arr[i]] == elm) {
						cnt++;
						arr[i] /= elm;
					}
					if (cnt%2 == 1) newn *= elm;
				}
				newn *= arr[i];
				arr[i] = newn;
			}

			int[] close = new int[n+1];
			List<Node> list = new ArrayList<>();
			for (int i = 1; i <= n; i++) list.add(new Node(arr[i], i));
			Collections.sort(list);

			for (int i = 0; i < n; i++) {
				if (i == n-1 || list.get(i+1).val != list.get(i).val) {
					close[list.get(i).idx] = -1;
				} else {
					close[list.get(i).idx] = list.get(i+1).idx;
				}
			}

			int[][] next = new int[n+1][k+1];
			List<Integer> upd = new ArrayList<>();
			List<Integer> nupd = new ArrayList<>();
			for (int i = 0; i <= k; i++) next[n][i] = n;
			for (int i = n-1; i >= 1; i--) {
				nupd.clear();
				if (close[i] == -1) {
					for (int j = 0; j <= k; j++) next[i][j] = next[i+1][j];
				} else {
					int tmp = close[i]-1, cnt = 0;
					if (upd.size() == 0 || tmp < upd.get(0)) {
						nupd.add(tmp);
						tmp = -1;
					}
					for (int j = 0; j < upd.size(); j++) {
						if (nupd.size() < k+1 && tmp != -1 && tmp < upd.get(j)) {
							nupd.add(tmp);
							tmp = -1;
						}
						if (nupd.size() < k+1) nupd.add(upd.get(j));
					}
					if (tmp != -1 && nupd.size() < k+1) nupd.add(tmp);

					for (int j = 0; j < nupd.size(); j++) 
						next[i][j] = nupd.get(j);
					for (int j = nupd.size(); j <= k; j++)
						next[i][j] = n;

					upd.clear();
					for (int j = 0; j < nupd.size(); j++) upd.add(nupd.get(j));
				}

			}
			
			int[][] dp = new int[n+1][k+1];
    		for (int i = 1; i <= n; i++)
    			for (int j = 0; j <= k; j++)
    				dp[i][j] = n;
    		for (int i = 0; i < n; i++) {
    			for (int cur = 0; cur <= k; cur++) {
    				for (int ncur = cur; ncur <= k; ncur++) {
    					dp[next[i+1][ncur-cur]][ncur] = Math.min(dp[next[i+1][ncur-cur]][ncur],
    															 dp[i][cur]+1);
    				}
    			}
    		}

    		int ans = n;
    		for (int i = 0; i <= k; i++) ans = Math.min(ans, dp[n][i]);
    		out.println(ans);
    	}
   	}

    //<>

    static class Node implements Comparable<Node> {
    	int val, idx;

    	Node (int val, int idx) {
    		this.val = val;
    		this.idx = idx;
    	}

    	public int compareTo(Node o) {
    		if (this.val != o.val) return this.val - o.val;
    		return this.idx - o.idx;
    	}
    }

    static class Reader {
 
        private InputStream mIs;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
    
        public Reader() {
            this(System.in);
        }
    
        public Reader(InputStream is) {
            mIs = is;
        }
    
        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
    
        }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = mIs.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }
    
        public String nextLine() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isEndOfLine(c));
            return res.toString();
        }
    
        public String next() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            StringBuilder res = new StringBuilder();
            do {
                res.appendCodePoint(c);
                c = read();
            } while (!isSpaceChar(c));
            return res.toString();
        }
    
        double nextDouble()
        {
            return Double.parseDouble(next());
        }
    
        public long nextLong() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            long res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
    
        public int nextInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }
    
        public boolean isSpaceChar(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }
    
        public boolean isEndOfLine(int c) {
            return c == '\n' || c == '\r' || c == -1;
        }
 
    }
    static void input_output() throws IOException {
        File f = new File(""in.txt"");
        if(f.exists() && !f.isDirectory()) { 
            in = new Reader(new FileInputStream(""in.txt""));
        } else in = new Reader();
        f = new File(""out.txt"");
        if(f.exists() && !f.isDirectory()) {
            out = new PrintWriter(new File(""out.txt""));
        } else out = new PrintWriter(System.out);
    }
}",6,5
"import java.io.*;
import java.util.*;
 
import java.math.*;
import java.awt.Point;
 
public class CFTemplate {
    static final long MOD = 1000000007L;
    //static final long MOD2 = 1000000009L;
    //static final long MOD = 998244353L;
    //static final long INF = 500000000000L;
    static final int INF = 1100000000;
    static final int NINF = -100000;
    static FastScanner sc;
    static PrintWriter pw;
    static final int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};

    public static void main(String[] args) {
        sc = new FastScanner();
        pw = new PrintWriter(System.out);
        
        ArrayList<Integer> primes = new ArrayList<Integer>();
        for (int i = 2; i <= 3200; i++) {
            boolean p = true;
            for (int j = 2; j*j <= i; j++) {
                if (i%j==0) {
                    p = false;
                    break;
                }
            }
            if (p) primes.add(i);
        }
        int Q = sc.ni();
        for (int q = 0; q < Q; q++) {
            int N = sc.ni();
            int K = sc.ni();
            int[] nums = new int[N+1];
            for (int i = 1; i <= N; i++) nums[i] = sc.ni();
            for (int i = 1; i <= N; i++) {
                for (int p: primes) {
                    int c = 0;
                    while (nums[i] % p == 0) {
                        nums[i] /= p;
                        c++;
                    }
                    if (c%2==1) nums[i] *= p;
                }
            }

            TreeSet<Integer> ts = new TreeSet<Integer>();
            HashMap<Integer,Integer> last = new HashMap<Integer,Integer>();

            int[][] dp = new int[N+1][K+1];
            for (int i = 1; i <= N; i++) {
                if (last.containsKey(nums[i])) {
                    ts.add(last.get(nums[i]));
                }
                last.put(nums[i],i);
                int[] inds = new int[K+1];
                int ind = 0;
                for (int x: ts.descendingSet()) {
                    inds[ind] = x;
                    if (ind==K) break;
                    ind++;
                }
                for (int j = 0; j <= K; j++) {
                    dp[i][j] = INF;
                    if (j > 0) dp[i][j] = dp[i][j-1];
                    for (int k = 0; k <= j; k++) {
                        dp[i][j] = Math.min(dp[i][j],dp[inds[k]][j-k]+1);
                    }
                }
            }
            pw.println(dp[N][K]);
        }
        pw.close();
    }

    public static void sort(int[] arr) {
        Random rgen = new Random();
        for (int i = 0; i < arr.length; i++) {
            int r = rgen.nextInt(arr.length);
            int temp = arr[i];
            arr[i] = arr[r];
            arr[r] = temp;
        }
        Arrays.sort(arr);
    }

    public static void sort(long[] arr) {
        Random rgen = new Random();
        for (int i = 0; i < arr.length; i++) {
            int r = rgen.nextInt(arr.length);
            long temp = arr[i];
            arr[i] = arr[r];
            arr[r] = temp;
        }
        Arrays.sort(arr);
    }

    //Sort an array (immune to quicksort TLE)
    public static void sort(int[][] arr) {
        Random rgen = new Random();
        for (int i = 0; i < arr.length; i++) {
            int r = rgen.nextInt(arr.length);
            int[] temp = arr[i];
            arr[i] = arr[r];
            arr[r] = temp;
        }
        Arrays.sort(arr, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                return a[1]-b[1];
                //Ascending order.
            }
        });
    }
    
    public static void sort(long[][] arr) {
        Random rgen = new Random();
        for (int i = 0; i < arr.length; i++) {
            int r = rgen.nextInt(arr.length);
            long[] temp = arr[i];
            arr[i] = arr[r];
            arr[r] = temp;
        }
        Arrays.sort(arr, new Comparator<long[]>() {
            @Override
            public int compare(long[] a, long[] b) {
                if (a[0] > b[0])
                    return 1;
                else if (a[0] < b[0])
                    return -1;
                else
                    return 0;
                //Ascending order.
            }
        });
    }

    static class FastScanner {
        BufferedReader br;
        StringTokenizer st;
 
        public FastScanner() {
            br = new BufferedReader(new InputStreamReader(System.in), 32768);
            st = null;
        }
 
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
 
        int ni() {
            return Integer.parseInt(next());
        }

        int[][] graph(int N, int[][] edges) {
            int[][] graph = new int[N][];
            int[] sz = new int[N];
            for (int[] e: edges) {
                sz[e[0]] += 1;
                sz[e[1]] += 1;
            }
            for (int i = 0; i < N; i++) {
                graph[i] = new int[sz[i]];
            }
            int[] cur = new int[N];
            for (int[] e: edges) {
                graph[e[0]][cur[e[0]]] = e[1];
                graph[e[1]][cur[e[1]]] = e[0];
                cur[e[0]] += 1;
                cur[e[1]] += 1;
            }
            return graph;
        }
 
        int[] intArray(int N, int mod) {
            int[] ret = new int[N];
            for (int i = 0; i < N; i++)
                ret[i] = ni()+mod;
            return ret;
        }
 
        long nl() {
            return Long.parseLong(next());
        }
 
        long[] longArray(int N, long mod) {
            long[] ret = new long[N];
            for (int i = 0; i < N; i++)
                ret[i] = nl()+mod;
            return ret;
        }
 
        double nd() {
            return Double.parseDouble(next());
        }
 
        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}",6,5
"import java.util.*;
import java.io.*;

public class Solve{
    public static void main(String[] args) throws Exception{
        Scanner sc=new Scanner(System.in);
        PrintWriter out =new PrintWriter(System.out);
        int size=(int)1e7+1;
        int[] pr=new int[size];
        for(int i=0;i<size;i++){
            pr[i]=i;
        }
        for(int i=2;i*i<size;i++){
           if(pr[i]==i){int val=i*i;
            for(int j=val;j<=size;j+=val){
                 pr[j]=j/val;
            }
           }
        }
        int t=sc.nextInt();
        int[] dp=new int[size];
        Arrays.fill(dp,-1);
        while(t-->0){
            int n=sc.nextInt();
            int k=sc.nextInt();
            int[] ar=new int[n];
            for(int i=0;i<n;i++){
                int a=sc.nextInt();
                ar[i]=pr[a];
            }
            int[] ans=new int[k+1];
            int[] ind=new int[k+1];
            for(int i=0;i<n;i++){
                for(int h=k;h>=0;h--){
                    if(dp[ar[i]]>=ind[h]){
                        ans[h]++;
                        ind[h]=i;
                    }
                    if(h>0 && (ans[h-1]<ans[h] ||(ans[h-1]==ans[h] && ind[h-1]>ind[h])))
                    {
                        ans[h]=ans[h-1];
                        ind[h]=ind[h-1];
                    }
                }
                dp[ar[i]]=i;
            }
            out.println(ans[k]+1);
            for(int i=0;i<n;i++)dp[ar[i]]=-1;
        }
        out.close();
    }
}",6,6
"import java.io.*;
import java.util.*;

public class Main {

    static final int primeCount = 452;
    static final int[] prime = new int[primeCount];

    static void build_prime() {
        boolean[] notPrime = new boolean[3200];
        for (int i = 2; i < 3200; i++) {
            if (notPrime[i]) continue;
            for (int j = i * i; j < 3200; j += i) {
                notPrime[j] = true;
            }
        }

        int count = 0;
        for (int i = 2; i < 3200; i++) {
            if (notPrime[i]) continue;

            prime[count++] = i;
        }
    }

    private static void run(Reader in, PrintWriter out) throws IOException {
        int n = in.nextInt();
        int m = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = getReal(in.nextInt());
        }

        int[] pre = new int[n];
        for (int i = 0; i < n; i++) pre[i] = -1;

        TreeMap<Integer, Integer> exist = new TreeMap<>();
        for (int i = 0; i < n; i++) {
            Integer result = exist.get(a[i]);
            if (result != null) {
                pre[i] = result;
            }
            exist.put(a[i], i);
        }

        int[][] left = new int[m + 1][n];
        for (int i = 0; i <= m; i++) {
            int start = 0;
            PriorityQueue<Integer> inSame = new PriorityQueue<>();
            for (int j = 0; j < n; j++) {
                if (pre[j] >= start) {
                    inSame.add(pre[j]);

                    if (inSame.size() > i) {
                        start = inSame.poll() + 1;
                    }
                }
                left[i][j] = start;
            }
        }

        int[][] dp = new int[n][m + 1];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= m; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
            for (int j = 0; j <= m; j++) {
                for (int k = 0; k <= j; k++) {
                    if (left[k][i] == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = Math.min(dp[i][j], dp[left[k][i] - 1][j - k] + 1);
                    }
                }
            }
        }

        out.println(dp[n - 1][m]);
    }

    static int getReal(int x) {
        int result = 1;
        for (int i = 0; i < primeCount; i++) {
            if (x % prime[i] == 0) {
                int count = 0;
                while (x % prime[i] == 0) {
                    count++;
                    x /= prime[i];
                }
                if (count % 2 == 1) {
                    result *= prime[i];
                }
            }
        }
        result *= x;
        return result;
    }

    public static void main(String[] args) throws IOException {
        Reader in = new Reader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));

        build_prime();
        int t = in.nextInt();
        for (int i = 0; i < t; i++) {
            run(in, out);
        }

        out.flush();
        in.close();
        out.close();
    }

    static class Reader {
        BufferedReader reader;
        StringTokenizer st;

        Reader(InputStreamReader stream) {
            reader = new BufferedReader(stream, 32768);
            st = null;
        }

        void close() throws IOException {
            reader.close();
        }

        String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        String nextLine() throws IOException {
            return reader.readLine();
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

    }
}",6,5
"import java.io.*;
import java.util.*;

public class Main {
  public static void main(String[] args) throws IOException {
    InputStreamReader in = new InputStreamReader(System.in);
    BufferedReader br = new BufferedReader(in);

    int t = Integer.parseInt(br.readLine());

    // get primes up to 10000
    /*
    boolean[] prime = new boolean[10001];
    for (int i = 0; i <= 10000; i++) {
      prime[i] = true;
    }

    for (int p = 2; p * p <= 10000; p++) {
      if (prime[p]) {
        for (int i = p * p; i <= 10000; i += p) {
          prime[i] = false;
        }
      }
    }
    ArrayList<Integer> primes = new ArrayList<>();

    for (int i = 2; i < 10001; i++) {
      if (prime[i]) {
        primes.add(i);
      }
    }
    */
    int A = 10000000;
    int[] convert = new int[A+1];
    for (int a = 1; a <= A; a++) {
      convert[a] = a;
    }
    for (int a = 2; a <= A/a; a++) {
      int sq = a*a;
      for (int b = sq; b <= A; b += sq) {
        while (convert[b] % sq == 0) {
          convert[b] /= sq;
        }
      }
    }

    int[] prevIndex = new int[A+1];
    for (int i = 0; i <= A; i++) {
      prevIndex[i] = -1;
    }

    for (int c = 0; c < t; c++) {
      StringTokenizer st = new StringTokenizer(br.readLine());

      int n = Integer.parseInt(st.nextToken());
      int k = Integer.parseInt(st.nextToken());

      int[] a = new int[n];
      int maxA = 0;

      st = new StringTokenizer(br.readLine());

      for (int i = 0; i < n; i++) {
        /*
        int raw = Integer.parseInt(st.nextToken());
        
        for (int p : primes) {
          if (p*p > raw) {
            break;
          }
          while (raw % (p*p) == 0) {
            raw /= p*p;
          }
        }
        a[i] = raw;
        */

        a[i] = convert[Integer.parseInt(st.nextToken())];
        maxA = Math.max(maxA, a[i]);
      }

      // hard version has extra here
      // better version O(nk)

      int[] partitions = new int[k+1];
      int[] partIndex = new int[k+1];

      for (int i = 0; i < n; i++) {
        int cur = a[i];
        for (int j = k; j >= 0; j--) {
          if (prevIndex[cur] >= partIndex[j]) {
            partitions[j]++;
            partIndex[j] = i;
          }
          if (j > 0 && (partitions[j-1] < partitions[j] || partitions[j-1] == partitions[j] && partIndex[j-1] > partIndex[j])) {
            partitions[j] = partitions[j-1];
            partIndex[j] = partIndex[j-1];
          }
        }
        prevIndex[cur] = i;
      }

      System.out.println(partitions[k]+1);

      for (int i = 0; i < n; i++) {
        int cur = a[i];
        prevIndex[cur] = -1;
      }


      /* this should work (O(n*k^2))
      int[][] minLeftIndex = new int[n][k+1];
    
      for (int j = 0; j <= k; j++) {
        HashMap<Integer, Integer> interval = new HashMap<>();
        int leftIndex = 0; // the right index is i in this case
        int removed = 0;

        for (int i = 0; i < n; i++) {
          if (!interval.containsKey(a[i])) {
            interval.put(a[i], 0);
          }
          interval.put(a[i], interval.get(a[i])+1);
          if (interval.get(a[i]) > 1) {
            removed++;
          }
          while (removed > j) {
            interval.put(a[leftIndex], interval.get(a[leftIndex])-1);
            if (interval.get(a[leftIndex]) > 0) {
              removed--;
            }
            leftIndex++;
          }
          minLeftIndex[i][j] = leftIndex;
          //System.out.println(i + "" "" + j + "" "" + leftIndex);
        }
      }

      int[][] dp = new int[n][k+1];

      // dp at all i = 0 = 0
      for (int i = 0; i < n; i++) {
        for (int j = 0; j <= k; j++) {
          int min = Integer.MAX_VALUE;
          for (int l = 0; l <= j; l++) {
            if (minLeftIndex[i][l] > 0) {
              min = Math.min(min, dp[minLeftIndex[i][l]-1][j-l] + 1); // 
            } else {
              min = 0;
            }
            
          }
          if (min != Integer.MAX_VALUE) {
            dp[i][j] = min;
          }
        }
      }
      
      System.out.println(dp[n-1][k]+1);

      

      */

      // easy solution
      /*
      HashSet<Integer> hs = new HashSet<>();

      int segments = 1;

      for (int i = 0; i < n; i++) {
        if (hs.contains(a[i])) {
          segments++;
          hs.clear();
        }
        hs.add(a[i]);
      }
      System.out.println(segments);
      */
    } 
  }
}",6,3
"// Don't place your source in a package
import java.lang.reflect.Array;
import java.text.DecimalFormat;
import java.util.*;
import java.lang.*;
import java.io.*;
import java.math.*;








// Please name your class Main
public class Main {
    static FastScanner fs=new FastScanner();
    static class FastScanner {//scanner from SecondThread
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st=new StringTokenizer("""");
        public String next() {
            while (!st.hasMoreElements())
                try {
                    st=new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            return st.nextToken();
        }
        int Int() {
            return Integer.parseInt(next());
        }

        long Long() {
            return Long.parseLong(next());
        }

        String Str(){
            return next();
        }
    }


    public static void main (String[] args) throws java.lang.Exception {
        PrintWriter out = new PrintWriter(System.out);

        int primes[]=new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
                73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,
                173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269,
                271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,
                383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,
                491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
                613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727,
                733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607,
                1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721,
                1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847,
                1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973,
                1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373,
                3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517,
                3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999};

        int T=Int();
        for(int t=0;t<T;t++){
            int n=Int();
            int k=Int();
            int A[]=new int[n];
            for(int i=0;i<n;i++){
                A[i]=Int();
            }
            Sol sol=new Sol();
            sol.solution(out,A,k,primes);
        }
        out.flush();

    }

    public static int Int(){
        return fs.Int();
    }
    public static long Long(){
        return fs.Long();
    }
    public static String Str(){
        return fs.Str();
    }

}



class Sol{
    int dp[][];
    public void solution(PrintWriter out,int A[],int K,int primes[]){
        int n=A.length;
        int id=0;
        int dp[][]=new int[n+1][K+1];
        for(int i=0;i<dp.length;i++){
            Arrays.fill(dp[i],n);
        }

        //pre-processing
        Map<String,Integer>f=new HashMap<>();
        for(int i=0;i<A.length;i++){
            String h=hash(A[i],primes);
            if(!f.containsKey(h)){
                f.put(h,id);
                A[i]=id;
                id++;
            }
            else{
                A[i]=f.get(h);
            }
        }


        int dis[][]=new int[A.length][K+1];
        for(int k=0;k<=K;k++){//how far it can go
            int r=n-1;
            Map<Integer,Integer>ff=new HashMap<>();
            for(int i=n-1;i>=0;i--){
                put(ff,A[i]);
                while(ff.size()+k<(r-i+1)){
                    remove(ff,A[r]);
                    dis[r][k]=i+1;
                    r--;
                }
            }
        }



        for(int i=0;i<n;i++){
            for(int j=0;j<=K;j++){
                if(j>=i+1){
                    dp[i][j]=1;
                    continue;
                }
                for(int k=0;k<=j;k++){//take k change
                    int reach=dis[i][k];//the maximum place I can reach
                    if(reach==0)dp[i][j]=1;
                    else dp[i][j]=Math.min(dp[i][j],1+dp[reach-1][j-k]);
                }
            }
        }
        out.println(dp[n-1][K]);

    }

    public void put(Map<Integer,Integer>f,int key){
        if(!f.containsKey(key))f.put(key,1);
        else f.put(key,f.get(key)+1);
    }
    public void remove(Map<Integer,Integer>f,int key){
        f.put(key,f.get(key)-1);
        if(f.get(key)==0)f.remove(key);
    }


    public String hash(int n,int primes[]){
        StringBuilder str=new StringBuilder(""a,"");
        for(int i:primes){
            if(i*i>n)break;
            int cnt=0;
            while(n%i==0){
                n/=i;
                cnt++;
            }
            cnt%=2;
            if(cnt!=0)str.append(i+"","");
        }
        if(n!=1)str.append(n+"","");
        return str.toString();
    }

}






",6,5
"import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.*;

public class SolutionE extends Thread {
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new
                                            InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = """";
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

    private static final FastReader scanner = new FastReader();
    private static final PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) {
        new Thread(null, new SolutionE(), ""Main"", 1 << 26).start();
    }

    static final int[] primeFactors = getSmallestPrimeFactorInIntervalInclusive(10_000_000);

    public void run() {
        int t = scanner.nextInt();
        for (int i = 0; i < t; i++) {
            solve();
        }
        out.close();
    }

    //runs in roughly O(maxN * lg^2(maxN)))
    public static int[] getSmallestPrimeFactorInIntervalInclusive(int maxN) {
        int[] result = new int[maxN + 1];

        result[1] = 1;
        for (int i = 2; i <= maxN; i++) {
            if (result[i] == 0) {
                for (int j = i; j <= maxN; j += i) {
                    result[j] = (result[j / i] % i == 0) ? (result[j/i]/i) : (result[j/i]*i);
                }
            }
        }
        return result;
    }


    private static void solve() {
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = primeFactors[scanner.nextInt()];
        }

        Map<Integer, Integer> lastSeenIndex = new HashMap<>();
        int[] revertPointers = new int[n];
        for (int i = 0; i < n; i++) {
            if (lastSeenIndex.get(a[i]) != null) {
                revertPointers[i] = lastSeenIndex.get(a[i]);
            } else {
                revertPointers[i] = -1;
            }
            lastSeenIndex.put(a[i], i);
        }

        int[][] maxSegment = new int[n][k+1];
        for (int j = 0; j <= k; j++) {
            int pointerLeft = 0;
            int pointerRight = 0;
            boolean[] changed = new boolean[n];
            int amountChanged = 0;
            while (pointerLeft < n) {
                if (pointerRight < n && revertPointers[pointerRight] < pointerLeft) {
                    pointerRight++;
                } else if (pointerRight < n && revertPointers[pointerRight] >= pointerLeft && amountChanged < j) {
                    changed[revertPointers[pointerRight]] = true;
                    pointerRight++;
                    amountChanged++;
                } else {
                    if (changed[pointerLeft]) {
                        amountChanged--;
                    }
                    maxSegment[pointerLeft][j] = pointerRight;
                    pointerLeft++;
                }
            }
        }

        int[][] dp = new int[n+1][k+1];

        for (int j = 0; j <= k; j++) {
            dp[n][j] = 0;
        }

        for (int i = n - 1; i >= 0; i--) {
            for (int j = 0; j <= k; j++) {
                dp[i][j] = n + 1;
                for (int x = 0; x <= j; x++) {
                    int nextJumpTo = maxSegment[i][x];
                    dp[i][j] = Math.min(dp[i][j], dp[nextJumpTo][j - x] + 1);
                }
            }
        }

        out.println(dp[0][k]);
    }

    //REMINDERS:
    //- CHECK FOR INTEGER-OVERFLOW BEFORE SUBMITTING

    //- CAN U BRUTEFORCE OVER SOMETHING, TO MAKE IT EASIER TO CALCULATE THE SOLUTION
}",6,6
"// XXXX
import java.io.*;
import java.util.*;

public class CF1497E2 extends PrintWriter {
	CF1497E2() { super(System.out); }
	static class Scanner {
		Scanner(InputStream in) { this.in = in; } InputStream in;
		byte[] bb = new byte[1 << 15]; int i, n;
		byte getc() {
			if (i == n) {
				i = n = 0;
				try { n = in.read(bb); } catch (IOException e) {}
			}
			return i < n ? bb[i++] : 0;
		}
		int nextInt() {
			byte c = 0; while (c <= ' ') c = getc();
			int a = 0; while (c > ' ') { a = a * 10 + c - '0'; c = getc(); }
			return a;
		}
	}
	Scanner sc = new Scanner(System.in);
	public static void main(String[] $) {
		CF1497E2 o = new CF1497E2(); o.main(); o.flush();
	}

	static final int A = 10000000, K = 20;
	int[] cc = new int[A + 1]; {
		for (int a = 1; a <= A; a++)
			cc[a] = a;
		for (int a = 2; a <= A / a; a++) {
			int s = a * a;
			for (int b = s; b <= A; b += s)
				while (cc[b] % s == 0)
					cc[b] /= s;
		}
	}
	void main() {
		int[] pp = new int[A + 1]; Arrays.fill(pp, -1);
		int t = sc.nextInt();
		while (t-- > 0) {
			int n = sc.nextInt();
			int k = sc.nextInt();
			int[] aa = new int[n];
			for (int i = 0; i < n; i++)
				aa[i] = cc[sc.nextInt()];
			int[] mp = new int[k + 1];
			int[] ip = new int[k + 1];
			for (int i = 0; i < n; i++) {
				int a = aa[i];
				for (int h = k; h >= 0; h--) {
					if (pp[a] >= ip[h]) {
						mp[h]++;
						ip[h] = i;
					}
					if (h > 0 && (mp[h - 1] < mp[h] || mp[h - 1] == mp[h] && ip[h - 1] > ip[h])) {
						mp[h] = mp[h - 1];
						ip[h] = ip[h - 1];
					}
				}
				pp[a] = i;
			}
			println(mp[k] + 1);
			for (int i = 0; i < n; i++) {
				int a = aa[i];
				pp[a] = -1;
			}
		}
	}
}
",6,6
"import java.util.*;
import java.io.*;

public class cf1497_Div2_E2 {
	static int[] spf;
	
	public static int factor(int n) {
		int val = 1;
		while (n > 1) {
			int cnt = 0;
			int p = spf[n];
			while (n % p == 0) {
				cnt++;
				n /= p;
			}
			if (cnt % 2 == 1)
				val *= p;
		}
		return val;
	}
	
	public static void main(String args[]) throws IOException {
		FastScanner in = new FastScanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		
		int t = in.nextInt();
		int max = (int)(1e7) + 1;
		
		boolean[] prime = new boolean[max + 1]; 
		Arrays.fill(prime, true);
		prime[0] = prime[1] = false;
		spf = new int[max];
		for (int i = 2; i < max; i++) spf[i] = i;
		for (int i = 2; i * i < max; i++) {
			if (prime[i]) {
				spf[i] = i;
				for (int j = i * i; j < max; j += i) {
					prime[j] = false;
					spf[j] = i;
				}
			}
		}
		
		int[] cnts = new int[max];
		
		for ( ; t > 0; t--) {
			int n = in.nextInt();
			int k = in.nextInt();
			int[] vals = new int[n];
			for (int i = 0; i < n; i++)
				vals[i] = factor(in.nextInt());
			
			// left[i][x] = l where al ... ai such that in x moves it is valid subsequence
			int[][] left = new int[n + 1][k + 1];
			// x y z w a b c
			
			for (int x = 0; x <= k; x++) {
				int l = n;
				int now = 0;
				for (int i = n - 1; i >= 0; i--) {
					while (l - 1 >= 0 && now + ((cnts[vals[l - 1]] > 0) ? 1 : 0) <= x) {
						l--;
						now += ((cnts[vals[l]] > 0) ? 1 : 0);
						// System.out.println(now);
						cnts[vals[l]]++;
					}
					// System.out.println(i + "" "" + x + "" "" + l + "" "" + now);
					left[i][x] = l;
					if (cnts[vals[i]] > 1) now--;
					cnts[vals[i]]--;
				}
			}
			
			// for (int[] x: left)
				// System.out.println(Arrays.toString(x));
		
				
			int oo = (int)(1e9);
			
			int[][] dp = new int[n + 1][k + 1];
			
			for (int i = 1; i <= n; i++)
				Arrays.fill(dp[i], oo);
			
			for (int i = 1; i <= n; i++) {
				for (int j = 0; j <= k; j++) {
					if (j > 0) dp[i][j] = dp[i][j - 1];
					for (int x = 0; x <= j; x++) {
						int l = left[i - 1][x];
						dp[i][j] = Math.min(dp[i][j], dp[l][j - x] + 1);
					}
				}
			}
			
			int min = Integer.MAX_VALUE;
			for (int i = 0; i <= k; i++) {
				min = Math.min(min, dp[n][i]);
			}
			
			out.println(min);
		}
		
		out.close();
	}

	
	static class FastScanner {
	    BufferedReader br;
	    StringTokenizer st;
		
	    public FastScanner(InputStream i) {
	        br = new BufferedReader(new InputStreamReader(i));
	        st = new StringTokenizer("""");
	    }
				
	    public String next() throws IOException {
	        if(st.hasMoreTokens())
	            return st.nextToken();
	        else
	            st = new StringTokenizer(br.readLine());
	        return next();
	    }

	    public int nextInt() throws IOException {
	        return Integer.parseInt(next());
	    }
	    //#
	    public long nextLong() throws IOException {
	        return Long.parseLong(next());
	    }
	    public double nextDouble() throws IOException {
	        return Double.parseDouble(next());
	    }
	    //$
	}
}
",6,5
"/**
 * author: derrick20
 * created: 3/19/21 11:57 PM
 */
import java.io.*;
import java.util.*;
import static java.lang.Math.*;

public class E2_SquareFreeDivision2 {
    static FastScanner sc = new FastScanner();
    static PrintWriter out = new PrintWriter(System.out);

    public static void main(String[] args) {
//        generate();
        int T = sc.nextInt();
        int MAX = (int) 1e7;
        int[] canonical = new int[MAX + 1];
        canonical[1] = 1;
        for (int factor = 2; factor <= MAX; factor++) {
            if (canonical[factor] == 0) {
                for (int mult = factor; mult <= MAX; mult += factor) {
                    int prev = canonical[mult / factor];
                    if (prev % factor == 0) {
                        canonical[mult] = prev / factor;
                    } else {
                        canonical[mult] = prev * factor;
                    }
                }
            }
        }
//        System.out.println(Arrays.toString(canonical));
        int[] freq = new int[MAX + 1];
        while (T-->0) {
            int N = sc.nextInt();
            int K = sc.nextInt();
            int[] a = new int[N + 1];
            for (int i = 1; i <= N; i++) {
                a[i] = canonical[sc.nextInt()];
            }
            int[][] transition = new int[K + 1][N + 1];
//            HashMap<Integer, Integer> freq = new HashMap<>();
            for (int k = 0; k <= K; k++) {
                int l = N + 1;
                int duplicates = 0;
                for (int r = N; r >= 1; r--) {
                    while (l - 1 >= 1) {
                        int nextDuplicates = duplicates;
                        if (freq[a[l - 1]] >= 1) {
                            nextDuplicates++;
                        }
                        if (nextDuplicates <= k) {
                            duplicates = nextDuplicates;
                            freq[a[l - 1]]++;
                            l--;
                        } else {
                            break;
                        }
                    }
                    transition[k][r] = l;
                    if (--freq[a[r]] >= 1) {
                        duplicates--;
                    }
                }
            }
            int[][] dp = new int[K + 1][N + 1];
            int oo = (int) 1e9;
            for (int[] row : dp) {
                Arrays.fill(row, oo);
            }
            for (int k = 0; k <= K; k++) {
                dp[k][0] = 0;
            }
            for (int r = 1; r <= N; r++) {
                for (int k = 0; k <= K; k++) {
                    for (int delta = 0; delta <= k; delta++) {
                        dp[k][r] = min(dp[k][r], dp[k - delta][transition[delta][r] - 1] + 1);
                    }
                }
            }
            out.println(dp[K][N]);
        }
        out.close();
    }

    static class FastScanner {
        private int BS = 1 << 16;
        private char NC = (char) 0;
        private byte[] buf = new byte[BS];
        private int bId = 0, size = 0;
        private char c = NC;
        private double cnt = 1;
        private BufferedInputStream in;
    
        public FastScanner() {
            in = new BufferedInputStream(System.in, BS);
        }
    
        public FastScanner(String s) {
            try {
                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);
            } catch (Exception e) {
                in = new BufferedInputStream(System.in, BS);
            }
        }
    
        char getChar() {
            while (bId == size) {
                try {
                    size = in.read(buf);
                } catch (Exception e) {
                    return NC;
                }
                if (size == -1) return NC;
                bId = 0;
            }
            return (char) buf[bId++];
        }
    
        int nextInt() {
            return (int) nextLong();
        }
    
        long nextLong() {
            cnt = 1;
            boolean neg = false;
            if (c == NC) c = getChar();
            for (; (c < '0' || c > '9'); c = getChar()) {
                if (c == '-') neg = true;
            }
            long res = 0;
            for (; c >= '0' && c <= '9'; c = getChar()) {
                res = (res << 3) + (res << 1) + c - '0';
                cnt *= 10;
            }
            return neg ? -res : res;
        }
    
        double nextDouble() {
            boolean neg = false;
            if (c == NC) c = getChar();
            for (; (c < '0' || c > '9'); c = getChar()) {
                if (c == '-') neg = true;
            }
            double cur = nextLong();
            if (c != '.') {
                return neg ? -cur : cur;
            } else {
                double frac = nextLong() / cnt;
                return neg ? -cur - frac : cur + frac;
            }
        }
    
        String next() {
            StringBuilder res = new StringBuilder();
            while (c <= 32) c = getChar();
            while (c > 32) {
                res.append(c);
                c = getChar();
            }
            return res.toString();
        }
    
        String nextLine() {
            StringBuilder res = new StringBuilder();
            while (c <= 32) c = getChar();
            while (c != '\n') {
                res.append(c);
                c = getChar();
            }
            return res.toString();
        }
    
        boolean hasNext() {
            if (c > 32) return true;
            while (true) {
                c = getChar();
                if (c == NC) return false;
                else if (c > 32) return true;
            }
        }
    }
    
    static void ASSERT(boolean assertion, String message) {
        if (!assertion) throw new AssertionError(message);
    }
    
    static void ASSERT(boolean assertion) {
        if (!assertion) throw new AssertionError();
    }
}",6,5
"import java.io.*;
import java.util.*;

public class E2 {
    static ArrayList<Integer> primes;
    static int[] mind;
    final static int MAXA = (int) 1e7;

    public static void main(String[] args) throws IOException {
        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(f.readLine());
        int t = Integer.parseInt(st.nextToken());
        primes = new ArrayList<>();
        mind = new int[MAXA + 1];
        for (int i = 2; i <= MAXA; i++) {
            if (mind[i] == 0) {
                primes.add(i);
                mind[i] = i;
            }
            for (int x : primes) {
                if (x > mind[i] || x * i > MAXA) break;
                mind[x * i] = x;
            }
        }
        int[] count = new int[MAXA + 1];
        for (int on8y = 0; on8y < t; on8y++) {
            st = new StringTokenizer(f.readLine());
            int n = Integer.parseInt(st.nextToken());
            int k = Integer.parseInt(st.nextToken());
            int[] a = new int[n];
            Arrays.fill(a, 1);
            st = new StringTokenizer(f.readLine());
            for (int i = 0; i < n; i++) {
                int x = Integer.parseInt(st.nextToken());
                int cnt = 0;
                int last = 0;
                while (x > 1) {
                    int p = mind[x];
                    if (last == p) cnt++;
                    else {
                        if (cnt % 2 == 1) a[i] *= last;
                        last = p;
                        cnt = 1;
                    }
                    x /= p;
                }
                if (cnt % 2 == 1) a[i] *= last;
            }
            int[][] mnleft = new int[n][k + 1];
            for (int j = 0; j < k + 1; j++) {
                int l = n;
                int now = 0;
                for (int i = n - 1; i >= 0; i--) {
                    while (l - 1 >= 0 && now + ((count[a[l - 1]] > 0) ? 1 : 0) <= j) {
                        l--;
                        now += (count[a[l]] > 0) ? 1 : 0;
                        count[a[l]]++;
                    }
                    mnleft[i][j] = l;
                    if (count[a[i]] > 1) now--;
                    count[a[i]]--;
                }
            }
            int[][] dp = new int[n + 1][k + 1];
            for (int i = 0; i < n + 1; i++) {
                Arrays.fill(dp[i], (int) 1e9 + 1);
            }
            for (int i = 0; i < k + 1; i++) dp[0][i] = 0;
            for (int i = 1; i <= n; i++) {
                for (int j = 0; j <= k; j++) {
                    if (j > 0) dp[i][j] = dp[i][j - 1];
                    for (int lst = 0; lst <= j; lst++) {
                        dp[i][j] = Math.min(dp[i][j], dp[mnleft[i - 1][lst]][j - lst] + 1);
                    }
                }
            }
            int ans = (int) 1e9 + 1;
            for (int c : dp[n]) ans = Math.min(ans, c);
            System.out.println(ans);

        }
    }
}


",6,6
"import java.io.*;
import java.util.*;

public class CF1497E2 extends PrintWriter {
	CF1497E2() { super(System.out); }
	static class Scanner {
		Scanner(InputStream in) { this.in = in; } InputStream in;
		byte[] bb = new byte[1 << 15]; int i, n;
		byte getc() {
			if (i == n) {
				i = n = 0;
				try { n = in.read(bb); } catch (IOException e) {}
			}
			return i < n ? bb[i++] : 0;
		}
		int nextInt() {
			byte c = 0; while (c <= ' ') c = getc();
			int a = 0; while (c > ' ') { a = a * 10 + c - '0'; c = getc(); }
			return a;
		}
	}
	Scanner sc = new Scanner(System.in);
	public static void main(String[] $) {
		CF1497E2 o = new CF1497E2(); o.main(); o.flush();
	}

	static final int A = 10000000, K = 20;
	int[] cc = new int[A + 1]; {
		boolean[] composite = new boolean[A + 1];
		for (int a = 1; a <= A; a++)
			cc[a] = a;
		for (int a = 2; a <= A; a++) {
			if (composite[a])
				continue;
			for (int b = a + a; b <= A; b += a)
				composite[b] = true;
			if (a <= A / a) {
				int a2 = a * a;
				for (int b = a2; b <= A; b += a2) {
					int c = cc[b];
					while (c % a2 == 0)
						c /= a2;
					cc[b] = c;
				}
			}
		}
	}
	void main() {
		int[] pp = new int[A + 1]; Arrays.fill(pp, -1);
		int t = sc.nextInt();
		while (t-- > 0) {
			int n = sc.nextInt();
			int k = sc.nextInt();
			int[] aa = new int[n];
			for (int i = 0; i < n; i++)
				aa[i] = cc[sc.nextInt()];
			int[] mp = new int[k + 1];
			int[] ip = new int[k + 1];
			for (int i = 0; i < n; i++) {
				int a = aa[i];
				for (int h = k; h >= 0; h--) {
					if (pp[a] >= ip[h]) {
						mp[h]++;
						ip[h] = i;
					}
					if (h > 0 && (mp[h - 1] < mp[h] || mp[h - 1] == mp[h] && ip[h - 1] > ip[h])) {
						mp[h] = mp[h - 1];
						ip[h] = ip[h - 1];
					}
				}
				pp[a] = i;
			}
			println(mp[k] + 1);
			for (int i = 0; i < n; i++) {
				int a = aa[i];
				pp[a] = -1;
			}
		}
	}
}
",6,6
