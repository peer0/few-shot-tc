{"back-translation": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\nclass C {\n    static class FastWriter {\n        private BufferedWriter bw;\n\n        FastWriter() {\n            bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        BigInteger nextBigInteger() {\n            try {\n                return new BigInteger(nextLine());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int q = fr.nextInt();\n        int[] aa = new int[n - 1];\n        int[] ab = new int[n - 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) dq.addLast(fr.nextInt());\n        for (int i = 0; i < n - 1; i++) {\n            int a = dq.removeFirst();\n            int b = dq.removeFirst();\n            aa[i] = a;\n            ab[i] = b;\n            int mi = Math.min(a, b);\n            int ma = Math.max(a, b);\n            dq.addFirst(ma);\n            dq.addLast(mi);\n        }\n        int fm = dq.removeFirst();\n        int[] arr = new int[n - 1];\n        for (int i = 0; i < arr.length; i++) arr[i] = dq.removeFirst();\n        while (q-- > 0) {\n            long m = fr.nextLong() - 1;\n            if (m < n - 1) {\n                fw.println(aa[(int) m] + \" \" + ab[(int) m]);\n            } else {\n                m = m % (n - 1);\n                fw.println(fm + \" \" + arr[(int) m]);\n            }\n        }\n        fw.close();\n    }\n}", "src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class C {\n    static class FastWriter {\n        private final BufferedWriter bw;\n\n        public FastWriter() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        public void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        BigInteger nextBigInteger() {\n            try {\n                return new BigInteger(nextLine());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int q = fr.nextInt();\n        int[] aa = new int[n - 1];\n        int[] ab = new int[n - 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) dq.addLast(fr.nextInt());\n        for (int i = 0; i < n - 1; i++) {\n            int a = dq.removeFirst();\n            int b = dq.removeFirst();\n            aa[i] = a;\n            ab[i] = b;\n            int mi = Math.min(a, b);\n            int ma = Math.max(a, b);\n            dq.addFirst(ma);\n            dq.addLast(mi);\n        }\n        int fm = dq.removeFirst();\n        int[] arr = new int[n - 1];\n        for (int i = 0; i < arr.length; i++) arr[i] = dq.removeFirst();\n        while (q-- > 0) {\n            long m = fr.nextLong() - 1;\n            if (m < n - 1) {\n                System.out.println(aa[(int) m] + \" \" + ab[(int) m]);\n            } else {\n                m = m % (n - 1);\n                System.out.println(fm + \" \" + arr[(int) m]);\n            }\n        }\n    }\n}\n", "index": 2, "complexity": 3}
{"back-translation": "class Node { int data; Node left, right; Node(int item) { data = item; left = right = null; } } class BinaryTree { Node root; void printLeaves(Node node) { if (node != null){ printLeaves(node.left); if (node.left == null && node.right == null) System.out.print(node.data + \" \"); printLeaves(node.right); } } void printBoundaryLeft(Node node) { if (node != null) { if (node.left != null){ System.out.print(node.data + \" \"); printBoundaryLeft(node.left); } else if (node.right != null){ System.out.print(node.data + \" \"); printBoundaryLeft(node.right); }} } void printBoundaryRight(Node node) { if (node != null){ if (node.right != null){ printBoundaryRight(node.right); System.out.print(node.data + \" \"); } else if (node.left != null){ printBoundaryRight(node.left); System.out.print(node.data + \" \"); }} } void printBoundary(Node node) { if (node != null){ System.out.print(node.data + \" \"); printBoundaryLeft(node.left); printLeaves(node.left); printLeaves(node.right); printBoundaryRight(node.right); }} public static void main(String args[]) { BinaryTree tree = new BinaryTree(); tree.root = new Node(20); tree.root.left = new Node(8); tree.root.left.left = new Node(4); tree.root.left.right = new Node(12); tree.root.left.right.left = new Node(10); tree.root.left.right.right = new Node(14); tree.root.right = new Node(22); tree.root.right.right = new Node(25); tree.printBoundary(tree.root); }}", "src": "\n// Java program to print boundary traversal of binary tree \n\n/* A binary tree node has data, pointer to left child \n\nand a pointer to right child */\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n// A simple function to print leaf nodes of a binary tree \n\nvoid\nprintLeaves(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nprintLeaves(node.left); \n\n\n// Print it if it is a leaf node \n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintLeaves(node.right); \n\n} \n\n} \n\n\n// A function to print all left boundary nodes, except a leaf node. \n\n// Print the nodes in TOP DOWN manner \n\nvoid\nprintBoundaryLeft(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nif\n(node.left != \nnull\n) { \n\n\n// to ensure top down order, print the node \n\n// before calling itself for left subtree \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintBoundaryLeft(node.left); \n\n} \n\nelse\nif\n(node.right != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintBoundaryLeft(node.right); \n\n} \n\n\n// do nothing if it is a leaf node, this way we avoid \n\n// duplicates in output \n\n} \n\n} \n\n\n// A function to print all right boundary nodes, except a leaf node \n\n// Print the nodes in BOTTOM UP manner \n\nvoid\nprintBoundaryRight(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nif\n(node.right != \nnull\n) { \n\n// to ensure bottom up order, first call for right \n\n// subtree, then print this node \n\nprintBoundaryRight(node.right); \n\nSystem.out.print(node.data + \n\" \"\n); \n\n} \n\nelse\nif\n(node.left != \nnull\n) { \n\nprintBoundaryRight(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\n} \n\n// do nothing if it is a leaf node, this way we avoid \n\n// duplicates in output \n\n} \n\n} \n\n\n// A function to do boundary traversal of a given binary tree \n\nvoid\nprintBoundary(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n// Print the left boundary in top-down manner. \n\nprintBoundaryLeft(node.left); \n\n\n// Print all leaf nodes \n\nprintLeaves(node.left); \n\nprintLeaves(node.right); \n\n\n// Print the right boundary in bottom-up manner \n\nprintBoundaryRight(node.right); \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n20\n); \n\ntree.root.left = \nnew\nNode(\n8\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n12\n); \n\ntree.root.left.right.left = \nnew\nNode(\n10\n); \n\ntree.root.left.right.right = \nnew\nNode(\n14\n); \n\ntree.root.right = \nnew\nNode(\n22\n); \n\ntree.root.right.right = \nnew\nNode(\n25\n); \n\ntree.printBoundary(tree.root); \n\n} \n} ", "index": 3, "complexity": 3}
{"back-translation": "public static void main(String[] args) throws Exception {\n\tnew Thread(null, new Solution1(), \"Solution1\", 1 << 26).start();\n}\n\nlong gcd(long a, long b) {\n\tif (a == 0) return b;\n\treturn gcd(b % a, a);\n}\n\nlong lcm(long a, long b) {\n\treturn (a * b) / gcd(a, b);\n}\n\nint root(int a) {\n\twhile (arr[a] != a) {\n\t\tarr[a] = arr[arr[a]];\n\t\ta = arr[a];\n\t}\n\treturn a;\n}\n\nvoid union(int a, int b) {\n\tint xroot = root(a);\n\tint yroot = root(b);\n\tif (arr[xroot] < arr[yroot]) {\n\t\tarr[xroot] = yroot;\n\t} else {\n\t\tarr[yroot] = xroot;\n\t}\n}\n\nboolean find(int a, int b) {\n\tint roota = root(a);\n\tint rootb = root(b);\n\tif (roota == rootb) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nint[] arr;\nfinal int level = 20;\n\npublic void run() {\n\tInputReader sc = new InputReader(System.in);\n\tPrintWriter w = new PrintWriter(System.out);\n\tint n = sc.nextInt();\n\tchar[] ch = new char[n];\n\tchar[] ch2 = new char[n];\n\tch = sc.next().toCharArray();\n\tch2 = sc.next().toCharArray();\n\tHashSet<Integer>[] hset = new HashSet[26];\n\tfor (int i = 0; i < 26; i++) {\n\t\thset[i] = new HashSet<>();\n\t}\n\tint count = 0;\n\tfor (int i = 0; i < ch.length; i++) {\n\t\tif (ch[i] != ch2[i]) {\n\t\t\thset[ch[i] - 97].add(ch2[i] - 97);\n\t\t\tcount++;\n\t\t}\n\t}\n\tboolean flag = false;\n\tint swap1 = -1;\n\tint swap2 = -1;\n\tint rem = -1;\n\tfor (int i = 0; i < ch.length; i++) {\n\t\tif (ch[i] != ch2[i]) {\n\t\t\tif (hset[ch2[i] - 97].size() != 0) {\n\t\t\t\tswap1 = i;\n\t\t\t\tflag = true;\n\t\t\t\tif (hset[ch2[i] - 97].contains(ch[i] - 97)) {\n\t\t\t\t\trem = i;\n\t\t\t\t\tcount -= 2;\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (flag) {\n\t\tcount--;\n\t\tw.println(count);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i != swap1 && ch[i] == ch2[swap1] && ch[i] != ch2[i]) {\n\t\t\t\tw.println((swap1 + 1) + \" \" + (i + 1));\n\t\t\t\tw.close();\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (rem == -1) {\n\t\t\tw.println(count);\n\t\t\tw.println(\"-1 -1\");\n\t\t} else {\n\t\t\tw.println(count);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i != rem && ch[i] == ch2[rem] && ch[rem] == ch2[i] && ch[i] != ch2[i]) {\n\t\t\t\t\tw.println((rem + 1) + \" \" + (i + 1));\n\t\t\t\t\tw.close();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tw.close();\n}", "src": "\t\t\n\t\t\t\t\t\t\timport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\n\t\t\t\t\t\t\t\t\t\t\tpublic class Solution1 implements Runnable\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstatic final long MAX = 1000000007L;\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class InputReader\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate InputStream stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate byte[] buf = new byte[1024];\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int curChar;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int numChars;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate SpaceCharFilter filter;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic InputReader(InputStream stream)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.stream = stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int read()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (numChars==-1) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (curChar >= numChars)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String nextLine()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString str = \"\";\n\t\t\t\t\t\t\t\t\t\t\t            try\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                str = br.readLine();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            catch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                e.printStackTrace();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            return str;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int nextInt()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic long nextLong() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlong res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic double nextDouble() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble m = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm /= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String readString() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res.toString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int c) \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String next() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn readString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic interface SpaceCharFilter \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t \t\n\t\t\t\t\t\t\t\t\t\t\t\tpublic static void main(String args[]) throws Exception\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Thread(null, new Solution1(),\"Solution1\",1<<26).start();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tlong gcd(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t        if (a == 0)\n\t\t\t\t\t\t\t\t\t\t\t            return b;\n\t\t\t\t\t\t\t\t\t\t\t         \n\t\t\t\t\t\t\t\t\t\t\t        return gcd(b%a, a);\n\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t    // method to return LCM of two numbers\n\t\t\t\t\t\t\t\t\t\t\t\t long lcm(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t\t        return (a*b)/gcd(a, b);\n\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t int root(int a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t while(arr[a] != a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[a] = arr[arr[a]];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t a = arr[a];\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t\t return a;\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t void union(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int xroot = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int yroot = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(arr[xroot] < arr[yroot]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[xroot] = yroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[yroot] = xroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t boolean find(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int roota = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int rootb = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(roota == rootb){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t int[] arr;\n\t\t\t\t\t\t\t\t\t\t\t\t final int level = 20;\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\tpublic void run()\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tInputReader sc= new InputReader(System.in);\n\t\t\t\t\t\t\t\t\t\t\t\t\tPrintWriter w= new PrintWriter(System.out);\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n = sc.nextInt();\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch2 = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tch = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tch2 = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tHashSet<Integer> hset[] = new HashSet[26];\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < 26;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[i]  =new HashSet();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[ch[i]-97].add(ch2[i]-97);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tboolean flag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap1 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap2 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint rem = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].size() != 0){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswap1 = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].contains(ch[i]-97)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trem = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount-=2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(flag){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != swap1 && ch[i] == ch2[swap1] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((swap1+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(rem == -1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(\"-1 -1\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != rem && ch[i] == ch2[rem] && ch[rem] == ch2[i] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((rem+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tboolean fun(long[] prefix,long mid,long temp,long[] arr){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(temp >= prefix[(int)mid]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class Pair implements Comparable<Pair>{\n\t\t\t\t\t\t\t\t\t\t\t\t\tint x;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(){}\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(int x,int y){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int compareTo(Pair p){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn Long.compare(this.x,p.x);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}", "index": 4, "complexity": 3}
{"back-translation": "import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class CodeForces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint d = in.nextInt(), sum = in.nextInt();\n\t\tList<Data> data = new ArrayList<>();\n\t\tfor (int i = 0; i < d; ++i) {\n\t\t\tint min = in.nextInt(), max = in.nextInt();\n\t\t\tint centre = (min + max) / 2;\n\t\t\tdata.add(new Data(centre - min, max - centre, centre));\n\t\t\tsum -= centre;\n\t\t}\n\t\tIterator<Data> it = data.iterator();\n\t\twhile (sum != 0) {\n\t\t\tif (!it.hasNext()) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tData da = it.next();\n\t\t\tif (sum > 0) {\n\t\t\t\tda.centre += da.above;\n\t\t\t\tsum -= da.above;\n\t\t\t} else {\n\t\t\t\tda.centre -= da.below;\n\t\t\t\tsum += da.below;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t\tfor (Data da : data) {\n\t\t\tSystem.out.print(da.centre + \" \");\n\t\t}\n\t}\n}\n\nclass Data {\n\tint below, above, centre;\n\t\n\tData(int below, int above, int centre) {\n\t\tthis.below = below;\n\t\tthis.above = above;\n\t\tthis.centre = centre;\n\t}\n}", "src": "import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class CodeForces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint d = in.nextInt(), sum = in.nextInt();\n\t\tList<Data> data = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < d; ++i) {\n\t\t\tint min = in.nextInt(), max = in.nextInt();\n\t\t\tint centre = (min + max) / 2;\n\t\t\tdata.add(new Data(centre - min, max - centre, centre));\n\t\t\tsum -= centre;\n\t\t}\n\t\t\n\t\tIterator<Data> it = data.iterator();\n\t\t\n\t\twhile (sum != 0) {\n\t\t\tif (!it.hasNext()) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tData da = it.next();\n\n\t\t\tif (sum > 0) {\n\t\t\t\tda.centre += da.above;\n\t\t\t\tsum -= da.above;\n\t\t\t} else {\n\t\t\t\tda.centre -= da.below;\n\t\t\t\tsum += da.below;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n\t\t\n\t\tfor (Data da : data) {\n\t\t\tSystem.out.print(da.centre + \" \");\n\t\t}\n\t}\n}\n\nclass Data {\n\tint below, above, centre;\n\t\n\tData(int below, int above, int centre) {\n\t\tthis.below = below;\n\t\tthis.above = above;\n\t\tthis.centre = centre;\n\t}\n}", "index": 5, "complexity": 3}
{"back-translation": "class PairInSortedRotated { static boolean pairInSortedRotated(int arr[], int n, int x) { int i; for (i = 0; i < n - 1; i++) if (arr[i] > arr[i + 1]) break; int l = (i + 1) % n; int r = i; while (l != r) { if (arr[l] + arr[r] == x) return true; if (arr[l] + arr[r] < x) l = (l + 1) % n; else r = (n + r - 1) % n; } return false; } public static void main (String[] args) { int arr[] = {11, 15, 6, 8, 9, 10}; int sum = 16; int n = arr.length; if (pairInSortedRotated(arr, n, sum)) System.out.print(\"Array has two elements\" + \" with sum 16\"); else System.out.print(\"Array doesn't have two\" + \" elements with sum 16 \"); } }", "src": "\n// Java program to find a pair with a given \n// sum in a sorted and rotated array \nclass\nPairInSortedRotated \n{ \n\n// This function returns true if arr[0..n-1] \n\n// has a pair with sum equals to x. \n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n// Find the pivot element \n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n// l is now index of \n\n// smallest element \n\n\nint\nr = i; \n// r is now index of largest \n\n//element \n\n\n// Keep moving either l or r till they meet \n\nwhile\n(l != r) \n\n{ \n\n// If we find a pair with sum x, we \n\n// return true \n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n// If current pair sum is less, move \n\n// to the higher sum \n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n// Move to the lower sum side \n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n} \n/*This code is contributed by Prakriti Gupta*/", "index": 6, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class B {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(bf.readLine());\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        Integer[] a = new Integer[n];\n        for (int i = 0; i < n; i++) a[i] = Integer.parseInt(st.nextToken());\n        Arrays.sort(a);\n        int[] b = new int[n];\n        for (int i = 0; i < n; i++) b[i] = a[i].intValue();\n        boolean diff = false;\n        boolean diff2 = false;\n        Set<Integer> vals = new HashSet<Integer>();\n        vals.add(b[0]);\n        int valval = 0;\n        for (int i = 1; i < n; i++) {\n            vals.add(b[i]);\n            if (b[i] == b[i - 1]) {\n                if (!diff) {\n                    diff = true;\n                    valval = b[i];\n                } else diff2 = true;\n            }\n        }\n        long sum = 0;\n        for (int i : b) sum += i;\n        sum -= 1L * n * (n - 1) / 2;\n        if (diff && !diff2) {\n            if (!vals.contains((valval - 1)) && (valval > 0)) {\n                if (sum % 2 == 0) out.println(\"cslnb\");\n                else out.println(\"sjfnb\");\n            } else out.println(\"cslnb\");\n        } else if (diff2) out.println(\"cslnb\");\n        else if (sum % 2 == 0) out.println(\"cslnb\");\n        else out.println(\"sjfnb\");\n        out.close();\n        System.exit(0);\n    }\n}", "src": "    import java.util.*;\n    import java.io.*;\n    import java.lang.*;\n    import java.math.*;\n    public class B {\n        public static void main(String[] args) throws Exception {\n            BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n            PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n            int n = Integer.parseInt(bf.readLine());\n            StringTokenizer st = new StringTokenizer(bf.readLine());\n            Integer[] a = new Integer[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n            Arrays.sort(a);\n            int[] b = new int[n];\n            for(int i=0; i<n; i++) b[i] = a[i].intValue();\n            boolean diff = false;\n            boolean diff2 = false;\n            Set<Integer> vals = new HashSet<Integer>();\n            vals.add(b[0]);\n            int valval = 0;\n            for(int i=1; i<n; i++) {\n                vals.add(b[i]);\n                if(b[i] == b[i-1]) {\n                    if(!diff) {\n                        diff = true;\n                        valval = b[i];\n                    }\n                    else diff2 = true;\n                }\n            } \n            long sum = 0;\n            for(int i : b) sum += i;\n            sum -= 1L*n*(n-1)/2;\n\n            if(diff && !diff2) {\n                if(!vals.contains((valval-1)) && (valval > 0)) {\n                    if(sum%2 == 0) out.println(\"cslnb\"); else out.println(\"sjfnb\");\n                }\n                else out.println(\"cslnb\");\n            }\n            else if(diff2) out.println(\"cslnb\");\n            else if(sum%2 == 0) out.println(\"cslnb\"); else out.println(\"sjfnb\");\n            // int n = Integer.parseInt(st.nextToken());\n     \n            \n            out.close(); System.exit(0);\n        }\n    }", "index": 7, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class ehab3 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        System.out.println((n + 1));\n        int c = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            int cd = n + i - ((a[i] + c) % n);\n            System.out.println(\"1 \" + (i + 1) + \" \" + cd);\n            c += cd;\n        }\n        System.out.println(\"2 \" + n + \" \" + n);\n    }\n}", "src": "import java.util.*;\n\npublic class ehab3 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint n = in.nextInt();\n\tint[] a = new int[n];\n\tfor ( int i = 0; i < n; i++ )\n\t    a[i] = in.nextInt();\n\tSystem.out.println( ( n + 1 ) );\n\tint c = 0;\n\tfor ( int i = n - 1; i >= 0; i-- ) {\n\t    int cd = n + i - ( ( a[i] + c ) % n );\n\t    System.out.println( \"1 \" + ( i + 1 ) + \" \" + cd );\n\t    c += cd;\n\t}\n\tSystem.out.println( \"2 \" + n + \" \" + n );\n    }\n}\n", "index": 8, "complexity": 3}
{"back-translation": "class GFG { static int MAX_CHAR = 26; static void findAndPrintUncommonChars(String str1, String str2) { int present[] = new int[MAX_CHAR]; for (int i = 0; i < MAX_CHAR; i++) { present[i] = 0; } int l1 = str1.length(); int l2 = str2.length(); for (int i = 0; i < l1; i++) { present[str1.charAt(i) - 'a'] = 1; } for (int i = 0; i < l2; i++) { if (present[str2.charAt(i) - 'a'] == 1 || present[str2.charAt(i) - 'a'] == -1) { present[str2.charAt(i) - 'a'] = -1; } else { present[str2.charAt(i) - 'a'] = 2; } } for (int i = 0; i < MAX_CHAR; i++) { if (present[i] == 1 || present[i] == 2) { System.out.print((char) (i + 'a') + \" \"); } } } public static void main(String[] args) { String str1 = \"characters\"; String str2 = \"alphabets\"; findAndPrintUncommonChars(str1, str2); } }", "src": "\n// Java implementation to find the uncommon \n// characters of the two strings \nclass\nGFG \n{ \n\n\n// size of the hash table \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n// function to find the uncommon \n\n// characters of the two strings \n\nstatic\nvoid\nfindAndPrintUncommonChars(String str1, \n\nString str2) \n\n{ \n\n// mark presence of each character as 0 \n\n// in the hash table 'present[]' \n\nint\npresent[] = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\npresent[i] = \n0\n; \n\n} \n\n\nint\nl1 = str1.length(); \n\nint\nl2 = str2.length(); \n\n\n// for each character of str1, mark its \n\n// presence as 1 in 'present[]' \n\nfor\n(\nint\ni = \n0\n; i < l1; i++) \n\n{ \n\npresent[str1.charAt(i) - \n'a'\n] = \n1\n; \n\n} \n\n\n// for each character of str2 \n\nfor\n(\nint\ni = \n0\n; i < l2; i++) \n\n{ \n\n\n// if a character of str2 is also present \n\n// in str1, then mark its presence as -1 \n\nif\n(present[str2.charAt(i) - \n'a'\n] == \n1\n\n|| present[str2.charAt(i) - \n'a'\n] == -\n1\n) \n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = -\n1\n; \n\n} \n\n\n// else mark its presence as 2 \n\nelse\n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = \n2\n; \n\n} \n\n} \n\n\n// print all the uncommon characters \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\nif\n(present[i] == \n1\n|| present[i] == \n2\n) \n\n{ \n\nSystem.out.print((\nchar\n) (i + \n'a'\n) + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str1 = \n\"characters\"\n; \n\nString str2 = \n\"alphabets\"\n; \n\nfindAndPrintUncommonChars(str1, str2); \n\n} \n} \n\n// This code is contributed by Rajput-JI ", "index": 9, "complexity": 3}
{"back-translation": "class Solution { static class Node { int data; Node left, right; } static Node newNode(int num) { Node temp = new Node(); temp.data = num; temp.left = temp.right = null; return temp; } static Node insert(Node root, int key) { if (root == null) return newNode(key); if (root.data > key) root.left = insert(root.left, key); else root.right = insert(root.right, key); return root; } static void storeInorder(Node ptr, Vector < Integer > vect) { if (ptr == null) return; storeInorder(ptr.left, vect); vect.add(ptr.data); storeInorder(ptr.right, vect); } static void pairSumUtil(Vector < Integer > vect1, Vector < Integer > vect2, int sum) { int left = 0; int right = vect2.size() - 1; while (left < vect1.size() && right >= 0) { if (vect1.get(left) + vect2.get(right) == sum) { System.out.print(\"(\" + vect1.get(left) + \", \" + vect2.get(right) + \"), \"); left++; right--; } else if (vect1.get(left) + vect2.get(right) < sum) left++; else right--; } } static void pairSum(Node root1, Node root2, int sum) { Vector < Integer > vect1 = new Vector < Integer > (), vect2 = new Vector < Integer > (); storeInorder(root1, vect1); storeInorder(root2, vect2); pairSumUtil(vect1, vect2, sum); } public static void main(String args[]) { Node root1 = null; root1 = insert(root1, 8); root1 = insert(root1, 10); root1 = insert(root1, 3); root1 = insert(root1, 6); root1 = insert(root1, 1); root1 = insert(root1, 5); root1 = insert(root1, 7); root1 = insert(root1, 14); root1 = insert(root1, 13); Node root2 = null; root2 = insert(root2, 5); root2 = insert(root2, 18); root2 = insert(root2, 2); root2 = insert(root2, 1); root2 = insert(root2, 3); root2 = insert(root2, 4); int sum = 10; pairSum(root1, root2, sum); } }", "src": "\n// Java program to find pairs with given sum such \n// that one element of pair exists in one BST and \n// other in other BST. \nimport\njava.util.*; \nclass\nsolution \n{ \n\n// A binary Tree node \nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n// A utility function to create a new BST node \n// with key as given num \nstatic\nNode newNode(\nint\nnum) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = num; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n// A utility function to insert a given key to BST \nstatic\nNode insert(Node root, \nint\nkey) \n{ \n\nif\n(root == \nnull\n) \n\nreturn\nnewNode(key); \n\nif\n(root.data > key) \n\nroot.left = insert(root.left, key); \n\nelse\n\nroot.right = insert(root.right, key); \n\nreturn\nroot; \n} \n\n// store storeInorder traversal in auxiliary array \nstatic\nvoid\nstoreInorder(Node ptr, Vector<Integer> vect) \n{ \n\nif\n(ptr==\nnull\n) \n\nreturn\n; \n\nstoreInorder(ptr.left, vect); \n\nvect.add(ptr.data); \n\nstoreInorder(ptr.right, vect); \n} \n\n// Function to find pair for given sum in different bst \n// vect1.get() -. stores storeInorder traversal of first bst \n// vect2.get() -. stores storeInorder traversal of second bst \nstatic\nvoid\npairSumUtil(Vector<Integer> vect1, Vector<Integer> vect2, \n\nint\nsum) \n{ \n\n// Initialize two indexes to two different corners \n\n// of two Vectors. \n\nint\nleft = \n0\n; \n\nint\nright = vect2.size() - \n1\n; \n\n\n// find pair by moving two corners. \n\nwhile\n(left < vect1.size() && right >= \n0\n) \n\n{ \n\n// If we found a pair \n\nif\n(vect1.get(left) + vect2.get(right) == sum) \n\n{ \n\nSystem.out.print( \n\"(\"\n+vect1.get(left) + \n\", \"\n+ vect2.get(right) + \n\"), \"\n); \n\nleft++; \n\nright--; \n\n} \n\n\n// If sum is more, move to higher value in \n\n// first Vector. \n\nelse\nif\n(vect1.get(left) + vect2.get(right) < sum) \n\nleft++; \n\n\n// If sum is less, move to lower value in \n\n// second Vector. \n\nelse\n\nright--; \n\n} \n} \n\n// Prints all pairs with given \"sum\" such that one \n// element of pair is in tree with root1 and other \n// node is in tree with root2. \nstatic\nvoid\npairSum(Node root1, Node root2, \nint\nsum) \n{ \n\n// Store inorder traversals of two BSTs in two \n\n// Vectors. \n\nVector<Integer> vect1= \nnew\nVector<Integer>(), vect2= \nnew\nVector<Integer>(); \n\nstoreInorder(root1, vect1); \n\nstoreInorder(root2, vect2); \n\n\n// Now the problem reduces to finding a pair \n\n// with given sum such that one element is in \n\n// vect1 and other is in vect2. \n\npairSumUtil(vect1, vect2, sum); \n} \n\n// Driver program to run the case \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n// first BST \n\nNode root1 = \nnull\n; \n\nroot1 = insert(root1, \n8\n); \n\nroot1 = insert(root1, \n10\n); \n\nroot1 = insert(root1, \n3\n); \n\nroot1 = insert(root1, \n6\n); \n\nroot1 = insert(root1, \n1\n); \n\nroot1 = insert(root1, \n5\n); \n\nroot1 = insert(root1, \n7\n); \n\nroot1 = insert(root1, \n14\n); \n\nroot1 = insert(root1, \n13\n); \n\n\n// second BST \n\nNode root2 = \nnull\n; \n\nroot2 = insert(root2, \n5\n); \n\nroot2 = insert(root2, \n18\n); \n\nroot2 = insert(root2, \n2\n); \n\nroot2 = insert(root2, \n1\n); \n\nroot2 = insert(root2, \n3\n); \n\nroot2 = insert(root2, \n4\n); \n\n\nint\nsum = \n10\n; \n\npairSum(root1, root2, sum); \n} \n} \n//contributed by Arnab Kundu ", "index": 10, "complexity": 3}
{"back-translation": "import java.util.LinkedList;\nimport java.util.Queue;\n\nclass Solution {\n\nstatic class NodeDetails {\n\nint data;\nint min, max;\n}\n\nstatic boolean levelOrderIsOfBST(int arr[], int n) {\n\nif (n == 0)\nreturn true;\n\nQueue<NodeDetails> q = new LinkedList<>();\nint i = 0;\nNodeDetails newNode = new NodeDetails();\nnewNode.data = arr[i++];\nnewNode.min = Integer.MIN_VALUE;\nnewNode.max = Integer.MAX_VALUE;\nq.add(newNode);\nwhile (i != n && q.size() > 0) {\nNodeDetails temp = q.peek();\nq.remove();\nnewNode = new NodeDetails();\nif (i < n && (arr[i] < (int)temp.data && arr[i] > (int)temp.min)) {\nnewNode.data = arr[i++];\nnewNode.min = temp.min;\nnewNode.max = temp.data;\nq.add(newNode);\n}\nnewNode = new NodeDetails();\nif (i < n && (arr[i] > (int)temp.data && arr[i] < (int)temp.max)) {\nnewNode.data = arr[i++];\nnewNode.min = temp.data;\nnewNode.max = temp.max;\nq.add(newNode);\n}\n}\nif (i == n)\nreturn true;\nreturn false;\n}\n\npublic static void main(String args[]) {\nint arr[] = {7, 4, 12, 3, 6, 8, 1, 5, 10};\nint n = arr.length;\nif (levelOrderIsOfBST(arr, n))\nSystem.out.print(\"Yes\");\nelse\nSystem.out.print(\"No\");\n}\n}", "src": "\n// Java implementation to check if the given array \n// can represent Level Order Traversal of Binary \n// Search Tree \nimport\njava.util.*; \n\nclass\nSolution \n{ \n\n// to store details of a node like \n// node's data, 'min' and 'max' to obtain the \n// range of values where node's left and \n// right child's should lie \nstatic\nclass\nNodeDetails \n{ \n\nint\ndata; \n\nint\nmin, max; \n}; \n\n// function to check if the given array \n// can represent Level Order Traversal \n// of Binary Search Tree \nstatic\nboolean\nlevelOrderIsOfBST(\nint\narr[], \nint\nn) \n{ \n\n// if tree is empty \n\nif\n(n == \n0\n) \n\nreturn\ntrue\n; \n\n\n// queue to store NodeDetails \n\nQueue<NodeDetails> q = \nnew\nLinkedList<NodeDetails>(); \n\n\n// index variable to access array elements \n\nint\ni = \n0\n; \n\n\n// node details for the \n\n// root of the BST \n\nNodeDetails newNode=\nnew\nNodeDetails(); \n\nnewNode.data = arr[i++]; \n\nnewNode.min = Integer.MIN_VALUE; \n\nnewNode.max = Integer.MAX_VALUE; \n\nq.add(newNode); \n\n\n// until there are no more elements \n\n// in arr[] or queue is not empty \n\nwhile\n(i != n && q.size() > \n0\n) \n\n{ \n\n// extracting NodeDetails of a \n\n// node from the queue \n\nNodeDetails temp = q.peek(); \n\nq.remove(); \n\nnewNode = \nnew\nNodeDetails(); \n\n\n// check whether there are more elements \n\n// in the arr[] and arr[i] can be left child \n\n// of 'temp.data' or not \n\nif\n(i < n && (arr[i] < (\nint\n)temp.data && \n\narr[i] > (\nint\n)temp.min)) \n\n{ \n\n// Create NodeDetails for newNode \n\n/// and add it to the queue \n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.min; \n\nnewNode.max = temp.data; \n\nq.add(newNode); \n\n} \n\n\nnewNode=\nnew\nNodeDetails(); \n\n\n// check whether there are more elements \n\n// in the arr[] and arr[i] can be right child \n\n// of 'temp.data' or not \n\nif\n(i < n && (arr[i] > (\nint\n)temp.data && \n\narr[i] < (\nint\n)temp.max)) \n\n{ \n\n// Create NodeDetails for newNode \n\n/// and add it to the queue \n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.data; \n\nnewNode.max = temp.max; \n\nq.add(newNode); \n\n} \n\n} \n\n\n// given array represents level \n\n// order traversal of BST \n\nif\n(i == n) \n\nreturn\ntrue\n; \n\n\n// given array do not represent \n\n// level order traversal of BST \n\nreturn\nfalse\n; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n7\n, \n4\n, \n12\n, \n3\n, \n6\n, \n8\n, \n1\n, \n5\n, \n10\n}; \n\nint\nn = arr.length; \n\nif\n(levelOrderIsOfBST(arr, n)) \n\nSystem.out.print( \n\"Yes\"\n); \n\nelse\n\nSystem.out.print( \n\"No\"\n); \n\n} \n} \n\n// This code is contributed by Arnab Kundu ", "index": 12, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n \npublic class pillar {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\t\tint n = sc.nextInt(); \n\t\tint[] a = new int[200005]; \n\t\tfor (int i = 1; i <= n; i++) \n\t\t\ta[i] = sc.nextInt(); \n\t\tfor (int i = 2; i < n; i++) \n\t\t\tif (a[i - 1] > a[i] && a[i] < a[i + 1]) {\n\t\t\t\tSystem.out.println(\"NO\"); \n\t\t\t\treturn; \n\t\t\t} \n\t\tSystem.out.println(\"YES\"); \n\t} \n}\n", "src": "import java.util.Scanner;\n \npublic class pillar {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint a[]=new int[200005];\n\t\tfor (int i=1;i<=n;i++) \n\t\ta[i]=sc.nextInt();\n\t\tfor (int i=2;i<n;i++) \n\t\tif (a[i-1]>a[i]&&a[i]<a[i+1]) {\n\t\t\tSystem.out.println(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t}\n}\n\n", "index": 13, "complexity": 3}
{"back-translation": "import java.io.*; public class GFG { static void digitsNum(int N) { if (N == 0) System.out.println(\"0\"); if (N % 9 != 0) System.out.print((N % 9)); for (int i = 1; i <= (N / 9); ++i) System.out.print(\"9\"); for (int i = 1; i <= N; ++i) System.out.print(\"0\"); System.out.print(\"\"); } public static void main (String[] args) { int N = 5; System.out.print(\"The number is : \"); digitsNum(N); } }", "src": "\n// Java program to find smallest \n// number to find smallest number \n// with N as sum of digits and \n// divisible by 10^N. \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nvoid\ndigitsNum(\nint\nN) \n{ \n\n// If N = 0 the string will be 0 \n\nif\n(N == \n0\n) \n\nSystem.out.println(\n\"0\"\n); \n\n\n\n// If n is not perfectly divisible \n\n// by 9 output the remainder \n\nif\n(N % \n9\n!= \n0\n) \n\nSystem.out.print((N % \n9\n)); \n\n\n\n// Print 9 N/9 times \n\nfor\n(\nint\ni = \n1\n; i <= (N / \n9\n); ++i) \n\nSystem.out.print(\n\"9\"\n); \n\n\n\n// Append N zero's to the number so \n\n// as to make it divisible by 10^N \n\nfor\n(\nint\ni = \n1\n; i <= N; ++i) \n\nSystem.out.print(\n\"0\"\n); \n\nSystem.out.print(\n\"\"\n); \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nN = \n5\n; \n\nSystem.out.print(\n\"The number is : \"\n); \n\ndigitsNum(N); \n\n} \n} \n\n// This code is contributed by vt_m ", "index": 14, "complexity": 3}
{"back-translation": "class Solution { static int count = 0; static class Node { int data; Node left; Node right; } static Node newNode(int data) { Node node = new Node(); node.data = data; node.left = null; node.right = null; return (node); } static void NthInorder(Node node, int n) { if (node == null) return; if (count <= n) { NthInorder(node.left, n); count++; if (count == n) System.out.printf(\"%d \", node.data); NthInorder(node.right, n); } } public static void main(String args[]) { Node root = newNode(10); root.left = newNode(20); root.right = newNode(30); root.left.left = newNode(40); root.left.right = newNode(50); int n = 4; NthInorder(root, n); } }", "src": "\n// Java program for nth nodes of inorder traversals \n\nimport\njava.util. *; \n\nclass\nSolution \n{ \nstatic\nint\ncount =\n0\n; \n/* A binary tree node has data, pointer to left child \nand a pointer to right child */\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left; \n\nNode right; \n} \n\n/* Helper function that allocates a new node with the \ngiven data and null left and right pointers. */\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\n\nreturn\n(node); \n} \n\n\n/* Given a binary tree, print its nth nodes of inorder*/\nstatic\nvoid\nNthInorder( Node node, \nint\nn) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\nif\n(count <= n) { \n\n/* first recur on left child */\n\nNthInorder(node.left, n); \n\ncount++; \n\n\n// when count = n then print element \n\nif\n(count == n) \n\nSystem.out.printf(\n\"%d \"\n, node.data); \n\n\n/* now recur on right child */\n\nNthInorder(node.right, n); \n\n} \n} \n\n/* Driver program to test above functions*/\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n10\n); \n\nroot.left = newNode(\n20\n); \n\nroot.right = newNode(\n30\n); \n\nroot.left.left = newNode(\n40\n); \n\nroot.left.right = newNode(\n50\n); \n\n\nint\nn = \n4\n; \n\n\nNthInorder(root, n); \n} \n} \n\n// This code is contributed \n// by Arnab Kundu ", "index": 15, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class MyClass {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        int k = 0;\n        int m = 0;\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n            if (a[i] >= 0) {\n                a[i] = -a[i] - 1;\n            }\n            if (a[i] < m) {\n                m = a[i];\n                k = i;\n            }\n        }\n        if (n % 2 == 1) {\n            a[k] = -a[k] - 1;\n        }\n        for (int i = 0; i < n; i++) {\n            System.out.print(a[i] + \" \");\n        }\n    }\n}", "src": "import java.util.*;\n\npublic class MyClass {\n    public static void main(String args[]) {\n        Scanner sc= new Scanner(System.in);\n        int n=sc.nextInt();\n        int [] a= new int[n];\n        int k=0;\n        int m=0;\n        for (int i=0;i<n;i++){\n            a[i]=sc.nextInt();\n            if (a[i]>=0){\n                a[i]=-a[i]-1;\n            }\n            if (a[i]<m){\n                m=a[i];\n                k=i;\n            }\n        }\n        if (n%2==1){\n            a[k]=-a[k]-1;\n        }\n        for (int i=0;i<n;i++){\n            System.out.print(a[i]+\" \");\n        }\n    }\n}\n", "index": 19, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SFly {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader lector = new BufferedReader(new InputStreamReader(System.in));\n\t\tint planet = Integer.parseInt(lector.readLine());\n\t\tint ini = Integer.parseInt(lector.readLine());\n\t\tdouble peso = ini;\n\t\tint[] desp = new int[planet];\n\t\tint[] ater = new int[planet];\n\t\tString[] temp = lector.readLine().split(\" \");\n\t\tfor (int i = 0; i < planet; i++) {\n\t\t\tdesp[i] = Integer.parseInt(temp[i]);\n\t\t\tif (desp[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = lector.readLine().split(\" \");\n\t\tfor (int i = 0; i < planet; i++) {\n\t\t\ter[i] = Integer.parseInt(temp[i]);\n\t\t\tif (ater[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = null;\n\t\tint i = planet - 1;\n\t\tpeso = (peso * ater[0]) / (ater[0] - 1);\n\t\twhile (i > 0) {\n\t\t\tpeso = (peso * desp[i]) / (desp[i] - 1);\n\t\t\tpeso = (peso * ater[i]) / (ater[i] - 1);\n\t\t\ti--;\n\t\t}\n\t\tpeso = (peso * desp[0]) / (desp[0] - 1);\n\t\tpeso = peso - ini;\n\t\tSystem.out.println(peso);\n\t\tlector.close();\n\t}\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SFly {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader lector = new BufferedReader(new InputStreamReader(System.in));\n\t\tint planet = Integer.parseInt(lector.readLine());\n\t\tint ini = Integer.parseInt(lector.readLine());\n\t\tdouble peso = ini;\n\t\tint[] desp = new int[planet];\n\t\tint[] ater = new int[planet];\n\t\tString[] temp = lector.readLine().split(\" \");\t\t\n\t\tfor(int i=0; i<planet; i++) {\n\t\t\tdesp[i] = Integer.parseInt(temp[i]);\n\t\t\tif(desp[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = lector.readLine().split(\" \");\t\t\n\t\tfor(int i=0; i<planet; i++) {\n\t\t\tater[i] = Integer.parseInt(temp[i]);\n\t\t\tif(ater[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = null;\n\t\tint i=planet-1;\n\t\tpeso = (peso*ater[0])/(ater[0]-1);\n\t\twhile(i>0) {\n\t\t\tpeso = (peso*desp[i])/(desp[i]-1);\n\t\t\tpeso = (peso*ater[i])/(ater[i]-1);\n\t\t\ti--;\n\t\t}\n\t\tpeso = (peso*desp[0])/(desp[0]-1);\n\t\tpeso = peso - ini;\n\t\tSystem.out.println(peso);\n\t\tlector.close();\n\t}\n}", "index": 20, "complexity": 3}
{"back-translation": "public class GFG {\n    static int findMaxAverage(int[] arr, int n, int k) {\n        if (k > n)\n            return -1;\n        int sum = arr[0];\n        for (int i = 1; i < k; i++)\n            sum += arr[i];\n        int max_sum = sum, max_end = k - 1;\n        for (int i = k; i < n; i++) {\n            sum = sum + arr[i] - arr[i - k];\n            if (sum > max_sum) {\n                max_sum = sum;\n                max_end = i;\n            }\n        }\n        return max_end - k + 1;\n    }\n    public static void main(String[] args) {\n        int arr[] = {1, 12, -5, -6, 50, 3};\n        int k = 4;\n        int n = arr.length;\n        System.out.println(\"The maximum average\" + \" subarray of length \" + k + \" begins at index \" + findMaxAverage(arr, n, k));\n    }\n}", "src": "\n// Java program to find maximum average subarray \n// of given length. \n\nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Returns beginning index of maximum average \n\n// subarray of length 'k' \n\nstatic\nint\nfindMaxAverage(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n// Check if 'k' is valid \n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n// Compute sum of first 'k' elements \n\nint\nsum = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < k; i++) \n\nsum += arr[i]; \n\n\nint\nmax_sum = sum, max_end = k-\n1\n; \n\n\n// Compute sum of remaining subarrays \n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nsum = sum + arr[i] - arr[i-k]; \n\nif\n(sum > max_sum) \n\n{ \n\nmax_sum = sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n// Return starting index \n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.println( \n\"The maximum average\"\n\n+ \n\" subarray of length \"\n+ k \n\n+ \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "index": 21, "complexity": 3}
{"back-translation": "import java.util.ArrayList;\npublic class PrintPath {\n    public static boolean hasPath(Node root, ArrayList<Integer> arr, int x) {\n        if (root == null) return false;\n        arr.add(root.data);\n        if (root.data == x) return true;\n        if (hasPath(root.left, arr, x) || hasPath(root.right, arr, x)) return true;\n        arr.remove(arr.size() - 1);\n        return false;\n    }\n    public static void printPath(Node root, int x) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        if (hasPath(root, arr, x)) {\n            for (int i = 0; i < arr.size() - 1; i++) System.out.print(arr.get(i) + \"->\");\n            System.out.print(arr.get(arr.size() - 1));\n        } else System.out.print(\"No Path\");\n    }\n    public static void main(String args[]) {\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.right = new Node(3);\n        root.left.left = new Node(4);\n        root.left.right = new Node(5);\n        root.right.left = new Node(6);\n        root.right.right = new Node(7);\n        int x = 5;\n        printPath(root, x);\n    }\n}\nclass Node {\n    int data;\n    Node left, right;\n    Node(int data) {\n        this.data = data;\n        left = right = null;\n    }\n};", "src": "\n// Java implementation to print the path from root \n// to a given node in a binary tree \nimport\njava.util.ArrayList; \npublic\nclass\nPrintPath { \n\n\n// Returns true if there is a path from root \n\n// to the given node. It also populates \n\n// 'arr' with the given path \n\npublic\nstatic\nboolean\nhasPath(Node root, ArrayList<Integer> arr, \nint\nx) \n\n{ \n\n// if root is NULL \n\n// there is no path \n\nif\n(root==\nnull\n) \n\nreturn\nfalse\n; \n\n\n// push the node's value in 'arr' \n\narr.add(root.data); \n\n\n// if it is the required node \n\n// return true \n\nif\n(root.data == x) \n\nreturn\ntrue\n; \n\n\n// else check whether the required node lies \n\n// in the left subtree or right subtree of \n\n// the current node \n\nif\n(hasPath(root.left, arr, x) || \n\nhasPath(root.right, arr, x)) \n\nreturn\ntrue\n; \n\n\n// required node does not lie either in the \n\n// left or right subtree of the current node \n\n// Thus, remove current node's value from \n\n// 'arr'and then return false \n\narr.remove(arr.size()-\n1\n); \n\nreturn\nfalse\n; \n\n} \n\n\n// function to print the path from root to the \n\n// given node if the node lies in the binary tree \n\npublic\nstatic\nvoid\nprintPath(Node root, \nint\nx) \n\n{ \n\n// ArrayList to store the path \n\nArrayList<Integer> arr=\nnew\nArrayList<>(); \n\n\n// if required node 'x' is present \n\n// then print the path \n\nif\n(hasPath(root, arr, x)) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i<arr.size()-\n1\n; i++) \n\nSystem.out.print(arr.get(i)+\n\"->\"\n); \n\nSystem.out.print(arr.get(arr.size() - \n1\n)); \n\n} \n\n\n// 'x' is not present in the binary tree \n\nelse\n\nSystem.out.print(\n\"No Path\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.left = \nnew\nNode(\n6\n); \n\nroot.right.right = \nnew\nNode(\n7\n); \n\nint\nx=\n5\n; \n\nprintPath(root, x); \n\n} \n} \n\n// A node of binary tree \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\nleft=right=\nnull\n; \n\n} \n}; \n//This code is contributed by Gaurav Tiwari ", "index": 22, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class SonyaExhibition {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt();\n\t\tint[] arr = new int[]{0, 1};\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\tSystem.out.print(arr[i % 2]);\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n}", "src": "import java.util.*;\nimport java.io.*;\n\npublic class SonyaExhibition {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt();\n\t\tint[] arr = {0,1};\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tSystem.out.print(arr[i % 2]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n}\n", "index": 23, "complexity": 3}
{"back-translation": "class Node { int key; Node left, right; public Node(int key) { this.key = key; left = right = null; } } class Res { boolean res = false; } class BinaryTree { Node root; int count(Node node) { if (node == null) return 0; return count(node.left) + count(node.right) + 1; } int checkRec(Node root, int n, Res res) { if (root == null) return 0; int c = checkRec(root.left, n, res) + 1 + checkRec(root.right, n, res); if (c == n - c) res.res = true; return c; } boolean check(Node root) { int n = count(root); Res res = new Res(); checkRec(root, n, res); return res.res; } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(5); tree.root.left = new Node(1); tree.root.right = new Node(6); tree.root.left.left = new Node(3); tree.root.right.left = new Node(7); tree.root.right.right = new Node(4); if (tree.check(tree.root) == true) System.out.println(\"YES\"); else System.out.println(\"NO\"); } }", "src": "\n// Java program to check if there exist an edge whose \n// removal creates two trees of same size \n\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n\n\npublic\nNode(\nint\nkey) \n\n{ \n\nthis\n.key = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nRes \n{ \n\nboolean\nres = \nfalse\n; \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n// To calculate size of tree with given root \n\nint\ncount(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\nreturn\ncount(node.left) + count(node.right) + \n1\n; \n\n} \n\n\n// This function returns size of tree rooted with given \n\n// root. It also set \"res\" as true if there is an edge \n\n// whose removal divides tree in two halves. \n\n// n is size of tree \n\nint\ncheckRec(Node root, \nint\nn, Res res) \n\n{ \n\n// Base case \n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\n\n// Compute sizes of left and right children \n\nint\nc = checkRec(root.left, n, res) + \n1\n\n+ checkRec(root.right, n, res); \n\n\n// If required property is true for current node \n\n// set \"res\" as true \n\nif\n(c == n - c) \n\nres.res = \ntrue\n; \n\n\n// Return size \n\nreturn\nc; \n\n} \n\n\n// This function mainly uses checkRec() \n\nboolean\ncheck(Node root) \n\n{ \n\n// Count total nodes in given tree \n\nint\nn = count(root); \n\n\n// Initialize result and recursively check all nodes \n\nRes res = \nnew\nRes(); \n\ncheckRec(root, n, res); \n\n\nreturn\nres.res; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n1\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nif\n(tree.check(tree.root) == \ntrue\n) \n\nSystem.out.println(\n\"YES\"\n); \n\nelse\n\nSystem.out.println(\n\"NO\"\n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "index": 25, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class helloWorld {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt += in.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt -= in.nextInt();\n\t\t}\n\t\t\n\t\tif (cnt < 0) {\n\t\t\tans = \"No\";\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}\n", "src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}\n", "index": 26, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\nScanner sc = new Scanner(System.in);\n int[][] x = new int [200010][10];\nString a = sc.nextLine();\nString b = sc.nextLine();\n int n = a.length();\nint m = b.length();\n for (int i = 1; i <= m; i++) {\n for (int j = 0; j < 2; j++) {\nx[i][j] = x[i - 1][j];\n }\n++x[i][b.charAt(i - 1) - '0'];\n }\n long res = 0;\nfor (int i = 0, c; i < n; i++) {\nc = a.charAt(i) - '0';\nfor (int j = 0; j < 2; j++) {\nres += Math.abs(c - j) * (x[m - n + i + 1][j] - x[i][j]);\n }\n}\nSystem.out.println(res);\n}\n}", "src": "import java.util.*;\n \npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\t int[][] x = new int [200010][10];\n     String a = sc.nextLine(); \n     String b = sc.nextLine(); \n \t  int n = a.length();\n\t  int m = b.length();\n       for (int i = 1; i <= m; i++) {\n         for (int j = 0; j < 2; j++) {\n           x[i][j] = x[i - 1][j];\n         }\n         ++x[i][b.charAt(i - 1) - '0'];\n       }\n       long res = 0;\n        for (int i = 0, c; i < n; i++) {\n          c = a.charAt(i) - '0';\n           for (int j = 0; j < 2; j++) {\n             res += Math.abs(c - j) * (x[m - n + i + 1][j] - x[i][j]);\n           }\n        }\n         System.out.println(res);\n  }\n}", "index": 28, "complexity": 3}
{"back-translation": "class PairInSortedRotated {\n    static boolean pairInSortedRotated(int arr[], int n, int x) {\n        int i;\n        for (i = 0; i < n - 1; i++) {\n            if (arr[i] > arr[i + 1]) {\n                break;\n            }\n        }\n        int l = (i + 1) % n;\n        int r = i;\n        while (l != r) {\n            if (arr[l] + arr[r] == x) {\n                return true;\n            }\n            if (arr[l] + arr[r] < x) {\n                l = (l + 1) % n;\n            } else {\n                r = (n + r - 1) % n;\n            }\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        int arr[] = {11, 15, 6, 8, 9, 10};\n        int sum = 16;\n        int n = arr.length;\n        if (pairInSortedRotated(arr, n, sum)) {\n            System.out.print(\"Array has two elements\" + \" with sum 16\");\n        } else {\n            System.out.print(\"Array doesn't have two\" + \" elements with sum 16 \");\n        }\n    }\n}", "src": "\n// Java program to find a pair with a given \n// sum in a sorted and rotated array \nclass\nPairInSortedRotated \n{ \n\n// This function returns true if arr[0..n-1] \n\n// has a pair with sum equals to x. \n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n// Find the pivot element \n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n// l is now index of \n\n// smallest element \n\n\nint\nr = i; \n// r is now index of largest \n\n//element \n\n\n// Keep moving either l or r till they meet \n\nwhile\n(l != r) \n\n{ \n\n// If we find a pair with sum x, we \n\n// return true \n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n// If current pair sum is less, move \n\n// to the higher sum \n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n// Move to the lower sum side \n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n} \n/*This code is contributed by Prakriti Gupta*/", "index": 29, "complexity": 3}
{"back-translation": "public class LinkedList { Node head; Node left; class Node { char data; Node next; Node(char d) { data = d; next = null; } } Node isPalindromeUtil(Node right) { left = head; if (right == null) return true; boolean isp = isPalindromeUtil(right.next); if (isp == false) return false; boolean isp1 = (right.data == (left).data); left = left.next; return isp1; } boolean isPalindrome(Node head) { boolean result = isPalindromeUtil(head); return result; } public void push(char new_data) { Node new_node = new Node(new_data); new_node.next = head; head = new_node; } void printList(Node ptr) { while (ptr != null) { System.out.print(ptr.data + \"->\"); ptr = ptr.next; } System.out.println(\"NULL\"); } public static void main(String[] args) { LinkedList llist = new LinkedList(); char str[] = { 'a', 'b', 'a', 'c', 'a', 'b', 'a' }; String string = new String(str); for (int i = 0; i < 7; i++) { llist.push(str[i]); llist.printList(llist.head); if (llist.isPalindrome(llist.head) != false) { System.out.println(\"Is Palindrome\"); System.out.println(\"\"); } else { System.out.println(\"Not Palindrome\"); System.out.println(\"\"); } } } }", "src": "\n/* Java program to check if linked list is palindrome recursively */\n\nclass\nLinkedList { \n\nNode head; \n// head of list \n\nNode left; \n\n\n/* Linked list Node*/\n\nclass\nNode { \n\nchar\ndata; \n\nNode next; \n\n\nNode(\nchar\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n// Initial parameters to this function are &head and head \n\nboolean\nisPalindromeUtil(Node right) \n\n{ \n\nleft = head; \n\n\n/* stop recursion when right becomes NULL */\n\nif\n(right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n/* If sub-list is not palindrome then no need to \n\ncheck for current left and right, return false */\n\nboolean\nisp = isPalindromeUtil(right.next); \n\nif\n(isp == \nfalse\n) \n\nreturn\nfalse\n; \n\n\n/* Check values at current left and right */\n\nboolean\nisp1 = (right.data == (left).data); \n\n\n/* Move left to next node */\n\nleft = left.next; \n\n\nreturn\nisp1; \n\n} \n\n\n// A wrapper over isPalindromeUtil() \n\nboolean\nisPalindrome(Node head) \n\n{ \n\nboolean\nresult = isPalindromeUtil(head); \n\nreturn\nresult; \n\n} \n\n\n/* Push a node to linked list. Note that this function \n\nchanges the head */\n\npublic\nvoid\npush(\nchar\nnew_data) \n\n{ \n\n/* Allocate the Node & \n\nPut in the data */\n\nNode new_node = \nnew\nNode(new_data); \n\n\n/* link the old list off the new one */\n\nnew_node.next = head; \n\n\n/* Move the head to point to new Node */\n\nhead = new_node; \n\n} \n\n\n// A utility function to print a given linked list \n\nvoid\nprintList(Node ptr) \n\n{ \n\nwhile\n(ptr != \nnull\n) { \n\nSystem.out.print(ptr.data + \n\"->\"\n); \n\nptr = ptr.next; \n\n} \n\nSystem.out.println(\n\"NULL\"\n); \n\n} \n\n\n/* Driver program to test the above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n/* Start with the empty list */\n\nLinkedList llist = \nnew\nLinkedList(); \n\n\nchar\nstr[] = { \n'a'\n, \n'b'\n, \n'a'\n, \n'c'\n, \n'a'\n, \n'b'\n, \n'a'\n}; \n\nString string = \nnew\nString(str); \n\nfor\n(\nint\ni = \n0\n; i < \n7\n; i++) { \n\nllist.push(str[i]); \n\nllist.printList(llist.head); \n\nif\n(llist.isPalindrome(llist.head) != \nfalse\n) { \n\nSystem.out.println(\n\"Is Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"Not Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n} \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "index": 30, "complexity": 3}
{"back-translation": "class GFG {\n\n    static void rearrange(int[] arr, int n) {\n\n        int temp;\n\n        for (int i = 0; i < n - 1; i++) {\n\n            if (i % 2 == 0 && arr[i] > arr[i + 1]) {\n                temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n            }\n\n            if (i % 2 != 0 && arr[i] < arr[i + 1]) {\n                temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n            }\n        }\n    }\n\n    static void printArray(int[] arr, int size) {\n        for (int i = 0; i < size; i++)\n            System.out.print(arr[i] + \" \");\n\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        int[] arr = { 6, 4, 2, 1, 8, 3 };\n        int n = arr.length;\n\n        System.out.print(\"Before rearranging: \\n\");\n        printArray(arr, n);\n\n        rearrange(arr, n);\n\n        System.out.print(\"After rearranging: \\n\");\n        printArray(arr, n);\n    }\n}", "src": "\n// Java code to rearrange an array such \n// that even index elements are smaller \n// and odd index elements are greater \n// than their next. \n\nclass\nGFG { \n\n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\nint\ntemp; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) { \n\nif\n(i % \n2\n== \n0\n&& arr[i] > arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\nif\n(i % \n2\n!= \n0\n&& arr[i] < arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\n} \n\n} \n\n\n/* Utility that prints out an array in \n\na line */\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n6\n, \n4\n, \n2\n, \n1\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.print(\n\"Before rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"After rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "index": 31, "complexity": 3}
{"back-translation": "import java.util.Arrays; public class GFG { static int arr[] = {100, 1000, 100, 1000, 1}; static int sum[] = new int[10000]; static int maxSumWO3Consec(int n) { if (sum[n] != -1) return sum[n]; if (n == 0) return sum[n] = 0; if (n == 1) return sum[n] = arr[0]; if (n == 2) return sum[n] = arr[1] + arr[0]; return sum[n] = Math.max(Math.max(maxSumWO3Consec(n - 1), maxSumWO3Consec(n - 2) + arr[n - 1]), arr[n - 2] + arr[n - 1] + maxSumWO3Consec(n - 3)); } public static void main(String[] args) { int n = arr.length; Arrays.fill(sum, -1); System.out.println(maxSumWO3Consec(n)); } }", "src": "\n// Java program to find the maximum \n// sum such that no three are \n// consecutive using recursion. \nimport\njava.util.Arrays; \n\nclass\nGFG \n{ \n\nstatic\nint\narr[] = {\n100\n, \n1000\n, \n100\n, \n1000\n, \n1\n}; \nstatic\nint\nsum[] = \nnew\nint\n[\n10000\n]; \n\n// Returns maximum subsequence \n// sum such that no three \n// elements are consecutive \nstatic\nint\nmaxSumWO3Consec(\nint\nn) \n{ \n\nif\n(sum[n] != -\n1\n) \n\nreturn\nsum[n]; \n\n\n//Base cases (process first three elements) \n\n\nif\n(n == \n0\n) \n\nreturn\nsum[n] = \n0\n; \n\n\nif\n(n == \n1\n) \n\nreturn\nsum[n] = arr[\n0\n]; \n\n\nif\n(n == \n2\n) \n\nreturn\nsum[n] = arr[\n1\n] + arr[\n0\n]; \n\n\n// Process rest of the elements \n\n// We have three cases \n\nreturn\nsum[n] = Math.max(Math.max(maxSumWO3Consec(n - \n1\n), \n\nmaxSumWO3Consec(n - \n2\n) + arr[n - \n1\n]), \n\narr[n - \n2\n] + arr[n - \n1\n] + maxSumWO3Consec(n - \n3\n)); \n\n\n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = arr.length; \n\nArrays.fill(sum, -\n1\n); \n\nSystem.out.println(maxSumWO3Consec(n)); \n} \n} \n\n// This code is contributed by Rajput-Ji ", "index": 32, "complexity": 3}
{"back-translation": "import java.util.*;import java.io.*;import java.math.BigInteger;public class Main {static final long mod = (int) 1e9 + 7;public static void main(String[] args) throws Exception {FastReader in = new FastReader();PrintWriter pw = new PrintWriter(System.out);int n = in.nextInt();long ans = 0;for (int i = 2; 2 * i <= n; i++) {ans += i * (n / i - 1);}ans *= 4;pw.print(ans);pw.flush();}}class pair {int f, s;}class FastReader {BufferedReader br;StringTokenizer st;public FastReader() {br = new BufferedReader(new InputStreamReader(System.in));}public String next() throws IOException {if (st == null || !st.hasMoreElements()) {st = new StringTokenizer(br.readLine());}return st.nextToken();}public int nextInt() throws IOException {return Integer.parseInt(next());}public long nextLong() throws IOException {return Long.parseLong(next());}}", "src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class Main\n{\n    static final long mod=(int)1e9+7;\n    public static void main(String[] args) throws Exception\n    {\n    \tFastReader in=new FastReader();\n    \tPrintWriter pw=new PrintWriter(System.out);\n    \tint n=in.nextInt();\n    \tlong ans=0;\n    \tfor(int i=2;2*i<=n;i++)\n    \t{\n    \t\tans+=i*(n/i-1);\n    \t}\n    \tans*=4;\n    \tpw.print(ans);\n    \tpw.flush();\n    }\n}\n\nclass pair\n{\n\tint f,s;\n}\n\nclass FastReader\n{\n    BufferedReader br;\n    StringTokenizer st;\n \n    public FastReader()\n    {\n        br=new BufferedReader(new InputStreamReader(System.in));\n    }\n \n    public String next() throws IOException\n    {\n        if(st==null || !st.hasMoreElements())\n        {\n            st=new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n \n    public int nextInt() throws IOException\n    {\n        return Integer.parseInt(next());\n    }\n \n    public long nextLong() throws IOException\n    {\n        return Long.parseLong(next());\n    }\n}", "index": 33, "complexity": 3}
{"back-translation": "class Tree { Node root; static class Node { int data; Node left, right; Node(int data) { this.data = data; this.left = null; this.right = null; } } public Node insertLevelOrder(int[] arr, Node root, int i) { if (i < arr.length) { Node temp = new Node(arr[i]); root = temp; root.left = insertLevelOrder(arr, root.left, 2 * i + 1); root.right = insertLevelOrder(arr, root.right, 2 * i + 2); } return root; } public void inOrder(Node root) { if (root != null) { inOrder(root.left); System.out.print(root.data + \" \"); inOrder(root.right); } } public static void main(String args[]) { Tree t2 = new Tree(); int arr[] = { 1, 2, 3, 4, 5, 6, 6, 6, 6 }; t2.root = t2.insertLevelOrder(arr, t2.root, 0); t2.inOrder(t2.root); } }", "src": "\n// Java program to construct binary tree from \n// given array in level order fashion \n\npublic\nclass\nTree { \n\nNode root; \n\n\n// Tree Node \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.left = \nnull\n; \n\nthis\n.right = \nnull\n; \n\n} \n\n} \n\n\n// Function to insert nodes in level order \n\npublic\nNode insertLevelOrder(\nint\n[] arr, Node root, \n\nint\ni) \n\n{ \n\n// Base case for recursion \n\nif\n(i < arr.length) { \n\nNode temp = \nnew\nNode(arr[i]); \n\nroot = temp; \n\n\n// insert left child \n\nroot.left = insertLevelOrder(arr, root.left, \n\n2\n* i + \n1\n); \n\n\n// insert right child \n\nroot.right = insertLevelOrder(arr, root.right, \n\n2\n* i + \n2\n); \n\n} \n\nreturn\nroot; \n\n} \n\n\n// Function to print tree nodes in InOrder fashion \n\npublic\nvoid\ninOrder(Node root) \n\n{ \n\nif\n(root != \nnull\n) { \n\ninOrder(root.left); \n\nSystem.out.print(root.data + \n\" \"\n); \n\ninOrder(root.right); \n\n} \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nTree t2 = \nnew\nTree(); \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n6\n, \n6\n, \n6\n}; \n\nt2.root = t2.insertLevelOrder(arr, t2.root, \n0\n); \n\nt2.inOrder(t2.root); \n\n} \n} ", "index": 34, "complexity": 3}
{"back-translation": "class GFG { static int findMedian(int[] arr, int i, int n) { if (i <= n) Arrays.sort(arr, i, n); else Arrays.sort(arr, n, i); return arr[n / 2]; } static int kthSmallest(int[] arr, int l, int r, int k) { if (k > 0 && k <= r - l + 1) { int n = r - l + 1; int i; int[] median = new int[(n + 4) / 5]; for (i = 0; i < n / 5; i++) median[i] = findMedian(arr, l + i * 5, 5); if (i * 5 < n) { median[i] = findMedian(arr, l + i * 5, n % 5); i++; } int medOfMed = (i == 1) ? median[i - 1] : kthSmallest(median, 0, i - 1, i / 2); int pos = partition(arr, l, r, medOfMed); if (pos - l == k - 1) return arr[pos]; if (pos - l > k - 1) return kthSmallest(arr, l, pos - 1, k); return kthSmallest(arr, pos + 1, r, k - pos + l - 1); } return Integer.MAX_VALUE; } static int[] swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } static int partition(int[] arr, int l, int r, int x) { int i; for (i = l; i < r; i++) if (arr[i] == x) break; swap(arr, i, r); i = l; for (int j = l; j <= r - 1; j++) { if (arr[j] <= x) { swap(arr, i, j); i++; } } swap(arr, i, r); return i; } public static void main(String[] args) { int arr[] = { 12, 3, 5, 7, 4, 19, 26 }; int n = arr.length, k = 3; System.out.println( \"K'th smallest element is \" + kthSmallest(arr, 0, n - 1, k)); } }", "src": "\n// Java implementation of worst \n// case linear time algorithm \n// to find k'th smallest element \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n// int partition(int arr[], int l, int r, int k); \n\n// A simple function to find median of arr[]. This is called \n// only for an array of size 5 in this program. \nstatic\nint\nfindMedian(\nint\narr[], \nint\ni,\nint\nn) \n{ \n\nif\n(i <= n) \n\nArrays.sort(arr, i, n); \n// Sort the array \n\nelse\n\nArrays.sort(arr, n, i); \n\nreturn\narr[n/\n2\n]; \n// Return middle element \n} \n\n// Returns k'th smallest element \n// in arr[l..r] in worst case \n// linear time. ASSUMPTION: ALL \n// ELEMENTS IN ARR[] ARE DISTINCT \nstatic\nint\nkthSmallest(\nint\narr[], \nint\nl, \nint\nr, \nint\nk) \n{ \n\n// If k is smaller than \n\n// number of elements in array \n\nif\n(k > \n0\n&& k <= r - l + \n1\n) \n\n{ \n\nint\nn = r - l + \n1\n; \n// Number of elements in arr[l..r] \n\n\n// Divide arr[] in groups of size 5, \n\n// calculate median of every group \n\n// and store it in median[] array. \n\nint\ni; \n\n\n// There will be floor((n+4)/5) groups; \n\nint\n[]median = \nnew\nint\n[(n + \n4\n) / \n5\n]; \n\nfor\n(i = \n0\n; i < n/\n5\n; i++) \n\nmedian[i] = findMedian(arr,l + i * \n5\n, \n5\n); \n\n\n// For last group with less than 5 elements \n\nif\n(i*\n5\n< n) \n\n{ \n\nmedian[i] = findMedian(arr,l + i * \n5\n, n % \n5\n); \n\ni++; \n\n} \n\n\n// Find median of all medians using recursive call. \n\n// If median[] has only one element, then no need \n\n// of recursive call \n\nint\nmedOfMed = (i == \n1\n)? median[i - \n1\n]: \n\nkthSmallest(median, \n0\n, i - \n1\n, i / \n2\n); \n\n\n// Partition the array around a random element and \n\n// get position of pivot element in sorted array \n\nint\npos = partition(arr, l, r, medOfMed); \n\n\n// If position is same as k \n\nif\n(pos-l == k - \n1\n) \n\nreturn\narr[pos]; \n\nif\n(pos-l > k - \n1\n) \n// If position is more, recur for left \n\nreturn\nkthSmallest(arr, l, pos - \n1\n, k); \n\n\n// Else recur for right subarray \n\nreturn\nkthSmallest(arr, pos + \n1\n, r, k - pos + l - \n1\n); \n\n} \n\n\n// If k is more than number of elements in array \n\nreturn\nInteger.MAX_VALUE; \n} \n\nstatic\nint\n[] swap(\nint\n[]arr, \nint\ni, \nint\nj) \n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n} \n\n// It searches for x in arr[l..r], and \n// partitions the array around x. \nstatic\nint\npartition(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n{ \n\n// Search for x in arr[l..r] and move it to end \n\nint\ni; \n\nfor\n(i = l; i < r; i++) \n\nif\n(arr[i] == x) \n\nbreak\n; \n\nswap(arr, i, r); \n\n\n// Standard partition algorithm \n\ni = l; \n\nfor\n(\nint\nj = l; j <= r - \n1\n; j++) \n\n{ \n\nif\n(arr[j] <= x) \n\n{ \n\nswap(arr, i, j); \n\ni++; \n\n} \n\n} \n\nswap(arr, i, r); \n\nreturn\ni; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n12\n, \n3\n, \n5\n, \n7\n, \n4\n, \n19\n, \n26\n}; \n\nint\nn = arr.length, k = \n3\n; \n\nSystem.out.println(\n\"K'th smallest element is \"\n\n+ kthSmallest(arr, \n0\n, n - \n1\n, k)); \n} \n} \n\n// This code has been contributed by 29AjayKumar ", "index": 35, "complexity": 3}
{"back-translation": "class Solution { static class INT { int data; INT(int d) { data = d; } } static void findPostOrderUtil(int[] pre, int n, int minval, int maxval, INT preIndex) { if (preIndex.data == n) return; if (pre[preIndex.data] < minval || pre[preIndex.data] > maxval) { return; } int val = pre[preIndex.data]; preIndex.data++; findPostOrderUtil(pre, n, minval, val, preIndex); findPostOrderUtil(pre, n, val, maxval, preIndex); System.out.print(val + \" \"); } static void findPostOrder(int[] pre, int n) { INT preIndex = new INT(0); findPostOrderUtil(pre, n, Integer.MIN_VALUE, Integer.MAX_VALUE, preIndex); } public static void main(String args[]) { int[] pre = {40, 30, 35, 80, 100}; int n = pre.length; findPostOrder(pre, n); } }", "src": "\n// Java program for finding postorder \n// traversal of BST from preorder traversal \n\nimport\njava.util.* ; \n\nclass\nSolution \n{ \nstatic\nclass\nINT \n{ \n\nint\ndata; \n\nINT(\nint\nd) \n\n{ \n\ndata=d; \n\n} \n} \n\n// Function to find postorder traversal from \n// preorder traversal. \nstatic\nvoid\nfindPostOrderUtil(\nint\npre[], \nint\nn, \nint\nminval, \n\nint\nmaxval, INT preIndex) \n{ \n\n\n// If entire preorder array is traversed then \n\n// return as no more element is left to be \n\n// added to post order array. \n\nif\n(preIndex.data == n) \n\nreturn\n; \n\n\n// If array element does not lie in range specified, \n\n// then it is not part of current subtree. \n\nif\n(pre[preIndex.data] < minval || pre[preIndex.data] > maxval) { \n\nreturn\n; \n\n} \n\n\n// Store current value, to be printed later, after \n\n// printing left and right subtrees. Increment \n\n// preIndex to find left and right subtrees, \n\n// and pass this updated value to recursive calls. \n\nint\nval = pre[preIndex.data]; \n\npreIndex.data++; \n\n\n// All elements with value between minval and val \n\n// lie in left subtree. \n\nfindPostOrderUtil(pre, n, minval, val, preIndex); \n\n\n// All elements with value between val and maxval \n\n// lie in right subtree. \n\nfindPostOrderUtil(pre, n, val, maxval, preIndex); \n\n\nSystem.out.print( val + \n\" \"\n); \n} \n\n// Function to find postorder traversal. \nstatic\nvoid\nfindPostOrder(\nint\npre[], \nint\nn) \n{ \n\n\n// To store index of element to be \n\n// traversed next in preorder array. \n\n// This is passed by reference to \n\n// utility function. \n\nINT preIndex = \nnew\nINT(\n0\n); \n\n\nfindPostOrderUtil(pre, n, Integer.MIN_VALUE, \n\nInteger.MAX_VALUE, preIndex); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\npre[] = { \n40\n, \n30\n, \n35\n, \n80\n, \n100\n}; \n\n\nint\nn = pre.length; \n\n\n// Calling function \n\nfindPostOrder(pre, n); \n} \n} \n\n// This code is contributed \n// by Arnab Kundu ", "index": 38, "complexity": 3}
{"back-translation": "public class GFG { static int maxSumWO3Consec(int arr[], int n) { int sum[] = new int[n]; if (n >= 1) sum[0] = arr[0]; if (n >= 2) sum[1] = arr[0] + arr[1]; if (n > 2) sum[2] = Math.max(sum[1], Math.max(arr[1] + arr[2], arr[0] + arr[2])); for (int i = 3; i < n; i++) sum[i] = Math.max(Math.max(sum[i - 1], sum[i - 2] + arr[i]), arr[i] + arr[i - 1] + sum[i - 3]); return sum[n - 1]; } public static void main(String[] args) { int arr[] = { 100, 1000, 100, 1000, 1 }; int n = arr.length; System.out.println(maxSumWO3Consec(arr, n)); } }", "src": "\n// java program to find the maximum sum \n// such that no three are consecutive \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Returns maximum subsequence sum such that no three \n\n// elements are consecutive \n\nstatic\nint\nmaxSumWO3Consec(\nint\narr[], \nint\nn) \n\n{ \n\n// Stores result for subarray arr[0..i], i.e., \n\n// maximum possible sum in subarray arr[0..i] \n\n// such that no three elements are consecutive. \n\nint\nsum[] = \nnew\nint\n[n]; \n\n\n// Base cases (process first three elements) \n\nif\n(n >= \n1\n) \n\nsum[\n0\n] = arr[\n0\n]; \n\n\nif\n(n >= \n2\n) \n\nsum[\n1\n] = arr[\n0\n] + arr[\n1\n]; \n\n\nif\n(n > \n2\n) \n\nsum[\n2\n] = Math.max(sum[\n1\n], Math.max(arr[\n1\n] + arr[\n2\n], arr[\n0\n] + arr[\n2\n])); \n\n\n// Process rest of the elements \n\n// We have three cases \n\n// 1) Exclude arr[i], i.e., sum[i] = sum[i-1] \n\n// 2) Exclude arr[i-1], i.e., sum[i] = sum[i-2] + arr[i] \n\n// 3) Exclude arr[i-2], i.e., sum[i-3] + arr[i] + arr[i-1] \n\nfor\n(\nint\ni = \n3\n; i < n; i++) \n\nsum[i] = Math.max(Math.max(sum[i - \n1\n], sum[i - \n2\n] + arr[i]), \n\narr[i] + arr[i - \n1\n] + sum[i - \n3\n]); \n\n\nreturn\nsum[n - \n1\n]; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n100\n, \n1000\n, \n100\n, \n1000\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSumWO3Consec(arr, n)); \n\n} \n} \n\n// This code is contributed by vt_m ", "index": 39, "complexity": 3}
{"back-translation": "import java.io.OutputStream; import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.util.InputMismatchException; import java.io.IOException; import java.io.InputStream; public class Main { public static void main(String[] args) { InputStream inputStream = System.in; OutputStream outputStream = System.out; InputReader in = new InputReader(inputStream); PrintWriter out = new PrintWriter(outputStream); CBanhMi solver = new CBanhMi(); solver.solve(1, in, out); out.close(); } static class CBanhMi { long mod = (long)1e9 + 7; public void solve(int testNumber, InputReader in, PrintWriter out) { int n = in.nextInt(); int q = in.nextInt(); long[] two = new long[n + 1]; two[0] = 1; for(int i = 1; i <= n; ++i) { two[i] = (two[i - 1] * 2L) % mod; } char[] s = in.nextCharArray(); int[] acc = new int[n + 1]; for(int i = 1; i <= n; ++i) { acc[i] = s[i - 1] == '0' ? 0 : 1; acc[i] += acc[i - 1]; } while(q-- > 0) { int f = in.nextInt(); int t = in.nextInt(); int ones = acc[t] - acc[f - 1]; int zeros = (t - f + 1) - ones; if(ones == 0) { out.println(0); } else { long ans = two[t - f + 1] - (zeros > 0 ? two[zeros] : 0); if(zeros == 0) { --ans; } ans = (ans + mod) % mod; out.println(ans); } } } } static class InputReader implements FastIO { private InputStream stream; private static final int DEFAULT_BUFFER_SIZE = 1 << 16; private static final int EOF = -1; private byte[] buf = new byte[DEFAULT_BUFFER_SIZE]; private int curChar; private int numChars; public InputReader(InputStream stream) { this.stream = stream; } public int read() { if(this.numChars == EOF) { throw new UnknownError(); } else { if(this.curChar >= this.numChars) { this.curChar = 0; try { this.numChars = this.stream.read(this.buf); } catch(IOException ex) { throw new InputMismatchException(); } if(this.numChars <= 0) { return EOF; } } return this.buf[this.curChar++]; } } public int nextInt() { int c; for(c = this.read(); isSpaceChar(c); c = this.read()) { } byte sgn = 1; if(c == 45) { sgn = -1; c = this.read(); } int res = 0; while(c >= 48 && c <= 57) { res *= 10; res += c - 48; c = this.read(); if(isSpaceChar(c)) { return res * sgn; } } throw new InputMismatchException(); } public String next() { int c; while(isSpaceChar(c = this.read())) { } StringBuilder result = new StringBuilder(); result.appendCodePoint(c); while(!isSpaceChar(c = this.read())) { result.appendCodePoint(c); } return result.toString(); } public static boolean isSpaceChar(int c) { return c == 32 || c == 10 || c == 13 || c == 9 || c == EOF; } public char[] nextCharArray() { return next().toCharArray(); } } static interface FastIO { } }", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author MaxHeap\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    CBanhMi solver = new CBanhMi();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class CBanhMi {\n\n    long mod = (long) (1e9 + 7);\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n      int n = in.nextInt();\n      int q = in.nextInt();\n      long[] two = new long[n + 1];\n      two[0] = 1;\n      for (int i = 1; i <= n; ++i) {\n        two[i] = (two[i - 1] * 2L);\n        two[i] %= mod;\n      }\n\n      char[] s = in.nextCharArray();\n      int[] acc = new int[n + 1];\n      for (int i = 1; i <= n; ++i) {\n        acc[i] = s[i - 1] == '0' ? 0 : 1;\n        acc[i] += acc[i - 1];\n      }\n      // 0 0 1 1 | 1: 1 1 2| 2: 2 3| 4: 5| 9\n      // 0 1 1 1| 1: 1 2 2| 2: 3 3| 5: 6| 11\n      // 0 1 1 wwqwq| 1: 1 2 2| 3: 5 3| 8: 8| 16\n      // 0 0 1 1| 1: 1 1 2| 3: 3 3| 6: 6| 12\n      // 0 0 0 1| 1: 1 1 1| 2: 2 2| 4: 4| 8\n      while (q-- > 0) {\n        int f = in.nextInt();\n        int t = in.nextInt();\n        int ones = acc[t] - acc[f - 1];\n        int zeros = (t - f + 1) - ones;\n        if (ones == 0) {\n          out.println(0);\n        } else {\n          long ans = two[t - f + 1] - (zeros > 0 ? two[zeros] : 0);\n          if (zeros == 0) {\n            --ans;\n          }\n          ans = (ans + mod) % mod;\n          out.println(ans);\n        }\n      }\n    }\n\n  }\n\n  static class InputReader implements FastIO {\n\n    private InputStream stream;\n    private static final int DEFAULT_BUFFER_SIZE = 1 << 16;\n    private static final int EOF = -1;\n    private byte[] buf = new byte[DEFAULT_BUFFER_SIZE];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (this.numChars == EOF) {\n        throw new UnknownError();\n      } else {\n        if (this.curChar >= this.numChars) {\n          this.curChar = 0;\n\n          try {\n            this.numChars = this.stream.read(this.buf);\n          } catch (IOException ex) {\n            throw new InputMismatchException();\n          }\n\n          if (this.numChars <= 0) {\n            return EOF;\n          }\n        }\n\n        return this.buf[this.curChar++];\n      }\n    }\n\n    public int nextInt() {\n      int c;\n      for (c = this.read(); isSpaceChar(c); c = this.read()) {\n      }\n\n      byte sgn = 1;\n      if (c == 45) {\n        sgn = -1;\n        c = this.read();\n      }\n\n      int res = 0;\n\n      while (c >= 48 && c <= 57) {\n        res *= 10;\n        res += c - 48;\n        c = this.read();\n        if (isSpaceChar(c)) {\n          return res * sgn;\n        }\n      }\n\n      throw new InputMismatchException();\n    }\n\n    public String next() {\n      int c;\n      while (isSpaceChar(c = this.read())) {\n      }\n\n      StringBuilder result = new StringBuilder();\n      result.appendCodePoint(c);\n\n      while (!isSpaceChar(c = this.read())) {\n        result.appendCodePoint(c);\n      }\n\n      return result.toString();\n    }\n\n    public static boolean isSpaceChar(int c) {\n      return c == 32 || c == 10 || c == 13 || c == 9 || c == EOF;\n    }\n\n    public char[] nextCharArray() {\n      return next().toCharArray();\n    }\n\n  }\n\n  static interface FastIO {\n\n  }\n}\n\n", "index": 40, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class MinimumDiameterTree{\n    public static void main(String[] args) {\n\tInputReader in = new InputReader(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint n = in.nextInt();\n\tint s = in.nextInt();\n\tint[] deg = new int[n];\n\t\n\tfor (int i = 1; i < n; ++i) {\n\t    deg[in.nextInt() - 1] ++;\n\t    deg[in.nextInt() - 1] ++;\n\t}\n\n\tint l = 0;\n\tfor (int i = 0; i < n; ++i)\n\t    if (deg[i] == 1) l++;\n\n\tout.println((double) 2 * s / l);\n\tout.close();\n    }\n\n    public static class InputReader {\n\tpublic BufferedReader reader;\n\tpublic StringTokenizer tokenizer;\n\n\tpublic InputReader(InputStream stream) {\n\t    reader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t    tokenizer = null;\n\t}\n\n\tpublic String next() {\n\t    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\ttry {\n\t\t    tokenizer = new StringTokenizer(reader.readLine());\n\t\t} catch (IOException e) {\n\t\t    throw new RuntimeException(e);\n\t\t}\n\t    }\n\t    return tokenizer.nextToken();\n\t}\n\n\tpublic int nextInt() {\n\t    return Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t    return Long.parseLong(next());\n\t}\n    }\n}\n", "src": "import java.util.*;\nimport java.io.*;\n\npublic class MinimumDiameterTree{\n    public static void main(String[] args) {\n\tInputReader in = new InputReader (System.in);\n\tPrintWriter out = new PrintWriter (System.out);\n\n\tint n = in.nextInt();\n\tint s = in.nextInt();\n\tint deg[] = new int [n];\n\t\n\tfor (int i = 1; i < n; ++i) {\n\t    deg[in.nextInt() - 1] ++;\n\t    deg[in.nextInt() - 1] ++;\n\t}\n\n\tint l = 0;\n\tfor (int i = 0; i < n; ++i)\n\t    if (deg[i] == 1) l ++;\n\n\tout.println((double) 2 * s / l);\n\tout.close();\n    }\n\n    public static class InputReader {\n\tpublic BufferedReader reader;\n\tpublic StringTokenizer tokenizer;\n\n\tpublic InputReader(InputStream stream) {\n\t    reader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t    tokenizer = null;\n\t}\n\n\tpublic String next() {\n\t    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\ttry {\n\t\t    tokenizer = new StringTokenizer(reader.readLine());\n\t\t} catch(IOException e) {\n\t\t    throw new RuntimeException(e);\n\t\t}\n\t    }\n\t    return tokenizer.nextToken();\n\t}\n\n\tpublic int nextInt() {\n\t    return Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "index": 41, "complexity": 3}
{"back-translation": "public class GFG { static final int M = 26; static int getIdx(char ch) { return (ch - 'a'); } static boolean allSame(int freq[], int N) { int same = 0; int i; for (i = 0; i < N; i++) { if (freq[i] > 0) { same = freq[i]; break; } } for (int j = i + 1; j < N; j++) if (freq[j] > 0 && freq[j] != same) return false; return true; } static boolean possibleSameCharFreqByOneRemoval(String str) { int l = str.length(); int [] freq = new int[M]; for (int i = 0; i < l; i++) freq[getIdx(str.charAt(i))]++; if (allSame(freq, M)) return true; for (char c = 'a'; c <= 'z'; c++) { int i = getIdx(c); if (freq[i] > 0) { freq[i]--; if (allSame(freq, M)) return true; freq[i]++; } } return false; } public static void main(String args[]) { String str = \"xyyzz\"; if (possibleSameCharFreqByOneRemoval(str)) System.out.println(\"Yes\"); else System.out.println(\"No\"); } }", "src": "\n// Java program to get same frequency character \n// string by removal of at most one char \npublic\nclass\nGFG { \n\n\nstatic\nfinal\nint\nM = \n26\n; \n\n\n// Utility method to get index of character ch \n\n// in lower alphabet characters \n\nstatic\nint\ngetIdx(\nchar\nch) \n\n{ \n\nreturn\n(ch - \n'a'\n); \n\n} \n\n\n// Returns true if all non-zero elements \n\n// values are same \n\nstatic\nboolean\nallSame(\nint\nfreq[], \nint\nN) \n\n{ \n\nint\nsame = \n0\n; \n\n\n// get first non-zero element \n\nint\ni; \n\nfor\n(i = \n0\n; i < N; i++) { \n\nif\n(freq[i] > \n0\n) { \n\nsame = freq[i]; \n\nbreak\n; \n\n} \n\n} \n\n\n// check equality of each element with \n\n// variable same \n\nfor\n(\nint\nj = i + \n1\n; j < N; j++) \n\nif\n(freq[j] > \n0\n&& freq[j] != same) \n\nreturn\nfalse\n; \n\n\nreturn\ntrue\n; \n\n} \n\n\n// Returns true if we can make all character \n\n// frequencies same \n\nstatic\nboolean\npossibleSameCharFreqByOneRemoval(String str) \n\n{ \n\nint\nl = str.length(); \n\n\n// fill frequency array \n\nint\n[] freq = \nnew\nint\n[M]; \n\n\nfor\n(\nint\ni = \n0\n; i < l; i++) \n\nfreq[getIdx(str.charAt(i))]++; \n\n\n// if all frequencies are same, then return true \n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\n\n/* Try decreasing frequency of all character \n\nby one and then check all equality of all \n\nnon-zero frequencies */\n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\ni = getIdx(c); \n\n\n// Check character only if it occurs in str \n\nif\n(freq[i] > \n0\n) { \n\nfreq[i]--; \n\n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\nfreq[i]++; \n\n} \n\n} \n\n\nreturn\nfalse\n; \n\n} \n\n\n// Driver code to test above methods \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"xyyzz\"\n; \n\nif\n(possibleSameCharFreqByOneRemoval(str)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "index": 42, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class Piles {\n    static int summation(int[] arr) {\n        int k, sum=0;\n        for(k=0;k<arr.length;k++) {\n            sum = sum + arr[k];\n        }\n        return sum;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        if(n>=1 && n<=50) {\n            int[] x = new int[n];\n            int[] y = new int[n];\n            \n            for(int i=0;i<n;i++) {\n                x[i] = sc.nextInt();\n            }\n            for(int j=0;j<n;j++) {\n                y[j] = sc.nextInt();\n            }\n            int xsum = summation(x);\n            int ysum = summation(y);\n            if(xsum>=ysum) {\n                System.out.println(\"Yes\");\n            }\n            else {\n                System.out.println(\"No\");\n            }\n        }\n\n    }\n\n}\n", "src": "import java.util.*;\nimport java.io.*;\npublic class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tfor(k=0;k<arr.length;k++) {\n\t\t\tsum = sum + arr[k];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n}\n", "index": 44, "complexity": 3}
{"back-translation": "class FindSmallestInteger { int findSmallest(int[] arr, int n) { int res = 1; for (int i = 0; i < n && arr[i] <= res; i++) { res = res + arr[i]; } return res; } public static void main(String[] args) { FindSmallestInteger small = new FindSmallestInteger(); int[] arr1 = {1, 3, 4, 5}; int n1 = arr1.length; System.out.println(small.findSmallest(arr1, n1)); int[] arr2 = {1, 2, 6, 10, 11, 15}; int n2 = arr2.length; System.out.println(small.findSmallest(arr2, n2)); int[] arr3 = {1, 1, 1, 1}; int n3 = arr3.length; System.out.println(small.findSmallest(arr3, n3)); int[] arr4 = {1, 1, 3, 4}; int n4 = arr4.length; System.out.println(small.findSmallest(arr4, n4)); } }", "src": "\n// Java program to find the smallest positive value that cannot be \n// represented as sum of subsets of a given sorted array \nclass\nFindSmallestInteger \n{ \n\n// Returns the smallest number that cannot be represented as sum \n\n// of subset of elements from set represented by sorted array arr[0..n-1] \n\nint\nfindSmallest(\nint\narr[], \nint\nn) \n\n{ \n\nint\nres = \n1\n; \n// Initialize result \n\n\n// Traverse the array and increment 'res' if arr[i] is \n\n// smaller than or equal to 'res'. \n\nfor\n(\nint\ni = \n0\n; i < n && arr[i] <= res; i++) \n\nres = res + arr[i]; \n\n\nreturn\nres; \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nFindSmallestInteger small = \nnew\nFindSmallestInteger(); \n\nint\narr1[] = {\n1\n, \n3\n, \n4\n, \n5\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(small.findSmallest(arr1, n1)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n6\n, \n10\n, \n11\n, \n15\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(small.findSmallest(arr2, n2)); \n\n\nint\narr3[] = {\n1\n, \n1\n, \n1\n, \n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(small.findSmallest(arr3, n3)); \n\n\nint\narr4[] = {\n1\n, \n1\n, \n3\n, \n4\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(small.findSmallest(arr4, n4)); \n\n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "index": 46, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\n\npublic class TransformedClass {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int numberOfStairs = 0;\n        StringBuilder result = new StringBuilder();\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int previousNum = 0;\n        int tmp = 0;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(st.nextToken());\n            if (tmp == 1) {\n                numberOfStairs++;\n                if (previousNum != 0) {\n                    result.append(previousNum + \" \");\n                }\n            }\n            previousNum = tmp;\n        }\n        result.append(previousNum);\n        System.out.println(numberOfStairs);\n        System.out.println(result);\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Cf1005A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int numberOfStairs = 0;\n        StringBuilder result = new StringBuilder(\"\");\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int previousNum = 0;\n        int tmp = 0;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken());\n            if (tmp == 1){\n                ++numberOfStairs;\n                if (previousNum != 0)\n                    result.append(previousNum + \" \");\n            }\n            previousNum = tmp;\n        }\n        result.append(previousNum);\n        System.out.println(numberOfStairs);\n        System.out.println(result);\n    }\n}\n", "index": 47, "complexity": 3}
{"back-translation": "class FindUnion {\n    static int printUnion(int arr1[], int arr2[], int m, int n) {\n        int i = 0, j = 0;\n        while (i < m && j < n) {\n            if (arr1[i] < arr2[j])\n                System.out.print(arr1[i++] + \" \");\n            else if (arr2[j] < arr1[i])\n                System.out.print(arr2[j++] + \" \");\n            else {\n                System.out.print(arr2[j++] + \" \");\n                i++;\n            }\n        }\n        while (i < m)\n            System.out.print(arr1[i++] + \" \");\n        while (j < n)\n            System.out.print(arr2[j++] + \" \");\n        return 0;\n    }\n\n    public static void main(String args[]) {\n        int arr1[] = {1, 2, 4, 5, 6};\n        int arr2[] = {2, 3, 5, 7};\n        int m = arr1.length;\n        int n = arr2.length;\n        printUnion(arr1, arr2, m, n);\n    }\n}", "src": "\n// Java program to find union of \n// two sorted arrays \n\nclass\nFindUnion \n{ \n\n/* Function prints union of arr1[] and arr2[] \n\nm is the number of elements in arr1[] \n\nn is the number of elements in arr2[] */\n\nstatic\nint\nprintUnion(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nwhile\n(i < m && j < n) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n\n/* Print remaining elements of \n\nthe larger array */\n\nwhile\n(i < m) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nwhile\n(j < n) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintUnion(arr1, arr2, m, n); \n\n} \n} ", "index": 50, "complexity": 3}
{"back-translation": "class GfG { static class Node { int data; Node left, right; } static void printOddNodes(Node root, boolean isOdd) { if (root == null) return; if (isOdd == true) System.out.print(root.data + \" \"); printOddNodes(root.left, !isOdd); printOddNodes(root.right, !isOdd); } static Node newNode(int data) { Node node = new Node(); node.data = data; node.left = null; node.right = null; return (node); } public static void main(String[] args) { Node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); printOddNodes(root, true); } }", "src": "\n// Recursive Java program to print odd level nodes \nclass\nGfG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\nstatic\nvoid\nprintOddNodes(Node root, \nboolean\nisOdd) \n{ \n\n// If empty tree \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n// If current node is of odd level \n\nif\n(isOdd == \ntrue\n) \n\nSystem.out.print(root.data + \n\" \"\n); \n\n\n// Recur for children with isOdd \n\n// switched. \n\nprintOddNodes(root.left, !isOdd); \n\nprintOddNodes(root.right, !isOdd); \n} \n\n// Utility method to create a node \nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nprintOddNodes(root, \ntrue\n); \n\n} \n} ", "index": 51, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.math.*;\n\npublic class C {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint n = sc.nextInt();\n\t\tint[] counts = new int[60];\n\t\tArrayList<ArrayDeque<Long>> nums = new ArrayList<>();\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tnums.add(new ArrayDeque<>());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong num = sc.nextLong();\n\t\t\tfor (int j = 1; j <= 60; ++j) {\n\t\t\t\tif (num < (1L << j)) {\n\t\t\t\t\tnums.get(j - 1).add(num);\n\t\t\t\t\t++counts[j - 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong curr = 0;\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= 60; ++j) {\n\t\t\t\tif (j == 60) {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (counts[j] == 0 || (curr & (1L << j)) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tlong num = nums.get(j).removeFirst();\n\t\t\t\t--counts[j];\n\t\t\t\tcurr ^= num;\n\t\t\t\tif (i > 0)\n\t\t\t\t\tans.append(\" \");\n\t\t\t\tans.append(num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.math.*;\n\npublic class C {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t/**/\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\t/*/\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(\"src/c.in\"))));\n\t\t/**/\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] counts = new int[60];\n\t\tArrayList<ArrayDeque<Long>> nums = new ArrayList<>();\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tnums.add(new ArrayDeque<>());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong num = sc.nextLong();\n\t\t\tfor (int j = 1; j <= 60; ++j) {\n\t\t\t\tif (num < (1L<<j)) {\n\t\t\t\t\tnums.get(j-1).add(num);\n\t\t\t\t\t++counts[j-1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong curr = 0;\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= 60; ++j) {\n\t\t\t\tif (j==60) {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (counts[j]==0||(curr&(1L<<j))!=0)\n\t\t\t\t\tcontinue;\n\t\t\t\tlong num = nums.get(j).removeFirst();\n\t\t\t\t--counts[j];\n\t\t\t\tcurr ^= num;\n\t\t\t\tif (i>0)\n\t\t\t\t\tans.append(\" \");\n\t\t\t\tans.append(num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t\tSystem.out.println(ans);\n\t}\n}\n", "index": 52, "complexity": 3}
{"back-translation": "class GFG { static int policeThief(char arr[], int n, int k) { int res = 0; List<Integer> thi = new ArrayList<Integer>(); List<Integer> pol = new ArrayList<Integer>(); for (int i = 0; i < n; i++) { if (arr[i] == 'P') pol.add(i); else if (arr[i] == 'T') thi.add(i); } int l = 0, r = 0; while (l < thi.size() && r < pol.size()) { if (Math.abs(thi.get(l) - pol.get(r)) <= k) { res++; l++; r++; } else if (thi.get(l) < pol.get(r)) l++; else r++; } return res; } public static void main(String args[]) { int k, n; char arr1[] = new char[] { 'P', 'T', 'T', 'P', 'T' }; k = 2; n = arr1.length; System.out.println(", "src": "\n// Java program to find maximum number of \n// thieves caught \nimport\njava.util.*; \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Returns maximum number of thieves \n\n// that can be caught. \n\nstatic\nint\npoliceThief(\nchar\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nArrayList<Integer> thi = \nnew\nArrayList<Integer>(); \n\nArrayList<Integer> pol = \nnew\nArrayList<Integer>(); \n\n\n// store indices in the ArrayList \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(arr[i] == \n'P'\n) \n\npol.add(i); \n\nelse\nif\n(arr[i] == \n'T'\n) \n\nthi.add(i); \n\n} \n\n\n// track lowest current indices of \n\n// thief: thi[l], police: pol[r] \n\nint\nl = \n0\n, r = \n0\n; \n\nwhile\n(l < thi.size() && r < pol.size()) { \n\n\n// can be caught \n\nif\n(Math.abs(thi.get(l) - pol.get(r)) <= k) { \n\nres++; \n\nl++; \n\nr++; \n\n} \n\n\n// increment the minimum index \n\nelse\nif\n(thi.get(l) < pol.get(r)) \n\nl++; \n\nelse\n\nr++; \n\n} \n\nreturn\nres; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nk, n; \n\nchar\narr1[] =\nnew\nchar\n[] { \n'P'\n, \n'T'\n, \n'T'\n, \n\n'P'\n, \n'T'\n}; \n\nk = \n2\n; \n\nn = arr1.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr1, n, k)); \n\n\nchar\narr2[] =\nnew\nchar\n[] { \n'T'\n, \n'T'\n, \n'P'\n, \n'P'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n2\n; \n\nn = arr2.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr2, n, k)); \n\n\nchar\narr3[] = \nnew\nchar\n[]{ \n'P'\n, \n'T'\n, \n'P'\n, \n'T'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n3\n; \n\nn = arr3.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr3, n, k)); \n\n} \n} \n\n/* This code is contributed by Danish kaleem */", "index": 53, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class round569d2c {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tArrayDeque<Integer> deq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdeq.addLast(in.nextInt());\n\t\t}\n\t\tlong[] queries = new long[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tqueries[i] = in.nextLong();\n\t\t}\n\t\tint[] origAs = new int[n-1];\n\t\tint[] origBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\torigAs[i] = a;\n\t\t\torigBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tint[] repeatAs = new int[n-1];\n\t\tint[] repeatBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\trepeatAs[i] = a;\n\t\t\trepeatBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tlong query = queries[i] - 1;\n\t\t\tif (query < n-1) {\n\t\t\t\tsb.append(origAs[(int)query] + \" \" + origBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquery %= (n-1);\n\t\t\t\tsb.append(repeatAs[(int)query] + \" \" + repeatBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t// ======================================================================================\n\t// =============================== Reference Code =======================================\n\t// ======================================================================================\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t// Method to return all primes smaller than or equal to \n\t// n using Sieve of Eratosthenes \n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t// Create a boolean array \"prime[0..n]\" and initialize \n\t\t// all entries it as true. A value in prime[i] will \n\t\t// finally be false if i is Not a prime, else true. \n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t// If prime[p] is not changed, then it is a prime \n\t\t\tif (prime[p] == true) {\n\t\t\t\t// Update all multiples of p \n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t// Binary search for number greater than or equal to target\n\t// returns -1 if number not found\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t// Base Case \n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; // To store results of recursive call \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t// Update x and y using results of recursive \n\t\t// call \n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t// Returns modulo inverse of a  \n\t// with respect to m using extended \n\t// Euclid Algorithm. Refer below post for details: \n\t// https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/ \n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t// Apply extended Euclid Algorithm \n\t\twhile (a > 1) {\n\t\t\t// q is quotient \n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t// m is remainder now, process \n\t\t\t// same as euclid's algo \n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t// Make x1 positive \n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t// k is size of num[] and rem[]. \n\t// Returns the smallest number \n\t// x such that: \n\t// x % num[0] = rem[0], \n\t// x % num[1] = rem[1], \n\t// .................. \n\t// x % num[k-2] = rem[k-1] \n\t// Assumption: Numbers in num[] are pairwise  \n\t// coprime (gcd for every pair is 1) \n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t// Compute product of all numbers \n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t// Initialize result \n\t\tint result = 0;\n\n\t\t// Apply above formula \n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t/**\n\t * Source: Matt Fontaine\n\t */\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 54, "complexity": 3}
{"back-translation": "class LISSTree { static class Node { int data, liss; Node left, right; public Node (int data) { this.data = data; this.liss = 0; } } static int liss(Node root) { if (root == null) return 0; if (root.liss != 0) return root.liss; if (root.left == null && root.right == null) return root.liss = 1; int liss_excl = liss(root.left) + liss(root.right); int liss_incl = 1; if (root.left != null) { liss_incl += (liss(root.left.left) + liss(root.left.right)); } if (root.right != null) { liss_incl += (liss(root.right.left) + liss(root.right.right)); } return root.liss = Math.max(liss_excl, liss_incl); } public static void main(String[] args) { Node root = new Node(20); root.left = new Node(8); root.left.left = new Node(4); root.left.right = new Node(12); root.left.right.left = new Node(10); root.left.right.right = new Node(14); root.right = new Node(22); root.right.right = new Node(25); System.out.println(\"Size of the Largest Independent Set is \" + liss(root)); } }", "src": "\n// Java program for calculating LISS \n// using dynamic programming \n\npublic\nclass\nLisTree \n{ \n\n/* A binary tree node has data, pointer \n\nto left child and a pointer to right \n\nchild */\n\nstatic\nclass\nnode \n\n{ \n\nint\ndata, liss; \n\nnode left, right; \n\n\npublic\nnode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.liss = \n0\n; \n\n} \n\n} \n\n\n// A memoization function returns size \n\n// of the largest independent set in \n\n// a given binary tree \n\nstatic\nint\nliss(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root.liss != \n0\n) \n\nreturn\nroot.liss; \n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\nroot.liss = \n1\n; \n\n\n// Calculate size excluding the \n\n// current node \n\nint\nliss_excl = liss(root.left) + liss(root.right); \n\n\n// Calculate size including the \n\n// current node \n\nint\nliss_incl = \n1\n; \n\nif\n(root.left != \nnull\n) \n\n{ \n\nliss_incl += (liss(root.left.left) + liss(root.left.right)); \n\n} \n\nif\n(root.right != \nnull\n) \n\n{ \n\nliss_incl += (liss(root.right.left) + liss(root.right.right)); \n\n} \n\n\n// Maximum of two sizes is LISS, \n\n// store it for future uses. \n\nreturn\nroot.liss = Math.max(liss_excl, liss_incl); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Let us construct the tree given \n\n// in the above diagram \n\n\nnode root = \nnew\nnode(\n20\n); \n\nroot.left = \nnew\nnode(\n8\n); \n\nroot.left.left = \nnew\nnode(\n4\n); \n\nroot.left.right = \nnew\nnode(\n12\n); \n\nroot.left.right.left = \nnew\nnode(\n10\n); \n\nroot.left.right.right = \nnew\nnode(\n14\n); \n\nroot.right = \nnew\nnode(\n22\n); \n\nroot.right.right = \nnew\nnode(\n25\n); \n\nSystem.out.println(\n\"Size of the Largest Independent Set is \"\n+ liss(root)); \n\n} \n} \n\n// This code is contributed by Rishabh Mahrsee ", "index": 56, "complexity": 3}
{"back-translation": "class GFG {\n    public static void print2largest(int[] arr, int arr_size) {\n        int i, first, second;\n        if (arr_size < 2) {\n            System.out.print(\" Invalid Input \");\n            return;\n        }\n        first = second = Integer.MIN_VALUE;\n        for (i = 0; i < arr_size; i++) {\n            if (arr[i] > first) {\n                second = first;\n                first = arr[i];\n            }\n            else if (arr[i] > second && arr[i] != first) {\n                second = arr[i];\n            }\n        }\n        if (second == Integer.MIN_VALUE)\n            System.out.print(\"There is no second largest\" + \" element\\n\");\n        else\n            System.out.print(\"The second largest element\" + \" is \" + second);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {12, 35, 1, 10, 34, 1};\n        int n = arr.length;\n        print2largest(arr, n);\n    }\n}", "src": "\n// JAVA Code for Find Second largest \n// element in an array \nclass\nGFG { \n\n\n/* Function to print the second largest \n\nelements */\n\npublic\nstatic\nvoid\nprint2largest(\nint\narr[], \n\nint\narr_size) \n\n{ \n\nint\ni, first, second; \n\n\n/* There should be atleast two elements */\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i++) \n\n{ \n\n/* If current element is smaller than \n\nfirst then update both first and second */\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n/* If arr[i] is in between first and \n\nsecond then update second */\n\nelse\nif\n(arr[i] > second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\n\nif\n(second == Integer.MIN_VALUE) \n\nSystem.out.print(\n\"There is no second largest\"\n+ \n\n\" element\\n\"\n); \n\nelse\n\nSystem.out.print(\n\"The second largest element\"\n+ \n\n\" is \"\n+ second); \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n35\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint2largest(arr, n); \n\n} \n} \n// This code is contributed by Arnav Kr. Mandal. ", "index": 58, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class TaxiDriversAndLyft2 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tlong n = scanner.nextLong();\n\t\tlong m = scanner.nextLong();\n\t\tlong[] people = new long[(int) (n+m)];\n\t\tint[] taxiDrivers = new int[(int) (n+m)];\n\t\t\n\t\tfor(int i = 0;i< (n+m); i++) {\n\t\t\tpeople[i] = scanner.nextLong();\n\t\t}\n\t\t\n\t\tfor(int i = 0;i< (n+m); i++) {\n\t\t\ttaxiDrivers[i] = scanner.nextInt();\n\t\t}\n\t\t\n\t\tint lastTaxiDriverIndex = -1;\n\t\tlong[] riderCountArray = new long[(int) (m)];\n\t\tlong[] a1 = new long[(int)n];\n\t\tlong[] b1 = new long[(int)m];\n\t\t\n\t\tint j=0, k=0;\n\t\tfor(int i = 0;i< (n+m); i++) {\n\t\t\tif(taxiDrivers[i] == 0) {\n\t\t\t\ta1[j] = people[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse  {\n\t\t\t\tb1[k] = people[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint l = 0, q=0;\n\t\tfor(int i=0;i<j;i++) {\n\t\t\twhile ((l<m-1 && m>1) && Math.abs(a1[i] - b1[l]) > Math.abs(a1[i] - b1[l+1])) {\n\t\t\t\tl++; \n\t\t\t}\n\t\t\t\n\t\t\triderCountArray[l]++;\t\n\t\t}\n\t\t\n\t\tfor(int i = 0;i< (m); i++) {\n\t\t\tSystem.out.print(riderCountArray[i]+\" \");\n\t\t}\n\t}\n}", "src": "\n\nimport java.util.Scanner;\n\npublic class TaxiDriversAndLyft2 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tlong n = scanner.nextLong();\n\t\tlong m = scanner.nextLong();\n\t\tlong[] people = new long[(int) (n+m)];\n\t\tint[] taxiDrivers = new int[(int) (n+m)];\n\t\t\n\t\tfor(int i = 0;i< (n+m); i++) {\n\t\t\tpeople[i] = scanner.nextLong();\n\t\t}\n\t\t\n\t\tfor(int i = 0;i< (n+m); i++) {\n\t\t\ttaxiDrivers[i] = scanner.nextInt();\n\t\t}\n\t\t\n\t\tint lastTaxiDriverIndex = -1;\n\t\tlong[] riderCountArray = new long[(int) (m)];\n\t\tlong[] a1 = new long[(int)n];\n\t\tlong[] b1 = new long[(int)m];\n\t\t\n\t\tint j=0, k=0;\n\t\tfor(int i = 0;i< (n+m); i++) {\t\n\t\t\tif(taxiDrivers[i] == 0) {\n\t\t\t\ta1[j] = people[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse  {\n\t\t\t\tb1[k] = people[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint l = 0, q=0;\n\t\tfor(int i=0;i<j;i++) {\n\t\t\twhile ((l<m-1 && m>1) && Math.abs(a1[i] - b1[l]) > Math.abs(a1[i] - b1[l+1])) {\n\t\t\t\tl++; \n\t\t\t}\n\t\t\t\n\t\t\triderCountArray[l]++;\t\n\t\t}\n\t\t\n\t\tfor(int i = 0;i< (m); i++) {\n\t\t\tSystem.out.print(riderCountArray[i]+\" \");\n\t\t}\n\t} \n}\n", "index": 59, "complexity": 3}
{"back-translation": "class NewCountSubString { public int newCountSubStr(char[] str, int n) { int m = 0; for (int i = 0; i < n; i++) { if (str[i] == '1') m++; } return m * (m - 1) / 2; } public static void main(String[] args) { NewCountSubString count = new NewCountSubString(); String string = \"00100101\"; char[] str = string.toCharArray(); int n = str.length; System.out.println(count.newCountSubStr(str, n)); } }", "src": "\n// A O(n) C++ program to count number of substrings \n//starting and ending with 1 \n\nclass\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[], \nint\nn) \n\n{ \n\nint\nm = \n0\n; \n// Count of 1's in input string \n\n\n// Traverse input string and count of 1's in it \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\nm++; \n\n} \n\n\n// Return count of possible pairs among m 1's \n\nreturn\nm * (m - \n1\n) / \n2\n; \n\n} \n\n\n// Driver program to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str, n)); \n\n} \n} ", "index": 60, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.math.BigInteger;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\npublic class Practice {\n\t\n\t   \n\n\t\tpublic static void main(String []args)\n\t\t{\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\tint n=sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tString s=sc.nextLine();\n\t\t\t//System.out.println(s);\n\t\t\tchar c[]=s.toCharArray();\n\t\t\tArrayList a =new ArrayList();\n\t\t\t\n\t\t\tfor(int i=0;i<c.length;i++)\n\t\t\t{\n\t\t\t\t//System.out.println(c[i]);\n\t\t\t\ta.add(c[i]);\n\t\t\t}\n\t\t\n\t\t\tint x=Collections.frequency(a,'0' );\n\t\t\tint y=Collections.frequency(a,'1');\n\t\t\t\n\t\t\t//System.out.println(x+ \"  \"+y );\n\t\t\tif(y==0 || y==1)\n\t\t\t{\n\t\t\t\tSystem.out.println(s);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(y>=2)\n\t\t\t\t{\n\t\t\t\t\tString s1=\"1\";\n\t\t\t\t\tfor(int i=0;i<x;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\ts1=s1+\"0\";\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(s1);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t}\n\n}", "index": 61, "complexity": 3}
{"back-translation": "public class GFG {\n    static int countFriendsPairings(int n) {\n        int a = 1, b = 2, c = 0;\n        if (n <= 2) {\n            return n;\n        }\n        for (int i = 3; i <= n; i++) {\n            c = b + (i - 1) * a;\n            a = b;\n            b = c;\n        }\n        return c;\n    }\n    public static void main(String[] args) {\n        int n = 4;\n        System.out.println(countFriendsPairings(n));\n    }\n}", "src": "\nclass\nGFG { \n\n// Returns count of ways n people \n\n// can remain single or paired up. \n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\na = \n1\n, b = \n2\n, c = \n0\n; \n\nif\n(n <= \n2\n) { \n\nreturn\nn; \n\n} \n\nfor\n(\nint\ni = \n3\n; i <= n; i++) { \n\nc = b + (i - \n1\n) * a; \n\na = b; \n\nb = c; \n\n} \n\nreturn\nc; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n} \n\n// This code is contributed by Ravi Kasha. ", "index": 62, "complexity": 3}
{"back-translation": "import java.util.Scanner;\npublic class Codeforces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, f[], c=0;\n\t\tn = in.nextInt();\n\t\tf = new int[n];\n\t\twhile(--n > 0) {\n\t\t\tf[in.nextInt() - 1]++;\n\t\t\tf[in.nextInt() - 1]++;\n\t\t\tin.nextLine();\n\t\t}\n\t\tint i = 0;\n\t\tfor(int j = 0; j < f.length; j++) {\n\t\t\tif(f[j] == 1) {\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(c);\n\t}\n}", "src": "import java.util.Scanner;\npublic class Codeforces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, f[], c=0;\n\t\tn = in.nextInt();\n\t\tf = new int[n];\n\t\twhile (--n>0){\n\t\t\tf[in.nextInt()-1] ++;\n\t\t\tf[in.nextInt()-1]++;\n\t\t\tin.nextLine();\n\t\t}\n\t\tfor(int i=0; i<f.length; i++) if (f[i] == 1) c++;\n\t\tSystem.out.println(c);\n\t}\n\n}\n", "index": 63, "complexity": 3}
{"back-translation": "class GFG { static void findSmallest(int m, int s) { if (s == 0) { System.out.print(m == 1 ? \"Smallest number is 0\" : \"Not possible\"); return; } if (s > 9 * m) { System.out.println(\"Not possible\"); return; } int[] res = new int[m]; s -= 1; for (int i = m-1; i > 0; i--) { if (s > 9) { res[i] = 9; s -= 9; } else { res[i] = s; s = 0; } } res[0] = s + 1; System.out.print(\"Smallest number is \"); for (int i = 0; i < m; i++) System.out.print(res[i]); } public static void main(String[] args) { int s = 9, m = 2; findSmallest(m, s); } }", "src": "\n// Java program to find the smallest number that can be \n// formed from given sum of digits and number of digits \n\nclass\nGFG \n{ \n\n// Function to print the smallest possible number with digit sum 's' \n\n// and 'm' number of digits \n\nstatic\nvoid\nfindSmallest(\nint\nm, \nint\ns) \n\n{ \n\n// If sum of digits is 0, then a number is possible \n\n// only if number of digits is 1 \n\nif\n(s == \n0\n) \n\n{ \n\nSystem.out.print(m == \n1\n? \n\"Smallest number is 0\"\n: \n\"Not possible\"\n); \n\n\nreturn\n; \n\n} \n\n\n// Sum greater than the maximum possible sum \n\nif\n(s > \n9\n*m) \n\n{ \n\nSystem.out.println(\n\"Not possible\"\n); \n\nreturn\n; \n\n} \n\n\n// Create an array to store digits of result \n\nint\n[] res = \nnew\nint\n[m]; \n\n\n// deduct sum by one to account for cases later \n\n// (There must be 1 left for the most significant \n\n// digit) \n\ns -= \n1\n; \n\n\n// Fill last m-1 digits (from right to left) \n\nfor\n(\nint\ni=m-\n1\n; i>\n0\n; i--) \n\n{ \n\n// If sum is still greater than 9, \n\n// digit must be 9 \n\nif\n(s > \n9\n) \n\n{ \n\nres[i] = \n9\n; \n\ns -= \n9\n; \n\n} \n\nelse\n\n{ \n\nres[i] = s; \n\ns = \n0\n; \n\n} \n\n} \n\n\n// Whatever is left should be the most significant \n\n// digit \n\nres[\n0\n] = s + \n1\n; \n// The initially subtracted 1 is \n\n// incorporated here \n\n\nSystem.out.print(\n\"Smallest number is \"\n); \n\nfor\n(\nint\ni=\n0\n; i<m; i++) \n\nSystem.out.print(res[i]); \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\ns = \n9\n, m = \n2\n; \n\nfindSmallest(m, s); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "index": 64, "complexity": 3}
{"back-translation": "class GFG {\n    static long binomialCoeff(int n, int k) {\n        long res = 1;\n        if (k > n - k) {\n            k = n - k;\n        }\n        for (int i = 0; i < k; ++i) {\n            res *= (n - i);\n            res /= (i + 1);\n        }\n        return res;\n    }\n    static long catalan(int n) {\n        long c = binomialCoeff(2 * n, n);\n        return c / (n + 1);\n    }\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            System.out.print(catalan(i) + \" \");\n        }\n    }\n}", "src": "\n// Java program for nth Catalan Number \n\nclass\nGFG { \n\n// Returns value of Binomial Coefficient C(n, k) \n\nstatic\nlong\nbinomialCoeff(\nint\nn, \nint\nk) { \n\nlong\nres = \n1\n; \n\n\n// Since C(n, k) = C(n, n-k) \n\nif\n(k > n - k) { \n\nk = n - k; \n\n} \n\n\n// Calculate value of [n*(n-1)*---*(n-k+1)] / [k*(k-1)*---*1] \n\nfor\n(\nint\ni = \n0\n; i < k; ++i) { \n\nres *= (n - i); \n\nres /= (i + \n1\n); \n\n} \n\n\nreturn\nres; \n\n} \n\n// A Binomial coefficient based function to find nth catalan \n// number in O(n) time \n\nstatic\nlong\ncatalan(\nint\nn) { \n\n// Calculate value of 2nCn \n\nlong\nc = binomialCoeff(\n2\n* n, n); \n\n\n// return 2nCn/(n+1) \n\nreturn\nc / (n + \n1\n); \n\n} \n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalan(i) + \n\" \"\n); \n\n} \n\n\n} \n} ", "index": 65, "complexity": 3}
{"back-translation": "class Solution { static class Node { Node left, right; int data; } static Node createNode(int x) { Node p = new Node(); p.data = x; p.left = p.right = null; return p; } static void insertNode(Node root, int x) { Node p = root, q = null; while (p != null) { q = p; if (p.data < x) p = p.right; else p = p.left; } if (q == null) p = createNode(x); else { if (q.data < x) q.right = createNode(x); else q.left = createNode(x); } } static int maxelpath(Node q, int x) { Node p = q; int mx = -1; while (p.data != x) { if (p.data > x) { mx = Math.max(mx, p.data); p = p.left; } else { mx = Math.max(mx, p.data); p = p.right; } } return Math.max(mx, x); } static int maximumElement(Node root, int x, int y) { Node p = root; while ((x < p.data && y < p.data) || (x > p.data && y > p.data)) { if (x < p.data && y < p.data) p = p.left; else if (x > p.data && y > p.data) p = p.right; } return Math.max(maxelpath(p, x), maxelpath(p, y)); } public static void main(String args[]) { int arr[] = {18, 36, 9, 6, 12, 10, 1, 8}; int a = 1, b = 10; int n = arr.length; Node root = createNode(arr[0]); for (int i = 1; i < n; i++) insertNode(root, arr[i]); System.out.println(maximumElement(root, a, b)); } }", "src": "\n// Java program to find maximum element in the path \n// between two Nodes of Binary Search Tree. \nclass\nSolution \n{ \n\nstatic\nclass\nNode \n{ \n\nNode left, right; \n\nint\ndata; \n} \n\n// Create and return a pointer of new Node. \nstatic\nNode createNode(\nint\nx) \n{ \n\nNode p = \nnew\nNode(); \n\np . data = x; \n\np . left = p . right = \nnull\n; \n\nreturn\np; \n} \n\n// Insert a new Node in Binary Search Tree. \nstatic\nvoid\ninsertNode( Node root, \nint\nx) \n{ \n\nNode p = root, q = \nnull\n; \n\n\nwhile\n(p != \nnull\n) \n\n{ \n\nq = p; \n\nif\n(p . data < x) \n\np = p . right; \n\nelse\n\np = p . left; \n\n} \n\n\nif\n(q == \nnull\n) \n\np = createNode(x); \n\nelse\n\n{ \n\nif\n(q . data < x) \n\nq . right = createNode(x); \n\nelse\n\nq . left = createNode(x); \n\n} \n} \n\n// Return the maximum element between a Node \n// and its given ancestor. \nstatic\nint\nmaxelpath(Node q, \nint\nx) \n{ \n\nNode p = q; \n\n\nint\nmx = -\n1\n; \n\n\n// Traversing the path between ansector and \n\n// Node and finding maximum element. \n\nwhile\n(p . data != x) \n\n{ \n\nif\n(p . data > x) \n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . left; \n\n} \n\nelse\n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . right; \n\n} \n\n} \n\n\nreturn\nMath.max(mx, x); \n} \n\n// Return maximum element in the path between \n// two given Node of BST. \nstatic\nint\nmaximumElement( Node root, \nint\nx, \nint\ny) \n{ \n\nNode p = root; \n\n\n// Finding the LCA of Node x and Node y \n\nwhile\n((x < p . data && y < p . data) || \n\n(x > p . data && y > p . data)) \n\n{ \n\n// Checking if both the Node lie on the \n\n// left side of the parent p. \n\nif\n(x < p . data && y < p . data) \n\np = p . left; \n\n\n// Checking if both the Node lie on the \n\n// right side of the parent p. \n\nelse\nif\n(x > p . data && y > p . data) \n\np = p . right; \n\n} \n\n\n// Return the maximum of maximum elements occur \n\n// in path from ancestor to both Node. \n\nreturn\nMath.max(maxelpath(p, x), maxelpath(p, y)); \n} \n\n\n// Driver Code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n18\n, \n36\n, \n9\n, \n6\n, \n12\n, \n10\n, \n1\n, \n8\n}; \n\nint\na = \n1\n, b = \n10\n; \n\nint\nn =arr.length; \n\n\n// Creating the root of Binary Search Tree \n\nNode root = createNode(arr[\n0\n]); \n\n\n// Inserting Nodes in Binary Search Tree \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\ninsertNode(root, arr[i]); \n\n\nSystem.out.println( maximumElement(root, a, b) ); \n\n} \n} \n//contributed by Arnab Kundu ", "index": 66, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class b {\n\n    public static void main(String[] args) {\n        FS in = new FS(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        Integer[] arr = new Integer[n];\n        int numZ = 0;\n        for (int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n            if (arr[i] == 0) numZ++;\n        }\n\n        Arrays.sort(arr);\n\n        if (numZ > 1) {\n            System.out.println(\"cslnb\");\n            return;\n        }\n        int numDup = 0;\n        int[] arr2 = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr2[i] = arr[i];\n            if (i != 0) {\n                if (arr2[i] == arr2[i - 1]) {\n                    arr2[i - 1]--;\n                    numDup++;\n                }\n            }\n        }\n\n        if (numDup > 1) {\n            System.out.println(\"cslnb\");\n            return;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (i != 0) {\n                if (arr2[i] == arr2[i - 1]) {\n                    System.out.println(\"cslnb\");\n                    return;\n                }\n            }\n        }\n        long num = 0;\n        if (numDup == 1) num++;\n        for (int i = 0; i < n; i++) {\n            num += arr2[i] - i;\n        }\n\n        if (num % 2 == 0) {\n            System.out.println(\"cslnb\");\n        } else {\n            System.out.println(\"sjfnb\");\n        }\n\n        out.close();\n    }\n\n    static class FS {\n\n        BufferedReader in;\n        StringTokenizer token;\n\n        public FS(InputStream str) {\n            in = new BufferedReader(new InputStreamReader(str));\n        }\n\n        public String next() {\n            if (token == null || !token.hasMoreElements()) {\n                try {\n                    token = new StringTokenizer(in.readLine());\n                } catch (IOException ex) {\n                }\n                return next();\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}", "src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n744444444747477777774\n44444447474747777777\n */\n\n/**\n *\n * @author Andy Phan\n */\npublic class b {\n    public static void main(String[] args) {\n        FS in = new FS(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int n = in.nextInt();\n        Integer[] arr = new Integer[n];\n        int numZ = 0;\n        for(int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n            if(arr[i] == 0) numZ++;\n        }\n        \n        Arrays.sort(arr);\n        \n        \n        if(numZ > 1) {\n            System.out.println(\"cslnb\");\n            return;\n        }\n        int numDup = 0;\n        int[] arr2 = new int[n];\n        for(int i = 0; i < n; i++) {\n            arr2[i] = arr[i];\n            if(i != 0) {\n                if(arr2[i] == arr2[i-1]) {\n                    arr2[i-1]--;\n                    numDup++;\n                }\n            }\n        }\n        \n        if(numDup > 1) {\n            System.out.println(\"cslnb\");\n            return;\n        }\n        \n        \n        for(int i = 0; i < n; i++) {\n            if(i != 0) {\n                if(arr2[i] == arr2[i-1]) {\n                    System.out.println(\"cslnb\");\n                    return;\n                }\n            }\n        }\n        long num = 0;\n        if(numDup == 1) num++;\n        for(int i = 0; i < n; i++) {\n            num += arr2[i]-i;\n        }\n        \n        if(num%2 == 0) {\n            System.out.println(\"cslnb\");\n        } else {\n            System.out.println(\"sjfnb\");\n        }\n        \n\n        out.close();\n    }\n    \n    static class FS {\n\n        BufferedReader in;\n        StringTokenizer token;\n        \n        public FS(InputStream str) {\n            in = new BufferedReader(new InputStreamReader(str));\n        }\n        \n        public String next() {\n            if (token == null || !token.hasMoreElements()) {\n                try {\n                    token = new StringTokenizer(in.readLine());\n                } catch (IOException ex) {\n                }\n                return next();\n            }\n            return token.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n", "index": 67, "complexity": 3}
{"back-translation": "import java.util.*;\npublic class kingrace {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        long a = input.nextLong();\n        input.nextLine();\n        String[] coo = input.nextLine().split(\" \");\n        long xcoin = Long.parseLong(coo[0]);\n        long ycoin = Long.parseLong(coo[1]);\n        Coordinates first = new Coordinates(1, 1, a);\n        Coordinates second = new Coordinates(a, a, a);\n        double x = (double) Math.sqrt(Math.abs((xcoin - 1) * (xcoin - 1) + (ycoin - 1) * (ycoin - 1)));\n        double y = (double) Math.sqrt(Math.abs((xcoin - a) * (xcoin - a) + (ycoin - a) * (ycoin - a)));\n        long c = 0;\n        long d = 0;\n        if (x > y) {\n            System.out.println(\"Black\");\n        } else if (x < y) {\n            System.out.println(\"White\");\n        } else {\n            c = first.distance(new Coordinates(xcoin, ycoin, a));\n            d = second.distance(new Coordinates(xcoin, ycoin, a));\n        }\n        if (d != 0 && c != 0)\n            if (d < c) {\n                System.out.println(\"Black\");\n            } else {\n                System.out.println(\"White\");\n            }\n        //System.out.prlongln(c + \" \" + d);\n        input.close();\n    }\n}\nclass Coordinates {\n    private long xcoord;\n    private long ycoord;\n    private long dim;\n\n    public Coordinates(long x, long y, long dimensions) {\n        xcoord = x;\n        ycoord = y;\n        dim = dimensions;\n    }\n\n    public void setCoordinates(long x, long y) {\n        xcoord = x;\n        ycoord = y;\n    }\n\n    public long distance(Coordinates num) {\n        long distance = 0;\n\n        while (this.xcoord != num.xcoord || this.ycoord != num.ycoord) {\n\n            if (num.xcoord - this.xcoord == 1 && num.ycoord == this.ycoord) {\n                distance++;\n                this.setCoordinates(this.xcoord + 1, this.ycoord);\n            } else if (num.xcoord - this.xcoord == -1 && num.ycoord == this.ycoord) {\n                distance++;\n                this.setCoordinates(this.xcoord - 1, this.ycoord);\n            } else if (num.xcoord - this.xcoord == 0 && num.ycoord - this.ycoord == 1) {\n                distance++;\n                this.setCoordinates(this.xcoord, this.ycoord + 1);\n            } else if (num.xcoord - this.xcoord == 0 && num.ycoord - this.ycoord == -1) {\n                distance++;\n                this.setCoordinates(this.xcoord, this.ycoord - 1);\n            } else if (num.xcoord - this.xcoord >= 0 && num.ycoord - this.ycoord <= 0) {\n                distance++;\n                this.setCoordinates(this.xcoord + 1, this.ycoord - 1);\n            } else if (num.xcoord - this.xcoord >= 0 && num.ycoord - this.ycoord >= 0) {\n                distance++;\n                this.setCoordinates(this.xcoord + 1, this.ycoord + 1);\n            } else if (num.xcoord - this.xcoord <= 0 && num.ycoord - this.ycoord <= 0)\n\n            {\n                distance++;\n                this.setCoordinates(this.xcoord - 1, this.ycoord - 1);\n            } else if (num.xcoord - this.xcoord <= 0 && num.ycoord - this.ycoord >= 0) {\n                distance++;\n                this.setCoordinates(this.xcoord - 1, this.ycoord + 1);\n            }\n\n        }\n\n        return distance;\n    }\n\n}", "src": "import java.util.*;\npublic class kingrace {public static void main(String[] args) \n{ \n    Scanner input=new Scanner(System.in);\n    long a = input.nextLong();\n   input.nextLine();\n    String [] coo = input.nextLine().split(\" \");\n    long xcoin = Long.parseLong(coo[0]);\n    long ycoin = Long.parseLong(coo[1]);\n    coordinates first = new coordinates(1,1,a);\n    coordinates second = new coordinates(a,a,a);\n    double x = (double)Math.sqrt(Math.abs((xcoin-1)*(xcoin-1)+(ycoin-1)*(ycoin-1)));\n    double y = (double)Math.sqrt(Math.abs((xcoin-a)*(xcoin-a)+(ycoin-a)*(ycoin-a)));\n   long c = 0;\n   long d = 0;\n    if (x>y)\n    {\n    \tSystem.out.println(\"Black\");\n    }\n    else if(x<y)\n    {\n    \tSystem.out.println(\"White\");\n    }\n    else {\n    c = first.Distance(new coordinates(xcoin,ycoin,a));\n    d = second.Distance(new coordinates(xcoin,ycoin,a));\n    }\n    if(d!=0&&c!=0)\n    if (d<c)\n    {\n    \tSystem.out.println(\"Black\");\n    \t\n    }\n    else \n    {\n    \tSystem.out.println(\"White\");\n    }\n  //System.out.prlongln(c +\" \"+d);\n  input.close();\n} \n\n}\nclass coordinates{\n\tprivate long xcoord;\n\tprivate long ycoord;\n\tprivate long dim; \n\tpublic coordinates(long x, long y, long dimensions)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\tdim = dimensions;\n\t\t\n\t}\n\tpublic void setCoordinates(long x, long y)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\t\n\t}\n\tpublic long Distance(coordinates num)\n\t{\n\t\tlong distance = 0; \n\t\t\n\t\t\n\t\twhile ((this.xcoord!=num.xcoord||this.ycoord!=num.ycoord))\n\t\t{\n\t\t\n\t\t\tif (num.xcoord-this.xcoord==1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\n\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==-1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==1)\n\t\t\t{distance ++; this.setCoordinates(this.xcoord, this.ycoord+1);}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==-1) {\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord, this.ycoord-1);\n\t\t\t}\n\t\t\t\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord-1); \n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord+1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord-1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t\t\t{distance ++; this.setCoordinates(this.xcoord-1, this.ycoord+1);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\treturn distance;\n\t}\n\t\n\t\n}\n", "index": 70, "complexity": 3}
{"back-translation": "class Multipy {\n    static void modify(int arr[], int n) {\n        if (n <= 1) return;\n        int prev = arr[0];\n        arr[0] = arr[0] * arr[1];\n        for (int i = 1; i < n - 1; i++) {\n            int curr = arr[i];\n            arr[i] = prev * arr[i + 1];\n            prev = curr;\n        }\n        arr[n - 1] = prev * arr[n - 1];\n    }\n\n    public static void main(String[] args) {\n        int arr[] = { 2, 3, 4, 5, 6 };\n        int n = arr.length;\n        modify(arr, n);\n        for (int i = 0; i < n; i++)\n            System.out.print(arr[i] + \" \");\n    }\n}", "src": "\n// Java program to update every array element with \n// multiplication of previous and next numbers in array \nimport\njava.io.*; \nimport\njava.util.*; \nimport\njava.lang.Math; \n\nclass\nMultipy \n{ \n\nstatic\nvoid\nmodify(\nint\narr[], \nint\nn) \n\n{ \n\n// Nothing to do when array size is 1 \n\nif\n(n <= \n1\n) \n\nreturn\n; \n\n\n// store current value of arr[0] and update it \n\nint\nprev = arr[\n0\n]; \n\narr[\n0\n] = arr[\n0\n] * arr[\n1\n]; \n\n\n// Update rest of the array elements \n\nfor\n(\nint\ni=\n1\n; i<n-\n1\n; i++) \n\n{ \n\n// Store current value of next interation \n\nint\ncurr = arr[i]; \n\n\n// Update current value using previos value \n\narr[i] = prev * arr[i+\n1\n]; \n\n\n// Update previous value \n\nprev = curr; \n\n} \n\n\n// Update last array element \n\narr[n-\n1\n] = prev * arr[n-\n1\n]; \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nmodify(arr, n); \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n} \n/* This code is contributed by Devesh Agrawal */", "index": 72, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main\n{\n\n    class node\n    {\n        int data;\n        node next;\n        \n        public node(int val)\n        {\n            data = val;\n            next = null;\n        }\n    }\n    \n    class linkedlist\n    {\n        node start;\n        node end;\n        int size;\n        int turn;\n        \n        public linkedlist()\n        {\n            start = null;\n            end = null;\n            size = 0;\n        }\n        \n        void add(int val)\n        {\n            if(size == 0)\n            {\n                node t = new node(val);\n                start = t;\n                end = t;\n                size++;\n            }\n            else\n            {\n                node t = new node(val);\n                end.next = t;\n                end = end.next;\n                size++;\n            }\n        }\n        \n        void myfunc()\n        {\n            if(start.data > start.next.data)\n            {\n                node t = new node(start.next.data);\n                start.next = start.next.next;\n                end.next = t;\n                end = end.next;\n            }\n            else\n            {\n                int t = start.data;\n                start = start.next;\n                add(t);\n                size--;\n            }\n        }\n        \n        int findmax()\n        {\n            int m = 0;\n            node temp = start;\n            for(int i = 0; i < size; i++)\n            {\n                if(temp.data > m)\n                {\n                    m = temp.data;\n                }\n                temp = temp.next;\n            }\n            return m;\n        }\n        \n        void display()\n        {\n            node temp = start;\n            for(int i = 0; i < size; i++)\n            {\n                System.out.print(temp.data + \" \");\n                temp = temp.next;\n            }\n            System.out.println(\"\");\n        }\n    }\n    \n    linkedlist l;\n    \n    public Main()\n    {\n        l = new linkedlist();\n    }\n    \n    public static void main(String[] argv) throws IOException\n    {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        Main ma = new Main();\n        String[] l1 = in.readLine().split(\" \");\n        int n = Integer.parseInt(l1[0]);\n        int q = Integer.parseInt(l1[1]);\n        String[] ar = in.readLine().split(\" \");\n        int a1 = Integer.parseInt(ar[0]);\n        int b1 = Integer.parseInt(ar[1]);\n        \n        for(int i = 0; i < n; i++)\n        {\n            ma.l.add(Integer.parseInt(ar[i]));\n        }\n        int m = ma.l.findmax();\n        int[][] pair = new int[n][2];\n        int t = 0;\n        \n        for(int i = 0; i < n; i++)\n        {\n            if(ma.l.start.data == m)\n                break;\n            ma.l.myfunc();\n            pair[t][0] = ma.l.start.data;\n            pair[t][1] = ma.l.start.next.data;\n            t++;\n        }\n        \n        int[] rl = new int[n];\n        node temp = ma.l.start;\n        \n        for(int i = 0; i < n; i++)\n        {\n            rl[i] = temp.data;\n            temp = temp.next;\n        }\n        \n        for(int i = 0; i < q; i++)\n        {\n            long a = Long.parseLong(in.readLine());\n            \n            if(a == 1)\n            {\n                System.out.println(a1 + \" \" + b1);\n            }\n            else\n            {\n                if(a <= t + 1)\n                {\n                    System.out.println(pair[(int)(a - 2)][0] + \" \" + pair[(int)(a - 2)][1]);\n                }\n                else\n                {\n                    if((a - t) % (n - 1) == 0)\n                    {\n                        System.out.println(rl[0] + \" \" + rl[n - 1]);\n                    }\n                    else\n                    {\n                        System.out.println(rl[0] + \" \" + rl[(int)((a - t) % (n - 1))]);\n                    }\n                }\n            }\n        }\n    }\n}\n", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Main\n\t{\t\n\t\tclass node{\n\t\tint data;\n\t\tnode next;\n\t\tpublic node(int val){\n\t\t\tdata=val;\n\t\t\tnext=null;\n\t\t}\n\t}\n\tclass linkedlist{\n\t\tnode start;\n\t\tnode end;\n\t\tint size;\n\t\tint turn;\n\t\tpublic linkedlist(){\n\t\t\tstart=null;\n\t\t\tend=null;\n\t\t\tsize=0;\n\t\t}\n\t\tvoid add(int val){\n\t\t\tif(size==0){\n\t\t\t\tnode t=new node(val);\n\t\t\t\tstart=t;\n\t\t\t\tend=t;\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnode t=new node(val);\n\t\t\t\tend.next=t;\n\t\t\t\tend=end.next;\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t\tvoid myfunc(){\n\t\t\tif(start.data>start.next.data){\n\t\t\t\t// System.out.println(\"me ni hu\");\n\t\t\t\tnode t=new node(start.next.data);\n\t\t\t\tstart.next=start.next.next;\n\t\t\t\tend.next=t;\n\t\t\t\tend=end.next;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// System.out.println(\"me hu\");\n\t\t\t\tint t=start.data;\n\t\t\t\tstart=start.next;\n\t\t\t\tadd(t);\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t\tint findmax(){\n\t\t\tint m=0;\n\t\t\tnode temp=start;\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tif(temp.data>m){\n\t\t\t\t\tm=temp.data;\n\t\t\t\t}\n\t\t\t\ttemp=temp.next;\n\t\t\t}\n\t\t\treturn m;\n\t\t}\n\t\tvoid display(){\n\t\t\tnode temp=start;\n\t\t\tfor(int i=0;i<size;i++){\n\t\t\t\tSystem.out.print(temp.data+\" \");\n\t\t\t\ttemp=temp.next;\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t}\n\tlinkedlist l;\n\tpublic Main(){\n\t\tl=new linkedlist();\n\t}\n\tpublic static void main(String [] argv) throws IOException\n\t{\n\t\tBufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n\t\tMain ma=new Main();\n\t\tString[] l1=in.readLine().split(\" \");\n\t\tint n=Integer.parseInt(l1[0]);\n\t\tint q=Integer.parseInt(l1[1]);\n\t\tString[] ar=in.readLine().split(\" \");\n\t\tint a1=Integer.parseInt(ar[0]);\n\t\tint b1=Integer.parseInt(ar[1]);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tma.l.add(Integer.parseInt(ar[i]));\n\t\t}\n\t\tint m=ma.l.findmax();\n\t\tint[][] pair=new int[n][2];\n\t\tint t=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(ma.l.start.data==m)\n\t\t\t\tbreak;\n\t\t\tma.l.myfunc();\n\t\t\tpair[t][0]=ma.l.start.data;\n\t\t\tpair[t][1]=ma.l.start.next.data;\n\t\t\tt++;\n\t\t}\n\t\tint rl[]=new int[n];\n\t\tnode temp=ma.l.start;\n\t\tfor(int i=0;i<n;i++){\n\t\t\trl[i]=temp.data;\n\t\t\ttemp=temp.next;\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tlong a=Long.parseLong(in.readLine());\n\t\t\tif(a==1){\n\t\t\t\tSystem.out.println(a1 + \" \" + b1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(a<=t+1){\n\t\t\t\t\tSystem.out.println(pair[(int)(a-2)][0]+\" \"+pair[(int)(a-2)][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif((a-t)%(n-1)==0){\n\t\t\t\t\t\tSystem.out.println(rl[0]+\" \"+rl[n-1]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tSystem.out.println(rl[0]+\" \"+rl[(int)((a-t)%(n-1))]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "index": 73, "complexity": 3}
{"back-translation": "class GFG {\n    static int answer_query(int[] a, int n, int l, int r) {\n        int count = 0;\n        for (int i = l; i < r; i++)\n            if (a[i] == a[i + 1])\n                count += 1;\n        return count;\n    }\n    public static void main(String[] args) {\n        int a[] = {1, 2, 2, 2, 3, 3, 4, 4, 4};\n        int n = a.length;\n        int L, R;\n        L = 1;\n        R = 8;\n        System.out.println(answer_query(a, n, L, R));\n        L = 0;\n        R = 4;\n        System.out.println(answer_query(a, n, L, R));\n    }\n}", "src": "\n// Java program to count the number of \n// indexes in range L R such that \n// Ai = Ai+1 \nclass\nGFG { \n\n\n// function that answers every query \n\n// in O(r-l) \n\nstatic\nint\nanswer_query(\nint\na[], \nint\nn, \n\nint\nl, \nint\nr) \n\n{ \n\n\n// traverse from l to r and count \n\n// the required indexes \n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = l; i < r; i++) \n\nif\n(a[i] == a[i + \n1\n]) \n\ncount += \n1\n; \n\n\nreturn\ncount; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = a.length; \n\n\n// 1-st query \n\nint\nL, R; \n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n\n// 2nd query \n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n} \n} \n\n// This code is contribute by \n// Smitha Dinesh Semwal ", "index": 74, "complexity": 3}
{"back-translation": "class Geeks { static void rvereseArray(int arr[], int start, int end) { while (start < end) { int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; start++; end--; } } static void printArray(int arr[], int size) { for (int i = 0; i < size; i++) System.out.print(arr[i] + \" \"); } static void splitArr(int arr[], int k, int n) { rvereseArray(arr, 0, n - 1); rvereseArray(arr, 0, n - k - 1); rvereseArray(arr, n - k, n - 1); } public static void main(String args[]) { int arr[] = { 12, 10, 5, 6, 52, 36 }; int n = arr.length; int k = 2; splitArr(arr, k, n); printArray(arr, n); } }", "src": "\n// Java program to Split the array and \n// add the first part to the end \nclass\nGeeks \n{ \n\n/* Function to reverse arr[] from index start to end*/\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n{ \n\nwhile\n(start < end) { \n\nint\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nstart++; \n\nend--; \n\n} \n} \n\n// Function to print an array \nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n} \n\n/* Function to left rotate arr[] of size n by k */\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nk, \nint\nn) \n{ \n\nrvereseArray(arr, \n0\n, n - \n1\n); \n\nrvereseArray(arr, \n0\n, n - k - \n1\n); \n\nrvereseArray(arr, n - k, n - \n1\n); \n} \n\n/* Driver program to test above functions */\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\n\n// Function calling \n\nsplitArr(arr, k, n); \n\nprintArray(arr, n); \n\n} \n\n} \n\n// This code is contributed by ankita_saini. ", "index": 75, "complexity": 3}
{"back-translation": "import java.io.*;\n\nclass GFG {\n\n    static int nonDecNums(int n) {\n        int[][] a = new int[n + 1][10];\n        for (int i = 0; i <= 9; i++)\n            a[0][i] = 1;\n        for (int i = 1; i <= n; i++)\n            a[i][9] = 1;\n        for (int i = 1; i <= n; i++)\n            for (int j = 8; j >= 0; j--)\n                a[i][j] = a[i - 1][j] + a[i][j + 1];\n        return a[n][0];\n    }\n\n    public static void main(String[] args) {\n        int n = 2;\n        System.out.println(\"Non-decreasing digits = \" + nonDecNums(n));\n    }\n}", "src": "\n// Java program for counting n digit numbers with \n// non decreasing digits \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Function that returns count of non- decreasing numbers \n\n// with n digits \n\nstatic\nint\nnonDecNums(\nint\nn) \n\n{ \n\n// a[i][j] = count of all possible number \n\n// with i digits having leading digit as j \n\nint\n[][] a = \nnew\nint\n[n + \n1\n][\n10\n]; \n\n\n// Initialization of all 0-digit number \n\nfor\n(\nint\ni = \n0\n; i <= \n9\n; i++) \n\na[\n0\n][i] = \n1\n; \n\n\n// Initialization of all i-digit \n\n// non-decreasing number leading with 9 \n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\na[i][\n9\n] = \n1\n; \n\n\n// for all digits we should calculate \n\n// number of ways depending upon leading \n\n// digits \n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfor\n(\nint\nj = \n8\n; j >= \n0\n; j--) \n\na[i][j] = a[i - \n1\n][j] + a[i][j + \n1\n]; \n\n\nreturn\na[n][\n0\n]; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Non-decreasing digits = \"\n+ nonDecNums(n)); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "index": 76, "complexity": 3}
{"back-translation": "class LinkedList { static LNode head; class LNode { int data; LNode next, prev; LNode(int d) { data = d; next = prev = null; } } class TNode { int data; TNode left, right; TNode(int d) { data = d; left = right = null; } } TNode sortedListToBST() { int n = countNodes(head); return sortedListToBSTRecur(n); } TNode sortedListToBSTRecur(int n) { if (n <= 0) return null; TNode left = sortedListToBSTRecur(n / 2); TNode root = new TNode(head.data); root.left = left; head = head.next; root.right = sortedListToBSTRecur(n - n / 2 - 1); return root; } int countNodes(LNode head) { int count = 0; LNode temp = head; while (temp != null) { temp = temp.next; count++; } return count; } void push(int new_data) { LNode new_node = new LNode(new_data); new_node.prev = null; new_node.next = head; if (head != null) head.prev = new_node; head = new_node; } void printList(LNode node) { while (node != null) { System.out.print(node.data + \" \"); node = node.next; } } void preOrder(TNode node) { if (node == null) return; System.out.print(node.data + \" \"); preOrder(node.left); preOrder(node.right); } public static void main(String[] args) { LinkedList llist = new LinkedList(); llist.push(7); llist.push(6); llist.push(5); llist.push(4); llist.push(3); llist.push(2); llist.push(1); System.out.println(\"Given Linked List \"); llist.printList(head); TNode root = llist.sortedListToBST(); System.out.println(\"\"); System.out.println(\"Pre-Order Traversal of constructed BST \"); llist.preOrder(root); } }", "src": "\nclass\nLinkedList { \n\n\n/* head node of link list */\n\nstatic\nLNode head; \n\n\n/* Link list Node */\n\nclass\nLNode \n\n{ \n\nint\ndata; \n\nLNode next, prev; \n\n\nLNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\n/* A Binary Tree Node */\n\nclass\nTNode \n\n{ \n\nint\ndata; \n\nTNode left, right; \n\n\nTNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n\n} \n\n\n/* This function counts the number of nodes in Linked List \n\nand then calls sortedListToBSTRecur() to construct BST */\n\nTNode sortedListToBST() \n\n{ \n\n/*Count the number of nodes in Linked List */\n\nint\nn = countNodes(head); \n\n\n/* Construct BST */\n\nreturn\nsortedListToBSTRecur(n); \n\n} \n\n\n/* The main function that constructs balanced BST and \n\nreturns root of it. \n\nn --> No. of nodes in the Doubly Linked List */\n\nTNode sortedListToBSTRecur(\nint\nn) \n\n{ \n\n/* Base Case */\n\nif\n(n <= \n0\n) \n\nreturn\nnull\n; \n\n\n/* Recursively construct the left subtree */\n\nTNode left = sortedListToBSTRecur(n / \n2\n); \n\n\n/* head_ref now refers to middle node, \n\nmake middle node as root of BST*/\n\nTNode root = \nnew\nTNode(head.data); \n\n\n// Set pointer to left subtree \n\nroot.left = left; \n\n\n/* Change head pointer of Linked List for parent \n\nrecursive calls */\n\nhead = head.next; \n\n\n/* Recursively construct the right subtree and link it \n\nwith root. The number of nodes in right subtree is \n\ntotal nodes - nodes in left subtree - 1 (for root) */\n\nroot.right = sortedListToBSTRecur(n - n / \n2\n- \n1\n); \n\n\nreturn\nroot; \n\n} \n\n\n/* UTILITY FUNCTIONS */\n\n/* A utility function that returns count of nodes in a \n\ngiven Linked List */\n\nint\ncountNodes(LNode head) \n\n{ \n\nint\ncount = \n0\n; \n\nLNode temp = head; \n\nwhile\n(temp != \nnull\n) \n\n{ \n\ntemp = temp.next; \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n/* Function to insert a node at the beginging of \n\nthe Doubly Linked List */\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n/* allocate node */\n\nLNode new_node = \nnew\nLNode(new_data); \n\n\n/* since we are adding at the begining, \n\nprev is always NULL */\n\nnew_node.prev = \nnull\n; \n\n\n/* link the old list off the new node */\n\nnew_node.next = head; \n\n\n/* change prev of head node to new node */\n\nif\n(head != \nnull\n) \n\nhead.prev = new_node; \n\n\n/* move the head to point to the new node */\n\nhead = new_node; \n\n} \n\n\n/* Function to print nodes in a given linked list */\n\nvoid\nprintList(LNode node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.next; \n\n} \n\n} \n\n\n/* A utility function to print preorder traversal of BST */\n\nvoid\npreOrder(TNode node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList llist = \nnew\nLinkedList(); \n\n\n/* Let us create a sorted linked list to test the functions \n\nCreated linked list will be 7->6->5->4->3->2->1 */\n\nllist.push(\n7\n); \n\nllist.push(\n6\n); \n\nllist.push(\n5\n); \n\nllist.push(\n4\n); \n\nllist.push(\n3\n); \n\nllist.push(\n2\n); \n\nllist.push(\n1\n); \n\n\nSystem.out.println(\n\"Given Linked List \"\n); \n\nllist.printList(head); \n\n\n/* Convert List to BST */\n\nTNode root = llist.sortedListToBST(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Pre-Order Traversal of constructed BST \"\n); \n\nllist.preOrder(root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "index": 77, "complexity": 3}
{"back-translation": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n\n    public static void main(String args[])throws IOException{\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        int[] a = new int[n];\n        for(int i = 0; i < n; i++){\n            a[i] = sc.nextInt();\n            if(!set1.contains(a[i])){\n                set1.add(a[i]);\n            }else{\n                System.out.println(0);\n                return;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            int b = a[i] & k;\n            if(b != a[i] && set1.contains(b)){\n                System.out.println(1);\n                return;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            int b = a[i] & k;\n            if(b != a[i] && set2.contains(b)){\n                System.out.println(2);\n                return;\n            }else{\n                set2.add(b);\n            }\n        }\n        System.out.println(-1);\n    }\n}", "src": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     //if(!set2.contains(b)){\n                            //set2.add(b);\n                     //}else{\n                       //     System.out.println(2);\n                         //   return;\n                     //}\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "index": 78, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class VasyaArray {\n    public static void main(String[] args) throws IOException {\n        FastReader in = new FastReader(System.in);\n        int n = in.nextInt();\n        long[] arr1 = new long[n];\n        long[] pre1 = new long[n];\n        int i, j;\n        arr1[0] = in.nextLong();\n        pre1[0] = arr1[0];\n        for (i = 1; i < n; i++) {\n            arr1[i] = in.nextLong();\n            pre1[i] = pre1[i - 1] + arr1[i];\n        }\n        int m = in.nextInt();\n        long[] arr2 = new long[m];\n        long[] pre2 = new long[m];\n        arr2[0] = in.nextLong();\n        pre2[0] = arr2[0];\n        for (i = 1; i < m; i++) {\n            arr2[i] = in.nextLong();\n            pre2[i] = pre2[i - 1] + arr2[i];\n        }\n        if (pre1[n - 1] != pre2[m - 1])\n            System.out.println(\"-1\");\n        else {\n            long s1 = 0, s2 = 0;\n            i = j = 0;\n            int k = 0;\n            while (true) {\n                if (s1 == s2) {\n                    if (s1 == 0) {\n                        s1 = arr1[i++];\n                        s2 = arr2[j++];\n                    } else {\n                        k++;\n                        s1 = s2 = 0;\n                        if (i == n && j == m)\n                            break;\n                    }\n                } else if (s1 > s2) {\n                    s2 += arr2[j++];\n                } else {\n                    s1 += arr1[i++];\n                }\n            }\n            System.out.println(k);\n        }\n    }\n}\nclass FastReader {\n    byte[] buf = new byte[2048];\n    int index, total;\n    InputStream in;\n    FastReader(InputStream is) {\n        in = is;\n    }\n    int scan() throws IOException {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) {\n                return -1;\n            }\n        }\n        return buf[index++];\n    }\n    String next() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    String nextLine() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c != 10; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    char nextChar() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        return (char) c;\n    }\n    int nextInt() throws IOException {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n    long nextLong() throws IOException {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\npublic class vasyaarray{\npublic static void main(String[] args)throws IOException {\n    FastReader in=new FastReader(System.in);\n        int n=in.nextInt();\n        long arr1[]=new long[n];\n        long pre1[]=new long[n];\n        int i,j;\n        arr1[0]=in.nextLong();\n        pre1[0]=arr1[0];\n        for(i=1;i<n;i++)\n        {\n            arr1[i]=in.nextLong();\n            pre1[i]=pre1[i-1]+arr1[i];\n        }\n        int m=in.nextInt();\n        long arr2[]=new long[m];\n        long pre2[]=new long[m];\n        arr2[0]=in.nextInt();\n        pre2[0]=arr2[0];\n        for(i=1;i<m;i++)\n        {\n            arr2[i]=in.nextInt();\n            pre2[i]=pre2[i-1]+arr2[i];\n        }\n        //System.out.println(Arrays.toString(pre1));\n         //System.out.println(Arrays.toString(pre2));\n        if(pre1[n-1]!=pre2[m-1])\n        System.out.println(\"-1\");\n        else\n        {\n            long s1=0,s2=0;\n            i=j=0;\n            int k=0;\n            while(true)\n            {\n                if(s1==s2)\n                {\n                    if(s1==0)\n                    {\n                        s1=arr1[i++];\n                        s2=arr2[j++];\n                        // System.out.println(s1+\" \"+s2+\" \"+i+\" \"+j);\n                    }\n                    else\n                    {\n                        k++;\n                        s1=s2=0;\n                        //System.out.println(k+\" \"+i+\" \"+j);\n                        if(i==n && j==m)\n                        break;\n                    }\n                }\n                else if(s1>s2)\n                {\n                    s2+=arr2[j++];\n                    //System.out.println(\"1\"+\" \"+s1+\" \"+s2+\" \"+i+\" \"+j);\n                }\n                else\n                {\n                    s1+=arr1[i++];\n                    //System.out.println(\"2 \"+s1+\" \"+s2+\" \"+i+\" \"+j);\n                }\n            }\n            System.out.println(k);\n        }\n    }\n}\nclass FastReader {\n \n    byte[] buf = new byte[2048];\n    int index, total;\n    InputStream in;\n \n    FastReader(InputStream is) {\n        in = is;\n    }\n \n    int scan() throws IOException {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) {\n                return -1;\n            }\n        }\n        return buf[index++];\n    }\n \n    String next() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    String nextLine() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c !=10; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    char nextChar() throws IOException{\n        int c;\n         for (c = scan(); c <= 32; c = scan());\n         return (char)c;\n        }\n \n    int nextInt() throws IOException {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n \n    long nextLong() throws IOException {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n}", "index": 80, "complexity": 3}
{"back-translation": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class pr902A {\n    static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        out.println(solve(n, m));\n        out.flush();\n        out.close();\n    }\n\n    private static String solve(int n, int m) {\n        int[] grid = new int[m + 1];\n        for (int i = 0; i < n; i++) {\n            int start = in.nextInt();\n            int end = in.nextInt();\n\n            grid[start]++;\n            grid[end]--;\n        }\n        int sum = 0;\n        for (int i = 0; i < m; i++) {\n            sum += grid[i];\n            if (sum == 0) return \"NO\";\n        }\n\n        return \"YES\";\n    }\n}", "src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class pr902A {\n    static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        out.println(solve(n, m));\n        out.flush();\n        out.close();\n    }\n\n    private static String solve(int n, int m) {\n        int[] grid = new int[m+1];\n        for (int i = 0; i < n; i++) {\n            int start = in.nextInt();\n            int end = in.nextInt();\n\n            grid[start]++;\n            grid[end]--;\n\n        }\n        int sum = 0;\n        for(int i = 0; i < m; i++){\n            sum += grid[i];\n            if(sum == 0) return \"NO\";\n        }\n\n        return \"YES\";\n    }\n}\n", "index": 81, "complexity": 3}
{"back-translation": "class Node {\n    int data;\n    Node left, right;\n\n    public Node(int d) {\n        data = d;\n        left = right = null;\n    }\n}\n\nclass BinaryTree {\n    Node root;\n\n    int isSumProperty(Node node) {\n        int left_data = 0, right_data = 0;\n\n        if (node == null || (node.left == null && node.right == null))\n            return 1;\n        else {\n            if (node.left != null)\n                left_data = node.left.data;\n            if (node.right != null)\n                right_data = node.right.data;\n\n            if ((node.data == left_data + right_data)\n                    && (isSumProperty(node.left) != 0)\n                    && isSumProperty(node.right) != 0)\n                return 1;\n            else\n                return 0;\n        }\n    }\n\n    public static void main(String[] args) {\n        BinaryTree tree = new BinaryTree();\n\n        tree.root = new Node(10);\n        tree.root.left = new Node(8);\n        tree.root.right = new Node(2);\n        tree.root.left.left = new Node(3);\n        tree.root.left.right = new Node(5);\n        tree.root.right.right = new Node(2);\n\n        if (tree.isSumProperty(tree.root) != 0)\n            System.out.println(\"The given tree satisfies children\" + \" sum property\");\n        else\n            System.out.println(\"The given tree does not satisfy children\" + \" sum property\");\n    }\n}", "src": "\n// Java program to check children sum property \n\n/* A binary tree node has data, pointer to left child \n\nand a pointer to right child */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* returns 1 if children sum property holds for the given \n\nnode and both of its children*/\n\nint\nisSumProperty(Node node) \n\n{ \n\n\n/* left_data is left child data and right_data is for right \n\nchild data*/\n\nint\nleft_data = \n0\n, right_data = \n0\n; \n\n\n/* If node is NULL or it's a leaf node then \n\nreturn true */\n\nif\n(node == \nnull\n\n|| (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n1\n; \n\nelse\n\n{ \n\n\n/* If left child is not present then 0 is used \n\nas data of left child */\n\nif\n(node.left != \nnull\n) \n\nleft_data = node.left.data; \n\n\n/* If right child is not present then 0 is used \n\nas data of right child */\n\nif\n(node.right != \nnull\n) \n\nright_data = node.right.data; \n\n\n/* if the node and both of its children satisfy the \n\nproperty return 1 else 0*/\n\nif\n((node.data == left_data + right_data) \n\n&& (isSumProperty(node.left)!=\n0\n) \n\n&& isSumProperty(node.right)!=\n0\n) \n\nreturn\n1\n; \n\nelse\n\nreturn\n0\n; \n\n} \n\n} \n\n\n/* driver program to test the above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n8\n); \n\ntree.root.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n2\n); \n\nif\n(tree.isSumProperty(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree satisfies children\"\n\n+ \n\" sum property\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree does not satisfy children\"\n\n+ \n\" sum property\"\n); \n\n} \n} ", "index": 82, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\npublic class Main{\npublic static void main(String[] args){\nScanner s=new Scanner(System.in);\nint n=s.nextInt();\nStringBuilder sb=new StringBuilder();\nlong[] a=new long[n/2];\nfor(int i=0;i<n/2;i++){\na[i]=s.nextLong();\n}\nint j=0;\nlong[] a2=new long[n/2];\nlong[] a1=new long[n/2];\na1[j]=a[a.length-1]/2;\na2[j]=a[a.length-1]-a[a.length-1]/2;\nfor(int i=(n-1)/2-1;i>=0;i--){\nlong n1=a1[j];\nif((a[i]-n1)<a2[j]){\na2[j+1]=a2[j++];\na1[j]=a[i]-a2[j];\n}else{\na1[++j]=n1;\na2[j]=a[i]-n1;\n}\n}\nint k=0;\nfor(int i=(n-1)/2;i>=0;i--){\nsb.append(a1[i]+\" \");\n}\nfor(int i=0;i<n/2;i++){\nsb.append(a2[i]+\" \");\n}\nSystem.out.println(sb.toString());\n}\n}", "src": "import java.io.*;\nimport java.util.*;\npublic class Main{\npublic static void main(String[] args){\n Scanner s= new Scanner(System.in);\n int n=s.nextInt();StringBuilder sb=new StringBuilder();\n long[] a=new long[n/2];\n for(int i=0;i<n/2;i++){\n                  a[i]=s.nextLong();\n }int j=0;long[] a2=new long[n/2];long[] a1=new long[n/2];\n a1[j]=a[a.length-1]/2;\n a2[j]=a[a.length-1]-a[a.length-1]/2;\n for(int i=(n-1)/2-1;i>=0;i--){\n //    a1[j]=a[i]/2;a2[j++]=a[i]-a[i]/2;\n    long n1=a1[j];\n    if((a[i]-n1)<a2[j]){\n      a2[j+1]=a2[j++];a1[j]=a[i]-a2[j];                      \n     }else{a1[++j]=n1;a2[j]=a[i]-n1;}\n }int k=0;//int[] ans=new int[2*n];\n for(int i=(n-1)/2;i>=0;i--)\n   sb.append(a1[i]+\" \");\n  for(int i=0;i<n/2;i++)\n    sb.append(a2[i]+\" \");\n            System.out.println(sb.toString());     \n}\n}", "index": 83, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\n/* spar5h */\n\npublic class cf1 implements Runnable{    \n\t\n\tpublic void run() {\n\n\t\tInputReader s = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\t\n\t\tint t = 1;\n\t\t\n\t\twhile(t-- > 0) {\n\t\t\t\n\t\t\tint n = s.nextInt(), m = s.nextInt();\n\t\t\t\n\t\t\tint[] a = new int[n + 1];\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t\ta[i] = s.nextInt();\n\t\t\t\n\t\t\tint[] b = new int[n + 1];\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t\tb[i] = s.nextInt();\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\t\n\t\t\tlist.add(a[1]);\n\t\t\t\n\t\t\tfor(int i = 2; i <= n; i++) {\n\t\t\t\tlist.add(b[i]); list.add(a[i]);\n\t\t\t}\n\t\t\t\n\t\t\tlist.add(b[1]);\n\t\t\t\n\t\t\tdouble wt = m;\n\t\t\tboolean check = true;\n\t\t\t\n\t\t\tfor(int i = list.size() - 1; i >= 0; i--) {\n\t\t\t\t\n\t\t\t\tif(list.get(i) <= 1) {\n\t\t\t\t\tcheck = false; break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdouble x = wt / (list.get(i) - 1);\n\t\t\t\t\t\t\n\t\t\t\twt += x;\n\t\t\t}\n\t\t\t\n\t\t\tif(check)\n\t\t\t\tw.println(wt - m);\n\t\t\telse\n\t\t\t\tw.println(-1);\n\t\t}\n\t\t\n\t\tw.close();\n\t}\n\t\n\tstatic class InputReader {\n\t\t\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\t\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars==-1) \n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t \n\t\tpublic String nextLine()\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n\t\t}\n\t\tpublic int nextInt()\n\t\t{\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile(isSpaceChar(c)) \n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\t\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t{\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') \n\t\t\t{\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\n\t\t\treturn res.toString();\n\t\t}\n\t \n\t\tpublic boolean isSpaceChar(int c) \n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t \n\t\tpublic String next() \n\t\t{\n\t\t\treturn readString();\n\t\t}\n\t\t\n\t\tpublic interface SpaceCharFilter \n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n    \n\tpublic static void main(String args[]) throws Exception\n\t{\n\t\tnew Thread(null, new cf1(),\"cf1\",1<<26).start();\n\t}\n}", "index": 85, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2];\n\t\tint x = scan.nextInt();\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\ta[i] += scan.nextInt();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\t}\n\n}", "src": "import java.util.Scanner;\n\npublic class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}\n", "index": 86, "complexity": 3}
{"back-translation": "class Node { int data; Node left, right; Node(int d) { data = d; left = right = null; } } class BinaryTree { Node head; Node insert(Node node, int data) { if (node == null) { return (new Node(data)); } else { if (data <= node.data) { node.left = insert(node.left, data); } else { node.right = insert(node.right, data); } return node; } } int minvalue(Node node) { Node current = node; while (current.left != null) { current = current.left; } return (current.data); } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); Node root = null; root = tree.insert(root, 4); tree.insert(root, 2); tree.insert(root, 1); tree.insert(root, 3); tree.insert(root, 6); tree.insert(root, 5); System.out.println(\"Minimum value of BST is \" + tree.minvalue(root)); } }", "src": "\n// Java program to find minimum value node in Binary Search Tree \n\n// A binary tree node \nclass\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode head; \n\n\n/* Given a binary search tree and a number, \n\ninserts a new node with the given number in \n\nthe correct place in the tree. Returns the new \n\nroot pointer which the caller should then use \n\n(the standard trick to avoid using reference \n\nparameters). */\n\nNode insert(Node node, \nint\ndata) { \n\n\n/* 1. If the tree is empty, return a new, \n\nsingle node */\n\nif\n(node == \nnull\n) { \n\nreturn\n(\nnew\nNode(data)); \n\n} \nelse\n{ \n\n\n/* 2. Otherwise, recur down the tree */\n\nif\n(data <= node.data) { \n\nnode.left = insert(node.left, data); \n\n} \nelse\n{ \n\nnode.right = insert(node.right, data); \n\n} \n\n\n/* return the (unchanged) node pointer */\n\nreturn\nnode; \n\n} \n\n} \n\n\n/* Given a non-empty binary search tree, \n\nreturn the minimum data value found in that \n\ntree. Note that the entire tree does not need \n\nto be searched. */\n\nint\nminvalue(Node node) { \n\nNode current = node; \n\n\n/* loop down to find the leftmost leaf */\n\nwhile\n(current.left != \nnull\n) { \n\ncurrent = current.left; \n\n} \n\nreturn\n(current.data); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode root = \nnull\n; \n\nroot = tree.insert(root, \n4\n); \n\ntree.insert(root, \n2\n); \n\ntree.insert(root, \n1\n); \n\ntree.insert(root, \n3\n); \n\ntree.insert(root, \n6\n); \n\ntree.insert(root, \n5\n); \n\n\nSystem.out.println(\n\"Minimum value of BST is \"\n+ tree.minvalue(root)); \n\n} \n} \n\n// This code is contributed by Mayank Jaiswal ", "index": 87, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class ErrorCorrectSystem {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tString a = scan.next();\n\t\tString b = scan.next();\n\t\t\n\t\tint[][] mismatch = new int[26][26];\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tArrays.fill(mismatch[i], -1);\n\t\t}\n\t\tint[][] pair = new int[2][26];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tArrays.fill(pair[i], -1);\n\t\t}\n\t\tint hd = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a.charAt(i) != b.charAt(i)) {\n\t\t\t\thd++;\n\t\t\t\tmismatch[a.charAt(i) - 'a'][b.charAt(i) - 'a'] = i;\n\t\t\t\tpair[0][a.charAt(i) - 'a'] = i;\n\t\t\t\tpair[1][b.charAt(i) - 'a'] = i;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tfor (int j = i + 1; j < 26; j++) {\n\t\t\t\tif (mismatch[i][j] > -1 && mismatch[j][i] > -1) {\n\t\t\t\t\tSystem.out.println(hd - 2);\n\t\t\t\t\tSystem.out.println((mismatch[i][j] + 1) + \" \" + (mismatch[j][i] + 1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a.charAt(i) != b.charAt(i)) {\n\t\t\t\t//try a gets b's letter\n\t\t\t\tif (pair[0][b.charAt(i) - 'a'] > -1) {\n\t\t\t\t\tSystem.out.println(hd - 1);\n\t\t\t\t\tSystem.out.println((i + 1) + \" \" + (pair[0][b.charAt(i) - 'a'] + 1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(hd);\n\t\tSystem.out.println(\"-1 -1\");\n\t}\n\n}", "src": "import java.util.*;\n\npublic class ErrorCorrectSystem\n{\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tString a = scan.next();\n\t\tString b = scan.next();\n\t\t\n\t\tint[][] mismatch = new int[26][26];\n\t\tfor(int i = 0; i < 26; i++) Arrays.fill(mismatch[i], -1);\n\t\tint[][] pair = new int[2][26];\n\t\tfor(int i = 0; i < 2; i++) Arrays.fill(pair[i], -1);\n\t\tint hd = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\thd++;\n\t\t\t\tmismatch[a.charAt(i)-'a'][b.charAt(i)-'a'] = i;\n\t\t\t\tpair[0][a.charAt(i)-'a'] = i;\n\t\t\t\tpair[1][b.charAt(i)-'a'] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tfor(int j = i+1; j < 26; j++) {\n\t\t\t\tif(mismatch[i][j] > -1 && mismatch[j][i] > -1) {\n\t\t\t\t\tSystem.out.println(hd-2);\n\t\t\t\t\tSystem.out.println((mismatch[i][j]+1)+\" \"+(mismatch[j][i]+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\t//try a gets b's letter\n\t\t\t\tif(pair[0][b.charAt(i)-'a'] > -1) {\n\t\t\t\t\tSystem.out.println(hd-1);\n\t\t\t\t\tSystem.out.println((i+1)+\" \"+(pair[0][b.charAt(i)-'a']+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(hd);\n\t\tSystem.out.println(\"-1 -1\");\n\t}\n\n}\n", "index": 89, "complexity": 3}
{"back-translation": "class GFG { static class Node { int data; Node left, right; } static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.left = temp.right = null; return temp; } static Node flipBinaryTree(Node root) { Node curr = root; Node next = null; Node temp = null; Node prev = null; while (curr != null) { next = curr.left; curr.left = temp; temp = curr.right; curr.right = prev; prev = curr; curr = next; } return prev; } static void printLevelOrder(Node root) { if (root == null) return; Queue<Node> q = new LinkedList<Node>(); q.add(root); while (true) { int nodeCount = q.size(); if (nodeCount == 0) break; while (nodeCount > 0) { Node node = q.peek(); System.out.print(node.data + \" \"); q.remove(); if (node.left != null) q.add(node.left); if (node.right != null) q.add(node.right); nodeCount--; } System.out.println(); } } public static void main(String args[]) { Node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.right.left = newNode(4); root.right.right = newNode(5); System.out.print(\"Level order traversal \" + \"of given tree\\n\"); printLevelOrder(root); root = flipBinaryTree(root); System.out.print(\"\\nLevel order traversal \" + \"of the flipped tree\\n\"); printLevelOrder(root); } }", "src": "\n// Java program to flip a binary tree \nimport\njava.util.*; \nclass\nGFG \n{ \n\n// A binary tree node \nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n// Utility function to create \n// a new Binary Tree Node \n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n// method to flip the binary tree \nstatic\nNode flipBinaryTree(Node root) \n{ \n\n// Initialization of pointers \n\nNode curr = root; \n\nNode next = \nnull\n; \n\nNode temp = \nnull\n; \n\nNode prev = \nnull\n; \n\n\n// Iterate through all left nodes \n\nwhile\n(curr != \nnull\n) \n\n{ \n\nnext = curr.left; \n\n\n// Swapping nodes now, need \n\n// temp to keep the previous \n\n// right child \n\n\n// Making prev's right \n\n// as curr's left child \n\ncurr.left = temp; \n\n\n// Storing curr's right child \n\ntemp = curr.right; \n\n\n// Making prev as curr's \n\n// right child \n\ncurr.right = prev; \n\n\nprev = curr; \n\ncurr = next; \n\n} \n\nreturn\nprev; \n} \n\n// Iterative method to do \n// level order traversal \n// line by line \nstatic\nvoid\nprintLevelOrder(Node root) \n{ \n\n// Base Case \n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n// Create an empty queue for \n\n// level order traversal \n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\n\n// Enqueue Root and \n\n// initialize height \n\nq.add(root); \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n// nodeCount (queue size) \n\n// indicates number of nodes \n\n// at current lelvel. \n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n// Dequeue all nodes of current \n\n// level and Enqueue all nodes \n\n// of next level \n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n4\n); \n\nroot.right.right = newNode(\n5\n); \n\n\nSystem.out.print(\n\"Level order traversal \"\n+ \n\n\"of given tree\\n\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\n\nSystem.out.print(\n\"\\nLevel order traversal \"\n+ \n\n\"of the flipped tree\\n\"\n); \n\nprintLevelOrder(root); \n} \n} \n\n// This code is contributed \n// by Arnab Kundu ", "index": 90, "complexity": 3}
{"back-translation": "class Main {\n\n    static void printUnsorted(int arr[], int n) {\n\n        int s = 0, e = n - 1, i, max, min;\n\n        for (s = 0; s < n - 1; s++) {\n            if (arr[s] > arr[s + 1]) {\n                break;\n            } \n        }\n\n        if (s == n - 1) {\n            System.out.println(\"The complete array is sorted\");\n            return;\n        }\n\n        for (e = n - 1; e > 0; e--) {\n            if (arr[e] < arr[e - 1]) {\n                break;\n            }\n        }\n\n        max = arr[s]; min = arr[s];\n\n        for (i = s + 1; i <= e; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n            if (arr[i] < min) {\n                min = arr[i];\n            }\n        }\n\n        for (i = 0; i < s; i++) {\n            if (arr[i] > min) {\n                s = i;\n                break;\n            }\n        }\n\n        for (i = n - 1; i >= e + 1; i--) {\n            if (arr[i] < max) {\n                e = i;\n                break;\n            }\n        }\n\n        System.out.println(\" The unsorted subarray which\" + \" makes the given array sorted lies\" + \" between the indices \" + s + \" and \" + e);\n        return;\n    }\n\n    public static void main(String args[]) {\n        int arr[] = { 10, 12, 20, 30, 25, 40, 32, 31, 35, 50, 60 };\n        int arr_size = arr.length;\n        printUnsorted(arr, arr_size);\n    }\n}", "src": "\n// Java program to find the Minimum length Unsorted Subarray, \n// sorting which makes the complete array sorted \nclass\nMain \n{ \n\nstatic\nvoid\nprintUnsorted(\nint\narr[], \nint\nn) \n\n{ \n\nint\ns = \n0\n, e = n-\n1\n, i, max, min; \n\n\n// step 1(a) of above algo \n\nfor\n(s = \n0\n; s < n-\n1\n; s++) \n\n{ \n\nif\n(arr[s] > arr[s+\n1\n]) \n\nbreak\n; \n\n} \n\nif\n(s == n-\n1\n) \n\n{ \n\nSystem.out.println(\n\"The complete array is sorted\"\n); \n\nreturn\n; \n\n} \n\n\n// step 1(b) of above algo \n\nfor\n(e = n - \n1\n; e > \n0\n; e--) \n\n{ \n\nif\n(arr[e] < arr[e-\n1\n]) \n\nbreak\n; \n\n} \n\n\n// step 2(a) of above algo \n\nmax = arr[s]; min = arr[s]; \n\nfor\n(i = s + \n1\n; i <= e; i++) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\nif\n(arr[i] < min) \n\nmin = arr[i]; \n\n} \n\n\n// step 2(b) of above algo \n\nfor\n( i = \n0\n; i < s; i++) \n\n{ \n\nif\n(arr[i] > min) \n\n{ \n\ns = i; \n\nbreak\n; \n\n} \n\n} \n\n\n// step 2(c) of above algo \n\nfor\n( i = n -\n1\n; i >= e+\n1\n; i--) \n\n{ \n\nif\n(arr[i] < max) \n\n{ \n\ne = i; \n\nbreak\n; \n\n} \n\n} \n\n\n// step 3 of above algo \n\nSystem.out.println(\n\" The unsorted subarray which\"\n+ \n\n\" makes the given array sorted lies\"\n+ \n\n\" between the indices \"\n+s+\n\" and \"\n+e); \n\nreturn\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n10\n, \n12\n, \n20\n, \n30\n, \n25\n, \n40\n, \n32\n, \n31\n, \n35\n, \n50\n, \n60\n}; \n\nint\narr_size = arr.length; \n\nprintUnsorted(arr, arr_size); \n\n} \n} ", "index": 91, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Dialog1 {\n    private static int n ;\n    private static String s ;\n    private static char[] a;\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        n = input.nextInt();\n        s = input.next();\n        a = s.toCharArray();\n\n        for (int i = 0; i < 200; ++i) {\n            int cur = i;\n            boolean fl = true;\n\n            for (int j = 0; j < n; ++j) {\n                if (a[j] == '+')\n                    ++cur;\n                else\n                    --cur;\n\n                if (cur < 0)\n                    fl = false;\n            }\n\n            if (fl) {\n                System.out.print(cur);\n                return;\n            }\n        }\n    }\n}", "src": "    import jdk.nashorn.internal.objects.NativeArray;\n\n    import javax.swing.JOptionPane ;\n    import javax.swing.plaf.basic.BasicInternalFrameTitlePane;\n    import java.sql.SQLSyntaxErrorException;\n    import java.util.Arrays;\n    import java.util.Scanner;\n    import java.util.Vector;\n\n\n    import static jdk.nashorn.internal.objects.NativeArray.sort;\n    import static jdk.nashorn.internal.runtime.ScriptObject.toPropertyDescriptor;\n\n    public class Dialog1 {\n        private static int n ;\n        private static String s ;\n        private static char[] a;\n        public static void main(String[] args) {\n            Scanner input = new Scanner(System.in);\n            n = input.nextInt() ;\n            s = input.next() ;\n            a = s.toCharArray();\n            for(int i = 0 ; i < 200 ; ++i) {\n                int cur = i ;\n                boolean fl = true ;\n                for(int j = 0 ; j < n ; ++j) {\n                    if(a[j] == '+')\n                        ++cur ;\n                    else\n                        --cur ;\n                    if(cur < 0)\n                        fl = false ;\n                }\n                if(fl) {\n                    System.out.print(cur);\n                    return ;\n                }\n            }\n        }\n    }", "index": 92, "complexity": 3}
{"back-translation": "class GFG {\n    public static int findFrequency(int[] arr, int n, int left, int right, int element) {\n        int count = 0;\n        for (int i = left - 1; i < right; ++i)\n            if (arr[i] == element)\n                ++count;\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {2, 8, 6, 9, 8, 6, 8, 2, 11};\n        int n = arr.length;\n\n        System.out.println(\"Frequency of 2 from 1 to 6 = \" + findFrequency(arr, n, 1, 6, 2));\n        System.out.println(\"Frequency of 8 from 4 to 9 = \" + findFrequency(arr, n, 4, 9, 8));\n    }\n}", "src": "\n// JAVA Code to find total count of an element \n// in a range \n\nclass\nGFG { \n\n\n// Returns count of element in arr[left-1..right-1] \n\npublic\nstatic\nint\nfindFrequency(\nint\narr[], \nint\nn, \n\nint\nleft, \nint\nright, \n\nint\nelement) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = left - \n1\n; i < right; ++i) \n\nif\n(arr[i] == element) \n\n++count; \n\nreturn\ncount; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n8\n, \n6\n, \n9\n, \n8\n, \n6\n, \n8\n, \n2\n, \n11\n}; \n\nint\nn = arr.length; \n\n\n// Print frequency of 2 from position 1 to 6 \n\nSystem.out.println(\n\"Frequency of 2 from 1 to 6 = \"\n+ \n\nfindFrequency(arr, n, \n1\n, \n6\n, \n2\n)); \n\n\n// Print frequency of 8 from position 4 to 9 \n\nSystem.out.println(\n\"Frequency of 8 from 4 to 9 = \"\n+ \n\nfindFrequency(arr, n, \n4\n, \n9\n, \n8\n)); \n\n\n} \n\n} \n// This code is contributed by Arnav Kr. Mandal. ", "index": 93, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TaskA {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tlong i = sc.nextInt();\n\t\tlong goal = sc.nextLong();\n\n\t\tif (i > goal) {\n\t\t\ti = goal;\n\t\t}\n\n\t\tint count = 0;\n\t\twhile (goal >= 0) {\n\t\t\tif (goal - i >= 0) {\n\t\t\t\tgoal = goal - i;\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tif (goal == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tout.print(count);\n\n\t\tout.flush();\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}\n", "src": "\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TaskA {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tlong i = sc.nextInt();\n\t\tlong goal = sc.nextLong();\n//\tlong goal=sum;\nif(i>goal) {\n\ti=goal;\n}\n\t\tint count = 0;\n\t\twhile (goal >= 0) {\n\t\t\tif (goal - i >= 0) {\n\t\t\t\tgoal = goal - i;\n\t\t\t\tcount++;\n\t\t\t} else\n\t\t\t\ti--;\n\t\t\tif (goal == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tout.print(count);\n\n\t\tout.flush();\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}\n", "index": 95, "complexity": 3}
{"back-translation": "import java.util.*;\npublic class A {\n    public static int palin(String str) {\n        int flag = 0;\n        int l = str.length();\n        for (int i = 0; i < l / 2; i++) {\n            if (str.charAt(i) != str.charAt(l - i - 1)) {\n                flag = 1;\n                break;\n            }\n        }\n        if (flag == 1)\n            return 0;\n        else\n            return 1;\n    }\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        HashSet<Character> hs = new HashSet<>();\n        for (int i = 0; i < str.length(); i++)\n            hs.add(str.charAt(i));\n        if (hs.size() == 1)\n            System.out.println(0);\n        else if (palin(str) == 0)\n            System.out.println(str.length());\n        else\n            System.out.println(str.length() - 1);\n    }\n}", "src": "import java.util.*;\npublic class A\n{\n    public static int palin(String str)\n    {\n        int flag=0;\n        int l=str.length();\n        for(int i=0;i<l/2;i++)\n        {\n            if(str.charAt(i)!=str.charAt(l-i-1))\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==1)\n        return 0;\n        else\n        return 1;\n    }\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        String str=sc.next();\n        HashSet<Character> hs=new HashSet<>();\n        for(int i=0;i<str.length();i++)\n        {\n            hs.add(str.charAt(i));\n        }\n        if(hs.size()==1)\n        System.out.println(0);\n        else if(palin(str)==0)\n        System.out.println(str.length());\n        else\n        System.out.println(str.length()-1);\n    }\n}", "index": 96, "complexity": 3}
{"back-translation": "import java.io.OutputStream;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        contest1 solver = new contest1();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class contest1 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int x = in.nextInt();\n            String s = \"\";\n            int count = 0;\n            int copya = a;\n            int copyb = b;\n            int change = 0;\n            if (x == 1) {\n                if (copya > copyb) {\n                    while (a > 0) {\n                        s = s + '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s = s + '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s = s + '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s = s + '0';\n                        a--;\n                    }\n                }\n            } else {\n                if (copya > copyb) {\n                    while (change <= x - 1) {\n                        if (change % 2 == 0) {\n                            s = s + '0';\n                            change++;\n                            a--;\n                        } else {\n                            s = s + '1';\n                            change++;\n                            b--;\n                        }\n                    }\n                } else if (copyb >= copya) {\n                    while (change <= x - 1) {\n                        if (change % 2 == 0) {\n                            s = s + '1';\n                            change++;\n                            b--;\n                        } else {\n                            s = s + '0';\n                            change++;\n                            a--;\n                        }\n                    }\n                }\n                char z = s.charAt(s.length() - 1);\n                if (z == '0') {\n                    while (a > 0) {\n                        s = s + '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s = s + '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s = s + '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s = s + '0';\n                        a--;\n                    }\n                }\n            }\n            out.println(s);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Priya\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        contest1 solver = new contest1();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class contest1 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int x = in.nextInt();\n            String s = \"\";\n            int count = 0;\n\n            int copya = a;\n            int copyb = b;\n            int change = 0;\n\n            if (x == 1) {\n                if (copya > copyb) {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n\n                }\n\n            } else {\n                // out.println(\"got in\");\n                if (copya > copyb) {\n                    while (change <= x - 1) {\n                        if (change % 2 == 0) {\n                            s += '0';\n                            change++;\n                            a--;\n                        } else {\n                            s += '1';\n                            change++;\n                            b--;\n                        }\n                    }\n\n                } else if (copyb >= copya) {\n                    //out.println(\"got in in \");\n                    while (change <= x - 1) {\n                        //out.println(change+\" hmm\");\n                        if (change % 2 == 0) {\n                            s += '1';\n                            change++;\n                            b--;\n                        } else {\n                            s += '0';\n                            change++;\n                            a--;\n                        }\n                    }\n                }\n\n                char z = s.charAt(s.length() - 1);\n                //out.println(z+\" hm\");\n                if (z == '0') {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                }\n            }\n            out.println(s);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "index": 97, "complexity": 3}
{"back-translation": "class GFG { static int sum = 0; static class Node { int data; Node left, right; } static Node getNode(int data) { Node newNode = new Node(); newNode.data = data; newNode.left = newNode.right = null; return newNode; } static void sumOfParentOfX(Node root, int x) { if (root == null) return; if ((root.left != null && root.left.data == x) || (root.right != null && root.right.data == x)) sum += root.data; sumOfParentOfX(root.left, x); sumOfParentOfX(root.right, x); } static int sumOfParentOfXUtil(Node root, int x) { sum = 0; sumOfParentOfX(root, x); return sum; } public static void main(String args[]) { Node root = getNode(4); root.left = getNode(2); root.right = getNode(5); root.left.left = getNode(7); root.left.right = getNode(2); root.right.left = getNode(2); root.right.right = getNode(3); int x = 2; System.out.println(\"Sum = \" + sumOfParentOfXUtil(root, x)); } }", "src": "\n// Java implementation to find \n// the sum of all the parent \n// nodes having child node x \nclass\nGFG \n{ \n// sum \nstatic\nint\nsum = \n0\n; \n\n\n// Node of a binary tree \nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n// function to get a new node \nstatic\nNode getNode(\nint\ndata) \n{ \n\n// allocate memory for the node \n\nNode newNode = \nnew\nNode(); \n\n\n// put in the data \n\nnewNode.data = data; \n\nnewNode.left = newNode.right = \nnull\n; \n\nreturn\nnewNode; \n} \n\n// function to find the sum of all the \n// parent nodes having child node x \nstatic\nvoid\nsumOfParentOfX(Node root, \nint\nx) \n{ \n\n// if root == NULL \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n// if left or right child \n\n// of root is 'x', then \n\n// add the root's data to 'sum' \n\nif\n((root.left != \nnull\n&& root.left.data == x) || \n\n(root.right != \nnull\n&& root.right.data == x)) \n\nsum += root.data; \n\n\n// recursively find the required \n\n// parent nodes in the left and \n\n// right subtree \n\nsumOfParentOfX(root.left, x); \n\nsumOfParentOfX(root.right, x); \n\n} \n\n// utility function to find the \n// sum of all the parent nodes \n// having child node x \nstatic\nint\nsumOfParentOfXUtil(Node root, \n\nint\nx) \n{ \n\nsum = \n0\n; \n\nsumOfParentOfX(root, x); \n\n\n// required sum of parent nodes \n\nreturn\nsum; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n// binary tree formation \n\nNode root = getNode(\n4\n); \n// 4 \n\nroot.left = getNode(\n2\n); \n// / \\ \n\nroot.right = getNode(\n5\n); \n// 2 5 \n\nroot.left.left = getNode(\n7\n); \n// / \\ / \\ \n\nroot.left.right = getNode(\n2\n); \n// 7 2 2 3 \n\nroot.right.left = getNode(\n2\n); \n\nroot.right.right = getNode(\n3\n); \n\n\nint\nx = \n2\n; \n\n\nSystem.out.println( \n\"Sum = \"\n+ \n\nsumOfParentOfXUtil(root, x)); \n} \n} \n\n// This code is contributed by Arnab Kundu ", "index": 98, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.InputMismatchException;\nimport java.util.NavigableSet;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, FastScanner in, FastPrinter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            char[] c = in.next().toCharArray();\n            NavigableSet<Integer> ones = new TreeSet<>();\n            NavigableSet<Integer> zeros = new TreeSet<>();\n            for (int i = 0; i < n; i++) {\n                if (c[i] == '0') zeros.add(i);\n                else ones.add(i);\n            }\n            if (ones.isEmpty() || zeros.isEmpty() || ones.last() - ones.first() + 1 <= k || zeros.last() - zeros.first() + 1 <= k) {\n                out.println(\"tokitsukaze\");\n                return;\n            }\n            if (check(ones, n, k) && check(zeros, n, k)) {\n                out.println(\"quailty\");\n                return;\n            }\n            out.println(\"once again\");\n        }\n\n        private boolean check(NavigableSet<Integer> ones, int n, int k) {\n            for (int i = 0; i + k <= n; i++) {\n                int left = ones.first();\n                int right = ones.last();\n                if (left >= i) {\n                    left = ones.higher(i + k - 1);\n                }\n                if (right < i + k) {\n                    right = ones.lower(i);\n                }\n                if (right - left + 1 > k) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class FastPrinter extends PrintWriter {\n        public FastPrinter(OutputStream out) {\n            super(out);\n        }\n\n        public FastPrinter(Writer out) {\n            super(out);\n        }\n\n    }\n\n    static class FastScanner extends BufferedReader {\n        public FastScanner(InputStream is) {\n            super(new InputStreamReader(is));\n        }\n\n        public int read() {\n            try {\n                int ret = super.read();\n                return ret;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n\n        public String next() {\n            StringBuilder sb = new StringBuilder();\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            if (c < 0) {\n                return null;\n            }\n            while (c >= 0 && !isWhiteSpace(c)) {\n                sb.appendCodePoint(c);\n                c = read();\n            }\n            return sb.toString();\n        }\n\n        static boolean isWhiteSpace(int c) {\n            return c >= 0 && c <= 32;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int ret = 0;\n            while (c >= 0 && !isWhiteSpace(c)) {\n                if (c < '0' || c > '9') {\n                    throw new NumberFormatException(\"digit expected \" + (char) c\n                            + \" found\");\n                }\n                ret = ret * 10 + c - '0';\n                c = read();\n            }\n            return ret * sgn;\n        }\n\n        public String readLine() {\n            try {\n                return super.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.util.SortedSet;\nimport java.util.Set;\nimport java.util.NavigableSet;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, FastScanner in, FastPrinter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            char[] c = in.next().toCharArray();\n            NavigableSet<Integer> ones = new TreeSet<>();\n            NavigableSet<Integer> zeros = new TreeSet<>();\n            for (int i = 0; i < n; i++) {\n                if (c[i] == '0') zeros.add(i);\n                else ones.add(i);\n            }\n            if (ones.isEmpty() || zeros.isEmpty() || ones.last() - ones.first() + 1 <= k || zeros.last() - zeros.first() + 1 <= k) {\n                out.println(\"tokitsukaze\");\n                return;\n            }\n            if (check(ones, n, k) && check(zeros, n, k)) {\n                out.println(\"quailty\");\n                return;\n            }\n            out.println(\"once again\");\n        }\n\n        private boolean check(NavigableSet<Integer> ones, int n, int k) {\n            for (int i = 0; i + k <= n; i++) {\n                int left = ones.first();\n                int right = ones.last();\n                if (left >= i) {\n                    left = ones.higher(i + k - 1);\n                }\n                if (right < i + k) {\n                    right = ones.lower(i);\n                }\n                if (right - left + 1 > k) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class FastPrinter extends PrintWriter {\n        public FastPrinter(OutputStream out) {\n            super(out);\n        }\n\n        public FastPrinter(Writer out) {\n            super(out);\n        }\n\n    }\n\n    static class FastScanner extends BufferedReader {\n        public FastScanner(InputStream is) {\n            super(new InputStreamReader(is));\n        }\n\n        public int read() {\n            try {\n                int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n                return ret;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n\n        public String next() {\n            StringBuilder sb = new StringBuilder();\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            if (c < 0) {\n                return null;\n            }\n            while (c >= 0 && !isWhiteSpace(c)) {\n                sb.appendCodePoint(c);\n                c = read();\n            }\n            return sb.toString();\n        }\n\n        static boolean isWhiteSpace(int c) {\n            return c >= 0 && c <= 32;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int ret = 0;\n            while (c >= 0 && !isWhiteSpace(c)) {\n                if (c < '0' || c > '9') {\n                    throw new NumberFormatException(\"digit expected \" + (char) c\n                            + \" found\");\n                }\n                ret = ret * 10 + c - '0';\n                c = read();\n            }\n            return ret * sgn;\n        }\n\n        public String readLine() {\n            try {\n                return super.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n    }\n}\n\n", "index": 99, "complexity": 3}
{"back-translation": "class arr_rot { static void leftRotate(int arr[], int n, int k) { int mod = k % n; for (int i = 0; i < n; ++i) System.out.print(arr[(i + mod) % n] + \" \"); System.out.println(); } public static void main(String[] args) { int arr[] = { 1, 3, 5, 7, 9 }; int n = arr.length; int k = 2; leftRotate(arr, n, k); k = 3; leftRotate(arr, n, k); k = 4; leftRotate(arr, n, k); } }", "src": "\n// JAVA implementation of left rotation \n// of an array K number of times \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\narr_rot \n{ \n\n// Function to leftRotate array multiple \n\n// times \n\nstatic\nvoid\nleftRotate(\nint\narr[], \nint\nn, \n\nint\nk) \n\n{ \n\n/* To get the starting point of \n\nrotated array */\n\nint\nmod = k % n; \n\n\n// Prints the rotated array from \n\n// start position \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[(i + mod) % n] \n\n+ \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n5\n, \n7\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nint\nk = \n2\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n3\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n4\n; \n\nleftRotate(arr, n, k); \n\n} \n} \n\n// This code is contributed by Sanjal ", "index": 100, "complexity": 3}
{"back-translation": "public class GFG {\n\n    static int[] dp = new int[1000];\n\n    static int countFriendsPairings(int n) {\n        if (dp[n] != -1)\n            return dp[n];\n        if (n > 2)\n            return dp[n] = countFriendsPairings(n - 1) + (n - 1) * countFriendsPairings(n - 2);\n        else\n            return dp[n] = n;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 1000; i++)\n            dp[i] = -1;\n        int n = 4;\n        System.out.println(countFriendsPairings(n));\n    }\n}", "src": "\n// Java program for solution of friends \n// pairing problem Using Recursion \n\nclass\nGFG { \n\nstatic\nint\n[] dp = \nnew\nint\n[\n1000\n]; \n\n\n// Returns count of ways n people \n\n// can remain single or paired up. \n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nif\n(dp[n] != -\n1\n) \n\nreturn\ndp[n]; \n\n\nif\n(n > \n2\n) \n\nreturn\ndp[n] = countFriendsPairings(n - \n1\n) + (n - \n1\n) * countFriendsPairings(n - \n2\n); \n\nelse\n\nreturn\ndp[n] = n; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < \n1000\n; i++) \n\ndp[i] = -\n1\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n} \n\n// This code is contributed by Ita_c. ", "index": 101, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class X\n{\n\tpublic static void main(String args[])throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tString s1 = br.readLine();\n\t\tString s2 = br.readLine();\n\t\tint i=0;\n\t\tchar c1,c2;\n\t\tint cost = 0;\n\t\twhile(i<n)\n\t\t{\n\t\t\tc1 = s1.charAt(i);\n\t\t\tc2 = s2.charAt(i);\n\t\t\tif(c1 != c2)\n\t\t\t{\n\t\t\t\tif((i+1)<n && s1.charAt(i+1) != s2.charAt(i+1) && s1.charAt(i) != s1.charAt(i+1))\n\t\t\t\t{\n\t\t\t\t\tcost +=1;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcost +=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n}", "src": "import java.util.*;\nimport java.io.*;\npublic class X\n{\n\tpublic static void main(String args[])throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tString s1 = br.readLine();\n\t\tString s2 = br.readLine();\n\t\tint i=0;\n\t\tchar c1,c2;\n\t\tint cost = 0;\n\t\twhile(i<n)\n\t\t{\n\t\t\tc1 = s1.charAt(i);\n\t\t\tc2 = s2.charAt(i);\n\t\t\tif(c1 != c2)\n\t\t\t{\n\t\t\t\tif((i+1)<n && s1.charAt(i+1) != s2.charAt(i+1) && s1.charAt(i) != s1.charAt(i+1))\n\t\t\t\t{\n\t\t\t\t\tcost +=1;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcost +=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n}", "index": 102, "complexity": 3}
{"back-translation": "class GFG { static void rearrange(int arr[], int n) { for (int i = 0; i < n; i++) { arr[arr[i] % n] += i * n; } for (int i = 0; i < n; i++) { arr[i] /= n; } } static void printArray(int arr[], int n) { for (int i = 0; i < n; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); } public static void main(String[] args) { int arr[] = { 2, 0, 1, 4, 5, 3 }; int n = arr.length; System.out.println(\"Given array is : \"); printArray(arr, n); rearrange(arr, n); System.out.println(\"Modified array is :\"); printArray(arr, n); } }", "src": "\n// A simple JAVA program to rearrange \n// contents of arr[] such that arr[j] \n// becomes j if arr[i] is j \n\nclass\nGFG { \n\n\n// A simple method to rearrange \n\n// 'arr[0..n-1]' so that 'arr[j]' \n\n// becomes 'i' if 'arr[i]' is 'j' \n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// retrieving old value and \n\n// storing with the new one \n\narr[arr[i] % n] += i * n; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// retrieving new value \n\narr[i] /= n; \n\n} \n\n} \n\n\n// A utility function to print \n\n// contents of arr[0..n-1] \n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n// Drive code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is : \"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is :\"\n); \n\nprintArray(arr, n); \n\n} \n} \n\n// This code has been contributed by 29AjayKumar ", "index": 103, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\nclass GFG {\n\n    static void printVector(Vector<Integer> v) {\n        System.out.println(v.size());\n\n        for (int i = 0; i < v.size(); i++)\n            System.out.print(v.get(i) + \" \");\n\n        System.out.println();\n    }\n\n    static void findTwoGroup(int n) {\n        int sum = n * (n + 1) / 2;\n        int group1Sum = sum / 2;\n        Vector<Integer> group1 = new Vector<Integer>();\n        Vector<Integer> group2 = new Vector<Integer>();\n\n        for (int i = n; i > 0; i--) {\n            if (group1Sum - i >= 0) {\n                group1.add(i);\n                group1Sum -= i;\n            } else {\n                group2.add(i);\n            }\n        }\n\n        printVector(group1);\n        printVector(group2);\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        findTwoGroup(n);\n    }\n}", "src": "\n// Java program to divide n integers \n// in two groups such that absolute \n// difference of their sum is minimum \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n// To print vector along size \n\nstatic\nvoid\nprintVector(Vector<Integer> v) \n\n{ \n\n// Print vector size \n\nSystem.out.println(v.size()); \n\n\n// Print vector elements \n\nfor\n(\nint\ni = \n0\n; i < v.size(); i++) \n\nSystem.out.print(v.get(i) + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n// To divide n in two groups such that \n\n// absolute difference of their sum is \n\n// minimum \n\nstatic\nvoid\nfindTwoGroup(\nint\nn) \n\n{ \n\n// Find sum of all elements upto n \n\nint\nsum = n * (n + \n1\n) / \n2\n; \n\n\n// Sum of elements of group1 \n\nint\ngroup1Sum = sum / \n2\n; \n\n\nVector<Integer> group1 = \nnew\nVector<Integer>(); \n\nVector<Integer> group2 = \nnew\nVector<Integer>(); \n\n\nfor\n(\nint\ni = n; i > \n0\n; i--) { \n\n\n// If sum is greater then or equal \n\n// to 0 include i in group1 \n\n// otherwise include in group2 \n\nif\n(group1Sum - i >= \n0\n) { \n\n\ngroup1.add(i); \n\n\n// Decrease sum of group1 \n\ngroup1Sum -= i; \n\n} \n\nelse\n{ \n\ngroup2.add(i); \n\n} \n\n} \n\n\n// Print both the groups \n\nprintVector(group1); \n\nprintVector(group2); \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nfindTwoGroup(n); \n\n} \n} \n\n// This code is contributed by Gitanjali. ", "index": 104, "complexity": 3}
{"back-translation": "import java.util.Arrays; public class GFG { static int minSum(int[] A, int n) { int min_val = Arrays.stream(A).min().getAsInt(); return (min_val * (n - 1)); } public static void main(String[] args) { int[] A = { 3, 6, 2, 8, 7, 5 }; int n = A.length; System.out.println((minSum(A, n))); } }", "src": "\n// Java program to minimize the \n// cost of array minimization \nimport\njava.util.Arrays; \n\npublic\nclass\nGFG { \n\n// Returns minimum possible \n// sum in array B[] \n\nstatic\nint\nminSum(\nint\n[] A, \nint\nn) { \n\nint\nmin_val = Arrays.stream(A).min().getAsInt(); \n\nreturn\n(min_val * (n - \n1\n)); \n\n} \n\n\n// Driver Code \n\nstatic\npublic\nvoid\nmain(String[] args) { \n\nint\n[] A = {\n3\n, \n6\n, \n2\n, \n8\n, \n7\n, \n5\n}; \n\nint\nn = A.length; \n\nSystem.out.println((minSum(A, n))); \n\n\n} \n} \n// This code is contributed by Rajput-Ji ", "index": 105, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public void solve() {\n        int n = ni();\n        int a = ni();\n        int b = ni();\n\n        long ans = 0;\n        HashMap<Long, Long> m = new HashMap<>();\n        HashMap<String, Long> s = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            ni();\n            long vx = ni();\n            long vy = ni();\n            long v = (long) a * vx - vy;\n            String k = vx + \"|\" + vy;\n            long cs = s.getOrDefault(k, 0L);\n            long c = m.getOrDefault(v, 0L);\n            ans += c - cs;\n            m.put(v, c + 1);\n            s.put(k, cs + 1);\n        }\n        write (ans * 2 + \"\\n\");\n    }\n\n    public static void main(String[] args) {\n        Main m = new Main();\n        m.solve();\n        try {\n            m.out.close();\n        } catch (IOException e) {}\n    }\n\n    BufferedReader in;\n    BufferedWriter out;\n    StringTokenizer tokenizer;\n\n    public Main() {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new BufferedWriter(new OutputStreamWriter(System.out));\n    }\n\n    public String n() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(in.readLine());\n            } catch (IOException e) {}\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int ni() {\n        return Integer.parseInt(n());\n    }\n\n    public long nl() {\n        return Long.parseLong(n());\n    }\n\n    public void write(String s) {\n        try {\n            out.write(s);\n        } catch (IOException e) {}\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public void solve() {\n        int n = ni();\n        int a = ni();\n        int b = ni();\n\n        long ans = 0;\n        HashMap<Long, Long> m = new HashMap<>();\n        HashMap<String, Long> s = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            ni();\n            long vx = ni();\n            long vy = ni();\n            long v = (long) a * vx - vy;\n            String k = vx + \"|\" + vy;\n            long cs = s.getOrDefault(k, 0L);\n            long c = m.getOrDefault(v, 0L);\n            ans += c - cs;\n            m.put(v, c + 1);\n            s.put(k, cs + 1);\n        }\n        write (ans * 2 + \"\\n\");\n    }\n\n\n\n    public static void main(String[] args) {\n        Main m = new Main();\n        m.solve();\n        try {\n            m.out.close();\n        } catch (IOException e) {}\n    }\n\n    BufferedReader in;\n    BufferedWriter out;\n    StringTokenizer tokenizer;\n    public Main() {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new BufferedWriter(new OutputStreamWriter(System.out));\n    }\n    public String n() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(in.readLine());\n            } catch (IOException e) {}\n        }\n        return tokenizer.nextToken();\n    }\n    public int ni() {\n        return Integer.parseInt(n());\n    }\n    public long nl() {\n        return Long.parseLong(n());\n    }\n    public void write(String s) {\n        try {\n            out.write(s);\n        } catch (IOException e) {}\n    }\n}", "index": 106, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class LectureSleep {\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n    }\n\n    static InputReader r = new InputReader(System.in);\n    static PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        int n = r.nextInt();\n        int k = r.nextInt();\n        int[] theorems = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            theorems[i] = r.nextInt();\n        }\n        int[] mishka = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            mishka[i] = r.nextInt();\n        }\n        int[] sums = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            if (mishka[i] == 0) {\n                sums[i] = sums[i - 1] + theorems[i];\n            } else {\n                sums[i] = sums[i - 1];\n            }\n        }\n        int max = 0;\n        for (int i = 1; i <= n - k + 1; i++) {\n            int sum = sums[i + k - 1] - sums[i - 1];\n            max = Math.max(max, sum);\n        }\n        int totalSum = 0;\n        for (int i = 1; i <= n; i++) {\n            if (mishka[i] == 1) {\n                totalSum += theorems[i];\n            }\n        }\n        pw.println(totalSum + max);\n        pw.close();\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class LectureSleep {\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n    }\n\n    static InputReader r = new InputReader(System.in);\n    static PrintWriter pw = new PrintWriter(System.out);\n\n\n    public static void main(String[] args) {\n        int n = r.nextInt(); // duration of lecture\n        int k = r.nextInt(); // number of minutes keep mishka awake\n        int[] theorems = new int[n+1];\n        for(int i = 1; i <= n; i++){\n            theorems[i] = r.nextInt();\n        }\n        int[] mishka = new int[n+1];\n        for(int i = 1; i <= n; i++){\n            mishka[i] = r.nextInt();\n        }\n        int[] sums = new int[n+1];\n        for(int i = 1; i <= n; i++){\n            if(mishka[i] == 0){\n                sums[i] = sums[i-1] + theorems[i];\n            } else{\n                sums[i] = sums[i-1];\n            }\n        }\n        int max = 0;\n        for(int i = 1; i <= n-k+1; i++){\n            int sum = sums[i+k-1] - sums[i-1];\n            max = Math.max(max, sum);\n        }\n        int totalSum = 0;\n        for(int i = 1; i <= n; i++){\n            if(mishka[i] == 1){\n                totalSum += theorems[i];\n            }\n        }\n\n        pw.println(totalSum + max);\n\n        pw.close();\n    }\n}", "index": 107, "complexity": 3}
{"back-translation": "import java.util.Arrays;\n\npublic class PairDifference {\n\n    static boolean findPair(int[] arr, int n) {\n        Arrays.sort(arr);\n        int i = 0, j = 1;\n        while (i < arr.length && j < arr.length) {\n            if (i != j && arr[j] - arr[i] == n) {\n                System.out.print(\"Pair Found: ( \" + arr[i] + \", \" + arr[j] + \" )\");\n                return true;\n            } else if (arr[j] - arr[i] < n) {\n                j++;\n            } else {\n                i++;\n            }\n        }\n        System.out.print(\"No such pair\");\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 8, 30, 40, 100};\n        int n = 60;\n        findPair(arr, n);\n    }\n}", "src": "\n// Java program to find a pair with the given difference \nimport\njava.io.*; \n\nclass\nPairDifference \n{ \n\n// The function assumes that the array is sorted \n\nstatic\nboolean\nfindPair(\nint\narr[],\nint\nn) \n\n{ \n\nint\nsize = arr.length; \n\n\n// Initialize positions of two elements \n\nint\ni = \n0\n, j = \n1\n; \n\n\n// Search for a pair \n\nwhile\n(i < size && j < size) \n\n{ \n\nif\n(i != j && arr[j]-arr[i] == n) \n\n{ \n\nSystem.out.print(\n\"Pair Found: \"\n+ \n\n\"( \"\n+arr[i]+\n\", \"\n+ arr[j]+\n\" )\"\n); \n\nreturn\ntrue\n; \n\n} \n\nelse\nif\n(arr[j] - arr[i] < n) \n\nj++; \n\nelse\n\ni++; \n\n} \n\n\nSystem.out.print(\n\"No such pair\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n8\n, \n30\n, \n40\n, \n100\n}; \n\nint\nn = \n60\n; \n\nfindPair(arr,n); \n\n} \n} \n/*This code is contributed by Devesh Agrawal*/", "index": 108, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n    private void solve() {\n        int n = scanner.nextInt();\n\n        Map<Integer, Integer> cnt = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            String s = scanner.nextLine();\n\n            LinkedList<Character> st = new LinkedList<>();\n\n            for (char c : s.toCharArray()) {\n                if (c == ')' && !st.isEmpty() && st.getLast() == '(') {\n                    st.pollLast();\n                    continue;\n                }\n                st.addLast(c);\n            }\n\n            int t = st.size();\n            Set<Character> set = new HashSet<>(st);\n            if (set.size() > 1) {\n                continue;\n            }\n            if (set.isEmpty()) {\n                cnt.put(0, cnt.getOrDefault(0, 0) + 1);\n                continue;\n            }\n\n            if (st.getLast() == '(') {\n                cnt.put(t, cnt.getOrDefault(t, 0) + 1);\n            } else {\n                cnt.put(-t, cnt.getOrDefault(-t, 0) + 1);\n            }\n        }\n\n        long ans = 0;\n\n        for (int next : cnt.keySet()) {\n            if (next == 0) {\n                ans += (long) cnt.get(next) * (cnt.get(next) - 1) + cnt.get(next);\n            } else if (next > 0) {\n                int t = next * -1;\n                if (cnt.containsKey(t)) {\n                    ans += (long) cnt.get(next) * cnt.get(t);\n                }\n            }\n        }\n\n        System.out.print(ans);\n\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n\n    private void solve() {\n        int n = scanner.nextInt();\n\n        Map<Integer, Integer> cnt = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            String s = scanner.nextLine();\n\n            LinkedList<Character> st = new LinkedList<>();\n\n            for (char c : s.toCharArray()) {\n                if (c == ')' && !st.isEmpty() && st.getLast() == '(') {\n                    st.pollLast();\n                    continue;\n                }\n                st.addLast(c);\n            }\n\n            int t = st.size();\n            Set<Character> set = new HashSet<>(st);\n            if (set.size() > 1) {\n                continue;\n            }\n            if (set.isEmpty()) {\n                cnt.put(0, cnt.getOrDefault(0, 0) + 1);\n                continue;\n            }\n\n            if (st.getLast() == '(') {\n                cnt.put(t, cnt.getOrDefault(t, 0) + 1);\n            } else {\n                cnt.put(-t, cnt.getOrDefault(-t, 0) + 1);\n            }\n        }\n\n        long ans = 0;\n\n        for (int next : cnt.keySet()) {\n            if (next == 0) {\n                ans += (long) cnt.get(next) * (cnt.get(next) - 1) + cnt.get(next);\n            } else if (next > 0) {\n                int t = next * -1;\n                if (cnt.containsKey(t)) {\n                    ans += (long) cnt.get(next) * cnt.get(t);\n                }\n            }\n        }\n\n        System.out.print(ans);\n\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "index": 109, "complexity": 3}
{"back-translation": "import java.util.HashMap;\nclass MajorityElement {\nprivate static void findMajority(int[] arr) {\nHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\nfor (int i = 0; i < arr.length; i++) {\nif (map.containsKey(arr[i])) {\nint count = map.get(arr[i]) + 1;\nif (count > arr.length / 2) {\nSystem.out.println(\"Majority found :- \" + arr[i]);\nreturn;\n}\nelse\nmap.put(arr[i], count);\n}\nelse\nmap.put(arr[i], 1);\n}\nSystem.out.println(\" No Majority element\");\n}\npublic static void main(String[] args) {\nint a[] = new int[]{2, 2, 2, 2, 5, 5, 2, 3, 3};\nfindMajority(a);\n}\n}", "src": "\nimport\njava.util.HashMap; \n\n/* Program for finding out majority element in an array */\n\nclass\nMajorityElement \n{ \n\nprivate\nstatic\nvoid\nfindMajority(\nint\n[] arr) \n\n{ \n\nHashMap<Integer,Integer> map = \nnew\nHashMap<Integer, Integer>(); \n\n\nfor\n(\nint\ni = \n0\n; i < arr.length; i++) { \n\nif\n(map.containsKey(arr[i])) { \n\nint\ncount = map.get(arr[i]) +\n1\n; \n\nif\n(count > arr.length /\n2\n) { \n\nSystem.out.println(\n\"Majority found :- \"\n+ arr[i]); \n\nreturn\n; \n\n} \nelse\n\nmap.put(arr[i], count); \n\n\n} \n\nelse\n\nmap.put(arr[i],\n1\n); \n\n} \n\nSystem.out.println(\n\" No Majority element\"\n); \n\n} \n\n\n\n/* Driver program to test the above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = \nnew\nint\n[]{\n2\n,\n2\n,\n2\n,\n2\n,\n5\n,\n5\n,\n2\n,\n3\n,\n3\n}; \n\n\nfindMajority(a); \n\n} \n} \n// This code is contributed by karan malhotra ", "index": 110, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Test{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint num = 1;\n\t\tint add;\n\t\tint i = 1;\n\t\twhile (i < n) {\n\t\t\tadd = 4 * i;\n\t\t\tnum += add;\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(num);\n\t}\n}", "src": "import java.util.Scanner;\n\npublic class Test{\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint num=1;\n\t\tint add;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tadd=4*i;\n\t\t\tnum+=add;\n\t\t}\n\t\tSystem.out.println(num);\n\t}\n}", "index": 111, "complexity": 3}
{"back-translation": "import java.util.Arrays;\n\npublic class Test {\n\n    static int arr[] = new int[]{1, 2, 3, 4, 5};\n\n    static void rotate() {\n\n        int x = arr[arr.length - 1], i;\n\n        for (i = arr.length - 1; i > 0; i--) {\n            arr[i] = arr[i - 1];\n        }\n\n        arr[0] = x;\n    }\n\n    public static void main(String[] args) {\n\n        System.out.println(\"Given Array is\");\n        System.out.println(Arrays.toString(arr));\n\n        rotate();\n\n        System.out.println(\"Rotated Array is\");\n        System.out.println(Arrays.toString(arr));\n    }\n}", "src": "\nimport\njava.util.Arrays; \n\npublic\nclass\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n1\n, \n2\n, \n3\n, \n4\n, \n5\n}; \n\n\n// Method for rotation \n\nstatic\nvoid\nrotate() \n\n{ \n\nint\nx = arr[arr.length-\n1\n], i; \n\nfor\n(i = arr.length-\n1\n; i > \n0\n; i--) \n\narr[i] = arr[i-\n1\n]; \n\narr[\n0\n] = x; \n\n} \n\n\n/* Driver program */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Given Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n\nrotate(); \n\n\nSystem.out.println(\n\"Rotated Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n} \n} ", "index": 112, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class BOOL {\n    static char [][]ch;\n    static int n,m;\nprivate static FastReader in =new FastReader();\n    public static void main(String[] args) {\n    int n=in.nextInt();\n    int a[]=new int[1000002];\n    int dp[]=new int[1000002],ans=0;\n    for(int i=0;i<n;i++){a[in.nextInt()]=in.nextInt();}\n    dp[0]=a[0]==0?0:1;\n    for(int i=1;i<1000002;i++){\n    if(a[i]==0){dp[i]=dp[i-1];}\n    else{\n    if(a[i]>=i){dp[i]=1;}\n    else{\n    dp[i]=dp[i-a[i]-1]+1;\n    }}\n    if(dp[i]>=ans)ans=dp[i];\n    }\n    System.out.println(n-ans);\n}\n}\nclass FastReader\n{\n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader()\n    {\n        br = new BufferedReader(new\n                 InputStreamReader(System.in));\n    }\n    String next()\n    {\n        while (st == null || !st.hasMoreElements())\n    {\n        try\n        {\n            st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n            e.printStackTrace();\n        }\n    }\n    return st.nextToken();\n    }\n    int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n    long nextLong()\n    {\n        return Long.parseLong(next());\n    }\n    double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n    String nextLine()\n    {\n        String str = \"\";\n        try\n        {\n            str = br.readLine();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class BOOL {\n    static char [][]ch;\n    static int n,m;\nprivate static FastReader in =new FastReader();\n    public static void main(String[] args) {\n    int n=in.nextInt();\n    int a[]=new int[1000002];\n    int dp[]=new int[1000002],ans=0;\n    for(int i=0;i<n;i++){a[in.nextInt()]=in.nextInt();}\n    dp[0]=a[0]==0?0:1;\n    for(int i=1;i<1000002;i++){\n    if(a[i]==0){dp[i]=dp[i-1];}\n    else{\n    if(a[i]>=i){dp[i]=1;}\n    else{\n    dp[i]=dp[i-a[i]-1]+1;\n    }}\n    if(dp[i]>=ans)ans=dp[i];\n    }\n        System.out.println(n-ans);\n    }}\nclass FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n}\n", "index": 113, "complexity": 3}
{"back-translation": "class Node { int data; Node left, right; Node(int item) { data = item; left = right = null; } } class BinaryTree { Node root; boolean isFullTree(Node node) { if (node == null) return true; if (node.left == null && node.right == null) return true; if ((node.left!=null) && (node.right!=null)) return (isFullTree(node.left) && isFullTree(node.right)); return false; } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); tree.root = new Node(10); tree.root.left = new Node(20); tree.root.right = new Node(30); tree.root.left.right = new Node(40); tree.root.left.left = new Node(50); tree.root.right.left = new Node(60); tree.root.left.left.left = new Node(80); tree.root.right.right = new Node(70); tree.root.left.left.right = new Node(90); tree.root.left.right.left = new Node(80); tree.root.left.right.right = new Node(90); tree.root.right.left.left = new Node(80); tree.root.right.left.right = new Node(90); tree.root.right.right.left = new Node(80); tree.root.right.right.right = new Node(90); if (tree.isFullTree(tree.root)) System.out.print(\"The binary tree is full\"); else System.out.print(\"The binary tree is not full\"); } }", "src": "\n// Java program to check if binay tree is full or not \n\n/* Tree node structure */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* this function checks if a binary tree is full or not */\n\nboolean\nisFullTree(Node node) \n\n{ \n\n// if empty tree \n\nif\n(node == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// if leaf node \n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// if both left and right subtrees are not null \n\n// the are full \n\nif\n((node.left!=\nnull\n) && (node.right!=\nnull\n)) \n\nreturn\n(isFullTree(node.left) && isFullTree(node.right)); \n\n\n// if none work \n\nreturn\nfalse\n; \n\n} \n\n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n20\n); \n\ntree.root.right = \nnew\nNode(\n30\n); \n\ntree.root.left.right = \nnew\nNode(\n40\n); \n\ntree.root.left.left = \nnew\nNode(\n50\n); \n\ntree.root.right.left = \nnew\nNode(\n60\n); \n\ntree.root.left.left.left = \nnew\nNode(\n80\n); \n\ntree.root.right.right = \nnew\nNode(\n70\n); \n\ntree.root.left.left.right = \nnew\nNode(\n90\n); \n\ntree.root.left.right.left = \nnew\nNode(\n80\n); \n\ntree.root.left.right.right = \nnew\nNode(\n90\n); \n\ntree.root.right.left.left = \nnew\nNode(\n80\n); \n\ntree.root.right.left.right = \nnew\nNode(\n90\n); \n\ntree.root.right.right.left = \nnew\nNode(\n80\n); \n\ntree.root.right.right.right = \nnew\nNode(\n90\n); \n\n\nif\n(tree.isFullTree(tree.root)) \n\nSystem.out.print(\n\"The binary tree is full\"\n); \n\nelse\n\nSystem.out.print(\n\"The binary tree is not full\"\n); \n\n} \n} \n\n// This code is contributed by Mayank Jaiswal ", "index": 114, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class A{\n       \n       public static void main(String args[]){\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int ans = 0;\n              int i = 1;\n              while(i <= n){\n                     ans += ((i*2) <= n) ? i : n-i+1;\n                     i++;\n              }\n              System.out.println(ans);\n       }\n}", "src": "import java.util.*;\nimport java.io.*;\npublic class A{\n       \n       public static void main(String args[]){\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int ans = 0;\n              for(int i = 1; i <= n; i++){\n                     ans += ((i*2) <= n) ? i : n-i+1;\n              }\n              System.out.println(ans);\n       }\n}", "index": 115, "complexity": 3}
{"back-translation": "public class GfG { static class Node { int data; Node left, right; } static Node newNode(int item) { Node temp = new Node(); temp.data = item; temp.left = null; temp.right = null; return temp; } static int getLevel(Node root, Node node, int level) { if (root == null) return 0; if (root == node) return level; int downlevel = getLevel(root.left, node, level+1); if (downlevel != 0) return downlevel; return getLevel(root.right, node, level+1); } static void printGivenLevel(Node root, Node node, int level) { if (root == null || level < 2) return; if (level == 2) { if (root.left == node || root.right == node) return; if (root.left != null) System.out.print(root.left.data + \" \"); if (root.right != null) System.out.print(root.right.data + \" \"); } else if (level > 2) { printGivenLevel(root.left, node, level-1); printGivenLevel(root.right, node, level-1); } } static void printCousins(Node root, Node node) { int level = getLevel(root, node, 1); printGivenLevel(root, node, level); } public static void main(String[] args) { Node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); root.left.right.right = newNode(15); root.right.left = newNode(6); root.right.right = newNode(7); root.right.left.right = newNode(8); printCousins(root, root.left.right); } }", "src": "\n// Java program to print cousins of a node \nclass\nGfG { \n\n// A Binary Tree Node \nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n// A utility function to create a new Binary \n// Tree Node \nstatic\nNode newNode(\nint\nitem) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = item; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n/* It returns level of the node if it is present \nin tree, otherwise returns 0.*/\nstatic\nint\ngetLevel(Node root, Node node, \nint\nlevel) \n{ \n\n// base cases \n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root == node) \n\nreturn\nlevel; \n\n\n// If node is present in left subtree \n\nint\ndownlevel = getLevel(root.left, node, level+\n1\n); \n\nif\n(downlevel != \n0\n) \n\nreturn\ndownlevel; \n\n\n// If node is not present in left subtree \n\nreturn\ngetLevel(root.right, node, level+\n1\n); \n} \n\n/* Print nodes at a given level such that sibling of \nnode is not printed if it exists */\nstatic\nvoid\nprintGivenLevel(Node root, Node node, \nint\nlevel) \n{ \n\n// Base cases \n\nif\n(root == \nnull\n|| level < \n2\n) \n\nreturn\n; \n\n\n// If current node is parent of a node with \n\n// given level \n\nif\n(level == \n2\n) \n\n{ \n\nif\n(root.left == node || root.right == node) \n\nreturn\n; \n\nif\n(root.left != \nnull\n) \n\nSystem.out.print(root.left.data + \n\" \"\n); \n\nif\n(root.right != \nnull\n) \n\nSystem.out.print(root.right.data + \n\" \"\n); \n\n} \n\n\n// Recur for left and right subtrees \n\nelse\nif\n(level > \n2\n) \n\n{ \n\nprintGivenLevel(root.left, node, level-\n1\n); \n\nprintGivenLevel(root.right, node, level-\n1\n); \n\n} \n} \n\n// This function prints cousins of a given node \nstatic\nvoid\nprintCousins(Node root, Node node) \n{ \n\n// Get level of given node \n\nint\nlevel = getLevel(root, node, \n1\n); \n\n\n// Print nodes of given level. \n\nprintGivenLevel(root, node, level); \n} \n\n// Driver Program to test above functions \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.left.right.right = newNode(\n15\n); \n\nroot.right.left = newNode(\n6\n); \n\nroot.right.right = newNode(\n7\n); \n\nroot.right.left.right = newNode(\n8\n); \n\n\nprintCousins(root, root.left.right); \n} \n} ", "index": 117, "complexity": 3}
{"back-translation": "import java.util.Arrays; public class GFG { static boolean sortedAfterSwap(int A[], boolean B[], int n) { int i, j; for (i = 0; i < n - 1; i++) { if (B[i]) { j = i; while (B[j]) { j++; } Arrays.sort(A, i, 1 + j); i = j; } } for (i = 0; i < n; i++) { if (A[i] != i + 1) { return false; } } return true; } public static void main(String[] args) { int A[] = { 1, 2, 5, 3, 4, 6}; boolean B[] = { false, true, true, true, false}; int n = A.length; if (sortedAfterSwap(A, B, n)) { System.out.println(\"A can be sorted\"); } else { System.out.println(\"A can not be sorted\"); } } }", "src": "\nimport\njava.util.Arrays; \n\n// Java program to test whether an array \n// can be sorted by swapping adjacent \n// elements using boolean array \n\nclass\nGFG { \n\n\n// Return true if array can be \n\n// sorted otherwise false \n\nstatic\nboolean\nsortedAfterSwap(\nint\nA[], \n\nboolean\nB[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\n// Check bool array B and sorts \n\n// elements for continuos sequence of 1 \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) { \n\nif\n(B[i]) { \n\nj = i; \n\nwhile\n(B[j]) { \n\nj++; \n\n} \n\n// Sort array A from i to j \n\nArrays.sort(A, i, \n1\n+ j); \n\ni = j; \n\n} \n\n} \n\n\n// Check if array is sorted or not \n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n(A[i] != i + \n1\n) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n// Driver program to test sortedAfterSwap() \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n1\n, \n2\n, \n5\n, \n3\n, \n4\n, \n6\n}; \n\nboolean\nB[] = { \nfalse\n, \ntrue\n, \ntrue\n, \ntrue\n, \nfalse\n}; \n\nint\nn = A.length; \n\n\nif\n(sortedAfterSwap(A, B, n)) { \n\nSystem.out.println(\n\"A can be sorted\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"A can not be sorted\"\n); \n\n} \n\n} \n} ", "index": 118, "complexity": 3}
{"back-translation": "import java.util.LinkedList;\nimport java.util.Queue;\n\nclass Node {\n    int data;\n    Node left, right;\n\n    public Node(int item) {\n        data = item;\n        left = right = null;\n    }\n}\n\nclass BinaryTree {\n    Node root;\n\n    void printSpecificLevelOrder(Node node) {\n        if (node == null) return;\n\n        System.out.print(node.data);\n\n        if (node.left != null)\n            System.out.print(\" \" + node.left.data + \" \" + node.right.data);\n\n        if (node.left.left == null) return;\n\n        Queue<Node> q = new LinkedList<>();\n        q.add(node.left);\n        q.add(node.right);\n\n        Node first = null, second = null;\n\n        while (!q.isEmpty()) {\n            first = q.peek();\n            q.remove();\n            second = q.peek();\n            q.remove();\n\n            System.out.print(\" \" + first.left.data + \" \" + second.right.data);\n            System.out.print(\" \" + first.right.data + \" \" + second.left.data);\n\n            if (first.left.left != null) {\n                q.add(first.left);\n                q.add(second.right);\n                q.add(first.right);\n                q.add(second.left);\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n\n        tree.root = new Node(1);\n        tree.root.left = new Node(2);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(4);\n        tree.root.left.right = new Node(5);\n        tree.root.right.left = new Node(6);\n        tree.root.right.right = new Node(7);\n        tree.root.left.left.left = new Node(8);\n        tree.root.left.left.right = new Node(9);\n        tree.root.left.right.left = new Node(10);\n        tree.root.left.right.right = new Node(11);\n        tree.root.right.left.left = new Node(12);\n        tree.root.right.left.right = new Node(13);\n        tree.root.right.right.left = new Node(14);\n        tree.root.right.right.right = new Node(15);\n        tree.root.left.left.left.left = new Node(16);\n        tree.root.left.left.left.right = new Node(17);\n        tree.root.left.left.right.left = new Node(18);\n        tree.root.left.left.right.right = new Node(19);\n        tree.root.left.right.left.left = new Node(20);\n        tree.root.left.right.left.right = new Node(21);\n        tree.root.left.right.right.left = new Node(22);\n        tree.root.left.right.right.right = new Node(23);\n        tree.root.right.left.left.left = new Node(24);\n        tree.root.right.left.left.right = new Node(25);\n        tree.root.right.left.right.left = new Node(26);\n        tree.root.right.left.right.right = new Node(27);\n        tree.root.right.right.left.left = new Node(28);\n        tree.root.right.right.left.right = new Node(29);\n        tree.root.right.right.right.left = new Node(30);\n        tree.root.right.right.right.right = new Node(31);\n\n        System.out.println(\"Specific Level Order traversal of binary tree is \");\n        tree.printSpecificLevelOrder(tree.root);\n    }\n}", "src": "\n// Java program for special level order traversal \n\nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \n\n/* Class containing left and right child of current \n\nnode and key value*/\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* Given a perfect binary tree, print its nodes in specific \n\nlevel order */\n\nvoid\nprintSpecificLevelOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n// Let us print root and next level first \n\nSystem.out.print(node.data); \n\n\n// Since it is perfect Binary Tree, right is not checked \n\nif\n(node.left != \nnull\n) \n\nSystem.out.print(\n\" \"\n+ node.left.data + \n\" \"\n+ node.right.data); \n\n\n// Do anything more if there are nodes at next level in \n\n// given perfect Binary Tree \n\nif\n(node.left.left == \nnull\n) \n\nreturn\n; \n\n\n// Create a queue and enqueue left and right children of root \n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\nq.add(node.left); \n\nq.add(node.right); \n\n\n// We process two nodes at a time, so we need two variables \n\n// to store two front items of queue \n\nNode first = \nnull\n, second = \nnull\n; \n\n\n// traversal loop \n\nwhile\n(!q.isEmpty()) \n\n{ \n\n// Pop two items from queue \n\nfirst = q.peek(); \n\nq.remove(); \n\nsecond = q.peek(); \n\nq.remove(); \n\n\n// Print children of first and second in reverse order \n\nSystem.out.print(\n\" \"\n+ first.left.data + \n\" \"\n+second.right.data); \n\nSystem.out.print(\n\" \"\n+ first.right.data + \n\" \"\n+second.left.data); \n\n\n// If first and second have grandchildren, enqueue them \n\n// in reverse order \n\nif\n(first.left.left != \nnull\n) \n\n{ \n\nq.add(first.left); \n\nq.add(second.right); \n\nq.add(first.right); \n\nq.add(second.left); \n\n} \n\n} \n\n} \n\n\n// Driver program to test for above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\ntree.root.left.left.left = \nnew\nNode(\n8\n); \n\ntree.root.left.left.right = \nnew\nNode(\n9\n); \n\ntree.root.left.right.left = \nnew\nNode(\n10\n); \n\ntree.root.left.right.right = \nnew\nNode(\n11\n); \n\ntree.root.right.left.left = \nnew\nNode(\n12\n); \n\ntree.root.right.left.right = \nnew\nNode(\n13\n); \n\ntree.root.right.right.left = \nnew\nNode(\n14\n); \n\ntree.root.right.right.right = \nnew\nNode(\n15\n); \n\n\ntree.root.left.left.left.left = \nnew\nNode(\n16\n); \n\ntree.root.left.left.left.right = \nnew\nNode(\n17\n); \n\ntree.root.left.left.right.left = \nnew\nNode(\n18\n); \n\ntree.root.left.left.right.right = \nnew\nNode(\n19\n); \n\ntree.root.left.right.left.left = \nnew\nNode(\n20\n); \n\ntree.root.left.right.left.right = \nnew\nNode(\n21\n); \n\ntree.root.left.right.right.left = \nnew\nNode(\n22\n); \n\ntree.root.left.right.right.right = \nnew\nNode(\n23\n); \n\ntree.root.right.left.left.left = \nnew\nNode(\n24\n); \n\ntree.root.right.left.left.right = \nnew\nNode(\n25\n); \n\ntree.root.right.left.right.left = \nnew\nNode(\n26\n); \n\ntree.root.right.left.right.right = \nnew\nNode(\n27\n); \n\ntree.root.right.right.left.left = \nnew\nNode(\n28\n); \n\ntree.root.right.right.left.right = \nnew\nNode(\n29\n); \n\ntree.root.right.right.right.left = \nnew\nNode(\n30\n); \n\ntree.root.right.right.right.right = \nnew\nNode(\n31\n); \n\n\nSystem.out.println(\n\"Specific Level Order traversal of binary\"\n\n+\n\"tree is \"\n); \n\ntree.printSpecificLevelOrder(tree.root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 119, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.FileInputStream;\nimport java.io.DataInputStream;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static Graph[] graph;\n\n    public static void add_edge(int u, int v) {\n        graph[u].adj.add(graph[v]);\n        graph[v].adj.add(graph[u]);\n    }\n\n    public static void dfs(int index) {\n        Graph z = graph[index];\n        z.vis = 1;\n        Graph v;\n        for (int i = 0; i < z.adj.size(); i++) {\n            v = z.adj.get(i);\n            if (v.vis == 0) {\n                v.dist = z.dist + 1;\n                v.parent = z.val;\n                dfs(v.val);\n            }\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int n = sc.nextInt();\n        Pair[] arr = new Pair[n];\n        Pair[] pref = new Pair[n];\n        Pair[] suff = new Pair[n];\n        for (int i = 0; i < n; i++) {\n            long u = sc.nextLong();\n            long v = sc.nextLong();\n            arr[i] = new Pair(u, v);\n            pref[i] = new Pair(0, 0);\n            suff[i] = new Pair(0, 0);\n        }\n        pref[0].x = arr[0].x;\n        pref[0].y = arr[0].y;\n        for (int i = 1; i < n; i++) {\n            pref[i].x = (long) Math.max(pref[i - 1].x, arr[i].x);\n            pref[i].y = (long) Math.min(pref[i - 1].y, arr[i].y);\n        }\n        suff[n - 1].x = arr[n - 1].x;\n        suff[n - 1].y = arr[n - 1].y;\n        for (int i = n - 2; i >= 0; i--) {\n            suff[i].x = (long) Math.max(suff[i + 1].x, arr[i].x);\n            suff[i].y = (long) Math.min(suff[i + 1].y, arr[i].y);\n        }\n        long max = Long.MIN_VALUE;\n        long ans = 0;\n\n        for (int i = 0; i < n; i++) {\n            long val = Long.MAX_VALUE;\n            long val1 = Long.MAX_VALUE;\n\n            if (i != 0 && i != n - 1) {\n                val = (long) Math.min(pref[i - 1].y, suff[i + 1].y) - (long) Math.max(pref[i - 1].x, suff[i + 1].x);\n            } else if (i != n - 1) {\n                val = suff[i + 1].y - suff[i + 1].x;\n            } else\n                val = pref[i - 1].y - pref[i - 1].x;\n\n            ans = val;\n            if (ans < 0)\n                ans = 0;\n            max = (long) Math.max(ans, max);\n        }\n        System.out.println(max);\n    }\n}\n\nclass mycomparator implements Comparator<Graph> {\n\n    public int compare(Graph a, Graph b) {\n        return b.dist - a.dist;\n    }\n}\n\nclass Graph {\n    int vis, col, val;\n    int parent;\n    int deg;\n    int dist;\n    ArrayList<Graph> adj;\n\n    Graph(int val) {\n        vis = 0;\n        col = -1;\n        adj = new ArrayList<>();\n        parent = -1;\n        this.val = val;\n        deg = 0;\n        dist = -1;\n    }\n}\n\nclass Pair {\n    long x, y;\n\n    Pair(long x, long y) {\n        this.x = x;\n        this.y = y;\n    }\n}", "src": "import java.io.DataInputStream; \nimport java.io.FileInputStream; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.Scanner; \nimport java.util.StringTokenizer;\nimport java.io.BufferedReader; \n\n import java.util.*;\npublic class Main \n{ \nstatic Graph graph[];\n\tpublic static void add_edge(int u,int v)\n\t{\n\t\tgraph[u].adj.add(graph[v]);\n\t\tgraph[v].adj.add(graph[u]);\n\t}\n\tpublic static void dfs(int index)\n\t{\n\t\tGraph z=graph[index];\n\t\tz.vis=1;Graph v;\n\t\tfor( int i=0;i<z.adj.size();i++)\n\t\t{\n\t\t\tv=z.adj.get(i);\n\t\t\tif(v.vis==0)\n\t\t\t{\n\t\t\t\tv.dist=z.dist+1;\n\t\t\t\tv.parent=z.val;\n\t\t\t\tdfs(v.val);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t}\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n  \n    public static void main(String[] args) \n    { \n        FastReader sc=new FastReader();\n\t\tint n=sc.nextInt();\n\t\tPair arr[]=new Pair[n];\n\t\tPair pref[]=new Pair[n];\n\t\tPair suff[]=new Pair[n];\n\t\tfor( int i=0;i<n;i++)\n\t\t{\n\t\t\tlong u=sc.nextLong();\n\t\t\tlong v=sc.nextLong();\n\t\t\tarr[i]=new Pair(u,v);\n\t\t\tpref[i]=new Pair(0,0);\n\t\t\tsuff[i]=new Pair(0,0);\n\t\t}\n\t\tpref[0].x=arr[0].x;\n\t\tpref[0].y=arr[0].y;\n\t\tfor( int i=1;i<n;i++)\n\t\t{\n\t\t\tpref[i].x=(long)Math.max(pref[i-1].x,arr[i].x);\n\t\t\tpref[i].y=(long)Math.min(pref[i-1].y,arr[i].y);\n\t\t}\n\t\tsuff[n-1].x=arr[n-1].x;\n\t\tsuff[n-1].y=arr[n-1].y;\n\t\tfor( int i=n-2;i>=0;i--)\n\t\t{\n\t\t\tsuff[i].x=(long)Math.max(suff[i+1].x,arr[i].x);\n\t\t\tsuff[i].y=(long)Math.min(suff[i+1].y,arr[i].y);\n\t\t}\n\t\tlong max=Long.MIN_VALUE;\n\t\tlong ans=0;\n\t\t\n\t\tfor( int i=0;i<n;i++)\n\t\t{\n\t\t\tlong val=Long.MAX_VALUE;\n\t\t\tlong val1=Long.MAX_VALUE;\n\t\t\t\n\t\t\tif(i!=0&&i!=n-1)\n\t\t\t{\n\t\t\t\t val=(long)Math.min(pref[i-1].y,suff[i+1].y)-(long)Math.max(pref[i-1].x,suff[i+1].x);\n\t\t\t\t \n\t\t\t}\n\t\t\telse if(i!=n-1)\n\t\t\t{\n\t\t\t\tval=suff[i+1].y-suff[i+1].x;\n\t\t\t}\n\t\t\telse\n\t\t\t\tval=pref[i-1].y-pref[i-1].x;\n\t\t\t\n\t\t\tans=val;\n\t\t\tif(ans<0)\n\t\t\t\tans=0;\n\t\t\tmax=(long)Math.max(ans,max);\n\t\t}\n\t\tSystem.out.println(max);\n     \n       \n\t\t\n\t\t\n\t\t\n    } \n}\nclass mycomparator implements Comparator<Graph>\n{\n\tpublic int compare(Graph a, Graph b)\n\t{\n\t\treturn b.dist-a.dist;\n\t}\n}\nclass Graph\n{\n\tint vis,col,val;int parent;int deg;int dist;\n\tArrayList<Graph> adj;\n\tGraph(int val)\n\t{\n\t\tvis=0;\n\t\tcol=-1;\n\t\tadj=new ArrayList<>();\n\t\tparent=-1;\n\t\tthis.val=val;\n\t\tdeg=0;\n\t\tdist=-1;\n\t}\n}\nclass Pair\n{\n\tlong x,y;\n\tPair( long x, long y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}", "index": 120, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class B {\n    static ArrayList<Integer>[] adj;\n    static int[] num;\n\n    static int dfs(int u, int p) {\n        int cnt = 0;\n        for (int v : adj[u]) {\n            if (v != p)\n                cnt += dfs(v, u);\n        }\n        if ((adj[u].size() == 1 && u != 0) || (u == 0 && adj[0].size() == 0))\n            cnt++;\n\n        num[cnt]++;\n        return cnt;\n    }\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        Scanner sc = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n\n        adj = new ArrayList[n];\n        for (int i = 0; i < adj.length; ++i) {\n            adj[i] = new ArrayList<>();\n        }\n\n        for (int i = 1; i < n; ++i) {\n            int p = sc.nextInt() - 1;\n            adj[p].add(i);\n            adj[i].add(p);\n        }\n\n        num = new int[n + 1];\n\n        dfs(0, -1);\n\n        for (int i = 1; i < num.length; ++i) {\n            num[i] += num[i - 1];\n        }\n\n        int cur = 1;\n\n        for (int i = 0; i < num.length; ++i) {\n            while (cur <= num[i]) {\n                out.print(i + \" \");\n\n                ++cur;\n            }\n        }\n\n        out.close();\n    }\n\n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n\n            return st.nextToken();\n        }\n\n        public int nextInt() throws NumberFormatException, IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class B {\n\tstatic ArrayList<Integer> [] adj;\n\tstatic int [] num;\n\tstatic int dfs(int u, int p){\n\t\tint cnt = 0;\n\t\tfor(int v:adj[u]){\n\t\t\tif(v != p)\n\t\t\t\tcnt += dfs(v, u);\n\t\t}\n\t\tif(adj[u].size() == 1 && u != 0 || u == 0 && adj[0].size() == 0)\n\t\t\tcnt++;\n\t\tnum[cnt]++;\n\t\treturn cnt;\n\t}\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tadj = new ArrayList[n];\n\t\tfor (int i = 0; i < adj.length; ++i) {\n\t\t\tadj[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tint p = sc.nextInt()-1;\n\t\t\tadj[p].add(i);\n\t\t\tadj[i].add(p);\n\t\t}\n\t\tnum = new int[n+1];\n\t\tdfs(0, -1);\n\t\tfor (int i = 1; i < num.length; ++i) {\n\t\t\tnum[i] += num[i-1];\n\t\t}\n\t\tint cur = 1;\n\t\tfor (int i = 0; i < num.length; ++i) {\n\t\t\twhile(cur <= num[i]){\n\t\t\t\tout.print(i + \" \");\n\t\t\t\t++cur;\n\t\t\t}\t\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n}\n", "index": 121, "complexity": 3}
{"back-translation": "class GFG {\n    final int MAX = 1000000;\n\n    static int breakSum(int n) {\n        int[] dp = new int[n + 1];\n\n        dp[0] = 0;\n        dp[1] = 1;\n\n        for (int i = 2; i <= n; i++)\n            dp[i] = Math.max(dp[i / 2] + dp[i / 3] + dp[i / 4], i);\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        int n = 24;\n        System.out.println(breakSum(n));\n    }\n}", "src": "\n// A simple recursive JAVA program to find \n// maximum sum by recursively breaking a \n// number in 3 parts. \nimport\njava.io.*; \n\nclass\nGFG { \n\n\nfinal\nint\nMAX = \n1000000\n; \n\n\n// Function to find the maximum sum \n\nstatic\nint\nbreakSum(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n+\n1\n]; \n\n\n// base conditions \n\ndp[\n0\n] = \n0\n; dp[\n1\n] = \n1\n; \n\n\n// Fill in bottom-up manner using recursive \n\n// formula. \n\nfor\n(\nint\ni=\n2\n; i<=n; i++) \n\ndp[i] = Math.max(dp[i/\n2\n] + dp[i/\n3\n] + dp[i/\n4\n], i); \n\n\nreturn\ndp[n]; \n\n} \n\n\n// Driver program to test the above function \n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\nn = \n24\n; \n\nSystem.out.println(breakSum(n)); \n\n} \n} \n// This code is contributed by Amit Kumar ", "index": 122, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class Solution{\n    \n    public static long page(long p,long k){\n        \n        return (p-1)/k;\n        \n    }\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        \n        long n = sc.nextLong();\n        int m = sc.nextInt();\n        long k = sc.nextLong();\n        long[] p = new long[m];\n        long del = 0;\n        long nb = 1;\n        int op = 0;\n        for(int i=0;i<m;i++) p[i] = sc.nextLong();\n        for(int i=1;i<m;i++){\n            if(page(p[i]-del,k)!=page(p[i-1]-del,k)){\n                \n                del += nb;\n                nb = 1;\n                op++;\n                \n            }else{\n                nb++;\n                \n            }\n        }\n        if(nb!=0) op++;\n        \n        System.out.println(op);\n        \n    }\n    \n}", "src": "import java.util.*;\nimport java.io.*;\npublic class Solution{\n    \n    public static long page(long p,long k){\n        \n        return (p-1)/k;\n        \n    }\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        \n        long n = sc.nextLong();\n        int m = sc.nextInt();\n        long k = sc.nextLong();\n        long[] p = new long[m];\n        long del = 0;\n        long nb = 1;\n        int op = 0;\n        for(int i=0;i<m;i++) p[i] = sc.nextLong();\n        for(int i=1;i<m;i++){\n            if(page(p[i]-del,k)!=page(p[i-1]-del,k)){\n                \n                del += nb;\n                nb = 1;\n                op++;\n                \n            }else{\n                nb++;\n                \n            }\n        }\n        if(nb!=0) op++;\n        \n        System.out.println(op);\n        \n    }\n    \n}", "index": 124, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TransformedClass {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter writer = new PrintWriter(System.out);\n\n        int n = Integer.parseInt(reader.readLine());\n\n        int[] a = new int[n];\n        int[] b = new int[n];\n\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(tokenizer.nextToken());\n        }\n\n        tokenizer = new StringTokenizer(reader.readLine());\n\n        for (int i = 0; i < n; i++) {\n            b[i] = Integer.parseInt(tokenizer.nextToken());\n        }\n\n        solve(n, a, b, writer);\n        writer.flush();\n        writer.close();\n    }\n\n    private static void solve(int n, int[] a, int[] b, PrintWriter writer) {\n        boolean[] book = new boolean[n + 1];\n        boolean f;\n        int j1 = 0, j2 = 0;\n        for (int i = 0; i < n; i++) {\n            f = false;\n            int num = b[i];\n            if (!book[num]) {\n                f = true;\n                j1 = j2;\n                for (; j2 < n; j2++) {\n                    book[a[j2]] = true;\n                    if (a[j2] == num) {\n                        j2++;\n                        break;\n                    }\n                }\n            }\n            writer.print(f ? j2 - j1 + \" \" : 0 + \" \");\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class pr1073B {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = Integer.parseInt(br.readLine());\n\n        int[] a = new int[n];\n        int[] b = new int[n];\n\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            b[i] = Integer.parseInt(st.nextToken());\n        }\n\n        solve(n, a, b, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, int[] a, int[] b, PrintWriter out) {\n        boolean[] book = new boolean[n+1];\n        boolean f;\n        int j1 = 0, j2 = 0;\n        for (int i = 0; i < n; i++) {\n            f = false;\n            int num = b[i];\n            if(!book[num]) {\n                f = true;\n                j1 = j2;\n                for (;j2 < n; j2++) {\n                    book[a[j2]] = true;\n                    if (a[j2] == num) {\n                        j2++;\n                        break;\n                    }\n                }\n            }\n            out.print(f ? j2-j1 + \" \": 0 + \" \");\n        }\n    }\n}\n", "index": 125, "complexity": 3}
{"back-translation": "import java.util.*;\npublic class Solution{\npublic static void main(String[]arg) {\n Scanner sc=new Scanner(System.in);\n int x=sc.nextInt();\n String s=sc.next();\n boolean f=true;\n boolean f2=true;\n boolean f3=true;\n boolean f4=true;\n int v=0;\n for(int i=0;i<s.length()-1;i++) {\n if(s.charAt(i)==s.charAt(i+1)&&(s.charAt(i)!='?'||s.charAt(i+1)!='?')) {\n f=false;\n break;\n }else {\n f=true;\n }\n }\n for(int i=0;i<s.length();i++) {\n if(s.charAt(i)=='?') {\n if(i==0||i==s.length()-1) {\n f2=true; \n v++;\n }else if(s.charAt(i)==s.charAt(i+1)) {\n f2=true;\n v++;\n }\n else if(s.charAt(i-1)==s.charAt(i+1)&&i!=0&&i!=s.length()-1) {\n f2=true;\n v++;\n }\n }else {\n if(v>0) f2=true;\n else f2=false;\n }\n }\n if(f&&f2) {\n System.out.println(\"YES\");\n}else {\n System.out.println(\"NO\");\n}\n }\n}", "src": "import java.util.*;\npublic class java{\n          public static void main(String[]arg) {\n        \t Scanner sc=new Scanner(System.in); \n        \t int x=sc.nextInt();\n        \t String s=sc.next();\n        \t boolean f=true;\n        \t boolean f2=true;\n        \t boolean f3=true;\n        \t boolean f4=true;\n        \t int v=0;\n        \t for(int i=0;i<s.length()-1;i++) {\n        \t\t if(s.charAt(i)==s.charAt(i+1)&&(s.charAt(i)!='?'||s.charAt(i+1)!='?')) {\n        \t\t\t f=false;\n        \t\t\t break;\n        \t\t }else {\n        \t\t\t f=true;\n        \t\t }\n        \t }\n        \t\n        \t \n        \t for(int i=0;i<s.length();i++) {\n        \t\t if(s.charAt(i)=='?') {\n        \t\t\t \n        \t\t\t if(i==0||i==s.length()-1) {\n        \t\t\t\t f2=true; \n        \t\t\t\t v++;\n        \t\t\t }else if(s.charAt(i)==s.charAt(i+1)) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t          }\n        \t\t\t else if(s.charAt(i-1)==s.charAt(i+1)&&i!=0&&i!=s.length()-1) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t         }\n        \t\t\t }else {\n        \t\t\t\t if(v>0) f2=true;\n        \t\t\t\t else f2=false;\n        \t\t\t }\n        \t\t }\n        \t \n        \tif(f&&f2) {\n        \t\tSystem.out.println(\"YES\");\n        \t}else {\n        \t\tSystem.out.println(\"NO\");\n        \t}\n          }\n          \n}\n", "index": 126, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Codeforces {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = Integer.parseInt(br.readLine());\n        String[] elements = br.readLine().split(\" \");\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = Integer.parseInt(elements[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            if (arr[i] % 2 == 0) {\n                arr[i] -= 1;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            pw.print(arr[i] + \" \");\n        }\n        pw.flush();\n        pw.close();\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\nimport java.util.Map.Entry;\n\npublic class Codeforces {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = new int[n];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for(int i = 0; i < n; i++){\n            arr[i] = Integer.parseInt(st.nextToken());\n        }\n        for(int i = 0; i < n; i++){\n            if(arr[i] % 2 == 0){\n                arr[i]--;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            pw.print(arr[i] + \" \");\n        }\n        pw.flush();\n        pw.close();\n    }\n}", "index": 127, "complexity": 3}
{"back-translation": "class Node {\n    int data;\n    Node left, right;\n\n    Node(int item) {\n        data = item;\n        left = right = null;\n    }\n}\n\nclass BinaryTree {\n    Node root;\n\n    int toSumTree(Node node) {\n        if (node == null) return 0;\n\n        int old_val = node.data;\n\n        node.data = toSumTree(node.left) + toSumTree(node.right);\n\n        return node.data + old_val;\n    }\n\n    void printInorder(Node node) {\n        if (node == null) return;\n\n        printInorder(node.left);\n        System.out.print(node.data + \" \");\n        printInorder(node.right);\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n\n        tree.root = new Node(10);\n        tree.root.left = new Node(-2);\n        tree.root.right = new Node(6);\n        tree.root.left.left = new Node(8);\n        tree.root.left.right = new Node(-4);\n        tree.root.right.left = new Node(7);\n        tree.root.right.right = new Node(5);\n\n        tree.toSumTree(tree.root);\n\n        System.out.println(\"Inorder Traversal of the resultant tree is:\");\n        tree.printInorder(tree.root);\n    }\n}", "src": "\n// Java program to convert a tree into its sum tree \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n// Convert a given tree to a tree where every node contains sum of \n\n// values of nodes in left and right subtrees in the original tree \n\nint\ntoSumTree(Node node) \n\n{ \n\n// Base case \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\n// Store the old value \n\nint\nold_val = node.data; \n\n\n// Recursively call for left and right subtrees and store the sum \n\n// as new value of this node \n\nnode.data = toSumTree(node.left) + toSumTree(node.right); \n\n\n// Return the sum of values of nodes in left and right subtrees \n\n// and old_value of this node \n\nreturn\nnode.data + old_val; \n\n} \n\n\n// A utility function to print inorder traversal of a Binary Tree \n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n/* Driver function to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n/* Constructing tree given in the above figure */\n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(-\n2\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.left = \nnew\nNode(\n8\n); \n\ntree.root.left.right = \nnew\nNode(-\n4\n); \n\ntree.root.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right = \nnew\nNode(\n5\n); \n\n\ntree.toSumTree(tree.root); \n\n\n// Print inorder traversal of the converted tree to test result \n\n// of toSumTree() \n\nSystem.out.println(\n\"Inorder Traversal of the resultant tree is:\"\n); \n\ntree.printInorder(tree.root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 128, "complexity": 3}
{"back-translation": "class Test {\n\nstatic int arr[] = {10, 324, 45, 90, 9808};\n\nstatic int largest() {\n\nint i;\n\nint max = arr[0];\n\nfor(i = 1; i < arr.length; i++)\n\nif(arr[i] > max)\n\nmax = arr[i];\n\nreturn max;\n\n}\n\npublic static void main(String[] args) {\n\nSystem.out.println(\"Largest in given array is \" + largest());\n\n}\n\n}", "src": "\n// Java Program to find maximum in arr[] \nclass\nTest \n{ \n\nstatic\nint\narr[] = {\n10\n, \n324\n, \n45\n, \n90\n, \n9808\n}; \n\n\n// Method to find maximum in arr[] \n\nstatic\nint\nlargest() \n\n{ \n\nint\ni; \n\n\n// Initialize maximum element \n\nint\nmax = arr[\n0\n]; \n\n\n// Traverse array elements from second and \n\n// compare every element with current max \n\nfor\n(i = \n1\n; i < arr.length; i++) \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\n\nreturn\nmax; \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Largest in given array is \"\n+ largest()); \n\n} \n\n} ", "index": 129, "complexity": 3}
{"back-translation": "class RearrangeArray { void rearrangeUtil(int arr[], int n, int i) { int val = -(i + 1); i = arr[i] - 1; while (arr[i] > 0) { int new_i = arr[i] - 1; arr[i] = val; val = -(i + 1); i = new_i; } } void rearrange(int arr[], int n) { int i; for (i = 0; i < n; i++) arr[i]++; for (i = 0; i < n; i++) { if (arr[i] > 0) rearrangeUtil(arr, n, i); } for (i = 0; i < n; i++) arr[i] = (-arr[i]) - 1; } void printArray(int arr[], int n) { int i; for (i = 0; i < n; i++) System.out.print(arr[i] + \" \"); System.out.println(\"\"); } public static void main(String[] args) { RearrangeArray arrange = new RearrangeArray(); int arr[] = { 2, 0, 1, 4, 5, 3 }; int n = arr.length; System.out.println(\"Given array is \"); arrange.printArray(arr, n); arrange.rearrange(arr, n); System.out.println(\"Modified array is \"); arrange.printArray(arr, n); } }", "src": "\n// A space efficient Java program to rearrange contents of \n// arr[] such that arr[j] becomes j if arr[i] is j \n\nclass\nRearrangeArray { \n\n// A utility function to rearrange elements in the cycle \n\n// starting at arr[i]. This function assumes values in \n\n// arr[] be from 1 to n. It changes arr[j-1] to i+1 \n\n// if arr[i-1] is j+1 \n\nvoid\nrearrangeUtil(\nint\narr[], \nint\nn, \nint\ni) \n\n{ \n\n// 'val' is the value to be stored at 'arr[i]' \n\n\n// The next value is determined using current index \n\nint\nval = -(i + \n1\n); \n\n\n// The next index is determined \n\n// using current value \n\ni = arr[i] - \n1\n; \n\n\n// While all elements in cycle are not processed \n\nwhile\n(arr[i] > \n0\n) { \n\n// Store value at index as it is going to be \n\n// used as next index \n\nint\nnew_i = arr[i] - \n1\n; \n\n\n// Update arr[] \n\narr[i] = val; \n\n\n// Update value and index for next iteration \n\nval = -(i + \n1\n); \n\ni = new_i; \n\n} \n\n} \n\n\n// A space efficient method to rearrange 'arr[0..n-1]' \n\n// so that 'arr[j]' becomes 'i' if 'arr[i]' is 'j' \n\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n// Increment all values by 1, so that all elements \n\n// can be made negative to mark them as visited \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i]++; \n\n\n// Process all cycles \n\nfor\n(i = \n0\n; i < n; i++) { \n\n// Process cycle starting at arr[i] if this cycle is \n\n// not already processed \n\nif\n(arr[i] > \n0\n) \n\nrearrangeUtil(arr, n, i); \n\n} \n\n\n// Change sign and values of arr[] to get the original \n\n// values back, i.e., values in range from 0 to n-1 \n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = (-arr[i]) - \n1\n; \n\n} \n\n\n// A utility function to print contents of arr[0..n-1] \n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n} ", "index": 130, "complexity": 3}
{"back-translation": "import java.util.HashSet; \n\nclass GFG { \nstatic int repeated_digit(int n) { \n\nHashSet<Integer> s = new HashSet<>(); \n\nwhile (n != 0) { \nint d = n % 10; \nif (s.contains(d)) { \nreturn 0; \n} \ns.add(d); \nn = n / 10; \n} \nreturn 1; \n} \n\nstatic int calculate(int L, int R) { \nint answer = 0; \nfor (int i = L; i < R + 1; ++i) { \nanswer = answer + repeated_digit(i); \n} \nreturn answer; \n} \n\npublic static void main(String[] args) { \nint L = 1, R = 100; \nSystem.out.println(calculate(L, R)); \n} \n}", "src": "\n// Java implementation of brute \n// force solution. \nimport\njava.util.LinkedHashSet; \n\nclass\nGFG \n{ \n// Function to check if the given \n// number has repeated digit or not \nstatic\nint\nrepeated_digit(\nint\nn) \n{ \n\nLinkedHashSet<Integer> s = \nnew\nLinkedHashSet<>(); \n\n\n// Traversing through each digit \n\nwhile\n(n != \n0\n) \n\n{ \n\nint\nd = n % \n10\n; \n\n\n// if the digit is present \n\n// more than once in the \n\n// number \n\nif\n(s.contains(d)) \n\n{ \n\n// return 0 if the number \n\n// has repeated digit \n\nreturn\n0\n; \n\n} \n\ns.add(d); \n\nn = n / \n10\n; \n\n} \n\n\n// return 1 if the number has \n\n// no repeated digit \n\nreturn\n1\n; \n} \n\n// Function to find total number \n// in the given range which has \n// no repeated digit \nstatic\nint\ncalculate(\nint\nL, \nint\nR) \n{ \n\nint\nanswer = \n0\n; \n\n\n// Traversing through the range \n\nfor\n(\nint\ni = L; i < R + \n1\n; ++i) \n\n{ \n\n\n// Add 1 to the answer if i has \n\n// no repeated digit else 0 \n\nanswer = answer + repeated_digit(i); \n\n} \n\n\nreturn\nanswer; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nL = \n1\n, R = \n100\n; \n\n\n// Calling the calculate \n\nSystem.out.println(calculate(L, R)); \n} \n} \n\n// This code is contributed by RAJPUT-JI ", "index": 132, "complexity": 3}
{"back-translation": "class GFG {\n    static int maxLoot(int[] hval, int n) {\n        if (n == 0) \n            return 0; \n        if (n == 1) \n            return hval[0]; \n        if (n == 2) \n            return Math.max(hval[0], hval[1]); \n        int[] dp = new int[n]; \n        dp[0] = hval[0]; \n        dp[1] = Math.max(hval[0], hval[1]); \n        for (int i = 2; i < n; i++) \n            dp[i] = Math.max(hval[i] + dp[i - 2], dp[i - 1]); \n        return dp[n - 1]; \n    }\n    public static void main(String[] args) {\n        int hval[] = {6, 7, 1, 3, 8, 2, 4}; \n        int n = hval.length; \n        System.out.println(\"Maximum loot value : \" + maxLoot(hval, n)); \n    }\n}", "src": "\n// Java program to find the maximum stolen value \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Function to calculate the maximum stolen value \n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\nif\n(n == \n1\n) \n\nreturn\nhval[\n0\n]; \n\nif\n(n == \n2\n) \n\nreturn\nMath.max(hval[\n0\n], hval[\n1\n]); \n\n\n// dp[i] represent the maximum value stolen \n\n// so far after reaching house i. \n\nint\n[] dp = \nnew\nint\n[n]; \n\n\n// Initialize the dp[0] and dp[1] \n\ndp[\n0\n] = hval[\n0\n]; \n\ndp[\n1\n] = Math.max(hval[\n0\n], hval[\n1\n]); \n\n\n// Fill remaining positions \n\nfor\n(\nint\ni = \n2\n; i<n; i++) \n\ndp[i] = Math.max(hval[i]+dp[i-\n2\n], dp[i-\n1\n]); \n\n\nreturn\ndp[n-\n1\n]; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "index": 134, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\nimport java.util.Collections;\nimport java.util.Arrays;\n\npublic class Codechef {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int res = 0;\n        for (int i = 1; i < n; i++) {\n            res = Math.max(res, Math.min(a / i, b / (n - i)));\n        }\n        System.out.println(res);\n    }\n\n}", "src": "\n import java.io.*;\n\nimport java.util.*;\nimport java.util.Collections;\nimport java.util.Arrays;\n\n\npublic class Codechef {\n     \n\n  public static void main(String[] args) throws IOException {\n\tScanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a=sc.nextInt();\n    int b=sc.nextInt();\n      int res=0;\n     for(int i=1;i<n;i++)\n     res=Math.max(res, Math.min(a/i, b/(n-i) ) );\n     System.out.println(res);\n  }\n\n   }\n  \n\n\n\n\n\n\n\n\n", "index": 135, "complexity": 3}
{"back-translation": "import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.*; public class Cf1003A { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); StringTokenizer stk = new StringTokenizer(br.readLine()); int[] arr = new int[100]; int max = 0; int tmp; for (int i = 0; i < n; i++) { tmp = Integer.parseInt(stk.nextToken()) - 1; if(max < ++arr[tmp]) { max = arr[tmp]; } else { max = max; } } System.out.println(max); } }", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Cf1003A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int[] arr = new int[100];\n        int max = 0;\n        int tmp;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken()) - 1;\n           max = max < ++arr[tmp] ? arr[tmp] : max;\n        }\n        System.out.println(max);\n    }\n}", "index": 136, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class CoinsTask {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint S = in.nextInt();\n\t\tint mCoins = 0;\n\t\twhile(S != 0){\n\t\t\tmCoins++;\n\t\t\tS -= n;\n\t\t}\n\t\tmCoins = S == 0 ? mCoins : mCoins + 1;\n\t\tSystem.out.print(mCoins);\n\t}\n\n}\n", "src": "import java.util.*;\n\npublic class CoinsTask {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint S = in.nextInt();\n\t\tint mCoins = 0;\n\t\twhile(S/n != 0) {\n\t\t\tmCoins+=1;\n\t\t\tS-=n;\n\t\t}\n\t\tmCoins = S == 0? mCoins : mCoins+1;\n\t\tSystem.out.print(mCoins);\n\t}\n\n}\n", "index": 137, "complexity": 3}
{"back-translation": "import java.util.Queue;\nimport java.util.LinkedList;\npublic class FlipTree {\n\n    public static Node flipBinaryTree(Node root) {\n        if (root == null)\n            return root;\n        if (root.left == null && root.right == null)\n            return root;\n        Node flippedRoot = flipBinaryTree(root.left);\n        root.left.left = root.right;\n        root.left.right = root;\n        root.left = root.right = null;\n        return flippedRoot;\n    }\n\n    public static void printLevelOrder(Node root) {\n        if (root == null)\n            return;\n        Queue<Node> q = new LinkedList<>();\n        q.add(root);\n        while (true) {\n            int nodeCount = q.size();\n            if (nodeCount == 0)\n                break;\n            while (nodeCount > 0) {\n                Node node = q.remove();\n                System.out.print(node.data + \" \");\n                if (node.left != null)\n                    q.add(node.left);\n                if (node.right != null)\n                    q.add(node.right);\n                nodeCount--;\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String args[]) {\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.right = new Node(1);\n        root.right.left = new Node(4);\n        root.right.right = new Node(5);\n        System.out.println(\"Level order traversal of given tree\");\n        printLevelOrder(root);\n        root = flipBinaryTree(root);\n        System.out.println(\"Level order traversal of flipped tree\");\n        printLevelOrder(root);\n    }\n}\nclass Node {\n\n    int data;\n    Node left, right;\n\n    Node(int data) {\n        this.data = data;\n    }\n};", "src": "\n/* Java program to flip a binary tree */\nimport\njava.util.Queue; \nimport\njava.util.LinkedList; \npublic\nclass\nFlipTree { \n\n\n// method to flip the binary tree \n\npublic\nstatic\nNode flipBinaryTree(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\nroot; \n\nif\n(root.left == \nnull\n&& root.right ==\nnull\n) \n\nreturn\nroot; \n\n\n// recursively call the same method \n\nNode flippedRoot=flipBinaryTree(root.left); \n\n\n// rearranging main root Node after returning \n\n// from recursive call \n\nroot.left.left=root.right; \n\nroot.left.right=root; \n\nroot.left=root.right=\nnull\n; \n\nreturn\nflippedRoot; \n\n} \n\n\n// Iterative method to do level order traversal \n\n// line by line \n\npublic\nstatic\nvoid\nprintLevelOrder(Node root) \n\n{ \n\n// Base Case \n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n// Create an empty queue for level order traversal \n\nQueue<Node> q=\nnew\nLinkedList<>(); \n\n// Enqueue Root and initialize height \n\nq.add(root); \n\nwhile\n(\ntrue\n) \n\n{ \n\n// nodeCount (queue size) indicates number \n\n// of nodes at current lelvel. \n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n// Dequeue all nodes of current level and \n\n// Enqueue all nodes of next level \n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.remove(); \n\nSystem.out.print(node.data+\n\" \"\n); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left=\nnew\nNode(\n2\n); \n\nroot.right=\nnew\nNode(\n1\n); \n\nroot.right.left = \nnew\nNode(\n4\n); \n\nroot.right.right = \nnew\nNode(\n5\n); \n\nSystem.out.println(\n\"Level order traversal of given tree\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\nSystem.out.println(\n\"Level order traversal of flipped tree\"\n); \n\nprintLevelOrder(root); \n\n} \n} \n\n/* A binary tree node structure */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\n} \n}; \n//This code is contributed by Gaurav Tiwari ", "index": 138, "complexity": 3}
{"back-translation": "import java.util.*;\npublic class Solution {\n\n    public static void main(String[] sp) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        String st = sc.next();\n\n        char[] arr = st.toCharArray();\n\n        boolean b = false;\n        for (char j = 'a'; j <= 'z'; j++) {\n            for (int i = 0; i < arr.length; i++) {\n                if (arr[i] == j) {\n                    arr[i] = '*';\n                    k--;\n                }\n                if (k == 0) {\n                    b = true;\n                    prin(arr);\n                    return;\n                }\n            }\n        }\n\n    }\n\n    public static void prin(char[] arr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] != '*')\n                sb.append(arr[i]);\n        }\n        if (sb.length() != 0)\n            System.out.println(sb.toString());\n    }\n}", "src": "import java.util.*;\npublic class Solution{\n\tpublic static void main(String sp[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString st = sc.next();\n\t\t\n\t\tchar arr[] = st.toCharArray();\n\t\t\n\t\tboolean b=false;\n\t\tfor(char j='a';j<='z';j++){\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]==j){\n\t\t\t\tarr[i]='*';\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tif(k==0){\n\t\t\t\tb=true;\n\t\t\t\tprin(arr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}}\n\n\t}\n\t\n\tpublic static void prin(char arr[]){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]!='*')\n\t\t\t\tsb.append(arr[i]);\n\t\t}\n\t\tif(sb.length()!=0)\n\t\t\tSystem.out.println(sb.toString());\n\t}\n}", "index": 139, "complexity": 3}
{"back-translation": "class BinaryTree { static Node root; void printSpiral(Node node) { if(node == null) return; Stack<Node> s1 = new Stack<Node>(); Stack<Node> s2 = new Stack<Node>(); s1.push(node); while(!s1.empty() || !s2.empty()) { while(!s1.empty()) { Node temp = s1.peek(); s1.pop(); System.out.print(temp.data + \" \"); if(temp.right != null) s2.push(temp.right); if(temp.left != null) s2.push(temp.left); } while(!s2.empty()) { Node temp = s2.peek(); s2.pop(); System.out.print(temp.data + \" \"); if(temp.left != null) s1.push(temp.left); if(temp.right != null) s1.push(temp.right); } } } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(7); tree.root.left.right = new Node(6); tree.root.right.left = new Node(5); tree.root.right.right = new Node(4); System.out.println(\"Spiral Order traversal of Binary Tree is \"); tree.printSpiral(root); } }", "src": "\n// Java implementation of an O(n) approach of level order \n// traversal in spiral form \n\nimport\njava.util.*; \n\n// A Binary Tree node \nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n// NULL check \n\n\n// Create two stacks to store alternate levels \n\n// For levels to be printed from right to left \n\nStack<Node> s1 = \nnew\nStack<Node>(); \n\n// For levels to be printed from left to right \n\nStack<Node> s2 = \nnew\nStack<Node>(); \n\n\n// Push first level to first stack 's1' \n\ns1.push(node); \n\n\n// Keep printing while any of the stacks has some nodes \n\nwhile\n(!s1.empty() || !s2.empty()) { \n\n// Print nodes of current level from s1 and push nodes of \n\n// next level to s2 \n\nwhile\n(!s1.empty()) { \n\nNode temp = s1.peek(); \n\ns1.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n// Note that is right is pushed before left \n\nif\n(temp.right != \nnull\n) \n\ns2.push(temp.right); \n\n\nif\n(temp.left != \nnull\n) \n\ns2.push(temp.left); \n\n} \n\n\n// Print nodes of current level from s2 and push nodes of \n\n// next level to s1 \n\nwhile\n(!s2.empty()) { \n\nNode temp = s2.peek(); \n\ns2.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n// Note that is left is pushed before right \n\nif\n(temp.left != \nnull\n) \n\ns1.push(temp.left); \n\nif\n(temp.right != \nnull\n) \n\ns1.push(temp.right); \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral Order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "index": 141, "complexity": 3}
{"back-translation": "import java.io.*;\n\nclass GFG {\n\n    static int PermutationCoeff(int n, int k) {\n\n        int Fn = 1, Fk = 1;\n\n        for (int i = 1; i <= n; i++) {\n\n            Fn *= i;\n\n            if (i == n - k)\n\n                Fk = Fn;\n\n        }\n\n        int coeff = Fn / Fk;\n\n        return coeff;\n\n    }\n\n    public static void main(String args[]) {\n\n        int n = 10, k = 2;\n\n        System.out.println(\"Value of P( \" + n + \",\" + k + \") is \" + PermutationCoeff(n, k));\n\n    }\n}", "src": "\n// A O(n) time and O(1) extra \n// space solution to calculate \n// the Permutation Coefficient \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nint\nPermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nFn = \n1\n, Fk = \n1\n; \n\n\n// Compute n! and (n-k)! \n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\nFn *= i; \n\nif\n(i == n - k) \n\nFk = Fn; \n\n} \n\nint\ncoeff = Fn / Fk; \n\nreturn\ncoeff; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ \n\nk +\n\") is \"\n+ \n\nPermutationCoeff(n, k) ); \n\n} \n} \n\n// This code is contributed by Nikita Tiwari. ", "index": 144, "complexity": 3}
{"back-translation": "import java.math.BigDecimal; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Scanner; class Node { int key; Node left; Node right; } class GFG { private static Node removeOutsideRange(Node root, int min, int max) { if (root == null) return null; root.left = removeOutsideRange(root.left, min, max); root.right = removeOutsideRange(root.right, min, max); if (root.key < min) { Node rchild = root.right; root = null; return rchild; } if (root.key > max) { Node lchild = root.left; root = null; return lchild; } return root; } public static Node newNode(int num) { Node temp = new Node(); temp.key = num; temp.left = null; temp.right = null; return temp; } public static Node insert(Node root, int key) { if (root == null) return newNode(key); if (root.key > key) root.left = insert(root.left, key); else root.right = insert(root.right, key); return root; } private static void inorderTraversal(Node root) { if (root != null) { inorderTraversal(root.left); System.out.print(root.key + \" \"); inorderTraversal(root.right); } } public static void main(String[] args) { Node root = null; root = insert(root, 6); root = insert(root, -13); root = insert(root, 14); root = insert(root, -8); root = insert(root, 15); root = insert(root, 13); root = insert(root, 7); System.out.print(\"Inorder Traversal of the given tree is: \"); inorderTraversal(root); root = removeOutsideRange(root, -10, 13); System.out.print(\"\\nInorder traversal of the modified tree: \"); inorderTraversal(root); } }", "src": "\n// A Java program to remove BST \n// keys outside the given range \nimport\njava.math.BigDecimal; \nimport\njava.util.ArrayList; \nimport\njava.util.Arrays; \nimport\njava.util.List; \nimport\njava.util.Scanner; \n\nclass\nNode \n{ \n\nint\nkey; \n\nNode left; \n\nNode right; \n} \n\nclass\nGFG \n{ \n\n// Removes all nodes having value \n\n// outside the given range and \n\n// returns the root of modified tree \n\nprivate\nstatic\nNode removeOutsideRange(Node root, \n\nint\nmin, \nint\nmax) \n\n{ \n\n// BASE CASE \n\nif\n(root == \nnull\n) \n\n{ \n\nreturn\nnull\n; \n\n} \n\n\n// FIRST FIX THE LEFT AND \n\n// RIGHT SUBTREE OF ROOT \n\nroot.left = removeOutsideRange(root.left, \n\nmin, max); \n\nroot.right = removeOutsideRange(root.right, \n\nmin, max); \n\n\n// NOW FIX THE ROOT. THERE ARE \n\n// TWO POSSIBLE CASES FOR THE ROOT \n\n// 1. a) Root's key is smaller than \n\n// min value(root is not in range) \n\nif\n(root.key < min) \n\n{ \n\nNode rchild = root.right; \n\nroot = \nnull\n; \n\nreturn\nrchild; \n\n} \n\n\n// 1. b) Root's key is greater than \n\n// max value (Root is not in range) \n\nif\n(root.key > max) \n\n{ \n\nNode lchild = root.left; \n\nroot = \nnull\n; \n\nreturn\nlchild; \n\n} \n\n\n// 2. Root in range \n\nreturn\nroot; \n\n} \n\n\npublic\nstatic\nNode newNode(\nint\nnum) \n\n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.key = num; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n\n} \n\n\npublic\nstatic\nNode insert(Node root, \n\nint\nkey) \n\n{ \n\nif\n(root == \nnull\n) \n\n{ \n\nreturn\nnewNode(key); \n\n} \n\nif\n(root.key > key) \n\n{ \n\nroot.left = insert(root.left, key); \n\n} \n\nelse\n\n{ \n\nroot.right = insert(root.right, key); \n\n} \n\nreturn\nroot; \n\n} \n\n\nprivate\nstatic\nvoid\ninorderTraversal(Node root) \n\n{ \n\nif\n(root != \nnull\n) \n\n{ \n\ninorderTraversal(root.left); \n\nSystem.out.print(root.key + \n\" \"\n); \n\ninorderTraversal(root.right); \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nNode root = \nnull\n; \n\nroot = insert(root, \n6\n); \n\nroot = insert(root, -\n13\n); \n\nroot = insert(root, \n14\n); \n\nroot = insert(root, -\n8\n); \n\nroot = insert(root, \n15\n); \n\nroot = insert(root, \n13\n); \n\nroot = insert(root, \n7\n); \n\n\nSystem.out.print(\n\"Inorder Traversal of \"\n+ \n\n\"the given tree is: \"\n); \n\ninorderTraversal(root); \n\n\nroot = removeOutsideRange(root, -\n10\n, \n13\n); \n\n\nSystem.out.print(\n\"\\nInorder traversal of \"\n+ \n\n\"the modified tree: \"\n); \n\ninorderTraversal(root); \n\n} \n} \n\n// This code is contributed \n// by Divya ", "index": 145, "complexity": 3}
{"back-translation": "class Main {\n\n    static int getMissingNo(int a[], int n) {\n        int i, total;\n        total = (n + 1) * (n + 2) / 2;\n        for (i = 0; i < n; i++)  total -= a[i];\n        return total;\n    }\n\n    public static void main(String args[]) {\n        int a[] = {1, 2, 4, 5, 6};\n        int miss = getMissingNo(a, 5);\n        System.out.println(miss);\n    }\n}", "src": "\n// Java program to find missing Number \n\nclass\nMain { \n\n// Function to ind missing number \n\nstatic\nint\ngetMissingNo(\nint\na[], \nint\nn) \n\n{ \n\nint\ni, total; \n\ntotal = (n + \n1\n) * (n + \n2\n) / \n2\n; \n\nfor\n(i = \n0\n; i < n; i++) \n\ntotal -= a[i]; \n\nreturn\ntotal; \n\n} \n\n\n/* program to test above function */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\na[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\nmiss = getMissingNo(a, \n5\n); \n\nSystem.out.println(miss); \n\n} \n} ", "index": 146, "complexity": 3}
{"back-translation": "class Node { int data; Node left, right; public Node(int data) { this.data = data; left = right = null; } } class BinaryTree { Node root; Node head; static Node prev = null; void BinaryTree2DoubleLinkedList(Node root) { if (root == null) return; BinaryTree2DoubleLinkedList(root.left); if (prev == null) head = root; else { root.left = prev; prev.right = root; } prev = root; BinaryTree2DoubleLinkedList(root.right); } void printList(Node node) { while (node != null) { System.out.print(node.data + \" \"); node = node.right; } } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(10); tree.root.left = new Node(12); tree.root.right = new Node(15); tree.root.left.left = new Node(25); tree.root.left.right = new Node(30); tree.root.right.left = new Node(36); tree.BinaryTree2DoubleLinkedList(tree.root); tree.printList(tree.head); } }", "src": "\n// A Java program for in-place conversion of Binary Tree to DLL \n\n// A binary tree node has data, left pointers and right pointers \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n// head --> Pointer to head node of created doubly linked list \n\nNode head; \n\n\n// Initialize previously visited node as NULL. This is \n\n// static so that the same value is accessible in all recursive \n\n// calls \n\nstatic\nNode prev = \nnull\n; \n\n\n// A simple recursive function to convert a given Binary tree \n\n// to Doubly Linked List \n\n// root --> Root of Binary Tree \n\nvoid\nBinaryTree2DoubleLinkedList(Node root) \n\n{ \n\n// Base case \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n// Recursively convert left subtree \n\nBinaryTree2DoubleLinkedList(root.left); \n\n\n// Now convert this node \n\nif\n(prev == \nnull\n) \n\nhead = root; \n\nelse\n\n{ \n\nroot.left = prev; \n\nprev.right = root; \n\n} \n\nprev = root; \n\n\n// Finally convert right subtree \n\nBinaryTree2DoubleLinkedList(root.right); \n\n} \n\n\n/* Function to print nodes in a given doubly linked list */\n\nvoid\nprintList(Node node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.right; \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Let us create the tree as shown in above diagram \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n12\n); \n\ntree.root.right = \nnew\nNode(\n15\n); \n\ntree.root.left.left = \nnew\nNode(\n25\n); \n\ntree.root.left.right = \nnew\nNode(\n30\n); \n\ntree.root.right.left = \nnew\nNode(\n36\n); \n\n\n// convert to DLL \n\ntree.BinaryTree2DoubleLinkedList(tree.root); \n\n\n// Print the converted List \n\ntree.printList(tree.head); \n\n\n} \n} \n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "index": 148, "complexity": 3}
{"back-translation": "// The transformed Java code\n\nclass Node {\n    int data;\n    Node left, right;\n\n    Node(int item) {\n        data = item;\n        left = right;\n    }\n}\n\nclass BinaryTree {\n    Node root;\n    ArrayList<Integer> list = new ArrayList<Integer>();\n\n    ArrayList<Integer> postOrderIterative(Node node) {\n        Stack<Node> S = new Stack<Node>();\n\n        if (node == null)\n            return list;\n\n        S.push(node);\n        Node prev = null;\n\n        while (!S.isEmpty()) {\n            Node current = S.peek();\n\n            if (prev == null || prev.left == current || prev.right == current) {\n                if (current.left != null)\n                    S.push(current.left);\n                else if (current.right != null)\n                    S.push(current.right);\n                else {\n                    S.pop();\n                    list.add(current.data);\n                }\n            } else if (current.left == prev) {\n                if (current.right != null)\n                    S.push(current.right);\n                else {\n                    S.pop();\n                    list.add(current.data);\n                }\n            } else if (current.right == prev) {\n                S.pop();\n                list.add(current.data);\n            }\n\n            prev = current;\n        }\n\n        return list;\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n\n        tree.root = new Node(1);\n        tree.root.left = new Node(2);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(4);\n        tree.root.left.right = new Node(5);\n        tree.root.right.left = new Node(6);\n        tree.root.right.right = new Node(7);\n\n        ArrayList<Integer> mylist = tree.postOrderIterative(tree.root);\n\n        System.out.println(\"Post order traversal of binary tree is : \");\n        System.out.println(mylist);\n    }\n}", "src": "\n// A java program for iterative postorder traversal using stack \n\nimport\njava.util.ArrayList; \nimport\njava.util.Stack; \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nArrayList<Integer> list = \nnew\nArrayList<Integer>(); \n\n\n// An iterative function to do postorder traversal \n\n// of a given binary tree \n\nArrayList<Integer> postOrderIterative(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack<Node>(); \n\n\n// Check for empty tree \n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\nS.push(node); \n\nNode prev = \nnull\n; \n\nwhile\n(!S.isEmpty()) \n\n{ \n\nNode current = S.peek(); \n\n\n/* go down the tree in search of a leaf an if so process it \n\nand pop stack otherwise move down */\n\nif\n(prev == \nnull\n|| prev.left == current || \n\nprev.right == current) \n\n{ \n\nif\n(current.left != \nnull\n) \n\nS.push(current.left); \n\nelse\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n/* go up the tree from left node, if the child is right \n\npush it onto stack otherwise process parent and pop \n\nstack */\n\n} \n\nelse\nif\n(current.left == prev) \n\n{ \n\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n/* go up the tree from right node and after coming back \n\nfrom right node process parent and pop stack */\n\n} \n\nelse\nif\n(current.right == prev) \n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\nprev = current; \n\n} \n\n\nreturn\nlist; \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n// Let us create trees shown in above diagram \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nArrayList<Integer> mylist = tree.postOrderIterative(tree.root); \n\n\nSystem.out.println(\n\"Post order traversal of binary tree is :\"\n); \n\nSystem.out.println(mylist); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 149, "complexity": 3}
{"back-translation": "import java.io.OutputStream;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EMilitaryProblem solver = new EMilitaryProblem();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EMilitaryProblem {\n        ArrayList<Integer>[] adj;\n        int[] sz;\n        int[] preorder;\n        int curPos;\n        int[] pos;\n\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            int q = br.nextInt();\n            preorder = new int[n];\n            sz = new int[n];\n            pos = new int[n];\n            curPos = 0;\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<Integer>();\n            }\n            for (int i = 1; i < n; i++) {\n                int u = br.nextInt();\n                u--;\n                adj[u].add(i);\n            }\n            dfs(0);\n            for (int i = 0; i < n; i++) {\n                pos[preorder[i]] = i;\n            }\n            for (int i = 0; i < q; i++) {\n                int u = br.nextInt();\n                int k = br.nextInt();\n                u--;\n                if (sz[u] < k) {\n                    pw.println(\"-1\");\n                } else {\n                    pw.println(preorder[pos[u] + k - 1] + 1);\n                }\n            }\n            pw.close();\n        }\n\n        public int dfs(int u) {\n            preorder[curPos] = u;\n            curPos++;\n            sz[u]++;\n            for (int e : adj[u]) {\n                sz[u] += dfs(e);\n            }\n            return sz[u];\n        }\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author caoash\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EMilitaryProblem solver = new EMilitaryProblem();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EMilitaryProblem {\n        ArrayList<Integer>[] adj;\n        int[] sz;\n        int[] preorder;\n        int curPos;\n        int[] pos;\n\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            int q = br.nextInt();\n            preorder = new int[n];\n            sz = new int[n];\n            pos = new int[n];\n            curPos = 0;\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) adj[i] = new ArrayList<Integer>();\n            for (int i = 1; i < n; i++) {\n                int u = br.nextInt();\n                u--;\n                adj[u].add(i);\n            }\n            dfs(0);\n            for (int i = 0; i < n; i++) {\n                pos[preorder[i]] = i;\n            }\n            for (int i = 0; i < q; i++) {\n                int u = br.nextInt();\n                int k = br.nextInt();\n                u--;\n                if (sz[u] < k) {\n                    pw.println(\"-1\");\n                } else {\n                    pw.println(preorder[pos[u] + k - 1] + 1);\n                }\n            }\n            pw.close();\n        }\n\n        public int dfs(int u) {\n            preorder[curPos] = u;\n            curPos++;\n            sz[u]++;\n            for (int e : adj[u]) {\n                sz[u] += dfs(e);\n            }\n            return sz[u];\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "index": 150, "complexity": 3}
{"back-translation": "ERROR", "src": "\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,ans=0;\n\t\tString sa,sb;\n\t\tchar[] a,b;\n\t\tn=sc.nextInt();\n\t\tsa=sc.next();\n\t\tsb=sc.next();\n\t\ta=sa.toCharArray();\n\t\tb=sb.toCharArray();\n\t\tans=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i==n/2)\n\t\t\t{\n\t\t\t\tif(a[i]!=b[i])\n\t\t\t\t\tans++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] vis=new int[28];\n\t\t\tvis[a[i]-'a']++;\n\t\t\tvis[b[i]-'a']++;\n\t\t\tvis[a[n-1-i]-'a']++;\n\t\t\tvis[b[n-1-i]-'a']++;\n\t\t\tint num=0,ans1=0,ans2=0;\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\tif(vis[j]!=0)\n\t\t\t\t{\n\t\t\t\t\tnum++;\n\t\t\t\t\tif(num==1)\n\t\t\t\t\t\tans1=vis[j];\n\t\t\t\t\telse\n\t\t\t\t\t\tans2=vis[j];\n\t\t\t\t}\n\t\t\tif(num==2)\n\t\t\t{\n\t\t\t\tif(ans1==1||ans2==1)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==3)\n\t\t\t{\n\t\t\t\tif(a[i]==a[n-i-1])\n\t\t\t\t\tans+=2;\n\t\t\t\telse\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==4)\n\t\t\t\tans+=2;\n\t\t\ta[i]=b[i];\n\t\t\ta[n-1-i]=b[n-1-i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 151, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class Solution\n{\n    public static void main(String [] args) throws IOException\n    {\n        PrintWriter pw=new PrintWriter(System.out);//use pw.println() not pw.write();\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(br.readLine());\n        \n        int n=Integer.parseInt(st.nextToken());\n        int k=Integer.parseInt(st.nextToken());\n        st=new StringTokenizer(br.readLine());\n        String str=st.nextToken();\n        char [] arr=str.toCharArray();\n        Arrays.sort(arr);\n        int weight=arr[0]-96;\n        char a=arr[0];\n        int included=1;\n        for(int i=1;i<arr.length;++i)\n        {\n            if(included==k)\n                break;\n            char c=arr[i];\n            if(c-a<2)\n                continue;\n           \n            weight+=arr[i]-96;\n            ++included;\n            a=arr[i];\n            \n        }\n        if(included==k)\n            pw.println(weight);\n        else\n            pw.println(-1);\n        pw.close();//Do not forget to write it after every program return statement !!\n    }\n}", "src": "import java.util.*;\n\nimport java.io.*;\npublic class Solution\n{\n    public static void main(String [] args) throws IOException\n    {\n        PrintWriter pw=new PrintWriter(System.out);//use pw.println() not pw.write();\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(br.readLine());\n        /*\n        inputCopy\n5 3\nxyabd\noutputCopy\n29\ninputCopy\n7 4\nproblem\noutputCopy\n34\ninputCopy\n2 2\nab\noutputCopy\n-1\ninputCopy\n12 1\nabaabbaaabbb\noutputCopy\n1\n        */\n        int n=Integer.parseInt(st.nextToken());\n        int k=Integer.parseInt(st.nextToken());\n        st=new StringTokenizer(br.readLine());\n        String str=st.nextToken();\n        char [] arr=str.toCharArray();\n        Arrays.sort(arr);\n        int weight=arr[0]-96;\n        char a=arr[0];\n        int included=1;\n        for(int i=1;i<arr.length;++i)\n        {\n            if(included==k)\n                break;\n            char c=arr[i];\n            if(c-a<2)\n                continue;\n           \n            weight+=arr[i]-96;\n            ++included;\n            a=arr[i];\n            \n        }\n        if(included==k)\n            pw.println(weight);\n        else\n            pw.println(-1);\n        pw.close();//Do not forget to write it after every program return statement !!\n    }\n}\n/*\n\u2192Judgement Protocol\nTest: #1, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n5 3\nxyabd\nOutput\n29\nAnswer\n29\nChecker Log\nok 1 number(s): \"29\"\nTest: #2, time: 78 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n7 4\nproblem\nOutput\n34\nAnswer\n34\nChecker Log\nok 1 number(s): \"34\"\nTest: #3, time: 139 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nab\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #4, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n12 1\nabaabbaaabbb\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #5, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 13\nqwertyuiopasdfghjklzxcvbnmaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n169\nAnswer\n169\nChecker Log\nok 1 number(s): \"169\"\nTest: #6, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 14\nqwertyuiopasdfghjklzxcvbnmaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #7, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\na\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #8, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 1\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #9, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 2\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #10, time: 92 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n13 13\nuwgmkyqeiaocs\nOutput\n169\nAnswer\n169\nChecker Log\nok 1 number(s): \"169\"\nTest: #11, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n13 13\nhzdxpbfvrltnj\nOutput\n182\nAnswer\n182\nChecker Log\nok 1 number(s): \"182\"\nTest: #12, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\nn\nOutput\n14\nAnswer\n14\nChecker Log\nok 1 number(s): \"14\"\nTest: #13, time: 92 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n10 8\nsmzeblyjqw\nOutput\n113\nAnswer\n113\nChecker Log\nok 1 number(s): \"113\"\nTest: #14, time: 78 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n20 20\ntzmvhskkyugkuuxpvtbh\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #15, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n30 15\nwjzolzzkfulwgioksfxmcxmnnjtoav\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #16, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n40 30\nxumfrflllrrgswehqtsskefixhcxjrxbjmrpsshv\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #17, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 31\nahbyyoxltryqdmvenemaqnbakglgqolxnaifnqtoclnnqiabpz\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #18, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n10 7\niuiukrxcml\nOutput\n99\nAnswer\n99\nChecker Log\nok 1 number(s): \"99\"\nTest: #19, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n38 2\nvjzarfykmrsrvwbwfwldsulhxtykmjbnwmdufa\nOutput\n5\nAnswer\n5\nChecker Log\nok 1 number(s): \"5\"\nTest: #20, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n12 6\nfwseyrarkwcd\nOutput\n61\nAnswer\n61\nChecker Log\nok 1 number(s): \"61\"\nTest: #21, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nac\nOutput\n4\nAnswer\n4\nChecker Log\nok 1 number(s): \"4\"\nTest: #22, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\nc\nOutput\n3\nAnswer\n3\nChecker Log\nok 1 number(s): \"3\"\nTest: #23, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nad\nOutput\n5\nAnswer\n5\nChecker Log\nok 1 number(s): \"5\"\nTest: #24, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n2 1\nac\nOutput\n-1\nAnswer\n1\nChecker Log\nwrong answer 1st number\n*/", "index": 152, "complexity": 3}
{"back-translation": "public class BinaryTreeToDLL { static class node { int data; node left, right; public node(int data) { this.data = data; } } static node prev; static void fixPrevptr(node root) { if (root == null) return; fixPrevptr(root.left); root.left = prev; prev = root; fixPrevptr(root.right); } static node fixNextptr(node root) { while (root.right != null) root = root.right; while (root != null && root.left != null) { node left = root.left; left.right = root; root = root.left; } return root; } static node BTTtoDLL(node root) { prev = null; fixPrevptr(root); return fixNextptr(root); } static void printlist(node root) { while (root != null) { System.out.print(root.data + ", "); root = root.right; } } static void inorder(node root) { if (root == null) return; inorder(root.left); System.out.print(root.data + ": "); inorder(root.right); } public static void main(String[] args) { node root = new node(10); root.left = new node(12); root.right = new node(15); root.left.left = new node(25); root.left.right = new node(30); root.right.left = new node(36); System.out.println(", "); inorder(root); node head = BTTtoDLL(root); System.out.println(": "); printlist(head); } }", "src": "\n// Java program to convert BTT to DLL using \n// simple inorder traversal \n\npublic\nclass\nBinaryTreeToDLL \n{ \n\nstatic\nclass\nnode \n\n{ \n\nint\ndata; \n\nnode left, right; \n\n\npublic\nnode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\n} \n\n} \n\n\nstatic\nnode prev; \n\n\n// Changes left pointers to work as previous \n\n// pointers in converted DLL The function \n\n// simply does inorder traversal of Binary \n\n// Tree and updates left pointer using \n\n// previously visited node \n\nstatic\nvoid\nfixPrevptr(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nfixPrevptr(root.left); \n\nroot.left = prev; \n\nprev = root; \n\nfixPrevptr(root.right); \n\n\n} \n\n\n// Changes right pointers to work \n\n// as next pointers in converted DLL \n\nstatic\nnode fixNextptr(node root) \n\n{ \n\n// Find the right most node in \n\n// BT or last node in DLL \n\nwhile\n(root.right != \nnull\n) \n\nroot = root.right; \n\n\n// Start from the rightmost node, traverse \n\n// back using left pointers. While traversing, \n\n// change right pointer of nodes \n\nwhile\n(root != \nnull\n&& root.left != \nnull\n) \n\n{ \n\nnode left = root.left; \n\nleft.right = root; \n\nroot = root.left; \n\n} \n\n\n// The leftmost node is head of linked list, return it \n\nreturn\nroot; \n\n} \n\n\nstatic\nnode BTTtoDLL(node root) \n\n{ \n\nprev = \nnull\n; \n\n\n// Set the previous pointer \n\nfixPrevptr(root); \n\n\n// Set the next pointer and return head of DLL \n\nreturn\nfixNextptr(root); \n\n} \n\n\n// Traverses the DLL from left tor right \n\nstatic\nvoid\nprintlist(node root) \n\n{ \n\nwhile\n(root != \nnull\n) \n\n{ \n\nSystem.out.print(root.data + \n\" \"\n); \n\nroot = root.right; \n\n} \n\n} \n\n\n// Standard Inorder traversal of tree \n\nstatic\nvoid\ninorder(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\ninorder(root.left); \n\nSystem.out.print(root.data + \n\" \"\n); \n\ninorder(root.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Let us create the tree shown in above diagram \n\nnode root = \nnew\nnode(\n10\n); \n\nroot.left = \nnew\nnode(\n12\n); \n\nroot.right = \nnew\nnode(\n15\n); \n\nroot.left.left = \nnew\nnode(\n25\n); \n\nroot.left.right = \nnew\nnode(\n30\n); \n\nroot.right.left = \nnew\nnode(\n36\n); \n\n\nSystem.out.println(\n\"Inorder Tree Traversal\"\n); \n\ninorder(root); \n\n\nnode head = BTTtoDLL(root); \n\n\nSystem.out.println(\n\"\\nDLL Traversal\"\n); \n\nprintlist(head); \n\n} \n} \n\n// This code is contributed by Rishabh Mahrsee ", "index": 153, "complexity": 3}
{"back-translation": "class GFG { static void findElements(int arr[], int n) { int first = arr[0]; int second = arr[1]; for (int i = 2; i < n; i++) { if (arr[i] > first) { second = first; first = arr[i]; } else if (arr[i] > second) second = arr[i]; } for (int i = 0; i < n; i++) if (arr[i] < second) System.out.print(arr[i] + \" \"); } public static void main(String args[]) { int arr[] = { 2, -6, 3, 5, 1 }; int n = arr.length; findElements(arr, n); } }", "src": "\n// Java program to find all elements \n// in array which have atleast \n// two greater elements itself. \nimport\njava.util.*; \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nint\nfirst = Integer.MIN_VALUE; \n\nint\nsecond = Integer.MAX_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n// If current element is smaller \n\n// than first then update both \n\n// first and second \n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n/* If arr[i] is in between \n\nfirst and second \n\nthen update second */\n\nelse\nif\n(arr[i] > second) \n\nsecond = arr[i]; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < second) \n\nSystem.out.print(arr[i] + \n\" \"\n) ; \n} \n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n} \n} \n\n// This code is contributed by Sahil_Bansall ", "index": 155, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class EhabAndAComponentChoosingProblem {\n    \n    long INF = (long) 1e18;\n    \n    int n;\n    int[] a;\n    \n    int[][] G;\n    \n    void solve() {\n        n = in.nextInt();\n        a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = in.nextInt();\n        int[] fr = new int[n - 1], to = new int[n - 1];\n        for (int i = 0; i < n - 1; i++) {\n            fr[i] = in.nextInt() - 1;\n            to[i] = in.nextInt() - 1;\n        }\n        G = build_graph(n, fr, to);\n        \n        int[][] ret = bfs(G, 0);\n        int[] par = ret[0], ord = ret[2];\n        \n        long best = -INF;\n        long[] dp = new long[n];\n        for (int i = n - 1; i >= 0; i--) {\n            int u = ord[i];\n            dp[u] = a[u];\n            for (int v : G[u]) {\n                if (v != par[u]) {\n                    if (dp[v] > 0) dp[u] += dp[v];\n                }\n            }\n            best = Math.max(best, dp[u]);\n        }\n        \n        int k = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            int u = ord[i];\n            dp[u] = a[u];\n            for (int v : G[u]) {\n                if (v != par[u]) {\n                    if (dp[v] > 0) dp[u] += dp[v];\n                }\n            }\n            if (dp[u] == best) {\n                dp[u] = -INF;\n                k++;\n            }\n        }\n        \n        out.printf(\"%d %d%n\", best * k, k);\n    }\n    \n    int[][] bfs(int[][] G, int root) {\n        int n = G.length;\n        \n        int[] par = new int[n];\n        Arrays.fill(par, -1);\n        \n        int[] dep = new int[n];\n        dep[root] = 0;\n        \n        int[] qu = new int[n];\n        qu[0] = root;\n        for (int l = 0, r = 1; l < r; l++) {\n            int u = qu[l];\n            for (int v : G[u]) {\n                if (v != par[u]) {\n                    qu[r++] = v;\n                    par[v] = u;\n                    dep[v] = dep[u] + 1;\n                }\n            }\n        }\n        \n        return new int[][]{par, dep, qu};\n    }\n    \n    int[][] build_graph(int n, int[] from, int[] to) {\n        int[][] G = new int[n][];\n        int[] cnt = new int[n];\n        for (int i = 0; i < from.length; i++) {\n            cnt[from[i]]++;\n            cnt[to[i]]++;\n        }\n        for (int i = 0; i < n; i++) G[i] = new int[cnt[i]];\n        for (int i = 0; i < from.length; i++) {\n            G[from[i]][--cnt[from[i]]] = to[i];\n            G[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return G;\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new EhabAndAComponentChoosingProblem().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class EhabAndAComponentChoosingProblem {\n    \n    long INF = (long) 1e18;\n    \n    int n;\n    int[] a;\n    \n    int[][] G;\n    \n    void solve() {\n        n = in.nextInt();\n        a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = in.nextInt();\n        int[] fr = new int[n - 1], to = new int[n - 1];\n        for (int i = 0; i < n - 1; i++) {\n            fr[i] = in.nextInt() - 1;\n            to[i] = in.nextInt() - 1;\n        }\n        G = build_graph(n, fr, to);\n        \n        int[][] ret = bfs(G, 0);\n        int[] par = ret[0], ord = ret[2];\n        \n        long best = -INF;\n        long[] dp = new long[n];\n        for (int i = n - 1; i >= 0; i--) {\n            int u = ord[i];\n            dp[u] = a[u];\n            for (int v : G[u]) {\n                if (v != par[u]) {\n                    if (dp[v] > 0) dp[u] += dp[v];\n                }\n            }\n            best = Math.max(best, dp[u]);\n        }\n        \n        int k = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            int u = ord[i];\n            dp[u] = a[u];\n            for (int v : G[u]) {\n                if (v != par[u]) {\n                    if (dp[v] > 0) dp[u] += dp[v];\n                }\n            }\n            if (dp[u] == best) {\n                dp[u] = -INF;\n                k++;\n            }\n        }\n        \n        out.printf(\"%d %d%n\", best * k, k);\n    }\n    \n    int[][] bfs(int[][] G, int root) {\n        int n = G.length;\n        \n        int[] par = new int[n];\n        Arrays.fill(par, -1);\n        \n        int[] dep = new int[n];\n        dep[root] = 0;\n        \n        int[] qu = new int[n];\n        qu[0] = root;\n        for (int l = 0, r = 1; l < r; l++) {\n            int u = qu[l];\n            for (int v : G[u]) {\n                if (v != par[u]) {\n                    qu[r++] = v;\n                    par[v] = u;\n                    dep[v] = dep[u] + 1;\n                }\n            }\n        }\n        \n        return new int[][]{par, dep, qu};\n    }\n    \n    int[][] build_graph(int n, int[] from, int[] to) {\n        int[][] G = new int[n][];\n        int[] cnt = new int[n];\n        for (int i = 0; i < from.length; i++) {\n            cnt[from[i]]++;\n            cnt[to[i]]++;\n        }\n        for (int i = 0; i < n; i++) G[i] = new int[cnt[i]];\n        for (int i = 0; i < from.length; i++) {\n            G[from[i]][--cnt[from[i]]] = to[i];\n            G[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return G;\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new EhabAndAComponentChoosingProblem().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "index": 156, "complexity": 3}
{"back-translation": "class GFG { static final int MAX_CHARS = 26; static void longestSubseqWithK(String str, int k) { int n = str.length(); int freq[] = new int[MAX_CHARS]; for (int i = 0; i < n; i++) { freq[str.charAt(i) - 'a']++; } for (int i = 0; i < n; i++) { if (freq[str.charAt(i) - 'a'] >= k) { System.out.print(str.charAt(i)); } } } public static void main(String[] args) { String str = \"geeksforgeeks\"; int k = 2; longestSubseqWithK(str, k); } }", "src": "\n// Java program to Find longest subsequence where \n// every character appears at-least k times \n\nclass\nGFG { \n\n\nstatic\nfinal\nint\nMAX_CHARS = \n26\n; \n\n\nstatic\nvoid\nlongestSubseqWithK(String str, \nint\nk) { \n\nint\nn = str.length(); \n\n\n// Count frequencies of all characters \n\nint\nfreq[] = \nnew\nint\n[MAX_CHARS]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nfreq[str.charAt(i) - \n'a'\n]++; \n\n} \n\n\n// Traverse given string again and print \n\n// all those characters whose frequency \n\n// is more than or equal to k. \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(freq[str.charAt(i) - \n'a'\n] >= k) { \n\nSystem.out.print(str.charAt(i)); \n\n} \n\n} \n\n} \n\n// Driver code \n\nstatic\npublic\nvoid\nmain(String[] args) { \n\nString str = \n\"geeksforgeeks\"\n; \n\nint\nk = \n2\n; \n\nlongestSubseqWithK(str, k); \n\n\n} \n} \n\n// This code is contributed by Rajput-Ji ", "index": 157, "complexity": 3}
{"back-translation": "class Node { int data; Node left, right; Node(int d) { data = d; left = right = null; } } class BinarySearchTree { Node root; BinarySearchTree() { root = null; } void inorder() { inorderUtil(this.root); } void inorderUtil(Node node) { if (node == null) return; inorderUtil(node.left); System.out.print(node.data + \" \"); inorderUtil(node.right); } void insert(int key) { root = insertRec(root, key); } Node insertRec(Node root, int data) { if (root == null) { root = new Node(data); return root; } if (data < root.data) root.left = insertRec(root.left, data); else if (data > root.data) root.right = insertRec(root.right, data); return root; } ArrayList<Integer> treeToList(Node node, ArrayList<Integer> list) { if (node == null) return list; treeToList(node.left, list); list.add(node.data); treeToList(node.right, list); return list; } boolean isPairPresent(Node node, int target) { ArrayList<Integer> a1 = new ArrayList<>(); ArrayList<Integer> a2 = treeToList(node, a1); int start = 0; int end = a2.size() - 1; while (start < end) { if (a2.get(start) + a2.get(end) == target) { System.out.println(\"Pair Found: \" + a2.get(start) + \" + \" + a2.get(end) + \" = \" + target); return true; } if (a2.get(start) + a2.get(end) > target) { end--; } if (a2.get(start) + a2.get(end) < target) { start++; } } System.out.println(\"No such values are found!\"); return false; } public static void main(String[] args) { BinarySearchTree tree = new BinarySearchTree(); tree.insert(15); tree.insert(10); tree.insert(20); tree.insert(8); tree.insert(12); tree.insert(16); tree.insert(25); tree.isPairPresent(tree.root, 33); } }", "src": "\n// Java code to find a pair with given sum \n// in a Balanced BST \nimport\njava.util.ArrayList; \n\n// A binary tree node \nclass\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n// Root of BST \n\nNode root; \n\n\n// Constructor \n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n// Inorder traversal of the tree \n\nvoid\ninorder() \n\n{ \n\ninorderUtil(\nthis\n.root); \n\n} \n\n\n// Utility function for inorder traversal of the tree \n\nvoid\ninorderUtil(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\ninorderUtil(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderUtil(node.right); \n\n} \n\n\n// This method mainly calls insertRec() \n\nvoid\ninsert(\nint\nkey) \n\n{ \n\nroot = insertRec(root, key); \n\n} \n\n\n/* A recursive function to insert a new key in BST */\n\nNode insertRec(Node root, \nint\ndata) \n\n{ \n\n\n/* If the tree is empty, return a new node */\n\nif\n(root == \nnull\n) { \n\nroot = \nnew\nNode(data); \n\nreturn\nroot; \n\n} \n\n\n/* Otherwise, recur down the tree */\n\nif\n(data < root.data) \n\nroot.left = insertRec(root.left, data); \n\nelse\nif\n(data > root.data) \n\nroot.right = insertRec(root.right, data); \n\n\nreturn\nroot; \n\n} \n\n\n// Method that adds values of given BST into ArrayList \n\n// and hence returns the ArrayList \n\nArrayList<Integer> treeToList(Node node, ArrayList<Integer> \n\nlist) \n\n{ \n\n// Base Case \n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\n\ntreeToList(node.left, list); \n\nlist.add(node.data); \n\ntreeToList(node.right, list); \n\n\nreturn\nlist; \n\n} \n\n\n// method that checks if there is a pair present \n\nboolean\nisPairPresent(Node node, \nint\ntarget) \n\n{ \n\n// This list a1 is passed as an argument \n\n// in treeToList method \n\n// which is later on filled by the values of BST \n\nArrayList<Integer> a1 = \nnew\nArrayList<>(); \n\n\n// a2 list contains all the values of BST \n\n// returned by treeToList method \n\nArrayList<Integer> a2 = treeToList(node, a1); \n\n\nint\nstart = \n0\n; \n// Starting index of a2 \n\n\nint\nend = a2.size() - \n1\n; \n// Ending index of a2 \n\n\nwhile\n(start < end) { \n\n\nif\n(a2.get(start) + a2.get(end) == target) \n// Target Found! \n\n{ \n\nSystem.out.println(\n\"Pair Found: \"\n+ a2.get(start) + \n\" + \"\n+ a2.get(end) + \n\" \"\n\n+ \n\"= \"\n+ target); \n\nreturn\ntrue\n; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) > target) \n// decrements end \n\n{ \n\nend--; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) < target) \n// increments start \n\n{ \n\nstart++; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No such values are found!\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n/* \n\n15 \n\n/ \\ \n\n10 20 \n\n/ \\ / \\ \n\n8 12 16 25 */\n\ntree.insert(\n15\n); \n\ntree.insert(\n10\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n8\n); \n\ntree.insert(\n12\n); \n\ntree.insert(\n16\n); \n\ntree.insert(\n25\n); \n\n\ntree.isPairPresent(tree.root, \n33\n); \n\n} \n} \n\n// This code is contributed by Kamal Rawal ", "index": 158, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class mohamedy23\n{\n  public static void main(String args[])\n  {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    String s = sc.next();\n    int i = s.length() - 1;\n\n    if (n == 1) {\n      if (s.charAt(0) == '1') {\n        System.out.print(\"YES\");\n        return;\n      } else {\n        System.out.print(\"NO\");\n        return;\n      }\n    } else if (n == 2) {\n      if (s.contains(\"00\") || s.contains(\"11\")) {\n        System.out.print(\"NO\");\n        return;\n      } else {\n        System.out.print(\"Yes\");\n        return;\n      }\n    } else if (s.contains(\"000\") || s.contains(\"11\")) {\n      System.out.print(\"NO\");\n      return;\n    } else if (s.charAt(0) == '0' && s.charAt(1) == '0' && s.charAt(2) == '1') {\n      System.out.print(\"NO\");\n      return;\n    } else if (s.charAt(i) == '0' && s.charAt(i - 1) == '0') {\n      System.out.print(\"NO\");\n      return;\n    }\n    System.out.print(\"YES\");\n  }\n}", "src": "import java.util.*;\n\t\tpublic class mohamedy23\n\t\t{\n\t      public static void main (String args[])\n\t\t    {\n\t\t    \tScanner sc=new Scanner(System.in);\n\t\t    \tint n=sc.nextInt();String s=sc.next();int i=s.length()-1;\n\t\t    \t\n\t\t    \tif(n==1) {\n\t\t    \t\tif(s.charAt(0)=='1') {\n\t\t    \t\t\tSystem.out.print(\"YES\");return;\n\t\t    \t\t}else {\n\t\t    \t\t\tSystem.out.print(\"NO\");return;\n\t\t    \t\t}\n\t\t    \t}else if(n==2) {\n\t\t    \t\tif(s.contains(\"00\")||s.contains(\"11\")) {\n\t\t    \t\t\tSystem.out.print(\"NO\");return;\n\t\t    \t\t}else {\n\t\t    \t\t\tSystem.out.print(\"Yes\");return;\n\t\t    \t\t}\n\t\t    \t}\n\t\t    \telse if(s.contains(\"000\")||s.contains(\"11\")) {\n\t\t    \t\tSystem.out.print(\"NO\");return;\n\t\t    \t}\n\t\t    \telse\tif(s.charAt(0)=='0'&&s.charAt(1)=='0'&&s.charAt(2)=='1') {\n\t\t    \t\tSystem.out.print(\"NO\");return;\n\t\t    \t}\n\t\t    \telse\tif(s.charAt(i)=='0'&&s.charAt(i-1)=='0') {\n\t\t    \t\tSystem.out.print(\"NO\");\n\t\t    \t\treturn;\n\t\t    \t\t}\n\t\t    \t System.out.print(\"YES\");\n\t\t    }\n\t\t}\n\t\t ", "index": 159, "complexity": 3}
{"back-translation": "class Test {\n    static final int MAX_CHAR = 26;\n\n    static int countPairs(String str) {\n        int result = 0;\n        int n = str.length();\n\n        for (int i = 0; i < n; i++)\n            for (int j = 1; (i + j) < n && j <= MAX_CHAR; j++)\n                if ((Math.abs(str.charAt(i + j) - str.charAt(i)) == j))\n                    result++;\n\n        return result;\n    }\n\n    public static void main(String args[]) {\n        String str = \"geeksforgeeks\";\n        System.out.println(countPairs(str));\n    }\n}", "src": "\n// An otpimized Java program to find pairs with distance \n// equal to English alphabet distance \n\nclass\nTest { \n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\n// Method to count pairs with distance \n\n// equal to English alphabet distance \n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n// This loop runs at most 26 times \n\nfor\n(\nint\nj = \n1\n; (i + j) < n && j <= MAX_CHAR; j++) \n\nif\n((Math.abs(str.charAt(i + j) - str.charAt(i)) == j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n} ", "index": 160, "complexity": 3}
{"back-translation": "public class GFG { static int permutationCoeff(int n, int k) { int[] fact = new int[n + 1]; fact[0] = 1; for (int i = 1; i <= n; i++) fact[i] = i * fact[i - 1]; return fact[n] / fact[n - k]; } public static void main(String[] args) { int n = 10, k = 2; System.out.println(\"Value of P( \" + n + \", \" + k + \") is \" + permutationCoeff(n, k)); } }", "src": "\n// A O(n) solution that uses \n// table fact[] to calculate \n// the Permutation Coefficient \nimport\njava .io.*; \n\npublic\nclass\nGFG { \n\n\n// Returns value of Permutation \n\n// Coefficient P(n, k) \n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\n[]fact = \nnew\nint\n[n+\n1\n]; \n\n\n// base case \n\nfact[\n0\n] = \n1\n; \n\n\n// Caculate value \n\n// factorials up to n \n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfact[i] = i * fact[i - \n1\n]; \n\n\n// P(n,k) = n! / (n - k)! \n\nreturn\nfact[n] / fact[n - k]; \n\n} \n\n\n// Driver Code \n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of\"\n\n+ \n\" P( \"\n+ n + \n\", \"\n+ k + \n\") is \"\n\n+ permutationCoeff(n, k) ); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "index": 161, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        IO io = new IO();\n        String s = io.nextLine();\n        if (s.length() < 3) io.println(\"No\");\n        else {\n            int[] b = new int[200];\n            for (int i = 2; i < s.length(); i++) {\n                b['.'] = b['A'] = b['B'] = b['C'] = 0;\n                b[s.charAt(i - 2)] = 1;\n                b[s.charAt(i - 1)] = 1;\n                b[s.charAt(i)] = 1;\n                if (b['A'] + b['B'] + b['C'] == 3) {\n                    io.println(\"Yes\");\n                    return;\n                }\n            }\n            io.println(\"No\");\n        }\n    }\n    static class IO {\n        BufferedInputStream din;\n        final int BUFFER_SIZE = 1 << 16;\n        byte[] buffer;\n        int byteRead, bufferPoint;\n        PrintWriter pw;\n        public IO() {\n            din = new BufferedInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPoint = byteRead = 0;\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), true);\n        }\n        int read() {\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (byteRead == -1) buffer[0] = -1;\n            }\n            return buffer[bufferPoint++];\n        }\n        int peek() {\n            if (byteRead == -1) return -1;\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (byteRead <= 0) return -1;\n            }\n            return buffer[bufferPoint];\n        }\n        boolean hasNext() {\n            int c = peek();\n            while (c != -1 && c <= ' ') {\n                read();\n                c = peek();\n            }\n            return c != -1;\n        }\n        char nextChar() {\n            int c = read();\n            while (c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1) {\n                c = read();\n            }\n            return (char) c;\n        }\n        double nextDouble() {\n            double ret = 0, div = 1;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n            if (neg) return -ret;\n            return ret;\n        }\n        String nextLine() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n        String next() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (Character.isWhitespace(c)) {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n        int nextInt() {\n            int ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n        long nextLong() {\n            long ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n        void println(Object o) {\n            pw.println(o);\n        }\n        void print(Object o) {\n            pw.print(o);\n        }\n        void printf(String format, Object... objects) {\n            pw.printf(format, objects);\n        }\n        void close() {\n            pw.close();\n        }\n        void done(Object o) {\n            print(o);\n            close();\n        }\n    }\n}", "src": "import java.io.*;\nimport java.util.Arrays;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        IO io = new IO();\n        String s=io.nextLine();\n        if (s.length()<3)io.println(\"No\");\n        else {\n            int[]b=new int[200];\n            for (int i=2;i<s.length();i++){\n                b['.']=b['A']=b['B']=b['C']=0;\n                b[s.charAt(i-2)]=1;\n                b[s.charAt(i-1)]=1;\n                b[s.charAt(i)]=1;\n                if (b['A']+b['B']+b['C']==3){io.println(\"Yes\");return;}\n            }\n            io.println(\"No\");\n        }\n    }\n\n\n    static class IO {\n\n        BufferedInputStream din;\n        final int BUFFER_SIZE = 1 << 16;\n        byte[] buffer;\n        int byteRead, bufferPoint;\n\n        StringBuilder builder;\n        PrintWriter pw;\n\n        public IO() {\n            din = new BufferedInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPoint = byteRead = 0;\n\n            builder = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                    System.out\n            )), true);\n        }\n\n        int read() {\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (byteRead == -1) buffer[0] = -1;\n            }\n            return buffer[bufferPoint++];\n        }\n\n        int peek() {\n            if (byteRead == -1) return -1;\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (byteRead <= 0) return -1;\n            }\n            return buffer[bufferPoint];\n        }\n\n        boolean hasNext() {\n            int c = peek();\n            while (c != -1 && c <= ' ') {\n                read();\n                c = peek();\n            }\n            return c != -1;\n        }\n\n        char nextChar() {\n            int c = read();\n            while (c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        double nextDouble() {\n            double ret = 0, div = 1;\n            int c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        String nextLine() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n\n        String next() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (Character.isWhitespace(c)) {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n        int nextInt() {\n            int ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        long nextLong() {\n            long ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        void println(Object o) {\n            pw.println(o);\n        }\n\n        void print(Object o) {\n            pw.print(o);\n        }\n\n        void printf(String format, Object... objects) {\n            pw.printf(format, objects);\n        }\n\n        void close() {\n            pw.close();\n        }\n\n        void done(Object o) {\n            print(o);\n            close();\n        }\n\n    }\n}", "index": 162, "complexity": 3}
{"back-translation": "class GfG { static class Node { int data; Node left, right; } static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.right = null; temp.left = null; return temp; } static Node KthLargestUsingMorrisTraversal(Node root, int k) { Node curr = root; Node Klargest = null; int count = 0; while (curr != null) { if (curr.right == null) { if (++count == k) Klargest = curr; curr = curr.left; } else { Node succ = curr.right; while (succ.left != null && succ.left != curr) succ = succ.left; if (succ.left == null) { succ.left = curr; curr = curr.right; } else { succ.left = null; if (++count == k) Klargest = curr; curr = curr.left; } } } return Klargest; } public static void main(String[] args) { Node root = newNode(4); root.left = newNode(2); root.right = newNode(7); root.left.left = newNode(1); root.left.right = newNode(3); root.right.left = newNode(6); root.right.right = newNode(10); System.out.println(\"Finding K-th largest Node in BST : \" + KthLargestUsingMorrisTraversal(root, 2).data); } }", "src": "\n// Java Program for finding K-th largest Node using O(1) \n// extra memory and reverse Morris traversal. \nclass\nGfG \n{ \n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n// helper function to create a new Node \nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.right = \nnull\n; \n\ntemp.left = \nnull\n; \n\nreturn\ntemp; \n} \n\nstatic\nNode KthLargestUsingMorrisTraversal(Node root, \nint\nk) \n{ \n\nNode curr = root; \n\nNode Klargest = \nnull\n; \n\n\n// count variable to keep count of visited Nodes \n\nint\ncount = \n0\n; \n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\n// if right child is NULL \n\nif\n(curr.right == \nnull\n) \n\n{ \n\n\n// first increment count and check if count = k \n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n// otherwise move to the left child \n\ncurr = curr.left; \n\n} \n\n\nelse\n\n{ \n\n\n// find inorder successor of current Node \n\nNode succ = curr.right; \n\n\nwhile\n(succ.left != \nnull\n&& succ.left != curr) \n\nsucc = succ.left; \n\n\nif\n(succ.left == \nnull\n) \n\n{ \n\n\n// set left child of successor to the \n\n// current Node \n\nsucc.left = curr; \n\n\n// move current to its right \n\ncurr = curr.right; \n\n} \n\n\n// restoring the tree back to original binary \n\n// search tree removing threaded links \n\nelse\n\n{ \n\n\nsucc.left = \nnull\n; \n\n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n// move current to its left child \n\ncurr = curr.left; \n\n} \n\n} \n\n} \n\nreturn\nKlargest; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n// Your Java Code \n\n/* Constructed binary tree is \n\n4 \n\n/ \\ \n\n2 7 \n\n/ \\ / \\ \n\n1 3 6 10 */\n\n\nNode root = newNode(\n4\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n7\n); \n\nroot.left.left = newNode(\n1\n); \n\nroot.left.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n6\n); \n\nroot.right.right = newNode(\n10\n); \n\n\nSystem.out.println(\n\"Finding K-th largest Node in BST : \"\n+ \n\nKthLargestUsingMorrisTraversal(root, \n2\n).data); \n} \n} ", "index": 163, "complexity": 3}
{"back-translation": "import java.util.Arrays; public class GFG { static int cost(int[] a, int n) { int min = Arrays.stream(a).min().getAsInt(); return (n - 1) * min; } public static void main(String[] args) { int[] a = {4, 3, 2}; int n = a.length; System.out.println(cost(a, n)); } }", "src": "\n// Java program to find minimum cost \n// to reduce array size to 1, \nimport\njava.lang.*; \n\npublic\nclass\nGFG { \n\n\n// function to calculate the \n\n// minimum cost \n\nstatic\nint\ncost(\nint\n[]a, \nint\nn) \n\n{ \n\nint\nmin = a[\n0\n]; \n\n\n// find the minimum using \n\n// for loop \n\nfor\n(\nint\ni = \n1\n; i< a.length; i++) \n\n{ \n\nif\n(a[i] < min) \n\nmin = a[i]; \n\n} \n\n\n// Minimum cost is n-1 multiplied \n\n// with minimum element. \n\nreturn\n(n - \n1\n) * min; \n\n} \n\n\n// driver program to test the \n\n// above function. \n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\n\nint\n[]a = { \n4\n, \n3\n, \n2\n}; \n\nint\nn = a.length; \n\n\nSystem.out.println(cost(a, n)); \n\n} \n} \n\n// This code is contributed by parashar. ", "index": 164, "complexity": 3}
{"back-translation": "class Node { char data; Node left, right; public Node(char item) { data = item; left = null; right = null; } } class BinaryTree { Node convertExpression(char[] expression, int i) { if (i >= expression.length) return null; Node root = new Node(expression[i]); ++i; if (i < expression.length && expression[i] == '?') root.left = convertExpression(expression, i + 1); else if (i < expression.length) root.right = convertExpression(expression, i + 1); return root; } public void printTree(Node root) { if (root == null) return; System.out.print(root.data + \" \"); printTree(root.left); printTree(root.right); } public static void main(String args[]) { String exp = \"a?b?c:d:e\"; BinaryTree tree = new BinaryTree(); char[] expression = exp.toCharArray(); Node root = tree.convertExpression(expression, 0); tree.printTree(root); } }", "src": "\n// Java program to covert a ternary \n// expreesion to a tree. \nimport\njava.util.Queue; \nimport\njava.util.LinkedList; \n\n// Class to represent Tree node \nclass\nNode \n{ \n\nchar\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n} \n\n// Class to covert a ternary expression to a Tree \nclass\nBinaryTree \n{ \n\n// Function to convert Ternary Expression to a Binary \n\n// Tree. It return the root of tree \n\nNode convertExpression(\nchar\n[] expression, \nint\ni) \n\n{ \n\n// Base case \n\nif\n(i >= expression.length) \n\nreturn\nnull\n; \n\n\n// store current character of expression_string \n\n// [ 'a' to 'z'] \n\nNode root = \nnew\nNode(expression[i]); \n\n\n// Move ahead in str \n\n++i; \n\n\n// if current character of ternary expression is '?' \n\n// then we add next character as a left child of \n\n// current node \n\nif\n(i < expression.length && expression[i]==\n'?'\n) \n\nroot.left = convertExpression(expression, i+\n1\n); \n\n\n// else we have to add it as a right child of \n\n// current node expression.at(0) == ':' \n\nelse\nif\n(i < expression.length) \n\nroot.right = convertExpression(expression, i+\n1\n); \n\n\nreturn\nroot; \n\n} \n\n\n// function print tree \n\npublic\nvoid\nprintTree( Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nSystem.out.print(root.data +\n\" \"\n); \n\nprintTree(root.left); \n\nprintTree(root.right); \n\n} \n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString exp = \n\"a?b?c:d:e\"\n; \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nchar\n[] expression=exp.toCharArray(); \n\nNode root = tree.convertExpression(expression, \n0\n); \n\ntree.printTree(root) ; \n\n} \n} \n\n/* This code is contributed by Mr. Somesh Awasthi */", "index": 165, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\npublic class D999 {\n    public static void main(String args[]) throws IOException\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int req = n / m;\n        int[] arr = new int[n + 1];\n        int[] size = new int[m];\n        List<Integer>[] list = new ArrayList[m];\n        for (int i = 0; i < m; i++)\n        {\n            list[i] = new ArrayList<>();\n        }\n        for (int i = 1; i <= n; i++)\n        {\n            arr[i] = sc.nextInt();\n            size[arr[i] % m]++;\n            list[arr[i] % m].add(i);\n        }\n        long tot = 0; int x = 0, y = 0;\n        List<Integer> idx = new ArrayList<>();\n        for (int i = 0; i < 2 * m; i++)\n        {\n            if (size[i % m] > req)\n            {\n                for (int j = 0; j < size[i % m] - req; j++)\n                {\n                    idx.add(list[i % m].get(j));\n                    y++;\n                }\n                size[i % m] = req;\n            }\n            else if (size[i % m] < req)\n            {\n                while (x != y && size[i % m] < req)\n                {\n                    int num = arr[idx.get(x)];\n                    int gg = i - num % m;\n                    tot += gg;\n                    arr[idx.get(x)] += gg;\n                    x++;\n                    size[i % m]++;\n                }\n            }\n        }\n        System.out.println(tot);\n        for (int i = 1; i <= n; i++)\n        {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n}", "src": "\nimport java.io.*;\nimport java.util.*;\npublic class D999 {\n    public static void main(String args[])throws IOException\n    {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        int req=n/m;\n        int arr[]=new int[n+1];\n        int size[]=new int[m];\n        List<Integer> list[]=new ArrayList[m];\n        for(int i=0;i<m;i++)\n        {\n            list[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=n;i++)\n        {\n            arr[i]=sc.nextInt();\n            size[arr[i]%m]++;\n            list[arr[i]%m].add(i);\n        }\n        long tot=0;int x=0,y=0;\n        List<Integer> idx=new ArrayList<>();\n        for(int i=0;i < 2*m;i++)\n        {\n            //System.out.println(i+\" \"+size[i%m]);\n            if(size[i%m]>req)\n            {\n                for(int j=0;j<size[i%m]-req;j++)\n                {\n                    idx.add(list[i%m].get(j));\n                    y++;\n                    \n                }\n                size[i%m]=req;\n                //System.out.println(i+\" \"+x+\" \"+y);\n            }\n            else if(size[i%m]<req)\n            {\n                //System.out.println(idx+\" \"+i);\n                while(x!=y && size[i%m]<req)\n                {\n                    int num=arr[idx.get(x)];\n                    int gg=i-num%m;\n                    tot+=gg;\n                    arr[idx.get(x)]+=gg;\n                    x++;\n                    size[i%m]++;\n                }\n            }\n        }\n        System.out.println(tot);\n        for(int i=1;i<=n;i++)\n        {\n            System.out.print(arr[i]+\" \");\n        }\n    }\n}", "index": 166, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n;\n        n = sc.nextInt();\n        int[] arr = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n        }\n\n        int min = 1000000000, temp;\n\n        for (int i = 0; i < n; i++) {\n            temp = arr[i] / Math.max(i, n - 1 - i);\n            if (temp < min) {\n                min = temp;\n            }\n        }\n\n        System.out.println(min);\n    }\n}", "src": "//package com.krakn.CF.B1159;\n\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n;\n        n = sc.nextInt();\n        int[] arr = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n        }\n\n        int min = 1000000000, temp;\n\n        for (int i = 0; i < n; i++) {\n            temp = arr[i] / Math.max(i, n - 1 - i);\n            if (temp < min)\n                min = temp;\n//            System.out.println(i + \" \" + temp);\n        }\n\n        System.out.println(min);\n    }\n}\n", "index": 167, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class TreasureHunt {\n    public static String Solve() {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        String kuro = sc.nextLine(), shiro = sc.nextLine(), katie = sc.nextLine();\n        sc.close();\n        String[] output = {\"Kuro\", \"Shiro\", \"Katie\", \"Draw\"};\n        if (n >= kuro.length())\n            return output[3];\n        int[] maxArr = new int[3];\n        int[][] freq = new int[3][58];\n        for (int i = 0; i < kuro.length(); i++) {\n            maxArr[0] = ++freq[0][kuro.charAt(i) - 65] > maxArr[0] ? freq[0][kuro.charAt(i) - 65] : maxArr[0];\n            maxArr[1] = ++freq[1][shiro.charAt(i) - 65] > maxArr[1] ? freq[1][shiro.charAt(i) - 65] : maxArr[1];\n            maxArr[2] = ++freq[2][katie.charAt(i) - 65] > maxArr[2] ? freq[2][katie.charAt(i) - 65] : maxArr[2];\n        }\n        int winner = 0, max = 0;\n        for (int i = 0; i < 3; i++) {\n            if (kuro.length() - maxArr[i] >= n)\n                maxArr[i] += n;\n            else\n                maxArr[i] = n == 1 ? kuro.length() - 1 : kuro.length();\n            if (max < maxArr[i]) {\n                winner = i;\n                max = maxArr[i];\n            } else if (max == maxArr[i])\n                winner = 3;\n        }\n        return output[winner];\n    }\n    public static void main(String[] args) {\n        System.out.println(Solve());\n    }\n}\n", "src": "import java.util.Scanner;\n\npublic class TreasureHunt {\n\t\n\tpublic static String Solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tsc.nextLine();\n\t\tString kuro = sc.nextLine(), shiro = sc.nextLine(), katie = sc.nextLine();\n\t\tsc.close();\n\t\tString[] output = {\"Kuro\", \"Shiro\", \"Katie\", \"Draw\"};\n\t\tif(n >= kuro.length())\n\t\t\treturn output[3];\n\t\tint[] maxArr = new int[3];\t\t\n\t\tint[][] freq = new int[3][58];\n\t\tfor(int i = 0; i < kuro.length(); i++) {\n\t\t\tmaxArr[0] = ++freq[0][kuro.charAt(i) - 65] > maxArr[0]? freq[0][kuro.charAt(i) - 65] : maxArr[0];\n\t\t\tmaxArr[1] = ++freq[1][shiro.charAt(i) - 65] > maxArr[1]? freq[1][shiro.charAt(i) - 65] : maxArr[1];\n\t\t\tmaxArr[2] = ++freq[2][katie.charAt(i) - 65] > maxArr[2]? freq[2][katie.charAt(i) - 65] : maxArr[2];\n\t\t}\n\t\tint winner = 0, max = 0;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tif(kuro.length() - maxArr[i] >= n)\n\t\t\t\tmaxArr[i] += n;\n\t\t\telse \n\t\t\t\tmaxArr[i] = n == 1? kuro.length() - 1: kuro.length();\n\t\t\tif(max < maxArr[i]) {\n\t\t\t\twinner = i;\n\t\t\t\tmax = maxArr[i];\n\t\t\t} else if(max == maxArr[i])\n\t\t\t\twinner = 3;\n\t\t}\n\t\t\n\t\treturn output[winner];\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(Solve());\n\t}\n}\n", "index": 169, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class SingleWildcard {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int a = input.nextInt();\n        int b = input.nextInt();\n        char[] s1 = new char[a];\n        s1 = input.next().toCharArray();\n        char[] s2 = new char[b];\n        s2 = input.next().toCharArray();\n        boolean condition = false;\n        for (int i = 0; i < a; i++) {\n            if (s1[i] == '*') {\n                condition = true;\n                break;\n            }\n        }\n        if (!condition) {\n            if (match(s1, s2)) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n            return;\n        } else {\n            int i = 0;\n            if (s1.length - 1 > s2.length) {\n                System.out.println(\"NO\");\n                return;\n            }\n            while (i < s1.length && i < s2.length && s1[i] == s2[i]) {\n                i++;\n            }\n            int j = s2.length - 1;\n            int k = s1.length - 1;\n            while (j >= 0 && k >= 0 && s1[k] == s2[j] && i <= j) {\n                j--;\n                k--;\n            }\n            if (i == k && i >= 0 && i < s1.length && s1[i] == '*') {\n                System.out.println(\"YES\");\n                return;\n            }\n            System.out.println(\"NO\");\n        }\n    }\n\n    static boolean match(char[] s1, char[] s2) {\n        if (s1.length != s2.length)\n            return false;\n        for (int i = 0; i < s1.length; i++) {\n            if (s1[i] != s2[i])\n                return false;\n        }\n        return true;\n    }\n}", "src": "import java.util.Scanner;\n\n//import java.util.Scanner;\n\n\n\n\npublic class SingleWildcard {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner input =new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tchar[] s1 =new char[a];\n\t\ts1 = input.next().toCharArray();\n\t\t\n\t\tchar[] s2 = new char[b];\n\t\ts2 = input.next().toCharArray();\n\t    boolean condition = false;\n\t    for(int i=0; i<a;i++){\n\t    \tif(s1[i]=='*'){\n\t    \t\tcondition= true;\n\t    \t\tbreak;\n\t    \t}\n\t    }\n\t   \n\t    if(!condition){\n\t    \tif(match(s1,s2)){\n\t    \t\tSystem.out.println(\"YES\");\n\t    \t\t\n\t    \t}\n\t    \telse\n\t    \t\tSystem.out.println(\"NO\");\n\t       return;\n\t    }\n\t    else{\n\t    \tint i=0;\n\t    \tif(s1.length-1>s2.length){\n\t    \t\tSystem.out.println(\"NO\");\n\t    \t\treturn;\n\t    \t}\n\t    \twhile(i<s1.length && i<s2.length && s1[i]==s2[i]){\n\t    \t\ti++;\n\t    \t}\n\t    \tint j=s2.length-1;\n\t    \tint k = s1.length-1;\n\t    \twhile(j>=0 && k>=0 &&  s1[k]==s2[j] && i<=j){\n\t    \t\tj--;\n\t    \t\tk--;\n\t    \t}\n\t    \t//System.out.println(i);\n\t    \tif(i==k && i>=0 && i<s1.length && s1[i]=='*' ){\n\t    \t\tSystem.out.println(\"YES\");\n\t    \t\treturn;\n\t    \t}\n\t    \tSystem.out.println(\"NO\");\n\t    }\n\t\t\n\t\t\n\t}\n\t\n\tstatic boolean match(char[] s1,char[] s2){\n\t\tif(s1.length!=s2.length)return false;\n\t\tfor(int i=0; i<s1.length;i++){\n\t\t\tif(s1[i]!=s2[i])return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\n}\n", "index": 170, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    \n    static MyScanner in = new MyScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int n = in.nextInt(), l[] = new int[n],\n            p = -1000000, d_min = 1000000, min = 1000000000;\n        for(int i = 0; i < n; i++) {\n            l[i] = in.nextInt();\n            min = Math.min(min, l[i]);\n        }\n        for(int i = 0; i < n; i++)\n            if(l[i] == min) {\n                d_min = Math.min(d_min, i - p);\n                p = i;\n            }\n        out.print(d_min);\n        out.close();\n    }\n    \n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public String nextLine() throws IOException {\n            while(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            String r = st.nextToken(\"\\n\");\n            st = new StringTokenizer(br.readLine(), \" \");\n            return r;\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}", "src": "import java.io.BufferedReader;\n\nimport java.io.PrintWriter;\n\nimport java.io.InputStreamReader;\n\nimport java.io.IOException;\n\nimport java.util.StringTokenizer;\n\npublic class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int n = in.nextInt(), l[] = new int[n],\n            p = -1000000, d_min = 1000000, min = 1000000000;\n        for(int i = 0; i < n; i++) {\n            l[i] = in.nextInt();\n            min = Math.min(min, l[i]);\n        }\n        for(int i = 0; i < n; i++)\n            if(l[i] == min) {\n                d_min = Math.min(d_min, i - p);\n                p = i;\n            }\n        out.print(d_min);\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public String nextLine() throws IOException {\n            while(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            String r = st.nextToken(\"\\n\");\n            st = new StringTokenizer(br.readLine(), \" \");\n            return r;\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 171, "complexity": 3}
{"back-translation": "public class Solution { static int m = (int) 1e9 + 7; public class Node {int a; int b; public void Node(int a, int b) { this.a = a; this.b = b; } } public int mul(int a, int b) { a = a % m; b = b % m; return ((a * b) % m); } public int pow(int a, int b) { int x = 1; while (b > 0) { if (b % 2 != 0) x = mul(x, a); a = mul(a, a); b = b / 2; } return x; } public static long gcd(long a, long b) { if (b == 0) return a; else return gcd(b, a % b); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); HashMap<Integer, Integer> h = new HashMap(); int[] a = new int[n]; int x = sc.nextInt(); for (int i = 0; i < n; i++) { a[i] = sc.nextInt(); if (h.get(a[i]) == null) { h.put(a[i], 1); } else { System.out.print(0); System.exit(0); } } for (int i = 0; i < n; i++) { int num = a[i] & x; if (num == a[i]) continue; if (h.get(num) == null) continue; else { System.out.print(1); System.exit(0); } } for (int i = 0; i < n; i++) { int num = a[i] & x; if (num == a[i]) continue; if (h.get(num) == null) h.put(num, 1); else { System.out.print(2); System.exit(0); } } System.out.print(-1); } }", "src": "//package contese_476;\nimport java.util.*;\npublic class q1 \n{\n\tint m=(int)1e9+7;\npublic class Node\n{\n\tint a;\n\tint b;\n\tpublic void Node(int a,int b)\n\t{\n\t\tthis.a=a;\n\t\tthis.b=b;\n\t}\n}\npublic int mul(int a ,int b)\n{\na=a%m;\nb=b%m;\nreturn((a*b)%m);\n}\npublic int pow(int a,int b)\n{\n\tint x=1;\n\twhile(b>0)\n\t{\n\t\tif(b%2!=0)\n\t\t\tx=mul(x,a);\n\t\ta=mul(a,a);\n\t\tb=b/2;\n\t}\n\treturn x;\n}\npublic static long gcd(long a,long b)\n{\n\tif(b==0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b,a%b);\n}\npublic static void main(String[] args)\n{\n\tScanner sc=new Scanner(System.in);\n\tint n=sc.nextInt();\n\tHashMap<Integer,Integer> h=new HashMap();\n\t//HashMap<Integer,Integer> h1=new HashMap();\n\tint[] a=new int[n];\n\tint x=sc.nextInt();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta[i]=sc.nextInt();\n\t\tif(h.get(a[i])==null)\n\t\t{\n\t\t\th.put(a[i], 1);\n\t\t\t//h1.put(a[i],i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.print(0);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint num=a[i]&x;\n\t\tif(num==a[i])\n\t\t\tcontinue;\n\t\tif(h.get(num)==null)\n\t\t\tcontinue;\n\t\t\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tSystem.out.print(1);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint num=a[i]&x;\n\t\tif(num==a[i])\n\t\t\tcontinue;\n\t\tif(h.get(num)==null)\n\t\t\th.put(num, 1);\n\t\telse\n\t\t{\n\t\t\tSystem.out.print(2);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tSystem.out.print(-1);\n\t\n     \n}\n\n}", "index": 172, "complexity": 3}
{"back-translation": "class GFG { static int maxLoot(int hval[], int n) { if (n == 0) return 0; int value1 = hval[0]; if (n == 1) return value1; int value2 = Math.max(hval[0], hval[1]); if (n == 2) return value2; int max_val = 0; for (int i = 2; i < n; i++) { max_val = Math.max(hval[i] + value1, value2); value1 = value2; value2 = max_val; } return max_val; } public static void main (String[] args) { int hval[] = {6, 7, 1, 3, 8, 2, 4}; int n = hval.length; System.out.println(\"Maximum loot value : \" + maxLoot(hval, n)); } }", "src": "\n// Java program to find the maximum stolen value \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Function to calculate the maximum stolen value \n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\n\nint\nvalue1 = hval[\n0\n]; \n\nif\n(n == \n1\n) \n\nreturn\nvalue1; \n\n\nint\nvalue2 = Math.max(hval[\n0\n], hval[\n1\n]); \n\nif\n(n == \n2\n) \n\nreturn\nvalue2; \n\n\n// contains maximum stolen value at the end \n\nint\nmax_val = \n0\n; \n\n\n// Fill remaining positions \n\nfor\n(\nint\ni=\n2\n; i<n; i++) \n\n{ \n\nmax_val = Math.max(hval[i]+value1, value2); \n\nvalue1 = value2; \n\nvalue2 = max_val; \n\n} \n\n\nreturn\nmax_val; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n} \n\n// Contributed by Pramod kumar ", "index": 173, "complexity": 3}
{"back-translation": "class GFG { static void initializeDiffArray(int A[], int D[]) { int n = A.length; D[0] = A[0]; D[n] = 0; for (int i = 1; i < n; i++) D[i] = A[i] - A[i - 1]; } static void update(int D[], int l, int r, int x) { D[l] += x; D[r + 1] -= x; } static int printArray(int A[], int D[]) { for (int i = 0; i < A.length; i++) { if (i == 0) A[i] = D[i]; else A[i] = D[i] + A[i - 1]; System.out.print(A[i] + \" \"); } System.out.println(); return 0; } public static void main(String[] args) { int A[] = { 10, 5, 20, 40 }; int n = A.length; int D[] = new int[n + 1]; initializeDiffArray(A, D); update(D, 0, 1, 10); printArray(A, D); update(D, 1, 3, 20); update(D, 2, 2, 30); printArray(A, D); } }", "src": "\n// Java code to demonstrate Difference Array \nclass\nGFG { \n\n\n// Creates a diff array D[] for A[] and returns \n\n// it after filling initial values. \n\nstatic\nvoid\ninitializeDiffArray(\nint\nA[], \nint\nD[]) \n\n{ \n\n\nint\nn = A.length; \n\n\nD[\n0\n] = A[\n0\n]; \n\nD[n] = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nD[i] = A[i] - A[i - \n1\n]; \n\n} \n\n\n// Does range update \n\nstatic\nvoid\nupdate(\nint\nD[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nD[l] += x; \n\nD[r + \n1\n] -= x; \n\n} \n\n\n// Prints updated Array \n\nstatic\nint\nprintArray(\nint\nA[], \nint\nD[]) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < A.length; i++) { \n\n\nif\n(i == \n0\n) \n\nA[i] = D[i]; \n\n\n// Note that A[0] or D[0] decides \n\n// values of rest of the elements. \n\nelse\n\nA[i] = D[i] + A[i - \n1\n]; \n\n\nSystem.out.print(A[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n\nreturn\n0\n; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Array to be updated \n\nint\nA[] = { \n10\n, \n5\n, \n20\n, \n40\n}; \n\nint\nn = A.length; \n\n// Create and fill difference Array \n\n// We use one extra space because \n\n// update(l, r, x) updates D[r+1] \n\nint\nD[] = \nnew\nint\n[n + \n1\n]; \n\ninitializeDiffArray(A, D); \n\n\n// After below update(l, r, x), the \n\n// elements should become 20, 15, 20, 40 \n\nupdate(D, \n0\n, \n1\n, \n10\n); \n\nprintArray(A, D); \n\n\n// After below updates, the \n\n// array should become 30, 35, 70, 60 \n\nupdate(D, \n1\n, \n3\n, \n20\n); \n\nupdate(D, \n2\n, \n2\n, \n30\n); \n\n\nprintArray(A, D); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "index": 174, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class round569d2a {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint sum = 1;\n\t\tint tracker = 4;\n\t\twhile (n > 1) {\n\t\t\tsum += tracker;\n\t\t\ttracker += 4;\n\t\t\tn--;\n\t\t}\n\t\tSystem.out.println(sum);\n\n\t}\n\n\t// ======================================================================================\n\t// =============================== Reference Code =======================================\n\t// ======================================================================================\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t// Method to return all primes smaller than or equal to \n\t// n using Sieve of Eratosthenes \n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t// Create a boolean array \"prime[0..n]\" and initialize \n\t\t// all entries it as true. A value in prime[i] will \n\t\t// finally be false if i is Not a prime, else true. \n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t// If prime[p] is not changed, then it is a prime \n\t\t\tif (prime[p] == true) {\n\t\t\t\t// Update all multiples of p \n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t// Binary search for number greater than or equal to target\n\t// returns -1 if number not found\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t// Base Case \n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; // To store results of recursive call \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t// Update x and y using results of recursive \n\t\t// call \n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t// Returns modulo inverse of a  \n\t// with respect to m using extended \n\t// Euclid Algorithm. Refer below post for details: \n\t// https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/ \n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t// Apply extended Euclid Algorithm \n\t\twhile (a > 1) {\n\t\t\t// q is quotient \n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t// m is remainder now, process \n\t\t\t// same as euclid's algo \n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t// Make x1 positive \n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t// k is size of num[] and rem[]. \n\t// Returns the smallest number \n\t// x such that: \n\t// x % num[0] = rem[0], \n\t// x % num[1] = rem[1], \n\t// .................. \n\t// x % num[k-2] = rem[k-1] \n\t// Assumption: Numbers in num[] are pairwise  \n\t// coprime (gcd for every pair is 1) \n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t// Compute product of all numbers \n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t// Initialize result \n\t\tint result = 0;\n\n\t\t// Apply above formula \n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t/**\n\t * Source: Matt Fontaine\n\t */\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 175, "complexity": 3}
{"back-translation": "import java.util.*;\n\nimport java.io.*;\npublic class Solution\n{\n    public static void main(String [] args) throws IOException\n    {\n        PrintWriter pw=new PrintWriter(System.out);\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(br.readLine());\n        int n=Integer.parseInt(st.nextToken());\n        int k=Integer.parseInt(st.nextToken());\n        st=new StringTokenizer(br.readLine());\n        String str=st.nextToken();\n        char [] arr=str.toCharArray();\n        Arrays.sort(arr);\n        int weight=arr[0]-96;\n        char a=arr[0];\n        int included=1;\n        for(int i=1;i<arr.length;++i)\n        {\n            if(included==k)\n                break;\n            char c=arr[i];\n            if(c-a<2)\n                continue;\n            weight+=arr[i]-96;\n            ++included;\n            a=arr[i];\n        }\n        if(included==k)\n            pw.println(weight);\n        else\n            pw.println(-1);\n        pw.close();\n    }\n}", "src": "import java.util.*;\n\nimport java.io.*;\npublic class Solution\n{\n    public static void main(String [] args) throws IOException\n    {\n        PrintWriter pw=new PrintWriter(System.out);//use pw.println() not pw.write();\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(br.readLine());\n        /*\n        inputCopy\n5 3\nxyabd\noutputCopy\n29\ninputCopy\n7 4\nproblem\noutputCopy\n34\ninputCopy\n2 2\nab\noutputCopy\n-1\ninputCopy\n12 1\nabaabbaaabbb\noutputCopy\n1\n        */\n        int n=Integer.parseInt(st.nextToken());\n        int k=Integer.parseInt(st.nextToken());\n        st=new StringTokenizer(br.readLine());\n        String str=st.nextToken();\n        char [] arr=str.toCharArray();\n        Arrays.sort(arr);\n        int weight=arr[0]-96;\n        char a=arr[0];\n        int included=1;\n        for(int i=1;i<arr.length;++i)\n        {\n            if(included==k)\n                break;\n            char c=arr[i];\n            if(c-a<2)\n                continue;\n           \n            weight+=arr[i]-96;\n            ++included;\n            a=arr[i];\n            \n        }\n        if(included==k)\n            pw.println(weight);\n        else\n            pw.println(-1);\n        pw.close();//Do not forget to write it after every program return statement !!\n    }\n}\n/*\n\u2192Judgement Protocol\nTest: #1, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n5 3\nxyabd\nOutput\n29\nAnswer\n29\nChecker Log\nok 1 number(s): \"29\"\nTest: #2, time: 78 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n7 4\nproblem\nOutput\n34\nAnswer\n34\nChecker Log\nok 1 number(s): \"34\"\nTest: #3, time: 139 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nab\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #4, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n12 1\nabaabbaaabbb\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #5, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 13\nqwertyuiopasdfghjklzxcvbnmaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n169\nAnswer\n169\nChecker Log\nok 1 number(s): \"169\"\nTest: #6, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 14\nqwertyuiopasdfghjklzxcvbnmaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #7, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\na\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #8, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 1\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n1\nAnswer\n1\nChecker Log\nok 1 number(s): \"1\"\nTest: #9, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 2\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #10, time: 92 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n13 13\nuwgmkyqeiaocs\nOutput\n169\nAnswer\n169\nChecker Log\nok 1 number(s): \"169\"\nTest: #11, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n13 13\nhzdxpbfvrltnj\nOutput\n182\nAnswer\n182\nChecker Log\nok 1 number(s): \"182\"\nTest: #12, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\nn\nOutput\n14\nAnswer\n14\nChecker Log\nok 1 number(s): \"14\"\nTest: #13, time: 92 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n10 8\nsmzeblyjqw\nOutput\n113\nAnswer\n113\nChecker Log\nok 1 number(s): \"113\"\nTest: #14, time: 78 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n20 20\ntzmvhskkyugkuuxpvtbh\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #15, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n30 15\nwjzolzzkfulwgioksfxmcxmnnjtoav\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #16, time: 93 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n40 30\nxumfrflllrrgswehqtsskefixhcxjrxbjmrpsshv\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #17, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n50 31\nahbyyoxltryqdmvenemaqnbakglgqolxnaifnqtoclnnqiabpz\nOutput\n-1\nAnswer\n-1\nChecker Log\nok 1 number(s): \"-1\"\nTest: #18, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n10 7\niuiukrxcml\nOutput\n99\nAnswer\n99\nChecker Log\nok 1 number(s): \"99\"\nTest: #19, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n38 2\nvjzarfykmrsrvwbwfwldsulhxtykmjbnwmdufa\nOutput\n5\nAnswer\n5\nChecker Log\nok 1 number(s): \"5\"\nTest: #20, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n12 6\nfwseyrarkwcd\nOutput\n61\nAnswer\n61\nChecker Log\nok 1 number(s): \"61\"\nTest: #21, time: 109 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nac\nOutput\n4\nAnswer\n4\nChecker Log\nok 1 number(s): \"4\"\nTest: #22, time: 108 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n1 1\nc\nOutput\n3\nAnswer\n3\nChecker Log\nok 1 number(s): \"3\"\nTest: #23, time: 124 ms., memory: 0 KB, exit code: 0, checker exit code: 0, verdict: OK\nInput\n2 2\nad\nOutput\n5\nAnswer\n5\nChecker Log\nok 1 number(s): \"5\"\nTest: #24, time: 77 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n2 1\nac\nOutput\n-1\nAnswer\n1\nChecker Log\nwrong answer 1st number\n*/", "index": 176, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport javafx.util.Pair;\npublic class Main\n{\n    static class FastReader\n    {\n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public FastReader() { this(System.in); }public FastReader(InputStream is) { mIs = is;}\n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];}\n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;}\n        public String next(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();}\n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;}\n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;}\n        public double d() throws IOException {return Double.parseDouble(next()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; }\n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; }\n        public void scanIntArr(int [] arr){ for(int li=0;li<arr.length;++li){ arr[li]=i();}}\n        public void scanLongArr(long [] arr){for (int i=0;i<arr.length;++i){arr[i]=l();}}\n        public void shuffle(int [] arr){ for(int i=arr.length;i>0;--i) { int r=(int)(Math.random()*i); int temp=arr[i-1]; arr[i-1]=arr[r]; arr[r]=temp; } }\n    }\n    public static void main(String[] args)throws IOException {\n        /*\ninputCopy\n4\n2 1 2 1\noutputCopy\n4\ninputCopy\n5\n0 -1 -1 -1 -1\noutputCopy\n4\n*/\n        PrintWriter pw = new PrintWriter(System.out);\n        FastReader fr = new FastReader();\n        int n=fr.i();\n        int [] arr=new int[n];\n        fr.scanIntArr(arr);\n        int min=Integer.MAX_VALUE;\n        int max=Integer.MIN_VALUE;\n        long sum=0;\n        if(n==1)\n        {\n            pw.println(arr[0]);\n            pw.flush();\n            pw.close();\n            return;\n        }\n        for(int i=0;i<n;++i)\n        {\n            if(arr[i]<min)\n                min=arr[i];\n            if(arr[i]>max)\n                max=arr[i];\n            sum+=Math.abs(arr[i]);\n        }\n        if(min>0)\n        {\n            sum-=2*min;\n        }\n        if(max<0)\n        {\n            sum+=2*max;\n        }\n        pw.println(sum);\n        pw.flush();\n        pw.close();\n    }\n}", "src": "\n// LM10: The next Ballon d'or\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport javafx.util.Pair;\npublic class Main\n{\n    static class FastReader\n    {\n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public FastReader() { this(System.in); }public FastReader(InputStream is) { mIs = is;}\n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];}\n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;}\n        public String next(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();}\n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;}\n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;}\n        public double d() throws IOException {return Double.parseDouble(next()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; }\n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; }\n        public void scanIntArr(int [] arr){ for(int li=0;li<arr.length;++li){ arr[li]=i();}}\n        public void scanLongArr(long [] arr){for (int i=0;i<arr.length;++i){arr[i]=l();}}\n        public void shuffle(int [] arr){ for(int i=arr.length;i>0;--i) { int r=(int)(Math.random()*i); int temp=arr[i-1]; arr[i-1]=arr[r]; arr[r]=temp; } }\n    }\n    public static void main(String[] args)throws IOException {\n        /*\ninputCopy\n4\n2 1 2 1\noutputCopy\n4\ninputCopy\n5\n0 -1 -1 -1 -1\noutputCopy\n4\n*/\n        PrintWriter pw = new PrintWriter(System.out);\n        FastReader fr = new FastReader();\n        int n=fr.i();\n        int [] arr=new int[n];\n        fr.scanIntArr(arr);\n        int min=Integer.MAX_VALUE;\n        int max=Integer.MIN_VALUE;\n        long sum=0;\n        if(n==1)\n        {\n            pw.println(arr[0]);\n            pw.flush();\n            pw.close();\n            return;\n        }\n        for(int i=0;i<n;++i)\n        {\n            if(arr[i]<min)\n                min=arr[i];\n            if(arr[i]>max)\n                max=arr[i];\n            sum+=Math.abs(arr[i]);\n        }\n        if(min>0)\n        {\n            sum-=2*min;\n        }\n        if(max<0)\n        {\n            sum+=2*max;\n        }\n        pw.println(sum);\n        pw.flush();\n        pw.close();\n    }\n}", "index": 178, "complexity": 3}
{"back-translation": "class RearrangeArray { void rearrangeNaive(int arr[], int n) { int temp[] = new int[n]; int i; for (i = 0; i < n; i++) temp[arr[i]] = i; for (i = 0; i < n; i++) arr[i] = temp[i]; } void printArray(int arr[], int n) { int i; for (i = 0; i < n; i++) { System.out.print(arr[i] + \" \"); } System.out.println(\"\"); } public static void main(String[] args) { RearrangeArray arrange = new RearrangeArray(); int arr[] = {1, 3, 0, 2}; int n = arr.length; System.out.println(\"Given array is \"); arrange.printArray(arr, n); arrange.rearrangeNaive(arr, n); System.out.println(\"Modified array is \"); arrange.printArray(arr, n); } }", "src": "\n// A simple Java program to rearrange contents of arr[] \n// such that arr[j] becomes j if arr[i] is j \nclass\nRearrangeArray { \n\n// A simple method to rearrange 'arr[0..n-1]' so that 'arr[j]' \n\n// becomes 'i' if 'arr[i]' is 'j' \n\nvoid\nrearrangeNaive(\nint\narr[], \nint\nn) \n\n{ \n\n// Create an auxiliary array of same size \n\nint\ntemp[] = \nnew\nint\n[n]; \n\nint\ni; \n\n\n// Store result in temp[] \n\nfor\n(i = \n0\n; i < n; i++) \n\ntemp[arr[i]] = i; \n\n\n// Copy temp back to arr[] \n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n// A utility function to print contents of arr[0..n-1] \n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n1\n, \n3\n, \n0\n, \n2\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrangeNaive(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n} ", "index": 179, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\npublic class GFG {\n\tpublic static void main (String[] args) {\n\t    Scanner sc = new Scanner(System.in);\n\t    int n = sc.nextInt();\n\t    int a = sc.nextInt();\n\t    int b = sc.nextInt();\n\t    int c = sc.nextInt();\n\t    int ans = 0;\n\t    int t = sc.nextInt();\n\t    int[] arr = new int[n];\n\t    for (int i = 0; i < n; i++) {\n\t        int nn = sc.nextInt();\n\t        ans += a;\n\t        if (b < c) {\n\t            ans += (t - nn) * (c - b);\n\t        }\n\t    }\n\t    System.out.println(ans);\n\t}\n}", "src": "import java.io.*;\nimport java.util.*;\npublic class GFG {\n\tpublic static void main (String[] args) {\n\t    Scanner sc = new Scanner (System.in);\n\t    int n = sc.nextInt();\n\t    int a = sc.nextInt();\n\t    int b = sc.nextInt();\n\t    int c = sc.nextInt();\n\t    int ans = 0;\n\t    int t= sc.nextInt();\n\t    int arr[] = new int[n];\n\t    for(int i=0;i<n;i++){\n\t        int nn = sc.nextInt();\n\t        ans+=a;\n\t        if(b<c){\n\t            ans += (t-nn) * (c - b);\n\t        }\n\t    }\n\t    System.out.println(ans);\n\t}\n}", "index": 180, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(bf.readLine());\n        int[]f=new int[1001];\n        int[]a=new int[n];\n        StringTokenizer tk=new StringTokenizer(bf.readLine());\n        for (int i = 0; i < n; i++) {\n            int element=Integer.parseInt(tk.nextToken());\n            a[i]=element;\n            f[element]++;\n        }\n        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        ArrayList<Integer> h=new ArrayList<Integer>();\n        int counter=0;\n        for (int i = 0; i < n; i++) {\n            if(f[a[i]]==1){counter++; h.add(a[i]);}\n            else{f[a[i]]-=1;}\n        }\n        pw.write(counter+\"\\n\");\n        for (int i = 0; i < h.size(); i++) {\n            pw.write(h.get(i)+\" \");\n        }\n        pw.flush();\n    }\n}", "src": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(bf.readLine());\n        int[]f=new int[1001];\n        int[]a=new int[n];\n        StringTokenizer tk=new StringTokenizer(bf.readLine());\n        for (int i = 0; i < n; i++) {\n            int element=Integer.parseInt(tk.nextToken());\n            a[i]=element;\n            f[element]++;\n        }\n        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        ArrayList<Integer> h=new ArrayList<>();\n        int counter=0;\n        for (int i = 0; i < n; i++) {\n            if(f[a[i]]==1){counter++; h.add(a[i]);}\n            else{f[a[i]]-=1;}\n        }\n        pw.write(counter+\"\\n\");\n        for (int i = 0; i < h.size(); i++) {\n            pw.write(h.get(i)+\" \");\n        }\n        pw.flush();\n    }\n}", "index": 181, "complexity": 3}
{"back-translation": "class GFG { static class node { int key; node left, right; node(int key) { this.key = key; this.left = null; this.right = null; } } static void convert(node root) { if (root == null) return; convert(root.right); convert(root.left); if (root.right == null) root.right = root.left; else root.right.left = root.left; root.left = null; } static void downRightTraversal(node root) { if (root != null) { System.out.print(root.key + \" \"); downRightTraversal(root.left); downRightTraversal(root.right); } } static node newNode(int key) { node temp = new node(0); temp.key = key; temp.left = null; temp.right = null; return temp; } public static void main(String[] args) { node root = new node(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); root.left.right.left = newNode(6); root.left.right.right = newNode(7); root.left.right.right.right = newNode(8); convert(root); System.out.println(\"Traversal of the tree converted to down-right form\"); downRightTraversal(root); } }", "src": "\n/* Java program to convert left-right to \ndown-right representation of binary tree */\nclass\nGFG \n{ \n\n// A Binary Tree Node \nstatic\nclass\nnode \n{ \n\nint\nkey; \n\nnode left, right; \n\nnode(\nint\nkey) \n\n{ \n\nthis\n.key = key; \n\nthis\n.left = \nnull\n; \n\nthis\n.right = \nnull\n; \n\n} \n} \n\n// An Iterative level order traversal \n// based function to convert left-right \n// to down-right representation. \nstatic\nvoid\nconvert(node root) \n{ \n\n// Base Case \n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n// Recursively convert left \n\n// an right subtrees \n\nconvert(root.left); \n\nconvert(root.right); \n\n\n// If left child is NULL, make right \n\n// child as left as it is the first child. \n\nif\n(root.left == \nnull\n) \n\nroot.left = root.right; \n\n\n// If left child is NOT NULL, then make \n\n// right child as right of left child \n\nelse\n\nroot.left.right = root.right; \n\n\n// Set root's right as NULL \n\nroot.right = \nnull\n; \n} \n\n// A utility function to traverse a \n// tree stored in down-right form. \nstatic\nvoid\ndownRightTraversal(node root) \n{ \n\nif\n(root != \nnull\n) \n\n{ \n\nSystem.out.print(root.key + \n\" \"\n); \n\ndownRightTraversal(root.right); \n\ndownRightTraversal(root.left); \n\n} \n} \n\n// Utility function to create \n// a new tree node \nstatic\nnode newNode(\nint\nkey) \n{ \n\nnode temp = \nnew\nnode(\n0\n); \n\ntemp.key = key; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n// Let us create binary tree \n\n// shown in above diagram \n\n/* \n\n1 \n\n/ \\ \n\n2 3 \n\n/ \\ \n\n4 5 \n\n/ / \\ \n\n6 7 8 \n\n*/\n\nnode root = \nnew\nnode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n4\n); \n\nroot.right.right = newNode(\n5\n); \n\nroot.right.left.left = newNode(\n6\n); \n\nroot.right.right.left = newNode(\n7\n); \n\nroot.right.right.right = newNode(\n8\n); \n\n\nconvert(root); \n\n\nSystem.out.println(\n\"Traversal of the tree \"\n+ \n\n\"converted to down-right form\"\n); \n\ndownRightTraversal(root); \n} \n} \n\n// This code is contributed \n// by Prerna Saini ", "index": 182, "complexity": 3}
{"back-translation": "class PrintLargest {\n    static void print3largest(int arr[], int arr_size) {\n        int i, first, second, third;\n        if (arr_size < 3) {\n            System.out.print(\" Invalid Input \");\n            return;\n        }\n        third = first = second = Integer.MIN_VALUE;\n        for (i = 0; i < arr_size; i++) {\n            if (arr[i] > first) {\n                third = second;\n                second = first;\n                first = arr[i];\n            } else if (arr[i] > second) {\n                third = second;\n                second = arr[i];\n            } else if (arr[i] > third) third = arr[i];\n        }\n        System.out.println(\"Three largest elements are \" + first + \" \" + second + \" \" + third);\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {12, 13, 1, 10, 34, 1};\n        int n = arr.length;\n        print3largest(arr, n);\n    }\n}", "src": "\n// Java code to find largest three elements \n// in an array \n\nclass\nPrintLargest \n{ \n\n/* Function to print three largest elements */\n\nstatic\nvoid\nprint3largest(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ni, first, second, third; \n\n\n/* There should be atleast three elements */\n\nif\n(arr_size < \n3\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nthird = first = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i ++) \n\n{ \n\n/* If current element is greater than \n\nfirst*/\n\nif\n(arr[i] > first) \n\n{ \n\nthird = second; \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n/* If arr[i] is in between first and \n\nsecond then update second */\n\nelse\nif\n(arr[i] > second) \n\n{ \n\nthird = second; \n\nsecond = arr[i]; \n\n} \n\n\nelse\nif\n(arr[i] > third) \n\nthird = arr[i]; \n\n} \n\n\nSystem.out.println(\n\"Three largest elements are \"\n+ \n\nfirst + \n\" \"\n+ second + \n\" \"\n+ third); \n\n} \n\n\n/* Driver program to test above function*/\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint3largest(arr, n); \n\n} \n} \n/*This code is contributed by Prakriti Gupta \nand edited by Ayush Singla(@ayusin51)*/", "index": 183, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static String S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        S = sc.next();\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        int ans = -1;\n        int time = 1;\n        int n = S.length();\n        for (int i = 1; i <= n*2; i++) {\n            if (S.charAt((i-1)%n) != S.charAt(i%n)) {\n                time++;\n            } else {\n                ans = max(time, ans);\n                time = 1;\n            }\n        }\n        ans = max(time, ans);\n\n        if (ans == n*2) {\n            return n;\n        } else {\n            return ans;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n", "src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static String S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        S = sc.next();\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        int ans = -1;\n        int time = 1;\n        int n = S.length();\n        for (int i = 1; i < n*2; i++) {\n            if( S.charAt((i-1)%n) != S.charAt(i%n) ) {\n                time++;\n            } else {\n                ans = Math.max(time, ans);\n                time = 1;\n            }\n        }\n        ans = Math.max(time, ans);\n\n        if( ans == n*2 ) {\n            return n;\n        } else {\n            return ans;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n", "index": 184, "complexity": 3}
{"back-translation": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class UniformString {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = Integer.parseInt(nextString());\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint n = Integer.parseInt(nextString());\n\t\t\tint k = Integer.parseInt(nextString());\n\t\t\tString s = \"\";\n\t\t\tfor (int j = 0; j < n; j++) \n\t\t\t\ts += (char)('a' + (j%k)); \n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = Integer.parseInt(nextString());\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = Integer.parseInt(nextString());\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = Long.parseLong(nextString());\n\t\treturn a;\n\t}\n}", "src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class UniformString {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = nextInt();\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint n = nextInt();\n\t\t\tint k = nextInt();\n\t\t\tString s = \"\";\n\t\t\tfor (int j = 0; j < n; j++) \n\t\t\t\ts += (char)('a' + (j%k)); \n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 185, "complexity": 3}
{"back-translation": "import java.math.BigDecimal;\nimport java.util.Scanner;\n\npublic class A1 {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n\n        long size = scan.nextLong();\n        int numberOfSpecial = scan.nextInt();\n        long pageSize = scan.nextLong();\n\n        long[] specialItemsArray = new long[numberOfSpecial];\n        for (int i = 0; i < numberOfSpecial; i++) {\n            specialItemsArray[i] = scan.nextLong();\n        }\n\n        int totalRemoved = 0;\n        int step = 0;\n\n        long currentPageIndex = BigDecimal.valueOf(specialItemsArray[0]).divide(BigDecimal.valueOf(pageSize), 2, RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();\n        int specialItemArrayIndex = 1;\n\n        while (specialItemArrayIndex < numberOfSpecial) {\n            long pageIndex = BigDecimal.valueOf(specialItemsArray[specialItemArrayIndex] - totalRemoved).divide(BigDecimal.valueOf(pageSize), 2, RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();\n            if (currentPageIndex != pageIndex) {\n                step++;\n                totalRemoved = specialItemArrayIndex;\n                currentPageIndex = BigDecimal.valueOf(specialItemsArray[specialItemArrayIndex] - totalRemoved).divide(BigDecimal.valueOf(pageSize), 2, RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();\n            }\n            specialItemArrayIndex++;\n        }\n\n        System.out.println(step + 1);\n\n    }\n\n}", "src": "\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.util.Scanner;\n\npublic class A1 {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n\n        long size = scan.nextLong();\n        int numberOfSpecial = scan.nextInt();\n        long pageSize = scan.nextLong();\n\n        long[] specialItemsArray = new long[numberOfSpecial];\n        for (int i = 0; i < numberOfSpecial; i++) {\n            specialItemsArray[i] = scan.nextLong();\n        }\n\n        int totalRemoved = 0;\n        int step = 0;\n\n        long currentPageIndex = BigDecimal.valueOf(specialItemsArray[0]).divide(BigDecimal.valueOf(pageSize),2, RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();\n        int specialItemArrayIndex = 1;\n\n        while (specialItemArrayIndex < numberOfSpecial) {\n            long pageIndex = BigDecimal.valueOf(specialItemsArray[specialItemArrayIndex] - totalRemoved).divide(BigDecimal.valueOf(pageSize),2,RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();\n            if (currentPageIndex != pageIndex) {\n                step++;\n                totalRemoved = specialItemArrayIndex;\n                currentPageIndex =  BigDecimal.valueOf(specialItemsArray[specialItemArrayIndex] - totalRemoved).divide(BigDecimal.valueOf(pageSize),2,RoundingMode.UP).setScale(0, RoundingMode.CEILING).longValue();\n            }\n            specialItemArrayIndex++;\n        }\n\n\n        System.out.println(step + 1);\n\n    }\n\n}\n", "index": 186, "complexity": 3}
{"back-translation": "class GFG { static boolean isInorder(int[] arr, int n) { if (n == 0 || n == 1) { return true; } for (int i = 1; i < n; i++) { if (arr[i - 1] > arr[i]) { return false; } } return true; } public static void main(String[] args) { int arr[] = {19, 23, 25, 30, 45}; int n = arr.length; if (isInorder(arr, n)) { System.out.println(\"Yes\"); } else { System.out.println(\"Non\"); } } } ", "src": "\n// Java program to check if a given array is sorted \n// or not. \n\nclass\nGFG { \n\n// Function that returns true if array is Inorder \n// traversal of any Binary Search Tree or not. \n\nstatic\nboolean\nisInorder(\nint\n[] arr, \nint\nn) { \n\n// Array has one or no element \n\nif\n(n == \n0\n|| n == \n1\n) { \n\nreturn\ntrue\n; \n\n} \n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n// Unsorted pair found \n\n{ \n\nif\n(arr[i - \n1\n] > arr[i]) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n// No unsorted pair found \n\nreturn\ntrue\n; \n\n} \n// Drivers code \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n19\n, \n23\n, \n25\n, \n30\n, \n45\n}; \n\nint\nn = arr.length; \n\nif\n(isInorder(arr, n)) { \n\nSystem.out.println(\n\"Yes\"\n); \n\n} \nelse\n{ \n\nSystem.out.println(\n\"Non\"\n); \n\n} \n\n} \n} \n//This code is contributed by 29AjayKumar ", "index": 188, "complexity": 3}
{"back-translation": "import java.util.HashMap;\n\nclass GFG {\n\n    static void printMinIndexChar(String str, String patt) {\n        HashMap<Character, Integer> hm = new HashMap<>();\n        int minIndex = Integer.MAX_VALUE;\n        int m = str.length();\n        int n = patt.length();\n        for(int i = 0; i < m; i++)\n            if(!hm.containsKey(str.charAt(i)))\n                hm.put(str.charAt(i),i);\n        for(int i = 0; i < n; i++)\n            if(hm.containsKey(patt.charAt(i)) && hm.get(patt.charAt(i)) < minIndex)\n                minIndex = hm.get(patt.charAt(i));\n        if(minIndex != Integer.MAX_VALUE)\n            System.out.println(\"Minimum Index Character = \" + str.charAt(minIndex));\n        else\n            System.out.println(\"No character present\");\n    }\n\n    public static void main(String[] args) {\n        String str = \"geeksforgeeks\";\n        String patt = \"set\";\n        printMinIndexChar(str, patt);\n    }\n}", "src": "\n// Java implementation to find the character in \n// first string that is present at minimum index \n// in second string \n\nimport\njava.util.HashMap; \n\npublic\nclass\nGFG \n{ \n\n// method to find the minimum index character \n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n// map to store the first index of each character of 'str' \n\nHashMap<Character, Integer> hm = \nnew\nHashMap<>(); \n\n\n// to store the index of character having \n\n// minimum index \n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n// lengths of the two strings \n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n// store the first index of each character of 'str' \n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(!hm.containsKey(str.charAt(i))) \n\nhm.put(str.charAt(i),i); \n\n\n// traverse the string 'patt' \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n// if patt[i] is found in 'um', check if \n\n// it has the minimum index or not accordingly \n\n// update 'minIndex' \n\nif\n(hm.containsKey(patt.charAt(i)) && \n\nhm.get(patt.charAt(i)) < minIndex) \n\nminIndex = hm.get(patt.charAt(i)); \n\n\n// print the minimum index character \n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n// if no character of 'patt' is present in 'str' \n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n// Driver Method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n} ", "index": 189, "complexity": 3}
{"back-translation": "public class Main {\n\nstatic class Node {\nint data;\nNode left, right;\n\nNode(int item) {\nthis.data = item;\nthis.left = this.right = null;\n}\n}\n\nstatic class BinaryTree {\nNode root;\n\nvoid reverseLevelOrder(Node node) {\nStack<Node> S = new Stack<>();\nQueue<Node> Q = new LinkedList<>();\nQ.add(node);\nwhile (!Q.isEmpty()) {\nnode = Q.peek();\nQ.remove();\nS.push(node);\nif (node.right != null)\nQ.add(node.right);\nif (node.left != null)\nQ.add(node.left);\n}\nwhile (!S.empty()) {\nnode = S.peek();\nSystem.out.print(node.data + \" \");\nS.pop();\n}\n}\n\npublic static void main(String args[]) {\nBinaryTree tree = new BinaryTree();\ntree.root = new Node(1);\ntree.root.left = new Node(2);\ntree.root.right = new Node(3);\ntree.root.left.left = new Node(4);\ntree.root.left.right = new Node(5);\ntree.root.right.left = new Node(6);\ntree.root.right.right = new Node(7);\nSystem.out.println(\"Level Order traversal of binary tree is :\");\ntree.reverseLevelOrder(tree.root);\n}\n}", "src": "\n// A recursive java program to print reverse level order traversal \n// using stack and queue \n\nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \nimport\njava.util.Stack; \n\n/* A binary tree node has data, pointer to left and right children */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* Given a binary tree, print its nodes in reverse level order */\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack(); \n\nQueue<Node> Q = \nnew\nLinkedList(); \n\nQ.add(node); \n\n\n// Do something like normal level order traversal order.Following \n\n// are the differences with normal level order traversal \n\n// 1) Instead of printing a node, we push the node to stack \n\n// 2) Right subtree is visited before left subtree \n\nwhile\n(Q.isEmpty() == \nfalse\n) \n\n{ \n\n/* Dequeue node and make it root */\n\nnode = Q.peek(); \n\nQ.remove(); \n\nS.push(node); \n\n\n/* Enqueue right child */\n\nif\n(node.right != \nnull\n) \n\n// NOTE: RIGHT CHILD IS ENQUEUED BEFORE LEFT \n\nQ.add(node.right); \n\n\n/* Enqueue left child */\n\nif\n(node.left != \nnull\n) \n\nQ.add(node.left); \n\n} \n\n\n// Now pop all items from stack one by one and print them \n\nwhile\n(S.empty() == \nfalse\n) \n\n{ \n\nnode = S.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nS.pop(); \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n// Let us create trees shown in above diagram \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is :\"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 190, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class AnnoyingPresent {\n\n\t//UPSOLVED\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n        long n = Long.parseLong(st.nextToken()) , m = Long.parseLong(st.nextToken());\n        \n        long sum = 0;\n        \n        for(int i=0;i<m;i++){\n        \tStringTokenizer st1 = new StringTokenizer(br.readLine());\n            sum+= n* Long.parseLong(st1.nextToken());\n            Long a= Long.parseLong(st1.nextToken());\n            if(a < 0){\n                if(n % 2 == 0)\n                    sum += n*n / 4*a;\n                else{\n                    sum += (n/2) * (n/2+1) * a;\n                }\n            }\n            else\n                sum += (a*(n) * (n-1) / 2);\n            \n        }\n        System.out.println((double)sum/n);\n\t}\n\n}\n", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class AnnoyingPresent {\n\n\t\n\t//UPSOLVED\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n        long n = Long.parseLong(st.nextToken()) , m = Long.parseLong(st.nextToken());\n        \n        long sum = 0;\n        \n        for(int i=0;i<m;i++){\n        \tStringTokenizer st1 = new StringTokenizer(br.readLine());\n            sum+= n* Long.parseLong(st1.nextToken());\n            Long a= Long.parseLong(st1.nextToken());\n            if(a < 0){\n                if(n % 2 == 0)\n                    sum += n*n / 4*a;\n                else{\n                    sum += (n/2) * (n/2+1) * a;\n                }\n            }\n            else\n                sum += (a*(n) * (n-1) / 2);\n            \n        }\n        System.out.println((double)sum/n);\n\t}\n\n}\n", "index": 191, "complexity": 3}
{"back-translation": "class ReverseArray { static void rvereseArray(int arr[], int start, int end) { int temp; if (start >= end) return; temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; rvereseArray(arr, start+1, end-1); } static void printArray(int arr[], int size) { for (int i=0; i < size; i++) System.out.print(arr[i] + ", "src": "\n// Recursive Java Program to reverse an array \nimport\njava.io.*; \n\nclass\nReverseArray { \n\n\n/* Function to reverse arr[] from start to end*/\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n\n{ \n\nint\ntemp; \n\nif\n(start >= end) \n\nreturn\n; \n\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nrvereseArray(arr, start+\n1\n, end-\n1\n); \n\n} \n\n\n/* Utility that prints out an array on a line */\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n/*Driver function to check for above functions*/\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nprintArray(arr, \n6\n); \n\nrvereseArray(arr, \n0\n, \n5\n); \n\nSystem.out.println(\n\"Reversed array is \"\n); \n\nprintArray(arr, \n6\n); \n\n} \n} \n/*This article is contributed by Devesh Agrawal*/", "index": 192, "complexity": 3}
{"back-translation": "public class GFG { static final int MAX_CHAR = 26; static int countSubstringWithEqualEnds(String s) { int result = 0; int n = s.length(); int[] count = new int[MAX_CHAR]; for (int i = 0; i < n; i++) count[s.charAt(i)- 'a']++; for (int i = 0; i < MAX_CHAR; i++) result += (count[i] * (count[i] + 1) / 2); return result; } public static void main(String args[]) { String s = \"abcab\"; System.out.println(countSubstringWithEqualEnds(s)); } }", "src": "\n// Most efficient Java program to count all \n// substrings with same first and last characters. \npublic\nclass\nGFG { \n\n\n// assuming lower case only \n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n// Calculating frequency of each character \n\n// in the string. \n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[s.charAt(i)-\n'a'\n]++; \n\n\n// Computing result using counts \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nresult += (count[i] * (count[i] + \n1\n) / \n2\n); \n\n\nreturn\nresult; \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "index": 194, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class GenerateLogin {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString a = scan.next();\n\t\tString b = scan.next();\n\t\tchar last = b.charAt(0);\n\t\tString ans = \"\" + a.charAt(0);\n\t\tint i = 1;\n\t\twhile (i < a.length()) {\n\t\t\tif (a.charAt(i) >= last) break;\n\t\t\tans += a.charAt(i);\n\t\t\ti++;\n\t\t}\n\t\tans += last;\n\t\tSystem.out.println(ans);\n\t}\n\n}\n", "src": "import java.util.Scanner;\n\npublic class GenerateLogin {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString a = scan.next();\n\t\tString b = scan.next();\n\t\tchar last = b.charAt(0);\n\t\tString ans = \"\"+a.charAt(0);\n\t\tfor(int i = 1;i<a.length();i++){\n\t\t\tif(a.charAt(i)>=last)break;\n\t\t\tans+=a.charAt(i);\n\t\t}\n\t\tans+=last;\n\t\tSystem.out.println(ans);\n\t}\n\n}\n", "index": 195, "complexity": 3}
{"back-translation": "boolean existPath(Node root, int[] arr, int index) { if (root == null) { return arr.length == 0; } if ((root.left == null && root.right == null) && (root.data == arr[index] && root.data == arr[arr.length - 1])) { return true; } return (index < arr.length && (root.data == arr[index] && (existPath(root.left, arr, index + 1) || existPath(root.right, arr, index + 1)))); } public static void main(String args[]) { int arr[] = {5, 8, 6, 7}; Node root = new Node(5); root.left = new Node(3); root.right = new Node(8); root.left.left = new Node(2); root.left.right = new Node(4); root.left.left.left = new Node(1); root.right.left = new Node(6); root.right.left.right = new Node(7); if (existPath(root, arr, 0)) { System.out.print(\"Path Exists\"); } else { System.out.print(\"Path does not Exist\"); } } class Node { int data; Node left, right; Node(int data) { this.data = data; left = right = null; } }; }", "src": "\n// Java program to see if there is a root to leaf path \n// with given sequence. \npublic\nclass\nCheckForPath { \n\n\n// function to check given sequence of root to leaf path exist \n\n// in tree or not. \n\n// index represents current element in sequence of rooth to \n\n// leaf path \n\npublic\nstatic\nboolean\nexistPath(Node root, \nint\narr[], \nint\nindex) \n\n{ \n\n// If root is NULL, then there must not be any element \n\n// in array. \n\nif\n(root==\nnull\n) \n\n{ \n\nreturn\narr.length==\n0\n; \n\n} \n\n\n// If this node is a leaf and matches with last entry \n\n// of array. \n\nif\n((root.left==\nnull\n&& root.right==\nnull\n) && (root.data==arr[index] \n\n&& root.data==arr[arr.length-\n1\n])) \n\n{ \n\nreturn\ntrue\n; \n\n} \n\n\n// If current node is equal to arr[index] this means \n\n// that till this level path has been matched and \n\n// remaining path can be either in left subtree or \n\n// right subtree. \n\nreturn\n(index<arr.length && (root.data==arr[index] && \n\n(existPath(root.left,arr,index+\n1\n) || \n\nexistPath(root.right, arr, index+\n1\n)))); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\n// arr[] is sequence of root to leaf path \n\nint\narr[] = {\n5\n, \n8\n, \n6\n, \n7\n}; \n\nNode root=\nnew\nNode(\n5\n); \n\nroot.left=\nnew\nNode(\n3\n); \n\nroot.right=\nnew\nNode(\n8\n); \n\nroot.left.left = \nnew\nNode(\n2\n); \n\nroot.left.right = \nnew\nNode(\n4\n); \n\nroot.left.left.left = \nnew\nNode(\n1\n); \n\nroot.right.left = \nnew\nNode(\n6\n); \n\nroot.right.left.right = \nnew\nNode(\n7\n); \n\n\nif\n(existPath(root, arr, \n0\n)) \n\n{ \n\nSystem.out.print(\n\"Path Exists\"\n); \n\n} \n\nelse\n\n{ \n\nSystem.out.print(\n\"Path does not Exist\"\n); \n\n} \n\n} \n} \n\n/* A binary tree node has data, pointer to left child \nand a pointer to right child */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\nleft=right=\nnull\n; \n\n} \n}; \n\n// This code is contributed by Gaurav Tiwari ", "index": 196, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\nclass GFG {\n\npublic static void main(String args[]) {\nint[] arr = {10, 7, 9, 2, 8, 3, 5, 4, 6, 1};\nint n = arr.length;\n\nfor (int i = 0; i < n; i++) {\narr[i] = i + 1;\n}\n\nfor (int i = 0; i < n; i++)\nSystem.out.print(arr[i] + \" \");\n}\n}", "src": "\n// Efficient Java program to sort an \n// array of numbers in range from 1 \n// to n. \nimport\njava.io.*; \nimport\njava.util.*; \n\npublic\nclass\nGFG { \n\n\n\n// function for sort array \n\nstatic\nvoid\nsortit(\nint\n[]arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i]=i+\n1\n; \n\n\n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n7\n, \n9\n, \n2\n, \n8\n, \n\n3\n, \n5\n, \n4\n, \n6\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n// for sort an array \n\nsortit(arr, n); \n\n\n// for print all the \n\n// element in sorted way \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} \n\n// This code is contributed by Manish Shaw \n// (manishshaw1) ", "index": 197, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\npublic class alex\n{\n    public static void main(String[] args)throws IOException\n    {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int sum=1;\n        int i=1;\n        while (i<=n)\n        {\n            sum=sum+(4*(i-1));\n            i++;\n        }\n        System.out.println(sum);\n    }\n}", "src": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\npublic class alex\n{\n    public static void main(String[] args)throws IOException\n    {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();int sum=1;\n        for(int i=1;i<=n;i++)\n        {\n            sum=sum+(4*(i-1));\n        }\n        System.out.println(sum);\n    }\n}", "index": 198, "complexity": 3}
{"back-translation": "class MinimumDistance {\n\n    int minDist(int arr[], int n, int x, int y) {\n        int i = 0;\n        int min_dist = Integer.MAX_VALUE;\n        int prev = 0;\n        for (i = 0; i < n; i++) {\n            if (arr[i] == x || arr[i] == y) {\n                prev = i;\n                break;\n            }\n        }\n        for (; i < n; i++) {\n            if (arr[i] == x || arr[i] == y) {\n                if (arr[prev] != arr[i] && (i - prev) < min_dist) {\n                    min_dist = i - prev;\n                    prev = i;\n                } else\n                    prev = i;\n            }\n        }\n        return min_dist;\n    }\n\n    public static void main(String[] args) {\n        MinimumDistance min = new MinimumDistance();\n        int arr[] = { 3, 5, 4, 2, 6, 3, 0, 0, 5, 4, 8, 3 };\n        int n = arr.length;\n        int x = 3;\n        int y = 6;\n        System.out.println(\"Minimum distance between \" + x + \" and \" + y + \" is \" + min.minDist(arr, n, x, y));\n    }\n}", "src": "\nclass\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni = \n0\n; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nint\nprev=\n0\n; \n\n\n// Find the first occurence of any of the two numbers (x or y) \n\n// and store the index of this occurence in prev \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\nprev = i; \n\nbreak\n; \n\n} \n\n} \n\n\n// Traverse after the first occurence \n\nfor\n(; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\n// If the current element matches with any of the two then \n\n// check if current element and prev element are different \n\n// Also check if this value is smaller than minimum distance \n\n// so far \n\nif\n(arr[prev] != arr[i] && (i - prev) < min_dist) \n\n{ \n\nmin_dist = i - prev; \n\nprev = i; \n\n} \n\nelse\n\nprev = i; \n\n} \n\n} \n\n\nreturn\nmin_dist; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n3\n, \n0\n, \n0\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n} ", "index": 199, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class codef8 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint[] beacon = new int[1000001];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tbeacon[sc.nextInt()] = sc.nextInt();\n\t\t}\n\t\tint[] dp = new int[1000001];\n\t\tint max = 1;\n\t\tif (beacon[0] > 0) {\n\t\t\tdp[0] = 1;\n\t\t}\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i - 1];\n\t\t\t} else {\n\t\t\t\tint b = beacon[i];\n\t\t\t\tif (i <= b) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i] = dp[i - b - 1] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\n\t\tSystem.out.println(num - max);\n\t\tsc.close();\n\t}\n\n}", "src": "import java.util.Scanner;\n\npublic class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint beacon[] = new int[1000001];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tbeacon[sc.nextInt()] = sc.nextInt();\n\t\t}\n\t\tint dp[] = new int[1000001];\n\t\tint max = 1;\n\t\tif (beacon[0] > 0) {\n\t\t\tdp[0] = 1;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} \n\t\t\telse {\n\t\t\t\tint b = beacon[i];\n\t\t\t\tif (i <= b) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = dp[i-b-1] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\t\t\n\t\tSystem.out.println(num-max);\n\t\tsc.close();\n\t}\n\n}\n", "index": 200, "complexity": 3}
{"back-translation": "class GfG { static class Node { int key; Node left, right; } static int findADepth(Node node) { int d = 0; while (node != null) { d++; node = node.left; } return d; } static boolean isPerfectRec(Node root, int d, int level) { if (root == null) return true; if (root.left == null && root.right == null) return (d == level+1); if (root.left == null || root.right == null) return false; return isPerfectRec(root.left, d, level+1) && isPerfectRec(root.right, d, level+1); } static boolean isPerfect(Node root) { int d = findADepth(root); return isPerfectRec(root, d, 0); } static Node newNode(int k) { Node node = new Node(); node.key = k; node.right = null; node.left = null; return node; } public static void main(String args[]) { Node root = null; root = newNode(10); root.left = newNode(20); root.right = newNode(30); root.left.left = newNode(40); root.left.right = newNode(50); root.right.left = newNode(60); root.right.right = newNode(70); if (isPerfect(root) == true) System.out.println(\"Yes\"); else System.out.println(\"No\"); } }", "src": "\n// Java program to check whether a given \n// Binary Tree is Perfect or not \nclass\nGfG { \n\n/* Tree node structure */\nstatic\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n} \n\n// Returns depth of leftmost leaf. \nstatic\nint\nfindADepth(Node node) \n{ \nint\nd = \n0\n; \nwhile\n(node != \nnull\n) \n{ \n\nd++; \n\nnode = node.left; \n} \nreturn\nd; \n} \n\n/* This function tests if a binary tree is perfect \nor not. It basically checks for two things : \n1) All leaves are at same level \n2) All internal nodes have two children */\nstatic\nboolean\nisPerfectRec(Node root, \nint\nd, \nint\nlevel) \n{ \n\n// An empty tree is perfect \n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// If leaf node, then its depth must be same as \n\n// depth of all other leaves. \n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\n(d == level+\n1\n); \n\n\n// If internal node and one child is empty \n\nif\n(root.left == \nnull\n|| root.right == \nnull\n) \n\nreturn\nfalse\n; \n\n\n// Left and right subtrees must be perfect. \n\nreturn\nisPerfectRec(root.left, d, level+\n1\n) && isPerfectRec(root.right, d, level+\n1\n); \n} \n\n// Wrapper over isPerfectRec() \nstatic\nboolean\nisPerfect(Node root) \n{ \nint\nd = findADepth(root); \nreturn\nisPerfectRec(root, d, \n0\n); \n} \n\n/* Helper function that allocates a new node with the \ngiven key and NULL left and right pointer. */\nstatic\nNode newNode(\nint\nk) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.key = k; \n\nnode.right = \nnull\n; \n\nnode.left = \nnull\n; \n\nreturn\nnode; \n} \n\n// Driver Program \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = \nnull\n; \n\nroot = newNode(\n10\n); \n\nroot.left = newNode(\n20\n); \n\nroot.right = newNode(\n30\n); \n\n\nroot.left.left = newNode(\n40\n); \n\nroot.left.right = newNode(\n50\n); \n\nroot.right.left = newNode(\n60\n); \n\nroot.right.right = newNode(\n70\n); \n\n\nif\n(isPerfect(root) == \ntrue\n) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n} \n} ", "index": 201, "complexity": 3}
{"back-translation": "import java.io.OutputStream;import java.io.PrintWriter;import java.io.InputStream;import java.util.StringTokenizer;import java.io.Writer;import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.util.StringTokenizer;import java.io.InputStream; public class Main{ public static void main(String[] args){ InputStream inputStream = System.in; OutputStream outputStream = System.out; FastScanner in = new FastScanner(inputStream); FastPrinter out = new FastPrinter(outputStream); TaskC solver = new TaskC(); solver.solve(1, in, out); out.close(); } static class TaskC{ public void solve(int testNumber, FastScanner in, FastPrinter out){ int n = in.nextInt(); long[] a = new long[n]; long[] b = new long[n]; for(int i = 0;i < n;i++){ b[i] = (a[i] = in.nextInt()); if(i > 0){ a[i] += a[i - 1]; } } for(int i = n - 2;i >= 0;i--){ b[i] += b[i + 1]; } long sum1 = 0; long sum3 = 0; long result = 0; for(int i = 0,j = n - 1;i < j;){ sum1 = a[i]; sum3 = b[j]; if(sum1 == sum3){ result = Math.max(result, sum1); i++; j--; } else if(sum1 < sum3){ i++; } else{ j--; } } out.println(result); } } static class FastScanner{ public BufferedReader br; public StringTokenizer st; public FastScanner(InputStream is){ br = new BufferedReader(new InputStreamReader(is)); } public FastScanner(File f){ try{ br = new BufferedReader(new FileReader(f)); }catch(FileNotFoundException e){ e.printStackTrace(); } } public String next(){ while(st == null || !st.hasMoreElements()){ String s = null; try{ s = br.readLine(); }catch(IOException e){ e.printStackTrace(); } if(s == null){ return null; } st = new StringTokenizer(s); } return st.nextToken(); } public int nextInt(){ return Integer.parseInt(next()); } } static class FastPrinter extends PrintWriter{ public FastPrinter(OutputStream out){ super(out); } public FastPrinter(Writer out){ super(out); } } }", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author zodiacLeo\n */\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskC\n    {\n        public void solve(int testNumber, FastScanner in, FastPrinter out)\n        {\n            int n = in.nextInt();\n            long[] a = new long[n];\n            long[] b = new long[n];\n            for (int i = 0; i < n; i++)\n            {\n                b[i] = a[i] = in.nextInt();\n                if (i > 0)\n                {\n                    a[i] += a[i - 1];\n                }\n            }\n            for (int i = n - 2; i >= 0; i--)\n            {\n                b[i] += b[i + 1];\n            }\n            \n            long sum1 = 0;\n            long sum3 = 0;\n            long result = 0;\n            for (int i = 0, j = n - 1; i < j; )\n            {\n                sum1 = a[i];\n                sum3 = b[j];\n                if (sum1 == sum3)\n                {\n                    result = Math.max(result, sum1);\n                    i++;\n                    j--;\n                }\n                else if (sum1 < sum3)\n                {\n                    i++;\n                }\n                else\n                {\n                    j--;\n                }\n            }\n            out.println(result);\n            \n            \n        }\n        \n    }\n    \n    static class FastScanner\n    {\n        public BufferedReader br;\n        public StringTokenizer st;\n        \n        public FastScanner(InputStream is)\n        {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n        \n        public FastScanner(File f)\n        {\n            try\n            {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        \n        public String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                String s = null;\n                try\n                {\n                    s = br.readLine();\n                } catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                {\n                    return null;\n                }\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        \n    }\n    \n    static class FastPrinter extends PrintWriter\n    {\n        public FastPrinter(OutputStream out)\n        {\n            super(out);\n        }\n        \n        public FastPrinter(Writer out)\n        {\n            super(out);\n        }\n        \n    }\n}\n\n", "index": 202, "complexity": 3}
{"back-translation": "class GFG { static int countFriendsPairings(int n) { int dp[] = new int[n + 1]; for (int i = 0; i <= n; i++) { if (i <= 2) dp[i] = i; else dp[i] = dp[i - 1] + (i - 1) * dp[i - 2]; } return dp[n]; } public static void main(String[] args) { int n = 4; System.out.println(countFriendsPairings(n)); } }", "src": "\n// Java program for solution of \n// friends pairing problem \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Returns count of ways n people \n\n// can remain single or paired up. \n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n + \n1\n]; \n\n\n// Filling dp[] in bottom-up manner using \n\n// recursive formula explained above. \n\nfor\n(\nint\ni = \n0\n; i <= n; i++) { \n\nif\n(i <= \n2\n) \n\ndp[i] = i; \n\nelse\n\ndp[i] = dp[i - \n1\n] + (i - \n1\n) * dp[i - \n2\n]; \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n} \n\n// This code is contributed by vt_m ", "index": 203, "complexity": 3}
{"back-translation": "class GFG { public static int maxSum(int[][] grid, int n) { int incl = Math.max(grid[0][0], grid[1][0]); int excl = 0, excl_new; for (int i = 1; i < n; i++) { excl_new = Math.max(excl, incl); incl = excl + Math.max(grid[0][i], grid[1][i]); excl = excl_new; } return Math.max(excl, incl); } public static void main(String[] args) { int grid[][] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}}; int n = 5; System.out.println(maxSum(grid, n)); } }", "src": "\n// Java Code for Maximum sum in a 2 x n grid \n// such that no two elements are adjacent \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Function to find max sum without adjacent \n\npublic\nstatic\nint\nmaxSum(\nint\ngrid[][], \nint\nn) \n\n{ \n\n// Sum including maximum element of first \n\n// column \n\nint\nincl = Math.max(grid[\n0\n][\n0\n], grid[\n1\n][\n0\n]); \n\n\n// Not including first column's element \n\nint\nexcl = \n0\n, excl_new; \n\n\n// Traverse for further elements \n\nfor\n(\nint\ni = \n1\n; i < n; i++ ) \n\n{ \n\n// Update max_sum on including or \n\n// excluding of previous column \n\nexcl_new = Math.max(excl, incl); \n\n\n// Include current column. Add maximum element \n\n// from both row of current column \n\nincl = excl + Math.max(grid[\n0\n][i], grid[\n1\n][i]); \n\n\n// If current column doesn't to be included \n\nexcl = excl_new; \n\n} \n\n\n// Return maximum of excl and incl \n\n// As that will be the maximum sum \n\nreturn\nMath.max(excl, incl); \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ngrid[][] = {{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n}, \n\n{ \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}}; \n\n\nint\nn = \n5\n; \n\nSystem.out.println(maxSum(grid, n)); \n\n} \n\n} \n// This code is contributed by Arnav Kr. Mandal. ", "index": 205, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint tmp;\n\t\tint min=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ttmp=sc.nextInt();\n\t\t\tif(i>n-1-i) {\n\t\t\t\ttmp=tmp/i;\n\t\t\t} else {\n\t\t\t\ttmp=tmp/(n-1-i);\n\t\t\t}\n\t\t\tif(tmp<min) {\n\t\t\t\tmin=tmp;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "src": "\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint tmp;\n\t\tint min=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ttmp=sc.nextInt();\n\t\t\tif(i>n-1-i) {\n\t\t\t\ttmp=tmp/i;\n\t\t\t}else {\n\t\t\t\ttmp=tmp/(n-1-i);\n\t\t\t}\n\t\t\tif(tmp<min) {\n\t\t\t\tmin=tmp;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}\n", "index": 207, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner in = new Scanner(System.in);\n\t\tString str = in.next();\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < str.length(); ++i) {\n\t\t\tif (str.charAt(i) == '1') {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tint i = 0;\n\t\twhile (i < str.length()) {\n\t\t\tif (str.charAt(i) == '0') {\n\t\t\t\tSystem.out.print(\"0\");\n\t\t\t} else if (str.charAt(i) == '2') {\n\t\t\t\twhile (cnt-- > 0) {\n\t\t\t\t\tSystem.out.print(\"1\");\n\t\t\t\t}\n\t\t\t\tSystem.out.print(\"2\");\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\twhile (cnt-- > 0) {\n\t\t\tSystem.out.print(\"1\");\n\t\t}\n\t\tin.close();\n\t}\n}", "src": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner in=new Scanner(System.in);\n\t\tString str=in.next();\n\t\tint cnt=0;\n\t\tfor(int i=0;i<str.length();++i) {\n\t\t\tif(str.charAt(i)=='1') {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tint i=0;\n\t\tfor(;i<str.length();++i) {\n\t\t\tif(str.charAt(i)=='0') {\n\t\t\t\tSystem.out.print(\"0\");\n\t\t\t}\n\t\t\telse if(str.charAt(i)=='2') {\n\t\t\t\twhile(cnt-->0) {//\n\t\t\t\t\tSystem.out.print(\"1\");\n\t\t\t\t}\n\t\t\t\tSystem.out.print(\"2\");\n\t\t\t}\n\t\t}\n\t\twhile(cnt-->0) {\n\t\t\tSystem.out.print(\"1\");\n\t\t}\n\t\tin.close();\n\t}\n}", "index": 208, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.io.*;\nimport java.util.*;\n \n \n \npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint n = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tif(n % 2 == 0) {\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint maxi = -1, max = -1;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tint x = a[i] >= 0 ? -a[i] - 1 : a[i];\n\t\t\t\tx = -x;\n\t\t\t\tif(x > max) {\n\t\t\t\t\tmax = x; maxi = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max == 1) {\n\t\t\t\ta[0] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\t\tif(i == maxi) {\n\t\t\t\t\t\tif(a[i] < 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int x : a)\n\t\t\tSystem.out.print(x + \" \");\n\t\t\n\t\tout.close();\n\t}\n\t\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "index": 209, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int best = 1;\n        int bestTime = Integer.MAX_VALUE;\n        for(int i=0;i<n;i++) {\n            int time;\n            int a = sc.nextInt();\n            time = (a % n == 0 || a % n <= i) ? a / n : (a + n) / n;\n            if (time < bestTime) {\n                best = i + 1;\n                bestTime = time;\n            }\n        }\n\n        pw.println(best);\n        pw.close();\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int best = 1;\n        int bestTime = Integer.MAX_VALUE;\n        for(int i=0;i<n;i++) {\n            int time;\n            int a = sc.nextInt();\n            time = (a%n==0 || a%n<=i) ? a/n : (a+n)/n;\n            if(time < bestTime) {\n                best = i + 1;\n                bestTime = time;\n            }\n        }\n\n        pw.println(best);\n        pw.close();\n    }\n}\n", "index": 210, "complexity": 3}
{"back-translation": "class Node { int data; Node left, right; Node(int item) { data = item; left = right = null; } } class BinaryTree { Node root1, root2; boolean identicalTrees(Node a, Node b) { if (a == null && b == null) return true; if (a != null && b != null) return (a.data == b.data && identicalTrees(a.left, b.left) && identicalTrees(a.right, b.right)); return false; } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root1 = new Node(1); tree.root1.left = new Node(2); tree.root1.right = new Node(3); tree.root1.left.left = new Node(4); tree.root1.left.right = new Node(5); tree.root2 = new Node(1); tree.root2.left = new Node(2); tree.root2.right = new Node(3); tree.root2.left.left = new Node(4); tree.root2.left.right = new Node(5); if (tree.identicalTrees(tree.root1, tree.root2)) System.out.println(\"Both trees are identical\"); else System.out.println(\"Trees are not identical\"); } }", "src": "\n// Java program to see if two trees are identical \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root1, root2; \n\n\n/* Given two trees, return true if they are \n\nstructurally identical */\n\nboolean\nidenticalTrees(Node a, Node b) \n\n{ \n\n/*1. both empty */\n\nif\n(a == \nnull\n&& b == \nnull\n) \n\nreturn\ntrue\n; \n\n\n/* 2. both non-empty -> compare them */\n\nif\n(a != \nnull\n&& b != \nnull\n) \n\nreturn\n(a.data == b.data \n\n&& identicalTrees(a.left, b.left) \n\n&& identicalTrees(a.right, b.right)); \n\n\n/* 3. one empty, one not -> false */\n\nreturn\nfalse\n; \n\n} \n\n\n/* Driver program to test identicalTrees() function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\ntree.root1 = \nnew\nNode(\n1\n); \n\ntree.root1.left = \nnew\nNode(\n2\n); \n\ntree.root1.right = \nnew\nNode(\n3\n); \n\ntree.root1.left.left = \nnew\nNode(\n4\n); \n\ntree.root1.left.right = \nnew\nNode(\n5\n); \n\n\ntree.root2 = \nnew\nNode(\n1\n); \n\ntree.root2.left = \nnew\nNode(\n2\n); \n\ntree.root2.right = \nnew\nNode(\n3\n); \n\ntree.root2.left.left = \nnew\nNode(\n4\n); \n\ntree.root2.left.right = \nnew\nNode(\n5\n); \n\n\nif\n(tree.identicalTrees(tree.root1, tree.root2)) \n\nSystem.out.println(\n\"Both trees are identical\"\n); \n\nelse\n\nSystem.out.println(\n\"Trees are not identical\"\n); \n\n\n} \n} ", "index": 211, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\n/* spar5h */\n\npublic class cf1 implements Runnable{    \n\t\n\tpublic void run() {\n\n\t\tInputReader s = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\t\n\t\tint t = 1;\n\t\t\n\t\twhile(t-- > 0) {\n\t\t\t\n\t\t\tint n = s.nextInt(), m = s.nextInt();\n\t\t\t\n\t\t\tint[] a = new int[n + 1];\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t\ta[i] = s.nextInt();\n\t\t\t\n\t\t\tint[] b = new int[n + 1];\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t\tb[i] = s.nextInt();\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\t\n\t\t\tlist.add(a[1]);\n\t\t\t\n\t\t\tfor(int i = 2; i <= n; i++) {\n\t\t\t\tlist.add(b[i]); list.add(a[i]);\n\t\t\t}\n\t\t\t\n\t\t\tlist.add(b[1]);\n\t\t\t\n\t\t\tdouble wt = m;\n\t\t\tboolean check = true;\n\t\t\t\n\t\t\tfor(int i = list.size() - 1; i >= 0; i--) {\n\t\t\t\t\n\t\t\t\tif(list.get(i) <= 1) {\n\t\t\t\t\tcheck = false; break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdouble x = wt / (list.get(i) - 1);\n\t\t\t\t\t\t\n\t\t\t\twt += x;\n\t\t\t}\n\t\t\t\n\t\t\tif(check)\n\t\t\t\tw.println(wt - m);\n\t\t\telse\n\t\t\t\tw.println(-1);\n\t\t}\n\t\t\n\t\tw.close();\n\t}\n\t\n\tstatic class InputReader {\n\t\t\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\t\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars==-1) \n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t \n\t\tpublic String nextLine()\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n\t\t}\n\t\tpublic int nextInt()\n\t\t{\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile(isSpaceChar(c)) \n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\t\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t{\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') \n\t\t\t{\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\n\t\t\treturn res.toString();\n\t\t}\n\t \n\t\tpublic boolean isSpaceChar(int c) \n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t \n\t\tpublic String next() \n\t\t{\n\t\t\treturn readString();\n\t\t}\n\t\t\n\t\tpublic interface SpaceCharFilter \n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n    \n\tpublic static void main(String args[]) throws Exception\n\t{\n\t\tnew Thread(null, new cf1(),\"cf1\",1<<26).start();\n\t}\n}", "index": 212, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.IOException;\n\npublic class D909Back {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        char[] line = br.readLine().toCharArray();\n        int n = line.length;\n\n        int l = 0;\n        ArrayList<Node> groups = new ArrayList<>();\n        Node node = new Node(line[0], 1);\n        groups.add(node);\n        for (int i = 1; i < n; i++) {\n            if (line[i] == groups.get(l).letter) {\n                groups.get(l).count++;\n            } else {\n                node = new Node(line[i], 1);\n                groups.add(node);\n                l++;\n            }\n        }\n\n        int moves = 0;\n        ArrayList<Node> temp = new ArrayList<>();\n        while (groups.size() > 1) {\n            moves++;\n            l = groups.size();\n            groups.get(0).count--;\n            groups.get(l - 1).count--;\n            for (int i = 1; i < l - 1; i++) {\n                groups.get(i).count -= 2;\n            }\n\n            int p;\n            for (p = 0; p < l; p++) {\n                if (groups.get(p).count > 0) {\n                    temp.add(groups.get(p));\n                    break;\n                }\n            }\n            int lTemp = temp.size();\n            for (p++; p < l; p++) {\n                if (groups.get(p).count <= 0) {\n                    continue;\n                }\n                if (groups.get(p).letter == temp.get(lTemp - 1).letter) {\n                    temp.get(lTemp - 1).count += groups.get(p).count;\n                } else {\n                    temp.add(groups.get(p));\n                    lTemp++;\n                }\n            }\n\n            groups.clear();\n            groups.addAll(temp);\n            temp.clear();\n        }\n\n        System.out.println(moves);\n    }\n\n    private static class Node {\n        char letter;\n        int count;\n\n        Node(char letter, int count) {\n            this.letter = letter;\n            this.count = count;\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class D909 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        char[] line = br.readLine().toCharArray();\n        int n = line.length;\n\n        int l = 0;\n        ArrayList<Node> groups = new ArrayList<>();\n        Node node = new Node(line[0], 1);\n        groups.add(node);\n        for (int i = 1; i < n; i++) {\n            if (line[i] == groups.get(l).letter) {\n                groups.get(l).count++;\n            } else {\n                node = new Node(line[i], 1);\n                groups.add(node);\n                l++;\n            }\n        }\n\n        int moves = 0;\n        ArrayList<Node> temp = new ArrayList<>();\n        while (groups.size() > 1) {\n            moves++;\n\n            l = groups.size();\n            groups.get(0).count--;\n            groups.get(l - 1).count--;\n            for (int i = 1; i < l - 1; i++) {\n                groups.get(i).count -= 2;\n            }\n\n            int p;\n            for (p = 0; p < l; p++) {\n                if (groups.get(p).count > 0) {\n                    temp.add(groups.get(p));\n                    break;\n                }\n            }\n            int lTemp = temp.size();\n            for (p++; p < l; p++) {\n                if (groups.get(p).count <= 0) {\n                    continue;\n                }\n                if (groups.get(p).letter == temp.get(lTemp - 1).letter) {\n                    temp.get(lTemp - 1).count += groups.get(p).count;\n                } else {\n                    temp.add(groups.get(p));\n                    lTemp++;\n                }\n            }\n\n            groups.clear();\n            groups.addAll(temp);\n            temp.clear();\n        }\n\n        System.out.println(moves);\n    }\n\n    private static class Node {\n        char letter;\n        int count;\n\n        Node(char letter, int count) {\n            this.letter = letter;\n            this.count = count;\n        }\n    }\n}\n", "index": 213, "complexity": 3}
{"back-translation": "class Test { static int arr1[] = new int[]{0, 1, 0, 1, 1, 1, 1}; static int arr2[] = new int[]{1, 1, 1, 1, 1, 0, 1}; static int longestCommonSum(int n) { int maxLen = 0; int preSum1 = 0, preSum2 = 0; int diff[] = new int[2 * n + 1]; for (int i = 0; i < diff.length; i++) { diff[i] = -1; } for (int i = 0; i < n; i++) { preSum1 += arr1[i]; preSum2 += arr2[i]; int curr_diff = preSum1 - preSum2; int diffIndex = n + curr_diff; if (curr_diff == 0) maxLen = i + 1; else if (diff[diffIndex] == -1) diff[diffIndex] = i; else { int len = i - diff[diffIndex]; if (len > maxLen) maxLen = len; } } return maxLen; } public static void main(String[] args) { System.out.print(\"Length of the longest common span with same sum is \"); System.out.println(longestCommonSum(arr1.length)); } }", "src": "\n// A O(n) and O(n) extra space Java program to find \n// longest common subarray of two binary arrays with \n// same sum \n\nclass\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n0\n, \n1\n, \n0\n, \n1\n, \n1\n, \n1\n, \n1\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n1\n}; \n\n\n// Returns length of the longest common sum in arr1[] \n\n// and arr2[]. Both are of same size n. \n\nstatic\nint\nlongestCommonSum(\nint\nn) \n\n{ \n\n// Initialize result \n\nint\nmaxLen = \n0\n; \n\n\n// Initialize prefix sums of two arrays \n\nint\npreSum1 = \n0\n, preSum2 = \n0\n; \n\n\n// Create an array to store staring and ending \n\n// indexes of all possible diff values. diff[i] \n\n// would store starting and ending points for \n\n// difference \"i-n\" \n\nint\ndiff[] = \nnew\nint\n[\n2\n*n+\n1\n]; \n\n\n// Initialize all starting and ending values as -1. \n\nfor\n(\nint\ni = \n0\n; i < diff.length; i++) { \n\ndiff[i] = -\n1\n; \n\n} \n\n\n// Traverse both arrays \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n// Update prefix sums \n\npreSum1 += arr1[i]; \n\npreSum2 += arr2[i]; \n\n\n// Comput current diff and index to be used \n\n// in diff array. Note that diff can be negative \n\n// and can have minimum value as -1. \n\nint\ncurr_diff = preSum1 - preSum2; \n\nint\ndiffIndex = n + curr_diff; \n\n\n// If current diff is 0, then there are same number \n\n// of 1's so far in both arrays, i.e., (i+1) is \n\n// maximum length. \n\nif\n(curr_diff == \n0\n) \n\nmaxLen = i+\n1\n; \n\n\n// If current diff is seen first time, then update \n\n// starting index of diff. \n\nelse\nif\n( diff[diffIndex] == -\n1\n) \n\ndiff[diffIndex] = i; \n\n\n// Current diff is already seen \n\nelse\n\n{ \n\n// Find length of this same sum common span \n\nint\nlen = i - diff[diffIndex]; \n\n\n// Update max len if needed \n\nif\n(len > maxLen) \n\nmaxLen = len; \n\n} \n\n} \n\nreturn\nmaxLen; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print(\n\"Length of the longest common span with same sum is \"\n); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n} ", "index": 214, "complexity": 3}
{"back-translation": "public class TaskB implements Runnable { boolean prime[] = new boolean[(int)1e6+10]; InputReader c; PrintWriter w; public void run() { c = new InputReader(System.in); w = new PrintWriter(System.out); char a[] = c.next().toCharArray(), b[] = c.next().toCharArray(); int n = a.length, m = b.length; int[][] prefix = new int[m][2]; for(int i=0;i<m;i++){ if(i!=0) { prefix[i][0] = prefix[i-1][0]; prefix[i][1] = prefix[i-1][1]; } prefix[i][b[i] - '0']++; } long res = 0; for(int i=0;i<n;i++){ int temp = a[i] - '0'; res += prefix[m - n + i][temp^1]; if(i!=0) res -= prefix[i-1][temp^1]; } w.println(res); w.close(); } void sieveOfEratosthenes(int n) { for(int i=0;i<n;i++) prime[i] = true; for(int p = 2; p*p <=n; p++) { if(prime[p] == true) { for(int i = p*p; i <= n; i += p) prime[i] = false; } } } class pair implements Comparable<pair>{ char ch; int ind; @Override public String toString() { return \"pair{\" + \"ch=\" + ch + \", ind=\" + ind + '\n'; } public pair(char ch, int ind) { this.ch = ch; this.ind = ind; } public int compareTo(pair car) { if(this.ch==car.ch) return this.ind - car.ind; return this.ch - car.ch; } } public static void sortbyColumn(int arr[][], int col){ Arrays.sort(arr, new Comparator<int[]>() { public int compare(int[] o1, int[] o2){ return(Integer.valueOf(o1[col]).compareTo(o2[col])); } }); } static long gcd(long a, long b){ if (b == 0) return a; return gcd(b, a % b); } public static class DJSet { public int[] upper; public DJSet(int n) { upper = new int[n]; Arrays.fill(upper, -1); } public int root(int x) { return upper[x] < 0 ? x : (upper[x] = root(upper[x])); } public boolean equiv(int x, int y) { return root(x) == root(y); } public boolean union(int x, int y) { x = root(x); y = root(y); if (x != y) { if (upper[y] < upper[x]) { int d = x; x = y; y = d; } upper[x] += upper[y]; upper[y] = x; } return x == y; } } public static int[] radixSort(int[] f) { int[] to = new int[f.length]; { int[] b = new int[65537]; for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++; for(int i = 1;i <= 65536;i++)b[i]+=b[i-1]; for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i]; int[] d = f; f = to;to = d; } { int[] b = new int[65537]; for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++; for(int i = 1;i <= 65536;i++)b[i]+=b[i-1]; for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i]; int[] d = f; f = to;to = d; } return f; } public void printArray(int[] a){ for(int i=0;i<a.length;i++) w.print(a[i]+\" \"); w.println(); } public int[] scanArrayI(int n){ int a[] = new int[n]; for(int i=0;i<n;i++) a[i] = c.nextInt(); return a; } public long[] scanArrayL(int n){ long a[] = new long[n]; for(int i=0;i<n;i++) a[i] = c.nextLong(); return a; } public void printArray(long[] a){ for(int i=0;i<a.length;i++) w.print(a[i]+\" \"); w.println(); } static class InputReader { private InputStream stream; private byte[] buf = new byte[1024]; private int curChar; private int numChars; private SpaceCharFilter filter; private BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); public InputReader(InputStream stream) { this.stream = stream; } public int read() { if (numChars==-1) throw new InputMismatchException(); if (curChar >= numChars) { curChar = 0; try { numChars = stream.read(buf); } catch (IOException e) { throw new InputMismatchException(); } if(numChars <= 0) return -1; } return buf[curChar++]; } public String nextLine() { String str = \"\"; try { str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } return str; } public int nextInt() { int c = read(); while(isSpaceChar(c)) c = read(); int sgn = 1; if (c == '-') { sgn = -1; c = read(); } int res = 0; do { if(c<'0'||c>'9') throw new InputMismatchException(); res *= 10; res += c - '0'; c = read(); } while (!isSpaceChar(c)); return res * sgn; } public long nextLong() { int c = read(); while (isSpaceChar(c)) c = read(); int sgn = 1; if (c == '-') { sgn = -1; c = read(); } long res = 0; do { if (c < '0' || c > '9') throw new InputMismatchException(); res *= 10; res += c - '0'; c = read(); } while (!isSpaceChar(c)); return res * sgn; } public double nextDouble() { int c = read(); while (isSpaceChar(c)) c = read(); int sgn = 1; if (c == '-') { sgn = -1; c = read(); } double res = 0; while (!isSpaceChar(c) && c != '.') { if (c == 'e' || c == 'E') return res * Math.pow(10, nextInt()); if (c < '0' || c > '9') throw new InputMismatchException(); res *= 10; res += c - '0'; c = read(); } if (c == '.') { c = read(); double m = 1; while (!isSpaceChar(c)) { if (c == 'e' || c == 'E') return res * Math.pow(10, nextInt()); if (c < '0' || c > '9') throw new InputMismatchException(); m /= 10; res += (c - '0') * m; c = read(); } } return res * sgn; } public String readString() { int c = read(); while (isSpaceChar(c)) c = read(); StringBuilder res = new StringBuilder(); do { res.appendCodePoint(c); c = read(); } while (!isSpaceChar(c)); return res.toString(); } public boolean isSpaceChar(int c) { if (filter != null) return filter.isSpaceChar(c); return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } public String next() { return readString(); } public interface SpaceCharFilter { public boolean isSpaceChar(int ch); } } public static void main(String args[]) throws Exception { new Thread(null, new TaskB(),", "src": "\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\n\npublic class TaskB implements Runnable {\n    boolean prime[] = new boolean[(int)1e6+10];\n    InputReader c;\n    PrintWriter w;\n\n    public void run() {\n        c = new InputReader(System.in);\n        w = new PrintWriter(System.out);\n\n        char a[] = c.next().toCharArray(), b[] = c.next().toCharArray();\n        int n = a.length, m = b.length;\n\n        int[][] prefix = new int[m][2];\n        for(int i=0;i<m;i++){\n            if(i!=0) {\n                prefix[i][0] = prefix[i-1][0];\n                prefix[i][1] = prefix[i-1][1];\n            }\n            prefix[i][b[i] - '0']++;\n            //w.println(prefix[i][0]+\" \"+prefix[i][1]);\n        }\n\n        long res = 0;\n        for(int i=0;i<n;i++){\n            int temp = a[i] - '0';\n\n            res += prefix[m - n + i][temp^1];\n            if(i!=0) res -= prefix[i-1][temp^1];\n        }\n\n        w.println(res);\n\n        w.close();\n    }\n\n    void sieveOfEratosthenes(int n) {\n        for(int i=0;i<n;i++)\n            prime[i] = true;\n\n        for(int p = 2; p*p <=n; p++)\n        {\n            if(prime[p] == true)\n            {\n                for(int i = p*p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n    }\n    class pair implements Comparable<pair>{\n        char ch;\n        int ind;\n\n        @Override\n        public String toString() {\n            return \"pair{\" +\n                    \"ch=\" + ch +\n                    \", ind=\" + ind +\n                    '}';\n        }\n\n        public pair(char ch, int ind) {\n            this.ch = ch;\n            this.ind = ind;\n        }\n        public int compareTo(pair car) {\n            if(this.ch==car.ch)\n                return this.ind - car.ind;\n            return this.ch - car.ch;\n        }\n    }\n    public static void sortbyColumn(int arr[][], int col){\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    static long gcd(long a, long b){\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static class DJSet {\n        public int[] upper;\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f) {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n    public void printArray(int[] a){\n        for(int i=0;i<a.length;i++)\n            w.print(a[i]+\" \");\n        w.println();\n    }\n    public int[] scanArrayI(int n){\n        int a[] = new int[n];\n        for(int i=0;i<n;i++)\n            a[i] = c.nextInt();\n        return a;\n    }\n    public long[] scanArrayL(int n){\n        long a[] = new long[n];\n        for(int i=0;i<n;i++)\n            a[i] = c.nextLong();\n        return a;\n    }\n    public void printArray(long[] a){\n        for(int i=0;i<a.length;i++)\n            w.print(a[i]+\" \");\n        w.println();\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new TaskB(),\"TaskB\",1<<26).start();\n    }\n}\n\n\n\n", "index": 215, "complexity": 3}
{"back-translation": "import java.util.*; class GFG { static int sequence(int n) { int f[] = new int[n + 1]; f[0] = 0; f[1] = 1; f[2] = 1; int i; for (i = 3; i <= n; i++) f[i] = f[f[i - 1]] + f[i - f[i - 1]]; return f[n]; } public static void main(String[] args) { int n = 10; System.out.println(sequence(n)); } }", "src": "\n// JAVA Code for Newman-Conway Sequence \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Function to find the n-th element \n\nstatic\nint\nsequence(\nint\nn) \n\n{ \n\n// Declare array to store sequence \n\nint\nf[] = \nnew\nint\n[n + \n1\n]; \n\nf[\n0\n] = \n0\n; \n\nf[\n1\n] = \n1\n; \n\nf[\n2\n] = \n1\n; \n\n\nint\ni; \n\n\nfor\n(i = \n3\n; i <= n; i++) \n\nf[i] = f[f[i - \n1\n]] + \n\nf[i - f[i - \n1\n]]; \n\n\nreturn\nf[n]; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(sequence(n)); \n\n\n} \n} \n\n// This code is contributed by Arnav Kr. Mandal. ", "index": 218, "complexity": 3}
{"back-translation": "class Sol { static class Node { char key; Node left, right; }; static void preorder(Node root1, Node root2, int lvl) { if(root1 == null || root2 == null) return; if(lvl % 2 == 0) { char t = root1.key; root1.key = root2.key; root2.key = t; } preorder(root1.left, root2.right, lvl + 1); preorder(root1.right, root2.left, lvl + 1); } static void reverseAlternate(Node root) { preorder(root.left, root.right, 0); } static void printInorder(Node root) { if(root == null) return; printInorder(root.left); System.out.print(root.key + \" \"); printInorder(root.right); } static Node newNode(int key) { Node temp = new Node(); temp.left = temp.right = null; temp.key = (char) key; return temp; } public static void main(String args[]) { Node root = newNode('a'); root.left = newNode('b'); root.right = newNode('c'); root.left.left = newNode('d'); root.left.right = newNode('e'); root.right.left = newNode('f'); root.right.right = newNode('g'); root.left.left.left = newNode('h'); root.left.left.right = newNode('i'); root.left.right.left = newNode('j'); root.left.right.right = newNode('k'); root.right.left.left = newNode('l'); root.right.left.right = newNode('m'); root.right.right.left = newNode('n'); root.right.right.right = newNode('o'); System.out.print(\"Inorder Traversal of given tree\\n\"); printInorder(root); reverseAlternate(root); System.out.print(\"\\n\\nInorder Traversal of modified tree\\n\"); printInorder(root); } }", "src": "\n// Java program to reverse alternate levels of a tree \nclass\nSol \n{ \n\nstatic\nclass\nNode \n{ \n\nchar\nkey; \n\nNode left, right; \n}; \n\nstatic\nvoid\npreorder( Node root1, Node root2, \nint\nlvl) \n{ \n\n// Base cases \n\nif\n(root1 == \nnull\n|| root2==\nnull\n) \n\nreturn\n; \n\n\n// Swap subtrees if level is even \n\nif\n(lvl % \n2\n== \n0\n) \n\n{ \n\nchar\nt = root1.key; \n\nroot1.key = root2.key; \n\nroot2.key = t; \n\n} \n\n\n// Recur for left and right subtrees (Note : left of root1 \n\n// is passed and right of root2 in first call and opposite \n\n// in second call. \n\npreorder(root1.left, root2.right, lvl+\n1\n); \n\npreorder(root1.right, root2.left, lvl+\n1\n); \n} \n\n// This function calls preorder() for left and right children \n// of root \nstatic\nvoid\nreverseAlternate( Node root) \n{ \n\npreorder(root.left, root.right, \n0\n); \n} \n\n// Inorder traversal (used to print initial and \n// modified trees) \nstatic\nvoid\nprintInorder( Node root) \n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\nprintInorder(root.left); \n\nSystem.out.print( root.key + \n\" \"\n); \n\nprintInorder(root.right); \n} \n\n// A utility function to create a new node \nstatic\nNode newNode(\nint\nkey) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.left = temp.right = \nnull\n; \n\ntemp.key = (\nchar\n)key; \n\nreturn\ntemp; \n} \n\n// Driver program to test above functions \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n'a'\n); \n\nroot.left = newNode(\n'b'\n); \n\nroot.right = newNode(\n'c'\n); \n\nroot.left.left = newNode(\n'd'\n); \n\nroot.left.right = newNode(\n'e'\n); \n\nroot.right.left = newNode(\n'f'\n); \n\nroot.right.right = newNode(\n'g'\n); \n\nroot.left.left.left = newNode(\n'h'\n); \n\nroot.left.left.right = newNode(\n'i'\n); \n\nroot.left.right.left = newNode(\n'j'\n); \n\nroot.left.right.right = newNode(\n'k'\n); \n\nroot.right.left.left = newNode(\n'l'\n); \n\nroot.right.left.right = newNode(\n'm'\n); \n\nroot.right.right.left = newNode(\n'n'\n); \n\nroot.right.right.right = newNode(\n'o'\n); \n\n\nSystem.out.print(\n\"Inorder Traversal of given tree\\n\"\n); \n\nprintInorder(root); \n\n\nreverseAlternate(root); \n\n\nSystem.out.print(\n\"\\n\\nInorder Traversal of modified tree\\n\"\n); \n\nprintInorder(root); \n\n} \n} \n\n// This code is contributed by Arnab Kundu ", "index": 219, "complexity": 3}
{"back-translation": "class FindCommon { void findCommon(int[] ar1, int[] ar2, int[] ar3) { int i = 0, j = 0, k = 0; while (i < ar1.length && j < ar2.length && k < ar3.length) { if (ar1[i] == ar2[j] && ar2[j] == ar3[k]) { System.out.print(ar1[i]+\" \"); i++; j++; k++; } else if (ar1[i] < ar2[j]) i++; else if (ar2[j] < ar3[k]) j++; else k++; } } public static void main(String args[]) { FindCommon ob = new FindCommon(); int ar1[] = { 1, 5, 10, 20, 40, 80 }; int ar2[] = { 6, 7, 20, 80, 100 }; int ar3[] = { 3, 4, 15, 20, 30, 70, 80, 120 }; System.out.print(\"Common elements are \"); ob.findCommon(ar1, ar2, ar3); } }", "src": "\n// Java program to find common elements in three arrays \nclass\nFindCommon \n{ \n\n// This function prints common elements in ar1 \n\nvoid\nfindCommon(\nint\nar1[], \nint\nar2[], \nint\nar3[]) \n\n{ \n\n// Initialize starting indexes for ar1[], ar2[] and ar3[] \n\nint\ni = \n0\n, j = \n0\n, k = \n0\n; \n\n\n// Iterate through three arrays while all arrays have elements \n\nwhile\n(i < ar1.length && j < ar2.length && k < ar3.length) \n\n{ \n\n// If x = y and y = z, print any of them and move ahead \n\n// in all arrays \n\nif\n(ar1[i] == ar2[j] && ar2[j] == ar3[k]) \n\n{ System.out.print(ar1[i]+\n\" \"\n); i++; j++; k++; } \n\n\n// x < y \n\nelse\nif\n(ar1[i] < ar2[j]) \n\ni++; \n\n\n// y < z \n\nelse\nif\n(ar2[j] < ar3[k]) \n\nj++; \n\n\n// We reach here when x > y and z < y, i.e., z is smallest \n\nelse\n\nk++; \n\n} \n\n} \n\n\n// Driver code to test above \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nFindCommon ob = \nnew\nFindCommon(); \n\n\nint\nar1[] = {\n1\n, \n5\n, \n10\n, \n20\n, \n40\n, \n80\n}; \n\nint\nar2[] = {\n6\n, \n7\n, \n20\n, \n80\n, \n100\n}; \n\nint\nar3[] = {\n3\n, \n4\n, \n15\n, \n20\n, \n30\n, \n70\n, \n80\n, \n120\n}; \n\n\nSystem.out.print(\n\"Common elements are \"\n); \n\nob.findCommon(ar1, ar2, ar3); \n\n} \n} \n\n/*This code is contributed by Rajat Mishra */", "index": 220, "complexity": 3}
{"back-translation": "class GFG {\n\n    static int maximumSegments(int n, int a, int b, int c) {\n        int[] dp = new int[n + 10];\n        Arrays.fill(dp, -1);\n        dp[0] = 0;\n        for (int i = 0; i < n; i++) {\n            if (dp[i] != -1) {\n                if (i + a <= n) dp[i + a] = Math.max(dp[i] + 1, dp[i + a]);\n                if (i + b <= n) dp[i + b] = Math.max(dp[i] + 1, dp[i + b]);\n                if (i + c <= n) dp[i + c] = Math.max(dp[i] + 1, dp[i + c]);\n            }\n        }\n        return dp[n];\n    }\n\n    public static void main(String arg[]) {\n        int n = 7, a = 5, b = 2, c = 5;\n        System.out.print(maximumSegments(n, a, b, c));\n    }\n}", "src": "\n// Java implementation to divide N into \n// maximum number of segments \n// of length a, b and c \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n\n// function to find the maximum \n\n// number of segments \n\nstatic\nint\nmaximumSegments(\nint\nn, \nint\na, \n\nint\nb, \nint\nc) \n\n{ \n\n// stores the maximum number of \n\n// segments each index can have \n\nint\ndp[] = \nnew\nint\n[n + \n10\n]; \n\n\n// initialize with -1 \n\nArrays.fill(dp, -\n1\n); \n\n\n// 0th index will have 0 segments \n\n// base case \n\ndp[\n0\n] = \n0\n; \n\n\n// traverse for all possible \n\n// segments till n \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(dp[i] != -\n1\n) \n\n{ \n\n\n// conditions \n\nif\n(i + a <= n ) \n//avoid buffer overflow \n\ndp[i + a] = Math.max(dp[i] + \n1\n, \n\ndp[i + a]); \n\n\nif\n(i + b <= n ) \n//avoid buffer overflow \n\ndp[i + b] = Math.max(dp[i] + \n1\n, \n\ndp[i + b]); \n\n\nif\n(i + c <= n ) \n//avoid buffer overflow \n\ndp[i + c] = Math.max(dp[i] + \n1\n, \n\ndp[i + c]); \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nn = \n7\n, a = \n5\n, b = \n2\n, c = \n5\n; \n\nSystem.out.print(maximumSegments(n, a, b, c)); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "index": 222, "complexity": 3}
{"back-translation": "class Test { static int arr[] = { 12, 34, 54, 2, 3 }; static int recSearch(int arr[], int l, int r, int x) { if (r < l) return -1; if (arr[l] == x) return l; if (arr[r] == x) return r; return recSearch(arr, l+1, r-1, x); } public static void main(String[] args) { int x = 3; int index = recSearch(arr, 0, arr.length-1, x); if (index != -1) System.out.println(\"Element \" + x + \" is present at index \" + index); else System.out.println(\"Element \" + x + \" is not present\"); } }", "src": "\n// Recursive Java program to search x in array \nclass\nTest \n{ \n\nstatic\nint\narr[] = {\n12\n, \n34\n, \n54\n, \n2\n, \n3\n}; \n\n\n/* Recursive Method to search x in arr[l..r] */\n\nstatic\nint\nrecSearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r < l) \n\nreturn\n-\n1\n; \n\nif\n(arr[l] == x) \n\nreturn\nl; \n\nif\n(arr[r] == x) \n\nreturn\nr; \n\nreturn\nrecSearch(arr, l+\n1\n, r-\n1\n, x); \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nx = \n3\n; \n\n\n//Method call to find x \n\nint\nindex = recSearch(arr, \n0\n, arr.length-\n1\n, x); \n\nif\n(index != -\n1\n) \n\nSystem.out.println(\n\"Element \"\n+ x + \n\" is present at index \"\n+ \n\nindex); \n\nelse\n\nSystem.out.println(\n\"Element \"\n+ x + \n\" is not present\"\n); \n\n} \n\n} ", "index": 224, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        char c[]=new char[n];\n        Arrays.fill(c,'o');\n        int x=1,y=1,z;\n        for(;y<=n;)\n        {\n            c[y-1]='O';\n            z=x+y;\n            x=y;\n            y=z;\n        }\n        String ans=new String(c);\n        System.out.println(ans);\n    }\n}", "src": "import java.util.*;\n\npublic class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        char c[]=new char[n];\n        Arrays.fill(c,'o');\n        int x=1,y=1,z;\n        while(y<=n)\n        {\n            c[y-1]='O';\n            z=x+y;\n            x=y;\n            y=z;\n        }\n        String ans=new String(c);\n        System.out.println(ans);\n    }\n}", "index": 225, "complexity": 3}
{"back-translation": "class Node { int data; Node left, right; Node(int d) { data = d; left = right = null; } } class BinarySearchTree { Node root; BinarySearchTree() { root = null; } public void insert(int data) { this.root = this.insertRec(this.root, data); } Node insertRec(Node node, int data) { if (node == null) { this.root = new Node(data); return this.root; } if (data < node.data) { node.left = this.insertRec(node.left, data); } else { node.right = this.insertRec(node.right, data); } return node; } public class count { int c = 0; } void secondLargestUtil(Node node, count C) { if (node == null || C.c >= 2) return; this.secondLargestUtil(node.right, C); C.c++; if (C.c == 2) { System.out.print(\"2nd largest element is \" + node.data); return; } this.secondLargestUtil(node.left, C); } void secondLargest(Node node) { count C = new count(); this.secondLargestUtil(this.root, C); } public static void main(String[] args) { BinarySearchTree tree = new BinarySearchTree(); tree.insert(50); tree.insert(30); tree.insert(20); tree.insert(40); tree.insert(70); tree.insert(60); tree.insert(80); tree.secondLargest(tree.root); } }", "src": "\n// Java code to find second largest element in BST \n\n// A binary tree node \nclass\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n// Root of BST \n\nNode root; \n\n\n// Constructor \n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n// function to insert new nodes \n\npublic\nvoid\ninsert(\nint\ndata) \n\n{ \n\nthis\n.root = \nthis\n.insertRec(\nthis\n.root, data); \n\n} \n\n\n/* A utility function to insert a new node with given \n\nkey in BST */\n\nNode insertRec(Node node, \nint\ndata) \n\n{ \n\n/* If the tree is empty, return a new node */\n\nif\n(node == \nnull\n) { \n\nthis\n.root = \nnew\nNode(data); \n\nreturn\nthis\n.root; \n\n} \n\n\n/* Otherwise, recur down the tree */\n\nif\n(data < node.data) { \n\nnode.left = \nthis\n.insertRec(node.left, data); \n\n} \nelse\n{ \n\nnode.right = \nthis\n.insertRec(node.right, data); \n\n} \n\nreturn\nnode; \n\n} \n\n\n// class that stores the value of count \n\npublic\nclass\ncount { \n\nint\nc = \n0\n; \n\n} \n\n\n// Function to find 2nd largest element \n\nvoid\nsecondLargestUtil(Node node, count C) \n\n{ \n\n// Base cases, the second condition is important to \n\n// avoid unnecessary recursive calls \n\nif\n(node == \nnull\n|| C.c >= \n2\n) \n\nreturn\n; \n\n\n// Follow reverse inorder traversal so that the \n\n// largest element is visited first \n\nthis\n.secondLargestUtil(node.right, C); \n\n\n// Increment count of visited nodes \n\nC.c++; \n\n\n// If c becomes k now, then this is the 2nd largest \n\nif\n(C.c == \n2\n) { \n\nSystem.out.print(\n\"2nd largest element is \"\n+ \n\nnode.data); \n\nreturn\n; \n\n} \n\n\n// Recur for left subtree \n\nthis\n.secondLargestUtil(node.left, C); \n\n} \n\n\n// Function to find 2nd largest element \n\nvoid\nsecondLargest(Node node) \n\n{ \n\n// object of class count \n\ncount C = \nnew\ncount(); \n\nthis\n.secondLargestUtil(\nthis\n.root, C); \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n/* Let us create following BST \n\n50 \n\n/ \\ \n\n30 70 \n\n/ \\ / \\ \n\n20 40 60 80 */\n\n\ntree.insert(\n50\n); \n\ntree.insert(\n30\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n40\n); \n\ntree.insert(\n70\n); \n\ntree.insert(\n60\n); \n\ntree.insert(\n80\n); \n\n\ntree.secondLargest(tree.root); \n\n} \n} \n\n// This code is contributed by Kamal Rawal ", "index": 226, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(br.readLine());\n        StringTokenizer st;\n        for(int z=0;z<t;z++){\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            st = new StringTokenizer(br.readLine());\n            int min=1;\n            int max=1;\n            for(int i=0;i<n;i++){\n                int k = Integer.parseInt(st.nextToken());\n                if(max<k){\n                    min = max;\n                    max = k;\n                }else if(min<k){\n                    min = k;\n                }\n            }\n            int res = Math.min(n-2,min-1);\n            System.out.println(res);\n        }\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(br.readLine());\n        StringTokenizer st;\n        for(int z=0;z<t;z++){\n            st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            st = new StringTokenizer(br.readLine());\n            int min=1;\n            int max=1;\n            for(int i=0;i<n;i++){\n                int k = Integer.parseInt(st.nextToken());\n                if(max<k){\n                    min = max;\n                    max = k;\n                }else if(min<k){\n                    min = k;\n                }\n            }\n            int res = Math.min(n-2,min-1);\n            System.out.println(res);\n        }\n    }\n}\n\n", "index": 227, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class CF_1029E_Tree_with_Small_Distances {\n    static ArrayList<Integer> adj[];\n    static int dist[];\n    static boolean visitParent[];\n    static int ans=0;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n  =sc.nextInt();\n        adj=new ArrayList[n+1];\n        dist = new int[n+1];\n        visitParent = new boolean[n+1];\n        for(int i=0;i<=n;i++) adj[i]=new ArrayList<Integer>();\n        int max=0;\n        for(int i=1;i<n;i++){\n            int u = sc.nextInt(),v=sc.nextInt();\n            adj[u].add(v);\n            adj[v].add(u);\n        }\n        dist[1]=0;\n        dfs(1,1);\n        System.out.println(ans);\n    }\n\n    private static void dfs(int i , int j) {\n        boolean f = false;\n        for(int k=0;k<adj[i].size();k++){\n            int x = adj[i].get(k);\n            if(x!=j){\n                dist[x]=dist[i]+1;\n                dfs(x,i);\n                if(visitParent[x]) f=true;\n            }\n        }\n        if(dist[i]>2&&!visitParent[j]&&!f&&!visitParent[i]){\n            visitParent[j]=true;\n            ans++;\n            for(int v=0;v<adj[i].size();v++){\n            }\n        }\n    }\n\n    static class Scanner \n{\n    StringTokenizer st;\n    BufferedReader br;\n\n    public Scanner(InputStream s){  br = new BufferedReader(new InputStreamReader(s));}\n\n    public String next() throws IOException \n    {\n        while (st == null || !st.hasMoreTokens()) \n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n    \n    public double nextDouble() throws IOException\n    {\n        String x = next();\n        StringBuilder sb = new StringBuilder(\"0\");\n        double res = 0, f = 1;\n        boolean dec = false, neg = false;\n        int start = 0;\n        if(x.charAt(0) == \\'-\n        \\'')\n        {\n            neg = true;\n            start++;\n        }\n        for(int i = start; i < x.length(); i++)\n            if(x.charAt(i) == \\'\\\n        '.')\n            {\n                res = Long.parseLong(sb.toString());\n                sb = new StringBuilder(\"0\");\n                dec = true;\n            }\n            else\n            {\n                sb.append(x.charAt(i));\n                if(dec)\n                    f *= 10;\n            }\n        res += Long.parseLong(sb.toString()) / f;\n        return res * (neg?-1:1);\n    }\n\n    public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n    public long nextLong() throws IOException {return Long.parseLong(next());}\n\n    public String nextLine() throws IOException {return br.readLine();}\n\n    public boolean ready() throws IOException {return br.ready(); }\n\n}\n}", "src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class CF_1029E_Tree_with_Small_Distances {\n\tstatic ArrayList<Integer> adj[];\n\tstatic int dist[];\n\tstatic boolean visitParent[];\n\tstatic int ans=0;\n public static void main(String[] args) throws IOException {\n\tScanner sc = new Scanner(System.in);\n\tint n  =sc.nextInt();\n\tadj=new ArrayList[n+1];\n\tdist = new int[n+1];\n\tvisitParent = new boolean[n+1];\n\tfor(int i=0;i<=n;i++) adj[i]=new ArrayList<Integer>();\n\tint max=0;\n\t//first contribution\n\tfor(int i=1;i<n;i++){\n\t\tint u = sc.nextInt(),v=sc.nextInt();\n\t\tadj[u].add(v);\n\t\tadj[v].add(u);\n\t}\n\tdist[1]=0;\n\tdfs(1,1);\n System.out.println(ans);\n \n \n }\nprivate static void dfs(int i , int j) {\n\t// TODO Auto-generated method stub\n\tboolean f = false;\n\tfor(int k=0;k<adj[i].size();k++){\n\t\tint x = adj[i].get(k);\n\t\tif(x!=j){\n\t\t\tdist[x]=dist[i]+1;\n\t\t\tdfs(x,i);\n\t\t\tif(visitParent[x])\n\t\t\t\tf=true;\n\t\t}\n\t}\n\t//System.out.println(Arrays.toString(dist));\n\tif(dist[i]>2&&!visitParent[j]&&!f&&!visitParent[i]){\n\t\tvisitParent[j]=true;\n\t\tans++;\n\t\tfor(int v=0;v<adj[i].size();v++){\n\t\t\t\n\t\t}\n\t}\n\t\n}\nstatic class Scanner \n{\n    StringTokenizer st;\n    BufferedReader br;\n\n    public Scanner(InputStream s){  br = new BufferedReader(new InputStreamReader(s));}\n\n    public String next() throws IOException \n    {\n        while (st == null || !st.hasMoreTokens()) \n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n    \n    public double nextDouble() throws IOException\n    {\n        String x = next();\n        StringBuilder sb = new StringBuilder(\"0\");\n        double res = 0, f = 1;\n        boolean dec = false, neg = false;\n        int start = 0;\n        if(x.charAt(0) == '-')\n        {\n            neg = true;\n            start++;\n        }\n        for(int i = start; i < x.length(); i++)\n            if(x.charAt(i) == '.')\n            {\n                res = Long.parseLong(sb.toString());\n                sb = new StringBuilder(\"0\");\n                dec = true;\n            }\n            else\n            {\n                sb.append(x.charAt(i));\n                if(dec)\n                    f *= 10;\n            }\n        res += Long.parseLong(sb.toString()) / f;\n        return res * (neg?-1:1);\n    }\n\n\n    public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n    public long nextLong() throws IOException {return Long.parseLong(next());}\n\n    public String nextLine() throws IOException {return br.readLine();}\n\n    public boolean ready() throws IOException {return br.ready(); }\n\n\n}\n\t\n}\n\n", "index": 228, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n=sc.nextInt();\n\t\t\tString s=sc.next();\n\t\t\tint sum=0;\n\t\t\tint i=0;\n\t\t\twhile(i<s.length()){\n\t\t\t\tif(s.charAt(i)=='+') {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t\tif(s.charAt(i)=='-'&&sum!=0) {\n\t\t\t\t\tsum--;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}", "src": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n=sc.nextInt();\n\t\t\tString s=sc.next();\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<s.length();i++) {\n\t\t\t\tif(s.charAt(i)=='+') {\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t\tif(s.charAt(i)=='-'&&sum!=0) {\n\t\t\t\t\tsum--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}", "index": 229, "complexity": 3}
{"back-translation": "import java.util.*;import java.io.*;import java.math.*;public class loser{static class InputReader{public BufferedReader br;public StringTokenizer token;public InputReader(InputStream stream){br=new BufferedReader(new InputStreamReader(stream),32768);token=null;}public String next(){while(token==null || !token.hasMoreTokens()){try{token=new StringTokenizer(br.readLine());}catch(IOException e){throw new RuntimeException(e);}}return token.nextToken();}public int nextInt(){return Integer.parseInt(next());}public long nextLong(){return Long.parseLong(next());}}static class card{String s;int l;public card(String s,int i){this.s=s;this.l=i;}}static class sort implements Comparator<card>{public int compare(card o1,card o2){if(o1.l!=o2.l)return (o1.l-o2.l);else return o1.s.compareTo(o2.s);}}static void shuffle(long a[]){List<Long> l=new ArrayList<>();for(int i=0;i<a.length;i++)l.add(a[i]);Collections.shuffle(l);for(int i=0;i<a.length;i++)a[i]=l.get(i);}static class Pair{int a;int b;public Pair(int a,int b){this.a =a;this.b =b;}}public  static void main(String[] args) {InputReader sc=new InputReader(System.in);int n=sc.nextInt();HashMap<String ,Integer> m=new HashMap<>();for(int i=0;i<n;i++){String t=sc.next();if(m.containsKey(t))m.put(t,m.get(t)+1);else m.put(t,1);}int ans=0;for(int i=0;i<n;i++){String t=sc.next();if(m.containsKey(t) && m.get(t)>0){m.put(t,m.get(t)-1);ans++;}}System.out.println(n-ans);}", "src": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    /*static long gcd(long a,long b)\n    {\n    if(b==0)\n    return a;\n    else\n    return gcd(b,a%b);\n    }\n    static boolean valid(int i,int j,int r,int c)\n    {\n    if(i<r && i>=0 && j<c && j>=0)\n    return true;\n    else\n    return false;\n    }*/\n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "index": 230, "complexity": 3}
{"back-translation": "import java.util.*; public class GFG { static int N = 12 ,ans; static Vector<Vector<Integer>> tree=new Vector<Vector<Integer>>(); static int dfs( int visit[], int node) { int num = 0 , temp = 0; visit[node] = 1; for(int i = 0; i < tree.get(node).size(); i++) { if(visit[tree.get(node).get(i)] == 0) { temp = dfs( visit, tree.get(node).get(i)); if(temp%2 != 0) num += temp; else ans++; } } return num+1; } static int minEdge( int n) { int visit[] = new int[n+2]; ans = 0; dfs( visit, 1); return ans; } public static void main(String args[]) { int n = 10; for(int i = 0; i < n + 2;i++) tree.add(new Vector<Integer>()); tree.get(1).add(3); tree.get(3).add(1); tree.get(1).add(6); tree.get(6).add(1); tree.get(1).add(2); tree.get(2).add(1); tree.get(3).add(4); tree.get(4).add(3); tree.get(6).add(8); tree.get(8).add(6); tree.get(2).add(7); tree.get(7).add(2); tree.get(2).add(5); tree.get(5).add(2); tree.get(4).add(9); tree.get(9).add(4); tree.get(4).add(10); tree.get(10).add(4); System.out.println( minEdge( n)); } }", "src": "\n// Java program to find maximum number to be removed \n// to convert a tree into forest containg trees of \n// even number of nodes \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\nstatic\nint\nN = \n12\n,ans; \n\n\nstatic\nVector<Vector<Integer>> tree=\nnew\nVector<Vector<Integer>>(); \n\n\n// Return the number of nodes of subtree having \n\n// node as a root. \n\nstatic\nint\ndfs( \nint\nvisit[], \nint\nnode) \n\n{ \n\nint\nnum = \n0\n, temp = \n0\n; \n\n\n// Mark node as visited. \n\nvisit[node] = \n1\n; \n\n\n// Traverse the adjacency list to find non- \n\n// visited node. \n\nfor\n(\nint\ni = \n0\n; i < tree.get(node).size(); i++) \n\n{ \n\nif\n(visit[tree.get(node).get(i)] == \n0\n) \n\n{ \n\n// Finding number of nodes of the subtree \n\n// of a subtree. \n\ntemp = dfs( visit, tree.get(node).get(i)); \n\n\n// If nodes are even, increment number of \n\n// edges to removed. \n\n// Else leave the node as child of subtree. \n\nif\n(temp%\n2\n!=\n0\n) \n\nnum += temp; \n\nelse\n\nans++; \n\n} \n\n} \n\n\nreturn\nnum+\n1\n; \n\n} \n\n\n// Return the maxium number of edge to remove \n\n// to make forest. \n\nstatic\nint\nminEdge( \nint\nn) \n\n{ \n\nint\nvisit[] = \nnew\nint\n[n+\n2\n]; \n\nans = \n0\n; \n\n\ndfs( visit, \n1\n); \n\n\nreturn\nans; \n\n} \n\n\n// Driven Program \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n; \n\n\n//set the size of vector \n\nfor\n(\nint\ni = \n0\n; i < n + \n2\n;i++) \n\ntree.add(\nnew\nVector<Integer>()); \n\n\ntree.get(\n1\n).add(\n3\n); \n\ntree.get(\n3\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n6\n); \n\ntree.get(\n6\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n2\n); \n\ntree.get(\n2\n).add(\n1\n); \n\n\ntree.get(\n3\n).add(\n4\n); \n\ntree.get(\n4\n).add(\n3\n); \n\n\ntree.get(\n6\n).add(\n8\n); \n\ntree.get(\n8\n).add(\n6\n); \n\n\ntree.get(\n2\n).add(\n7\n); \n\ntree.get(\n7\n).add(\n2\n); \n\n\ntree.get(\n2\n).add(\n5\n); \n\ntree.get(\n5\n).add(\n2\n); \n\n\ntree.get(\n4\n).add(\n9\n); \n\ntree.get(\n9\n).add(\n4\n); \n\n\ntree.get(\n4\n).add(\n10\n); \n\ntree.get(\n10\n).add(\n4\n); \n\n\nSystem.out.println( minEdge( n)); \n\n} \n} \n\n// This code is contributed by Arnab Kundu ", "index": 231, "complexity": 3}
{"back-translation": "import java.math.BigInteger;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        char str[][] = new char[5][n];\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < n; j++)\n                str[i][j] = '.';\n        }\n        if (k % 2 == 0) {\n            k /= 2;\n            for (int i = 1; i <= 2; i++) {\n                for (int j = 1; j <= k; j++)\n                    str[i][j] = '#';\n            }\n        } else {\n            str[1][n / 2] = '#';\n            if (k != 1) {\n                int tmp = n / 2;\n                if (k <= n - 2) {\n                    for (int i = 1; i <= (k - 1) / 2; i++) {\n                        str[1][i] = '#';\n                        str[1][n - 1 - i] = '#';\n                    }\n                } else {\n                    for (int i = 1; i <= n - 2; i++) str[1][i] = '#';\n                    k -= n - 2;\n                    for (int i = 1; i <= k / 2; i++) {\n                        str[2][i] = '#';\n                        str[2][n - 1 - i] = '#';\n                    }\n                }\n\n            }\n        }\n        System.out.println(\"YES\");\n        for (int i = 0; i < 4; i++) {\n            System.out.println(str[i]);\n        }\n    }\n}", "src": "\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner (System.in);\n    public static void main(String[] args) {\n    \tint n = sc.nextInt();\n    \tint k = sc.nextInt();\n    \tchar str[][] = new char[5][n];\n        for(int i = 0;i < 4;i ++){\n        \tfor(int j = 0;j < n;j ++)\n                str[i][j] = '.';\n        }\n        if(k % 2 == 0){\n            k /= 2;\n            for(int i = 1;i <= 2;i++){\n                for(int j = 1;j <= k;j++)\n                     str[i][j] = '#'; \n            }\n        }\n        else{\n            str[1][n / 2] = '#';\n            if(k != 1){\n                int tmp = n / 2;\n                if(k <= n - 2){\n                    for(int i = 1;i<= (k - 1) / 2;i++){\n                        str[1][i] = '#';\n                        str[1][n - 1 - i] = '#';\n                    }\n                }\n                else{\n                    for(int i = 1;i <= n - 2;i++) str[1][i] = '#';\n                    k -= n - 2;\n                    for(int i = 1;i <= k/2;i++){\n                        str[2][i] = '#';\n                        str[2][n - 1 - i]='#';\n                    }\n                }\n     \n            }\n        }\n        System.out.println(\"YES\");\n        for(int i = 0;i < 4;i ++){\n        \tSystem.out.println(str[i]);\n        }\n    }\n }", "index": 233, "complexity": 3}
{"back-translation": "import java.util.*;\npublic class Test { \npublic static void main(String[] args) {\nScanner sc = new Scanner(System.in);\nint n = sc.nextInt();\nint x = (int) Math.sqrt(n);\nint[] a = new int[n + 5];\nfor (int i = 1, o = n, j; i <= n; i += x) {\nfor (j = (int) Math.min(i + x - 1, n); j >= i; a[j--] = o--);\n}\nfor (int i = 1; i <= n; i++) System.out.print(a[i] + \" \");\nSystem.out.println();\n}\n}", "src": "import java.util.*;\npublic class Test { public static void main(String[] args)\n{\nScanner sc = new Scanner(System.in);\nint n= sc.nextInt();\nint x= (int)Math.sqrt(n) ;\nint a[] = new int[n+5];\nfor(int i=1,o=n,j;i<=n;i+=x)\nfor(j=(int)Math.min(i+x-1,n);j>=i;a[j--]=o--);\nfor(int i=1;i<=n;i++)System.out.print(a[i]+\" \");\nSystem.out.println();\n\n\n} \n}", "index": 234, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class ChainReaction {\n\n\tpublic static void main(String[] args) {\n\t\tScanner kb = new Scanner(System.in);\n\t\tint num = kb.nextInt();\n\n\t\tint[] beacons = new int[1000002];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tbeacons[kb.nextInt()] = kb.nextInt();\n\t\t}\n\n\t\tint[] dp = new int[1000002];\n\t\tint max = 0;\n\t\tif (beacons[0] != 0)\n\t\t\tdp[0] = 1;\n\n\t\tfor (int i = 1; i < dp.length; i++) {\n\t\t\tif (beacons[i] == 0) {\n\t\t\t\tdp[i] = dp[i - 1];\n\t\t\t} else {\n\t\t\t\tint index = i - 1 - beacons[i];\n\t\t\t\tif (index < 0)\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\telse\n\t\t\t\t\tdp[i] = 1 + dp[index];\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t\t//if (i<11)\n\t\t\t//System.out.println(i +\" is \"+dp[i]);\n\t\t}\n\n\t\tSystem.out.println(num - max);\n\t}\n\n}", "src": "import java.util.Scanner;\n\npublic class ChainReaction {\n\t\n\tpublic static void main(String [] args) {\n\t\tScanner kb = new Scanner(System.in);\n\t\tint num = kb.nextInt();\n\t\t\n\t\tint[] beacons = new int[1000002];\n\t\tfor (int i=0; i<num; i++) {\n\t\t\tbeacons[kb.nextInt()] = kb.nextInt();\n\t\t}\n\t\t\n\t\tint [] dp = new int[1000002];\n\t\tint max = 0;\n\t\tif (beacons[0] != 0)\n\t\t\tdp[0] = 1;\n\t\t\n\t\tfor (int i=1; i<dp.length; i++) {\n\t\t\tif (beacons[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} else {\n\t\t\t\tint index = i-1-beacons[i];\n\t\t\t\tif (index<0)\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\telse\n\t\t\t\t\tdp[i] = 1 + dp[index];\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t\t//if (i<11)\n\t\t\t\t//System.out.println(i +\" is \"+dp[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(num-max);\n\t}\n\n}\n", "index": 235, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class helloWorld {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint[][] dn = new int[200][m + 1];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\n\t\tfor (int k = 2; k <= m; k++)\n\t\t\tfor (int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif (exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor (int j = i + 2; j <= 'z'; j++)\n\t\t\t\t\t\tif (dn[j][k - 1] > 0 && (a == 0 || (a > dn[j][k - 1])))\n\t\t\t\t\t\t\ta = dn[j][k - 1];\n\t\t\t\t\tif (a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1;\n\t\t\t\t}\n\n\t\tint ans = -1;\n\t\tfor (int i = 'a'; i <= 'z'; i++)\n\t\t\tif (dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]))\n\t\t\t\tans = dn[i][m];\n\n\t\tSystem.out.println(ans);\n\n\t\tin.close();\n\t}\n}", "src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}\t\n\n\n\n", "index": 236, "complexity": 3}
{"back-translation": "public class GFG { static int countWays(int n) { int[] DP = new int[n + 1]; DP[0] = DP[1] = DP[2] = 1; DP[3] = 2; for (int i = 4; i <= n; i++) DP[i] = DP[i - 1] + DP[i - 3] + DP[i - 4]; return DP[n]; } public static void main(String[] args) { int n = 10; System.out.println(countWays(n)); } }", "src": "\n// Java program to illustrate \n// the number of ways to represent \n// N as sum of 1, 3 and 4. \n\nclass\nGFG { \n\n\n// Function to count the \n\n// number of ways to represent \n\n// n as sum of 1, 3 and 4 \n\nstatic\nint\ncountWays(\nint\nn) \n\n{ \n\nint\nDP[] = \nnew\nint\n[n + \n1\n]; \n\n\n// base cases \n\nDP[\n0\n] = DP[\n1\n] = DP[\n2\n] = \n1\n; \n\nDP[\n3\n] = \n2\n; \n\n\n// iterate for all values from 4 to n \n\nfor\n(\nint\ni = \n4\n; i <= n; i++) \n\nDP[i] = DP[i - \n1\n] + DP[i - \n3\n] \n\n+ DP[i - \n4\n]; \n\n\nreturn\nDP[n]; \n\n} \n\n\n// driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(countWays(n)); \n\n} \n} \n\n// This code is contributed \n// by prerna saini. ", "index": 237, "complexity": 3}
{"back-translation": "class MergeArrays { void moveToEnd(int mPlusN[], int size) { int i, j = size - 1; for (i = size - 1; i >= 0; i--) { if (mPlusN[i] != -1) { mPlusN[j] = mPlusN[i]; j--; } } } void merge(int mPlusN[], int N[], int m, int n) { int i = n; int j = 0; int k = 0; while (k < (m + n)) { if ((i < (m + n) && mPlusN[i] <= N[j]) || (j == n)) { mPlusN[k] = mPlusN[i]; k++; i++; } else { mPlusN[k] = N[j]; k++; j++; } } } void printArray(int arr[], int size) { int i; for (i = 0; i < size; i++) System.out.print(arr[i] + \" \"); System.out.println(\"\"); } public static void main(String[] args) { MergeArrays mergearray = new MergeArrays(); int mPlusN[] = {2, 8, -1, -1, -1, 13, -1, 15, 20}; int N[] = {5, 7, 9, 25}; int n = N.length; int m = mPlusN.length - n; mergearray.moveToEnd(mPlusN, m + n); mergearray.merge(mPlusN, N, m, n); mergearray.printArray(mPlusN, m + n); } }", "src": "\nclass\nMergeArrays \n{ \n\n/* Function to move m elements at the end of array mPlusN[] */\n\nvoid\nmoveToEnd(\nint\nmPlusN[], \nint\nsize) \n\n{ \n\nint\ni, j = size - \n1\n; \n\nfor\n(i = size - \n1\n; i >= \n0\n; i--) \n\n{ \n\nif\n(mPlusN[i] != -\n1\n) \n\n{ \n\nmPlusN[j] = mPlusN[i]; \n\nj--; \n\n} \n\n} \n\n} \n\n\n/* Merges array N[] of size n into array mPlusN[] \n\nof size m+n*/\n\nvoid\nmerge(\nint\nmPlusN[], \nint\nN[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = n; \n\n\n/* Current index of i/p part of mPlusN[]*/\n\nint\nj = \n0\n; \n\n\n/* Current index of N[]*/\n\nint\nk = \n0\n; \n\n\n/* Current index of output mPlusN[]*/\n\nwhile\n(k < (m + n)) \n\n{ \n\n/* Take an element from mPlusN[] if \n\na) value of the picked element is smaller and we have \n\nnot reached end of it \n\nb) We have reached end of N[] */\n\nif\n((i < (m + n) && mPlusN[i] <= N[j]) || (j == n)) \n\n{ \n\nmPlusN[k] = mPlusN[i]; \n\nk++; \n\ni++; \n\n} \n\nelse\n// Otherwise take element from N[] \n\n{ \n\nmPlusN[k] = N[j]; \n\nk++; \n\nj++; \n\n} \n\n} \n\n} \n\n\n/* Utility that prints out an array on a line */\n\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMergeArrays mergearray = \nnew\nMergeArrays(); \n\n\n/* Initialize arrays */\n\nint\nmPlusN[] = {\n2\n, \n8\n, -\n1\n, -\n1\n, -\n1\n, \n13\n, -\n1\n, \n15\n, \n20\n}; \n\nint\nN[] = {\n5\n, \n7\n, \n9\n, \n25\n}; \n\nint\nn = N.length; \n\nint\nm = mPlusN.length - n; \n\n\n/*Move the m elements at the end of mPlusN*/\n\nmergearray.moveToEnd(mPlusN, m + n); \n\n\n/*Merge N[] into mPlusN[] */\n\nmergearray.merge(mPlusN, N, m, n); \n\n\n/* Print the resultant mPlusN */\n\nmergearray.printArray(mPlusN, m + n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 239, "complexity": 3}
{"back-translation": "class Profit { static int maxProfit(int price[], int n) { int profit[] = new int[n]; for (int i=0; i<n; i++) profit[i] = 0; int max_price = price[n-1]; for (int i=n-2; i>=0; i--) { if (price[i] > max_price) max_price = price[i]; profit[i] = Math.max(profit[i+1], max_price-price[i]); } int min_price = price[0]; for (int i=1; i<n; i++) { if (price[i] < min_price) min_price = price[i]; profit[i] = Math.max(profit[i-1], profit[i] + (price[i]-min_price) ); } int result = profit[n-1]; return result; } public static void main(String args[]) { int price[] = {2, 30, 15, 10, 8, 25, 80}; int n = price.length; System.out.println(\"Maximum Profit = \"+ maxProfit(price, n)); } }", "src": "\nclass\nProfit \n{ \n\n// Returns maximum profit with two transactions on a given \n\n// list of stock prices, price[0..n-1] \n\nstatic\nint\nmaxProfit(\nint\nprice[], \nint\nn) \n\n{ \n\n// Create profit array and initialize it as 0 \n\nint\nprofit[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nprofit[i] = \n0\n; \n\n\n/* Get the maximum profit with only one transaction \n\nallowed. After this loop, profit[i] contains maximum \n\nprofit from price[i..n-1] using at most one trans. */\n\nint\nmax_price = price[n-\n1\n]; \n\nfor\n(\nint\ni=n-\n2\n;i>=\n0\n;i--) \n\n{ \n\n// max_price has maximum of price[i..n-1] \n\nif\n(price[i] > max_price) \n\nmax_price = price[i]; \n\n\n// we can get profit[i] by taking maximum of: \n\n// a) previous maximum, i.e., profit[i+1] \n\n// b) profit by buying at price[i] and selling at \n\n// max_price \n\nprofit[i] = Math.max(profit[i+\n1\n], max_price-price[i]); \n\n} \n\n\n/* Get the maximum profit with two transactions allowed \n\nAfter this loop, profit[n-1] contains the result */\n\nint\nmin_price = price[\n0\n]; \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\n// min_price is minimum price in price[0..i] \n\nif\n(price[i] < min_price) \n\nmin_price = price[i]; \n\n\n// Maximum profit is maximum of: \n\n// a) previous maximum, i.e., profit[i-1] \n\n// b) (Buy, Sell) at (min_price, price[i]) and add \n\n// profit of other trans. stored in profit[i] \n\nprofit[i] = Math.max(profit[i-\n1\n], profit[i] + \n\n(price[i]-min_price) ); \n\n} \n\nint\nresult = profit[n-\n1\n]; \n\nreturn\nresult; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nprice[] = {\n2\n, \n30\n, \n15\n, \n10\n, \n8\n, \n25\n, \n80\n}; \n\nint\nn = price.length; \n\nSystem.out.println(\n\"Maximum Profit = \"\n+ maxProfit(price, n)); \n\n} \n\n}\n/* This code is contributed by Rajat Mishra */", "index": 240, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static InputReader in = new InputReader(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n\n    static long oo = 1000000000000L;\n    static int[][] memo;\n\n    public static void main(String[] args) throws IOException {\n\n        int[] cnt = new int[101];\n        cnt[1] = 1;\n        for(int i = 2; i <= 100; ++i) {\n            cnt[i] = cnt[i-1] + 4 * (i - 1);\n        }\n        int n = in.nextInt();\n        System.out.println( cnt[n] );\n\n        out.close();\n    }\n\n    static int maxHit(ArrayList<Integer> a, int p, int i) {\n        if(i == a.size())\n            return 0;\n        if(memo[p][i] != -1)\n            return memo[p][i];\n        int ret = maxHit(a, p, i + 1);\n        if(p == -1 || a.get(p) < a.get(i)) {\n            ret = Math.max(ret, maxHit(a, i, i + 1) );\n        }\n        return memo[p][i] = ret;\n    }\n\n\n    static long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    static boolean nextPermutation(int[] a) {\n        for(int i = a.length - 2; i >= 0; --i) {\n            if(a[i] < a[i+1]) {\n                for(int j = a.length - 1; ; --j) {\n                    if(a[i] < a[j]) {\n                        int t = a[i];\n                        a[i] = a[j];\n                        a[j] = t;\n                        for(i++, j = a.length - 1; i < j; ++i, --j) {\n                            t = a[i];\n                            a[i] = a[j];\n                            a[j] = t;\n                        }\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n\n    static void shuffle(int[] a) {\n        Random r = new Random();\n        for(int i = a.length - 1; i > 0; --i) {\n            int si = r.nextInt(i);\n            int t = a[si];\n            a[si] = a[i];\n            a[i] = t;\n        }\n    }\n\n    static void shuffle(long[] a) {\n        Random r = new Random();\n        for(int i = a.length - 1; i > 0; --i) {\n            int si = r.nextInt(i);\n            long t = a[si];\n            a[si] = a[i];\n            a[i] = t;\n        }\n    }\n\n    static int lower_bound(int[] a, int n, int k) {\n        int s = 0;\n        int e = n;\n        int m;\n        while (e - s > 0) {\n            m = (s + e) / 2;\n            if (a[m] < k)\n                s = m + 1;\n            else\n                e = m;\n        }\n        return e;\n    }\n    static int lower_bound(long[] a, int n, long k) {\n        int s = 0;\n        int e = n;\n        int m;\n        while (e - s > 0) {\n            m = (s + e) / 2;\n            if (a[m] < k)\n                s = m + 1;\n            else\n                e = m;\n        }\n        return e;\n    }\n\n    static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int first, second;\n\n        public Pair(int first, int second) {\n            super();\n            this.first = first;\n            this.second = second;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            return this.first != o.first ? this.first - o.first : this.second - o.second;\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + first;\n            result = prime * result + second;\n            return result;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            Pair other = (Pair) obj;\n            if (first != other.first)\n                return false;\n            if (second != other.second)\n                return false;\n            return true;\n        }\n    }\n\n\n}\n\n\n\nclass InputReader {\n\n    private final InputStream stream;\n    private final byte[] buf = new byte[8192];\n    private int curChar, snumChars;\n\n    public InputReader(InputStream st) {\n        this.stream = st;\n    }\n\n    public int read() {\n        if (snumChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= snumChars) {\n            curChar = 0;\n            try {\n                snumChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (snumChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public long nextLong() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public int[] nextIntArray(int n) {\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public String nextLine() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n}", "src": "import java.io.*;\nimport java.util.*;\n \n \n \npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint[] cnt = new int[101];\n\t\tcnt[1] = 1;\n\t\tfor(int i = 2; i <= 100; ++i) {\n\t\t\tcnt[i] = cnt[i-1] + 4 * (i - 1);\n\t\t}\n\t\tint n = in.nextInt();\n\t\tSystem.out.println( cnt[n] );\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic int maxHit(ArrayList<Integer> a, int p, int i) {\n\t\tif(i == a.size())\n\t\t\treturn 0;\n\t\tif(memo[p][i] != -1)\n\t\t\treturn memo[p][i];\n\t\tint ret = maxHit(a, p, i + 1);\n\t\tif(p == -1 || a.get(p) < a.get(i)) {\n\t\t\tret = Math.max(ret, maxHit(a, i, i + 1) );\n\t\t}\n\t\treturn memo[p][i] = ret;\n\t}\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "index": 241, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.util.*;\n\npublic class helloWorld \n{\n\tstatic ArrayList<Integer> ar;\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tStringBuilder ans = new StringBuilder();\n\t\tif(n <= 2)\n\t\t\tans.append(\"No\");\n\t\telse if(n == 4) {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tans.append(\"1 2\\n\");\n\t\t\tans.append(\"3 1 3 4\\n\");\n\t\t}\n\t\telse  {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tif(n % 2 == 1) {\n\t\t\t\tint a = (n+1)/2;\n\t\t\t\tans.append(\"1 \");\n\t\t\t\tans.append(a);\n\t\t\t\tans.append(\"\\n\");\n\t\t\t\tans.append(n-1);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+1; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a = n/2;\n\t\t\t\tans.append(\"2 \");\n\t\t\t\tans.append(a + \" \");\n\t\t\t\tans.append(a+1 + \" \\n\");\n\t\t\t\tans.append(n-2);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+2; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 242, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint[] beacon = new int[1000001];\n\t\tint[] pos = new int[num];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tint position = sc.nextInt();\n\t\t\tbeacon[position] = sc.nextInt();\n\t\t\tpos[i] = position;\n\t\t}\n\t\tint[] dp = new int[1000001];\n\t\tint max = 0;\n\t\tif (beacon[0] != 0)\n\t\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i - 1];\n\t\t\t} else {\n\t\t\t\tint j = i - beacon[i] - 1;\n\t\t\t\tif (j < 0) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i] = dp[j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\n\t\tSystem.out.println(num - max);\n\t}\n\n}", "src": "import java.util.Scanner;\n\npublic class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint beacon[] = new int[1000001];\n\t\tint pos[] = new int[num];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tint position = sc.nextInt();\n\t\t\tbeacon[position] = sc.nextInt();\n\t\t\tpos[i] = position;\n\t\t}\n\t\tint dp[] = new int[1000001];\n\t\tint max = 0;\n\t\tif (beacon[0] != 0)\n\t\t\tdp[0] = 1;\n\t\t\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} \n\t\t\telse {\n\t\t\t\tint j = i - beacon[i] - 1;\n\t\t\t\tif (j < 0) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = dp[j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\t\t\n\t\tSystem.out.println(num-max);\n\t}\n\n}\n", "index": 243, "complexity": 3}
{"back-translation": "import java.io.*;\n\n\npublic class Transformed {\n    StreamTokenizer in;\n    PrintWriter out;\n\n    int nextInt() throws IOException {\n        in.nextToken();\n        return (int)in.nval;\n    }\n\n    long nextLong() throws IOException {\n        in.nextToken();\n        return (long)in.nval;\n    }\n\n    String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n\n\n    void run() throws IOException {\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    void solve() throws IOException {\n        int n = nextInt(), k = nextInt(), sum = 0, count = 0;\n        String str = nextString();\n        char[] arr = str.toCharArray();\n        boolean[] bool = new boolean[26];\n        for(char ch : arr) {\n            bool[(int)ch - 97] = true;\n        }\n        for(int i = 0; i < 26;) {\n            if(bool[i]) {\n                sum += i + 1;\n                count++;\n                i += 1;\n            }\n            if(count == k) break;\n        }\n        if(count == k) out.println(sum);\n        else out.println(-1);\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Transformed().run();\n    }\n}", "src": "import java.io.*;\n\n\npublic class First {\n    StreamTokenizer in;\n    PrintWriter out;\n\n    int nextInt() throws IOException {\n        in.nextToken();\n        return (int)in.nval;\n    }\n\n    long nextLong() throws IOException {\n        in.nextToken();\n        return (long) in.nval;\n    }\n\n    String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n\n\n    void run() throws IOException {\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    void solve() throws IOException {\n        int n = nextInt(), k = nextInt(), sum = 0, count = 0;\n        String str = nextString();\n        char[] arr = str.toCharArray();\n        boolean[] bool = new boolean[26];\n        for(char ch: arr){\n            bool[((int)ch)-97] = true;\n        }\n        for(int i = 0; i < 26; i++){\n            if(bool[i]){\n                sum += i+1;\n                count++;\n                i += 1;\n            }\n            if(count == k) break;\n        }\n        if(count == k) out.println(sum);\n        else out.println(-1);\n    }\n\n    public static void main(String[] args) throws IOException {\n        new First().run();\n    }\n}", "index": 244, "complexity": 3}
{"back-translation": "class Test { static int arr[] = new int[] { 3 , 7 , 90 , 20 , 10 , 50 , 40}; static void findMinAvgSubarray(int n, int k) { if(n < k) return; int res_index = 0; int curr_sum = 0; for(int i = 0; i < k; i++) curr_sum += arr[i]; int min_sum = curr_sum; for(int i = k; i < n; i++) { curr_sum += arr[i] - arr[i - k]; if(curr_sum < min_sum) { min_sum = curr_sum; res_index = (i - k + 1); } } System.out.println(\"Subarray between [\"+ res_index + \", \" + (res_index + k - 1) + \"] has minimum average\"); } public static void main(String[] args) { int k = 3; findMinAvgSubarray(arr.length, k); } }", "src": "\n// A Simple Java program to find \n// minimum average subarray \n\nclass\nTest { \n\n\nstatic\nint\narr[] = \nnew\nint\n[] { \n3\n, \n7\n, \n90\n, \n20\n, \n10\n, \n50\n, \n40\n}; \n\n\n// Prints beginning and ending indexes of subarray \n\n// of size k with minimum average \n\nstatic\nvoid\nfindMinAvgSubarray(\nint\nn, \nint\nk) \n\n{ \n\n// k must be smaller than or equal to n \n\nif\n(n < k) \n\nreturn\n; \n\n\n// Initialize beginning index of result \n\nint\nres_index = \n0\n; \n\n\n// Compute sum of first subarray of size k \n\nint\ncurr_sum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\ncurr_sum += arr[i]; \n\n\n// Initialize minimum sum as current sum \n\nint\nmin_sum = curr_sum; \n\n\n// Traverse from (k+1)'th element to n'th element \n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\n// Add current item and remove first \n\n// item of previous subarray \n\ncurr_sum += arr[i] - arr[i - k]; \n\n\n// Update result if needed \n\nif\n(curr_sum < min_sum) { \n\nmin_sum = curr_sum; \n\nres_index = (i - k + \n1\n); \n\n} \n\n} \n\n\nSystem.out.println(\n\"Subarray between [\"\n+ \n\nres_index + \n\", \"\n+ (res_index + k - \n1\n) + \n\n\"] has minimum average\"\n); \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nk = \n3\n; \n// Subarray size \n\nfindMinAvgSubarray(arr.length, k); \n\n} \n} ", "index": 245, "complexity": 3}
{"back-translation": "public class GFG { static long countWays(int n) { long[][] dp = new long[2][n + 1]; dp[0][1] = 1; dp[1][1] = 2; for (int i = 2; i <= n; i++) { dp[0][i] = dp[0][i - 1] + dp[1][i - 1]; dp[1][i] = dp[0][i - 1] * 2 + dp[1][i - 1]; } return dp[0][n] + dp[1][n]; } public static void main(String[] args) { int n = 5; System.out.print(\"Total no of ways with n = \" + n + \" are: \" + countWays(n)); } }", "src": "\n// Java program to count ways to build street \n// under given constraints \npublic\nclass\nGFG { \n\n// function to count ways of building \n// a street of n rows \n\nstatic\nlong\ncountWays(\nint\nn) { \n\nlong\ndp[][] = \nnew\nlong\n[\n2\n][n + \n1\n]; \n\n\n// base case \n\ndp[\n0\n][\n1\n] = \n1\n; \n\ndp[\n1\n][\n1\n] = \n2\n; \n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\n\n// ways of building houses in both \n\n// the spots of ith row \n\ndp[\n0\n][i] = dp[\n0\n][i - \n1\n] + dp[\n1\n][i - \n1\n]; \n\n\n// ways of building an office in one of \n\n// the two spots of ith row \n\ndp[\n1\n][i] = dp[\n0\n][i - \n1\n] * \n2\n+ dp[\n1\n][i - \n1\n]; \n\n} \n\n\n// total ways for n rows \n\nreturn\ndp[\n0\n][n] + dp[\n1\n][n]; \n\n} \n\n// driver program for checking above function \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nint\nn = \n5\n; \n\nSystem.out.print(\n\"Total no of ways with n = \"\n+ n \n\n+ \n\" are: \"\n+ countWays(n)); \n\n} \n\n} \n\n/*This code is contributed by PrinciRaj1992*/", "index": 246, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class LightItUp {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint m = Integer.parseInt(st.nextToken());\n\t\tint previous = 0;\n\t\tint[] array = new int[n + 1];\n\t\tint answer = 0;\n\t\tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarray[i] = Integer.parseInt(st1.nextToken());\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tanswer += (array[i] - previous);\n\t\t\t}\n\t\t\tprevious = array[i];\n\t\t}\n\t\tif (n % 2 == 0) {\n\t\t\tanswer += (m - previous);\n\t\t}\n\t\tprevious = m;\n\t\tint max = Integer.MAX_VALUE;\n\t\twhile (n-- != 0) {\n\t\t\tint temp = array[n];\n\t\t\tif (n % 2 == 0) {\n\t\t\t\tarray[n] = array[n + 1] - (previous - array[n]);\n\t\t\t} else {\n\t\t\t\tarray[n] = array[n + 1] + (previous - array[n]);\n\t\t\t}\n\t\t\tprevious = temp;\n\t\t\tmax = Math.min(max, array[n]);\n\t\t}\n\t\tif (max >= -1) {\n\t\t\tSystem.out.println(answer);\n\t\t} else {\n\t\t\tSystem.out.println(answer - (max + 1));\n\t\t}\n\t}\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class LightItUp {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t StringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint m = Integer.parseInt(st.nextToken());\n\t\tint previous = 0;\n\t\tint array[] = new int[n+1];\n\t\tint answer = 0;\n\t\t\n\t\tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarray[i] = Integer.parseInt(st1.nextToken());\n\t\t\tif(i % 2 == 0){\n\t\t\t\tanswer += (array[i] - previous);\n\t\t\t}\n\t\t\tprevious = array[i];\n\t\t}\n\t\t\n\t\tif(n % 2 == 0){\n\t\t\tanswer += (m - previous);\n\t\t}\n\t\tprevious = m;\n\t\tint max = Integer.MAX_VALUE;\n\t\t\n\t\twhile(n-- != 0){\n\t\t\tint temp = array[n];\n\t\t\tif(n%2 == 0){\n\t\t\t\tarray[n] = array[n+1] - (previous - array[n]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarray[n] = array[n+1] + (previous - array[n]);\n\t\t\t}\n\t\t\tprevious = temp;\n\t\t\tmax = Math.min(max, array[n]);\n\t\t}\n\t\tif(max>=-1){\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(answer - (max+1));\n\t\t}\n\n\t}\n\n}\n", "index": 247, "complexity": 3}
{"back-translation": "public class GFG { static int minTimeForWritingChars(int N, int insert, int remove, int copy) { if (N == 0) return 0; if (N == 1) return insert; int dp[] = new int[N + 1]; for (int i = 1; i <= N; i++) { if (i % 2 == 0) dp[i] = Math.min(dp[i - 1] + insert, dp[i / 2] + copy); else dp[i] = Math.min(dp[i - 1] + insert, dp[(i + 1) / 2] + copy + remove); } return dp[N]; } public static void main(String[] args) { int N = 9; int insert = 1, remove = 2, copy = 1; System.out.println(minTimeForWritingChars(N, insert, remove, copy)); } }", "src": "\n// Java program to write characters in \n// minimum time by inserting, removing \n// and copying operation \n\npublic\nclass\nGFG{ \n\n\n// method returns minimum time to write \n\n// 'N' characters \n\nstatic\nint\nminTimeForWritingChars(\nint\nN, \nint\ninsert, \n\nint\nremove, \nint\ncopy) \n\n{ \n\nif\n(N == \n0\n) \n\nreturn\n0\n; \n\nif\n(N == \n1\n) \n\nreturn\ninsert; \n\n\n// declare dp array and initialize with zero \n\nint\ndp[] = \nnew\nint\n[N + \n1\n]; \n\n\n\n// loop for 'N' number of times \n\nfor\n(\nint\ni = \n1\n; i <= N; i++) \n\n{ \n\n/* if current char count is even then \n\nchoose minimum from result for (i-1) \n\nchars and time for insertion and \n\nresult for half of chars and time \n\nfor copy */\n\nif\n(i % \n2\n== \n0\n) \n\ndp[i] = Math.min(dp[i-\n1\n] + insert, dp[i/\n2\n] + copy); \n\n\n/* if current char count is odd then \n\nchoose minimum from \n\nresult for (i-1) chars and time for \n\ninsertion and \n\nresult for half of chars and time for \n\ncopy and one extra character deletion*/\n\nelse\n\ndp[i] = Math.min(dp[i-\n1\n] + insert, \n\ndp[(i+\n1\n)/\n2\n] + copy + remove); \n\n} \n\nreturn\ndp[N]; \n\n} \n\n\n// Driver code to test above methods \n\npublic\nstatic\nvoid\nmain(String []args) \n\n{ \n\nint\nN = \n9\n; \n\nint\ninsert = \n1\n, remove = \n2\n, copy = \n1\n; \n\nSystem.out.println(minTimeForWritingChars(N, insert,remove, copy)); \n\n} \n\n// This code is contributed by Ryuga \n} ", "index": 248, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class Practice {\n    \n    \n    public static void main(String []args)\n    {\n        Scanner sc=new Scanner(System.in);\n        \n        \n        String s=sc.nextLine();\n        int n=0;\n        int m=0;\n        //System.out.println(5%0);\n        \n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)=='-')\n            {\n                n++;\n            }\n            else\n            {\n                m++;\n            }\n        }\n        if(m==0)\n        {\n            System.out.println(\"YES\");\n        }\n        else\n        {\n        if(n%m==0)\n        {\n            System.out.println(\"YES\");\n        }\n        else\n        {\n            System.out.println(\"NO\");\n        }\n        }\n        \n        \n        \n        \n        \n        \n        \n        \n}\n\n}", "src": "import java.math.BigInteger;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\npublic class Practice {\n\t\n\t   \n\n\t\tpublic static void main(String []args)\n\t\t{\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\t\n\t\t\t\n\t\t\tString s=sc.nextLine();\n\t\t\tint n=0;\n\t\t\tint m=0;\n\t\t\t//System.out.println(5%0);\n\t\t\t\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)=='-')\n\t\t\t\t{\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif(n%m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t}\n\n}", "index": 250, "complexity": 3}
{"back-translation": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class PlayingPiano {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n\n        List<Integer> as = new LinkedList<>();\n        int[] as2 = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            int a = scanner.nextInt();\n            as.add(a);\n            as2[i] = a;\n        }\n\n        //System.out.println(solve(as));\n        System.out.println(solve2(as2));\n\n        scanner.close();\n    }\n\n    public static String solve(List<Integer> as) {\n        List<Integer> fingers = new LinkedList<>();\n        fingers.add(1);\n        fingers.add(2);\n        fingers.add(3);\n        fingers.add(4);\n        fingers.add(5);\n\n        List<Integer> solution = assign(as, fingers, fingers);\n        if (solution == null) {\n            return \"-1\";\n        } else {\n            StringBuilder sb = new StringBuilder();\n            for (int b : solution) {\n                sb.append(b);\n                sb.append(\" \");\n            }\n            sb.deleteCharAt(sb.length() - 1);\n            return sb.toString();\n        }\n    }\n\n    private static List<Integer> assign(List<Integer> as, List<Integer> fingers, List<Integer> allFingers) {\n        if (fingers.isEmpty()) {\n            return null;\n        }\n\n        if (as.size() == 1) {\n            List<Integer> ret = new LinkedList<>();\n            ret.add(fingers.get(0));\n            return ret;\n        }\n\n        List<Integer> subList = as.subList(1, as.size());\n\n        for (int i = 0; i < fingers.size(); i++) {\n            List<Integer> subFingers = new LinkedList<>();\n            final int j = i;\n            if (as.get(0) < as.get(1)) {\n                subFingers = allFingers.stream()\n                        .filter(p -> p > fingers.get(j)).collect(Collectors.toList());\n            } else if (as.get(0) > as.get(1)) {\n                subFingers = allFingers.stream()\n                        .filter(p -> p < fingers.get(j)).collect(Collectors.toList());\n            } else {\n                subFingers = allFingers.stream()\n                        .filter(p -> p != fingers.get(j)).collect(Collectors.toList());\n            }\n\n            List<Integer> ret = assign(subList, subFingers, allFingers);\n            if (ret != null) {\n                List<Integer> solution = new LinkedList<>();\n                solution.add(fingers.get(i));\n                solution.addAll(ret);\n                return solution;\n            }\n        }\n        return null;\n\n    }\n\n    public static String solve2(int[] as) {\n        int[] ret = new int[as.length];\n\n        if (as.length == 1) return \"1\";\n\n        if (as[0] < as[1]) ret[0] = 1;\n        else if (as[0] == as[1]) ret[0] = 3;\n        else ret[0] = 5;\n\n        for (int i = 1; i < as.length - 1; i++) {\n            if (as[i-1] < as[i] && ret[i-1] == 5) return \"-1\";\n            if (as[i-1] > as[i] && ret[i-1] == 1) return \"-1\";\n\n            if (as[i-1] < as[i] && as[i] < as[i+1]) {\n                ret[i] = ret[i-1] + 1;\n            } else if (as[i-1] == as[i] && as[i] < as[i+1]) {\n                ret[i] = ret[i-1] == 1 ? 2 : 1;\n            } else if (as[i-1] > as[i] && as[i] < as[i+1]) {\n                ret[i] = 1;\n            } else if (as[i-1] < as[i] && as[i] == as[i+1]) {\n                ret[i] = ret[i-1] + 1;\n            } else if (as[i-1] == as[i] && as[i] == as[i+1]) {\n                ret[i] = ret[i-1] == 4 ? 2 : 4;\n            } else if (as[i-1] > as[i] && as[i] == as[i+1]) {\n                ret[i] = ret[i-1] == 2 ? 1 : 2;\n            } else if (as[i-1] < as[i] && as[i] > as[i+1]) {\n                ret[i] = 5;\n            } else if (as[i-1] == as[i] && as[i] > as[i+1]) {\n                ret[i] = ret[i-1] == 5 ? 4 : 5;\n            } else if (as[i-1] > as[i] && as[i] > as[i+1]) {\n                ret[i] = ret[i-1] - 1;\n            }\n        }\n\n        if (as.length > 1) {\n            if (as[as.length - 1] > as[as.length - 2]) {\n                if (ret[as.length - 2] == 5)\n                    return \"-1\";\n                ret[as.length - 1] = 5;\n            } else if (as[as.length - 1] == as[as.length - 2]) {\n                ret[as.length - 1] = ret[as.length - 2] == 5 ? 4 : 5;\n            } else {\n                if (ret[as.length - 2] == 1)\n                    return \"-1\";\n                ret[as.length - 1] = 1;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int b : ret) {\n            sb.append(b);\n            sb.append(\" \");\n        }\n        sb.deleteCharAt(sb.length() - 1);\n        return sb.toString();\n    }\n\n}\n", "src": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class PlayingPiano {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\t int n = scanner.nextInt();\n\t\t \n\t\t List<Integer> as = new LinkedList<>();\n\t\t int[] as2 = new int[n];\n\t\t \n\t\t for (int i = 0; i < n; i++) {\n\t\t\t int a = scanner.nextInt();\n\t\t\t as.add(a);\n\t\t\t as2[i] = a;\n\t\t }\n\t\t \n\t\t //System.out.println(solve(as));\n\t\t System.out.println(solve2(as2));\n\t\t\n\t\tscanner.close();\n\t}\n\n\tpublic static String solve(List<Integer> as) {\n\t\tList<Integer> fingers = new LinkedList<>();\n\t\t fingers.add(1);\n\t\t fingers.add(2);\n\t\t fingers.add(3);\n\t\t fingers.add(4);\n\t\t fingers.add(5);\n\t\t \n\t\t List<Integer> solution = assign(as, fingers, fingers);\n\t\t if (solution == null) {\n\t\t\t return \"-1\";\n\t\t } else {\n\t\t\t StringBuilder sb = new StringBuilder();\n\t\t\t for (int b : solution) {\n\t\t\t\t sb.append(b);\n\t\t\t\t sb.append(\" \");\n\t\t\t }\n\t\t\t sb.deleteCharAt(sb.length() - 1);\n\t\t\t return sb.toString();\n\t\t }\n\t}\n\n\tprivate static List<Integer> assign(List<Integer> as, List<Integer> fingers, List<Integer> allFingers) {\n\t\t// if fingers is empty return null\n\t\tif (fingers.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// if as size is one then return first element in fingers\n\t\tif (as.size() == 1) {\n\t\t\tList<Integer> ret = new LinkedList<>();\n\t\t\tret.add(fingers.get(0));\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\t// get sublist\n\t\tList<Integer> subList = as.subList(1, as.size());\n\t\t\n\t\tfor (int i = 0; i < fingers.size(); i++) {\n\t\t\t// recursively call with sublist and limited list of fingers\n\t\t\tList<Integer> subFingers = new LinkedList<>();\n\t\t\tfinal int j = i;\n\t\t\tif (as.get(0) < as.get(1)) {\n\t\t\t\t subFingers = allFingers.stream()\n\t\t\t\t\t    .filter(p -> p > fingers.get(j)).collect(Collectors.toList());\n\t\t\t} else if (as.get(0) > as.get(1)) {\n\t\t\t\tsubFingers = allFingers.stream()\n\t\t\t\t\t    .filter(p -> p < fingers.get(j)).collect(Collectors.toList());\n\t\t\t} else {\n\t\t\t\tsubFingers = allFingers.stream()\n\t\t\t\t\t    .filter(p -> p != fingers.get(j)).collect(Collectors.toList());\n\t\t\t}\n\t\t\t\n\t\t\tList<Integer> ret = assign(subList, subFingers, allFingers);\n\t\t\tif (ret != null) {\n\t\t\t\tList<Integer> solution = new LinkedList<>();\n\t\t\t\tsolution.add(fingers.get(i));\n\t\t\t\tsolution.addAll(ret);\n\t\t\t\treturn solution;\n\t\t\t}\n\t\t\t\n\t\t\t// if return is null, then return null, else return an array\n\t\t}\n\t\treturn null;\n\t\t\n\t}\n\t\n\tpublic static String solve2(int[] as) {\n\t\tint[] ret = new int[as.length];\n\t\t\n\t\tif (as.length == 1) return \"1\";\n\t\t\n\t\tif (as[0] < as[1]) ret[0] = 1;\n\t\telse if (as[0] == as[1])\tret[0] = 3;\n\t\telse ret[0] = 5;\n\t\t\n\t\tfor (int i = 1; i < as.length - 1; i++) {\n\t\t\tif (as[i-1] < as[i] && ret[i-1] == 5) return \"-1\";\n\t\t\tif (as[i-1] > as[i] && ret[i-1] == 1) return \"-1\";\n\t\t\t\n\t\t\tif (as[i-1] < as[i] && as[i] < as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] + 1;\n\t\t\t} else if (as[i-1] == as[i] && as[i] < as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] == 1 ? 2 : 1;\n\t\t\t} else if (as[i-1] > as[i] && as[i] < as[i+1]) {\n\t\t\t\tret[i] = 1;\n\t\t\t} else if (as[i-1] < as[i] && as[i] == as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] + 1;\n\t\t\t} else if (as[i-1] == as[i] && as[i] == as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] == 4 ? 2 : 4;\n\t\t\t} else if (as[i-1] > as[i] && as[i] == as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] == 2 ? 1 : 2;\n\t\t\t} else if (as[i-1] < as[i] && as[i] > as[i+1]) {\n\t\t\t\tret[i] = 5;\n\t\t\t} else if (as[i-1] == as[i] && as[i] > as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] == 5 ? 4 : 5;\n\t\t\t} else if (as[i-1] > as[i] && as[i] > as[i+1]) {\n\t\t\t\tret[i] = ret[i-1] - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (as.length > 1) {\n\t\t\tif (as[as.length - 1] > as[as.length - 2]) {\n\t\t\t\tif (ret[as.length - 2] == 5)\n\t\t\t\t\treturn \"-1\";\n\t\t\t\tret[as.length - 1] = 5;\n\t\t\t} else if (as[as.length - 1] == as[as.length - 2]) {\n\t\t\t\tret[as.length - 1] = ret[as.length - 2] == 5 ? 4 : 5;\n\t\t\t} else {\n\t\t\t\tif (ret[as.length - 2] == 1)\n\t\t\t\t\treturn \"-1\";\n\t\t\t\tret[as.length - 1] = 1;\n\t\t\t} \n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\t for (int b : ret) {\n\t\t\t sb.append(b);\n\t\t\t sb.append(\" \");\n\t\t }\n\t\t sb.deleteCharAt(sb.length() - 1);\n\t\t return sb.toString();\n\t}\n\n}\n", "index": 251, "complexity": 3}
{"back-translation": "class GFG { static int countSeq(int n) { int nCr = 1, res = 1; for (int r = 1; r <= n; r++) { nCr = (nCr * (n + 1 - r)) / r; res += nCr * nCr; } return res; } public static void main(String args[]) { int n = 2; System.out.print(\"Count of sequences is \"); System.out.println(countSeq(n)); } }", "src": "\n// Java program to find remaining \n// chocolates after k iterations \nclass\nGFG \n{ \n// A O(n) C++ program to count \n// even length binary sequences \n// such that the sum of first \n// and second half bits is same \n\n// Returns the count of \n// even length sequences \nstatic\nint\ncountSeq(\nint\nn) \n{ \n\nint\nnCr = \n1\n, res = \n1\n; \n\n\n// Calculate SUM ((nCr)^2) \n\nfor\n(\nint\nr = \n1\n; r <= n ; r++) \n\n{ \n\n// Compute nCr using nC(r-1) \n\n// nCr/nC(r-1) = (n+1-r)/r; \n\nnCr = (nCr * (n + \n1\n- r)) / r; \n\n\nres += nCr * nCr; \n\n} \n\n\nreturn\nres; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.print(\n\"Count of sequences is \"\n); \n\nSystem.out.println(countSeq(n)); \n} \n} \n\n// This code is contributed \n// by Shivi_Aggarwal ", "index": 252, "complexity": 3}
{"back-translation": "public class Main {\n    public static void main(String[] args) throws java.lang.Exception {\n        Scanner s = new Scanner(System.in);\n        int n = Integer.parseInt(s.nextLine());\n        int ans = Integer.MAX_VALUE;\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextInt();\n        }\n        for (int i = 1; i < n; i++) {\n            ans = Math.min(ans, Math.min(arr[i], arr[0]) / i);\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            ans = Math.min(ans, Math.min(arr[n - 1], arr[i]) / (n - i - 1));\n        }\n        System.out.println(ans);\n    }\n}", "src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint arr[] = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tans = Math.min(ans, Math.min(arr[i],arr[0])/i);\n\t\t}\n\t\tfor (int i=n-2;i>=0;i--){\n\t\t\tans = Math.min(ans, Math.min(arr[n-1],arr[i])/(n-i-1));\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 253, "complexity": 3}
{"back-translation": "class GfG { static class node { int data; node left, right; } static int updatetree(node root) { if (root == null) return 0; if (root.left == null && root.right == null) return root.data; int leftsum = updatetree(root.left); int rightsum = updatetree(root.right); root.data += leftsum; return root.data + rightsum; } static void inorder(node node) { if (node == null) return; inorder(node.left); System.out.print(node.data + \" \"); inorder(node.right); } static node newNode(int data) { node node = new node(); node.data = data; node.left = null; node.right = null; return (node); } public static void main(String[] args) { node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); root.right.right = newNode(6); updatetree(root); System.out.println(\"Inorder traversal of the modified tree is\"); inorder(root); } }", "src": "\n// Java program to store sum of nodes in left subtree in every \n// node \nclass\nGfG { \n\n// A tree node \nstatic\nclass\nnode \n{ \n\nint\ndata; \n\nnode left, right; \n} \n\n// Function to modify a Binary Tree so that every node \n// stores sum of values in its left child including its \n// own value \nstatic\nint\nupdatetree(node root) \n{ \n\n// Base cases \n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\nroot.data; \n\n\n// Update left and right subtrees \n\nint\nleftsum = updatetree(root.left); \n\nint\nrightsum = updatetree(root.right); \n\n\n// Add leftsum to current node \n\nroot.data += leftsum; \n\n\n// Return sum of values under root \n\nreturn\nroot.data + rightsum; \n} \n\n// Utility function to do inorder traversal \nstatic\nvoid\ninorder(node node) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\ninorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorder(node.right); \n} \n\n// Utility function to create a new node \nstatic\nnode newNode(\nint\ndata) \n{ \n\nnode node = \nnew\nnode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n// Driver program \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n/* Let us construct below tree \n\n1 \n\n/ \\ \n\n2 3 \n\n/ \\ \\ \n\n4 5 6 */\n\nnode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.right.right = newNode(\n6\n); \n\n\nupdatetree(root); \n\n\n\nSystem.out.println(\n\"Inorder traversal of the modified tree is\"\n); \n\ninorder(root); \n} \n} ", "index": 255, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tint i = 0;\n\t\twhile(i < n)\n\t\t{\n\t\t\tcnt += in.nextInt();\n\t\t\ti++;\n\t\t}\n\t\t\n\t\ti = 0;\n\t\twhile(i < n)\n\t\t{\n\t\t\tcnt -= in.nextInt();\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}\n", "src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}\n", "index": 256, "complexity": 3}
{"back-translation": "class GFG { static class Node { int data; Node left; Node right; Node(int data) { this.data = data; left = null; right = null; } } static void levelOrder(Node root) { if(root == null) return; Queue<Node> q = new LinkedList<>(); q.add(root); q.add(null); while(!q.isEmpty()) { Node curr = q.poll(); if(curr == null) { if(!q.isEmpty()) { q.add(null); System.out.println(); } } else { if(curr.left != null) q.add(curr.left); if(curr.right != null) q.add(curr.right); System.out.print(curr.data + \" \"); } } } public static void main(String[] args) { Node root = new Node(1); root.left = new Node(2); root.right = new Node(3); root.left.left = new Node(4); root.left.right = new Node(5); root.right.right = new Node(6); levelOrder(root); } }", "src": "\n// Java program to do level order \n// traversal line by line \nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \n\npublic\nclass\nGFG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n// Prints level order traversal line \n\n// by line using two queues. \n\nstatic\nvoid\nlevelOrder(Node root) { \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\n\n// Pushing root node into the queue. \n\nq.add(root); \n\n\n// Pushing delimiter into the queue. \n\nq.add(\nnull\n); \n\n\n// Executing loop till queue becomes \n\n// empty \n\nwhile\n(!q.isEmpty()) { \n\n\nNode curr = q.poll(); \n\n\n// condition to check the \n\n// occurence of next level \n\nif\n(curr == \nnull\n) { \n\nif\n(!q.isEmpty()) { \n\nq.add(\nnull\n); \n\nSystem.out.println(); \n\n} \n\n} \nelse\n{ \n\n// Pushing left child current node \n\nif\n(curr.left != \nnull\n) \n\nq.add(curr.left); \n\n\n// Pushing right child current node \n\nif\n(curr.right != \nnull\n) \n\nq.add(curr.right); \n\n\nSystem.out.print(curr.data + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nlevelOrder(root); \n\n} \n} \n\n// This code is Contributed by Rishabh Jindal ", "index": 257, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class Waw {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = sc.nextLong();\n        long[] p = new long[n];\n        p[n - 1] = a[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            if (a[i] < p[i + 1]) p[i] = p[i + 1] - 1;\n            else p[i] = a[i];\n        }\n        long max = p[0];\n        long res = p[0] - a[0];\n        for (int i = 1; i < n; i++) {\n            if (max < p[i]) max = p[i];\n            res += max - a[i];\n        }\n        System.out.println(res);\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\npublic class Waw{\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i=0;i<n;i++) a[i] = sc.nextLong();\n        long[] p = new long[n];\n        p[n-1] = a[n-1];\n        for(int i=n-2;i>=0;i--){\n            if(a[i]<p[i+1]) p[i] = p[i+1]-1;\n            else p[i] = a[i];\n        }\n        long max = p[0];\n        long res = p[0] - a[0];\n        for(int i=1;i<n;i++){\n            if(max < p[i]) max = p[i];\n            res += max - a[i];\n        }\n        System.out.println(res);\n    }\n}", "index": 258, "complexity": 3}
{"back-translation": "import java.util.*;\n \npublic class Main {\n \n    public static void main(String[] args) {\n\t// write your code here\n        Scanner scan = new Scanner(System.in);\n        int T = scan.nextInt();\n        while(T > 0) {\n            int n = scan.nextInt();\n            int[] arr = new int[n];\n            for(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n            int m1 = 1, m2 = 1;\n            for(int i = 0; i < n; i++) {\n                if(arr[i] >= m1) {\n                    m2 = m1;\n                    m1 = arr[i];\n                } else if (arr[i] >= m2) {\n                    m2 = arr[i];\n                }\n            }\n            System.out.println(Math.min(Math.min(m1, m2) - 1, n - 2));\n            T--;\n        }\n    }\n}", "src": "import java.util.*;\n \npublic class Main {\n \n    public static void main(String[] args) {\n\t// write your code here\n        Scanner scan = new Scanner(System.in);\n        int T = scan.nextInt();\n        for(; T > 0; T--) {\n            int n = scan.nextInt();\n            int[] arr = new int[n];\n            for(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n            int m1 = 1, m2 = 1;\n            for(int i = 0; i < n; i++) {\n                if(arr[i] >= m1) {\n                    m2 = m1;\n                    m1 = arr[i];\n                } else if (arr[i] >= m2) {\n                    m2 = arr[i];\n                }\n            }\n            System.out.println(Math.min(Math.min(m1, m2) - 1, n - 2));\n        }\n    }\n}", "index": 260, "complexity": 3}
{"back-translation": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D2C982_cut_them_all solver = new D2C982_cut_them_all();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D2C982_cut_them_all {\n        int n;\n        ArrayList<Integer>[] adj;\n        int[] sizes;\n        boolean[] visited;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            n = in.nextInt();\n            if ((n & 1) == 1) {\n                out.println(-1);\n                return;\n            }\n            sizes = new int[n];\n            visited = new boolean[n];\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            for (int i = 1; i < n; i++) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n\n            int root = 0;\n            for (int i = 1; i < n; i++) {\n                if (adj[i].size() > adj[root].size()) {\n                    root = i;\n                }\n            }\n\n            dfs(root);\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if ((sizes[i] & 1) == 0) cnt++;\n            }\n            out.println(cnt - 1);\n\n        }\n\n        int dfs(int u) {\n\n            visited[u] = true;\n            int cnt = 1;\n\n            for (int w : adj[u])\n                if (!visited[w])\n                    cnt += dfs(w);\n\n            sizes[u] = cnt;\n            return cnt;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n    }\n\n    static boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author El-Bishoy\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D2C982_cut_them_all solver = new D2C982_cut_them_all();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D2C982_cut_them_all {\n        int n;\n        ArrayList<Integer>[] adj;\n        int[] sizes = new int[n];\n        boolean[] visited = new boolean[n];\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            n = in.nextInt();\n            if ((n & 1) == 1) {\n                out.println(-1);\n                return;\n            }\n            sizes = new int[n];\n            visited = new boolean[n];\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            for (int i = 1; i < n; i++) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n\n            int root = 0;\n            for (int i = 1; i < n; i++) {\n                if (adj[i].size() > adj[root].size()) {\n                    root = i;\n                }\n            }\n\n            dfs(root);\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if ((sizes[i] & 1) == 0) cnt++;\n            }\n            out.println(cnt - 1);\n\n        }\n\n        int dfs(int u) {\n\n            visited[u] = true;\n            int cnt = 1;\n\n            for (int w : adj[u])\n                if (!visited[w])\n                    cnt += dfs(w);\n\n            sizes[u] = cnt;\n            return cnt;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "index": 261, "complexity": 3}
{"back-translation": "import java.util.Stack; public class GFG { static class Node { int data; Node left, right; public Node(int data) { this.data = data; left = null; right = null; } } static Node root1; static Node root2; static int countPairs(Node root1, Node root2, int x) { if (root1 == null || root2 == null) return 0; Stack<Node> st1 = new Stack<>(); Stack<Node> st2 = new Stack<>(); Node top1, top2; int count = 0; while (true) { while (root1 != null) { st1.push(root1); root1 = root1.left; } while (root2 != null) { st2.push(root2); root2 = root2.right; } if (st1.empty() || st2.empty()) break; top1 = st1.peek(); top2 = st2.peek(); if ((top1.data + top2.data) == x) { count++; st1.pop(); st2.pop(); root1 = top1.right; root2 = top2.left; } else if ((top1.data + top2.data) < x) { st1.pop(); root1 = top1.right; } else { st2.pop(); root2 = top2.left; } } return count; } public static void main(String args[]) { root1 = new Node(5); root1.left = new Node(3); root1.right = new Node(7); root1.left.left = new Node(2); root1.left.right = new Node(4); root1.right.left = new Node(6); root1.right.right = new Node(8); root2 = new Node(10); root2.left = new Node(6); root2.right = new Node(15); root2.left.left = new Node(3); root2.left.right = new Node(8); root2.right.left = new Node(11); root2.right.right = new Node(18); int x = 16; System.out.println(\"Pairs = \" + countPairs(root1, root2, x)); } }", "src": "\n// Java implementation to count pairs from two \n// BSTs whose sum is equal to a given value x \nimport\njava.util.Stack; \npublic\nclass\nGFG { \n\n\n// structure of a node of BST \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n// constructor \n\npublic\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\nstatic\nNode root1; \n\nstatic\nNode root2; \n\n// function to count pairs from two BSTs \n\n// whose sum is equal to a given value x \n\nstatic\nint\ncountPairs(Node root1, Node root2, \n\nint\nx) \n\n{ \n\n// if either of the tree is empty \n\nif\n(root1 == \nnull\n|| root2 == \nnull\n) \n\nreturn\n0\n; \n\n\n// stack 'st1' used for the inorder \n\n// traversal of BST 1 \n\n// stack 'st2' used for the reverse \n\n// inorder traversal of BST 2 \n\n//stack<Node*> st1, st2; \n\nStack<Node> st1 = \nnew\nStack<>(); \n\nStack<Node> st2 = \nnew\nStack<>(); \n\nNode top1, top2; \n\n\nint\ncount = \n0\n; \n\n\n// the loop will break when either of two \n\n// traversals gets completed \n\nwhile\n(\ntrue\n) { \n\n\n// to find next node in inorder \n\n// traversal of BST 1 \n\nwhile\n(root1 != \nnull\n) { \n\nst1.push(root1); \n\nroot1 = root1.left; \n\n} \n\n\n// to find next node in reverse \n\n// inorder traversal of BST 2 \n\nwhile\n(root2 != \nnull\n) { \n\nst2.push(root2); \n\nroot2 = root2.right; \n\n} \n\n\n// if either gets empty then corresponding \n\n// tree traversal is completed \n\nif\n(st1.empty() || st2.empty()) \n\nbreak\n; \n\n\ntop1 = st1.peek(); \n\ntop2 = st2.peek(); \n\n\n// if the sum of the node's is equal to 'x' \n\nif\n((top1.data + top2.data) == x) { \n\n// increment count \n\ncount++; \n\n\n// pop nodes from the respective stacks \n\nst1.pop(); \n\nst2.pop(); \n\n\n// insert next possible node in the \n\n// respective stacks \n\nroot1 = top1.right; \n\nroot2 = top2.left; \n\n} \n\n\n// move to next possible node in the \n\n// inoder traversal of BST 1 \n\nelse\nif\n((top1.data + top2.data) < x) { \n\nst1.pop(); \n\nroot1 = top1.right; \n\n} \n\n\n// move to next possible node in the \n\n// reverse inoder traversal of BST 2 \n\nelse\n{ \n\nst2.pop(); \n\nroot2 = top2.left; \n\n} \n\n} \n\n\n// required count of pairs \n\nreturn\ncount; \n\n} \n\n\n// Driver program to test above \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n// formation of BST 1 \n\nroot1 = \nnew\nNode(\n5\n); \n/* 5 */\n\nroot1.left = \nnew\nNode(\n3\n); \n/* / \\ */\n\nroot1.right = \nnew\nNode(\n7\n); \n/* 3 7 */\n\nroot1.left.left = \nnew\nNode(\n2\n); \n/* / \\ / \\ */\n\nroot1.left.right = \nnew\nNode(\n4\n); \n/* 2 4 6 8 */\n\nroot1.right.left = \nnew\nNode(\n6\n); \n\nroot1.right.right = \nnew\nNode(\n8\n); \n\n\n// formation of BST 2 \n\nroot2 = \nnew\nNode(\n10\n); \n/* 10 */\n\nroot2.left = \nnew\nNode(\n6\n); \n/* / \\ */\n\nroot2.right = \nnew\nNode(\n15\n); \n/* 6 15 */\n\nroot2.left.left = \nnew\nNode(\n3\n); \n/* / \\ / \\ */\n\nroot2.left.right = \nnew\nNode(\n8\n); \n/* 3 8 11 18 */\n\nroot2.right.left = \nnew\nNode(\n11\n); \n\nroot2.right.right = \nnew\nNode(\n18\n); \n\n\nint\nx = \n16\n; \n\nSystem.out.println(\n\"Pairs = \"\n\n+ countPairs(root1, root2, x)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "index": 262, "complexity": 3}
{"back-translation": "class GFG {\n\n    static int countOccurrences(String s, int K) {\n        int n = s.length();\n        int C = 0, c1 = 0, c2 = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == 'a')\n                c1++;\n\n            if (s.charAt(i) == 'b') {\n                c2++;\n                C += c1;\n            }\n        }\n\n        return C * K + (K * (K - 1) / 2) * c1 * c2;\n    }\n\n    public static void main(String[] args) {\n        String S = \"abcb\";\n        int k = 2;\n\n        System.out.println(countOccurrences(S, k));\n    }\n}", "src": "\n// Java code to find number of subsequences of \n// \"ab\" in the string S which is repeated K times. \n\nimport\njava.io.*; \n\nclass\nGFG { \n\n\nstatic\nint\ncountOccurrences(String s, \nint\nK) \n\n{ \n\nint\nn = s.length(); \n\nint\nC = \n0\n, c1 = \n0\n, c2 = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(s.charAt(i) == \n'a'\n) \n\nc1++; \n// Count of 'a's \n\nif\n(s.charAt(i) == \n'b'\n) { \n\nc2++; \n// Count of 'b's \n\n\n// occurrence of \"ab\"s \n\n// in string S \n\nC += c1; \n\n} \n\n} \n\n\n// Add following two : \n\n// 1) K * (Occurrences of \"ab\" in single string) \n\n// 2) a is from one string and b is from other. \n\nreturn\nC * K + (K * (K - \n1\n) / \n2\n) * c1 * c2; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString S = \n\"abcb\"\n; \n\nint\nk = \n2\n; \n\n\nSystem.out.println(countOccurrences(S, k)); \n\n} \n} \n\n// This code is contributed by vt_m. ", "index": 263, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class FirstClass {\n\t\n\tpublic static void main(String[] args)throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tint[] arr = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n\t\t\n\t\tint max = -1;\n\t\tboolean flag = true;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t{\n\t\t\tif(arr[i] > max+1)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tout.println(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmax = Math.max(max, arr[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(flag)\n\t\t\tout.println(-1);\n\t\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n}", "src": "import java.util.*;\nimport java.io.*;\n\npublic class FirstClass {\n\t\n\tpublic static void main(String[] args)throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tint arr[] = new int [n];\n\t\t\n\t\tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t{\n\t\t\tarr[i] = Integer.parseInt(st1.nextToken());\n\t\t}\n\t\t\n\t\tint max = -1;\n\t\tboolean flag = true;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t{\n\t\t\tif(arr[i] > max+1)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tout.println(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmax = Math.max(max, arr[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(flag)\n\t\t\tout.println(-1);\n\t\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n}\n", "index": 267, "complexity": 3}
{"back-translation": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Equator {\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n    public static StringTokenizer st;\n    \n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        int[] a = intArray(n);\n        \n        long s = 0;\n        for (int x : a)\n            s += x;\n        \n        long m = 0;\n        for (int i = 0; i < n; i++) {\n            m += a[i];\n            if (m * 2 >= s) {\n                System.out.println(i + 1);\n                return;\n            }\n        }\n    }\n    \n    public static String nextLine() throws IOException {\n        return in.readLine();\n    }\n\n    public static String nextString() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(in.readLine());\n        return st.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(nextString());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(nextString());\n    }\n\n    public static int[] intArray(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextInt();\n        return a;\n    }\n\n    public static int[][] intArray(int n, int m) throws IOException {\n        int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                a[i][j] = nextInt();\n        return a;\n    }\n\n    public static long[] longArray(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextLong();\n        return a;\n    }\n}", "src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Equator {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint[] a = intArray(n);\n\t\t\n\t\tlong s = 0;\n\t\tfor (int x : a)\n\t\t\ts += x;\n\t\t\n\t\tlong m = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tm += a[i];\n\t\t\tif (m*2 >= s) {\n\t\t\t\tSystem.out.println(i+1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 269, "complexity": 3}
{"back-translation": "public class CompleteBTree { static class Node { int data; Node left; Node right; Node(int d) { data = d; left = null; right = null; } } static boolean isCompleteBT(Node root) { if (root == null) return true; Queue<Node> queue = new LinkedList<>(); boolean flag = false; queue.add(root); while (!queue.isEmpty()) { Node temp_node = queue.remove(); if (temp_node.left != null) { if (flag == true) return false; queue.add(temp_node.left); } else flag = true; if (temp_node.right != null) { if (flag == true) return false; queue.add(temp_node.right); } else flag = true; } return true; } public static void main(String[] args) { Node root = new Node(1); root.left = new Node(2); root.right = new Node(3); root.left.left = new Node(4); root.left.right = new Node(5); root.right.right = new Node(6); if (isCompleteBT(root) == true) System.out.println(\"Complete Binary Tree\"); else System.out.println(\"NOT Complete Binary Tree\"); } }", "src": "\n//A Java program to check if a given binary tree is complete or not \n\nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \n\npublic\nclass\nCompleteBTree \n{ \n\n/* A binary tree node has data, a pointer to left child \n\nand a pointer to right child */\n\nstatic\nclass\nNode \n\n{ \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\n// Constructor \n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n/* Given a binary tree, return true if the tree is complete \n\nelse false */\n\nstatic\nboolean\nisCompleteBT(Node root) \n\n{ \n\n// Base Case: An empty tree is complete Binary Tree \n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// Create an empty queue \n\nQueue<Node> queue =\nnew\nLinkedList<>(); \n\n\n// Create a flag variable which will be set true \n\n// when a non full node is seen \n\nboolean\nflag = \nfalse\n; \n\n\n// Do level order traversal using queue. \n\nqueue.add(root); \n\nwhile\n(!queue.isEmpty()) \n\n{ \n\nNode temp_node = queue.remove(); \n\n\n/* Check if left child is present*/\n\nif\n(temp_node.left != \nnull\n) \n\n{ \n\n// If we have seen a non full node, and we see a node \n\n// with non-empty left child, then the given tree is not \n\n// a complete Binary Tree \n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n// Enqueue Left Child \n\nqueue.add(temp_node.left); \n\n} \n\n// If this a non-full node, set the flag as true \n\nelse\n\nflag = \ntrue\n; \n\n\n/* Check if right child is present*/\n\nif\n(temp_node.right != \nnull\n) \n\n{ \n\n// If we have seen a non full node, and we see a node \n\n// with non-empty right child, then the given tree is not \n\n// a complete Binary Tree \n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n// Enqueue Right Child \n\nqueue.add(temp_node.right); \n\n\n} \n\n// If this a non-full node, set the flag as true \n\nelse\n\nflag = \ntrue\n; \n\n} \n\n// If we reach here, then the tree is complete Binary Tree \n\nreturn\ntrue\n; \n\n} \n\n\n/* Driver program to test above functions*/\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n/* Let us construct the following Binary Tree which \n\nis not a complete Binary Tree \n\n1 \n\n/ \\ \n\n2 3 \n\n/ \\ \\ \n\n4 5 6 \n\n*/\n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nif\n(isCompleteBT(root) == \ntrue\n) \n\nSystem.out.println(\n\"Complete Binary Tree\"\n); \n\nelse\n\nSystem.out.println(\n\"NOT Complete Binary Tree\"\n); \n\n} \n\n} \n//This code is contributed by Sumit Ghosh ", "index": 270, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  static Scanner in = new Scanner(System.in);\n  static PrintWriter out = new PrintWriter(System.out);\n  \n  public static void main(String[] args) {\n    int n = in.nextInt();\n    int m = in.nextInt();\n    long boyMax = 0;\n    int NBoyMax = 0;\n\n    long sweets = 0;\n    TreeSet<Long> boyMember = new TreeSet<>();\n    for (int i = 0; i < n; i++) {\n      long input = in.nextLong();\n      boyMember.add(input);\n      if (boyMax < input) {\n        boyMax = input;\n        NBoyMax = 1;\n      } else if (boyMax == input) {\n        NBoyMax++;\n      }\n      sweets += (input * m);\n    }\n\n    long smallestGirl = (long) 1e8 + 1;\n    long sum = 0;\n    for (int i = 0; i < m; i++) {\n      long input = in.nextLong();\n      sum += input;\n      if (smallestGirl > input) {\n        smallestGirl = input;\n      }\n    }\n\n    if (smallestGirl < boyMember.last()) {\n      out.println(-1);\n    } else if (smallestGirl == boyMember.last()) {\n      sweets += (sum - boyMember.last() * m);\n      out.println(sweets);\n    } else {\n\n      if (NBoyMax > 1) {\n        sweets += (sum - boyMember.last() * m);\n        out.println(sweets);\n      } else {\n        Object[] boyList = boyMember.toArray();\n        if (boyList.length > 1) {\n          long boy = 0;\n          boy = (long) boyList[boyList.length - 2];\n          sweets += (sum - smallestGirl - boyMember.last() * (m - 1));\n          sweets += (smallestGirl - boy);\n          out.println(sweets);\n        } else {\n          out.println(-1);\n        }\n      }\n    }\n\n    in.close();\n    out.close();\n  }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  static Scanner in = new Scanner(System.in);\n  static PrintWriter out = new PrintWriter(System.out);\n  \n  public static void main(String[] args) {\n    int n = in.nextInt();\n    int m = in.nextInt();\n    long boyMax = 0;\n    int NBoyMax = 0;\n\n    long sweets = 0;\n    TreeSet<Long> boyMember = new TreeSet<>();\n    for (int i = 0; i < n; i++) {\n      long input = in.nextLong();\n      boyMember.add(input);\n      if (boyMax < input) {\n        boyMax = input;\n        NBoyMax = 1;\n      } else if (boyMax == input) NBoyMax++;\n      sweets += (input * m);\n    }\n\n    long smallestGirl = (long) 1e8 + 1;\n    long sum = 0;\n    for (int i = 0; i < m; i++) {\n      long input = in.nextLong();\n      sum += input;\n      if (smallestGirl > input) smallestGirl = input;\n    }\n\n    if (smallestGirl < boyMember.last()) {\n      out.println(-1);\n    } else if (smallestGirl == boyMember.last()) {\n      sweets += sum - boyMember.last() * m;\n      out.println(sweets);\n    } else {\n\n      if (NBoyMax > 1) {\n        sweets += sum - boyMember.last() * m;\n        out.println(sweets);\n      } else {\n        Object[] boyList = boyMember.toArray();\n        if (boyList.length > 1) {\n          long boy = 0;\n          boy = (long)boyList[boyList.length - 2];\n          sweets += (sum - smallestGirl - boyMember.last() * (m - 1));\n          sweets += (smallestGirl - boy);\n          out.println(sweets);\n        } else {\n          out.println(-1);\n        }\n      }\n    }\n\n    in.close();\n    out.close();\n  }\n}", "index": 271, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Solution {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString s = sc.next();\n\n\t\tStringBuilder ans = new StringBuilder();\n\t\tint count = 0;\n\t\tint open = 0;\n\t\tint i = 0;\n\t\twhile (i < s.length()) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tans.append(\"(\");\n\t\t\t\tcount++;\n\t\t\t\topen++;\n\t\t\t} else {\n\t\t\t\tans.append(\")\");\n\t\t\t\topen--;\n\t\t\t}\n\t\t\tif (count == k / 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\twhile (open > 0) {\n\t\t\tans.append(\")\");\n\t\t\topen--;\n\t\t}\n\t\tSystem.out.println(ans.toString());\n\t}\n}", "src": "import java.util.Scanner;\n\npublic class Solution {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString s = sc.next();\n\n\t\tStringBuilder ans = new StringBuilder();\n\t\tint count = 0;\n\t\tint open = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tans.append(\"(\");\n\t\t\t\tcount++;\n\t\t\t\topen++;\n\t\t\t} else {\n\t\t\t\tans.append(\")\");\n\t\t\t\topen--;\n\t\t\t}\n\t\t\tif (count == k / 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile (open > 0) {\n\t\t\tans.append(\")\");\n\t\t\topen--;\n\t\t}\n\t\tSystem.out.println(ans.toString());\n\t}\n}", "index": 272, "complexity": 3}
{"back-translation": "class GFG {\n    public static int sumOfSubstrings(String num) {\n        int n = num.length();\n        int[] sumofdigit = new int[n];\n        sumofdigit[0] = num.charAt(0) - '0';\n        int res = sumofdigit[0];\n        for (int i = 1; i < n; i++) {\n            int numi = num.charAt(i) - '0';\n            sumofdigit[i] = (i + 1) * numi + 10 * sumofdigit[i - 1];\n            res += sumofdigit[i];\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        String num = \"1234\";\n        System.out.println(sumOfSubstrings(num));\n    }\n}", "src": "\n// Java program to print sum of all substring of \n// a number represented as a string \nimport\njava.util.Arrays; \n\nclass\nGFG{ \n\n\n// Returns sum of all substring of num \n\npublic\nstatic\nint\nsumOfSubstrings(String num) \n\n{ \n\nint\nn = num.length(); \n\n\n// allocate memory equal to length of string \n\nint\nsumofdigit[] = \nnew\nint\n[n]; \n\n\n// initialize first value with first digit \n\nsumofdigit[\n0\n] = num.charAt(\n0\n)-\n'0'\n; \n\nint\nres = sumofdigit[\n0\n]; \n\n\n// loop over all digits of string \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nint\nnumi = num.charAt(i)-\n'0'\n; \n\n\n// update each sumofdigit from previous value \n\nsumofdigit[i] = (i+\n1\n) * numi + \n\n10\n* sumofdigit[i-\n1\n]; \n\n\n// add current value to the result \n\nres += sumofdigit[i]; \n\n} \n\n\nreturn\nres; \n\n} \n\n\n// Driver code to test above methods \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString num = \n\"1234\"\n; \n\n\nSystem.out.println(sumOfSubstrings(num)); \n\n\n} \n} \n// This code is contributed by Arnav Kr. Mandal. ", "index": 273, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class round569d2b {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tif (n % 2 == 0) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint max = Integer.MIN_VALUE;\n\t\t\tint maxIndex = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint elem = arr[i];\n\t\t\t\tif (elem < 0) {\n\t\t\t\t\telem = -1*elem-1;\n\t\t\t\t}\n\t\t\t\tif (elem > max) {\n\t\t\t\t\tmax = elem;\n\t\t\t\t\tmaxIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i == maxIndex) {\n\t\t\t\t\tif (arr[i] < 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < n ;i++) {\n\t\t\tsb.append(arr[i] + \" \");\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t// ======================================================================================\n\t// =============================== Reference Code =======================================\n\t// ======================================================================================\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t// Method to return all primes smaller than or equal to \n\t// n using Sieve of Eratosthenes \n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t// Create a boolean array \"prime[0..n]\" and initialize \n\t\t// all entries it as true. A value in prime[i] will \n\t\t// finally be false if i is Not a prime, else true. \n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t// If prime[p] is not changed, then it is a prime \n\t\t\tif (prime[p] == true) {\n\t\t\t\t// Update all multiples of p \n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t// Binary search for number greater than or equal to target\n\t// returns -1 if number not found\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t// Base Case \n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; // To store results of recursive call \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t// Update x and y using results of recursive \n\t\t// call \n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t// Returns modulo inverse of a  \n\t// with respect to m using extended \n\t// Euclid Algorithm. Refer below post for details: \n\t// https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/ \n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t// Apply extended Euclid Algorithm \n\t\twhile (a > 1) {\n\t\t\t// q is quotient \n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t// m is remainder now, process \n\t\t\t// same as euclid's algo \n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t// Make x1 positive \n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t// k is size of num[] and rem[]. \n\t// Returns the smallest number \n\t// x such that: \n\t// x % num[0] = rem[0], \n\t// x % num[1] = rem[1], \n\t// .................. \n\t// x % num[k-2] = rem[k-1] \n\t// Assumption: Numbers in num[] are pairwise  \n\t// coprime (gcd for every pair is 1) \n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t// Compute product of all numbers \n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t// Initialize result \n\t\tint result = 0;\n\n\t\t// Apply above formula \n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t/**\n\t * Source: Matt Fontaine\n\t */\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 276, "complexity": 3}
{"back-translation": "class GFG { static int max(int x, int y) { return (x > y ? x : y); } static int maxTasks(int[] high, int[] low, int n) { int[] task_dp = new int[n + 1]; task_dp[0] = 0; task_dp[1] = high[0]; for (int i = 2; i <= n; i++) task_dp[i] = Math.max(high[i - 1] + task_dp[i - 2], low[i - 1] + task_dp[i - 1]); return task_dp[n]; } public static void main(String[] args) { int n = 5; int[] high = {3, 6, 8, 7, 6}; int[] low = {1, 5, 4, 5, 3}; System.out.println(maxTasks(high, low, n)); } }", "src": "\n// A DP based Java program to find maximum tasks. \nclass\nGFG \n{ \n\n// Returns the maximum among the 2 numbers \nstatic\nint\nmax(\nint\nx, \nint\ny) \n{ \n\nreturn\n(x > y ? x : y); \n} \n\n// Returns maximum amount of task that can be \n// done till day n \nstatic\nint\nmaxTasks(\nint\n[]high, \nint\n[]low, \nint\nn) \n{ \n\n// An array task_dp that stores the maximum \n\n// task done \n\nint\n[] task_dp = \nnew\nint\n[n + \n1\n]; \n\n\n// If n = 0, no solution exists \n\ntask_dp[\n0\n] = \n0\n; \n\n\n// If n = 1, high effort task on that day will \n\n// be the solution \n\ntask_dp[\n1\n] = high[\n0\n]; \n\n\n// Fill the entire array determining which \n\n// task to choose on day i \n\nfor\n(\nint\ni = \n2\n; i <= n; i++) \n\ntask_dp[i] = Math.max(high[i - \n1\n] + task_dp[i - \n2\n], \n\nlow[i - \n1\n] + task_dp[i - \n1\n]); \n\nreturn\ntask_dp[n]; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n5\n; \n\nint\n[]high = {\n3\n, \n6\n, \n8\n, \n7\n, \n6\n}; \n\nint\n[]low = {\n1\n, \n5\n, \n4\n, \n5\n, \n3\n}; \n\nSystem.out.println(maxTasks(high, low, n)); \n} \n} \n\n// This code is contributed by Code_Mech. ", "index": 277, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Cheast {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] l = new int[n];\n        l[0] = sc.nextInt();\n        int x = 1;\n        int c = 1;\n        for (int i = 1; i < n; i++) {\n            l[i] = sc.nextInt();\n            if (l[i] <= l[i - 1] * 2) {\n                c++;\n                x = Integer.max(x, c);\n            } else {\n                c = 1;\n            }\n        }\n        System.out.println(x);\n    }\n}\n", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Cheast {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] l = new int[n];\n        l[0] = sc.nextInt();\n        int x=1;\n        int c=1;\n        for (int i=1;i<n;i++) {\n            l[i] = sc.nextInt();\n            if (l[i] <= l[i-1]*2) {\n                c++;\n                x = Math.max(x,c);\n            }\n            else\n                c = 1;\n        }\n        System.out.println(x);\n\n\n\n    }\n}\n", "index": 278, "complexity": 3}
{"back-translation": "import java.util.*;\npublic class Main {\n\n    public static void main(String args[]) {\n        Scanner scan = new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        int[] game=new int[n];\n        int[] bill=new int[m];\n        for (int i = 0; i <n ; i++) {\n            game[i]=scan.nextInt();\n        }\n        for (int i = 0; i <m ; i++) {\n            bill[i]=scan.nextInt();\n        }\n        int i=0;\n        int j=0;\n        int ans=0;\n        while (i<m){\n            boolean f=true;\n            for (int k = j; k <n ; k++) {\n                if (bill[i]>=game[k]){\n                    ans++;\n                    i++;\n                    j=k+1;\n                    f=false;\n                    break;\n                }\n            }\n            if (f){\n                break;\n            }\n        }\n        System.out.println(ans);\n    }\n}", "src": "import java.util.*;\npublic class Main {\n\n    public static void main(String args[]) {\n        Scanner scan = new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        int[] game=new int[n];\n        int[] bill=new int[m];\n        for (int i = 0; i <n ; i++) {\n            game[i]=scan.nextInt();\n        }\n        for (int i = 0; i <m ; i++) {\n            bill[i]=scan.nextInt();\n        }\n        int i=0;\n        int j=0;\n        int ans=0;\n        while (i<m){\n            boolean f=true;\n            for (int k = j; k <n ; k++) {\n                if (bill[i]>=game[k]){\n                    ans++;\n                    i++;\n                    j=k+1;\n                    f=false;\n                    break;\n                }\n            }\n            if (f){\n                break;\n            }\n        }\n        System.out.println(ans);\n    }\n}\n\n\n", "index": 279, "complexity": 3}
{"back-translation": "import java.util.Arrays;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args)\n    {\n        Scanner stdin = new Scanner(System.in);\n        test(stdin);\n        stdin.close();\n    }\n    public static void test(Scanner stdin)\n    {\n        int n = stdin.nextInt();\n        int min = Integer.MAX_VALUE;\n        for(int i = 0; i < n; i++)\n        {\n            int a = stdin.nextInt();\n            if((int)((1.0)*a/(Math.max(i, n - i - 1))) < min)\n            { min = (int)((1.0)*a/(Math.max(i, n - i - 1))); }\n        }\n        System.out.println(min);\n    }\n}", "src": "import java.util.Arrays;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args)\n    {\n        Scanner stdin = new Scanner(System.in);\n        /*int n = stdin.nextInt();\n        for(int i = 0; i < n; i++)\n        {\n        \ttest(stdin);\n        }*/\n        test(stdin);\n        stdin.close();\n    }\n    public static void test(Scanner stdin)\n    {\n    \tint n = stdin.nextInt();\n    \tint min = Integer.MAX_VALUE;\n    \tfor(int i = 0; i < n; i++)\n    \t{\n    \t\tint a = stdin.nextInt();\n    \t\tif((int)((1.0)*a/(Math.max(i, n - i - 1))) < min)\n    \t\t{ min = (int)((1.0)*a/(Math.max(i, n - i - 1))); }\n    \t}\n    \tSystem.out.println(min);\n    }\n}", "index": 280, "complexity": 3}
{"back-translation": "class GfG { public static int minMaxProduct(int[] arr1, int[] arr2, int n1, int n2) { int max = arr1[0]; int min = arr2[0]; int i; for (i = 1; i < n1 && i < n2; ++i) { if (arr1[i] > max) max = arr1[i]; if (arr2[i] < min) min = arr2[i]; } while (i < n1) { if (arr1[i] > max) max = arr1[i]; i++; } while (i < n2) { if (arr2[i] < min) min = arr2[i]; i++; } return max * min; } public static void main(String argc[]) { int[] arr1 = new int[]{ 10, 2, 3, 6, 4, 1}; int[] arr2 = new int[]{ 5, 1, 4, 2, 6, 9}; int n1 = 6; int n2 = 6; System.out.println(minMaxProduct(arr1, arr2, n1, n2)); } }", "src": "\n// Java program to calculate the \n// product of max element of first \n// array and min element of second array \nimport\njava.util.*; \nimport\njava.lang.*; \n\nclass\nGfG \n{ \n\n\n// Function to calculate the product \n\npublic\nstatic\nint\nminMaxProduct(\nint\narr1[], \n\nint\narr2[], \n\nint\nn1, \n\nint\nn2) \n\n{ \n\n\n// Initialize max of \n\n// first array \n\nint\nmax = arr1[\n0\n]; \n\n\n// initialize min of \n\n// second array \n\nint\nmin = arr2[\n0\n]; \n\n\nint\ni; \n\nfor\n(i = \n1\n; i < n1 && i < n2; ++i) \n\n{ \n\n\n// To find the maximum \n\n// element in first array \n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\n\n// To find the minimum element \n\n// in second array \n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\n} \n\n\n// Process remaining elements \n\nwhile\n(i < n1) \n\n{ \n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\ni++; \n\n} \n\nwhile\n(i < n2) \n\n{ \n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\ni++; \n\n} \n\n\nreturn\nmax * min; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String argc[]) \n\n{ \n\nint\n[] arr1= \nnew\nint\n[]{ \n10\n, \n2\n, \n3\n, \n\n6\n, \n4\n, \n1\n}; \n\nint\n[] arr2 = \nnew\nint\n[]{ \n5\n, \n1\n, \n4\n, \n\n2\n, \n6\n, \n9\n}; \n\nint\nn1 = \n6\n; \n\nint\nn2 = \n6\n; \n\nSystem.out.println(minMaxProduct(arr1, arr2, \n\nn1, n2)); \n\n} \n} \n\n// This code is contributed by Sagar Shukla ", "index": 281, "complexity": 3}
{"back-translation": "import java.util.ArrayList; public class GFG { static class Pair { char first; int second; Pair(char first, int second) { this.first = first; this.second = second; } } static int longestNull(String str) { ArrayList<Pair> arr = new ArrayList<>(); arr.add(new Pair('@', -1)); int maxlen = 0; for (int i = 0; i < str.length(); ++i) { arr.add(new Pair(str.charAt(i), i)); while (arr.size() >= 3 && arr.get(arr.size() - 3).first == '1' && arr.get(arr.size() - 2).first == '0' && arr.get(arr.size() - 1).first == '0') { arr.remove(arr.size() - 3); arr.remove(arr.size() - 2); arr.remove(arr.size() - 1); } int tmp = arr.get(arr.size() - 1).second; maxlen = Math.max(maxlen, i - tmp); } return maxlen; } public static void main(String args[]) { System.out.println(longestNull(\"1011100000100\")); } }", "src": "\n// Java implementation of program to find \n// the maximum length that can be removed \nimport\njava.util.ArrayList; \n\npublic\nclass\nGFG \n{ \n\n// User defined class Pair \n\nstatic\nclass\nPair{ \n\nchar\nfirst; \n\nint\nsecond; \n\nPair(\nchar\nfirst, \nint\nsecond){ \n\nthis\n.first = first; \n\nthis\n.second = second; \n\n} \n\n} \n\n\n/* Function to find the length of longest \n\nsub-string that can me make removed \n\narr --> pair type of array whose first \n\nfield store character in string \n\nand second field stores \n\ncorresponding index of that character*/\n\nstatic\nint\nlongestNull(String str) \n\n{ \n\nArrayList<Pair> arr = \nnew\nArrayList<>(); \n\n\n// store {'@',-1} in arr , here this value \n\n// will work as base index \n\narr.add(\nnew\nPair(\n'@'\n, -\n1\n)); \n\n\nint\nmaxlen = \n0\n; \n// Initialize result \n\n\n// one by one iterate characters of string \n\nfor\n(\nint\ni = \n0\n; i < str.length(); ++i) \n\n{ \n\n// make pair of char and index , then \n\n// store them into arr \n\narr.add(\nnew\nPair(str.charAt(i), i)); \n\n\n// now if last three elements of arr[] \n\n// are making sub-string \"100\" or not \n\nwhile\n(arr.size() >= \n3\n&& \n\narr.get(arr.size()-\n3\n).first==\n'1'\n&& \n\narr.get(arr.size()-\n2\n).first==\n'0'\n&& \n\narr.get(arr.size()-\n1\n).first==\n'0'\n) \n\n{ \n\n// if above condition is true then \n\n// delete sub-string \"100\" from arr[] \n\narr.remove(arr.size() - \n3\n); \n\narr.remove(arr.size() - \n2\n); \n\narr.remove(arr.size() - \n1\n); \n\n} \n\n\n// index of current last element in arr[] \n\nint\ntmp = arr.get(arr.size() - \n1\n).second; \n\n\n// This is important, here 'i' is the index \n\n// of current character inserted into arr[] \n\n// and 'tmp' is the index of last element \n\n// in arr[] after continuous deletion of \n\n// sub-string \"100\" from arr[] till we make \n\n// it null, difference of these to 'i-tmp' \n\n// gives the length of current sub-string \n\n// that can be make null by continuous \n\n// deletion of sub-string \"100\" \n\nmaxlen = Math.max(maxlen, i - tmp); \n\n} \n\n\nreturn\nmaxlen; \n\n} \n\n\n// Driver program to run the case \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(longestNull(\n\"1011100000100\"\n)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "index": 282, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\npublic class CommentaryBoxes {\n    public static void main(String[] args) {\n        FastReader in = new FastReader();\n        long n = in.nextLong();\n        long m = in.nextLong();\n        long a = in.nextLong();\n        long b = in.nextLong();\n        long total = 0;\n        long val = n % m;\n        if (n % m != 0) {\n            long x = val * b;\n            long y = (m - val) * a;\n            total = Math.min(x, y);\n        }\n        System.out.println(Math.abs(total));\n    }\n    public static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String string = \"\";\n            try {\n                string = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return string;\n        }\n    }\n}", "src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n *\n * @author Haya\n */\npublic class CommentaryBoxes {\n\n    public static void main(String[] args) {\n        \n        FastReader in = new FastReader();\n        \n        long n = in.nextLong();\n        long m = in.nextLong();\n        long a = in.nextLong();\n        long b = in.nextLong();\n        long total = 0;\n        \n        long val =(n%m);\n        if (n%m != 0){\n            \n            long x = (val)*b;\n            long y = (m-val)*a;\n            \n            total = Math.min(x, y);\n        }\n        System.out.println(Math.abs(total));\n        \n    }\n\n    public static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String string = \"\";\n            try {\n                string = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return string;\n        }\n\n    }\n\n}\n", "index": 283, "complexity": 3}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        ERandomForestRank solver = new ERandomForestRank();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ERandomForestRank {\n        int n;\n        List<Integer>[] tree;\n        int mod = 998244353;\n        long[][] dp;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.nextInt();\n            tree = Utils.genArrayList(n);\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1;\n                tree[a].add(b);\n                tree[b].add(a);\n            }\n            dp = new long[n][];\n            out.println((dfs(0, -1)[2] * 2) % mod);\n        }\n\n        long[] dfs(int node, int par) {\n            long tot = 1;\n            long alltaken = 1;\n            for (int next : tree[node]) {\n                if (next == par) continue;\n                long[] r = dfs(next, node);\n                tot = tot * (r[0] + r[1] + r[0] + r[1]) % mod;\n                alltaken = alltaken * (r[1] + r[1] + r[0]) % mod;\n            }\n            long free = alltaken;\n            long notfree = (tot - alltaken + mod) % mod;\n            long sum = notfree;\n            for (int next : tree[node]) {\n                if (next == par) continue;\n                long mult = tot * Utils.inv((dp[next][0] + dp[next][1] + dp[next][0] + dp[next][1]) % mod, mod) % mod;\n                sum = (sum + 2 * mult * dp[next][2]) % mod;\n            }\n            return dp[node] = new long[]{free, notfree, sum};\n        }\n\n    }\n\n    static class Utils {\n        public static <E> List<E>[] genArrayList(int size) {\n            return Stream.generate(ArrayList::new).limit(size).toArray(List[]::new);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 20];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lewin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        ERandomForestRank solver = new ERandomForestRank();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ERandomForestRank {\n        int n;\n        List<Integer>[] tree;\n        int mod = 998244353;\n        long[][] dp;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.nextInt();\n            tree = LUtils.genArrayList(n);\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1;\n                tree[a].add(b);\n                tree[b].add(a);\n            }\n            dp = new long[n][];\n            out.println((dfs(0, -1)[2] * 2) % mod);\n        }\n\n        long[] dfs(int node, int par) {\n            long tot = 1;\n            long alltaken = 1;\n            for (int next : tree[node]) {\n                if (next == par) continue;\n                long[] r = dfs(next, node);\n                tot = tot * (r[0] + r[1] + r[0] + r[1]) % mod;\n                alltaken = alltaken * (r[1] + r[1] + r[0]) % mod;\n            }\n            long free = alltaken;\n            long notfree = (tot - alltaken + mod) % mod;\n            long sum = notfree;\n            for (int next : tree[node]) {\n                if (next == par) continue;\n                long mult = tot * Utils.inv((dp[next][0] + dp[next][1] + dp[next][0] + dp[next][1]) % mod, mod) % mod;\n                sum = (sum + 2 * mult * dp[next][2]) % mod;\n            }\n            return dp[node] = new long[]{free, notfree, sum};\n        }\n\n    }\n\n    static class Utils {\n        public static long inv(long N, long M) {\n            long x = 0, lastx = 1, y = 1, lasty = 0, q, t, a = N, b = M;\n            while (b != 0) {\n                q = a / b;\n                t = a % b;\n                a = b;\n                b = t;\n                t = x;\n                x = lastx - q * x;\n                lastx = t;\n                t = y;\n                y = lasty - q * y;\n                lasty = t;\n            }\n            return (lastx + M) % M;\n        }\n\n    }\n\n    static class LUtils {\n        public static <E> List<E>[] genArrayList(int size) {\n            return Stream.generate(ArrayList::new).limit(size).toArray(List[]::new);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 20];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "index": 284, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class CF1027D {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint[] cc = new int[n];\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcc[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tst = new StringTokenizer(br.readLine());\n\t\tint[] aa = new int[n];\n\t\tfor (int i = 0; i < n; i++){\n\t\t\taa[i] = Integer.parseInt(st.nextToken()) - 1;\n\t\t}\n\t\tint[] used = new int[n];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i] == 2){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint j = i;\n\t\t\twhile (used[j] == 0) {\n\t\t\t\tused[j] = 1;\n\t\t\t\tj = aa[j];\n\t\t\t}\n\t\t\tif (used[j] == 1) {\n\t\t\t\tint c = cc[j];\n\t\t\t\twhile (used[j] == 1) {\n\t\t\t\t\tused[j] = 2;\n\t\t\t\t\tc = Math.min(c, cc[j]);\n\t\t\t\t\tj = aa[j];\n\t\t\t\t}\n\t\t\t\tans += c;\n\t\t\t}\n\t\t\tj = i;\n\t\t\twhile (used[j] == 1) {\n\t\t\t\tused[j] = 2;\n\t\t\t\tj = aa[j];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class CF1027D {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint[] cc = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcc[i] = Integer.parseInt(st.nextToken());\n\t\tst = new StringTokenizer(br.readLine());\n\t\tint[] aa = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = Integer.parseInt(st.nextToken()) - 1;\n\t\tint[] used = new int[n];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i] == 2)\n\t\t\t\tcontinue;\n\t\t\tint j = i;\n\t\t\twhile (used[j] == 0) {\n\t\t\t\tused[j] = 1;\n\t\t\t\tj = aa[j];\n\t\t\t}\n\t\t\tif (used[j] == 1) {\n\t\t\t\tint c = cc[j];\n\t\t\t\twhile (used[j] == 1) {\n\t\t\t\t\tused[j] = 2;\n\t\t\t\t\tc = Math.min(c, cc[j]);\n\t\t\t\t\tj = aa[j];\n\t\t\t\t}\n\t\t\t\tans += c;\n\t\t\t}\n\t\t\tj = i;\n\t\t\twhile (used[j] == 1) {\n\t\t\t\tused[j] = 2;\n\t\t\t\tj = aa[j];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "index": 286, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\nimport java.lang.Math;\n\nclass CloseSum {\n    static void printClosest(int arr[], int n, int x) {\n        int res_l = 0, res_r = 0;\n        int l = 0, r = n - 1, diff = Integer.MAX_VALUE;\n        while (r > l) {\n            if (Math.abs(arr[l] + arr[r] - x) < diff) {\n                res_l = l;\n                res_r = r;\n                diff = Math.abs(arr[l] + arr[r] - x);\n            }\n            if (arr[l] + arr[r] > x) r--;\n            else l++;\n        }\n        System.out.println(\" The closest pair is \" + arr[res_l] + \" and \" + arr[res_r]);\n    }\n    public static void main(String[] args) {\n        int arr[] = { 10, 22, 28, 29, 30, 40 }, x = 54;\n        int n = arr.length;\n        printClosest(arr, n, x);\n    }\n}", "src": "\n// Java program to find pair with sum closest to x \nimport\njava.io.*; \nimport\njava.util.*; \nimport\njava.lang.Math; \n\nclass\nCloseSum { \n\n\n// Prints the pair with sum cloest to x \n\nstatic\nvoid\nprintClosest(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres_l=\n0\n, res_r=\n0\n; \n// To store indexes of result pair \n\n\n// Initialize left and right indexes and difference between \n\n// pair sum and x \n\nint\nl = \n0\n, r = n-\n1\n, diff = Integer.MAX_VALUE; \n\n\n// While there are elements between l and r \n\nwhile\n(r > l) \n\n{ \n\n// Check if this pair is closer than the closest pair so far \n\nif\n(Math.abs(arr[l] + arr[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(arr[l] + arr[r] - x); \n\n} \n\n\n// If this pair has more sum, move to smaller values. \n\nif\n(arr[l] + arr[r] > x) \n\nr--; \n\nelse\n// Move to larger values \n\nl++; \n\n} \n\n\nSystem.out.println(\n\" The closest pair is \"\n+arr[res_l]+\n\" and \"\n+ arr[res_r]); \n} \n\n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n22\n, \n28\n, \n29\n, \n30\n, \n40\n}, x = \n54\n; \n\nint\nn = arr.length; \n\nprintClosest(arr, n, x); \n\n} \n} \n/*This code is contributed by Devesh Agrawal*/", "index": 287, "complexity": 3}
{"back-translation": "class GFG { static int findRepeating(int[] arr, int n) { int res = 0; for (int i = 0; i < n - 1; i++) res = res ^ (i + 1) ^ arr[i]; res = res ^ arr[n - 1]; return res; } public static void main(String[] args) { int arr[] = {9, 8, 2, 6, 1, 8, 5, 3, 4, 7}; int n = arr.length; System.out.println(findRepeating(arr, n)); } }", "src": "\n// Java program to find the only repeating \n// element in an array where elements are \n// from 1 to n-1. \nclass\nGFG \n{ \n\n\nstatic\nint\nfindRepeating(\nint\narr[], \nint\nn) \n\n{ \n\n\n// res is going to store value of \n\n// 1 ^ 2 ^ 3 .. ^ (n-1) ^ arr[0] ^ \n\n// arr[1] ^ .... arr[n-1] \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nres = res ^ (i + \n1\n) ^ arr[i]; \n\nres = res ^ arr[n - \n1\n]; \n\n\nreturn\nres; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n9\n, \n8\n, \n2\n, \n6\n, \n1\n, \n8\n, \n5\n, \n3\n, \n4\n, \n7\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findRepeating(arr, n)); \n\n} \n} \n\n// This code is contributed by \n// Smitha Dinesh Semwal. ", "index": 288, "complexity": 3}
{"back-translation": "class Node {\n    int data;\n    Node left, right;\n\n    Node(int d) {\n        data = d;\n        left = right = null;\n    }\n}\n\nclass BinarySearchTree {\n    Node root;\n\n    BinarySearchTree() {\n        root = null;\n    }\n\n    void inorder() {\n        inorderUtil(this.root);\n    }\n\n    void inorderUtil(Node node) {\n        if (node == null) return;\n\n        inorderUtil(node.left);\n        System.out.print(node.data + \" \");\n        inorderUtil(node.right);\n    }\n\n    public void insert(int data) {\n        this.root = this.insertRec(this.root, data);\n    }\n\n    Node insertRec(Node node, int data) {\n        if (node == null) {\n            this.root = new Node(data);\n            return this.root;\n        }\n\n        if (data <= node.data) {\n            node.left = this.insertRec(node.left, data);\n        } else {\n            node.right = this.insertRec(node.right, data);\n        }\n\n        return node;\n    }\n\n    public static void main(String[] args) {\n        BinarySearchTree tree = new BinarySearchTree();\n\n        tree.insert(50);\n        tree.insert(30);\n        tree.insert(20);\n        tree.insert(40);\n        tree.insert(70);\n        tree.insert(60);\n        tree.insert(80);\n\n        tree.modifyBST(tree.root);\n\n        tree.inorder();\n    }\n\n    class Sum {\n        int sum = 0;\n    }\n\n    void modifyBSTUtil(Node node, Sum S) {\n        if (node == null) return;\n\n        this.modifyBSTUtil(node.right, S);\n\n        S.sum = S.sum + node.data;\n        node.data = S.sum;\n\n        this.modifyBSTUtil(node.left, S);\n    }\n\n    void modifyBST(Node node) {\n        Sum S = new Sum();\n        this.modifyBSTUtil(node, S);\n    }\n}", "src": "\n// Java code to add all greater values to \n// every node in a given BST \n\n// A binary tree node \nclass\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n// Root of BST \n\nNode root; \n\n\n// Constructor \n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n// Inorder traversal of the tree \n\nvoid\ninorder() \n\n{ \n\ninorderUtil(\nthis\n.root); \n\n} \n\n\n// Utility function for inorder traversal of \n\n// the tree \n\nvoid\ninorderUtil(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\ninorderUtil(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderUtil(node.right); \n\n} \n\n\n// adding new node \n\npublic\nvoid\ninsert(\nint\ndata) \n\n{ \n\nthis\n.root = \nthis\n.insertRec(\nthis\n.root, data); \n\n} \n\n\n/* A utility function to insert a new node with \n\ngiven data in BST */\n\nNode insertRec(Node node, \nint\ndata) \n\n{ \n\n/* If the tree is empty, return a new node */\n\nif\n(node == \nnull\n) { \n\nthis\n.root = \nnew\nNode(data); \n\nreturn\nthis\n.root; \n\n} \n\n\n/* Otherwise, recur down the tree */\n\nif\n(data <= node.data) { \n\nnode.left = \nthis\n.insertRec(node.left, data); \n\n} \nelse\n{ \n\nnode.right = \nthis\n.insertRec(node.right, data); \n\n} \n\nreturn\nnode; \n\n} \n\n\n// This class initialises the value of sum to 0 \n\npublic\nclass\nSum { \n\nint\nsum = \n0\n; \n\n} \n\n\n// Recursive function to add all greater values in \n\n// every node \n\nvoid\nmodifyBSTUtil(Node node, Sum S) \n\n{ \n\n// Base Case \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n// Recur for right subtree \n\nthis\n.modifyBSTUtil(node.right, S); \n\n\n// Now *sum has sum of nodes in right subtree, add \n\n// root->data to sum and update root->data \n\nS.sum = S.sum + node.data; \n\nnode.data = S.sum; \n\n\n// Recur for left subtree \n\nthis\n.modifyBSTUtil(node.left, S); \n\n} \n\n\n// A wrapper over modifyBSTUtil() \n\nvoid\nmodifyBST(Node node) \n\n{ \n\nSum S = \nnew\nSum(); \n\nthis\n.modifyBSTUtil(node, S); \n\n} \n\n\n// Driver Function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n/* Let us create following BST \n\n50 \n\n/ \\ \n\n30 70 \n\n/ \\ / \\ \n\n20 40 60 80 */\n\n\ntree.insert(\n50\n); \n\ntree.insert(\n30\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n40\n); \n\ntree.insert(\n70\n); \n\ntree.insert(\n60\n); \n\ntree.insert(\n80\n); \n\n\ntree.modifyBST(tree.root); \n\n\n// print inoder tarversal of the modified BST \n\ntree.inorder(); \n\n} \n} \n\n// This code is contributed by Kamal Rawal ", "index": 290, "complexity": 3}
{"back-translation": "import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.Arrays;import java.util.InputMismatchException;import static java.lang.Math.max;public class E_2 {public static void main(String[] args) throws Exception {FastReader in = new FastReader(System.in);PrintWriter pw = new PrintWriter(System.out);int n = in.nextInt(), k = in.nextInt(), N = (int) 5e6 + 1;int left = 0, right = 0;int a[] = new int[n + 1];for (int i = 1; i <= n; i++) {a[i] = in.nextInt();if (a[i] == k) left++;}int f[] = new int[N + 1];int ans = 0;for (int i = n; i >= 1; i--) {if (a[i] == k) left--;f[a[i]]++;f[a[i]] = max(f[a[i]], 1 + right);ans = max(ans, f[a[i]] + left);if (a[i] == k) right++;}pw.println(ans);pw.close();}static void debug(Object... obj) {System.err.println(Arrays.deepToString(obj));}static class FastReader {InputStream is;private byte[] inbuf = new byte[1024];private int lenbuf = 0, ptrbuf = 0;public FastReader(InputStream is) {this.is = is;}public int readByte() {if (lenbuf == -1) throw new InputMismatchException();if (ptrbuf >= lenbuf) {ptrbuf = 0;try {lenbuf = is.read(inbuf);} catch (IOException e) {throw new InputMismatchException();}if (lenbuf <= 0) return -1;}return inbuf[ptrbuf++];}public int nextInt() {int num = 0, b;boolean minus = false;while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;if (b == '-') {minus = true;b = readByte();}while (true) {if (b >= '0' && b <= '9') {num = (num << 3) + (num << 1) + (b - '0');} else {return minus ? -num : num;}b = readByte();}}}}", "src": "/**\n * Created by Aminul on 3/14/2019.\n */\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\nimport static java.lang.Math.max;\n\npublic class E_2 {\n    public static void main(String[] args) throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = in.nextInt(), k = in.nextInt(), N = (int) 5e6 + 1;\n        int left = 0, right = 0;\n        int a[] = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            a[i] = in.nextInt();\n            if (a[i] == k) left++;\n        }\n        int f[] = new int[N + 1];\n        int ans = 0;\n        for (int i = n; i >= 1; i--) {\n            if (a[i] == k) left--;\n            f[a[i]]++;\n            f[a[i]] = max(f[a[i]], 1 + right);\n            ans = max(ans, f[a[i]] + left);\n            if (a[i] == k) right++;\n        }\n        pw.println(ans);\n        pw.close();\n    }\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n\n        public FastReader(InputStream is) {\n            this.is = is;\n        }\n\n        public int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (ptrbuf >= lenbuf) {\n                ptrbuf = 0;\n                try {\n                    lenbuf = is.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public int nextInt() {\n            int num = 0, b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n    }\n}", "index": 291, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class C01Easy {\n\tpublic static void main(String[] args) {\n\t\ttry (BufferedReader r = new BufferedReader(new InputStreamReader(System.in))) {\n\t\t\tfinal String[] line = r.readLine().split(\" \");\n\t\t\tfinal int N = Integer.parseInt(line[0]), P = Integer.parseInt(line[1]);\n\t\t\tfinal String[] numS = r.readLine().split(\" \");\n\t\t\tif (numS.length != N) throw new IllegalArgumentException();\n\t\t\tfinal int[] n = new int[N];\n\t\t\tint sum1 = 0, sum2 = 0;\n\t\t\tint i;\n\t\t\tfor (i = 0; i < N; i++) {\n\t\t\t\tn[i] = Integer.parseInt(numS[i]) % P;\n\t\t\t\tsum2 += n[i];\n\t\t\t\tif (sum2 >= P) sum2 -= P;\n\t\t\t}\n\t\t\tint max = sum2;\n\t\t\tfor (i = 0; i < N; i++) {\n\t\t\t\tsum1 += n[i];\n\t\t\t\tif (sum1 >= P) sum1 -= P;\n\t\t\t\tsum2 -= n[i];\n\t\t\t\tif (sum2 < 0) sum2 += P;\n\t\t\t\tfinal int s = sum1 + sum2;\n\t\t\t\tif (s > max) max = s;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "src": "/*\n * Created on 17.05.2019\n */\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * @author Wolfgang Weck\n */\npublic class C01Easy {\n\tpublic static void main(String[] args) {\n\t\ttry (BufferedReader r = new BufferedReader(new InputStreamReader(System.in))) {\n\t\t\tfinal String[] line = r.readLine().split(\" \");\n\t\t\tfinal int N = Integer.parseInt(line[0]), P = Integer.parseInt(line[1]);\n\t\t\tfinal String[] numS = r.readLine().split(\" \");\n\t\t\tif (numS.length != N) throw new IllegalArgumentException();\n\t\t\tfinal int[] n = new int[N];\n\t\t\tint sum1 = 0, sum2 = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tn[i] = Integer.parseInt(numS[i]) % P;\n\t\t\t\tsum2 += n[i];\n\t\t\t\tif (sum2 >= P) sum2 -= P;\n\t\t\t}\n\t\t\tint max = sum2;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tsum1 += n[i];\n\t\t\t\tif (sum1 >= P) sum1 -= P;\n\t\t\t\tsum2 -= n[i];\n\t\t\t\tif (sum2 < 0) sum2 += P;\n\t\t\t\tfinal int s = sum1 + sum2;\n\t\t\t\tif (s > max) max = s;\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n", "index": 292, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt(), t;\n        int[] a = new int[101];\n        int answ = 0;\n        for (int i = 0; i < n; i++) {\n            t = in.nextInt();\n            a[t]++;\n            if (a[t] < 2) {\n                if (answ < k) {\n                    data.append(i + 1).append(\" \");\n                    answ++;\n                }\n            }\n\n        }\n        if (answ == k) {\n            System.out.println(\"YES\");\n            System.out.println(data);\n        } else {\n            System.out.println(\"NO\");\n        }\n\n\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "src": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt(), t;\n        int[] a = new int[101];\n        int answ = 0;\n        for (long i = 0; i < n; i++) {\n            t = in.nextInt();\n            a[t]++;\n            if (a[t] < 2) {\n                if (answ < k) {\n                    data.append(i + 1).append(\" \");\n                    answ++;\n                }\n            }\n\n        }\n        if (answ == k) {\n            System.out.println(\"YES\");\n            System.out.println(data);\n        } else {\n            System.out.println(\"NO\");\n        }\n\n\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 293, "complexity": 3}
{"back-translation": "class Node { int data; Node left, right; Node(int d) { data = d; left = right = null; } } class BinaryTree { static Node root; Node sortedArrayToBST(int arr[], int start, int end) { if (start > end) { return null; } int mid = (start + end) / 2; Node node = new Node(arr[mid]); node.left = sortedArrayToBST(arr, start, mid - 1); node.right = sortedArrayToBST(arr, mid + 1, end); return node; } void preOrder(Node node) { if (node == null) { return; } System.out.print(node.data + \" \"); preOrder(node.left); preOrder(node.right); } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); int arr[] = new int[]{ 1, 2, 3, 4, 5, 6, 7 }; int n = arr.length; root = tree.sortedArrayToBST(arr, 0, n - 1); System.out.println(\"Preorder traversal of constructed BST\"); tree.preOrder(root); } }", "src": "\n// Java program to print BST in given range \n\n// A binary tree node \nclass\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\n\n/* A function that constructs Balanced Binary Search Tree \n\nfrom a sorted array */\n\nNode sortedArrayToBST(\nint\narr[], \nint\nstart, \nint\nend) { \n\n\n/* Base Case */\n\nif\n(start > end) { \n\nreturn\nnull\n; \n\n} \n\n\n/* Get the middle element and make it root */\n\nint\nmid = (start + end) / \n2\n; \n\nNode node = \nnew\nNode(arr[mid]); \n\n\n/* Recursively construct the left subtree and make it \n\nleft child of root */\n\nnode.left = sortedArrayToBST(arr, start, mid - \n1\n); \n\n\n/* Recursively construct the right subtree and make it \n\nright child of root */\n\nnode.right = sortedArrayToBST(arr, mid + \n1\n, end); \n\n\nreturn\nnode; \n\n} \n\n\n/* A utility function to print preorder traversal of BST */\n\nvoid\npreOrder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn = arr.length; \n\nroot = tree.sortedArrayToBST(arr, \n0\n, n - \n1\n); \n\nSystem.out.println(\n\"Preorder traversal of constructed BST\"\n); \n\ntree.preOrder(root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 294, "complexity": 3}
{"back-translation": "public class Solution { static class Node { int data; Node left, right; } static Node temp = new Node(); static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.left = temp.right = null; return temp; } static Node leftMostNode(Node node) { while (node != null && node.left != null) node = node.left; return node; } static Node rightMostNode(Node node) { while (node != null && node.right != null) node = node.right; return node; } static Node findInorderRecursive(Node root, Node x) { if (root == null) return null; if (root == x || (temp = findInorderRecursive(root.left, x)) != null || (temp = findInorderRecursive(root.right, x)) != null) { if (temp != null) { if (root.left == temp) { System.out.print(\"Inorder Successor of \" + x.data); System.out.print(\" is \" + root.data + \"\\n\"); return null; } } return root; } return null; } static void inorderSuccesor(Node root, Node x) { if (x.right != null) { Node inorderSucc = leftMostNode(x.right); System.out.print(\"Inorder Successor of \" + x.data + \" is \"); System.out.print(inorderSucc.data + \"\\n\"); } if (x.right == null) { int f = 0; Node rightMost = rightMostNode(root); if (rightMost == x) System.out.print(\"No inorder successor! Right most node.\\n\"); else findInorderRecursive(root, x); } } public static void main(String args[]) { Node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); root.right.right = newNode(6); inorderSuccesor(root, root.right); inorderSuccesor(root, root.left.left); inorderSuccesor(root, root.right.right); } }", "src": "\n// Java program to find inorder successor of a node \nclass\nSolution \n{ \n// A Binary Tree Node \n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n// Temporary node for case 2 \nstatic\nNode temp = \nnew\nNode(); \n\n// Utility function to create a new tree node \nstatic\nNode newNode(\nint\ndata) \n\n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n// function to find left most node in a tree \nstatic\nNode leftMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.left != \nnull\n) \n\nnode = node.left; \n\nreturn\nnode; \n} \n\n// function to find right most node in a tree \nstatic\nNode rightMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.right != \nnull\n) \n\nnode = node.right; \n\nreturn\nnode; \n} \n\n// recursive function to find the Inorder Scuccessor \n// when the right child of node x is null \nstatic\nNode findInorderRecursive(Node root, Node x ) \n\n{ \n\nif\n(root==\nnull\n) \n\nreturn\nnull\n; \n\n\nif\n(root==x || (temp = findInorderRecursive(root.left,x))!=\nnull\n|| \n\n(temp = findInorderRecursive(root.right,x))!=\nnull\n) \n\n{ \n\nif\n(temp!=\nnull\n) \n\n{ \n\nif\n(root.left == temp) \n\n{ \n\nSystem.out.print( \n\"Inorder Successor of \"\n+x.data); \n\nSystem.out.print( \n\" is \"\n+ root.data + \n\"\\n\"\n); \n\nreturn\nnull\n; \n\n} \n\n} \n\n\nreturn\nroot; \n\n} \n\n\nreturn\nnull\n; \n} \n\n// function to find inorder successor of \n// a node \nstatic\nvoid\ninorderSuccesor(Node root, Node x) \n\n{ \n\n// Case1: If right child is not null \n\nif\n(x.right != \nnull\n) \n\n{ \n\nNode inorderSucc = leftMostNode(x.right); \n\nSystem.out.print(\n\"Inorder Successor of \"\n+x.data+\n\" is \"\n); \n\nSystem.out.print(inorderSucc.data+\n\"\\n\"\n); \n\n} \n\n\n// Case2: If right child is null \n\nif\n(x.right == \nnull\n) \n\n{ \n\nint\nf = \n0\n; \n\n\nNode rightMost = rightMostNode(root); \n\n\n// case3: If x is the right most node \n\nif\n(rightMost == x) \n\nSystem.out.print(\n\"No inorder successor! Right most node.\\n\"\n); \n\nelse\n\nfindInorderRecursive(root, x); \n\n} \n} \n\n// Driver program to test above functions \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n// Let's con the binary tree \n\n// as shown in above diagram \n\n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.right.right = newNode(\n6\n); \n\n\n// Case 1 \n\ninorderSuccesor(root, root.right); \n\n\n// case 2 \n\ninorderSuccesor(root, root.left.left); \n\n\n// case 3 \n\ninorderSuccesor(root, root.right.right); \n\n} \n} \n//contributed by Arnab Kundu ", "index": 297, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.io.*;\nimport java.util.*;\n\n\npublic class tr {\n\tstatic int[][] ad;\n    static boolean []vis;\n    static int []goods;\n    static int[][]sol;\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n=sc.nextInt();\n\t\tint []a=new int [n];\n\t\tint max=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=sc.nextInt();\n\t\tStack<Integer> s=new Stack<>();\n\t\tboolean f=true;\n\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\tmax=Math.max(max,a[i]);\n\t\t\t\t\tif(!s.isEmpty() && a[i]>s.peek())\n\t\t\t\t\t\tf=false;\n\t\t\t\t\ts.push(a[i]);\n\t\t\t\t\twhile(!s.isEmpty()) {\n\t\t\t\t\t\tint high=s.pop();\n\t\t\t\t\t\tif(s.isEmpty() || s.peek()!=high) {\n\t\t\t\t\t\t\ts.push(high);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\t}\n\t\t\t\t//\tSystem.out.println(s+\" \"+max);\n\t\t\t\t}\n\t\t\t\t//System.out.println(f+\" \"+max);\n\t\t\t\tif(f && s.size()==0)\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\telse if(f && s.size()==1 && s.peek()==max)\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\telse\n\t\t\t\t\tout.println(\"NO\");\n\t\t out.flush();\n\t}\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t}\n\t\treturn gcd(b, a % b);\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tint a;\n\t\tint b;\n\n\t\tpair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\treturn  o.a-a ;\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "index": 298, "complexity": 3}
{"back-translation": "import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner s = new Scanner(System.in); int n = Integer.parseInt(s.nextLine()); int ans = 0; String inp = s.nextLine(); for (int i = 0; i < n; i++) { char k = inp.charAt(i); if (k == '+') ans++; if (k == '-') { if (ans > 0) ans--; } } System.out.println(ans); } }", "src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = 0;\n\t\tString inp = s.nextLine();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchar k = inp.charAt(i);\n\t\t\tif (k == '+')\n\t\t\t\tans++;\n\t\t\tif (k == '-') {\n\t\t\t\tif (ans>0)\n\t\t\t\t\tans--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 299, "complexity": 3}
{"back-translation": "class Node {\n    int data;\n    Node left, right, nextRight;\n    Node(int item) {\n        data = item;\n        left = right = nextRight = null;\n    }\n}\n\nclass BinaryTree {\n    Node root;\n    int isLeaf(Node node) {\n        if (node == null) return 0;\n        if (node.left == null && node.right == null) return 1;\n        return 0;\n    }\n    int isSumTree(Node node) {\n        int ls;\n        int rs;\n        if (node == null || isLeaf(node) == 1) return 1;\n        if (isSumTree(node.left) != 0 && isSumTree(node.right) != 0) {\n            if (node.left == null) ls = 0;\n            else if (isLeaf(node.left) != 0) ls = node.left.data;\n            else ls = 2 * (node.left.data);\n            if (node.right == null) rs = 0;\n            else if (isLeaf(node.right) != 0) rs = node.right.data;\n            else rs = 2 * (node.right.data);\n            if ((node.data == rs + ls)) return 1;\n            else return 0;\n        }\n        return 0;\n    }\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node(26);\n        tree.root.left = new Node(10);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(4);\n        tree.root.left.right = new Node(6);\n        tree.root.right.right = new Node(3);\n        if (tree.isSumTree(tree.root) != 0) System.out.println(\"The given tree is a sum tree\");\n        else System.out.println(\"The given tree is not a sum tree\");\n    }\n}", "src": "\n// Java program to check if Binary tree is sum tree or not \n\n\n/* A binary tree node has data, left child and right child */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right, nextRight; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = nextRight = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* Utility function to check if the given node is leaf or not */\n\nint\nisLeaf(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nreturn\n1\n; \n\nreturn\n0\n; \n\n} \n\n\n/* returns 1 if SumTree property holds for the given \n\ntree */\n\nint\nisSumTree(Node node) \n\n{ \n\nint\nls; \n// for sum of nodes in left subtree \n\nint\nrs; \n// for sum of nodes in right subtree \n\n\n/* If node is NULL or it's a leaf node then \n\nreturn true */\n\nif\n(node == \nnull\n|| isLeaf(node) == \n1\n) \n\nreturn\n1\n; \n\n\nif\n(isSumTree(node.left) != \n0\n&& isSumTree(node.right) != \n0\n) \n\n{ \n\n// Get the sum of nodes in left subtree \n\nif\n(node.left == \nnull\n) \n\nls = \n0\n; \n\nelse\nif\n(isLeaf(node.left) != \n0\n) \n\nls = node.left.data; \n\nelse\n\nls = \n2\n* (node.left.data); \n\n\n// Get the sum of nodes in right subtree \n\nif\n(node.right == \nnull\n) \n\nrs = \n0\n; \n\nelse\nif\n(isLeaf(node.right) != \n0\n) \n\nrs = node.right.data; \n\nelse\n\nrs = \n2\n* (node.right.data); \n\n\n/* If root's data is equal to sum of nodes in left \n\nand right subtrees then return 1 else return 0*/\n\nif\n((node.data == rs + ls)) \n\nreturn\n1\n; \n\nelse\n\nreturn\n0\n; \n\n} \n\n\nreturn\n0\n; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n26\n); \n\ntree.root.left = \nnew\nNode(\n10\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n3\n); \n\n\nif\n(tree.isSumTree(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree is a sum tree\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree is not a sum tree\"\n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 300, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            String s2[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int m=Integer.parseInt(s1[1]);\n            int a[]=new int[n];\n            int b[]=new int[n];\n            int c[]=new int[n];\n            int d[]=new int[n];\n            HashSet<Integer> hs=new HashSet<Integer>();\n            hs.add(0);\n            hs.add(m);\n            int max=0;\n            for(int i=0;i<n;i++)\n            {\n                  a[i]=Integer.parseInt(s2[i]);\n                  if(i%2==0)\n                   b[i]=1;\n                  hs.add(a[i]);\n            }\n            \n            c[0]=a[0];\n            for(int i=1;i<n;i++)\n            {\n                  if(b[i]==0)\n                   c[i]=c[i-1];\n                  else\n                   c[i]=c[i-1]+a[i]-a[i-1];\n            }\n            \n            if(b[n-1]==0)\n             d[n-1]=m-a[n-1];\n            for(int i=n-2;i>=0;i--)\n            {\n                  if(b[i]==1)\n                   d[i]=d[i+1];\n                  else\n                   d[i]=d[i+1]+a[i+1]-a[i];\n            }\n            \n            max=c[n-1];\n            if(b[n-1]==0)\n             max+=m-a[n-1];\n            //System.out.println(max);\n            for(int i=n-1;i>=0;i--)\n            {\n                  int u=a[i]-1;\n                  int v=a[i]+1;\n                  if(!hs.contains(u)) {\n                        if(b[i]==0) {\n                             int r=(m - a[i] - 1) + d[i] + c[i];\n                             max = Math.max(max,r);\n                        } else {\n                              int l=0;\n                              if (i>0)\n                               l=a[i-1];\n                              int r=(m - a[i] - 1) + c[i] - d[i];\n                              max = Math.max(max,r);\n                        }\n                  }\n                  \n                  if (!hs.contains(v)) {\n                        if (b[i]==0) {\n                           if (i == n-1) {\n                              int r=c[i]+1;\n                              max=Math.max(max,r);\n                           } else {\n                               int r=c[i]+1+m-a[i+1]-d[i+1];\n                               max=Math.max(max,r);\n                           }\n                        } else {\n                                if (i == n-1) {\n                                   int r=c[i]+m-a[i]-1;\n                                   max=Math.max(max,r);\n                                } else {\n                                    int r=c[i]+m-a[i+1]-d[i+1]+a[i+1]-1-a[i];\n                                    max=Math.max(max,r);\n                                }\n                        }\n                  }\n            }\n            \n            System.out.println(max);\n      }\n}", "src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            String s2[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int m=Integer.parseInt(s1[1]);\n            int a[]=new int[n];\n            int b[]=new int[n];\n            int c[]=new int[n];\n            int d[]=new int[n];\n            HashSet<Integer> hs=new HashSet<Integer>();\n            hs.add(0);\n            hs.add(m);\n            int max=0;\n            for(int i=0;i<n;i++)\n            {\n                  a[i]=Integer.parseInt(s2[i]);\n                  if(i%2==0)\n                   b[i]=1;\n                  hs.add(a[i]);\n            }\n            \n            c[0]=a[0];\n            for(int i=1;i<n;i++)\n            {\n                  if(b[i]==0)\n                   c[i]=c[i-1];\n                  else\n                   c[i]=c[i-1]+a[i]-a[i-1];\n            }\n            \n            if(b[n-1]==0)\n             d[n-1]=m-a[n-1];\n            for(int i=n-2;i>=0;i--)\n            {\n                  if(b[i]==1)\n                   d[i]=d[i+1];\n                  else\n                   d[i]=d[i+1]+a[i+1]-a[i];\n            }\n            \n            max=c[n-1];\n            if(b[n-1]==0)\n             max+=m-a[n-1];\n            //System.out.println(max);\n            for(int i=n-1;i>=0;i--)\n            {\n                  int u=a[i]-1;\n                  int v=a[i]+1;\n                  if(!hs.contains(u))\n                  {\n                        if(b[i]==0)\n                        {\n                             int r=1+m-a[i]-d[i]+c[i-1];\n                             max=Math.max(max,r);\n                        }\n                        else\n                        {\n                              int l=0;\n                              if(i>0)\n                               l=a[i-1];\n                              int r=c[i]-1+m-a[i]-d[i];\n                              max=Math.max(max,r);\n                        }\n                  }\n                  \n                  if(!hs.contains(v))\n                  {\n                        if(b[i]==0)\n                        {\n                           if(i==n-1)\n                           {\n                              int r=c[i]+1;\n                              max=Math.max(max,r);\n                           }\n                           else\n                           {\n                               int r=c[i]+1+m-a[i+1]-d[i+1];\n                               max=Math.max(max,r);\n                           }\n                        }\n                        else\n                        {\n                                if(i==n-1)\n                                {\n                                   int r=c[i]+m-a[i]-1;\n                                   max=Math.max(max,r);\n                                }\n                                else\n                                {\n                                    int r=c[i]+m-a[i+1]-d[i+1]+a[i+1]-1-a[i];  \n                                    max=Math.max(max,r);\n                                }\n                        }\n                  }\n            }\n            \n            System.out.println(max);\n      }\n}", "index": 301, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    static boolean canWinFromOneMove(char []s,int k) {\n        int prefix=0;\n        int n=s.length;\n        for(int i=0;i<n && s[i]==s[0];i++)\n            prefix++;\n        int suffix=0;\n        for(int i=n-1;i>=0 && s[i]==s[n-1];i--)\n            suffix++;\n        \n        return s[0]==s[n-1] && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;\n            \n    }\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int n=sc.nextInt(),k=sc.nextInt();\n        char []s=sc.next().toCharArray();\n        if(canWinFromOneMove(s, k)) {\n            System.out.println(\"tokitsukaze\");\n            return;\n        }\n        int []suff=new int [n+1];\n        suff[n-1]=1;\n        for(int i=n-2;i>=0;i--) {\n            suff[i]=1+(s[i+1]==s[i]?suff[i+1]:0);\n        }\n        for(int i=n-2;i>=0;i--)\n            suff[i]=Math.max(suff[i], suff[i+1]);\n        int max=0,curr=0;\n        boolean draw=false;\n        int ones=0;\n        for(int i=0;i+k<=n;i++) {\n            \n            // one\n            int prefix=ones==i?k+ones:max;\n            int suffix=i+k==n?k:s[i+k]=='1' && suff[i+k]==n-(i+k)?k+suff[i+k]:suff[i+k];\n            char first=i==0?'1':s[0],last=i+k==n?'1':s[n-1];\n            boolean zero=first==last && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;\n            // zero\n             prefix=ones==0?k+ones:max;\n             suffix=i+k==n?k:s[i+k]=='0' && suff[i+k]==n-(i+k)?k+suff[i+k]:suff[i+k];\n             first=i==0?'0':s[0];\n             last=i+k==n?'0':s[n-1];\n            boolean one=first==last && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;\n            if(!zero || !one) {\n                draw=true;\n            }\n            if(s[i]=='1')\n                ones++;\n            if(i>0 && s[i]==s[i-1] )\n                curr++;\n            else\n                curr=1;\n            max=Math.max(max, curr);\n        }\n        out.println(draw?\"once again\":\"quailty\");\n        out.close();\n\n    }\n\n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.parseDouble(next());\n        }\n\n        boolean ready() throws IOException {\n            return br.ready();\n        }\n\n    }\n\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n\tstatic boolean canWinFromOneMove(char []s,int k) {\n\t\tint prefix=0;\n\t\tint n=s.length;\n\t\tfor(int i=0;i<n && s[i]==s[0];i++)\n\t\t\tprefix++;\n\t\tint suffix=0;\n\t\tfor(int i=n-1;i>=0 && s[i]==s[n-1];i--)\n\t\t\tsuffix++;\n\t\t\n\t\treturn s[0]==s[n-1] && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;\n\t\t\t\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n=sc.nextInt(),k=sc.nextInt();\n\t\tchar []s=sc.next().toCharArray();\n\t\tif(canWinFromOneMove(s, k)) {\n\t\t\tSystem.out.println(\"tokitsukaze\");\n\t\t\treturn;\n\t\t}\n\t\tint []suff=new int [n+1];\n\t\tsuff[n-1]=1;\n\t\tfor(int i=n-2;i>=0;i--) {\n\t\t\tsuff[i]=1+(s[i+1]==s[i]?suff[i+1]:0);\n\t\t}\n\t\tfor(int i=n-2;i>=0;i--)\n\t\t\tsuff[i]=Math.max(suff[i], suff[i+1]);\n\t\tint max=0,curr=0;\n\t\tboolean draw=false;\n\t\tint ones=0;\n\t\tfor(int i=0;i+k<=n;i++) {\n\t\t\t\n\t\t\t// one\n\t\t\tint prefix=ones==i?k+ones:max;\n\t\t\tint suffix=i+k==n?k:s[i+k]=='1' && suff[i+k]==n-(i+k)?k+suff[i+k]:suff[i+k];\n\t\t\tchar first=i==0?'1':s[0],last=i+k==n?'1':s[n-1];\n\t\t\tboolean zero=first==last && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;\n\t\t\t// zero\n\t\t\t prefix=ones==0?k+ones:max;\n\t\t\t suffix=i+k==n?k:s[i+k]=='0' && suff[i+k]==n-(i+k)?k+suff[i+k]:suff[i+k];\n\t\t\t first=i==0?'0':s[0];\n\t\t\t last=i+k==n?'0':s[n-1];\n\t\t\tboolean one=first==last && prefix+suffix+k>=n || Math.max(prefix, suffix)+k>=n;\n\t\t\tif(!zero || !one) {\n//\t\t\t\tSystem.err.println(i+1);\n\t\t\t\tdraw=true;\n\t\t\t}\n\t\t\tif(s[i]=='1')\n\t\t\t\tones++;\n\t\t\tif(i>0 && s[i]==s[i-1] )\n\t\t\t\tcurr++;\n\t\t\telse\n\t\t\t\tcurr=1;\n\t\t\tmax=Math.max(max, curr);\n\t\t}\n\t\tout.println(draw?\"once again\":\"quailty\");\n\t\tout.close();\n\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tboolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "index": 309, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class B {\n    public static void main(String[] args) throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5 + 50];\n        int g[] = new int[(int)2e5 + 50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n + 1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if (f[a] > 0) {\n                ans = 0;\n                break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if ((a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)) {\n                ans = 1;\n                break;\n            }\n\n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if (g[a] > 1) {\n                ans = 2;\n                break;\n            }\n\n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is) {\n            for (int i = '0'; i <= '9'; i++) ints[i] = i - '0';\n            this.is = is;\n        }\n\n        public int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (ptrbuf >= lenbuf) {\n                ptrbuf = 0;\n                try {\n                    lenbuf = is.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        public int skip() {\n            int b;\n            while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n            return b;\n        }\n\n        public String next() {\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while (!(isSpaceChar(b))) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int num = 0, b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + ints[b];\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + ints[b];\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public char[] next(int n) {\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while (p < n && !(isSpaceChar(b))) {\n                buf[p++] = (char) b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n    }", "src": "/**\n * Created by Baelish on 7/30/2018.\n */\n\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            //g[a]++;\n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       /* public char nextChar() {\n            return (char)skip();\n        }*/\n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        /*private char buff[] = new char[1005];\n        public char[] nextCharArray(){\n            int b = skip(), p = 0;\n            while(!(isSpaceChar(b))){\n                buff[p++] = (char)b;\n                b = readByte();\n            }\n            return Arrays.copyOf(buff, p);\n        }*/\n    }\n}", "index": 310, "complexity": 3}
{"back-translation": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            StringBuilder s=new StringBuilder();\n            for(int i=0;i<k;i++){\n                s.append(\"1\");\n            }\n            System.out.println(s.toString());\n        }\n        else{\n            int a=(n-k)/2;\n            StringBuilder s=new StringBuilder();\n                for(int i=0;i<a && s.length()<n;i++){\n                    s.append(\"1\");\n                }\n                if(s.length()<n){\n                    s.append(\"0\");\n                }\n            while(s.length()<n){\n                s.append(s.toString());\n            }\n            StringBuilder s1=new StringBuilder();\n            for(int i=0;i<n;i++){\n                s1.append(Character.toString(s.charAt(i)));\n            }\n            System.out.println(s1.toString());\n        }\n\t}\n}", "src": "import java.util.*;\npublic class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            while(s.length()<n){\n                s=s+s;\n            }\n            String s1=new String();\n            for(int i=0;i<n;i++){\n                s1=s1+Character.toString(s.charAt(i));\n            }\n            System.out.println(s1);\n        }\n\t}\n}", "index": 312, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[] ar = new int[200];\n\t\t\n\t\tString str = in.next();\n\t\tfor(int i = 0; i < str.length(); i++)\n\t\t\tar[ str.charAt(i) ]++;\n\t\t\t\n\t\tint ans = 100000;\n\t\t\n\t\tfor(int i = 65; i < 65 + m; i++)\n\t\t\tans = Math.min(ans, ar[i]);\n\t\tans *= m;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}\n\n", "src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[] ar = new int[200];\n\t\t\n\t\tString str = in.next();\n\t\tfor(int i = 0; i < str.length(); i++)\n\t\t\tar[ str.charAt(i) ]++;\n\t\t\t\n\t\tint ans = 100000;\n\t\t\n\t\tfor(int i = 'A'; i < 'A' + m; i++)\n\t\t\tans = Math.min(ans, ar[i]);\n\t\tans *= m;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}\n\n", "index": 313, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class TwoGram {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        String s = sc.next();\n\n        HashMap<String, Integer> hm = new HashMap<>();\n        for (int i = 0; i < n - 1; i++) {\n            String curr = s.substring(i, i + 2);\n\n            if (hm.containsKey(curr)) {\n                hm.put(curr, hm.get(curr) + 1);\n            } else {\n                hm.put(curr, 1);\n            }\n        }\n\n        String ans = \"\";\n        int currMax = 0;\n        for (String twoGram : hm.keySet()) {\n            if (hm.get(twoGram) > currMax) {\n                ans = twoGram;\n                currMax = hm.get(twoGram);\n            }\n        }\n\n        System.out.println(ans);\n\n        sc.close();\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\n\npublic class TwoGram {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        String s = sc.next();\n\n        HashMap <String, Integer> hm = new HashMap<>();\n        for (int i = 0; i < n - 1; i++) {\n            String curr = s.substring(i, i + 2);\n\n            if (hm.containsKey(curr)) {\n                hm.put(curr, hm.get(curr) + 1);\n            } else {\n                hm.put(curr, 1);\n            }\n        }\n\n        String ans = \"\";\n        int currMax = 0;\n        for (String twoGram : hm.keySet()) {\n            if (hm.get(twoGram) > currMax) {\n                ans = twoGram;\n                currMax = hm.get(twoGram);\n            }\n        }\n\n        System.out.println(ans);\n\n        sc.close();\n    }\n}\n", "index": 314, "complexity": 3}
{"back-translation": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Fingerprints {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tset.add(nextInt());\n\t\t}\n\t\t\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (set.contains(a[i])) {\n\t\t\t\ts += \" \" + a[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(s.length() == 0 ? s : s.substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Fingerprints {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tset.add(nextInt());\n\t\t\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (set.contains(a[i]))\n\t\t\t\ts += \" \" + a[i];\n\t\t\n\t\tSystem.out.println(s.length() == 0 ? s : s.substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 315, "complexity": 3}
{"back-translation": "class GFG {\n\n    static void segregateElements(int arr[], int n) {\n        int temp[] = new int[n];\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            if (arr[i] >= 0)\n                temp[j++] = arr[i];\n        }\n        if (j == n || j == 0)\n            return;\n        for (int i = 0; i < n; i++) {\n            if (arr[i] < 0)\n                temp[j++] = arr[i];\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i] = temp[i];\n        }\n    }\n\n    public static void main(String arg[]) {\n        int arr[] = {1, -1, -3, -2, 7, 5, 11, 6};\n        int n = arr.length;\n        segregateElements(arr, n);\n        for (int i = 0; i < n; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n}", "src": "\n// Java program to Move All -ve Element At End \n// Without changing order Of Array Element \nimport\njava.util.Arrays; \n\nclass\nGFG { \n\n\n// Moves all -ve element to end of array in \n\n// same order. \n\nstatic\nvoid\nsegregateElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n// Create an empty array to store result \n\nint\ntemp[] = \nnew\nint\n[n]; \n\n\n// Traversal array and store +ve element in \n\n// temp array \n\nint\nj = \n0\n; \n// index of temp \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] >= \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n// If array contains all positive or all \n\n// negative. \n\nif\n(j == n || j == \n0\n) \n\nreturn\n; \n\n\n// Store -ve element in temp array \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n// Copy contents of temp[] to arr[] \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = { \n1\n, -\n1\n, -\n3\n, -\n2\n, \n7\n, \n5\n, \n11\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nsegregateElements(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "index": 316, "complexity": 3}
{"back-translation": "class Node { int key; Node left, right; public Node(int item) { key = item; left = right = null; } } class BinaryTree { Node root; BinaryTree() { root = null; } void printPostorder(Node node) { if (node == null) return; printPostorder(node.left); printPostorder(node.right); System.out.print(node.key + \" \"); } void printInorder(Node node) { if (node == null) return; printInorder(node.left); System.out.print(node.key + \" \"); printInorder(node.right); } void printPreorder(Node node) { if (node == null) return; System.out.print(node.key + \" \"); printPreorder(node.left); printPreorder(node.right); } void printPostorder() { printPostorder(root); } void printInorder() { printInorder(root); } void printPreorder() { printPreorder(root); } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(4); tree.root.left.right = new Node(5); System.out.println(\"Preorder traversal of binary tree is \"); tree.printPreorder(); System.out.println(\"\\nInorder traversal of binary tree is \"); tree.printInorder(); System.out.println(\"\\nPostorder traversal of binary tree is \"); tree.printPostorder(); } }", "src": "\n// Java program for different tree traversals \n\n/* Class containing left and right child of current \n\nnode and key value*/\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\nkey = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\n// Root of Binary Tree \n\nNode root; \n\n\nBinaryTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n/* Given a binary tree, print its nodes according to the \n\n\"bottom-up\" postorder traversal. */\n\nvoid\nprintPostorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n// first recur on left subtree \n\nprintPostorder(node.left); \n\n\n// then recur on right subtree \n\nprintPostorder(node.right); \n\n\n// now deal with the node \n\nSystem.out.print(node.key + \n\" \"\n); \n\n} \n\n\n/* Given a binary tree, print its nodes in inorder*/\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n/* first recur on left child */\n\nprintInorder(node.left); \n\n\n/* then print the data of node */\n\nSystem.out.print(node.key + \n\" \"\n); \n\n\n/* now recur on right child */\n\nprintInorder(node.right); \n\n} \n\n\n/* Given a binary tree, print its nodes in preorder*/\n\nvoid\nprintPreorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n/* first print data of node */\n\nSystem.out.print(node.key + \n\" \"\n); \n\n\n/* then recur on left sutree */\n\nprintPreorder(node.left); \n\n\n/* now recur on right subtree */\n\nprintPreorder(node.right); \n\n} \n\n\n// Wrappers over above recursive functions \n\nvoid\nprintPostorder() { printPostorder(root); } \n\nvoid\nprintInorder() { printInorder(root); } \n\nvoid\nprintPreorder() { printPreorder(root); } \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\n\nSystem.out.println(\n\"Preorder traversal of binary tree is \"\n); \n\ntree.printPreorder(); \n\n\nSystem.out.println(\n\"\\nInorder traversal of binary tree is \"\n); \n\ntree.printInorder(); \n\n\nSystem.out.println(\n\"\\nPostorder traversal of binary tree is \"\n); \n\ntree.printPostorder(); \n\n} \n} ", "index": 317, "complexity": 3}
{"back-translation": "import java.util.*;import java.io.*;import java.lang.*;import java.math.*;public class C {public static void main(String[] args) throws Exception {BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));int n = Integer.parseInt(bf.readLine());int counter = 0;for(int i=0; i<2*n/3; i++) System.out.println(\"0 \" + i);for(int i=0; i<n-2*n/3; i++) System.out.println(\"3 \" + (2*i+1));}}", "src": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class C {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        // Scanner scan = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(bf.readLine());\n        int counter = 0;\n        for(int i=0; i<2*n/3; i++) System.out.println(\"0 \" + i);\n        for(int i=0; i<n-2*n/3; i++) System.out.println(\"3 \" + (2*i+1));\n\n    }\n}\n", "index": 318, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class C{\n    static PrintWriter out;\n    static InputReader in;\n    public static void main(String args[]){\n        out = new PrintWriter(System.out);\n        in = new InputReader();\n        new C();\n        out.flush(); out.close();\n    }   \n    C(){\n       int w = solve();\n       out.print(w == 0 ? \"sjfnb\" : \"cslnb\");\n    }\n    int n;\n    long a[];\n    int solve(){\n        n = in.nextInt(); a = new long[n];\n        long sum = 0;\n        for(int i = 0; i < n; i++)sum += a[i] = in.nextLong();\n        if(sum == 0){\n            return 1;\n        }\n        Arrays.sort(a);\n        int c = 0, c0 = 0; long p = -1, max = 0;\n        int f = 0;\n        long t = -1; int pp = -1;\n        for(int i = 0; i < n; i++){\n            if(a[i] == p){\n                c++;\n            }else{\n                if(p == 0)c0 = c;\n                if(c >= 2){f++; t = p; pp = i - 2;}\n                max = Math.max(max, c);\n                p = a[i];\n                c = 1;\n            }\n        }\n        max = Math.max(max, c);\n        sum = 0;\n        if(c >= 2){f++; t = p; pp = n - 2;}\n        if(max > 2 || c0 > 1 || f > 1)return 1;\n        if(f == 1){\n            long v = Arrays.binarySearch(a, t - 1);\n            if(v >= 0)return 1;\n            a[pp]--; sum = 1;\n        }\n\n        p = -1;\n        for(int i = 0; i < n; i++){\n            sum += a[i] - (p + 1);\n            a[i] = p + 1;\n            p = a[i];\n        }\n\n        return 1 - (int)(sum % 2);\n    }\n    public static class InputReader{\n        BufferedReader br;\n        StringTokenizer st;\n        InputReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        public String next(){\n            while(st == null || !st.hasMoreTokens()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch(IOException e){}\n            }\n            return st.nextToken();\n        }\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\npublic class C{\n    static PrintWriter out;\n    static InputReader in;\n    public static void main(String args[]){\n        out = new PrintWriter(System.out);\n        in = new InputReader();\n        new C();\n        out.flush(); out.close();\n    }   \n    C(){\n       int w = solve();\n       out.print(w == 0 ? \"sjfnb\" : \"cslnb\");\n    }\n    int n;\n    long a[];\n    int solve(){\n        n = in.nextInt(); a = new long[n];\n        long sum = 0;\n        for(int i = 0; i < n; i++)sum += a[i] = in.nextLong();\n        if(sum == 0){\n            return 1;\n        }\n        Arrays.sort(a);\n        int c = 0, c0 = 0; long p = -1, max = 0;\n        int f = 0;\n        long t = -1; int pp = -1;\n        for(int i = 0; i < n; i++){\n            if(a[i] == p){\n                c++;\n            }else{\n                if(p == 0)c0 = c;\n                if(c >= 2){f++; t = p; pp = i - 2;}\n                max = Math.max(max, c);\n                p = a[i];\n                c = 1;\n            }\n        }\n        max = Math.max(max, c);\n        sum = 0;\n        if(c >= 2){f++; t = p; pp = n - 2;}\n        if(max > 2 || c0 > 1 || f > 1)return 1;\n        if(f == 1){\n            long v = Arrays.binarySearch(a, t - 1);\n            if(v >= 0)return 1;\n            a[pp]--; sum = 1;\n        }\n\n        p = -1;\n        for(int i = 0; i < n; i++){\n            sum += a[i] - (p + 1);\n            a[i] = p + 1;\n            p = a[i];\n        }\n\n        return 1 - (int)(sum % 2);\n    }\n    public static class InputReader{\n        BufferedReader br;\n        StringTokenizer st;\n        InputReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        public String next(){\n            while(st == null || !st.hasMoreTokens()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch(IOException e){}\n            }\n            return st.nextToken();\n        }\n    }\n}\n        ", "index": 319, "complexity": 3}
{"back-translation": "import java.util.*; import java.lang.*; public class GfG { public static String noAdjacentDup(String s1) { int n = s1.length(); char[] s = s1.toCharArray(); for (int i = 1; i < n; i++) { if (s[i] == s[i - 1]) { s[i] = 'a'; while (s[i] == s[i - 1] || (i + 1 < n && s[i] == s[i + 1])) s[i]++; i++; } } return (new String(s)); } public static void main(String argc[]) { String s = \"geeksforgeeks\"; System.out.println(noAdjacentDup(s)); } }", "src": "\n// Java program to print a string with \n// no adjacent duplicates by doing \n// minimum changes to original string \nimport\njava.util.*; \nimport\njava.lang.*; \n\npublic\nclass\nGfG{ \n\n\n// Function to print simple string \n\npublic\nstatic\nString noAdjacentDup(String s1) \n\n{ \n\nint\nn = s1.length(); \n\nchar\n[] s = s1.toCharArray(); \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n// If any two adjacent \n\n// characters are equal \n\nif\n(s[i] == s[i - \n1\n]) \n\n{ \n\n// Initialize it to 'a' \n\ns[i] = \n'a'\n; \n\n\n// Traverse the loop until it \n\n// is different from the left \n\n// and right letter. \n\nwhile\n(s[i] == s[i - \n1\n] || \n\n(i + \n1\n< n && s[i] == s[i + \n1\n])) \n\ns[i]++; \n\n\ni++; \n\n} \n\n} \n\nreturn\n(\nnew\nString(s)); \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\n\nString s = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(noAdjacentDup(s)); \n\n\n} \n\n} \n\n/* This code is contributed by Sagar Shukla */", "index": 320, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\npublic class codef\n{\n    public static void main(String ar[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n      \tint n=Integer.parseInt(br.readLine());\n        String st[]=br.readLine().split(\" \");\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n        \ta[i]=Integer.parseInt(st[i]);\n        int max=0;\n        for(int i=0;i<n;i++)\n        {\n        \tif(i!=0 && a[i]>a[max])\n        \t\tmax=i;\n        }\n        int maxi=max;\n        int i=max-1;\n        \twhile(i>=0)\n        \t{\n            \tif(a[i]>a[max])\n            \t{\n                \tSystem.out.println(\"NO\");\n                \treturn;\n            \t}\n            \tmax=i;\n            \ti--;\n        \t}\n        \tmax=maxi;\n        \ti=max+1;\n        \twhile(i<n)\n        \t{\n            \tif(a[i]>a[max])\n            \t{\n                \tSystem.out.println(\"NO\");\n                \treturn;\n            \t}\n            \tmax=i;\n            \ti++;\n        \t}\n        \tSystem.out.println(\"YES\");\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\npublic class codef\n{\n    public static void main(String ar[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        String st[]=br.readLine().split(\" \");\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n            a[i]=Integer.parseInt(st[i]);\n\n        int max=0;\n        for(int i=0;i<n;i++)\n        {\n            if(i!=0 && a[i]>a[max])\n                max=i;\n        }\n       // System.out.println(a[max]);\n        int maxi=max;\n        int i=max-1;\n        while(i>=0)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i--;\n        }\n        max=maxi;\n        i=max+1;\n        while(i<n)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i++;\n        }\n        System.out.println(\"YES\");\n    }\n}", "index": 321, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class SequenceTransformation {\n    void solve() {\n        int p = 1;\n        int n = in.nextInt();\n        while (n > 0) {\n            if (n == 1) {\n                out.print(p + \" \");\n                break;\n            }\n            if (n == 2) {\n                out.print(p + \" \");\n                out.print(2 * p + \" \");\n                break;\n            }\n            if (n == 3) {\n                out.print(p + \" \");\n                out.print(p + \" \");\n                out.print(3 * p + \" \");\n                break;\n            }\n            for (int i = 0; i < (n + 1) / 2; i++) {\n                out.print(p + \" \");\n            }\n            p *= 2;\n            n /= 2;\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new SequenceTransformation().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class SequenceTransformation {\n    void solve() {\n        int p = 1, n = in.nextInt();\n        while (n > 0) {\n            if (n == 1) {\n                out.print(p + \" \");\n                break;\n            }\n            if (n == 2) {\n                out.print(p + \" \");\n                out.print(2 * p + \" \");\n                break;\n            }\n            if (n == 3) {\n                out.print(p + \" \");\n                out.print(p + \" \");\n                out.print(3 * p + \" \");\n                break;\n            }\n            for (int i = 0; i < (n + 1) / 2; i++) {\n                out.print(p + \" \");\n            }\n            p *= 2;\n            n /= 2;\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new SequenceTransformation().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "index": 322, "complexity": 3}
{"back-translation": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int[] a = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     if(!set2.contains(b)){\n                            set2.add(b);\n                     }else{\n                            System.out.println(2);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "src": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     //if(!set2.contains(b)){\n                            //set2.add(b);\n                     //}else{\n                       //     System.out.println(2);\n                         //   return;\n                     //}\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "index": 325, "complexity": 3}
{"back-translation": "class Partition { static boolean findPartition(int[] arr, int n) { int sum = 0; int i, j; for (i = 0; i < n; i++) sum += arr[i]; if (sum % 2 != 0) return false; boolean[][] part = new boolean[sum / 2 + 1][n + 1]; for (i = 0; i <= n; i++) part[0][i] = true; for (i = 1; i <= sum / 2; i++) part[i][0] = false; for (i = 1; i <= sum / 2; i++) { for (j = 1; j <= n; j++) { part[i][j] = part[i][j - 1]; if (i >= arr[j - 1]) part[i][j] = part[i][j] || part[i - arr[j - 1]][j - 1]; } } return part[sum / 2][n]; } public static void main(String[] args) { int[] arr = {3, 1, 1, 2, 2, 1}; int n = arr.length; if (findPartition(arr, n) == true) System.out.println(\"Can be divided into two subsets of equal sum\"); else System.out.println(\"Can not be divided into two subsets of equal sum\"); } }", "src": "\n// A dynamic programming based Java program for partition problem \nimport\njava.io.*; \n\nclass\nPartition { \n\n\n// Returns true if arr[] can be partitioned in two subsets of \n\n// equal sum, otherwise false \n\nstatic\nboolean\nfindPartition (\nint\narr[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n; \n\nint\ni, j; \n\n\n// Caculcate sun of all elements \n\nfor\n(i = \n0\n; i < n; i++) \n\nsum += arr[i]; \n\n\nif\n(sum%\n2\n!= \n0\n) \n\nreturn\nfalse\n; \n\n\nboolean\npart[][]=\nnew\nboolean\n[sum/\n2\n+\n1\n][n+\n1\n]; \n\n\n// initialize top row as true \n\nfor\n(i = \n0\n; i <= n; i++) \n\npart[\n0\n][i] = \ntrue\n; \n\n\n// initialize leftmost column, except part[0][0], as 0 \n\nfor\n(i = \n1\n; i <= sum/\n2\n; i++) \n\npart[i][\n0\n] = \nfalse\n; \n\n\n// Fill the partition table in botton up manner \n\nfor\n(i = \n1\n; i <= sum/\n2\n; i++) \n\n{ \n\nfor\n(j = \n1\n; j <= n; j++) \n\n{ \n\npart[i][j] = part[i][j-\n1\n]; \n\nif\n(i >= arr[j-\n1\n]) \n\npart[i][j] = part[i][j] || \n\npart[i - arr[j-\n1\n]][j-\n1\n]; \n\n} \n\n} \n\n\n/* // uncomment this part to print table \n\nfor (i = 0; i <= sum/2; i++) \n\n{ \n\nfor (j = 0; j <= n; j++) \n\nprintf (\"%4d\", part[i][j]); \n\nprintf(\"\\n\"); \n\n} */\n\n\nreturn\npart[sum/\n2\n][n]; \n\n} \n\n\n/*Driver function to check for above function*/\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n3\n, \n1\n, \n1\n, \n2\n, \n2\n,\n1\n}; \n\nint\nn = arr.length; \n\nif\n(findPartition(arr, n) == \ntrue\n) \n\nSystem.out.println(\n\"Can be divided into two \"\n\n\"subsets of equal sum\"\n); \n\nelse\n\nSystem.out.println(\n\"Can not be divided into\"\n\n\" two subsets of equal sum\"\n); \n\n\n} \n} \n/* This code is contributed by Devesh Agrawal */", "index": 326, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n    static int n = 5;\n    static int[] arr = new int[5];\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            if (arr[i] >= 0) {\n                arr[i] = -arr[i] - 1;\n            }\n        }\n        if (n % 2 != 0) {\n            int min = 0;\n            for (int i = 1; i < n; i++) {\n                if (arr[i] < arr[min])\n                    min = i;\n            }\n            arr[min] = -arr[min] - 1;\n        }\n        for (int x : arr) {\n            System.out.print(x + \" \");\n        }\n\n    }\n}", "src": "import java.util.*;\n\n\npublic class Main {\n    static int n=5;\n    static int[] arr=new int[5];\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n        int arr[]=new int[n];\n        for (int i=0;i<n;i++)\n        {\n            arr[i]=sc.nextInt();\n        }\n        for (int i=0;i<n;i++)\n        {\n            if (arr[i]>=0)\n            {\n                arr[i]=-arr[i]-1;\n            }\n        }\n        if (n%2!=0)\n        {\n            int min=0;\n            for (int i=1;i<n;i++)\n            {\n                if (arr[i]<arr[min])\n                    min=i;\n            }\n            arr[min]=-arr[min]-1;\n        }\n        for (int x:arr)\n        {\n            System.out.print(x + \" \");\n        }\n\n    }\n}", "index": 327, "complexity": 3}
{"back-translation": "public class FullNodes { public static void findFullNode(Node root) { if (root != null) { findFullNode(root.left); if (root.left != null && root.right != null) System.out.print(root.data + \" \"); findFullNode(root.right); } } public static void main(String args[]) { Node root = new Node(1); root.left = new Node(2); root.right = new Node(3); root.left.left = new Node(4); root.right.left = new Node(5); root.right.right = new Node(6); root.right.left.right = new Node(7); root.right.right.right = new Node(8); root.right.left.right.left = new Node(9); findFullNode(root); } } class Node { int data; Node left, right; Node(int data) { left = right = null; this.data = data; } } ", "src": "\n// Java program to find the all full nodes in \n// a given binary tree \npublic\nclass\nFullNodes { \n\n\n// Traverses given tree in Inorder fashion and \n\n// prints all nodes that have both children as \n\n// non-empty. \n\npublic\nstatic\nvoid\nfindFullNode(Node root) \n\n{ \n\nif\n(root != \nnull\n) \n\n{ \n\nfindFullNode(root.left); \n\nif\n(root.left != \nnull\n&& root.right != \nnull\n) \n\nSystem.out.print(root.data+\n\" \"\n); \n\nfindFullNode(root.right); \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.right.left = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\nroot.right.left.right = \nnew\nNode(\n7\n); \n\nroot.right.right.right = \nnew\nNode(\n8\n); \n\nroot.right.left.right.left = \nnew\nNode(\n9\n); \n\nfindFullNode(root); \n\n} \n} \n\n/* A binary tree node */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nleft=right=\nnull\n; \n\nthis\n.data=data; \n\n} \n}; \n//This code is contributed by Gaurav Tiwari ", "index": 328, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n\n        String a = scanner.nextLine(), b = scanner.nextLine();\n\n        int n = b.length(), m = a.length();\n\n        int p[] = new int[n];\n\n        p[0] = b.charAt(0) - '0';\n\n        for (int i = 1; i < n; i++) {\n            p[i] = p[i - 1] + (b.charAt(i) - '0');\n        }\n\n        long ans = 0;\n        for (int i = 0; i < m; i++) {\n            int cur = a.charAt(i) - '0';\n\n            int cnt = p[n - m + i] - (i > 0 ? p[i - 1] : 0);\n\n            if (cur == 0) {\n                ans += cnt;\n            } else {\n                ans += n - m + 1  - cnt;\n            }\n        }\n\n        System.out.println(ans);\n\n    }\n\n    class Pair {\n        int c, f;\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n\n        String a = scanner.nextLine(), b = scanner.nextLine();\n\n        int n = b.length(), m = a.length();\n\n        int p[] = new int[n];\n\n        p[0] = b.charAt(0) - '0';\n\n        for (int i = 1; i < n; i++) {\n            p[i] = p[i - 1] + (b.charAt(i) - '0');\n        }\n\n        long ans = 0;\n        for (int i = 0; i < m; i++) {\n            int cur = a.charAt(i) - '0';\n\n            int cnt = p[n - m + i] - (i > 0 ? p[i - 1] : 0);\n\n            if (cur == 0) {\n                ans += cnt;\n            } else {\n                ans += n - m + 1  - cnt;\n            }\n        }\n\n        System.out.println(ans);\n\n    }\n\n\n    class Pair {\n        int c, f;\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "index": 329, "complexity": 3}
{"back-translation": "import java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\nimport static java.lang.Math.ceil;\n\npublic class practise {\n    static final int N = 31;\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out,true);\n    static long[] c = new long[N];\n    static int[] w = new int[N];\n\n    public static void main(String[] args) {\n        w[0] = 1;\n        for (int i = 1; i < N; i++) w[i] = w[i - 1] * 2;\n        int n = sc.nextInt();\n        int l = sc.nextInt();\n        for (int i = 0; i < N; i++) c[i] = Long.MAX_VALUE;\n        for (int i = 0; i < n; i++) c[i] = sc.nextInt();\n        for (int i = 1; i < N; i++) {\n            c[i] = min(c[i - 1] * 2, c[i]);\n        }\n        long ans = 0;\n        for (int i = 0; i < N; i++) {\n            if ((l & w[i]) != 0) {\n                ans += c[i];\n            }\n        }\n        long m = 0;\n        for (int i = N - 1; i >= 0; i--) {\n            if ((l & w[i]) != 0) {\n                m += c[i];\n            } else {\n                ans = min(ans, m + c[i]);\n            }\n        }\n        out.println(ans);\n    }\n\n    static long min(long a, long b) {\n        return a < b ? a : b;\n    }\n}", "src": "import java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\nimport static java.lang.Math.ceil;\n\npublic class practise {\n    static final int N = 31;\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out,true);\n    static long c[] = new long[N];\n    static int w[] = new int[N];\n    public static void main(String[] args) {\n        w[0] = 1;\n        for(int i=1;i<N;i++) w[i] = w[i-1]*2;\n        int n = sc.nextInt(); int l = sc.nextInt();\n        for(int i=0;i<N;i++) c[i] = Long.MAX_VALUE;\n        for(int i=0;i<n;i++) c[i] = sc.nextInt();\n        for(int i=1;i<N;i++) {\n            c[i] = min(c[i-1]*2,c[i]);\n        }\n        long ans = 0;\n        for(int i=0;i<N;i++) {\n            if( (l&w[i])!=0) {\n                ans += c[i];\n            }\n        }\n        long m = 0;\n        for(int i=N - 1;i>=0;i--) {\n            if((l&w[i])!=0) {\n                m += c[i];\n            } else {\n                ans = min(ans,m+c[i]);\n            }\n        }\n        out.println(ans);\n    }\n\n    static long min(long a,long b) {\n        return a<b?a:b;\n    }\n}\n", "index": 330, "complexity": 3}
{"back-translation": "class GFG { static int maxRevenue(int m, int[] x, int[] revenue, int n, int t) { int[] maxRev = new int[m + 1]; for (int i = 0; i < m + 1; i++) maxRev[i] = 0; int nxtbb = 0; for (int i = 1; i <= m; i++) { if (nxtbb < n) { if (x[nxtbb] != i) maxRev[i] = maxRev[i - 1]; else { if (i <= t) maxRev[i] = Math.max(maxRev[i - 1], revenue[nxtbb]); else maxRev[i] = Math.max(maxRev[i - t - 1] + revenue[nxtbb], maxRev[i - 1]); nxtbb++; } } else maxRev[i] = maxRev[i - 1]; } return maxRev[m]; } public static void main(String[] args) { int m = 20; int[] x = new int[]{6, 7, 12, 13, 14}; int[] revenue = new int[]{5, 6, 5, 3, 1}; int n = x.length; int t = 5; System.out.println(maxRevenue(m, x, revenue, n, t)); } }", "src": "\n// Java program to find maximum revenue \n// by placing billboard on the highway \n// with given constarints. \n\nclass\nGFG \n{ \n\nstatic\nint\nmaxRevenue(\nint\nm, \nint\n[] x, \n\nint\n[] revenue, \n\nint\nn, \nint\nt) \n{ \n\n\n// Array to store maximum revenue \n\n// at each miles. \n\nint\n[] maxRev = \nnew\nint\n[m + \n1\n]; \n\nfor\n(\nint\ni = \n0\n; i < m + \n1\n; i++) \n\nmaxRev[i] = \n0\n; \n\n\n// actual minimum distance between \n\n// 2 billboards. \n\nint\nnxtbb = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\n{ \n\n// check if all billboards are \n\n// already placed. \n\nif\n(nxtbb < n) \n\n{ \n\n// check if we have billboard for \n\n// that particular mile. If not, \n\n// copy the previous maximum revenue. \n\nif\n(x[nxtbb] != i) \n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n\n// we do have billboard for this mile. \n\nelse\n\n{ \n\n// We have 2 options, we either take \n\n// current or we ignore current billboard. \n\n\n// If current position is less than or \n\n// equal to t, then we can have only \n\n// one billboard. \n\nif\n(i <= t) \n\nmaxRev[i] = Math.max(maxRev[i - \n1\n], \n\nrevenue[nxtbb]); \n\n\n// Else we may have to remove \n\n// previously placed billboard \n\nelse\n\nmaxRev[i] = Math.max(maxRev[i - t - \n1\n] + \n\nrevenue[nxtbb], \n\nmaxRev[i - \n1\n]); \n\n\nnxtbb++; \n\n} \n\n} \n\nelse\n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n} \n\n\nreturn\nmaxRev[m]; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String []args) \n{ \n\nint\nm = \n20\n; \n\nint\n[] x = \nnew\nint\n[]{\n6\n, \n7\n, \n12\n, \n13\n, \n14\n}; \n\nint\n[] revenue = \nnew\nint\n[]{\n5\n, \n6\n, \n5\n, \n3\n, \n1\n}; \n\nint\nn = x.length; \n\nint\nt = \n5\n; \n\nSystem.out.println(maxRevenue(m, x, revenue, n, t)); \n} \n} \n\n// This code is contributed by Ita_c. ", "index": 331, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader in = new FastReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong n = in.nextLong();\n\t\tlong k = in.nextLong();\n\t\tlong s = in.nextLong();\n\t\tif (k > s || k * (n - 1) < s) {\n\t\t\tout.println(\"NO\");\n\t\t} else {\n\t\t\tout.println(\"YES\");\n\t\t\tlong cur = 1;\n\t\t\twhile (k > 0) {\n\t\t\t\tlong x = Math.min(n - 1, s - k + 1);\n\t\t\t\tif ( cur - x > 0 ) {\n\t\t\t\t\tcur  -= x;\n\t\t\t\t} else {\n\t\t\t\t\tcur += x;\n\t\t\t\t}\n\t\t\t\tout.print(cur + \" \");\n\t\t\t\ts -= x;\n\t\t\t\tk--;\n\t\t\t}\n\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class FastReader {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic FastReader(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic FastReader(FileReader fileReader) {\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n}", "src": "\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader in = new FastReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong n = in.nextLong();\n\t\tlong k = in.nextLong();\n\t\tlong s = in.nextLong();\n\t\tif (k > s || k * (n - 1) < s) {\n\t\t\tout.println(\"NO\");\n\t\t} else {\n\t\t\tout.println(\"YES\");\n\t\t\tlong cur = 1;\n\t\t\twhile (k > 0) {\n\t\t\t\tlong x = Math.min(n - 1, s - k + 1);\n\t\t\t\tcur = ( cur - x > 0 ? cur  - x : cur + x);\n\t\t\t\tout.print(cur + \" \");\n\t\t\t\ts -= x;\n\t\t\t\tk--;\n\t\t\t}\n\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class FastReader {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic FastReader(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic FastReader(FileReader fileReader) {\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n}", "index": 332, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static void solve(InputReader in, OutputWriter out) {\n        int n = in.nextInt();\n        if (n < 6) {\n            out.println(-1);\n        } else {\n            int m = (n - 1);\n            for (int i = 1; i <= m; i++) {\n                out.println(\"1 \" + i);\n            }\n            out.println(m + \" \" + n);\n            out.println(\"1 \" + n);\n        }\n        for (int i = 1; i <= n; i++) {\n            out.println(\"1 \" + i);\n        }\n    }\n\n    private static void shuffleArray(int[] array) {\n        int index;\n        Random random = new Random();\n        for (int i = array.length - 1; i >= 0; i--) {\n            index = random.nextInt(i);\n            if (index != i) {\n                array[index] ^= array[i];\n                array[i] ^= array[index];\n                array[index] ^= array[i];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        solve(in, out);\n        in.close();\n        out.close();\n    }\n\n    private static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        InputReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n            st = null;\n        }\n\n        String nextLine() {\n            String line = null;\n            try {\n                line = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return line;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = nextLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        byte nextByte() {\n            return Byte.parseByte(next());\n        }\n\n        short nextShort() {\n            return Short.parseShort(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class OutputWriter {\n        BufferedWriter bw;\n\n        OutputWriter(OutputStream os) {\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n        }\n\n        void print(int i) {\n            print(Integer.toString(i));\n        }\n\n        void println(int i) {\n            println(Integer.toString(i));\n        }\n\n        void print(long l) {\n            print(Long.toString(l));\n        }\n\n        void println(long l) {\n            println(Long.toString(l));\n        }\n\n        void print(double d) {\n            print(Double.toString(d));\n        }\n\n        void println(double d) {\n            println(Double.toString(d));\n        }\n\n        void print(boolean b) {\n            print(Boolean.toString(b));\n        }\n\n        void println(boolean b) {\n            println(Boolean.toString(b));\n        }\n\n        void print(char c) {\n            try {\n                bw.write(c);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(char c) {\n            println(Character.toString(c));\n        }\n\n        void print(String s) {\n            try {\n                bw.write(s);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(String s) {\n            print(s);\n            print(\"\n\");\n        }\n\n        void close() {\n            try {\n                bw.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static void solve(InputReader in, OutputWriter out) {\n        int n = in.nextInt();\n\n        if (n < 6) {\n            out.println(-1);\n        } else {\n            int m = (n - 2);\n            for (int i = 2; i <= m; i++) {\n                out.println(\"1 \" + i);\n            }\n            out.println(m + \" \" + (m + 1));\n            out.println(m + \" \" + (m + 2));\n        }\n\n        for (int i = 2; i <= n; i++) {\n            out.println(\"1 \" + i);\n        }\n    }\n\n    private static void shuffleArray(int[] array) {\n        int index;\n        Random random = new Random();\n        for (int i = array.length - 1; i > 0; i--) {\n            index = random.nextInt(i + 1);\n            if (index != i) {\n                array[index] ^= array[i];\n                array[i] ^= array[index];\n                array[index] ^= array[i];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        solve(in, out);\n        in.close();\n        out.close();\n    }\n\n    private static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        InputReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n            st = null;\n        }\n\n        String nextLine() {\n            String line = null;\n            try {\n                line = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return line;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = nextLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        byte nextByte() {\n            return Byte.parseByte(next());\n        }\n\n        short nextShort() {\n            return Short.parseShort(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class OutputWriter {\n        BufferedWriter bw;\n\n        OutputWriter(OutputStream os) {\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n        }\n\n        void print(int i) {\n            print(Integer.toString(i));\n        }\n\n        void println(int i) {\n            println(Integer.toString(i));\n        }\n\n        void print(long l) {\n            print(Long.toString(l));\n        }\n\n        void println(long l) {\n            println(Long.toString(l));\n        }\n\n        void print(double d) {\n            print(Double.toString(d));\n        }\n\n        void println(double d) {\n            println(Double.toString(d));\n        }\n\n        void print(boolean b) {\n            print(Boolean.toString(b));\n        }\n\n        void println(boolean b) {\n            println(Boolean.toString(b));\n        }\n\n        void print(char c) {\n            try {\n                bw.write(c);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(char c) {\n            println(Character.toString(c));\n        }\n\n        void print(String s) {\n            try {\n                bw.write(s);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(String s) {\n            print(s);\n            print('\\n');\n        }\n\n        void close() {\n            try {\n                bw.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n", "index": 333, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class C {\n\n    void solve(){\n       int n = readInt();\n       int q = readInt();\n       int max = 0;\n       int[] a = new int[n];\n       Deque<Integer> deque = new ArrayDeque<>();\n       for(int i = 0;i<n;i++){\n           a[i] = readInt();\n           deque.addLast(a[i]);\n           max = Math.max(max, a[i]);\n       }\n        List<String> ans = new ArrayList<>();\n        while(deque.peekFirst() != max){\n           int one = deque.pollFirst();\n           int two = deque.pollFirst();\n           ans.add(one + \" \" + two);\n           deque.addFirst(one > two ? one : two);\n           deque.addLast(one > two ? two : one);\n           if(one == max) break;\n       }\n\n       for(int i = 0;i<n;i++){\n           a[i] = deque.pollFirst();\n       }\n\n       for(int i = 0;i<q;i++){\n          long x = readLong();\n           if(x <= ans.size()){\n               out.println(ans.get((int)x - 1));\n               continue;\n           }\n           x -= ans.size();\n           int y =(int) (x%(n - 1) - 1%(n - 1) + (n - 1)) % (n - 1) + 1;\n           out.println(max + \" \" + a[y]);\n       }\n    }\n\n    public static void main(String[] args) {\n        new C().run();\n    }\n\n    void run(){\n        init();\n        solve();\n        out.close();\n    }\n\n    BufferedReader in;\n    PrintWriter out;\n\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init(){\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out  = new PrintWriter(System.out);\n    }\n\n    String readLine(){\n        try{\n            return in.readLine();\n        }catch(Exception ex){\n            throw new RuntimeException(ex);\n        }\n    }\n    String readString(){\n        while(!tok.hasMoreTokens()){\n            String nextLine = readLine();\n            if(nextLine == null) return null;\n            tok = new StringTokenizer(nextLine);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt(){\n        return Integer.parseInt(readString());\n    }\n\n    long readLong(){\n        return Long.parseLong(readString());\n    }\n\n    double readDouble(){\n        return Double.parseDouble(readString());\n    }\n}\n", "src": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class C {\n\n    void solve(){\n       int n = readInt();\n       int q = readInt();\n       int max = 0;\n       int[] a = new int[n];\n       Deque<Integer> deque = new ArrayDeque<>();\n       for(int i = 0;i<n;i++){\n           a[i] = readInt();\n           deque.addLast(a[i]);\n           max = Math.max(max, a[i]);\n       }\n        List<String> ans = new ArrayList<>();\n        while(deque.peekFirst() != max){\n           int one = deque.pollFirst();\n           int two = deque.pollFirst();\n           ans.add(one + \" \" + two);\n           deque.addFirst(one > two ? one : two);\n           deque.addLast(one > two ? two : one);\n           if(one == max) break;\n       }\n\n       for(int i = 0;i<n;i++){\n           a[i] = deque.pollFirst();\n       }\n\n       for(int i = 0;i<q;i++){\n          long x = readLong();\n           if(x <= ans.size()){\n               out.println(ans.get((int)x - 1));\n               continue;\n           }\n           x -= ans.size();\n           int y =(int) (x%(n - 1) - 1%(n - 1) + (n - 1)) % (n - 1) + 1;\n           out.println(max + \" \" + a[y]);\n       }\n    }\n\n    public static void main(String[] args) {\n        new C().run();\n    }\n\n    void run(){\n        init();\n        solve();\n        out.close();\n    }\n\n    BufferedReader in;\n    PrintWriter out;\n\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init(){\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out  = new PrintWriter(System.out);\n    }\n\n    String readLine(){\n        try{\n            return in.readLine();\n        }catch(Exception ex){\n            throw new RuntimeException(ex);\n        }\n    }\n    String readString(){\n        while(!tok.hasMoreTokens()){\n            String nextLine = readLine();\n            if(nextLine == null) return null;\n            tok = new StringTokenizer(nextLine);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt(){\n        return Integer.parseInt(readString());\n    }\n\n    long readLong(){\n        return Long.parseLong(readString());\n    }\n\n    double readDouble(){\n        return Double.parseDouble(readString());\n    }\n}\n", "index": 335, "complexity": 3}
{"back-translation": "class GFG {\n\n    static int x, y;\n\n    static void getTwoElements(int arr[], int n) {\n        int xor1;\n        int set_bit_no;\n        int i;\n        x = 0;\n        y = 0;\n        xor1 = arr[0];\n        for (i = 1; i < n; i++)\n            xor1 = xor1 ^ arr[i];\n        for (i = 1; i <= n; i++)\n            xor1 = xor1 ^ i;\n        set_bit_no = xor1 & ~(xor1 - 1);\n        for (i = 0; i < n; i++) {\n            if ((arr[i] & set_bit_no) != 0)\n                x = x ^ arr[i];\n            else\n                y = y ^ arr[i];\n        }\n        for (i = 1; i <= n; i++) {\n            if ((i & set_bit_no) != 0)\n                x = x ^ i;\n            else\n                y = y ^ i;\n        }\n    }\n\n    public static void main(String[] args) {\n        int arr[] = { 1, 3, 4, 5, 1, 6, 2 };\n        int n = arr.length;\n        getTwoElements(arr, n);\n        System.out.println(\" The missing element is \" + x + \"and the \" + \"repeating number is \" + y);\n    }\n}", "src": "\n// Java program to Find the repeating \n// and missing elements \n\nimport\njava.io.*; \n\nclass\nGFG { \n\nstatic\nint\nx, y; \n\n\nstatic\nvoid\ngetTwoElements(\nint\narr[], \nint\nn) \n\n{ \n\n/* Will hold xor of all elements \n\nand numbers from 1 to n */\n\nint\nxor1; \n\n\n/* Will have only single set bit of xor1 */\n\nint\nset_bit_no; \n\n\nint\ni; \n\nx = \n0\n; \n\ny = \n0\n; \n\n\nxor1 = arr[\n0\n]; \n\n\n/* Get the xor of all array elements */\n\nfor\n(i = \n1\n; i < n; i++) \n\nxor1 = xor1 ^ arr[i]; \n\n\n/* XOR the previous result with numbers from \n\n1 to n*/\n\nfor\n(i = \n1\n; i <= n; i++) \n\nxor1 = xor1 ^ i; \n\n\n/* Get the rightmost set bit in set_bit_no */\n\nset_bit_no = xor1 & ~(xor1 - \n1\n); \n\n\n/* Now divide elements into two sets by comparing \n\nrightmost set bit of xor1 with the bit at the same \n\nposition in each element. Also, get XORs of two \n\nsets. The two XORs are the output elements. The \n\nfollowing two for loops serve the purpose */\n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n((arr[i] & set_bit_no) != \n0\n) \n\n/* arr[i] belongs to first set */\n\nx = x ^ arr[i]; \n\n\nelse\n\n/* arr[i] belongs to second set*/\n\ny = y ^ arr[i]; \n\n} \n\nfor\n(i = \n1\n; i <= n; i++) { \n\nif\n((i & set_bit_no) != \n0\n) \n\n/* i belongs to first set */\n\nx = x ^ i; \n\n\nelse\n\n/* i belongs to second set*/\n\ny = y ^ i; \n\n} \n\n\n/* *x and *y hold the desired output elements */\n\n} \n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n4\n, \n5\n, \n1\n, \n6\n, \n2\n}; \n\n\nint\nn = arr.length; \n\ngetTwoElements(arr, n); \n\nSystem.out.println(\n\" The missing element is \"\n\n+ x + \n\"and the \"\n\n+ \n\"repeating number is \"\n\n+ y); \n\n} \n} \n\n// This code is contributed by Gitanjali. ", "index": 337, "complexity": 3}
{"back-translation": "// Java program to find max value of i*arr[i]\n\nimport\njava.util.Arrays;\n\nclass\nTest \n{\n\nstatic\nint\narr[] = \nnew\nint\n[]{\n10\n, \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n};\n\nstatic\nint\nmaxSum()\n{\nint\narrSum = 0;\nint\ncurrVal = 0;\nfor\n(\nint\ni = 0; i < arr.length; i++)\n{\narrSum = arrSum + arr[i];\ncurrVal = currVal + (i * arr[i]);\n}\nint\nmaxVal = currVal;\nfor\n(\nint\nj = 1; j < arr.length; j++)\n{\ncurrVal = currVal + arrSum - arr.length * arr[arr.length - j];\nif\n(currVal > maxVal)\nmaxVal = currVal;\n}\nreturn\nmaxVal;\n}\n\npublic\nstatic\nvoid\nmain(String[] args)\n{\nSystem.out.println(\n\"Max sum is \" + maxSum());\n}\n}", "src": "\n// Java program to find max value of i*arr[i] \n\nimport\njava.util.Arrays; \n\nclass\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n10\n, \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\n\n// Returns max possible value of i*arr[i] \n\nstatic\nint\nmaxSum() \n\n{ \n\n// Find array sum and i*arr[i] with no rotation \n\nint\narrSum = \n0\n; \n// Stores sum of arr[i] \n\nint\ncurrVal = \n0\n; \n// Stores sum of i*arr[i] \n\nfor\n(\nint\ni=\n0\n; i<arr.length; i++) \n\n{ \n\narrSum = arrSum + arr[i]; \n\ncurrVal = currVal+(i*arr[i]); \n\n} \n\n\n// Initialize result as 0 rotation sum \n\nint\nmaxVal = currVal; \n\n\n// Try all rotations one by one and find \n\n// the maximum rotation sum. \n\nfor\n(\nint\nj=\n1\n; j<arr.length; j++) \n\n{ \n\ncurrVal = currVal + arrSum-arr.length*arr[arr.length-j]; \n\nif\n(currVal > maxVal) \n\nmaxVal = currVal; \n\n} \n\n\n// Return result \n\nreturn\nmaxVal; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Max sum is \"\n+ maxSum()); \n\n} \n} ", "index": 338, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n    static int check(int temp) {\n        int count1 = 0;\n        while (temp > 0) {\n            if (temp % 2 != 0) count1++;\n            temp /= 2;\n        }\n        return count1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String a = sc.next();\n        String b = sc.next();\n        int m = a.length();\n        int n = b.length();\n        int[] zero = new int[n];\n        int[] one = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n                if (b.charAt(i) == '0') zero[i]++;\n                else one[i]++;\n            } else {\n                zero[i] = zero[i - 1];\n                one[i] = one[i - 1];\n                if (b.charAt(i) == '0') zero[i]++;\n                else one[i]++;\n            }\n        }\n\n        long res = 0;\n        for (int i = 0; i < m; i++) {\n            int x = n - m + i;\n            if (a.charAt(i) == '0') res += one[x];\n            else res += zero[x];\n            if (i > 0) {\n                if (a.charAt(i) == '0') res -= one[i - 1];\n                else res -= zero[i - 1];\n            }\n        }\n\n        System.out.println(res);\n    }\n}", "src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tstatic int check(int temp)\n\t{\n\t\tint count1 = 0; \n    while (temp>0) \n    { \n        if(temp % 2 != 0) \n        count1++; \n        temp/= 2; \n    } \n    return count1;\n\t}\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tScanner sc=new Scanner(System.in);\n\t\tString a=sc.next();\n\t\tString b=sc.next();\n\t\tint m=a.length();\n\t\tint n=b.length();\n\t\tint[] zero=new int[n];\n\t\tint[] one=new int[n];\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i==0)\n\t\t\t{\n\t\t\t\tif(b.charAt(i)=='0')\n\t\t\t\tzero[i]++;\n\t\t\t\telse\n\t\t\t\tone[i]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tzero[i]=zero[i-1];\n\t\t\t\tone[i]=one[i-1];\n\t\t\t\tif(b.charAt(i)=='0')\n\t\t\t\tzero[i]++;\n\t\t\t\telse\n\t\t\t\tone[i]++;\n\t\t    }\n\t\t}\n\t\t\n\n\t\tlong res=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\tint x=n-m+i;\n\t\tif(a.charAt(i)=='0')\n\t\tres+=one[x];\n\t\telse\n\t\tres+=zero[x];\n\t\tif(i>0)\n\t\t{\n\t\t\tif(a.charAt(i)=='0')\n\t\t\tres-=one[i-1];\n\t\t\telse\n\t\t\tres-=zero[i-1];\n\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(res);\n\t}\n}", "index": 339, "complexity": 3}
{"back-translation": "public class Solution { static boolean checkLevelLeafNode(Node root) { if(root == null) return true; Queue<Node> q = new LinkedList<>(); q.add(root); int result = Integer.MAX_VALUE; int level = 0; while(q.size() != 0) { int size = q.size(); level++; while(size > 0) { Node temp = q.remove(); if(temp.left != null) { q.add(temp.left); if(temp.left.left == null && temp.left.right == null) { if(result == Integer.MAX_VALUE) result = level; else if(result != level) return false; } } if(temp.right != null) { q.add(temp.right); if(temp.right.left == null && temp.right.right == null) { if(result == Integer.MAX_VALUE) result = level; else if(result != level) return false; } } size--; } } return true; } public static void main(String args[]) { Node root = new Node(1); root.left = new Node(2); root.right = new Node(3); root.left.right = new Node(4); root.right.left = new Node(5); root.right.right = new Node(6); boolean result = checkLevelLeafNode(root); if(result == true) System.out.println(\"All leaf nodes are at the same level\"); else System.out.println(\"Leaf nodes not at the same level\"); } }", "src": "\n// Java program to check if all leaf nodes are at \n// same level of binary tree \nimport\njava.util.*; \n\n// User defined node class \nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n// Constructor to create a new tree node \n\nNode(\nint\nkey) { \n\nint\ndata = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nGFG { \n\n\n// return true if all leaf nodes are \n\n// at same level, else false \n\nstatic\nboolean\ncheckLevelLeafNode(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n// create a queue for level order traversal \n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\nq.add(root); \n\n\nint\nresult = Integer.MAX_VALUE; \n\nint\nlevel = \n0\n; \n\n\n// traverse until the queue is empty \n\nwhile\n(q.size() != \n0\n) { \n\nint\nsize = q.size(); \n\nlevel++; \n\n\n// traverse for complete level \n\nwhile\n(size > \n0\n) { \n\nNode temp = q.remove(); \n\n\n// check for left child \n\nif\n(temp.left != \nnull\n) { \n\nq.add(temp.left); \n\n\n// if its leaf node \n\nif\n(temp.left.left == \nnull\n&& temp.left.right == \nnull\n) { \n\n\n// if it's first leaf node, then update result \n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n// if it's not first leaf node, then compare \n\n// the level with level of previous leaf node. \n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n// check for right child \n\nif\n(temp.right != \nnull\n) { \n\nq.add(temp.right); \n\n\n// if its leaf node \n\nif\n(temp.right.left == \nnull\n&& temp.right.right == \nnull\n) { \n\n\n// if it's first leaf node, then update result \n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n// if it's not first leaf node, then compare \n\n// the level with level of previous leaf node. \n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\nsize--; \n\n} \n\n\n} \n\nreturn\ntrue\n; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n// construct a tree \n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.right = \nnew\nNode(\n4\n); \n\nroot.right.left = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nboolean\nresult = checkLevelLeafNode(root); \n\nif\n(result == \ntrue\n) \n\nSystem.out.println(\n\"All leaf nodes are at same level\"\n); \n\nelse\n\nSystem.out.println(\n\"Leaf nodes not at same level\"\n); \n\n} \n} \n// This code is contributed by rachana soma ", "index": 340, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] P = new int[n];\n        int[] check = new int[n];\n        for (int i = 1; i < n; i++) {\n\n            P[i] = scanner.nextInt();\n            P[i]--;\n            check[P[i]]++;\n        }\n        int[] leaves = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            if (check[i] == 0) {\n                leaves[P[i]]++;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n\n            if (check[i] > 0 && leaves[i] < 3) {\n                System.out.println(\"No\");\n                return;\n            }\n        }\n        System.out.println(\"Yes\");\n    }\n}\n", "src": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] P = new int[n];\n        int[] check=new int[n];\n        for (int i = 1; i < n; i++) {\n\n            P[i] = scanner.nextInt();\n            P[i]--;\n            check[P[i]]++;\n        }\n        int[] leaves = new int[n];\n\n\n        for (int i=0;i<n;i++) {\n            if(check[i]==0){\n                leaves[P[i]]++;\n            }\n        }\n\n\n        for (int i = 0; i < n; i++) {\n\n            if (check[i]>0&&leaves[i]<3) {\n                System.out.println(\"No\");\n                return;\n            }\n        }\n        System.out.println(\"Yes\");\n    }\n}\n", "index": 341, "complexity": 3}
{"back-translation": "class GfG { static class Node { int data; Node left, right; } static void printOddNodes(Node root) { if (root == null) return; Queue<Node> q = new LinkedList<Node>(); q.add(root); boolean isOdd = true; while (true) { int nodeCount = q.size(); if (nodeCount == 0) break; while (nodeCount > 0) { Node node = q.peek(); if (isOdd == true) System.out.print(node.data + \" \"); q.remove(); if (node.left != null) q.add(node.left); if (node.right != null) q.add(node.right); nodeCount--; } isOdd = !isOdd; } } static Node newNode(int data) { Node node = new Node(); node.data = data; node.left = null; node.right = null; return (node); } public static void main(String[] args) { Node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); printOddNodes(root); } }", "src": "\n// Iterative Java program to print odd level nodes \nimport\njava.util.*; \nclass\nGfG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\n// Iterative method to do level order traversal line by line \nstatic\nvoid\nprintOddNodes(Node root) \n{ \n\n// Base Case \n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n// Create an empty queue for level \n\n// order tarversal \n\nQueue<Node> q = \nnew\nLinkedList<Node> (); \n\n\n// Enqueue root and initialize level as odd \n\nq.add(root); \n\nboolean\nisOdd = \ntrue\n; \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n// nodeCount (queue size) indicates \n\n// number of nodes at current level. \n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n// Dequeue all nodes of current level \n\n// and Enqueue all nodes of next level \n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nif\n(isOdd == \ntrue\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\n\nisOdd = !isOdd; \n\n} \n} \n\n// Utility method to create a node \nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nprintOddNodes(root); \n} \n} ", "index": 342, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tint[] f = new int[n];\n\t\tint[] t = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = sc.nextInt();\n\t\t\tt[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(f, t, s));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] f, int[] t, int s) {\n\t\tint[] maxTimes = new int[s + 1];\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tmaxTimes[f[i]] = Math.max(maxTimes[f[i]], t[i]);\n\t\t}\n\n\t\tint time = 0;\n\t\tfor (int i = s; i > 0; i--) {\n\t\t\ttime = Math.max(time, maxTimes[i]);\n\t\t\ttime++;\n\t\t}\n\t\treturn time;\n\t}\n}", "src": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tint[] f = new int[n];\n\t\tint[] t = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = sc.nextInt();\n\t\t\tt[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(f, t, s));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] f, int[] t, int s) {\n\t\tint[] maxTimes = new int[s + 1];\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tmaxTimes[f[i]] = Math.max(maxTimes[f[i]], t[i]);\n\t\t}\n\n\t\tint time = 0;\n\t\tfor (int i = s; i > 0; i--) {\n\t\t\ttime = Math.max(time, maxTimes[i]);\n\n\t\t\ttime++;\n\t\t}\n\t\treturn time;\n\t}\n}\n", "index": 343, "complexity": 3}
{"back-translation": "ERROR", "src": "// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF903F {\n\tstatic final int INF = 0x3f3f3f3f;\n\tstatic void fill(int[][][][] aa, int a) {\n\t\tfor (int h0 = 0; h0 <= 4; h0++)\n\t\t\tfor (int h1 = 0; h1 <= 4; h1++)\n\t\t\t\tfor (int h2 = 0; h2 <= 4; h2++)\n\t\t\t\t\tfor (int h3 = 0; h3 <= 4; h3++)\n\t\t\t\t\t\taa[h0][h1][h2][h3] = a;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint a1 = Integer.parseInt(st.nextToken());\n\t\tint a2 = Integer.parseInt(st.nextToken());\n\t\tint a3 = Integer.parseInt(st.nextToken());\n\t\tint a4 = Integer.parseInt(st.nextToken());\n\t\tint[] aa = new int[10];\n\t\taa[0] = aa[1] = aa[2] = aa[3] = a1;\n\t\taa[4] = aa[5] = aa[6] = a2;\n\t\taa[7] = aa[8] = a3;\n\t\taa[9] = a4;\n\t\tint[][] ww = new int[10][4];\n\t\tww[0][0] = 1;\n\t\tww[1][1] = 1;\n\t\tww[2][2] = 1;\n\t\tww[3][3] = 1;\n\t\tww[4][0] = ww[4][1] = 2;\n\t\tww[5][1] = ww[5][2] = 2;\n\t\tww[6][2] = ww[6][3] = 2;\n\t\tww[7][0] = ww[7][1] = ww[7][2] = 3;\n\t\tww[8][1] = ww[8][2] = ww[8][3] = 3;\n\t\tww[9][0] = ww[9][1] = ww[9][2] = ww[9][3] = 4;\n\t\tchar[][] cc = new char[4][n + 8];\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tchar[] c_ = cc[k];\n\t\t\tbr.readLine().getChars(0, n, c_, 4);\n\t\t\tc_[0] = c_[1] = c_[2] = c_[3]\n\t\t\t\t= c_[n + 4] = c_[n + 5] = c_[n + 6] = c_[n + 7] = '.';\n\t\t}\n\t\tint[][][][] dp = new int[5][5][5][5];\n\t\tint[][][][] dq = new int[5][5][5][5];\n\t\tfill(dp, INF);\n\t\tdp[4][4][4][4] = 0;\n\t\tint[] hh = new int[4];\n\t\tfor (int i = 0; i < n + 4; i++) {\n\t\t\tfor (int h0 = 0; h0 <= 4; h0++)\n\t\t\t\tfor (int h1 = 0; h1 <= 4; h1++)\n\t\t\t\t\tfor (int h2 = 0; h2 <= 4; h2++)\n\t\t\t\t\t\tfor (int h3 = 0; h3 <= 4; h3++)\n\t\t\t\t\t\t\tfor (int s = 0; s < 10; s++) {\n\t\t\t\t\t\t\t\thh[0] = h0;\n\t\t\t\t\t\t\t\thh[1] = h1;\n\t\t\t\t\t\t\t\thh[2] = h2;\n\t\t\t\t\t\t\t\thh[3] = h3;\n\t\t\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\t\t\tint h = ww[s][k];\n\t\t\t\t\t\t\t\t\tif (hh[k] < h) {\n\t\t\t\t\t\t\t\t\t\twhile (h < 4 && cc[k][i + h] == '.')\n\t\t\t\t\t\t\t\t\t\t\th++;\n\t\t\t\t\t\t\t\t\t\thh[k] = h;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint x = dp[h0][h1][h2][h3] + aa[s];\n\t\t\t\t\t\t\t\tif (dp[hh[0]][hh[1]][hh[2]][hh[3]] > x)\n\t\t\t\t\t\t\t\t\tdp[hh[0]][hh[1]][hh[2]][hh[3]] = x;\n\t\t\t\t\t\t\t}\n\t\t\tfill(dq, INF);\n\t\t\tfor (int h0 = 1; h0 <= 4; h0++) {\n\t\t\t\thh[0] = h0 < 4 || cc[0][i + 4] == '*' ? h0 - 1 : 4;\n\t\t\t\tfor (int h1 = 1; h1 <= 4; h1++) {\n\t\t\t\t\thh[1] = h1 < 4 || cc[1][i + 4] == '*' ? h1 - 1 : 4;\n\t\t\t\t\tfor (int h2 = 1; h2 <= 4; h2++) {\n\t\t\t\t\t\thh[2] = h2 < 4 || cc[2][i + 4] == '*' ? h2 - 1 : 4;\n\t\t\t\t\t\tfor (int h3 = 1; h3 <= 4; h3++) {\n\t\t\t\t\t\t\thh[3] = h3 < 4 || cc[3][i + 4] == '*' ? h3 - 1 : 4;\n\t\t\t\t\t\t\tint x = dp[h0][h1][h2][h3];\n\t\t\t\t\t\t\tif (dq[hh[0]][hh[1]][hh[2]][hh[3]] > x)\n\t\t\t\t\t\t\t\tdq[hh[0]][hh[1]][hh[2]][hh[3]] = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][][][] tmp = dp; dp = dq; dq = tmp;\n\t\t}\n\t\tSystem.out.println(dp[4][4][4][4]);\n\t}\n}\n", "index": 344, "complexity": 3}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static void solve(InputReader in, OutputWriter out) {\n        int n = in.nextInt();\n\n        List<List<Integer>> g = new ArrayList<>(n + 1);\n        for (int i = 0; i < n + 1; i++) {\n            g.add(new LinkedList<>());\n        }\n\n        int degree1 = 0, degree2 = 0, root = 0;\n        for (int i = 0; i < n - 1; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n\n            g.get(a).add(b);\n            g.get(b).add(a);\n\n            if (g.get(a).size() > degree1) {\n\n                if (a == root) {\n                    degree1 = g.get(a).size();\n                } else {\n                    degree2 = degree1;\n                    degree1 = g.get(a).size();\n                    root = a;\n                }\n\n            } else if (g.get(a).size() > degree2) {\n                degree2 = g.get(a).size();\n            }\n\n            if (g.get(b).size() > degree1) {\n\n                if (b == root) {\n                    degree1 = g.get(b).size();\n                } else {\n                    degree2 = degree1;\n                    degree1 = g.get(b).size();\n                    root = b;\n                }\n\n            } else if (g.get(b).size() > degree2) {\n                degree2 = g.get(b).size();\n            }\n        }\n\n        if (degree2 > 2) {\n            out.print(\"No\");\n        } else {\n            out.println(\"Yes\");\n\n            List<Integer> leaves = new LinkedList<>();\n            for (int i = 1; i <= n; i++) {\n                if (i != root) {\n                    if (g.get(i).size() == 1) {\n                        leaves.add(i);\n                    }\n                }\n            }\n\n            out.println(leaves.size());\n            for (int i : leaves) {\n                out.println(root + \" \" + i);\n            }\n        }\n    }\n\n    private static void shuffleArray(int[] array) {\n        int index;\n        Random random = new Random();\n        for (int i = array.length - 1; i > 0; i--) {\n            index = random.nextInt(i + 1);\n            if (index != i) {\n                array[index] ^= array[i];\n                array[i] ^= array[index];\n                array[index] ^= array[i];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        solve(in, out);\n        in.close();\n        out.close();\n    }\n\n    private static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        InputReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n            st = null;\n        }\n\n        String nextLine() {\n            String line = null;\n            try {\n                line = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return line;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = nextLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        byte nextByte() {\n            return Byte.parseByte(next());\n        }\n\n        short nextShort() {\n            return Short.parseShort(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class OutputWriter {\n        BufferedWriter bw;\n\n        OutputWriter(OutputStream os) {\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n        }\n\n        void print(int i) {\n            print(Integer.toString(i));\n        }\n\n        void println(int i) {\n            println(Integer.toString(i));\n        }\n\n        void print(long l) {\n            print(Long.toString(l));\n        }\n\n        void println(long l) {\n            println(Long.toString(l));\n        }\n\n        void print(double d) {\n            print(Double.toString(d));\n        }\n\n        void println(double d) {\n            println(Double.toString(d));\n        }\n\n        void print(boolean b) {\n            print(Boolean.toString(b));\n        }\n\n        void println(boolean b) {\n            println(Boolean.toString(b));\n        }\n\n        void print(char c) {\n            try {\n                bw.write(c);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(char c) {\n            println(Character.toString(c));\n        }\n\n        void print(String s) {\n            try {\n                bw.write(s);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(String s) {\n            print(s);\n            print('\\n');\n        }\n\n        void close() {\n            try {\n                bw.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static void solve(InputReader in, OutputWriter out) {\n        int n = in.nextInt();\n\n        List<List<Integer>> g = new ArrayList<>(n + 1);\n        for (int i = 0; i < n + 1; i++) {\n            g.add(new LinkedList<>());\n        }\n\n        int degree1 = 0, degree2 = 0, root = 0;\n        for (int i = 0; i < n - 1; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n\n            g.get(a).add(b);\n            g.get(b).add(a);\n\n            if (g.get(a).size() > degree1) {\n\n                if (a == root) {\n                    degree1 = g.get(a).size();\n                } else {\n                    degree2 = degree1;\n                    degree1 = g.get(a).size();\n                    root = a;\n                }\n\n            } else if (g.get(a).size() > degree2) {\n                degree2 = g.get(a).size();\n            }\n\n            if (g.get(b).size() > degree1) {\n\n                if (b == root) {\n                    degree1 = g.get(b).size();\n                } else {\n                    degree2 = degree1;\n                    degree1 = g.get(b).size();\n                    root = b;\n                }\n\n            } else if (g.get(b).size() > degree2) {\n                degree2 = g.get(b).size();\n            }\n        }\n\n        if (degree2 > 2) {\n            out.print(\"No\");\n        } else {\n            out.println(\"Yes\");\n\n            List<Integer> leaves = new LinkedList<>();\n            for (int i = 1; i <= n; i++) {\n                if (i != root) {\n                    if (g.get(i).size() == 1) {\n                        leaves.add(i);\n                    }\n                }\n            }\n\n            out.println(leaves.size());\n            for (int i : leaves) {\n                out.println(root + \" \" + i);\n            }\n        }\n    }\n\n    private static void shuffleArray(int[] array) {\n        int index;\n        Random random = new Random();\n        for (int i = array.length - 1; i > 0; i--) {\n            index = random.nextInt(i + 1);\n            if (index != i) {\n                array[index] ^= array[i];\n                array[i] ^= array[index];\n                array[index] ^= array[i];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        solve(in, out);\n        in.close();\n        out.close();\n    }\n\n    private static class InputReader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        InputReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n            st = null;\n        }\n\n        String nextLine() {\n            String line = null;\n            try {\n                line = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return line;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = nextLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        byte nextByte() {\n            return Byte.parseByte(next());\n        }\n\n        short nextShort() {\n            return Short.parseShort(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class OutputWriter {\n        BufferedWriter bw;\n\n        OutputWriter(OutputStream os) {\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n        }\n\n        void print(int i) {\n            print(Integer.toString(i));\n        }\n\n        void println(int i) {\n            println(Integer.toString(i));\n        }\n\n        void print(long l) {\n            print(Long.toString(l));\n        }\n\n        void println(long l) {\n            println(Long.toString(l));\n        }\n\n        void print(double d) {\n            print(Double.toString(d));\n        }\n\n        void println(double d) {\n            println(Double.toString(d));\n        }\n\n        void print(boolean b) {\n            print(Boolean.toString(b));\n        }\n\n        void println(boolean b) {\n            println(Boolean.toString(b));\n        }\n\n        void print(char c) {\n            try {\n                bw.write(c);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(char c) {\n            println(Character.toString(c));\n        }\n\n        void print(String s) {\n            try {\n                bw.write(s);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(String s) {\n            print(s);\n            print('\\n');\n        }\n\n        void close() {\n            try {\n                bw.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n", "index": 345, "complexity": 3}
{"back-translation": "class SecondSmallest {\n    static void print2Smallest(int[] arr) {\n        int first, second, arr_size = arr.length;\n\n        if (arr_size < 2) {\n            System.out.println(\" Invalid Input \");\n            return;\n        }\n\n        first = second = Integer.MAX_VALUE;\n\n        for (int i = 0; i < arr_size; i++) {\n            if (arr[i] < first) {\n                second = first;\n                first = arr[i];\n            }\n\n            else if (arr[i] < second && arr[i] != first) {\n                second = arr[i];\n            }\n        }\n\n        if (second == Integer.MAX_VALUE)\n            System.out.println(\"There is no second\" + \" smallest element\");\n        else\n            System.out.println(\"The smallest element is \" + first + \" and second Smallest\" + \" element is \" + second);\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {12, 13, 1, 10, 34, 1};\n        print2Smallest(arr);\n    }\n}", "src": "\n// Java program to find smallest and second smallest elements \nimport\njava.io.*; \n\nclass\nSecondSmallest \n{ \n\n/* Function to print first smallest and second smallest \n\nelements */\n\nstatic\nvoid\nprint2Smallest(\nint\narr[]) \n\n{ \n\nint\nfirst, second, arr_size = arr.length; \n\n\n/* There should be atleast two elements */\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MAX_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < arr_size ; i ++) \n\n{ \n\n/* If current element is smaller than first \n\nthen update both first and second */\n\nif\n(arr[i] < first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n/* If arr[i] is in between first and second \n\nthen update second */\n\nelse\nif\n(arr[i] < second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nif\n(second == Integer.MAX_VALUE) \n\nSystem.out.println(\n\"There is no second\"\n+ \n\n\"smallest element\"\n); \n\nelse\n\nSystem.out.println(\n\"The smallest element is \"\n+ \n\nfirst + \n\" and second Smallest\"\n+ \n\n\" element is \"\n+ second); \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nprint2Smallest(arr); \n\n} \n} \n/*This code is contributed by Devesh Agrawal*/", "index": 348, "complexity": 3}
{"back-translation": "ERROR", "src": "//package contese_476;\nimport java.util.*;\npublic class q1 \n{\n\tint m=(int)1e9+7;\npublic class Node\n{\n\tint a;\n\tint b;\n\tpublic void Node(int a,int b)\n\t{\n\t\tthis.a=a;\n\t\tthis.b=b;\n\t}\n}\npublic int mul(int a ,int b)\n{\na=a%m;\nb=b%m;\nreturn((a*b)%m);\n}\npublic int pow(int a,int b)\n{\n\tint x=1;\n\twhile(b>0)\n\t{\n\t\tif(b%2!=0)\n\t\t\tx=mul(x,a);\n\t\ta=mul(a,a);\n\t\tb=b/2;\n\t}\n\treturn x;\n}\npublic static long gcd(long a,long b)\n{\n\tif(b==0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b,a%b);\n}\npublic static void main(String[] args)\n{\n\tScanner sc=new Scanner(System.in);\n\tint n=sc.nextInt();\n\tHashMap<Integer,Integer> h=new HashMap();\n\t//HashMap<Integer,Integer> h1=new HashMap();\n\tint[] a=new int[n];\n\tint x=sc.nextInt();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta[i]=sc.nextInt();\n\t\tif(h.get(a[i])==null)\n\t\t{\n\t\t\th.put(a[i], 1);\n\t\t\t//h1.put(a[i],i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.print(0);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint num=a[i]&x;\n\t\tif(num==a[i])\n\t\t\tcontinue;\n\t\tif(h.get(num)==null)\n\t\t\tcontinue;\n\t\t\n\t\telse\n\t\t{\n\t\t\t\n\t\t\tSystem.out.print(1);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint num=a[i]&x;\n\t\tif(num==a[i])\n\t\t\tcontinue;\n\t\tif(h.get(num)==null)\n\t\t\th.put(num, 1);\n\t\telse\n\t\t{\n\t\t\tSystem.out.print(2);\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\tSystem.out.print(-1);\n\t\n     \n}\n\n}", "index": 349, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SFly {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader lector = new BufferedReader(new InputStreamReader(System.in));\n\t\tint planet = Integer.parseInt(lector.readLine());\n\t\tint ini = Integer.parseInt(lector.readLine());\n\t\tdouble peso = ini;\n\t\tint[] desp = new int[planet];\n\t\tint[] ater = new int[planet];\n\t\tString[] temp = lector.readLine().split(\" \");\n\t\t\n\t\tfor (int i = 0; i < planet; i++) {\n\t\t\tdesp[i] = Integer.parseInt(temp[i]);\n\t\t\tif (desp[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = lector.readLine().split(\" \");\n\t\t\n\t\tfor (int i = 0; i < planet; i++) {\n\t\t\tater[i] = Integer.parseInt(temp[i]);\n\t\t\tif (ater[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = null;\n\t\tint i = planet - 1;\n\t\tpeso = (peso * ater[0]) / (ater[0] - 1);\n\t\twhile (i > 0) {\n\t\t\tpeso = (peso * desp[i]) / (desp[i] - 1);\n\t\t\tpeso = (peso * ater[i]) / (ater[i] - 1);\n\t\t\ti--;\n\t\t}\n\t\tpeso = (peso * desp[0]) / (desp[0] - 1);\n\t\tpeso = peso - ini;\n\t\tSystem.out.println(peso);\n\t\tlector.close();\n\t}\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SFly {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader lector = new BufferedReader(new InputStreamReader(System.in));\n\t\tint planet = Integer.parseInt(lector.readLine());\n\t\tint ini = Integer.parseInt(lector.readLine());\n\t\tdouble peso = ini;\n\t\tint[] desp = new int[planet];\n\t\tint[] ater = new int[planet];\n\t\tString[] temp = lector.readLine().split(\" \");\t\t\n\t\tfor(int i=0; i<planet; i++) {\n\t\t\tdesp[i] = Integer.parseInt(temp[i]);\n\t\t\tif(desp[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = lector.readLine().split(\" \");\t\t\n\t\tfor(int i=0; i<planet; i++) {\n\t\t\tater[i] = Integer.parseInt(temp[i]);\n\t\t\tif(ater[i] == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tlector.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttemp = null;\n\t\tint i=planet-1;\n\t\tpeso = (peso*ater[0])/(ater[0]-1);\n\t\twhile(i>0) {\n\t\t\tpeso = (peso*desp[i])/(desp[i]-1);\n\t\t\tpeso = (peso*ater[i])/(ater[i]-1);\n\t\t\ti--;\n\t\t}\n\t\tpeso = (peso*desp[0])/(desp[0]-1);\n\t\tpeso = peso - ini;\n\t\tSystem.out.println(peso);\n\t\tlector.close();\n\t}\n}", "index": 350, "complexity": 3}
{"back-translation": "class GFG { public static int findLength(String str, int n) { int current_sum = 0; int max_sum = 0; for (int i = 0; i < n; i++) { current_sum += (str.charAt(i) == '0' ? 1 : -1); if (current_sum < 0) current_sum = 0; max_sum = Math.max(current_sum, max_sum); } return max_sum == 0 ? -1 : max_sum; } public static void main(String[] args) { String str = \"11000010001\"; int n = str.length(); System.out.println(findLength(str, n)); } }", "src": "\n// Java Program to find the length of \n// substring with maximum difference of \n// zeroes and ones in binary string. \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Find the length of substring with maximum \n\n// difference of zeros and ones in binary \n\n// string \n\npublic\nstatic\nint\nfindLength(String str, \nint\nn) \n\n{ \n\n\nint\ncurrent_sum = \n0\n; \n\nint\nmax_sum = \n0\n; \n\n\n// traverse a binary string from left to right \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// add current value to the current_sum \n\n// according to the Character \n\n// if it's '0' add 1 else -1 \n\ncurrent_sum += (str.charAt(i) == \n'0'\n? \n1\n: -\n1\n); \n\n\nif\n(current_sum < \n0\n) \n\ncurrent_sum = \n0\n; \n\n\n// update maxium sum \n\nmax_sum = Math.max(current_sum, max_sum); \n\n} \n\n// return -1 if string does not contain any zero \n\n// that means string contains all ones otherwise max_sum \n\nreturn\nmax_sum == \n0\n? -\n1\n: max_sum; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"11000010001\"\n; \n\nint\nn = str.length(); \n\n\nSystem.out.println(findLength(str, n)); \n\n} \n} ", "index": 352, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.util.*;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc= new Scanner(System.in);\n\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\tint loca[]=new int[n+m];\n\t\tint res[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++)\n\t\t\tloca[i]=sc.nextInt();\n\t\t\n\t\tint y=0;\n\t\tint driver[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++){\n\t\t\tint x=sc.nextInt();\n\t\t\tif(x==1)\n\t\t\t\tdriver[y++]=i;\n\t\t}\n\t\t\n\t\tint i=0,j=0,p=0,q=0;\n\t\tfor(i=0;i<m+n;i++) {\n\t\t\tif(i==driver[0])\n\t\t\t\t{i++;break;}\n\t\t\tif(loca[i]<loca[driver[0]])\n\t\t\t\tres[0]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t//j=1;\n\t\t\n\t\tfor(;i<n+m;i++){\n\t\t\t\n\t\t\tint coor=loca[i];\n\t\t\t\n\t\t\t/*if(coor>q&&j!=0)\n\t\t\t\tj++;*/\n\t\t\t\n\t\t\tif(j==m-1)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tp=driver[j];q=driver[j+1];\t\t\n\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint d1=coor-loca[p],d2=loca[q]-coor;\n\t\t\t\n\t\t\tif(d2==0)\n\t\t\t\t{j++;continue;}\n\t\t\tif(d1<=d2)\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tres[j+1]++;\n\t\t\t\n\t\t\t//add check for j+1<m\n\t\t\t//handle cases for j==0 && j==m-1\n\t\t}\n\t\t\n\t\tfor(;i<m+n;i++) {\n\t\t\t\n\t\t\tif(i==driver[j])\n\t\t\t{i++;break;}\n\t\t\t\n\t\t\tif(loca[i]>loca[driver[j]])\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(i=0;i<m;i++)\n\t\t\tSystem.out.print(res[i]+\" \");\n\t}\n}", "index": 353, "complexity": 3}
{"back-translation": "class KeyComparator implements Comparator<Key> { public int compare(Key k1, Key k2) { if (k1.freq < k2.freq) return 1; else if (k1.freq > k2.freq) return -1; return 0; } } class Key { int freq; char ch; Key(int val, char c) { freq = val; ch = c; } } class GFG { static int MAX_CHAR = 26; static void rearrangeString(String str) { int n = str.length(); int[] count = new int[MAX_CHAR]; for (int i = 0; i < n; i++) count[str.charAt(i) - 'a']++; PriorityQueue<Key> pq = new PriorityQueue<>(new KeyComparator()); for (char c = 'a'; c <= 'z'; c++) { int val = c - 'a'; if (count[val] > 0) pq.add(new Key(count[val], c)); } str = \"\"; Key prev = new Key(-1, '#'); while (pq.size() != 0) { Key k = pq.peek(); pq.poll(); str = str + k.ch; if (prev.freq > 0) pq.add(prev); (k.freq)--; prev = k; } if (n != str.length()) System.out.println(\" Not valid String \"); else System.out.println(str); } public static void main(String args[]) { String str = \"bbbaa\"; rearrangeString(str); } }", "src": "\n// Java program to rearrange characters in a string \n// so that no two adjacent characters are same. \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nKeyComparator \nimplements\nComparator<Key> { \n\n\n// Overriding compare()method of Comparator \n\npublic\nint\ncompare(Key k1, Key k2) \n\n{ \n\nif\n(k1.freq < k2.freq) \n\nreturn\n1\n; \n\nelse\nif\n(k1.freq > k2.freq) \n\nreturn\n-\n1\n; \n\nreturn\n0\n; \n\n} \n} \n\nclass\nKey { \n\nint\nfreq; \n// store frequency of character \n\nchar\nch; \n\nKey(\nint\nval, \nchar\nc) \n\n{ \n\nfreq = val; \n\nch = c; \n\n} \n} \n\nclass\nGFG { \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n// Function to rearrange character of a string \n\n// so that no char repeat twice \n\nstatic\nvoid\nrearrangeString(String str) \n\n{ \n\nint\nn = str.length(); \n\n\n// Store frequencies of all characters in string \n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[str.charAt(i) - \n'a'\n]++; \n\n\n// Insert all characters with their frequencies \n\n// into a priority_queue \n\nPriorityQueue<Key> pq = \nnew\nPriorityQueue<>(\nnew\n\nKeyComparator()); \n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\nval = c - \n'a'\n; \n\nif\n(count[val] > \n0\n) \n\npq.add(\nnew\nKey(count[val], c)); \n\n} \n\n\n// 'str' that will store resultant value \n\nstr = \n\"\"\n; \n\n\n// work as the previous visited element \n\n// initial previous element be. ( '#' and \n\n// it's frequency '-1' ) \n\nKey prev = \nnew\nKey(-\n1\n, \n'#'\n); \n\n\n// traverse queue \n\nwhile\n(pq.size() != \n0\n) { \n\n\n// pop top element from queue and add it \n\n// to string. \n\nKey k = pq.peek(); \n\npq.poll(); \n\nstr = str + k.ch; \n\n\n// If frequency of previous character is less \n\n// than zero that means it is useless, we \n\n// need not to push it \n\nif\n(prev.freq > \n0\n) \n\npq.add(prev); \n\n\n// make current character as the previous 'char' \n\n// decrease frequency by 'one' \n\n(k.freq)--; \n\nprev = k; \n\n} \n\n\n// If length of the resultant string and original \n\n// string is not same then string is not valid \n\nif\n(n != str.length()) \n\nSystem.out.println(\n\" Not valid String \"\n); \n\nelse\n\nSystem.out.println(str); \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"bbbaa\"\n; \n\nrearrangeString(str); \n\n} \n} \n\n// This code is contributed by rachana soma ", "index": 354, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class CF1197B {\n    public static void main(String[] args) {\n        FastReader input = new FastReader();\n        int n = input.nextInt();\n        int[] arr = new int[n];\n        int max = 0;\n        int maxIndex = 0;\n        for (int i = 0; i < n; i++) {\n            arr[i] = input.nextInt();\n            if (arr[i] > max) {\n                max = arr[i];\n                maxIndex = i;\n            }\n        }\n        int j = maxIndex - 1;\n        int k = maxIndex + 1;\n        while (j >= 0 && k < n) {\n            if (arr[j] > arr[k]) {\n                if (arr[j] < max) {\n                    max = arr[j];\n                    j--;\n                } else {\n                    System.out.println(\"NO\");\n                    return;\n                }\n            } else {\n                if (arr[k] < max) {\n                    max = arr[k];\n                    k++;\n                } else {\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        if (j >= 0) {\n            while (j >= 0) {\n                if (arr[j] < max) {\n                    max = arr[j];\n                    j--;\n                } else {\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        if (k < n) {\n            while (k < n) {\n                if (arr[k] < max) {\n                    max = arr[k];\n                    k++;\n                } else {\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        if (j == -1 && k == n) {\n            System.out.println(\"YES\");\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class CF1197B {\n    public static void main(String[] args) {\n        FastReader input = new FastReader();\n        int n = input.nextInt();\n        int[] arr = new int[n];\n        int max = 0;\n        int maxIndex = 0;\n        for(int i = 0;i < n;i++){\n            arr[i] = input.nextInt();\n            if(arr[i] > max){\n                max = arr[i];\n                maxIndex = i;\n            }\n        }\n        int j = maxIndex - 1;\n        int k = maxIndex + 1;\n        while (j >= 0 && k < n){\n            if(arr[j] > arr[k]){\n                if(arr[j] < max){\n                    max = arr[j];\n                    j--;\n                }\n                else {\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n            else{\n                if(arr[k] < max){\n                    max = arr[k];\n                    k++;\n                }\n                else{\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        if(j >= 0){\n            while (j >= 0){\n                if(arr[j] < max){\n                    max = arr[j];\n                    j--;\n                }\n                else{\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        if(k < n){\n            while (k < n){\n                if(arr[k] < max){\n                    max = arr[k];\n                    k++;\n                }\n                else{\n                    System.out.println(\"NO\");\n                    return;\n                }\n            }\n        }\n        if(j == -1 && k == n){\n            System.out.println(\"YES\");\n        }\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "index": 355, "complexity": 3}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            Debug debug = new Debug();\n            int n = in.nextInt();\n            int K = in.nextInt();\n\n            List<Integer>[] g = GraphUtils.nextU(in, n, n - 1, true);\n            int[] center = GraphUtils.getCenter(g);\n            if (center.length == 2) {\n                out.println(\"No\");\n                return;\n            }\n\n            int[][] pars = GraphUtils.parents3(g, center[0]);\n            int[] par = pars[0], ord = pars[1], depth = pars[2];\n            int[] deg = new int[n];\n            for (int i = 0; i < n; ++i) deg[i] = g[i].size();\n\n            if (deg[center[0]] < 3) {\n                out.println(\"No\");\n                return;\n            }\n\n            for (int i = 0; i < n; ++i) {\n                if (deg[i] == 1) {\n                    if (depth[i] != K) {\n                        out.println(\"No\");\n                        return;\n                    }\n                } else if (i != center[0]) {\n                    if (deg[i] < 4) {\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            }\n            out.println(\"Yes\");\n        }\n    }\n\n    static class GraphUtils {\n        public static List<Integer>[] nextU(FastReader in, int n, int m, boolean oneIndexed) {\n            int diff = oneIndexed ? 1 : 0;\n            List<Integer>[] g = new List[n];\n            for (int i = 0; i < n; ++i) g[i] = new ArrayList<>();\n            for (int i = 0; i < m; ++i) {\n                int u = in.nextInt() - diff;\n                int v = in.nextInt() - diff;\n                g[u].add(v);\n                g[v].add(u);\n            }\n            return g;\n        }\n\n        public static int[][] parents3(List<Integer>[] g, int root) {\n            int n = g.length;\n            int[] par = new int[n];\n            fill(par, -1);\n\n            int[] depth = new int[n];\n            depth[0] = 0;\n\n            int[] q = new int[n];\n            q[0] = root;\n            for (int p = 0, r = 1; p < r; p++) {\n                int cur = q[p];\n                for (int nex : g[cur]) {\n                    if (par[cur] != nex) {\n                        q[r++] = nex;\n                        par[nex] = cur;\n                        depth[nex] = depth[cur] + 1;\n                    }\n                }\n            }\n            return new int[][]{par, q, depth};\n        }\n\n        public static int[] getCenter(List<Integer>[] g) {\n            int n = g.length;\n            int[] q = new int[n];\n            int[] deg = new int[n];\n            int p = 0;\n            for (int i = 0; i < n; i++) {\n                deg[i] = g[i].size();\n                if (g[i].size() <= 1) {\n                    q[p++] = i;\n                }\n            }\n            int bound = p == n ? 0 : p;\n            for (int z = 0; z < p; z++) {\n                if (bound == z && p < n) bound = p;\n                int cur = q[z];\n                deg[cur]--;\n                for (int e : g[cur]) {\n                    if (--deg[e] == 1) q[p++] = e;\n                }\n            }\n            assert p == n;\n            assert bound >= n - 2 && bound < n;\n            if (bound == n - 2) {\n                return new int[]{q[n - 2], q[n - 1]};\n            } else {\n                return new int[]{q[n - 1]};\n            }\n        }\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c)) c = pread();\n            int sgn = 1;\n            if (c == \\'-\\') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == \\'\\,\\') c = pread();\n                if (c < \\'0\\' || c > \\'9\\') throw new InputMismatchException();\n                res *= 10;\n                res += c - \\'0\\';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == \\' \\' || c == \\'\\n\\' || c == \\'\\r\\' || c == \\'\\t\\' || c == -1;\n        }\n    }\n\n    static class Debug {\n        PrintWriter out;\n        boolean oj;\n        boolean system;\n        long timeBegin;\n        Runtime runtime;\n\n        public Debug(PrintWriter out) {\n            oj = System.getProperty(\\\"ONLINE_JUDGE\\\") != null;\n            this.out = out;\n            this.timeBegin = System.currentTimeMillis();\n            this.runtime = Runtime.getRuntime();\n        }\n\n        public Debug() {\n            system = true;\n            oj = System.getProperty(\\\"ONLINE_JUDGE\\\") != null;\n            OutputStream outputStream = System.out;\n            this.out = new PrintWriter(outputStream);\n            this.timeBegin = System.currentTimeMillis();\n            this.runtime = Runtime.getRuntime();\n        }\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            Debug debug = new Debug();\n            int n = in.nextInt();\n            int K = in.nextInt();\n\n            List<Integer>[] g = GraphUtils.nextU(in, n, n - 1, true);\n            int[] center = GraphUtils.getCenter(g);\n            if (center.length == 2) {\n                out.println(\"No\");\n                return;\n            }\n\n            int[][] pars = GraphUtils.parents3(g, center[0]);\n            int[] par = pars[0], ord = pars[1], depth = pars[2];\n            int[] deg = new int[n];\n            for (int i = 0; i < n; ++i) deg[i] = g[i].size();\n\n            if (deg[center[0]] < 3) {\n                out.println(\"No\");\n                return;\n            }\n\n            // all leaves depth = K\n            for (int i = 0; i < n; ++i) {\n                if (deg[i] == 1) {\n                    if (depth[i] != K) {\n                        out.println(\"No\");\n                        return;\n                    }\n                } else if (i != center[0]) {\n                    if (deg[i] < 4) {\n                        out.println(\"No\");\n                        return;\n                    }\n                }\n            }\n            out.println(\"Yes\");\n        }\n\n    }\n\n    static class GraphUtils {\n        public static List<Integer>[] nextU(FastReader in, int n, int m, boolean oneIndexed) {\n            int diff = oneIndexed ? 1 : 0;\n            List<Integer>[] g = new List[n];\n            for (int i = 0; i < n; ++i) g[i] = new ArrayList<>();\n            for (int i = 0; i < m; ++i) {\n                int u = in.nextInt() - diff;\n                int v = in.nextInt() - diff;\n                g[u].add(v);\n                g[v].add(u);\n            }\n            return g;\n        }\n\n        public static int[][] parents3(List<Integer>[] g, int root) {\n            int n = g.length;\n            int[] par = new int[n];\n            ArrayUtils.fill(par, -1);\n\n            int[] depth = new int[n];\n            depth[0] = 0;\n\n            int[] q = new int[n];\n            q[0] = root;\n            for (int p = 0, r = 1; p < r; p++) {\n                int cur = q[p];\n                for (int nex : g[cur]) {\n                    if (par[cur] != nex) {\n                        q[r++] = nex;\n                        par[nex] = cur;\n                        depth[nex] = depth[cur] + 1;\n                    }\n                }\n            }\n            return new int[][]{par, q, depth};\n        }\n\n        public static int[] getCenter(List<Integer>[] g) {\n            int n = g.length;\n            int[] q = new int[n];\n            int[] deg = new int[n];\n            int p = 0;\n            for (int i = 0; i < n; i++) {\n                deg[i] = g[i].size();\n                if (g[i].size() <= 1) { // < for n=1\n                    q[p++] = i;\n                }\n            }\n            int bound = p == n ? 0 : p;\n            for (int z = 0; z < p; z++) {\n                if (bound == z && p < n) bound = p;\n                int cur = q[z];\n                deg[cur]--;\n                for (int e : g[cur]) {\n                    if (--deg[e] == 1) q[p++] = e;\n                }\n            }\n            assert p == n;\n            assert bound >= n - 2 && bound < n;\n            if (bound == n - 2) {\n                return new int[]{q[n - 2], q[n - 1]};\n            } else {\n                return new int[]{q[n - 1]};\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void fill(int[] array, int value) {\n            Arrays.fill(array, value);\n        }\n\n    }\n\n    static class Debug {\n        PrintWriter out;\n        boolean oj;\n        boolean system;\n        long timeBegin;\n        Runtime runtime;\n\n        public Debug(PrintWriter out) {\n            oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n            this.out = out;\n            this.timeBegin = System.currentTimeMillis();\n            this.runtime = Runtime.getRuntime();\n        }\n\n        public Debug() {\n            system = true;\n            oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n            OutputStream outputStream = System.out;\n            this.out = new PrintWriter(outputStream);\n            this.timeBegin = System.currentTimeMillis();\n            this.runtime = Runtime.getRuntime();\n        }\n\n    }\n}\n\n", "index": 356, "complexity": 3}
{"back-translation": "import java.util.*;\npublic class Main{\n    public static void main(String args[]){\n     Scanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a[]=new int[n];\n    for(int i=0;i<n;i++){\n    a[i]=sc.nextInt();\n    }\n    Arrays.sort(a);\n    int t=1,c=0;\n    for(int i=1;i<n;i++){\n        if(a[i]==a[i-1]){\n            if(i-2>=0&&a[i-2]==a[i-1]-1){\n                System.out.println(\"cslnb\");\n                return;\n            }\n            c++;\n        }\n        if(a[i]==a[i-1]&&a[i]==0){\n        System.out.println(\"cslnb\");\n        return;\n        }\n    }\n    if(c>1){\n        System.out.println(\"cslnb\");\n        return;\n    }\n    for(int i=0;i<n;i++){\n        if((a[i]-i)%2!=0){\n        t=t^1;\n        }\n    }\n    if(t==1){\n    System.out.println(\"cslnb\");\n    }\n    else{\n    System.out.println(\"sjfnb\");\n    }\n    }\n    \n}", "src": "import java.util.*;\npublic class Main{\n    public static void main(String args[]){\n     Scanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a[]=new int[n];\n    for(int i=0;i<n;i++)\n    a[i]=sc.nextInt();\n    Arrays.sort(a);\n    //boolean \n    int t=1,c=0;\n    for(int i=1;i<n;i++){\n        if(a[i]==a[i-1])\n        {\n            if(i-2>=0&&a[i-2]==a[i-1]-1){\n                System.out.println(\"cslnb\");\n                return;\n            }\n            c++;\n        }\n        if(a[i]==a[i-1]&&a[i]==0){\n        System.out.println(\"cslnb\");\n        return;\n        }\n    }\n    if(c>1)\n    {\n        System.out.println(\"cslnb\");\n        return;\n    }\n    for(int i=0;i<n;i++){\n        if((a[i]-i)%2!=0)\n        t=t^1;\n    }\n    if(t==1)\n    System.out.println(\"cslnb\");\n    else\n    System.out.println(\"sjfnb\");\n    \n    \n    \n    }\n    \n}", "index": 357, "complexity": 3}
{"back-translation": "public class Main { public static void rearrange(int arr[], int n) { int max_ele = arr[n - 1]; int min_ele = arr[0]; for (int i = 0; i < n; i++) { if (i % 2 == 0) { arr[i] = max_ele; max_ele -= 1; } else { arr[i] = min_ele; min_ele += 1; } } } public static void main(String args[]) { int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int n = arr.length; System.out.println(\"Original Array\"); for (int i = 0; i < n; i++) System.out.print(arr[i] + \" \"); rearrange(arr, n); System.out.print(\"\\nModified Array\\n\"); for (int i = 0; i < n; i++) System.out.print(arr[i] + \" \"); } }", "src": "\n// Java program to rearrange an \n// array in minimum maximum form \n\npublic\nclass\nMain { \n\n\n// Prints max at first position, min at second \n\n// position second max at third position, second \n\n// min at fourth position and so on. \n\npublic\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n// initialize index of first minimum and first \n\n// maximum element \n\nint\nmax_ele = arr[n - \n1\n]; \n\nint\nmin_ele = arr[\n0\n]; \n\n// traverse array elements \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n// at even index : we have to put maximum element \n\nif\n(i % \n2\n== \n0\n) { \n\narr[i] = max_ele; \n\nmax_ele -= \n1\n; \n\n} \n\n\n// at odd index : we have to put minimum element \n\nelse\n{ \n\narr[i] = min_ele; \n\nmin_ele += \n1\n; \n\n} \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Original Array\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"\\nModified Array\\n\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} ", "index": 361, "complexity": 3}
{"back-translation": "import java.util.Scanner;\npublic class P1075A\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong n, x, y;\n\t\tn = scan.nextLong();\n\t\tx = scan.nextLong();\n\t\ty = scan.nextLong();\n\t\tboolean flag = true, flag1 = false, flag2 = false;\n\t\tlong w1, w2, b1, b2;\n\t\tlong W = 0L, B = 0L;\n\t\tw1 = w2 = 1;\n\t\tb1 = b2 = n;\n\t\twhile (w1 < n)\n\t\t{\n\t\t\tif (w1 == x)\n\t\t\t{\n\t\t\t\tflag1 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (w2 == y)\n\t\t\t\tbreak;\n\t\t\t++w1;\n\t\t\t++w2;\n\t\t\t++W;\n\t\t}\n\t\tif (flag1)\n\t\t\tW += (y - w2);\n\t\telse\n\t\t\tW += (x - w1);\n\t\twhile (b1 > 1)\n\t\t{\n\t\t\tif (b1 == x)\n\t\t\t{\n\t\t\t\tflag2 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (b2 == y)\n\t\t\t\tbreak;\n\t\t\t--b1;\n\t\t\t--b2;\n\t\t\t++B;\n\t\t}\n\t\tif (flag2)\n\t\t\tB += (b2 - y);\n\t\telse\n\t\t\tB += (b1 - x);\n\t\tif (B < W)\n\t\t\tSystem.out.println(\"Black\");\n\t\telse\n\t\t\tSystem.out.println(\"White\");\n\t}\n}", "src": "import java.util.Scanner;\npublic class P1075A\n{\n\tpublic static void main(String[] args)\n\t{\n\t Scanner scan=new Scanner(System.in);\n\t long n,x,y;\n\t n=scan.nextLong();\n\t x=scan.nextLong();\n\t y=scan.nextLong();\n\t boolean flag=true,flag1=false,flag2=false;\n\t long w1,w2,b1,b2;\n\t long W=0l,B=0l;\n\t w1=w2=1;\t\tb1=b2=n;\n\t while(w1<n)\n\t\t{\n\t\t if(w1==x)\n\t\t\t{flag1=true;\tbreak;}\n\t\t if(w2==y)\n\t\t\tbreak;\n\t\t ++w1;\t++w2;\t++W;\n\t\t}\n\t if(flag1)\n\t\tW+=(y-w2);\n\t else\n\t\tW+=(x-w1);\n\t while(b1>1)\n\t\t{\n\t\t if(b1==x)\n\t\t\t{flag2=true;\tbreak;}\n\t\t if(b2==y)\n\t\t\tbreak;\n\t\t --b1;\t--b2;\t++B;\n\t\t}\n\t if(flag2)\n\t\tB+=(b2-y);\n\t else\n\t\tB+=(b1-x);\n\t if(B<W)\n\t\tSystem.out.println(\"Black\");\n\t else\n\t\tSystem.out.println(\"White\");\n\t}\n}", "index": 362, "complexity": 3}
{"back-translation": "class Main { static Reader scan; static PrintWriter pw; static int n, k, left[], right[], arr[]; static long MOD = 1000000007, count[], dp[]; public static void main(String[] args) { new Thread(null, null, \"BaZ\", 1 << 25) { public void run() { try { solve(); } catch (Exception e) { e.printStackTrace(); System.exit(1); } } }.start(); } static void solve() { scan = new Reader(); pw = new PrintWriter(System.out, true); StringBuilder sb = new StringBuilder(); n = ni(); k = ni(); int stack[] = new int[1000001]; int top = -1; arr = new int[n]; left = new int[n]; right = new int[n]; for (int i = 0; i < n; ++i) { arr[i] = ni(); while (top >= 0 && arr[stack[top]] <= arr[i]) top--; if (top == -1) left[i] = 0; else left[i] = stack[top] + 1; stack[++top] = i; } top = -1; for (int i = n - 1; i >= 0; --i) { while (top >= 0 && arr[stack[top]] < arr[i]) top--; if (top == -1) right[i] = n - 1; else right[i] = stack[top] - 1; stack[++top] = i; } dp = new long[n + 1]; for (int i = 0; i <= n; ++i) { if (i < k) continue; dp[i] = dp[i - k + 1] + (i - k + 1); } count = new long[n]; long ans = 0; for (int i = 0; i < n; ++i) { int len = right[i] - left[i] + 1; int lef = i - left[i]; int rig = right[i] - i; long count = dp[len] - dp[lef] - dp[rig]; if (count >= MOD) count %= MOD; ans += count * arr[i]; if (ans >= MOD) ans %= MOD; } pl(ans); pw.flush(); pw.close(); } static int ni() { return scan.nextInt(); } static long nl() { return scan.nextLong(); } static double nd() { return scan.nextDouble(); } static void pl() { pw.println(); } static void p(Object o) { pw.print(o + \" \"); } static void pl(Object o) { pw.println(o); } static void psb(StringBuilder sb) { pw.print(sb); } static void pa(String arrayName, Object arr[]) { pl(arrayName + \" : \"); for (Object o : arr) p(o); pl(); } static void pa(String arrayName, int arr[]) { pl(arrayName + \" : \"); for (int o : arr) p(o); pl(); } static void pa(String arrayName, long arr[]) { pl(arrayName + \" : \"); for (long o : arr) p(o); pl(); } static void pa(String arrayName, double arr[]) { pl(arrayName + \" : \"); for (double o : arr) p(o); pl(); } static void pa(String arrayName, char arr[]) { pl(arrayName + \" : \"); for (char o : arr) p(o); pl(); } static void pa(String listName, List list) { pl(listName + \" : \"); for (Object o : list) p(o); pl(); } static void pa(String arrayName, Object[][] arr) { pl(arrayName + \" : \"); for (int i = 0; i < arr.length; ++i) { for (Object o : arr[i]) p(o); pl(); } } static void pa(String arrayName, int[][] arr) { pl(arrayName + \" : \"); for (int i = 0; i < arr.length; ++i) { for (int o : arr[i]) p(o); pl(); } } static void pa(String arrayName, long[][] arr) { pl(arrayName + \" : \"); for (int i = 0; i < arr.length; ++i) { for (long o : arr[i]) p(o); pl(); } } static void pa(String arrayName, char[][] arr) { pl(arrayName + \" : \"); for (int i = 0; i < arr.length; ++i) { for (char o : arr[i]) p(o); pl(); } } static void pa(String arrayName, double[][] arr) { pl(arrayName + \" : \"); for (int i = 0; i < arr.length; ++i) { for (double o : arr[i]) p(o); pl(); } } static class Reader { final private int BUFFER_SIZE = 1 << 16; private DataInputStream din; private byte[] buffer; private int bufferPointer, bytesRead; public Reader() { din = new DataInputStream(System.in); buffer = new byte[BUFFER_SIZE]; bufferPointer = bytesRead = 0; } public Reader(String file_name) throws IOException { din = new DataInputStream(new FileInputStream(file_name)); buffer = new byte[BUFFER_SIZE]; bufferPointer = bytesRead = 0; } public String readLine() throws IOException { byte[] buf = new byte[64]; int cnt = 0, c; while ((c = read()) != -1) { if (c == '\\n') break; buf[cnt++] = (byte) c; } return new String(buf, 0, cnt); } public int nextInt() throws IOException { int ret = 0; byte c = read(); while (c <= ' ') c = read(); boolean neg = (c == '-'); if (neg) c = read(); do { ret = ret * 10 + c - '0'; } while ((c = read()) >= '0' && c <= '9'); if (neg) return -ret; return ret; } public long nextLong() throws IOException { long ret = 0; byte c = read(); while (c <= ' ') c = read(); boolean neg = (c == '-'); if (neg) c = read(); do { ret = ret * 10 + c - '0'; } while ((c = read()) >= '0' && c <= '9'); if (neg) return -ret; return ret; } public double nextDouble() throws IOException { double ret = 0, div = 1; byte c = read(); while (c <= ' ') c = read(); boolean neg = (c == '-'); if (neg) c = read(); do { ret = ret * 10 + c - '0'; } while ((c = read()) >= '0' && c <= '9'); if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10); if (neg) return -ret; return ret; } private void fillBuffer() throws IOException { bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); if (bytesRead == -1) buffer[0] = -1; } private byte read() throws IOException { if (bufferPointer == bytesRead) fillBuffer(); return buffer[bufferPointer++]; } public void close() throws IOException { if (din == null) return; din.close(); } } }", "src": "/**\n * BaZ :D\n */\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\npublic class Main\n{\n    static Reader scan;\n    static PrintWriter pw;\n    static int n,k,left[],right[],arr[];\n    static long MOD = 1000000007,count[],dp[];\n    public static void main(String[] args) {\n        new Thread(null,null,\"BaZ\",1<<25)\n        {\n            public void run()\n            {\n                try\n                {\n                    solve();\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n    static void solve() throws IOException\n    {\n        scan = new Reader();\n        pw = new PrintWriter(System.out,true);\n        StringBuilder sb = new StringBuilder();\n        n = ni();\n        k = ni();\n        int stack[] = new int[1000001];\n        int top = -1;\n        arr = new int[n];\n        left = new int[n];\n        right = new int[n];\n        for(int i=0;i<n;++i) {\n            arr[i] = ni();\n            while(top>=0 && arr[stack[top]]<=arr[i])\n                top--;\n            if(top==-1)\n                left[i] = 0;\n            else left[i] = stack[top]+1;\n            stack[++top] = i;\n        }\n        top = -1;\n        for(int i=n-1;i>=0;--i) {\n            while(top>=0 && arr[stack[top]]<arr[i])\n                top--;\n            if(top==-1)\n                right[i] = n-1;\n            else right[i] = stack[top]-1;\n            stack[++top] = i;\n        }\n        //pa(\"left\", left);\n        //pa(\"right\", right);\n        dp = new long[n+1];\n        for(int i=0;i<=n;++i) {\n            if(i<k)\n              continue;\n            dp[i] = dp[i-k+1] + (i-k+1);\n        }\n        count = new long[n];\n        long ans = 0;\n        for(int i=0;i<n;++i) {\n            int len = right[i]-left[i]+1;\n            int lef = i-left[i];\n            int rig = right[i]-i;\n            long count = dp[len] - dp[lef] - dp[rig];\n            if(count>=MOD)\n              count%=MOD;\n            ans += count*arr[i];\n            if(ans>=MOD)\n                ans%=MOD;\n        }\n        pl(ans);\n        pw.flush();\n        pw.close();\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n}", "index": 363, "complexity": 3}
{"back-translation": "class Grid {\n    static int count(int n) {\n        int[] dp = new int[n+1];\n        dp[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i >= 1 && i <= 3)\n                dp[i] = 1;\n            else if (i == 4)\n                dp[i] = 2;\n            else\n                dp[i] = dp[i-1] + dp[i-4];\n        }\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        System.out.println(\"Count of ways is: \" + count(n));\n    }\n}", "src": "\n// Java program to count of ways to place 1 x 4 tiles \n// on n x 4 grid \nimport\njava.io.*; \n\nclass\nGrid \n{ \n\n// Function that count the number of ways to place 1 x 4 tiles \n\n// on n x 4 grid. \n\nstatic\nint\ncount(\nint\nn) \n\n{ \n\n// Create a table to store results of sub-problems \n\n// dp[i] stores count of ways for i x 4 grid. \n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\ndp[\n0\n] = \n0\n; \n\n// Fill the table from d[1] to dp[n] \n\nfor\n(\nint\ni=\n1\n;i<=n;i++) \n\n{ \n\n// Base cases \n\nif\n(i >= \n1\n&& i <= \n3\n) \n\ndp[i] = \n1\n; \n\nelse\nif\n(i==\n4\n) \n\ndp[i] = \n2\n; \n\n\nelse\n\n{ \n\n// dp(i-1) : Place first tile horizontally \n\n// dp(i-4) : Place first tile vertically \n\n// which means 3 more tiles have \n\n// to be placed vertically. \n\ndp[i] = dp[i-\n1\n] + dp[i-\n4\n]; \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nSystem.out.println(\n\"Count of ways is: \"\n+ count(n)); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "index": 366, "complexity": 3}
{"back-translation": "import java.util.Scanner;\n\npublic class HammingDistancesSum {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString a = sc.nextLine(), b = sc.nextLine();\n\t\tlong sum = 0;\n\t\tint[][] frequency = new int[200010][2];\n\t\tfor (int i = 1; i <= b.length(); i++) {\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t\tfrequency[i][j] = frequency[i - 1][j];\n\t\t\tfrequency[i][Character.getNumericValue((b.charAt(i - 1)))]++;\n\t\t}\n\n\t\tfor (int i = 0; i < a.length(); i++) {\n\t\t\tint c = Character.getNumericValue(a.charAt(i));\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tint flippingTerm = Math.abs(c - j);\n\t\t\t\tint endOfWindowValue = frequency[b.length() - a.length() + i + 1][j];\n\t\t\t\tint startOfWindowOffset = frequency[i][j];\n\t\t\t\tsum += flippingTerm * (endOfWindowValue - startOfWindowOffset);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t\tsc.close();\n\t}\n}", "src": "import java.util.Scanner;\n\npublic class HammingDistancesSum {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString  a = sc.nextLine(), b = sc.nextLine();\n\t\tlong sum = 0;\n\t\tint frequency[][] = new int[200010][2];\n\t\tfor (int i = 1; i <= b.length(); i++) {\n\t        for (int j = 0; j < 2; j++)\n\t            frequency[i][j] = frequency[i - 1][j];\n\t        frequency[i][Character.getNumericValue((b.charAt(i - 1)))]++;\n\t    }\n\t   \n\t    for (int i = 0; i < a.length(); i++) {\n\t        int c = Character.getNumericValue(a.charAt(i));\n\t        for (int j = 0; j < 2; j++) {\n\t        \tint flippingTerm = Math.abs(c - j);\n\t        \tint endOfWindowValue = frequency[b.length() - a.length() + i + 1][j];\n\t        \tint startOfWindowOffset = frequency[i][j];\n\t            sum += flippingTerm * (endOfWindowValue - startOfWindowOffset);\n\t        }\n\t    }\n\t\tSystem.out.println(sum);\n\t\tsc.close();\n\t}\n}\n", "index": 367, "complexity": 3}
{"back-translation": "class FindUnion {\n\n    static void UnionArray(int[] arr1, int[] arr2) {\n\n        int m = arr1[arr1.length - 1];\n        int n = arr2[arr2.length - 1];\n        int ans = 0;\n\n        if (m > n) {\n            ans = m;\n        } else\n            ans = n;\n\n        int[] newtable = new int[ans + 1];\n\n        System.out.print(arr1[0] + \" \");\n        ++newtable[arr1[0]];\n\n        for (int i = 1; i < arr1.length; i++) {\n            if (arr1[i] != arr1[i - 1]) {\n                System.out.print(arr1[i] + \" \");\n                ++newtable[arr1[i]];\n            }\n        }\n\n        for (int j = 0; j < arr2.length; j++) {\n            if (newtable[arr2[j]] == 0) {\n                System.out.print(arr2[j] + \" \");\n                ++newtable[arr2[j]];\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        int arr1[] = {1, 2, 2, 2, 3};\n        int arr2[] = {2, 3, 4, 5};\n\n        UnionArray(arr1, arr2);\n    }\n}", "src": "\n// Java program to find union of two \n// sorted arrays (Handling Duplicates) \nclass\nFindUnion \n{ \n\n\nstatic\nvoid\nUnionArray(\nint\narr1[], \n\nint\narr2[]) \n\n{ \n\n// Taking max element present in either array \n\nint\nm = arr1[arr1.length - \n1\n]; \n\nint\nn = arr2[arr2.length - \n1\n]; \n\n\nint\nans = \n0\n; \n\n\nif\n(m > n) \n\n{ \n\nans = m; \n\n} \n\nelse\n\nans = n; \n\n\n// Finding elements from 1st array \n\n// (non duplicates only). Using \n\n// another array for storing union \n\n// elements of both arrays \n\n// Assuming max element present \n\n// in array is not more than 10^7 \n\nint\nnewtable[] = \nnew\nint\n[ans + \n1\n]; \n\n\n// First element is always \n\n// present in final answer \n\nSystem.out.print(arr1[\n0\n] + \n\" \"\n); \n\n\n// Incrementing the First element's count \n\n// in it's corresponding index in newtable \n\n++newtable[arr1[\n0\n]]; \n\n\n// Starting traversing the first \n\n// array from 1st index till last \n\nfor\n(\nint\ni = \n1\n; i < arr1.length; i++) \n\n{ \n\n// Checking whether current element \n\n// is not equal to it's previous element \n\nif\n(arr1[i] != arr1[i - \n1\n]) \n\n{ \n\nSystem.out.print(arr1[i] + \n\" \"\n); \n\n++newtable[arr1[i]]; \n\n} \n\n} \n\n\n// Finding only non common \n\n// elements from 2nd array \n\nfor\n(\nint\nj = \n0\n; j < arr2.length; j++) \n\n{ \n\n// By checking whether it's already \n\n// present in newtable or not \n\nif\n(newtable[arr2[j]] == \n0\n) \n\n{ \n\nSystem.out.print(arr2[j] + \n\" \"\n); \n\n++newtable[arr2[j]]; \n\n} \n\n} \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n4\n, \n5\n}; \n\n\nUnionArray(arr1, arr2); \n\n} \n} ", "index": 368, "complexity": 3}
{"back-translation": "class GFG { static int smallestSubWithSum(int arr[], int n, int x) { int curr_sum = 0, min_len = n + 1; int start = 0, end = 0; while (end < n) { while (curr_sum <= x && end < n) { if (curr_sum <= 0 && x > 0) { start = end; curr_sum = 0; } curr_sum += arr[end++]; } while (curr_sum > x && start < n) { if (end - start < min_len) min_len = end - start; curr_sum -= arr[start++]; } } return min_len; } public static void main(String[] args) { int arr1[] = {-8, 1, 4, 2, -6}; int x = 6; int n1 = arr1.length; int res1 = smallestSubWithSum(arr1, n1, x); if (res1 == n1 + 1) System.out.println(\"Not possible\"); else System.out.println(res1); } }", "src": "\n// Java O(n) solution for \n// finding smallest subarray \n// with sum greater than x \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Returns length of smallest \n// subarray with sum greater \n// than x. If there is no \n// subarray with given sum, \n// then returns n+1 \nstatic\nint\nsmallestSubWithSum(\nint\narr[], \n\nint\nn, \nint\nx) \n{ \n\n// Initialize current \n\n// sum and minimum length \n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n// Initialize starting \n\n// and ending indexes \n\nint\nstart = \n0\n, end = \n0\n; \n\nwhile\n(end < n) \n\n{ \n\n// Keep adding array \n\n// elements while current \n\n// sum is smaller than x \n\nwhile\n(curr_sum <= x && end < n) \n\n{ \n\n// Ignore subarrays with \n\n// negative sum if x is \n\n// positive. \n\nif\n(curr_sum <= \n0\n&& x > \n0\n) \n\n{ \n\nstart = end; \n\ncurr_sum = \n0\n; \n\n} \n\n\ncurr_sum += arr[end++]; \n\n} \n\n\n// If current sum becomes \n\n// greater than x. \n\nwhile\n(curr_sum > x && start < n) \n\n{ \n\n// Update minimum \n\n// length if needed \n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n// remove starting elements \n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n} \n\n\n// Driver Code \npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\narr1[] = {- \n8\n, \n1\n, \n4\n, \n2\n, -\n6\n}; \n\nint\nx = \n6\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, \n\nn1, x); \n\nif\n(res1 == n1 + \n1\n) \n\nSystem.out.println(\n\"Not possible\"\n); \n\nelse\n\nSystem.out.println (res1); \n} \n} \n\n// This code is contributed by ajit ", "index": 370, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class TransformedClass {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int result = 1;\n        int thomasSum = 0;\n        StringTokenizer stk;\n        stk = new StringTokenizer(br.readLine());\n        int first = Integer.parseInt(stk.nextToken());\n        int second = Integer.parseInt(stk.nextToken());\n        int third = Integer.parseInt(stk.nextToken());\n        int fourth = Integer.parseInt(stk.nextToken());\n        thomasSum = first + second + third + fourth;\n        int tmp;\n        int i = 1;\n        while (i < n) {\n            stk = new StringTokenizer(br.readLine());\n            first = Integer.parseInt(stk.nextToken());\n            second = Integer.parseInt(stk.nextToken());\n            third = Integer.parseInt(stk.nextToken());\n            fourth = Integer.parseInt(stk.nextToken());\n            tmp = first + second + third + fourth;\n            if (tmp > thomasSum)\n                result++;\n            i++;\n        }\n        System.out.println(result);\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Cf1017A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int result = 1;\n        int thomasSum = 0;\n        StringTokenizer stk;\n        stk = new StringTokenizer(br.readLine());\n        int first = Integer.parseInt(stk.nextToken());\n        int second = Integer.parseInt(stk.nextToken());\n        int third = Integer.parseInt(stk.nextToken());\n        int fourth = Integer.parseInt(stk.nextToken());\n        thomasSum = first + second + third + fourth;\n        int tmp;\n        for (int i = 1; i < n; i++) {\n            stk = new StringTokenizer(br.readLine());\n            first = Integer.parseInt(stk.nextToken());\n            second = Integer.parseInt(stk.nextToken());\n            third = Integer.parseInt(stk.nextToken());\n            fourth = Integer.parseInt(stk.nextToken());\n            tmp = first + second + third + fourth;\n            if (tmp > thomasSum)\n                result++;\n        }\n        System.out.println(result);\n    }\n}", "index": 371, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.io.*;\nimport java.util.*;\n \n \n \npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint n = in.nextInt();\n\t\tint q = in.nextInt();\n\t\t\n\t\tArrayDeque<Integer> dq = new ArrayDeque<>();\n\t\tint max = -1;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x = in.nextInt();\n\t\t\tdq.add(x);\n\t\t\tmax = Math.max(max, x);\n\t\t}\n\t\tArrayList<Pair> ans = new ArrayList<>();\n\t\twhile(dq.peekFirst() != max) {\n\t\t\tint a = dq.pollFirst();\n\t\t\tint b = dq.pollFirst();\n\t\t\tans.add(new Pair(a, b));\n\t\t\tif(a > b) {\n\t\t\t\tdq.addFirst(a);\n\t\t\t\tdq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdq.addFirst(b);\n\t\t\t\tdq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> a = new ArrayList<>();\n\t\tdq.pollFirst();\n\t\tfor(int x : dq)\n\t\t\ta.add(x);\n\t\twhile(q --> 0) {\n\t\t\tlong m = in.nextLong() - 1;\n\t\t\tif(m < ans.size()) {\n\t\t\t\tSystem.out.println(ans.get((int)m).first + \" \" + ans.get((int)m).second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint idx = (int)((m - ans.size()) % a.size());\n\t\t\t\tSystem.out.println(max + \" \" + a.get(idx));\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\t\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "index": 372, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass GFG {\n\n    static int maxSum(int arr[], int n) {\n        int sum = 0;\n        int i;\n        int pivot = findPivot(arr, n);\n        int diff = n - 1 - pivot;\n        for (i = 0; i < n; i++) {\n            sum += ((i + diff) % n) * arr[i];\n        }\n        return sum;\n    }\n\n    static int findPivot(int arr[], int n) {\n        int i;\n        for (i = 0; i < n; i++) {\n            if (arr[i] > arr[(i + 1) % n]) {\n                return i;\n            }\n        }\n        return 0;\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {8, 3, 1, 2};\n        int n = arr.length;\n        int max = maxSum(arr, n);\n        System.out.println(max);\n    }\n}", "src": "\n// Java program to find maximum sum \n// of all rotation of i*arr[i] using pivot. \n\nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// function definition \nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nsum = \n0\n; \n\nint\ni; \n\nint\npivot = findPivot(arr, n); \n\n\n// difference in pivot and index of \n\n// last element of array \n\nint\ndiff = n - \n1\n- pivot; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nsum= sum + ((i + diff) % n) * arr[i]; \n\n} \n\nreturn\nsum; \n} \n\n// function to find pivot \nstatic\nint\nfindPivot(\nint\narr[], \nint\nn) \n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] > arr[(i + \n1\n) % n]) \n\nreturn\ni; \n\n} \n\nreturn\n0\n; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n// rotated input array \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nmax = maxSum(arr,n); \n\nSystem.out.println(max); \n\n} \n} ", "index": 373, "complexity": 3}
{"back-translation": "class Main { static int countOccurrences(int[] arr, int n, int x) { int res = 0; for (int i = 0; i < n; i++) if (x == arr[i]) res++; return res; } public static void main(String args[]) { int[] arr = {1, 2, 2, 2, 2, 3, 4, 7, 8, 8}; int n = arr.length; int x = 2; System.out.println(countOccurrences(arr, n, x)); } }", "src": "\n// Java program to count occurrences \n// of an element \n\nclass\nMain \n{ \n\n// Returns number of times x occurs in arr[0..n-1] \n\nstatic\nint\ncountOccurrences(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nif\n(x == arr[i]) \n\nres++; \n\nreturn\nres; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n3\n, \n4\n, \n7\n,\n8\n,\n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.println(countOccurrences(arr, n, x)); \n\n} \n} ", "index": 374, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.InputMismatchException;\nimport java.util.Stack;\npublic class D527A2 {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint N = in.nextInt();\n\t\tStack<Integer> stack = new Stack<>();\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint num = in.nextInt() % 2;\n\t\t\tif(stack.size() >= 1 && stack.lastElement() == num)\n\t\t\t\tstack.pop();\n\t\t\telse\n\t\t\t\tstack.add(num);\n\t\t}\n\t\t\n\t\tSystem.out.println(stack.size() <= 1 ? \"YES\" : \"NO\");\n\t}\n\t\n\t/**\n\t * Source: Matt Fontaine\n\t */\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}\n/*\n5\n2 1 1 2 5\noutputCopy\nYES\ninputCopy\n3\n4 5 3\noutputCopy\nYES\ninputCopy\n2\n10 10\noutputCopy\nYES\ninputCopy\n3\n1 2 3\noutputCopy\nNO\n\n5\n2 3 2 2 3\n\nYES\n*/", "index": 375, "complexity": 3}
{"back-translation": "import java.util.Scanner;\npublic class NewClass {\n    static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        int n = in.nextInt(), ans = Integer.MAX_VALUE, t = 0;\n        String x = in.next();\n        for (int i = 0; i < n; i++) {\n            if (x.charAt(i) == '-')\n                t--;\n            else\n                t++;\n            ans = Math.min(ans, t);\n        }\n        if (ans <= 0)\n            System.out.println(Math.abs(ans) + t);\n        else\n            System.out.println(t);\n    }\n}", "src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package newpackage;\nimport java.util.*;\n/**\n *\n * @author parpaorsa\n */\npublic class NewClass {\n    static Scanner in=new Scanner(System.in);\n    public static void main(String[] args) {\n        int n = in.nextInt(),ans=Integer.MAX_VALUE,t=0;\n        String x = in.next();\n        for (int i = 0; i < n; i++) {\n            if(x.charAt(i)=='-')t--;\n            else t++;\n            ans=Math.min(ans,t);\n        }\n           if(ans <= 0) \n               System.out.println(Math.abs(ans)+t);\n           else \n               System.out.println(t);\n    }\n \n}\n", "index": 376, "complexity": 3}
{"back-translation": "import java.util.Scanner;\npublic class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i) {\n\t\t\ts1+=input.nextInt();\n\t\t}\n\t\tfor (int i=0;i<n;++i) {\n\t\t\ts2+=input.nextInt();\n\t\t}\n\t\tif (s1 >= s2) {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "src": "\n\nimport java.util.Scanner;\npublic class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts1+=input.nextInt();\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts2+=input.nextInt();\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}\n", "index": 377, "complexity": 3}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class Code {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t int n = Integer.parseInt(br.readLine());\n\t\t HashMap<Double,Integer>h = new HashMap<>();\n\t\t double [] temp = new double[n];\n\t\t int m = 0;\n\t\t for(int i=0;i<n;i++) {\n\t\t\t String l = br.readLine();\n\t\t\t int[] x = new int[4];\n\t\t\t int k=0;\n\t\t\t boolean t = false;\n\t\t\t for(int j=0;j<l.length();j++) {\n\t\t\t\t if(l.charAt(j)=='(' || l.charAt(j)=='+' || l.charAt(j)==')' || l.charAt(j)=='/')\n\t\t\t\t\t x[k++] = j;\n\t\t\t }\n\t\t\t double a = Integer.parseInt(l.substring(x[0]+1,x[1]));\n\t\t\t double b = Integer.parseInt(l.substring(x[1]+1, x[2]));\n\t\t\t double c = Integer.parseInt(l.substring(x[3]+1));\n\t\t\t temp[m++] = (a+b)/c;\n\t\t\t //System.out.print((a+b)/c + \" \");\n\t\t\tif(h.containsKey((a+b)/c))\n\t\t\t\t\th.put((a+b)/c, h.get((a+b)/c)+1);\n\t\t\telse\n\t\t\t\th.put((a+b)/c, 1);\n\t\t }\n\t\t //System.out.println(h);\n\t\t for(int i=0;i<n;i++) {\n\t\t\t System.out.print(h.get(temp[i]) + \" \");\n\t\t }\n\t}\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class Code {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t int n = Integer.parseInt(br.readLine());\n\t\t HashMap<Double,Integer>h = new HashMap<>();\n\t\t double [] temp = new double[n];\n\t\t int m = 0;\n\t\t for(int i=0;i<n;i++) {\n\t\t\t String l = br.readLine();\n\t\t\t int[] x = new int[4];\n\t\t\t int k=0;\n\t\t\t boolean t = false;\n\t\t\t for(int j=0;j<l.length();j++) {\n\t\t\t\t if(l.charAt(j)=='(' || l.charAt(j)=='+' || l.charAt(j)==')' || l.charAt(j)=='/')\n\t\t\t\t\t x[k++] = j;\n\t\t\t }\n\t\t\t double a = Integer.parseInt(l.substring(x[0]+1,x[1]));\n\t\t\t double b = Integer.parseInt(l.substring(x[1]+1, x[2]));\n\t\t\t double c = Integer.parseInt(l.substring(x[3]+1));\n\t\t\t temp[m++] = (a+b)/c;\n\t\t\t //System.out.print((a+b)/c + \" \");\n\t\t\tif(h.containsKey((a+b)/c))\n\t\t\t\t\th.put((a+b)/c, h.get((a+b)/c)+1);\n\t\t\telse\n\t\t\t\th.put((a+b)/c, 1);\n\t\t }\n\t\t //System.out.println(h);\n\t\t for(int i=0;i<n;i++) {\n\t\t\t System.out.print(h.get(temp[i]) + \" \");\n\t\t }\n\t}\n\t}\n", "index": 378, "complexity": 3}
{"back-translation": "ERROR", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class C {\n\n\tpublic static int mod = 1000000000 + 7;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString n = br.readLine();\n\t\tint k = Integer.parseInt(br.readLine());\n\t\tint l = n.length();\n\t\t\n\t\tif(k == 0) {\n\t\t\tSystem.out.println(1);\n\t\t}else {\n\t\t\tint max = 1000;\n\t\t\tif (l <= 10) {\n\t\t\t\tmax = Integer.min(1000, Integer.parseInt(n, 2));\n\t\t\t}\n\n\t\t\tint[] steps = new int[max + 1];\n\t\t\t\t\t\n\t\t\tfor (int i = 2; i <= max; i++) {\n\t\t\t\tint ones = numberOfOnes(i);\n\t\t\t\tsteps[i] = 1 + steps[ones];\n\t\t\t}\n\n\t\t\tif (l <= 10) {\n\t\t\t\tint ans = 0;\n\t\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\t\tif (steps[i] == k) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t} else {\n\t\t\t\tint[][] C = binomial(max);\n\n\t\t\t\tint ans = 0;\n\t\t\t\tint count = 0;\n\n\t\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\t\tif (n.charAt(i) == '1') {\n\t\t\t\t\t\tfor (int j = count; j < max; j++) {\n\t\t\t\t\t\t\tif (steps[j] == k - 1) {\n\t\t\t\t\t\t\t\tans = (ans + C[l - i - 1][j - count]) % mod;\n\t\t\t\t\t\t\t\tif (i == 0 && k == 1) {\n\t\t\t\t\t\t\t\t\tans = (ans + mod - 1) % mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint ones = 0;\n\t\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\t\tif (n.charAt(i) == '1') {\n\t\t\t\t\t\tones++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (steps[ones] == k-1) {\n\t\t\t\t\tans = (ans + 1) % mod;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int numberOfOnes(int x) {\n\t\tchar[] s = Integer.toBinaryString(x).toCharArray();\n\t\tint count = 0;\n\t\tfor (char c : s) {\n\t\t\tif (c == '1') {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static int[][] binomial(int n) {\n\t\tint[][] C = new int[n + 1][n + 1];\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tC[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tC[i][j] = ((C[i - 1][j - 1] % mod) + (C[i - 1][j] % mod)) % mod;\n\t\t\t}\n\t\t}\n\n\t\treturn C;\n\t}\n\n}\n", "index": 380, "complexity": 3}
{"back-translation": "class Count_Subsequences {\n\n    static final int MAX_CHAR = 256;\n\n    public static int countSub(String str) {\n        int[] last = new int[MAX_CHAR];\n        Arrays.fill(last, -1);\n        int n = str.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n\n        for (int i = 1; i <= n; i++) {\n            dp[i] = 2 * dp[i - 1];\n\n            if (last[(int) str.charAt(i - 1)] != -1)\n                dp[i] = dp[i] - dp[last[(int) str.charAt(i - 1)]];\n\n            last[(int) str.charAt(i - 1)] = (i - 1);\n        }\n\n        return dp[n];\n    }\n\n    public static void main(String[] args) {\n        System.out.println(countSub(\"gfg\"));\n    }\n}", "src": "\n// Java program to count number of distinct \n// subsequences of a given string. \nimport\njava.util.ArrayList; \nimport\njava.util.Arrays; \npublic\nclass\nCount_Subsequences { \n\n\nstatic\nfinal\nint\nMAX_CHAR = \n256\n; \n\n\n// Returns count of distinct sunsequences of str. \n\nstatic\nint\ncountSub(String str) \n\n{ \n\n// Create an array to store index \n\n// of last \n\nint\n[] last = \nnew\nint\n[MAX_CHAR]; \n\nArrays.fill(last, -\n1\n); \n\n\n// Length of input string \n\nint\nn = str.length(); \n\n\n// dp[i] is going to store count of distinct \n\n// subsequences of length i. \n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\n\n// Empty substring has only one subsequence \n\ndp[\n0\n] = \n1\n; \n\n\n// Traverse through all lengths from 1 to n. \n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n// Number of subsequences with substring \n\n// str[0..i-1] \n\ndp[i] = \n2\n*dp[i-\n1\n]; \n\n\n// If current character has appeared \n\n// before, then remove all subsequences \n\n// ending with previous occurrence. \n\nif\n(last[(\nint\n)str.charAt(i-\n1\n)] != -\n1\n) \n\ndp[i] = dp[i] - dp[last[(\nint\n)str.charAt(i-\n1\n)]]; \n\n\n// Mark occurrence of current character \n\nlast[(\nint\n)str.charAt(i-\n1\n)] = (i-\n1\n); \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(countSub(\n\"gfg\"\n)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "index": 381, "complexity": 3}
{"back-translation": "class ClosestPair { void printClosest(int ar1[], int ar2[], int m, int n, int x) { int diff = Integer.MAX_VALUE; int res_l = 0, res_r = 0; int l = 0, r = n-1; while (l < m && r >= 0) { if (Math.abs(ar1[l] + ar2[r] - x) < diff) { res_l = l; res_r = r; diff = Math.abs(ar1[l] + ar2[r] - x); } if (ar1[l] + ar2[r] > x) r--; else l++; } System.out.print(\"The closest pair is [\" + ar1[res_l] + \", \" + ar2[res_r] + \"]\"); } public static void main(String args[]) { ClosestPair ob = new ClosestPair(); int[] ar1 = {1, 4, 5, 7}; int[] ar2 = {10, 20, 30, 40}; int m = ar1.length; int n = ar2.length; int x = 38; ob.printClosest(ar1, ar2, m, n, x); } }", "src": "\n// Java program to find closest pair in an array \nclass\nClosestPair \n{ \n\n// ar1[0..m-1] and ar2[0..n-1] are two given sorted \n\n// arrays/ and x is given number. This function prints \n\n// the pair from both arrays such that the sum of the \n\n// pair is closest to x. \n\nvoid\nprintClosest(\nint\nar1[], \nint\nar2[], \nint\nm, \nint\nn, \nint\nx) \n\n{ \n\n// Initialize the diff between pair sum and x. \n\nint\ndiff = Integer.MAX_VALUE; \n\n\n// res_l and res_r are result indexes from ar1[] and ar2[] \n\n// respectively \n\nint\nres_l = \n0\n, res_r = \n0\n; \n\n\n// Start from left side of ar1[] and right side of ar2[] \n\nint\nl = \n0\n, r = n-\n1\n; \n\nwhile\n(l<m && r>=\n0\n) \n\n{ \n\n// If this pair is closer to x than the previously \n\n// found closest, then update res_l, res_r and diff \n\nif\n(Math.abs(ar1[l] + ar2[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(ar1[l] + ar2[r] - x); \n\n} \n\n\n// If sum of this pair is more than x, move to smaller \n\n// side \n\nif\n(ar1[l] + ar2[r] > x) \n\nr--; \n\nelse\n// move to the greater side \n\nl++; \n\n} \n\n\n// Print the result \n\nSystem.out.print(\n\"The closest pair is [\"\n+ ar1[res_l] + \n\n\", \"\n+ ar2[res_r] + \n\"]\"\n); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nClosestPair ob = \nnew\nClosestPair(); \n\nint\nar1[] = {\n1\n, \n4\n, \n5\n, \n7\n}; \n\nint\nar2[] = {\n10\n, \n20\n, \n30\n, \n40\n}; \n\nint\nm = ar1.length; \n\nint\nn = ar2.length; \n\nint\nx = \n38\n; \n\nob.printClosest(ar1, ar2, m, n, x); \n\n} \n} \n/*This code is contributed by Rajat Mishra */", "index": 382, "complexity": 3}
{"back-translation": "class Node { int data; Node left, right; Node(int item) { data = item; left = right = null; } } class Index { int index = 0; } class BinaryTree { Node root; Index myindex = new Index(); Node constructTreeUtil(int[] pre, char[] preLN, Index index_ptr, int n, Node temp) { int index = index_ptr.index; if (index == n) return null; temp = new Node(pre[index]); index_ptr.index++; if (preLN[index] == 'N') { temp.left = constructTreeUtil(pre, preLN, index_ptr, n, temp.left); temp.right = constructTreeUtil(pre, preLN, index_ptr, n, temp.right); } return temp; } Node constructTree(int[] pre, char[] preLN, int n, Node node) { int index = 0; return constructTreeUtil(pre, preLN, myindex, n, node); } void printInorder(Node node) { if (node == null) return; printInorder(node.left); System.out.print(node.data + \" \"); printInorder(node.right); } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); int pre[] = new int[]{10, 30, 20, 5, 15}; char preLN[] = new char[]{'N', 'N', 'L', 'L', 'L'}; int n = pre.length; Node mynode = tree.constructTree(pre, preLN, n, tree.root); System.out.println(\"Following is Inorder Traversal of the\" + \"Constructed Binary Tree: \"); tree.printInorder(mynode); } }", "src": "\n// Java program to construct a binary tree from preorder traversal \n\n// A Binary Tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nIndex \n{ \n\nint\nindex = \n0\n; \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nIndex myindex = \nnew\nIndex(); \n\n\n/* A recursive function to create a Binary Tree from given pre[] \n\npreLN[] arrays. The function returns root of tree. index_ptr is used \n\nto update index values in recursive calls. index must be initially \n\npassed as 0 */\n\nNode constructTreeUtil(\nint\npre[], \nchar\npreLN[], Index index_ptr, \n\nint\nn, Node temp) \n\n{ \n\n// store the current value of index in pre[] \n\nint\nindex = index_ptr.index; \n\n\n// Base Case: All nodes are constructed \n\nif\n(index == n) \n\nreturn\nnull\n; \n\n\n// Allocate memory for this node and increment index for \n\n// subsequent recursive calls \n\ntemp = \nnew\nNode(pre[index]); \n\n(index_ptr.index)++; \n\n\n// If this is an internal node, construct left and right subtrees \n\n// and link the subtrees \n\nif\n(preLN[index] == \n'N'\n) \n\n{ \n\ntemp.left = constructTreeUtil(pre, preLN, index_ptr, n, \n\ntemp.left); \n\ntemp.right = constructTreeUtil(pre, preLN, index_ptr, n, \n\ntemp.right); \n\n} \n\n\nreturn\ntemp; \n\n} \n\n\n// A wrapper over constructTreeUtil() \n\nNode constructTree(\nint\npre[], \nchar\npreLN[], \nint\nn, Node node) \n\n{ \n\n// Initialize index as 0. Value of index is used in recursion to \n\n// maintain the current index in pre[] and preLN[] arrays. \n\nint\nindex = \n0\n; \n\n\nreturn\nconstructTreeUtil(pre, preLN, myindex, n, node); \n\n} \n\n\n/* This function is used only for testing */\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n/* first recur on left child */\n\nprintInorder(node.left); \n\n\n/* then print the data of node */\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n/* now recur on right child */\n\nprintInorder(node.right); \n\n} \n\n\n// driver function to test the above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\npre[] = \nnew\nint\n[]{\n10\n, \n30\n, \n20\n, \n5\n, \n15\n}; \n\nchar\npreLN[] = \nnew\nchar\n[]{\n'N'\n, \n'N'\n, \n'L'\n, \n'L'\n, \n'L'\n}; \n\nint\nn = pre.length; \n\n\n// construct the above tree \n\nNode mynode = tree.constructTree(pre, preLN, n, tree.root); \n\n\n// Test the constructed tree \n\nSystem.out.println(\n\"Following is Inorder Traversal of the\"\n\n+ \n\"Constructed Binary Tree: \"\n); \n\ntree.printInorder(mynode); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal \n", "index": 383, "complexity": 3}
{"back-translation": "import java.util.*;\n\npublic class helloWorld { \n\tpublic static void main(String[] args) { \n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint[][] dn = new int[200][m + 1];\n\t\t\n\t\tfor (int i = 0; i < n; i++) { \n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor (int k = 2; k <= m; k++)\n\t\t\tfor (int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif (exist[i]) { \n\t\t\t\t\tint a = 0; \n\t\t\t\t\tfor (int j = i + 2; j <= 'z'; j++) \n\t\t\t\t\t\tif (dn[j][k - 1] > 0 && (a == 0 || (a > dn[j][k - 1]))) \n\t\t\t\t\t\t\ta = dn[j][k - 1];\n\t\t\t\t\tif (a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1; \n\t\tfor (int i = 'a'; i <= 'z'; i++)\n\t\t\tif (dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]))\n\t\t\t\tans = dn[i][m]; \n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}\t\n\n\n\n", "index": 384, "complexity": 3}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class RGBSubstring {\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int Q = scanner.nextInt();\n        while(Q-->0) {\n            int N = scanner.nextInt();\n            int K = scanner.nextInt();\n            String s1 = \"RGB\";\n            String s2 = \"GBR\";\n            String s3 = \"BRG\";\n            char[] arr = scanner.next().toCharArray();\n            int[] cnts = new int[3];\n            for(int i = 0; i < K; i++) {\n                int ind = i % 3;\n                if (arr[i] != s1.charAt(ind)) cnts[0]++;\n                if (arr[i] != s2.charAt(ind)) cnts[1]++;\n                if (arr[i] != s3.charAt(ind)) cnts[2]++;\n            }\n            int ans = Math.min(Math.min(cnts[0], cnts[1]), cnts[2]);\n            for(int i = K; i < N; i++) {\n                int ind = (K-1)%3;\n                int[] nextCnts = new int[3];\n                nextCnts[1] = cnts[0];\n                nextCnts[2] = cnts[1];\n                nextCnts[0] = cnts[2];\n                if ('R' != arr[i-K]) nextCnts[1]--;\n                if ('G' != arr[i-K]) nextCnts[2]--;\n                if ('B' != arr[i-K]) nextCnts[0]--;\n                if (arr[i] != s1.charAt(ind)) nextCnts[0]++;\n                if (arr[i] != s2.charAt(ind)) nextCnts[1]++;\n                if (arr[i] != s3.charAt(ind)) nextCnts[2]++;\n                cnts = nextCnts;\n                for(int j = 0; j < 3; j++) ans = Math.min(ans, cnts[j]);\n            }\n            out.println(ans);\n        }\n        out.flush();\n    }\n    \n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n}\n", "src": "import java.util.*;\nimport java.io.*;\n\npublic class RGBSubstring {\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int Q = scanner.nextInt();\n        while(Q-->0) {\n            int N = scanner.nextInt();\n            int K = scanner.nextInt();\n            String s1 = \"RGB\";\n            String s2 = \"GBR\";\n            String s3 = \"BRG\";\n            char[] arr = scanner.next().toCharArray();\n            int[] cnts = new int[3];\n            for(int i = 0; i < K; i++) {\n                int ind = i % 3;\n                if (arr[i] != s1.charAt(ind)) cnts[0]++;\n                if (arr[i] != s2.charAt(ind)) cnts[1]++;\n                if (arr[i] != s3.charAt(ind)) cnts[2]++;\n            }\n            int ans = Math.min(Math.min(cnts[0], cnts[1]), cnts[2]);\n            for(int i = K; i < N; i++) {\n                int ind = (K-1)%3;\n                int[] nextCnts = new int[3];\n                nextCnts[1] = cnts[0];\n                nextCnts[2] = cnts[1];\n                nextCnts[0] = cnts[2];\n                if ('R' != arr[i-K]) nextCnts[1]--;\n                if ('G' != arr[i-K]) nextCnts[2]--;\n                if ('B' != arr[i-K]) nextCnts[0]--;\n                if (arr[i] != s1.charAt(ind)) nextCnts[0]++;\n                if (arr[i] != s2.charAt(ind)) nextCnts[1]++;\n                if (arr[i] != s3.charAt(ind)) nextCnts[2]++;\n                cnts = nextCnts;\n                for(int j = 0; j < 3; j++) ans = Math.min(ans, cnts[j]);\n            }\n            out.println(ans);\n        }\n        out.flush();\n    }\n    \n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n}\n", "index": 385, "complexity": 5}
{"back-translation": "class GFG { static int maxSubarrayXOR(int arr[], int n) { int ans = 0; for (int i=0; i<n; i++) { int curr_xor = 0; for (int j=i; j<n; j++) { curr_xor = curr_xor ^ arr[j]; ans = Math.max(ans, curr_xor); } } return ans; } public static void main(String args[]) { int arr[] = {8, 1, 2, 12}; int n = arr.length; System.out.println(\"Max subarray XOR is \"+ maxSubarrayXOR(arr, n)); } }", "src": "\n// A simple Java program to find max subarray XOR \nclass\nGFG { \n\nstatic\nint\nmaxSubarrayXOR(\nint\narr[], \nint\nn) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n// Initialize result \n\n\n// Pick starting points of subarrays \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n// to store xor of current subarray \n\nint\ncurr_xor = \n0\n; \n\n\n// Pick ending points of subarrays starting with i \n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\ncurr_xor = curr_xor ^ arr[j]; \n\nans = Math.max(ans, curr_xor); \n\n} \n\n} \n\nreturn\nans; \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n8\n, \n1\n, \n2\n, \n12\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Max subarray XOR is \"\n+ \n\nmaxSubarrayXOR(arr, n)); \n\n} \n} \n//This code is contributed by Sumit Ghosh ", "index": 386, "complexity": 5}
{"back-translation": "ERROR", "src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.System.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t// out.println(\"---- \"+arr[i]);\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// out.println(list.toString());\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// out.println(list.toString());\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "index": 387, "complexity": 5}
{"back-translation": "class Node {\n    int data;\n    Node left, right;\n\n    Node(int item) {\n        data = item;\n        left = right = null;\n    }\n}\n\nclass BinaryTree {\n    Node root;\n\n    Node buildTree(int inorder[], int start, int end, Node node) {\n        if (start > end) return null;\n\n        int i = max(inorder, start, end);\n\n        node = new Node(inorder[i]);\n\n        if (start == end) return node;\n\n        node.left = buildTree(inorder, start, i - 1, node.left);\n        node.right = buildTree(inorder, i + 1, end, node.right);\n\n        return node;\n    }\n\n    int max(int arr[], int strt, int end) {\n        int i, max = arr[strt], maxind = strt;\n        for (i = strt + 1; i <= end; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n                maxind = i;\n            }\n        }\n        return maxind;\n    }\n\n    void printInorder(Node node) {\n        if (node == null) return;\n        printInorder(node.left);\n        System.out.print(node.data + \" \");\n        printInorder(node.right);\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n\n        int inorder[] = new int[]{5, 10, 40, 30, 28};\n        int len = inorder.length;\n        Node mynode = tree.buildTree(inorder, 0, len - 1, tree.root);\n\n        System.out.println(\"Inorder traversal of the constructed tree is \");\n        tree.printInorder(mynode);\n    }\n}", "src": "\n// Java program to construct tree from inorder traversal \n\n/* A binary tree node has data, pointer to left child \n\nand a pointer to right child */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* Recursive function to construct binary of size len from \n\nInorder traversal inorder[]. Initial values of start and end \n\nshould be 0 and len -1. */\n\nNode buildTree(\nint\ninorder[], \nint\nstart, \nint\nend, Node node) \n\n{ \n\nif\n(start > end) \n\nreturn\nnull\n; \n\n\n/* Find index of the maximum element from Binary Tree */\n\nint\ni = max(inorder, start, end); \n\n\n/* Pick the maximum value and make it root */\n\nnode = \nnew\nNode(inorder[i]); \n\n\n/* If this is the only element in inorder[start..end], \n\nthen return it */\n\nif\n(start == end) \n\nreturn\nnode; \n\n\n/* Using index in Inorder traversal, construct left and \n\nright subtress */\n\nnode.left = buildTree(inorder, start, i - \n1\n, node.left); \n\nnode.right = buildTree(inorder, i + \n1\n, end, node.right); \n\n\nreturn\nnode; \n\n} \n\n\n/* UTILITY FUNCTIONS */\n\n\n/* Function to find index of the maximum value in arr[start...end] */\n\nint\nmax(\nint\narr[], \nint\nstrt, \nint\nend) \n\n{ \n\nint\ni, max = arr[strt], maxind = strt; \n\nfor\n(i = strt + \n1\n; i <= end; i++) \n\n{ \n\nif\n(arr[i] > max) \n\n{ \n\nmax = arr[i]; \n\nmaxind = i; \n\n} \n\n} \n\nreturn\nmaxind; \n\n} \n\n\n/* This funtcion is here just to test buildTree() */\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n/* first recur on left child */\n\nprintInorder(node.left); \n\n\n/* then print the data of node */\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n/* now recur on right child */\n\nprintInorder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n/* Assume that inorder traversal of following tree is given \n\n40 \n\n/ \\ \n\n10 30 \n\n/ \\ \n\n5 28 */\n\nint\ninorder[] = \nnew\nint\n[]{\n5\n, \n10\n, \n40\n, \n30\n, \n28\n}; \n\nint\nlen = inorder.length; \n\nNode mynode = tree.buildTree(inorder, \n0\n, len - \n1\n, tree.root); \n\n\n/* Let us test the built tree by printing Inorder traversal */\n\nSystem.out.println(\n\"Inorder traversal of the constructed tree is \"\n); \n\ntree.printInorder(mynode); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 388, "complexity": 5}
{"back-translation": "class GFG {\n    static int findMaxSum(int[] arr, int n) {\n        int res = Integer.MIN_VALUE;\n        for (int i = 0; i < n; i++) {\n            int prefix_sum = arr[i];\n            for (int j = 0; j < i; j++) {\n                prefix_sum += arr[j];\n            }\n            int suffix_sum = arr[i];\n            for (int j = n - 1; j > i; j--) {\n                suffix_sum += arr[j];\n            }\n            if (prefix_sum == suffix_sum) {\n                res = Math.max(res, prefix_sum);\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {-2, 5, 3, 1, 2, 6, -4, 2};\n        int n = arr.length;\n        System.out.println(findMaxSum(arr, n));\n    }\n}", "src": "\n// java program to find maximum \n// equilibrium sum. \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Function to find maximum \n\n// equilibrium sum. \n\nstatic\nint\nfindMaxSum(\nint\n[]arr, \nint\nn) \n\n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\nprefix_sum = arr[i]; \n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nprefix_sum += arr[j]; \n\n\nint\nsuffix_sum = arr[i]; \n\n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nsuffix_sum += arr[j]; \n\n\nif\n(prefix_sum == suffix_sum) \n\nres = Math.max(res, prefix_sum); \n\n} \n\n\nreturn\nres; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {-\n2\n, \n5\n, \n3\n, \n1\n, \n2\n, \n6\n, -\n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findMaxSum(arr, n)); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "index": 389, "complexity": 5}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.readInt();\n            int[] a = in.readIntArray(n);\n            int[][] sol = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                sol[0][i] = a[i];\n            }\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j < n - i; j++) {\n                    sol[i][j] = sol[i - 1][j] ^ sol[i - 1][j + 1];\n                }\n            }\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j < n - i; j++) {\n                    sol[i][j] = Math.max(sol[i][j], Math.max(sol[i - 1][j], sol[i - 1][j + 1]));\n                }\n            }\n            int q = in.readInt();\n            for (int i = 0; i < q; i++) {\n                int l = in.readInt() - 1;\n                int r = in.readInt() - 1;\n                out.println(sol[r - l][l]);\n            }\n        }\n    }\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() {\n        try {\n            if (curChar >= numChars) {\n                curChar = 0;\n                numChars = stream.read(buf);\n                        if (numChars <= 0)\n                            return -1;\n                    }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        return (int) readLong();\n    }\n\n    public long readLong() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n            if (c == -1) throw new RuntimeException();\n        }\n        boolean negative = false;\n        if (c == \\'-\\') {\n            negative = true;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < \\'0\\' || c > \\'9\\') throw new InputMismatchException();\n            res *= 10;\n            res += (c - \\'0\\');\n            c = read();\n        } while (!isSpaceChar(c));\n        return negative ? (-res) : (res);\n    }\n\n    public int[] readIntArray(int size) {\n        int[] arr = new int[size];\n        for (int i = 0; i < size; i++) arr[i] = readInt();\n        return arr;\n    }\n\n    private boolean isSpaceChar(int c) {\n        return c == \\' \\' || c == \\'\\n\\' || c == \\'\\r\\' || c == \\'\\t\\' || c == -1;\n    }\n}\n\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author pandusonu\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            // out.print(\"Case #\" + testNumber + \": \");\n            int n = in.readInt();\n            int[] a = in.readIntArray(n);\n            int[][] sol = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                sol[0][i] = a[i];\n            }\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j < n - i; j++) {\n                    sol[i][j] = sol[i - 1][j] ^ sol[i - 1][j + 1];\n                }\n            }\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j < n - i; j++) {\n                    sol[i][j] = Math.max(sol[i][j], Math.max(sol[i - 1][j], sol[i - 1][j + 1]));\n                }\n            }\n            int q = in.readInt();\n            for (int i = 0; i < q; i++) {\n                int l = in.readInt() - 1;\n                int r = in.readInt() - 1;\n                out.println(sol[r - l][l]);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() {\n            try {\n                if (curChar >= numChars) {\n                    curChar = 0;\n                    numChars = stream.read(buf);\n                    if (numChars <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            return (int) readLong();\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n                if (c == -1) throw new RuntimeException();\n            }\n            boolean negative = false;\n            if (c == '-') {\n                negative = true;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res *= 10;\n                res += (c - '0');\n                c = read();\n            } while (!isSpaceChar(c));\n            return negative ? (-res) : (res);\n        }\n\n        public int[] readIntArray(int size) {\n            int[] arr = new int[size];\n            for (int i = 0; i < size; i++) arr[i] = readInt();\n            return arr;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "index": 390, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class CF915D {\n    static ArrayList[] aa;\n    static boolean[] visited, instack;\n    static int[] stack;\n    static int cnt, h_, i_, j_;\n    static boolean dfs1(int i) {\n        if (visited[i]) {\n            if (instack[i]) {\n                h_ = i;\n                return true;\n            }\n            return false;\n        }\n        visited[i] = instack[i] = true;\n        stack[cnt++] = i;\n        ArrayList<Integer> adj = aa[i];\n        for (int j : adj)\n            if (dfs1(j))\n                return true;\n        instack[i] = false;\n        cnt--;\n        return false;\n    }\n    static boolean dfs2(int i) {\n        if (visited[i])\n            return instack[i];\n        visited[i] = instack[i] = true;\n        ArrayList<Integer> adj = aa[i];\n        for (int j : adj)\n            if (!(i == i_ && j == j_) && dfs2(j))\n                return true;\n        instack[i] = false;\n        return false;\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        aa = new ArrayList[n];\n        for (int i = 0; i < n; i++)\n            aa[i] = new ArrayList<Integer>();\n        while (m-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int i = Integer.parseInt(st.nextToken()) - 1;\n            int j = Integer.parseInt(st.nextToken()) - 1;\n            aa[i].add(j);\n        }\n        visited = new boolean[n];\n        instack = new boolean[n];\n        stack = new int[n];\n        for (int i = 0; i < n; i++)\n            if (dfs1(i))\n                break;\n        if (cnt == 0) {\n            System.out.println(\"YES\");\n            return;\n        }\n        for (j_ = h_, i_ = stack[--cnt]; ; j_ = i_, i_ = stack[--cnt]) {\n            Arrays.fill(visited, false);\n            Arrays.fill(instack, false);\n            boolean cycle = false;\n            for (int i = 0; i < n; i++)\n                if (dfs2(i)) {\n                    cycle = true;\n                    break;\n                }\n            if (!cycle) {\n                System.out.println(\"YES\");\n                return;\n            }\n            if (i_ == h_)\n                break;\n        }\n        System.out.println(\"NO\");\n    }\n}\n", "src": "// discussed with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF915D {\n\tstatic ArrayList[] aa;\n\tstatic boolean[] visited, instack;\n\tstatic int[] stack;\n\tstatic int cnt, h_, i_, j_;\n\tstatic boolean dfs1(int i) {\n\t\tif (visited[i]) {\n\t\t\tif (instack[i]) {\n\t\t\t\th_ = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tvisited[i] = instack[i] = true;\n\t\tstack[cnt++] = i;\n\t\tArrayList<Integer> adj = aa[i];\n\t\tfor (int j : adj)\n\t\t\tif (dfs1(j))\n\t\t\t\treturn true;\n\t\tinstack[i] = false;\n\t\tcnt--;\n\t\treturn false;\n\t}\n\tstatic boolean dfs2(int i) {\n\t\tif (visited[i])\n\t\t\treturn instack[i];\n\t\tvisited[i] = instack[i] = true;\n\t\tArrayList<Integer> adj = aa[i];\n\t\tfor (int j : adj)\n\t\t\tif (!(i == i_ && j == j_) && dfs2(j))\n\t\t\t\treturn true;\n\t\tinstack[i] = false;\n\t\treturn false;\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint m = Integer.parseInt(st.nextToken());\n\t\taa = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = new ArrayList<Integer>();\n\t\twhile (m-- > 0) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint i = Integer.parseInt(st.nextToken()) - 1;\n\t\t\tint j = Integer.parseInt(st.nextToken()) - 1;\n\t\t\taa[i].add(j);\n\t\t}\n\t\tvisited = new boolean[n];\n\t\tinstack = new boolean[n];\n\t\tstack = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (dfs1(i))\n\t\t\t\tbreak;\n\t\tif (cnt == 0) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t\treturn;\n\t\t}\n\t\tfor (j_ = h_, i_ = stack[--cnt]; ; j_ = i_, i_ = stack[--cnt]) {\n\t\t\tArrays.fill(visited, false);\n\t\t\tArrays.fill(instack, false);\n\t\t\tboolean cycle = false;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (dfs2(i)) {\n\t\t\t\t\tcycle = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (!cycle) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (i_ == h_)\n\t\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(\"NO\");\n\t}\n}\n", "index": 392, "complexity": 5}
{"back-translation": "class GFG { static int maxSum(int arr[], int n) { int res = Integer.MIN_VALUE; for (int i = 0; i < n; i++) { int curr_sum = 0; for (int j = 0; j < n; j++) { int index = (i + j) % n; curr_sum += j * arr[index]; } res = Math.max(res, curr_sum); } return res; } public static void main(String args[]) { int arr[] = {8, 3, 1, 2}; int n = arr.length; System.out.println(maxSum(arr, n)); } }", "src": "\n// A Naive Java program to find \n// maximum sum rotation \nimport\njava.util.*; \nimport\njava.io.*; \n\nclass\nGFG { \n\n// Returns maximum value of i*arr[i] \nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n// Initialize result \nint\nres = Integer.MIN_VALUE; \n\n// Consider rotation beginning with i \n// for all possible values of i. \nfor\n(\nint\ni = \n0\n; i < n; i++) \n{ \n\n\n// Initialize sum of current rotation \n\nint\ncurr_sum = \n0\n; \n\n\n// Compute sum of all values. We don't \n\n// actually rotation the array, but compute \n\n// sum by finding ndexes when arr[i] is \n\n// first element \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nint\nindex = (i + j) % n; \n\ncurr_sum += j * arr[index]; \n\n} \n\n\n// Update result if required \n\nres = Math.max(res, curr_sum); \n} \n\nreturn\nres; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n} \n\n\n} \n\n// This code is contributed by Sahil_Bansall ", "index": 393, "complexity": 5}
{"back-translation": "class GFG { static int catalanDP(int n) { int catalan[] = new int[n + 2]; catalan[0] = 1; catalan[1] = 1; for (int i = 2; i <= n; i++) { catalan[i] = 0; for (int j = 0; j < i; j++) { catalan[i] += catalan[j] * catalan[i - j - 1]; } } return catalan[n]; } public static void main(String[] args) { for (int i = 0; i < 10; i++) { System.out.print(catalanDP(i) + \" \"); } } } ", "src": "\nclass\nGFG{ \n\n// A dynamic programming based function to find nth \n// Catalan number \n\nstatic\nint\ncatalanDP(\nint\nn) { \n\n// Table to store results of subproblems \n\nint\ncatalan[] = \nnew\nint\n[n + \n2\n]; \n\n\n// Initialize first two values in table \n\ncatalan[\n0\n] = \n1\n; \n\ncatalan[\n1\n] = \n1\n; \n\n\n// Fill entries in catalan[] using recursive formula \n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\ncatalan[i] = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < i; j++) { \n\ncatalan[i] += catalan[j] * catalan[i - j - \n1\n]; \n\n} \n\n} \n\n\n// Return last entry \n\nreturn\ncatalan[n]; \n\n} \n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalanDP(i) + \n\" \"\n); \n\n} \n\n} \n} \n// This code contributed by Rajput-Ji ", "index": 394, "complexity": 5}
{"back-translation": "class GFG { static Stack<Integer> sortStack(Stack<Integer> input) { Stack<Integer> tmpStack = new Stack<Integer>(); while (!input.empty()) { int tmp = input.peek(); input.pop(); while (!tmpStack.empty() && tmpStack.peek() < tmp) { input.push(tmpStack.peek()); tmpStack.pop(); } tmpStack.push(tmp); } return tmpStack; } static void sortArrayUsingStacks(int[] arr, int n) { Stack<Integer> input = new Stack<Integer>(); for (int i = 0; i < n; i++) input.push(arr[i]); Stack<Integer> tmpStack = sortStack(input); for (int i = 0; i < n; i++) { arr[i] = tmpStack.peek(); tmpStack.pop(); } } public static void main(String args[]) { int[] arr = { 10, 5, 15, 45 }; int n = arr.length; sortArrayUsingStacks(arr, n); for (int i = 0; i < n; i++) System.out.print(arr[i] + \" \"); } }", "src": "\n// Java program to sort an \n// array using stack \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n// This function return \n\n// the sorted stack \n\nstatic\nStack<Integer> sortStack(Stack<Integer> input) \n\n{ \n\nStack<Integer> tmpStack = \n\nnew\nStack<Integer>(); \n\n\nwhile\n(!input.empty()) \n\n{ \n\n// pop out the \n\n// first element \n\nint\ntmp = input.peek(); \n\ninput.pop(); \n\n\n// while temporary stack is \n\n// not empty and top of stack \n\n// is smaller than temp \n\nwhile\n(!tmpStack.empty() && \n\ntmpStack.peek() < tmp) \n\n{ \n\n// pop from temporary \n\n// stack and push it \n\n// to the input stack \n\ninput.push(tmpStack.peek()); \n\ntmpStack.pop(); \n\n} \n\n\n// push temp in \n\n// tempory of stack \n\ntmpStack.push(tmp); \n\n} \n\n\nreturn\ntmpStack; \n\n} \n\n\nstatic\nvoid\nsortArrayUsingStacks(\nint\n[]arr, \n\nint\nn) \n\n{ \n\n// push array elements \n\n// to stack \n\nStack<Integer> input = \n\nnew\nStack<Integer>(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ninput.push(arr[i]); \n\n\n// Sort the temporary stack \n\nStack<Integer> tmpStack = \n\nsortStack(input); \n\n\n// Put stack elements \n\n// in arrp[] \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i] = tmpStack.peek(); \n\ntmpStack.pop(); \n\n} \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n5\n, \n15\n, \n45\n}; \n\nint\nn = arr.length; \n\n\nsortArrayUsingStacks(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} \n\n// This code is contributed by \n// Manish Shaw(manishshaw1) ", "index": 396, "complexity": 5}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static final int MAXN = 1005;\n    static final long MOD = 1_000_000_007;\n    static final boolean DEBUG = false;\n    static int n, m;\n    static long[][] stlr = new long[MAXN][MAXN];\n    static long[] bell = new long[MAXN];\n    static long[] occ;\n    static PrintStream cerr = System.err;\n\n    public static void main(String[] args) {\n        Readin();\n        stlr[0][0] = bell[0] = 1;\n        for (int i = 1; i <= m; i++)\n            for (int j = 1; j <= i; j++) {\n                stlr[i][j] = (stlr[i - 1][j - 1] + stlr[i - 1][j] * (long) j) % MOD;\n                bell[i] = (bell[i] + stlr[i][j]) % MOD;\n            }\n        if (DEBUG)\n            for (int i = 1; i <= m; i++)\n                cerr.println(\"Bell[\" + i + \"] =\" + bell[i]);\n        Arrays.sort(occ);\n        if (DEBUG) {\n            cerr.println(\"After Sorting\");\n            for (int i = 0; i < m; i++)\n                cerr.println(occ[i] + \" \");\n        }\n        long ans = 1;\n        for (int i = 0, j = 0; i < m; i = j) {\n            for (j = i + 1; j < m && occ[i] == occ[j]; j++) ;\n            ans = (ans * bell[j - i]) % MOD;\n        }\n        System.out.println(ans);\n    }\n\n    static void Readin() {\n        Scanner cin;\n        if (!DEBUG) cin = new Scanner(System.in);\n        else {\n            try {\n                cin = new Scanner(new File(\"input.txt\"));\n            } catch (FileNotFoundException e) {\n                if (DEBUG) cerr.println(\"Not Fount input.txt\");\n                return;\n            }\n        }\n        m = cin.nextInt();\n        n = cin.nextInt();\n        occ = new long[m];\n        for (int i = 0; i < n; i++) {\n            String s = cin.next();\n            for (int j = 0; j < m; j++)\n                occ[j] |= ((long) (s.charAt(j) - '0')) << i;\n        }\n        cin.close();\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int MAXN= 1005;\n\tstatic final long MOD =1_000_000_007;\n\tstatic final boolean DEBUG= false;\n\tstatic int  n, m;\n\tstatic long stlr[][]= new long[MAXN][MAXN],bell[]= new long[MAXN],occ[];\n\tstatic PrintStream cerr=System.err;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tReadin();\n\t\tstlr[0][0]= bell[0] =1;\n\t\tfor (int i=1; i<=m; i++)\n\t\t\tfor (int j=1;j<=i;j++) {\n\t\t\t\tstlr[i][j]= (stlr[i-1][j-1]+stlr[i-1][j]*(long)j)%MOD;\n\t\t\t\tbell[i]= (bell[i]+stlr[i][j])%MOD;\n\t\t\t}\n\t\tif (DEBUG)\n\t\t\tfor (int i=1; i<=m; i++) cerr.println(\"Bell[\"+i+\"] =\"+bell[i]);\n\t\tArrays.sort(occ);\n\t\tif (DEBUG) {\n\t\t\tcerr.println(\"After Sorting\");\n\t\t\tfor (int i=0;i<m; i++) cerr.println(occ[i]+\" \");}\n\t\tlong ans=1;\n\t\tfor (int i=0,j=0; i<m; i=j) {\n\t\t\tfor (j=i+1; j<m && occ[i]==occ[j];j++);\n\t\t\tans= (ans*bell[j-i])%MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tstatic void Readin() {\n\t\tScanner  cin;\n\t\tif ( !DEBUG)cin= new Scanner(System.in);\n\t\telse {\n\t\t\ttry {\n\t\t\t\tcin = new Scanner(new File(\"input.txt\"));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\tif ( DEBUG)cerr.println(\"Not Fount input.txt\");\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t\tm = cin.nextInt(); n=cin.nextInt();\n\t\tocc= new long[m];\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tString s= cin.next();\n\t\t\tfor (int j=0;j <m; j++)\n\t\t\t\tocc[j]|=((long)(s.charAt(j)-'0'))<<i;\n\t\t}\n\t\tcin.close();\n\t}\n}\n", "index": 397, "complexity": 5}
{"back-translation": "import java.util.Scanner;\n\npublic class A961_Tetris {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner input = new Scanner(System.in);\n\t\tint platforms = input.nextInt();\n\t\tint in = input.nextInt();\n\t\tint[] cols = new int[platforms];\n\t\tint[] squares = new int[in];\n\t\t\n\t\tfor (int i = 0; i < in; i++) {\n\t\t\tsquares[i] = input.nextInt();\n\t\t}\n\t\t\n\t\tboolean hi = false;\n\t\tint score = 0;\n\t\t\n\t\tfor (int i = 0; i < in; i++) {\n\t\t\tcols[squares[i] - 1]++;\n\t\t\thi = checkscore(cols);\n\t\t\tif (hi) {\n\t\t\t\thi = false;\n\t\t\t\tscore++;\n\t\t\t\tfor (int j = 0; j < cols.length; j++) {\n\t\t\t\t\tcols[j]--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(score);\n\t\t\n\t}\n\t\n\tpublic static boolean checkscore(int[] cols) {\n\t\tfor (int i = 0; i < cols.length; i++) {\n\t\t\tif (cols[i] == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}\n\n}\n", "src": "import java.util.Scanner;\n\npublic class A961_Tetris {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner input = new Scanner(System.in);\n\t\tint platforms = input.nextInt();\n\t\tint in = input.nextInt();\n\t\tint[] cols = new int[platforms];\n\t\tint[] squares = new int[in];\n\t\t\n\t\tfor (int i = 0; i < in; i ++) {\n\t\t\tsquares[i] = input.nextInt();\n\t\t}\n\t\t\n\t\tboolean hi = false;\n\t\tint score = 0;\n\t\t\n\t\tfor (int i = 0; i < in; i ++) {\n\t\t\tcols[squares[i] - 1] ++;\n\t\t\thi = checkscore(cols);\n\t\t\tif (hi == true) {\n\t\t\t\thi = false;\n\t\t\t\tscore ++;\n\t\t\t\tfor (int j = 0; j < cols.length; j ++) {\n\t\t\t\t\tcols[j] --;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(score);\n\t\t\n\t}\n\t\n\tpublic static boolean checkscore(int[] cols) {\n\t\tfor (int i = 0; i < cols.length; i ++) {\n\t\t\tif (cols[i] == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}\n\n}\n", "index": 399, "complexity": 5}
{"back-translation": "import java.util.Scanner;\npublic class Tokitsukaze {\n\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        long k =sc.nextLong();\n        double[] p = new double[m];\n        for (int i = 0; i < m; i++) {\n            p[i] = sc.nextDouble();\n        }\n        int c = 0;\n        int used = 0;\n        for (int i = 0; i < m;) {\n            long low = (long) ((Math.floor(p[i] / k) * k) - i) + 1;\n            long high = low + k;\n            for (int j = i; j < m; j++) {\n                if (p[j] >= low && p[j] <= high) {\n                    i++;\n                }\n            }\n            c++;\n        }\n        System.out.println(c);\n\n    }\n    \n}\n", "src": "import java.util.Scanner;\npublic class Tokitsukaze {\n\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        long k =sc.nextLong();\n        double[]p=new double[m];\n        for(int i = 0;i<m;i++){\n            p[i]=sc.nextDouble();\n        }\n        int c=0;\n        int used=0;\n        for(int i = 0;i<m;){\n            long low=(long)((Math.floor(p[i]/k)*k)-i)+1;\n            long high=low+k;\n            for(int j=i;j<m;j++){\n                if(p[j]>=low&&p[i]<=high){\n                    i++;\n                }\n            }\n            c++;\n        }\n        System.out.println(c);\n\n    }\n    \n}\n", "index": 401, "complexity": 5}
{"back-translation": "public class PrintPost { static int preIndex = 0; void printPost(int[] in, int[] pre, int inStrt, int inEnd) { if (inStrt > inEnd) return; int inIndex = search(in, inStrt, inEnd, pre[preIndex++]); printPost(in, pre, inStrt, inIndex - 1); printPost(in, pre, inIndex + 1, inEnd); System.out.print(in[inIndex] + \" \"); } int search(int[] in, int startIn, int endIn, int data) { int i = 0; for(i = startIn; i < endIn; i++) if (in[i] == data) return i; return i; } public static void main(String ars[]) { int in[] = { 4, 2, 5, 1, 3, 6 }; int pre[] = { 1, 2, 4, 5, 3, 6 }; int len = in.length; PrintPost tree = new PrintPost(); tree.printPost(in, pre, 0, len - 1); } }", "src": "\n// Java program to print Postorder traversal from given Inorder \n// and Preorder traversals. \n\npublic\nclass\nPrintPost { \n\nstatic\nint\npreIndex = \n0\n; \n\nvoid\nprintPost(\nint\n[] in, \nint\n[] pre, \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\n; \n\n\n// Find index of next item in preorder traversal in \n\n// inorder. \n\nint\ninIndex = search(in, inStrt, inEnd, pre[preIndex++]); \n\n\n// traverse left tree \n\nprintPost(in, pre, inStrt, inIndex - \n1\n); \n\n\n// traverse right tree \n\nprintPost(in, pre, inIndex + \n1\n, inEnd); \n\n\n// print root node at the end of traversal \n\nSystem.out.print(in[inIndex] + \n\" \"\n); \n\n} \n\n\nint\nsearch(\nint\n[] in, \nint\nstartIn, \nint\nendIn, \nint\ndata) \n\n{ \n\nint\ni = \n0\n; \n\nfor\n(i = startIn; i < endIn; i++) \n\nif\n(in[i] == data) \n\nreturn\ni; \n\nreturn\ni; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String ars[]) \n\n{ \n\nint\nin[] = { \n4\n, \n2\n, \n5\n, \n1\n, \n3\n, \n6\n}; \n\nint\npre[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n3\n, \n6\n}; \n\nint\nlen = in.length; \n\nPrintPost tree = \nnew\nPrintPost(); \n\ntree.printPost(in, pre, \n0\n, len - \n1\n); \n\n} \n} ", "index": 402, "complexity": 5}
{"back-translation": "import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStream;import java.io.OutputStreamWriter;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.Locale;import java.util.Map.Entry;import java.util.Random;import java.util.Scanner;import java.util.TreeSet;public final class CF_573_D1_A {static boolean verb=true;static void log(Object X){if (verb) System.err.println(X);}static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}static void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+\" \");System.err.println(\"\");}}static void log(long[] X){if (verb) {for (long U:X) System.err.print(U+\" \");System.err.println(\"\");}}static void logWln(Object X){if (verb) System.err.print(X);}static void info(Object o){System.out.println(o);}static void output(Object o){outputWln(\"\")+o+\"\\n\";}static void outputWln(Object o){try {out.write(\"\")+ o);} catch (Exception e) {}}static long mod=998244353;static int CX=64;static BufferedWriter out;static InputReader reader;static void process() throws Exception {Locale.setDefault(Locale.US);out = new BufferedWriter(new OutputStreamWriter(System.out));reader = new InputReader(System.in);long n=reader.readLong();int m=reader.readInt();long k=reader.readLong();long[] p=new long[m];for (int i=0;i<m;i++) p[i]=reader.readLong()-1;int pid=-1;int rem=m;int win=0;long mx=k-1;int res=0;int idx=0;while (rem>0) {while (p[idx]>mx) {mx+=k;if (mx>=n-1)mx=n-1;}int nxt=idx;while (nxt+1<m && p[nxt+1]<=mx)nxt++;int nb=nxt-idx+1;rem-=nb;mx+=nb;idx=nxt+1;res++;}output(res);try {out.close();} catch (Exception E) {}}public static void main(String[] args) throws Exception {process();}static final class InputReader {private final InputStream stream;private final byte[] buf=new byte[1024];private int curChar;private int numChars;public InputReader(InputStream stream){this.stream=stream;}private int read() throws IOException {if (curChar>=numChars) {curChar=0;numChars=stream.read(buf);if (numChars<=0)return -1;}return buf[curChar++];}public final String readString() throws IOException {int c=read();while (isSpaceChar(c)){c=read();}StringBuilder res=new StringBuilder();do {res.append((char) c);c=read();} while (!isSpaceChar(c));return res.toString();}public final int readInt() throws IOException {int c=read();boolean neg=false;while (isSpaceChar(c)) {c=read();}char d=(char) c;if (d==\"){neg=true;c=read();}int res=0;do {res*=10;res+=c-'0';c=read();} while (!isSpaceChar(c));if (neg)return -res;return res;}public final long readLong() throws IOException {int c=read();boolean neg=false;while (isSpaceChar(c)){c=read();}char d=(char) c;if (d==\"){neg=true;c=read();}long res=0;do {res*=10;res+=c-'0';c=read();} while (!isSpaceChar(c));if (neg)return -res;return res;}private boolean isSpaceChar(int c) {return c==' ' || c=='\\n' || c=='\\r' || c=='\\t' || c==-1;}}}", "src": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map.Entry;\n\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic final class CF_573_D1_A {\n\n\n\tstatic boolean verb=true;\n\tstatic void log(Object X){if (verb) System.err.println(X);}\n\tstatic void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+\" \");System.err.println(\"\");}}\n\tstatic void log(long[] X){if (verb) {for (long U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\n\tstatic void logWln(Object X){if (verb) System.err.print(X);}\n\tstatic void info(Object o){\tSystem.out.println(o);}\n\tstatic void output(Object o){outputWln(\"\"+o+\"\\n\");\t}\n\tstatic void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n\n\t//static long mod=1000000007;\n\tstatic long mod=998244353 ; \n\tstatic int CX=64;\n\n\n\t// Global vars\n\tstatic BufferedWriter out;\n\tstatic InputReader reader;\n\n\n\t\n\n\tstatic void process() throws Exception {\n\n\t\tLocale.setDefault(Locale.US);\n\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\treader = new InputReader(System.in);\n\n\t\tlong n=reader.readLong();\n\t\tint m=reader.readInt();\n\t\t\n\t\tlong k=reader.readLong();\n\t\tlong[] p=new long[m];\n\t\tfor (int i=0;i<m;i++)\n\t\t\tp[i]=reader.readLong()-1;\n\t\t\n\t\tint pid=-1;\n\t\tint rem=m;\n\t\tint win=0; // current window\n\t\tlong mx=k-1; // max value of window\n\t\tint res=0;\n\t\tint idx=0;\n\t\t\n\t\twhile (rem>0) {\n\t\t\t//log(\"======\");\n\t\t\twhile (p[idx]>mx) {\n\t\t\t\tmx+=k;\n\t\t\t\tif (mx>=n-1)\n\t\t\t\t\tmx=n-1;\n\t\t\t\t//log(\"mx:\"+mx);\n\t\t\t}\n\t\t\n\t\t\tint nxt=idx;\n\t\t\twhile (nxt+1<m && p[nxt+1]<=mx)\n\t\t\t\tnxt++;\n\t\t\tint nb=nxt-idx+1;\n\t\t\trem-=nb;\n\t\t\tmx+=nb;\n\t\t\tidx=nxt+1;\n\t\t\tres++;\n\t\t}\n\t\toutput(res);\n\n\t\n\t\ttry {\n\t\t\tout.close();\n\t\t} catch (Exception E) {\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tprocess();\n\n\t}\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t// log(\"d:\"+d);\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t// log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t// log(\"d:\"+d);\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t// log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n}", "index": 403, "complexity": 5}
{"back-translation": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class TaxiDriversAndLyft {\n    \n    static class Resident{\n        Integer index;\n        Integer type;\n        Integer requests;\n        \n        public Resident(int index, int type) {\n            this.index = index;\n            this.type = type;\n            this.requests = 0;\n        }\n        \n        @Override\n        public String toString() {\n            if(type == 0) {\n                return \"Rider at index : \" + index;\n            }\n            else {\n                return \"Driver at index : \" + index + \", Requests: \" + requests;\n            }\n        }\n    }\n    \n    static ArrayList<Resident> residents;\n    static ArrayList<Integer> drivers_indexes = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Scanner reader = new Scanner(System.in);\n        int n = reader.nextInt();\n        int m = reader.nextInt();\n        int length = n + m;\n        \n        int [] coordinates = new int[length];\n        int [] types = new int[length];\n        residents = new ArrayList<>();\n        drivers_indexes = new ArrayList<>();\n        \n        for (int i = 0; i < length; i++) {\n            coordinates[i] = reader.nextInt();\n        }\n        \n        for (int i = 0; i < length; i++) {\n            types[i] = reader.nextInt();\n            \n            if(types[i] == 1)\n                drivers_indexes.add(i);\n            \n            residents.add(new Resident(i, types[i]));\n        }\n        reader.close();    \n        \n        for (int i = 0; i < length; i++) {\n            Resident current = residents.get(i);\n            if(current.type == 0) {\n                int left = i-1, right = i+1;\n                        \n                while(left >= 0 || right < length) {\n                    if(left >= 0 && residents.get(left).type == 1) {\n                        residents.get(left).requests++;\n                        break;\n                    }\n                    else if(right < length && residents.get(right).type == 1) {\n                        residents.get(right).requests++;\n                        break;\n                    }\n                    \n                    left--;\n                    right++;\n                }\n            }\n        }\n        \n        for(int index : drivers_indexes) {\n            System.out.print(residents.get(index).requests + \" \");\n        }\n    }\n\n}", "src": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class TaxiDriversAndLyft {\n\t\n\tstatic class Resident{\n\t\tInteger index;\t\t\t// For all residents\n\t\tInteger type;\t\t\t// 1 if driver & 0 for rider\n\t\tInteger requests;\t\t// Only for drivers\n\t\t\n\t\tpublic Resident(int index, int type) {\n\t\t\tthis.index = index;\n\t\t\tthis.type = type;\n\t\t\tthis.requests = 0;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif(type == 0) {\n\t\t\t\treturn \"Rider at index : \" + index;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"Driver at index : \" + index + \", Requests: \" + requests;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Resident> residents;\n\tstatic ArrayList<Integer> drivers_indexes = new ArrayList<>();\n\n\tpublic static void main(String[] args) {\n\t\tScanner reader = new Scanner(System.in);\n\t\tint n = reader.nextInt();\n\t\tint m = reader.nextInt();\n\t\tint length = n + m;\n\t\t\n\t\tint [] coordinates = new int[length];\n\t\tint [] types = new int[length];\n\t\tresidents = new ArrayList<>();\n\t\tdrivers_indexes = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tcoordinates[i] = reader.nextInt();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\ttypes[i] = reader.nextInt();\n\t\t\t\n\t\t\tif(types[i] == 1)\n\t\t\t\tdrivers_indexes.add(i);\n\t\t\t\t\n\t\t\tresidents.add(new Resident(i, types[i]));\n\t\t}\n\t\treader.close();\t\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tResident current = residents.get(i);\n\t\t\tif(current.type == 0) {\n\t\t\t\tint left = i-1, right = i+1;\n\t\t\t\t\t\t\t\t\n\t\t\t\twhile(left >= 0 || right < length) {\n\t\t\t\t\tif(left >= 0 && residents.get(left).type == 1) {\n\t\t\t\t\t\tresidents.get(left).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(right < length && residents.get(right).type == 1) {\n\t\t\t\t\t\tresidents.get(right).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tleft--;\n\t\t\t\t\tright++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int index : drivers_indexes) {\n\t\t\tSystem.out.print(residents.get(index).requests + \" \");\n\t\t}\n\t}\n\n}\n", "index": 404, "complexity": 5}
{"back-translation": "class EquilibriumIndex { int equilibrium(int arr[], int n) { int i, j; int leftsum, rightsum; for (i = 0; i < n; i++) { leftsum = 0; for (j = 0; j < i; j++) leftsum += arr[j]; rightsum = 0; for (j = i + 1; j < n; j++) rightsum += arr[j]; if (leftsum == rightsum) return i; } return -1; } public static void main(String[] args) { EquilibriumIndex equi = new EquilibriumIndex(); int arr[] = { -7, 1, 5, 2, -4, 3, 0 }; int arr_size = arr.length; System.out.println(equi.equilibrium(arr, arr_size)); } }", "src": "\n// Java program to find equilibrium \n// index of an array \n\nclass\nEquilibriumIndex { \n\nint\nequilibrium(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\nleftsum, rightsum; \n\n\n/* Check for indexes one by one until \n\nan equilibrium index is found */\n\nfor\n(i = \n0\n; i < n; ++i) { \n\n\n/* get left sum */\n\nleftsum = \n0\n; \n\nfor\n(j = \n0\n; j < i; j++) \n\nleftsum += arr[j]; \n\n\n/* get right sum */\n\nrightsum = \n0\n; \n\nfor\n(j = i + \n1\n; j < n; j++) \n\nrightsum += arr[j]; \n\n\n/* if leftsum and rightsum are same, \n\nthen we are done */\n\nif\n(leftsum == rightsum) \n\nreturn\ni; \n\n} \n\n\n/* return -1 if no equilibrium index is found */\n\nreturn\n-\n1\n; \n\n} \n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nEquilibriumIndex equi = \nnew\nEquilibriumIndex(); \n\nint\narr[] = { -\n7\n, \n1\n, \n5\n, \n2\n, -\n4\n, \n3\n, \n0\n}; \n\nint\narr_size = arr.length; \n\nSystem.out.println(equi.equilibrium(arr, arr_size)); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 405, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class MainG {\n    static StdIn in = new StdIn();\n    static PrintWriter out = new PrintWriter(System.out);\n    static long M=(long)1e9+7;\n    \n    public static void main(String[] args) {\n        char[] cs = in.next().toCharArray();\n        int n=cs.length;\n        int[] x = new int[n];\n        for(int i=0; i<n; ++i)\n            x[i]=cs[i]-'0';\n        long[] dp1 = new long[n+1];\n        for(int i=0; i<n; ++i) \n            dp1[i+1]=(x[i]+dp1[i]*10)%M;\n        long ans=0;\n        for(int d1=1; d1<=9; ++d1) {\n            long[][] dp2 = new long[2][n+1];\n            for(int i=0; i<n; ++i) {\n                dp2[0][i+1]=x[i]>=d1?(10*dp2[0][i]+1)%M:dp2[0][i];\n                for(int d2=0; d2<x[i]; ++d2)\n                    dp2[1][i+1]=((d2>=d1?10*(dp2[0][i]+dp2[1][i])+dp1[i]+1:dp2[0][i]+dp2[1][i])+dp2[1][i+1])%M;\n                for(int d2=x[i]; d2<=9; ++d2)\n                    dp2[1][i+1]=((d2>=d1?10*dp2[1][i]+dp1[i]:dp2[1][i])+dp2[1][i+1])%M;\n            }\n            ans+=dp2[0][n]+dp2[1][n];\n        }\n        out.println(ans%M);\n        out.close();\n    }\n    \n    interface Input {\n        public String next();\n        public String nextLine();\n        public int nextInt();\n        public long nextLong();\n        public double nextDouble();\n    }\n    static class StdIn implements Input {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n        public StdIn() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n        public StdIn(InputStream in) {\n            try{\n                din = new DataInputStream(in);\n            } catch(Exception e) {\n                throw new RuntimeException();\n            }\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n        public String next() {\n            int c;\n            while((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n            StringBuilder s = new StringBuilder();\n            while (c != -1)\n            {\n                if (c == ' ' || c == '\\n'||c=='\\r')\n                    break;\n                s.append((char)c);\n                c=read();\n            }\n            return s.toString();\n        }\n        public String nextLine() {\n            int c;\n            while((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n            StringBuilder s = new StringBuilder();\n            while (c != -1)\n            {\n                if (c == '\\n'||c=='\\r')\n                    break;\n                s.append((char)c);\n                c = read();\n            }\n            return s.toString();\n        }\n        public int nextInt() {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n                ret = ret * 10 + c - '0';\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n        public int[] readIntArray(int n) {\n            int[] ar = new int[n];\n            for(int i=0; i<n; ++i)\n                ar[i]=nextInt();\n            return ar;\n        }\n        public long nextLong() {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n                ret = ret * 10 + c - '0';\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n        public long[] readLongArray(int n) {\n            long[] ar = new long[n];\n            for(int i=0; i<n; ++i)\n                ar[i]=nextLong();\n            return ar;\n        }\n        public double nextDouble() {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n                ret = ret * 10 + c - '0';\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.')\n                while ((c = read()) >= '0' && c <= '9')\n                    ret += (c - '0') / (div *= 10);\n            if (neg)\n                return -ret;\n            return ret;\n        }\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n        private byte read() {\n            try{\n                if (bufferPointer == bytesRead)\n                    fillBuffer();\n                return buffer[bufferPointer++];\n            } catch(IOException e) {\n                throw new RuntimeException();\n            }\n        }\n        public void close() throws IOException {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class MainG {\n\tstatic StdIn in = new StdIn();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic long M=(long)1e9+7;\n\t\n\tpublic static void main(String[] args) {\n\t\tchar[] cs = in.next().toCharArray();\n\t\tint n=cs.length;\n\t\tint[] x = new int[n];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tx[i]=cs[i]-'0';\n\t\tlong[] dp1 = new long[n+1];\n\t\tfor(int i=0; i<n; ++i) \n\t\t\tdp1[i+1]=(x[i]+dp1[i]*10)%M;\n\t\tlong ans=0;\n\t\tfor(int d1=1; d1<=9; ++d1) {\n\t\t\tlong[][] dp2 = new long[2][n+1];\n\t\t\tfor(int i=0; i<n; ++i) {\n\t\t\t\tdp2[0][i+1]=x[i]>=d1?(10*dp2[0][i]+1)%M:dp2[0][i];\n\t\t\t\tfor(int d2=0; d2<x[i]; ++d2)\n\t\t\t\t\tdp2[1][i+1]=((d2>=d1?10*(dp2[0][i]+dp2[1][i])+dp1[i]+1:dp2[0][i]+dp2[1][i])+dp2[1][i+1])%M;\n\t\t\t\tfor(int d2=x[i]; d2<=9; ++d2)\n\t\t\t\t\tdp2[1][i+1]=((d2>=d1?10*dp2[1][i]+dp1[i]:dp2[1][i])+dp2[1][i+1])%M;\n\t\t\t}\n\t\t\tans+=dp2[0][n]+dp2[1][n];\n\t\t}\n\t\tout.println(ans%M);\n\t\tout.close();\n\t}\n\t\n\tinterface Input {\n\t\tpublic String next();\n\t\tpublic String nextLine();\n\t\tpublic int nextInt();\n\t\tpublic long nextLong();\n\t\tpublic double nextDouble();\n\t}\n\tstatic class StdIn implements Input {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\t\tpublic StdIn() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic StdIn(InputStream in) {\n\t\t\ttry{\n\t\t\t\tdin = new DataInputStream(in);\n\t\t\t} catch(Exception e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic String next() {\n\t\t\tint c;\n\t\t\twhile((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\twhile (c != -1)\n\t\t\t{\n\t\t\t\tif (c == ' ' || c == '\\n'||c=='\\r')\n\t\t\t\t\tbreak;\n\t\t\t\ts.append((char)c);\n\t\t\t\tc=read();\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\tint c;\n\t\t\twhile((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\twhile (c != -1)\n\t\t\t{\n\t\t\t\tif (c == '\\n'||c=='\\r')\n\t\t\t\t\tbreak;\n\t\t\t\ts.append((char)c);\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic int[] readIntArray(int n) {\n\t\t\tint[] ar = new int[n];\n\t\t\tfor(int i=0; i<n; ++i)\n\t\t\t\tar[i]=nextInt();\n\t\t\treturn ar;\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic long[] readLongArray(int n) {\n\t\t\tlong[] ar = new long[n];\n\t\t\tfor(int i=0; i<n; ++i)\n\t\t\t\tar[i]=nextLong();\n\t\t\treturn ar;\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\t\t\tif (c == '.')\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9')\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\t\tprivate byte read() {\n\t\t\ttry{\n\t\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\t\tfillBuffer();\n\t\t\t\treturn buffer[bufferPointer++];\n\t\t\t} catch(IOException e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\t}\n}", "index": 406, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n\npublic class q4 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));\n        \n        int query = in.nextInt();\n        \n        while (query-- > 0) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            \n            char[] arr = new char[n];\n            //slot all n into char array\n            String code = in.next();\n            for (int i = 0; i < n; i++) {\n                arr[i] = code.charAt(i);\n                \n            }\n            \n            //R, G, B cycle\n            int r = 0;\n            int g = 0;\n            int b = 0;\n            \n            for (int i = 0; i < k; i++) {\n                if (i % 3 == 0) {\n                    if (arr[i] == 'R') {g++; b++;}\n                    else if (arr[i] == 'G') {r++; b++;}\n                    else {r++; g++;} //if is 'B'\n                } else if (i % 3 == 1) {\n                    if (arr[i] == 'G') {g++; b++;}\n                    else if (arr[i] == 'B') {r++; b++;}\n                    else {r++; g++;} //if is 'R'\n                } else { //if mod 3 is 2\n                    if (arr[i] == 'B') {g++; b++;}\n                    else if (arr[i] == 'R') {r++; b++;}\n                    else {r++; g++;} //if is 'G'     \n                }\n            }\n            \n            //starting from kth position, if different then add 1, and check (j-k)th position\n            int rMin = r;\n            int gMin = g;\n            int bMin = b;\n            for (int j = k; j < n; j++) {\n                //R cycle\n                if ((j % 3 == 0 && arr[j] != 'R') ||  \n                    (j % 3 == 1 && arr[j] != 'G') ||\n                    (j % 3 == 2 && arr[j] != 'B')) {\n                    r++;\n                }\n                //R cycle \n                if (((j - k) % 3 == 0 && arr[j - k] != 'R') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'G') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'B')) {\n                    r--;\n                }\n                rMin = Math.min(r, rMin);\n                //G cycle\n                if ((j % 3 == 0 && arr[j] != 'G') ||  \n                    (j % 3 == 1 && arr[j] != 'B') ||\n                    (j % 3 == 2 && arr[j] != 'R')) {\n                    g++;\n                } \n                if (((j - k) % 3 == 0 && arr[j - k] != 'G') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'B') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'R')) {\n                    g--;\n                }      \n                gMin = Math.min(gMin, g);\n                //B cycle\n                if ((j % 3 == 0 && arr[j] != 'B') ||  \n                    (j % 3 == 1 && arr[j] != 'R') ||\n                    (j % 3 == 2 && arr[j] != 'G')) {\n                    b++;\n                }       \n                if (((j - k) % 3 == 0 && arr[j - k] != 'B') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'R') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'G')) {\n                    b--;\n                } \n                bMin = Math.min(bMin, b);\n                \n            }\n            \n            out.println(Math.min(Math.min(rMin, gMin), bMin));\n            \n        }\n        out.flush();\n        \n    } \n    \n}", "src": "//q4\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n\npublic class q4 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));\n        \n        int query = in.nextInt();\n        \n        while (query -- > 0) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            \n            char[] arr = new char[n];\n            //slot all n into char array\n            String code = in.next();\n            for (int i = 0; i < n; i++) {\n                arr[i] = code.charAt(i);\n                \n            }\n            \n            //R, G, B cycle\n            int r = 0;\n            int g = 0;\n            int b = 0;\n            \n            for (int i = 0; i < k; i++) {\n                if (i % 3 == 0) {\n                    if (arr[i] == 'R') {g++; b++;}\n                    else if (arr[i] == 'G') {r++; b++;}\n                    else {r++; g++;} //if is 'B'\n                } else if (i % 3 == 1) {\n                    if (arr[i] == 'G') {g++; b++;}\n                    else if (arr[i] == 'B') {r++; b++;}\n                    else {r++; g++;} //if is 'R'\n                } else { //if mod 3 is 2\n                    if (arr[i] == 'B') {g++; b++;}\n                    else if (arr[i] == 'R') {r++; b++;}\n                    else {r++; g++;} //if is 'G'     \n                }\n            }\n            \n            //starting from kth position, if different then add 1, and check (j-k)th position\n            int rMin = r;\n            int gMin = g;\n            int bMin = b;\n            for (int j = k; j < n; j++) {\n                //R cycle\n                if ((j % 3 == 0 && arr[j] != 'R') ||  \n                    (j % 3 == 1 && arr[j] != 'G') ||\n                    (j % 3 == 2 && arr[j] != 'B')) {\n                    r++;\n                }\n                //R cycle \n                if (((j - k) % 3 == 0 && arr[j - k] != 'R') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'G') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'B')) {\n                    r--;\n                }\n                rMin = Math.min(r, rMin);\n                //G cycle\n                if ((j % 3 == 0 && arr[j] != 'G') ||  \n                    (j % 3 == 1 && arr[j] != 'B') ||\n                    (j % 3 == 2 && arr[j] != 'R')) {\n                    g++;\n                } \n                if (((j - k) % 3 == 0 && arr[j - k] != 'G') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'B') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'R')) {\n                    g--;\n                }      \n                gMin = Math.min(gMin, g);\n                //B cycle\n                if ((j % 3 == 0 && arr[j] != 'B') ||  \n                    (j % 3 == 1 && arr[j] != 'R') ||\n                    (j % 3 == 2 && arr[j] != 'G')) {\n                    b++;\n                }       \n                if (((j - k) % 3 == 0 && arr[j - k] != 'B') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'R') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'G')) {\n                    b--;\n                } \n                bMin = Math.min(bMin, b);\n                \n            }\n            \n            out.println(Math.min(Math.min(rMin, gMin), bMin));\n            \n        }\n        out.flush();\n        \n    } \n    \n}", "index": 407, "complexity": 5}
{"back-translation": "class MinimumCostPath { private static int min(int x, int y, int z) { if (x < y) return (x < z)? x : z; else return (y < z)? y : z; } private static int minCost(int[][] cost, int m, int n) { int i, j; int[][] tc= new int[m+1][n+1]; tc[0][0] = cost[0][0]; for (i = 1; i <= m; i++) tc[i][0] = tc[i-1][0] + cost[i][0]; for (j = 1; j <= n; j++) tc[0][j] = tc[0][j-1] + cost[0][j]; for (i = 1; i <= m; i++) for (j = 1; j <= n; j++) tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]; return tc[m][n]; } public static void main(String args[]) { int cost[][]= {{1, 2, 3}, {4, 8, 2}, {1, 5, 3}}; System.out.println(minCost(cost, 2, 2)); } }", "src": "\n/* Java program for Dynamic Programming implementation \n\nof Min Cost Path problem */\nimport\njava.util.*; \n\nclass\nMinimumCostPath \n{ \n\n/* A utility function that returns minimum of 3 integers */\n\nprivate\nstatic\nint\nmin(\nint\nx, \nint\ny, \nint\nz) \n\n{ \n\nif\n(x < y) \n\nreturn\n(x < z)? x : z; \n\nelse\n\nreturn\n(y < z)? y : z; \n\n} \n\n\nprivate\nstatic\nint\nminCost(\nint\ncost[][], \nint\nm, \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\ntc[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\ntc[\n0\n][\n0\n] = cost[\n0\n][\n0\n]; \n\n\n/* Initialize first column of total cost(tc) array */\n\nfor\n(i = \n1\n; i <= m; i++) \n\ntc[i][\n0\n] = tc[i-\n1\n][\n0\n] + cost[i][\n0\n]; \n\n\n/* Initialize first row of tc array */\n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[\n0\n][j] = tc[\n0\n][j-\n1\n] + cost[\n0\n][j]; \n\n\n/* Construct rest of the tc array */\n\nfor\n(i = \n1\n; i <= m; i++) \n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[i][j] = min(tc[i-\n1\n][j-\n1\n], \n\ntc[i-\n1\n][j], \n\ntc[i][j-\n1\n]) + cost[i][j]; \n\n\nreturn\ntc[m][n]; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\ncost[][]= {{\n1\n, \n2\n, \n3\n}, \n\n{\n4\n, \n8\n, \n2\n}, \n\n{\n1\n, \n5\n, \n3\n}}; \n\nSystem.out.println(minCost(cost,\n2\n,\n2\n)); \n\n} \n} \n// This code is contributed by Pankaj Kumar ", "index": 408, "complexity": 5}
{"back-translation": "class GFG {\n    static final int N = 3;\n\n    static int getMin(int arr[]) {\n        int minInd = 0;\n        for (int i = 1; i < N; i++)\n            if (arr[i] < arr[minInd])\n                minInd = i;\n        return minInd;\n    }\n\n    static int getMax(int arr[]) {\n        int maxInd = 0;\n        for (int i = 1; i < N; i++)\n            if (arr[i] > arr[maxInd])\n                maxInd = i;\n        return maxInd;\n    }\n\n    static int minOf2(int x, int y) {\n        return (x < y) ? x : y;\n    }\n\n    static void minCashFlowRec(int amount[]) {\n        int mxCredit = getMax(amount), mxDebit = getMin(amount);\n        if (amount[mxCredit] == 0 && amount[mxDebit] == 0)\n            return;\n        int min = minOf2(-amount[mxDebit], amount[mxCredit]);\n        amount[mxCredit] -= min;\n        amount[mxDebit] += min;\n        System.out.println(\"Person \" + mxDebit + \" pays \" + min + \" to \" + \"Person \" + mxCredit);\n        minCashFlowRec(amount);\n    }\n\n    static void minCashFlow(int graph[][]) {\n        int amount[] = new int[N];\n        for (int p = 0; p < N; p++)\n            for (int i = 0; i < N; i++)\n                amount[p] += (graph[i][p] - graph[p][i]);\n        minCashFlowRec(amount);\n    }\n\n    public static void main(String[] args) {\n        int graph[][] = {{0, 1000, 2000}, {0, 0, 5000}, {0, 0, 0}};\n        minCashFlow(graph);\n    }\n}", "src": "\n// Java program to fin maximum cash \n// flow among a set of persons \n\nclass\nGFG \n{ \n\n// Number of persons (or vertices in the graph) \n\nstatic\nfinal\nint\nN = \n3\n; \n\n\n// A utility function that returns \n\n// index of minimum value in arr[] \n\nstatic\nint\ngetMin(\nint\narr[]) \n\n{ \n\nint\nminInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] < arr[minInd]) \n\nminInd = i; \n\nreturn\nminInd; \n\n} \n\n\n// A utility function that returns \n\n// index of maximum value in arr[] \n\nstatic\nint\ngetMax(\nint\narr[]) \n\n{ \n\nint\nmaxInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] > arr[maxInd]) \n\nmaxInd = i; \n\nreturn\nmaxInd; \n\n} \n\n\n// A utility function to return minimum of 2 values \n\nstatic\nint\nminOf2(\nint\nx, \nint\ny) \n\n{ \n\nreturn\n(x < y) ? x: y; \n\n} \n\n\n// amount[p] indicates the net amount \n\n// to be credited/debited to/from person 'p' \n\n// If amount[p] is positive, then \n\n// i'th person will amount[i] \n\n// If amount[p] is negative, then \n\n// i'th person will give -amount[i] \n\nstatic\nvoid\nminCashFlowRec(\nint\namount[]) \n\n{ \n\n// Find the indexes of minimum and \n\n// maximum values in amount[] \n\n// amount[mxCredit] indicates the maximum amount \n\n// to be given (or credited) to any person . \n\n// And amount[mxDebit] indicates the maximum amount \n\n// to be taken(or debited) from any person. \n\n// So if there is a positive value in amount[], \n\n// then there must be a negative value \n\nint\nmxCredit = getMax(amount), mxDebit = getMin(amount); \n\n\n// If both amounts are 0, then \n\n// all amounts are settled \n\nif\n(amount[mxCredit] == \n0\n&& amount[mxDebit] == \n0\n) \n\nreturn\n; \n\n\n// Find the minimum of two amounts \n\nint\nmin = minOf2(-amount[mxDebit], amount[mxCredit]); \n\namount[mxCredit] -= min; \n\namount[mxDebit] += min; \n\n\n// If minimum is the maximum amount to be \n\nSystem.out.println(\n\"Person \"\n+ mxDebit + \n\" pays \"\n+ min \n\n+ \n\" to \"\n+ \n\"Person \"\n+ mxCredit); \n\n\n// Recur for the amount array. \n\n// Note that it is guaranteed that \n\n// the recursion would terminate \n\n// as either amount[mxCredit] or \n\n// amount[mxDebit] becomes 0 \n\nminCashFlowRec(amount); \n\n} \n\n\n// Given a set of persons as graph[] \n\n// where graph[i][j] indicates \n\n// the amount that person i needs to \n\n// pay person j, this function \n\n// finds and prints the minimum \n\n// cash flow to settle all debts. \n\nstatic\nvoid\nminCashFlow(\nint\ngraph[][]) \n\n{ \n\n// Create an array amount[], \n\n// initialize all value in it as 0. \n\nint\namount[]=\nnew\nint\n[N]; \n\n\n// Calculate the net amount to \n\n// be paid to person 'p', and \n\n// stores it in amount[p]. The \n\n// value of amount[p] can be \n\n// calculated by subtracting \n\n// debts of 'p' from credits of 'p' \n\nfor\n(\nint\np = \n0\n; p < N; p++) \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\namount[p] += (graph[i][p] - graph[p][i]); \n\n\nminCashFlowRec(amount); \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n// graph[i][j] indicates the amount \n\n// that person i needs to pay person j \n\nint\ngraph[][] = { {\n0\n, \n1000\n, \n2000\n}, \n\n{\n0\n, \n0\n, \n5000\n}, \n\n{\n0\n, \n0\n, \n0\n},}; \n\n\n// Print the solution \n\nminCashFlow(graph); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "index": 409, "complexity": 5}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class LogicalExpression {\n    \n    static final int N = 256;\n    \n    static void solve() {\n        Expression[] E = new Expression[N];\n        for (int i = 0; i < N; i++) {\n            E[i] = new Expression();\n        }\n        \n        Expression newExpression1 = new Expression(\"x\", null, null);\n        Expression newExpression2 = new Expression(\"y\", null, null);\n        Expression newExpression3 = new Expression(\"z\", null, null);\n        E[Integer.parseInt(\"00001111\", 2)].update_f(newExpression1.f);\n        E[Integer.parseInt(\"00110011\", 2)].update_f(newExpression2.f);\n        E[Integer.parseInt(\"01010101\", 2)].update_f(newExpression3.f);\n        \n        for (int l = 2; l < 40; l++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (E[i].e != null && E[j].t != null && E[i].e.length() + E[j].t.length() + 1 == l) {\n                        E[i | j].update_e(E[i].e + '|' + E[j].t);\n                    }\n                    if (E[i].t != null && E[j].f != null && E[i].t.length() + E[j].f.length() + 1 == l) {\n                        E[i & j].update_t(E[i].t + '&' + E[j].f);\n                    }\n                }\n                if (E[i].f != null) {\n                    E[i ^ (N - 1)].update_f('!' + E[i].f);\n                }\n            }\n        }\n        \n        String[] res = new String[N];\n        for (int i = 0; i < N; i++) {\n            res[i] = E[i].calc_best();\n        }\n        \n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int x = Integer.parseInt(in.nextToken(), 2);\n            out.println(res[x]);\n        }\n    }\n    \n    static class Expression {\n        String e, t, f;\n        \n        Expression() {\n        }\n        \n        Expression(String e, String t, String f) {\n            this.e = e;\n            this.t = t;\n            this.f = f;\n        }\n        \n        String calc_best() {\n            String best = e;\n            if (compare(best, t) > 0) {\n                best = t;\n            }\n            if (compare(best, f) > 0) {\n                best = f;\n            }\n            return best;\n        }\n        \n        void update_e(String ne) {\n            if (e == null || compare(e, ne) > 0) {\n                e = ne;\n                update_f('(' + e + ')');\n            }\n        }\n        \n        void update_t(String nt) {\n            if (t == null || compare(t, nt) > 0) {\n                t = nt;\n                update_e(t);\n            }\n        }\n        \n        void update_f(String nf) {\n            if (f == null || compare(f, nf) > 0) {\n                f = nf;\n                update_t(f);\n            }\n        }\n        \n        int compare(String a, String b) {\n            if (a.length() != b.length()) {\n                return Integer.compare(a.length(), b.length());\n            }\n            return a.compareTo(b);\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        LogicalExpression.solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class LogicalExpression {\n    \n    int N = 256;\n    \n    void solve() {\n        Expression[] E = new Expression[N];\n        for (int i = 0; i < N; i++) E[i] = new Expression();\n        \n        E[Integer.parseInt(\"00001111\", 2)].update_f(\"x\");\n        E[Integer.parseInt(\"00110011\", 2)].update_f(\"y\");\n        E[Integer.parseInt(\"01010101\", 2)].update_f(\"z\");\n        \n        for (int l = 2; l < 40; l++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (E[i].e != null && E[j].t != null && E[i].e.length() + E[j].t.length() + 1 == l) {\n                        E[i | j].update_e(E[i].e + '|' + E[j].t);\n                    }\n                    if (E[i].t != null && E[j].f != null && E[i].t.length() + E[j].f.length() + 1 == l) {\n                        E[i & j].update_t(E[i].t + '&' + E[j].f);\n                    }\n                }\n                if (E[i].f != null) E[i ^ (N - 1)].update_f('!' + E[i].f);\n            }\n        }\n        \n        String[] res = new String[N];\n        for (int i = 0; i < N; i++) res[i] = E[i].calc_best();\n        \n        int n = in.nextInt();\n        for (int i = 0; i < n; i++) {\n            int x = Integer.parseInt(in.nextToken(), 2);\n            out.println(res[x]);\n        }\n    }\n    \n    static class Expression {\n        String e, t, f;\n        \n        Expression() {\n        }\n        \n        public Expression(String e, String t, String f) {\n            this.e = e;\n            this.t = t;\n            this.f = f;\n        }\n        \n        String calc_best() {\n            String best = e;\n            if (compare(best, t) > 0) best = t;\n            if (compare(best, f) > 0) best = f;\n            return best;\n        }\n        \n        void update_e(String ne) {\n            if (e == null || compare(e, ne) > 0) {\n                e = ne;\n                update_f('(' + e + ')');\n            }\n        }\n        \n        void update_t(String nt) {\n            if (t == null || compare(t, nt) > 0) {\n                t = nt;\n                update_e(t);\n            }\n        }\n        \n        void update_f(String nf) {\n            if (f == null || compare(f, nf) > 0) {\n                f = nf;\n                update_t(f);\n            }\n        }\n        \n        int compare(String a, String b) {\n            if (a.length() != b.length()) return Integer.compare(a.length(), b.length());\n            return a.compareTo(b);\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new LogicalExpression().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "index": 410, "complexity": 5}
{"back-translation": "class Node { int data; Node left, right; public Node(int data) { this.data = data; left = right = null; } } class Index { int index; } class BinaryTree { Node buildUtil(int[] in, int[] post, int inStrt, int inEnd, Index pIndex) { if (inStrt > inEnd) return null; Node node = new Node(post[pIndex.index]); (pIndex.index)--; if (inStrt == inEnd) return node; int iIndex = search(in, inStrt, inEnd, node.data); node.right = buildUtil(in, post, iIndex + 1, inEnd, pIndex); node.left = buildUtil(in, post, inStrt, iIndex - 1, pIndex); return node; } Node buildTree(int[] in, int[] post, int n) { Index pIndex = new Index(); pIndex.index = n - 1; return buildUtil(in, post, 0, n - 1, pIndex); } int search(int[] arr, int strt, int end, int value) { int i; for (i = strt; i <= end; i++) { if (arr[i] == value) break; } return i; } void preOrder(Node node) { if (node == null) return; System.out.print(node.data + \" \"); preOrder(node.left); preOrder(node.right); } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); int in[] = new int[] { 4, 8, 2, 5, 1, 6, 3, 7 }; int post[] = new int[] { 8, 4, 5, 2, 6, 7, 3, 1 }; int n = in.length; Node root = tree.buildTree(in, post, n); System.out.println(\"Preorder of the constructed tree : \"); tree.preOrder(root); } }", "src": "\n// Java program to construct a tree using inorder \n// and postorder traversals \n\n/* A binary tree node has data, pointer to left \n\nchild and a pointer to right child */\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\n// Class Index created to implement pass by reference of Index \nclass\nIndex { \n\nint\nindex; \n} \n\nclass\nBinaryTree { \n\n/* Recursive function to construct binary of size n \n\nfrom Inorder traversal in[] and Postrder traversal \n\npost[]. Initial values of inStrt and inEnd should \n\nbe 0 and n -1. The function doesn't do any error \n\nchecking for cases where inorder and postorder \n\ndo not form a tree */\n\nNode buildUtil(\nint\nin[], \nint\npost[], \nint\ninStrt, \n\nint\ninEnd, Index pIndex) \n\n{ \n\n// Base case \n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n/* Pick current node from Postrder traversal using \n\npostIndex and decrement postIndex */\n\nNode node = \nnew\nNode(post[pIndex.index]); \n\n(pIndex.index)--; \n\n\n/* If this node has no children then return */\n\nif\n(inStrt == inEnd) \n\nreturn\nnode; \n\n\n/* Else find the index of this node in Inorder \n\ntraversal */\n\nint\niIndex = search(in, inStrt, inEnd, node.data); \n\n\n/* Using index in Inorder traversal, construct left and \n\nright subtress */\n\nnode.right = buildUtil(in, post, iIndex + \n1\n, inEnd, pIndex); \n\nnode.left = buildUtil(in, post, inStrt, iIndex - \n1\n, pIndex); \n\n\nreturn\nnode; \n\n} \n\n\n// This function mainly initializes index of root \n\n// and calls buildUtil() \n\nNode buildTree(\nint\nin[], \nint\npost[], \nint\nn) \n\n{ \n\nIndex pIndex = \nnew\nIndex(); \n\npIndex.index = n - \n1\n; \n\nreturn\nbuildUtil(in, post, \n0\n, n - \n1\n, pIndex); \n\n} \n\n\n/* Function to find index of value in arr[start...end] \n\nThe function assumes that value is postsent in in[] */\n\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n\n{ \n\nint\ni; \n\nfor\n(i = strt; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nbreak\n; \n\n} \n\nreturn\ni; \n\n} \n\n\n/* This funtcion is here just to test */\n\nvoid\npreOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\nin[] = \nnew\nint\n[] { \n4\n, \n8\n, \n2\n, \n5\n, \n1\n, \n6\n, \n3\n, \n7\n}; \n\nint\npost[] = \nnew\nint\n[] { \n8\n, \n4\n, \n5\n, \n2\n, \n6\n, \n7\n, \n3\n, \n1\n}; \n\nint\nn = in.length; \n\nNode root = tree.buildTree(in, post, n); \n\nSystem.out.println(\n\"Preorder of the constructed tree : \"\n); \n\ntree.preOrder(root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "index": 412, "complexity": 5}
{"back-translation": "import java.util.*;\nimport java.math.*;\npublic class Main {\n\tstatic class en implements Comparable<en>{\n\t\tint w,h,dex;\n\t\ten(int a,int b,int c){\n\t\t\tw=a;\n\t\t\th=b;\n\t\t\tdex=c;\n\t\t}\n\t\tpublic int compareTo(en o) {\n\t\t\treturn w-o.w;\n\t\t}\n\t}\n\tpublic static void main(String args[]) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tint n=cin.nextInt(),ww=cin.nextInt(),hh=cin.nextInt(),num=0;\n\t\tQueue<en> que=new PriorityQueue();\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint a=cin.nextInt(),b=cin.nextInt();\n\t\t\tif(a>ww&&b>hh) {\n\t\t\t\tque.add(new en(a,b,i));\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tint dp[][]=new int[num+5][2],ans=0,ad=0,arr[][]=new int[num+5][3];\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tarr[i][0]=que.peek().w;\n\t\t\tarr[i][1]=que.peek().h;\n\t\t\tarr[i][2]=que.remove().dex;\n\t\t}\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tint te=0,td=0;\n\t\t\tfor(int j=1;j<i;j++) {\n\t\t\t\tif(arr[j][0]<arr[i][0]&&arr[j][1]<arr[i][1]&&dp[j][0]>te) {\n\t\t\t\t\tte=dp[j][0];\n\t\t\t\t\ttd=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][0]=te+1;\n\t\t\tdp[i][1]=td;\n\t\t\tif(dp[i][0]>ans) {\n\t\t\t\tans=dp[i][0];\n\t\t\t\tad=i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tArrayList<Integer> an=new ArrayList();\n\t\tint u=ad;\n\t\twhile(u>0) {\n\t\t\tan.add(arr[u][2]);\n\t\t\tu=dp[u][1];\n\t\t\t//System.out.println(u);\n\t\t}\n\t\tfor(int i=an.size()-1;i>=0;i--) System.out.print(an.get(i)+\" \");\n\t}\n}", "src": "\nimport java.util.*;\nimport java.math.*;\npublic class Main {\n\tstatic class en implements Comparable<en>{\n\t\tint w,h,dex;\n\t\ten(int a,int b,int c){\n\t\t\tw=a;\n\t\t\th=b;\n\t\t\tdex=c;\n\t\t}\n\t\tpublic int compareTo(en o) {\n\t\t\treturn w-o.w;\n\t\t}\n\t}\n\tpublic static void main(String args[]) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tint n=cin.nextInt(),ww=cin.nextInt(),hh=cin.nextInt(),num=0;\n\t\tQueue<en> que=new PriorityQueue();\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint a=cin.nextInt(),b=cin.nextInt();\n\t\t\tif(a>ww&&b>hh) {\n\t\t\t\tque.add(new en(a,b,i));\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tint dp[][]=new int[num+5][2],ans=0,ad=0,arr[][]=new int[num+5][3];\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tarr[i][0]=que.peek().w;\n\t\t\tarr[i][1]=que.peek().h;\n\t\t\tarr[i][2]=que.remove().dex;\n\t\t}\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tint te=0,td=0;\n\t\t\tfor(int j=1;j<i;j++) {\n\t\t\t\tif(arr[j][0]<arr[i][0]&&arr[j][1]<arr[i][1]&&dp[j][0]>te) {\n\t\t\t\t\tte=dp[j][0];\n\t\t\t\t\ttd=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][0]=te+1;\n\t\t\tdp[i][1]=td;\n\t\t\tif(dp[i][0]>ans) {\n\t\t\t\tans=dp[i][0];\n\t\t\t\tad=i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tArrayList<Integer> an=new ArrayList();\n\t\tint u=ad;\n\t\twhile(u>0) {\n\t\t\tan.add(arr[u][2]);\n\t\t\tu=dp[u][1];\n\t\t\t//System.out.println(u);\n\t\t}\n\t\tfor(int i=an.size()-1;i>=0;i--) System.out.print(an.get(i)+\" \");\n\t}\n}\n", "index": 413, "complexity": 5}
{"back-translation": "class GfG { static int preIndex = 0; static class Node { int data; Node left, right; } static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.left = null; temp.right = null; return temp; } static int search(int arr[], int strt, int end, int value) { for (int i = strt; i <= end; i++) { if (arr[i] == value) return i; } return -1; } static Node buildTree(int in[], int pre[], int inStrt, int inEnd) { if (inStrt > inEnd) return null; Node tNode = newNode(pre[preIndex++]); if (inStrt == inEnd) return tNode; int inIndex = search(in, inStrt, inEnd, tNode.data); tNode.left = buildTree(in, pre, inStrt, inIndex-1); tNode.right = buildTree(in, pre, inIndex+1, inEnd); return tNode; } static int checkPostorder(Node node, int postOrder[], int index) { if (node == null) return index; index = checkPostorder(node.left,postOrder,index); index = checkPostorder(node.right,postOrder,index); if (node.data == postOrder[index]) index++; else return -1; return index; } public static void main(String[] args) { int inOrder[] = {4, 2, 5, 1, 3}; int preOrder[] = {1, 2, 4, 5, 3}; int postOrder[] = {4, 5, 2, 3, 1}; int len = inOrder.length; Node root = buildTree(inOrder, preOrder, 0, len - 1); int index = checkPostorder(root,postOrder,0); if (index == len) System.out.println(", "src": "\n/* Java program to check if all three given \ntraversals are of the same tree */\nimport\njava.util.*; \nclass\nGfG { \n\nstatic\nint\npreIndex = \n0\n; \n\n// A Binary Tree Node \nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n// Utility function to create a new tree node \nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n/* Function to find index of value in arr[start...end] \nThe function assumes that value is present in in[] */\nstatic\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n{ \n\nfor\n(\nint\ni = strt; i <= end; i++) \n\n{ \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\n-\n1\n; \n} \n\n/* Recursive function to construct binary tree \nof size len from Inorder traversal in[] and \nPreorder traversal pre[]. Initial values \nof inStrt and inEnd should be 0 and len -1. \nThe function doesn't do any error checking for \ncases where inorder and preorder do not form a \ntree */\nstatic\nNode buildTree(\nint\nin[], \nint\npre[], \nint\ninStrt, \nint\ninEnd) \n{ \n\n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n/* Pick current node from Preorder traversal \n\nusing preIndex and increment preIndex */\n\nNode tNode = newNode(pre[preIndex++]); \n\n\n/* If this node has no children then return */\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n/* Else find the index of this node in \n\nInorder traversal */\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n/* Using index in Inorder traversal, \n\nconstruct left and right subtress */\n\ntNode.left = buildTree(in, pre, inStrt, inIndex-\n1\n); \n\ntNode.right = buildTree(in, pre, inIndex+\n1\n, inEnd); \n\n\nreturn\ntNode; \n} \n\n/* function to compare Postorder traversal \non constructed tree and given Postorder */\nstatic\nint\ncheckPostorder(Node node, \nint\npostOrder[], \nint\nindex) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\nindex; \n\n\n/* first recur on left child */\n\nindex = checkPostorder(node.left,postOrder,index); \n\n\n/* now recur on right child */\n\nindex = checkPostorder(node.right,postOrder,index); \n\n\n/* Compare if data at current index in \n\nboth Postorder traversals are same */\n\nif\n(node.data == postOrder[index]) \n\nindex++; \n\nelse\n\nreturn\n-\n1\n; \n\n\nreturn\nindex; \n} \n\n// Driver program to test above functions \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\ninOrder[] = {\n4\n, \n2\n, \n5\n, \n1\n, \n3\n}; \n\nint\npreOrder[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n3\n}; \n\nint\npostOrder[] = {\n4\n, \n5\n, \n2\n, \n3\n, \n1\n}; \n\n\nint\nlen = inOrder.length; \n\n\n// build tree from given \n\n// Inorder and Preorder traversals \n\nNode root = buildTree(inOrder, preOrder, \n0\n, len - \n1\n); \n\n\n// compare postorder traversal on constructed \n\n// tree with given Postorder traversal \n\nint\nindex = checkPostorder(root,postOrder,\n0\n); \n\n\n// If both postorder traversals are same \n\nif\n(index == len) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n} ", "index": 414, "complexity": 5}
{"back-translation": "import java.util.*;\n\npublic class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "src": "//\n//                                  _oo8oo_\n//                                 o8888888o\n//                                 88\" . \"88\n//                                 (| -_- |)\n//                                 0\\  =  /0\n//                               ___/'==='\\___\n//                             .' \\\\|     |// '.\n//                            / \\\\|||  :  |||// \\\n//                           / _||||| -:- |||||_ \\\n//                          |   | \\\\\\  -  /// |   |\n//                          | \\_|  ''\\---/''  |_/ |\n//                          \\  .-\\__  '-'  __/-.  /\n//                        ___'. .'  /--.--\\  '. .'___\n//                     .\"\" '<  '.___\\_<|>_/___.'  >' \"\".\n//                    | | :  `- \\`.:`\\ _ /`:.`/ -`  : | |\n//                    \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n//                =====`-.____`.___ \\_____/ ___.`____.-`=====\n//                                  `=---=`\n//\n//\n//               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//                          \u4f5b\u7956\u4fdd\u4f51         \u6c38\u4e0d\u5b95\u673a/\u6c38\u65e0bug\n//\n\nimport java.util.*;\n\npublic class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n//        System.out.println(Arrays.toString(list.toArray()));\n//        if (list.size() < n) {\n//            System.out.println(0);\n//        } else {\n//            System.out.println(list.get(n - 1).num);\n//        }\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}\n", "index": 415, "complexity": 5}
{"back-translation": "import java.io.OutputStream;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.io.IOException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BObtainingTheString solver = new BObtainingTheString();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BObtainingTheString {\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            String s = br.nextString();\n            String t = br.nextString();\n            char[] sarr = new char[n];\n            char[] tarr = new char[n];\n            int[] sAppear = new int[26];\n            int[] tAppear = new int[26];\n            for (int i = 0; i < s.length(); i++) {\n                sarr[i] = s.charAt(i);\n                tarr[i] = t.charAt(i);\n                sAppear[s.charAt(i) - 'a']++;\n                tAppear[t.charAt(i) - 'a']++;\n            }\n            for (int i = 0; i < 26; i++) {\n                if (sAppear[i] != tAppear[i]) {\n                    pw.println(-1);\n                    pw.close();\n                }\n            }\n            ArrayList<Integer> ans = new ArrayList<Integer>();\n            for (int i = 0; i < n; i++) {\n                char curr = tarr[i];\n                for (int j = i + 1; j < n; j++) {\n                    if (sarr[j] == curr) {\n                        for (int k = j; k > i; k--) {\n                            ans.add(k);\n                            char temp = sarr[k - 1];\n                            sarr[k - 1] = sarr[k];\n                            sarr[k] = temp;\n                        }\n                        break;\n                    }\n                }\n            }\n            pw.println(ans.size());\n            for (int e : ans) {\n                pw.print(e + \" \");\n            }\n            pw.close();\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author caoash\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BObtainingTheString solver = new BObtainingTheString();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BObtainingTheString {\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            String s = br.nextString();\n            String t = br.nextString();\n            char[] sarr = new char[n];\n            char[] tarr = new char[n];\n            int[] sAppear = new int[26];\n            int[] tAppear = new int[26];\n            for (int i = 0; i < s.length(); i++) {\n                sarr[i] = s.charAt(i);\n                tarr[i] = t.charAt(i);\n                sAppear[s.charAt(i) - 'a']++;\n                tAppear[t.charAt(i) - 'a']++;\n            }\n            for (int i = 0; i < 26; i++) {\n                if (sAppear[i] != tAppear[i]) {\n                    pw.println(-1);\n                    pw.close();\n                }\n            }\n            ArrayList<Integer> ans = new ArrayList<Integer>();\n            for (int i = 0; i < n; i++) {\n                char curr = tarr[i];\n                for (int j = i + 1; j < n; j++) {\n                    if (sarr[j] == curr) {\n                        for (int k = j; k > i; k--) {\n                            ans.add(k);\n                            char temp = sarr[k - 1];\n                            sarr[k - 1] = sarr[k];\n                            sarr[k] = temp;\n                        }\n                        break;\n                    }\n                }\n            }\n            pw.println(ans.size());\n            for (int e : ans) {\n                pw.print(e + \" \");\n            }\n            pw.close();\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "index": 416, "complexity": 5}
{"back-translation": "class GFG { static int maxSumIS(int arr[], int n) { int i, j, max = 0; int msis[] = new int[n]; for (i = 0; i < n; i++) msis[i] = arr[i]; for (i = 1; i < n; i++) for (j = 0; j < i; j++) if (arr[i] > arr[j] && msis[i] < msis[j] + arr[i]) msis[i] = msis[j] + arr[i]; for (i = 0; i < n; i++) if (max < msis[i]) max = msis[i]; return max; } public static void main(String args[]) { int arr[] = new int[]{1, 101, 2, 3, 100, 4, 5}; int n = arr.length; System.out.println(\"Sum of maximum sum \" + \"increasing subsequence is \" + maxSumIS(arr, n)); } }", "src": "\n/* Dynamic Programming Java \n\nimplementation of Maximum Sum \n\nIncreasing Subsequence (MSIS) \n\nproblem */\nclass\nGFG \n{ \n\n/* maxSumIS() returns the \n\nmaximum sum of increasing \n\nsubsequence in arr[] of size n */\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n/* Initialize msis values \n\nfor all indexes */\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n/* Compute maximum sum values \n\nin bottom up manner */\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n/* Pick maximum of all \n\nmsis values */\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n} \n\n// This code is contributed \n// by Rajat Mishra ", "index": 417, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n\n        new Main().go();\n    }\n\n    PrintWriter out;\n    Reader in;\n    BufferedReader br;\n\n    Main() throws IOException {\n\n        try {\n\n            //br = new BufferedReader( new FileReader(\"input.txt\") );\n            //in = new Reader(\"input.txt\");\n            in = new Reader(\"input.txt\");\n            out = new PrintWriter( new BufferedWriter(new FileWriter(\"output.txt\")) );\n        }\n        catch (Exception e) {\n\n            //br = new BufferedReader( new InputStreamReader( System.in ) );\n            in = new Reader();\n            out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );\n        }\n    }\n\n    void go() throws Exception {\n\n        //int t = in.nextInt();\n        int t = 1;\n        while (t > 0) {\n            solve();\n            t--;\n        }\n\n        out.flush();\n        out.close();\n    }\n\n\n    int inf = 2000000000;\n    int mod = 1000000007;\n    double eps = 0.000000001;\n\n    int n;\n    int m;\n\n    ArrayList<Pair>[] g;\n    String s;\n    int[][] a;\n    void solve() throws IOException {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        a = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            String s = in.nextLine();\n            for (int j = 0; j < m; j++) {\n                a[i][j] = s.charAt(j);\n            }\n        }\n\n        int[][] f = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                f[i][j] = inf;\n\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < m; j++) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = m - 1; j >= 0; j--) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        for (int j = 0; j < m; j++) {\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        for (int j = 0; j < m; j++) {\n            int cnt = 0;\n            for (int i = n - 1; i >= 0; i--) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        ArrayList<Item> ans = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) {\n                if (a[i][j] == '*' && f[i][j] > 0)\n                    ans.add(new Item(i + 1, j + 1, f[i][j]));\n            }\n        boolean[][] used = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < m; j++) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n            cnt = 0;\n            for (int j = m - 1; j >= 0; j--) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n        }\n\n        for (int j = 0; j < m; j++) {\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n            cnt = 0;\n            for (int i = n - 1; i >= 0; i--) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n        }\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                if (a[i][j] == '*' && !used[i][j]) {\n                    out.println(-1);\n                    return;\n                }\n\n        out.println(ans.size());\n        for (Item i : ans)\n            out.println(i.a + \" \" + i.b + \" \" + i.c);\n    }\n\n\n    class Pair implements Comparable<Pair>{\n\n        int a;\n        int b;\n\n        Pair(int a, int b) {\n\n            this.a = a;\n            this.b = b;\n        }\n\n        public int compareTo(Pair p) {\n            if (a != p.a)\n                return Integer.compare(a, p.a);\n            else\n                return Integer.compare(b, p.b);\n        }\n    }\n\n    class Item {\n\n        int a;\n        int b;\n        int c;\n\n        Item(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n    }\n\n\n    class Reader {\n\n        BufferedReader  br;\n        StringTokenizer tok;\n\n        Reader(String file) throws IOException {\n            br = new BufferedReader( new FileReader(file) );\n        }\n\n        Reader() throws IOException {\n            br = new BufferedReader( new InputStreamReader(System.in) );\n        }\n\n        String next() throws IOException {\n\n            while (tok == null || !tok.hasMoreElements())\n                tok = new StringTokenizer(br.readLine());\n            return tok.nextToken();\n        }\n\n        int nextInt() throws NumberFormatException, IOException {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.valueOf(next());\n        }\n\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n    }\n\n    static class InputReader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public InputReader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n\n        new Main().go();\n    }\n\n    PrintWriter out;\n    Reader in;\n    BufferedReader br;\n\n    Main() throws IOException {\n\n        try {\n\n            //br = new BufferedReader( new FileReader(\"input.txt\") );\n            //in = new Reader(\"input.txt\");\n            in = new Reader(\"input.txt\");\n            out = new PrintWriter( new BufferedWriter(new FileWriter(\"output.txt\")) );\n        }\n        catch (Exception e) {\n\n            //br = new BufferedReader( new InputStreamReader( System.in ) );\n            in = new Reader();\n            out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );\n        }\n    }\n\n    void go() throws Exception {\n\n        //int t = in.nextInt();\n        int t = 1;\n        while (t > 0) {\n            solve();\n            t--;\n        }\n\n        out.flush();\n        out.close();\n    }\n\n\n    int inf = 2000000000;\n    int mod = 1000000007;\n    double eps = 0.000000001;\n\n    int n;\n    int m;\n\n    ArrayList<Pair>[] g;\n    String s;\n    int[][] a;\n    void solve() throws IOException {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        a = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            String s = in.nextLine();\n            for (int j = 0; j < m; j++) {\n                a[i][j] = s.charAt(j);\n            }\n        }\n\n        int[][] f = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                f[i][j] = inf;\n\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < m; j++) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = m - 1; j >= 0; j--) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        for (int j = 0; j < m; j++) {\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        for (int j = 0; j < m; j++) {\n            int cnt = 0;\n            for (int i = n - 1; i >= 0; i--) {\n                if (a[i][j] == '*') {\n                    f[i][j] = Math.min(f[i][j], cnt);\n                    cnt++;\n                } else {\n                    cnt = 0;\n                }\n            }\n        }\n\n        ArrayList<Item> ans = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++) {\n                if (a[i][j] == '*' && f[i][j] > 0)\n                    ans.add(new Item(i + 1, j + 1, f[i][j]));\n            }\n        boolean[][] used = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < m; j++) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n            cnt = 0;\n            for (int j = m - 1; j >= 0; j--) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n        }\n\n        for (int j = 0; j < m; j++) {\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n            cnt = 0;\n            for (int i = n - 1; i >= 0; i--) {\n                if (a[i][j] == '*' && f[i][j] > 0) {\n                    cnt = Math.max(cnt, f[i][j] + 1);\n                }\n                if (cnt > 0) used[i][j] = true;\n                cnt--;\n            }\n        }\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                if (a[i][j] == '*' && !used[i][j]) {\n                    out.println(-1);\n                    return;\n                }\n\n        out.println(ans.size());\n        for (Item i : ans)\n            out.println(i.a + \" \" + i.b + \" \" + i.c);\n    }\n\n\n    class Pair implements Comparable<Pair>{\n\n        int a;\n        int b;\n\n        Pair(int a, int b) {\n\n            this.a = a;\n            this.b = b;\n        }\n\n        public int compareTo(Pair p) {\n            if (a != p.a)\n                return Integer.compare(a, p.a);\n            else\n                return Integer.compare(b, p.b);\n        }\n    }\n\n    class Item {\n\n        int a;\n        int b;\n        int c;\n\n        Item(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n    }\n\n\n    class Reader {\n\n        BufferedReader  br;\n        StringTokenizer tok;\n\n        Reader(String file) throws IOException {\n            br = new BufferedReader( new FileReader(file) );\n        }\n\n        Reader() throws IOException {\n            br = new BufferedReader( new InputStreamReader(System.in) );\n        }\n\n        String next() throws IOException {\n\n            while (tok == null || !tok.hasMoreElements())\n                tok = new StringTokenizer(br.readLine());\n            return tok.nextToken();\n        }\n\n        int nextInt() throws NumberFormatException, IOException {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.valueOf(next());\n        }\n\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n    }\n\n    static class InputReader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public InputReader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n}", "index": 419, "complexity": 5}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Codeforces {\n\n    static int n;\n    static double max;\n    static int[] pre;\n\n    public static void findIntensity(int l) {\n        int i = 0, j = i + l;\n        while (j < n + 1) {\n            double res = (double)(pre[j] - pre[i]) / (double)l;\n            max = Math.max(max, res);\n            i++;\n            j++;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int[] heat = new int[n];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            heat[i] = Integer.parseInt(st.nextToken());\n        }\n        max = 0;\n        pre = new int[n + 1];\n        pre[0] = 0;\n        for (int i = 0; i < n; i++) {\n            pre[i + 1] = pre[i] + heat[i];\n        }\n        for (int i = k; i <= n; i++) {\n            findIntensity(i);\n        }\n        System.out.println(max);\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\nimport java.util.Map.Entry;\n\npublic class Codeforces {\n\n    static int n;\n    static double max;\n    static int[] pre;\n\n    public static void findIntensity(int l){\n        for(int i = 0, j = i + l; j < n + 1; i++, j++){\n            double res = (pre[j] - pre[i]) / (double) l;\n            max = Math.max(max, res);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int[] heat = new int[n];\n        st = new StringTokenizer(br.readLine());\n        for(int i = 0; i < n; i++){\n            heat[i] = Integer.parseInt(st.nextToken());\n        }\n        max = 0;\n        pre = new int[n + 1];\n        pre[0] = 0;\n        for(int i = 0; i < n; i++){\n            pre[i + 1] = pre[i] + heat[i];\n        }\n        for(int i = k; i <= n; i++){\n            findIntensity(i);\n        }\n        System.out.println(max);\n    }\n}", "index": 420, "complexity": 5}
{"back-translation": "class GFG { static int MaxSumBS(int[] arr, int n) { int max_sum = Integer.MIN_VALUE; int[] MSIBS = new int[n]; int[] MSDBS = new int[n]; for (int i = 0; i < n; i++) { MSDBS[i] = arr[i]; MSIBS[i] = arr[i]; } for (int i = 1; i < n; i++) for (int j = 0; j < i; j++) if (arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) MSIBS[i] = MSIBS[j] + arr[i]; for (int i = n - 2; i >= 0; i--) for (int j = n - 1; j > i; j--) if (arr[i] > arr[j] && MSDBS[i] < MSDBS[j] + arr[i]) MSDBS[i] = MSDBS[j] + arr[i]; for (int i = 0; i < n; i++) max_sum = Math.max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i])); return max_sum; } public static void main(String[] args) { int arr[] = { 1, 15, 51, 45, 33, 100, 12, 18, 9 }; int n = arr.length; System.out.println(\"Maximum Sum : \" + MaxSumBS(arr, n)); } }", "src": "\n// java program to find maximum \n// sum of bi-tonic sub-sequence \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Function return maximum sum \n\n// of Bi-tonic sub-sequence \n\nstatic\nint\nMaxSumBS(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmax_sum = Integer.MIN_VALUE; \n\n\n// MSIBS[i] ==> Maximum sum Increasing Bi-tonic \n\n// subsequence ending with arr[i] \n\n// MSDBS[i] ==> Maximum sum Decreasing Bi-tonic \n\n// subsequence starting with arr[i] \n\n// Initialize MSDBS and MSIBS values as arr[i] for \n\n// all indexes \n\nint\nMSIBS[] = \nnew\nint\n[n]; \n\nint\nMSDBS[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nMSDBS[i] = arr[i]; \n\nMSIBS[i] = arr[i]; \n\n} \n\n\n// Compute MSIBS values from left to right */ \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) \n\nMSIBS[i] = MSIBS[j] + arr[i]; \n\n\n// Compute MSDBS values from right to left \n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && MSDBS[i] < MSDBS[j] + arr[i]) \n\nMSDBS[i] = MSDBS[j] + arr[i]; \n\n\n// Find the maximum value of MSIBS[i] + \n\n// MSDBS[i] - arr[i] \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmax_sum = Math.max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i])); \n\n\n// return max sum of bi-tonic \n\n// sub-sequence \n\nreturn\nmax_sum; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n15\n, \n51\n, \n45\n, \n33\n, \n100\n, \n12\n, \n18\n, \n9\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum Sum : \"\n+ MaxSumBS(arr, n)); \n\n} \n} \n\n// This code is contributed by vt_m ", "index": 421, "complexity": 5}
{"back-translation": "class GFG { static int MAX_CHAR = 26; static boolean check(int freq[], int k) { for (int i = 0; i < MAX_CHAR; i++) if (freq[i] != 0 && freq[i] != k) return false; return true; } static int substrings(String s, int k) { int res = 0; for (int i = 0; i < s.length(); i++) { int freq[] = new int[MAX_CHAR]; for (int j = i; j < s.length(); j++) { int index = s.charAt(j) - 'a'; freq[index]++; if (freq[index] > k) break; else if (freq[index] == k && check(freq, k)) res++; } } return res; } public static void main(String[] args) { String s = \"aabbcc\"; int k = 2; System.out.println(substrings(s, k)); s = \"aabbc\"; k = 2; System.out.println(substrings(s, k)); } }", "src": "\n// Java program to count number of substrings \n// with counts of distinct characters as k. \nclass\nGFG \n{ \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n// Returns true if all values \n// in freq[] are either 0 or k. \nstatic\nboolean\ncheck(\nint\nfreq[], \nint\nk) \n{ \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nif\n(freq[i] !=\n0\n&& freq[i] != k) \n\nreturn\nfalse\n; \n\nreturn\ntrue\n; \n} \n\n// Returns count of substrings where frequency \n// of every present character is k \nstatic\nint\nsubstrings(String s, \nint\nk) \n{ \n\nint\nres = \n0\n; \n// Initialize result \n\n\n// Pick a starting point \n\nfor\n(\nint\ni = \n0\n; i< s.length(); i++) \n\n{ \n\n\n// Initialize all frequencies as 0 \n\n// for this starting point \n\nint\nfreq[] = \nnew\nint\n[MAX_CHAR]; \n\n\n// One by one pick ending points \n\nfor\n(\nint\nj = i; j<s.length(); j++) \n\n{ \n\n\n// Increment frequency of current char \n\nint\nindex = s.charAt(j) - \n'a'\n; \n\nfreq[index]++; \n\n\n// If frequency becomes more than \n\n// k, we can't have more substrings \n\n// starting with i \n\nif\n(freq[index] > k) \n\nbreak\n; \n\n\n// If frequency becomes k, then check \n\n// other frequencies as well. \n\nelse\nif\n(freq[index] == k && \n\ncheck(freq, k) == \ntrue\n) \n\nres++; \n\n} \n\n} \n\nreturn\nres; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nString s = \n\"aabbcc\"\n; \n\nint\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n\n\ns = \n\"aabbc\"\n; \n\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n} \n} \n\n// This code has been contributed by 29AjayKumar ", "index": 422, "complexity": 5}
{"back-translation": "class GFG { static void printPrevSmaller(int[] arr, int n) { System.out.print(\"_, \"); for (int i = 1; i < n; i++) { int j; for (j = i - 1; j >= 0; j--) { if (arr[j] < arr[i]) { System.out.print(arr[j] + \", \"); break; } } if (j == -1) System.out.print(\"_, \"); } } public static void main(String[] args) { int[] arr = {1, 3, 0, 2, 5}; int n = arr.length; printPrevSmaller(arr, n); } }", "src": "\n// Java implementation of simple \n// algorithm to find smaller \n// element on left side \nimport\njava.io.*; \nclass\nGFG { \n\n// Prints smaller elements on \n// left side of every element \nstatic\nvoid\nprintPrevSmaller(\nint\n[]arr, \nint\nn) \n{ \n\n\n// Always print empty or '_' \n\n// for first element \n\nSystem.out.print( \n\"_, \"\n); \n\n\n// Start from second element \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n// look for smaller \n\n// element on left of 'i' \n\nint\nj; \n\nfor\n(j = i - \n1\n; j >= \n0\n; j--) \n\n{ \n\nif\n(arr[j] < arr[i]) \n\n{ \n\nSystem.out.print(arr[j] + \n\", \"\n); \n\nbreak\n; \n\n} \n\n} \n\n\n// If there is no smaller \n\n// element on left of 'i' \n\nif\n(j == -\n1\n) \n\nSystem.out.print( \n\"_, \"\n) ; \n\n} \n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]arr = {\n1\n, \n3\n, \n0\n, \n2\n, \n5\n}; \n\nint\nn = arr.length; \n\nprintPrevSmaller(arr, n); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "index": 423, "complexity": 5}
{"back-translation": "class GFG {\n    static void printKMax(int arr[], int n, int k) {\n        int j, max;\n        for (int i = 0; i <= n - k; i++) {\n            max = arr[i];\n            for (j = 1; j < k; j++) {\n                if (arr[i + j] > max)\n                    max = arr[i + j];\n            }\n            System.out.print(max + \" \");\n        }\n    }\n    public static void main(String args[]) {\n        int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        int k = 3;\n        printKMax(arr, arr.length, k);\n    }\n}", "src": "\n// Java Program to find the maximum for each and every contiguous subarray of size k. \n\npublic\nclass\nGFG { \n\n// Method to find the maximum for each and every contiguous subarray of size k. \n\nstatic\nvoid\nprintKMax(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nj, max; \n\n\nfor\n(\nint\ni = \n0\n; i <= n - k; i++) { \n\n\nmax = arr[i]; \n\n\nfor\n(j = \n1\n; j < k; j++) { \n\nif\n(arr[i + j] > max) \n\nmax = arr[i + j]; \n\n} \n\nSystem.out.print(max + \n\" \"\n); \n\n} \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}; \n\nint\nk = \n3\n; \n\nprintKMax(arr, arr.length, k); \n\n} \n} \n\n// This code is contributed by Sumit Ghosh ", "index": 424, "complexity": 5}
{"back-translation": "class SmallestSubarraySum { static int smallestSubWithSum(int arr[], int n, int x) { int min_len = n + 1; for (int start = 0; start < n; start++) { int curr_sum = arr[start]; if (curr_sum > x) return 1; for (int end = start + 1; end < n; end++) { curr_sum += arr[end]; if (curr_sum > x && (end - start + 1) < min_len) min_len = (end - start + 1); } } return min_len; } public static void main(String[] args) { int arr1[] = { 1, 4, 45, 6, 10, 19 }; int x = 51; int n1 = arr1.length; int res1 = smallestSubWithSum(arr1, n1, x); if (res1 == n1 + 1) System.out.println(\"Not Possible\"); else System.out.println(res1); int arr2[] = { 1, 10, 5, 2, 7 }; int n2 = arr2.length; x = 9; int res2 = smallestSubWithSum(arr2, n2, x); if (res2 == n2 + 1) System.out.println(\"Not Possible\"); else System.out.println(res2); int arr3[] = { 1, 11, 100, 1, 0, 200, 3, 2, 1, 250 }; int n3 = arr3.length; x = 280; int res3 = smallestSubWithSum(arr3, n3, x); if (res3 == n3 + 1) System.out.println(\"Not Possible\"); else System.out.println(res3); } }", "src": "\nclass\nSmallestSubArraySum \n{ \n\n// Returns length of smallest subarray with sum greater than x. \n\n// If there is no subarray with given sum, then returns n+1 \n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n// Initilize length of smallest subarray as n+1 \n\nint\nmin_len = n + \n1\n; \n\n\n// Pick every element as starting point \n\nfor\n(\nint\nstart = \n0\n; start < n; start++) \n\n{ \n\n// Initialize sum starting with current start \n\nint\ncurr_sum = arr[start]; \n\n\n// If first element itself is greater \n\nif\n(curr_sum > x) \n\nreturn\n1\n; \n\n\n// Try different ending points for curremt start \n\nfor\n(\nint\nend = start + \n1\n; end < n; end++) \n\n{ \n\n// add last element to current sum \n\ncurr_sum += arr[end]; \n\n\n// If sum becomes more than x and length of \n\n// this subarray is smaller than current smallest \n\n// length, update the smallest length (or result) \n\nif\n(curr_sum > x && (end - start + \n1\n) < min_len) \n\nmin_len = (end - start + \n1\n); \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 426, "complexity": 5}
{"back-translation": "public class GFG { static int offeringNumber(int n, int[] templeHeight) { int sum = 0; for (int i = 0; i < n; ++i) { int left = 0, right = 0; for (int j = i - 1; j >= 0; --j) { if (templeHeight[j] < templeHeight[j + 1]) ++left; else break; } for (int j = i + 1; j < n; ++j) { if (templeHeight[j] < templeHeight[j - 1]) ++right; else break; } sum += Math.max(right, left) + 1; } return sum; } public static void main(String[] args) { int arr1[] = { 1, 2, 2 }; System.out.println(offeringNumber(3, arr1)); int arr2[] = { 1, 4, 3, 6, 2, 1 }; System.out.println(offeringNumber(6, arr2)); } }", "src": "\n// Program to find minimum \n// total offerings required \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Returns minimum \n// offerings required \nstatic\nint\nofferingNumber(\nint\nn, \n\nint\ntempleHeight[]) \n{ \n\nint\nsum = \n0\n; \n// Initialize result \n\n\n// Go through all \n\n// temples one by one \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\n// Go to left while \n\n// height keeps increasing \n\nint\nleft = \n0\n, right = \n0\n; \n\nfor\n(\nint\nj = i - \n1\n; j >= \n0\n; --j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j + \n1\n]) \n\n++left; \n\nelse\n\nbreak\n; \n\n} \n\n\n// Go to right while \n\n// height keeps increasing \n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j - \n1\n]) \n\n++right; \n\nelse\n\nbreak\n; \n\n} \n\n\n// This temple should offer \n\n// maximum of two values \n\n// to follow the rule. \n\nsum += Math.max(right, left) + \n1\n; \n\n} \n\n\nreturn\nsum; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain (String[] args) \n{ \nint\narr1[] = {\n1\n, \n2\n, \n2\n}; \nSystem.out.println(offeringNumber(\n3\n, arr1)); \nint\narr2[] = {\n1\n, \n4\n, \n3\n, \n\n6\n, \n2\n, \n1\n}; \nSystem.out.println(offeringNumber(\n6\n, arr2)); \n} \n} \n\n// This code is contributed by akt_mit ", "index": 428, "complexity": 5}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class CodeForces {\n\n\tpublic static int difference(String s, String b, int n, int k) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] pre = new int[n];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (i == 1) {\n\t\t\t\tpre[i - 1] = (s.charAt(i-1) == b.charAt(i-1) ? 0 : 1);\n\t\t\t}\n\t\t\tpre[i] = pre[i - 1] + (s.charAt(i) == b.charAt(i) ? 0 : 1);\n\t\t}\n\t\tint v = -1;\n\t\tfor (int i = k - 1; i < n; i++) {\n\t\t\tmin = Math.min(min, pre[i] - (v == -1 ? 0 : pre[v]));\n\t\t\tv++;\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint t = Integer.parseInt(br.readLine());\n\t\tO: while (t-- > 0) {\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tint k = Integer.parseInt(br.readLine());\n\t\t\tString s = br.readLine();\n\t\t\tint c = 1;\n\t\t\tStringBuilder R = new StringBuilder();\n\t\t\tStringBuilder G = new StringBuilder();\n\t\t\tStringBuilder B = new StringBuilder();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (c % 3 == 1) {\n\t\t\t\t\tR.append(", "src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class CodeForces {\n\n\tpublic static int difference(String s, String b, int n, int k) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] pre = new int[n];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (i == 1) {\n\t\t\t\tpre[i - 1] = (s.charAt(i-1) == b.charAt(i-1) ? 0 : 1);\n\t\t\t}\n\t\t\tpre[i] = pre[i - 1] + (s.charAt(i) == b.charAt(i) ? 0 : 1);\n\t\t}\n\t\tint v = -1;\n\t\tfor (int i = k - 1; i < n; i++) {\n\t\t\tmin = Math.min(min, pre[i] - (v == -1 ? 0 : pre[v]));\n\t\t\tv++;\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint t = sc.nextInt();\n\t\tO: while (t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tString s = sc.nextLine();\n\t\t\tint c = 1;\n\t\t\tStringBuilder R = new StringBuilder();\n\t\t\tStringBuilder G = new StringBuilder();\n\t\t\tStringBuilder B = new StringBuilder();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (c % 3 == 1) {\n\t\t\t\t\tR.append(\"R\") ;\n\t\t\t\t\tG.append(\"G\");\n\t\t\t\t\tB.append(\"B\");\n\t\t\t\t} else if (c % 3 == 2) {\n\t\t\t\t\tR.append(\"G\");\n\t\t\t\t\tG.append(\"B\");\n\t\t\t\t\tB.append(\"R\");\n\t\t\t\t} else {\n\t\t\t\t\tR.append(\"B\");\n\t\t\t\t\tG.append(\"R\");\n\t\t\t\t\tB.append(\"G\");\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tString RR = R.toString(),BB = B.toString() , GG = G.toString();\n\t\t\tString[] arr = new String[] { RR, BB, GG };\n\t\t\tint i = 0;\n\t\t\tint j = k;\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\twhile (i < 3) {\n\t\t\t\tmin = Math.min(min, difference(s, arr[i], n, k));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tpw.println(min);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic class SegmentTree {\n\t\tstatic int[] S, in;\n\t\tstatic int N;\n\n\t\tpublic SegmentTree(int[] arr) {\n\t\t\tin = arr;\n\t\t\tN = in.length - 1;\n\t\t\tS = new int[N << 1];\n\t\t\tbuild(1, 1, N);\n\t\t}\n\n\t\tstatic int stat;\n\n\t\tvoid build(int node, int b, int e) {\n\t\t\tif (b == e) {\n\t\t\t\tS[node] = in[b];\n\t\t\t\tstat = 1;\n\t\t\t} else {\n\t\t\t\tint mid = (b + e) / 2;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[node] = S[node << 1] | S[node << 1 | 1];\n\n\t\t\t\t} else {\n\t\t\t\t\tS[node] = S[node << 1] ^ S[node << 1 | 1];\n\t\t\t\t}\n\t\t\t\tstat = 1 - stat;\n\t\t\t}\n\t\t}\n\n\t\tint update(int idx, int val) {\n\t\t\tidx += (N - 1);\n\n\t\t\tS[idx] = val;\n\t\t\tint stat = 1;\n\t\t\twhile (idx > 1) {\n\t\t\t\tidx >>= 1;\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[idx] = S[idx << 1] | S[idx << 1 | 1];\n\t\t\t\t\tstat = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS[idx] = S[idx << 1] ^ S[idx << 1 | 1];\n\t\t\t\t\tstat = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn S[1];\n\t\t}\n\n\t}\n\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint a, b;\n\n\t\tpublic Pair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic int compareTo(Pair A) {\n\t\t\tif (a != A.a)\n\t\t\t\treturn A.a - a;\n\t\t\treturn A.b - b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader r) {\n\t\t\tbr = new BufferedReader(r);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "index": 429, "complexity": 5}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n    private void solve() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n\n        int n = nextInt(), m = nextInt();\n        boolean[][] used = new boolean[n + 1][m + 1];\n\n        for (int j = 1; j <= (m + 1) / 2; j++) {\n            int x1 = 1, x2 = n;\n            for (int i = 1; i <= n; i++) {\n                if (x1 <= n && !used[x1][j]) {\n                    out.println(x1 + \" \" + j);\n                    used[x1++][j] = true;\n                }\n                if (x2 > 0 && !used[x2][m - j + 1]) {\n                    out.println(x2 + \" \" + (m - j + 1));\n                    used[x2--][m - j + 1] = true;\n                }\n            }\n        }\n\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new D().solve();\n    }\n\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter out;\n\n    private String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return st.nextToken();\n    }\n\n    private int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    private long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    private double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n    private void solve() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n\n        int n = nextInt(), m = nextInt();\n        boolean[][] used = new boolean[n + 1][m + 1];\n\n        for (int j = 1; j <= (m + 1) / 2; j++) {\n            int x1 = 1, x2 = n;\n            for (int i = 1; i <= n; i++) {\n                if (x1 <= n && !used[x1][j]) {\n                    out.println(x1 + \" \" + j);\n                    used[x1++][j] = true;\n                }\n                if (x2 > 0 && !used[x2][m - j + 1]) {\n                    out.println(x2 + \" \" + (m - j + 1));\n                    used[x2--][m - j + 1] = true;\n                }\n            }\n        }\n\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new D().solve();\n    }\n\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter out;\n\n    private String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return st.nextToken();\n    }\n\n    private int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    private long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    private double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "index": 430, "complexity": 5}
{"back-translation": "ERROR", "src": "import java.io.*;\nimport java.util.*;\n\n\n\npublic class hi {\n    public static void main(String[] args) throws IOException{\n        Reader in=new Reader();\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\tint n=in.nextInt();\n\t\tint[] arr=in.nextIntArray(n);\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tint a=(int)Math.floor((Math.min(arr[i],arr[j])/Math.abs(i-j)));\n\t\t\t\tif(a < k)\n\t\t\t\t\tk=a;\n\t\t\t}\n\t\t}\n\t\tw.println(k);\n        w.close();\n        return;\n\t}\n\t\n}\n\n\nclass Reader \n\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\t\tpublic String nextLine() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n        public String next() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\t\tpublic int nextInt() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} while ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n        } \n        public int[] nextIntArray(int n) throws IOException{\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n            }\n\n\t\t\treturn a;\n\t\t}\n\t\tpublic long nextLong() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic double nextDouble() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n\n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n\n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n        } \n        public boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n    }\n", "index": 431, "complexity": 5}
{"back-translation": "class MinimumDistance {\n\n    int minDist(int[] arr, int n, int x, int y) {\n\n        int i, j;\n\n        int min_dist = Integer.MAX_VALUE;\n\n        for(i = 0; i < n; i++) {\n\n            for(j = i + 1; j < n; j++) {\n\n                if((x == arr[i] && y == arr[j] || y == arr[i] && x == arr[j]) && min_dist > Math.abs(i - j))\n\n                    min_dist = Math.abs(i - j);\n\n            }\n\n        }\n\n        return min_dist;\n\n    }\n\n\n    public static void main(String[] args) {\n\n        MinimumDistance min = new MinimumDistance();\n\n        int arr[] = {3, 5, 4, 2, 6, 5, 6, 6, 5, 4, 8, 3};\n\n        int n = arr.length;\n\n        int x = 3;\n\n        int y = 6;\n\n\n        System.out.println(\"Minimum distance between \" + x + \" and \" + y + \" is \" + min.minDist(arr, n, x, y));\n\n    }\n}", "src": "\n// Java Program to Find the minimum \n// distance between two numbers \nclass\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni, j; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nfor\n(j = i + \n1\n; j < n; j++) \n\n{ \n\nif\n((x == arr[i] && y == arr[j] \n\n|| y == arr[i] && x == arr[j]) \n\n&& min_dist > Math.abs(i - j)) \n\nmin_dist = Math.abs(i - j); \n\n} \n\n} \n\nreturn\nmin_dist; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n5\n, \n6\n, \n6\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n} ", "index": 432, "complexity": 5}
{"back-translation": "ERROR", "src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.System.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t// out.println(\"---- \"+arr[i]);\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// out.println(list.toString());\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// out.println(list.toString());\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "index": 433, "complexity": 5}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] v = new int[n];\n        int[] ans = new int[n];\n        long s = 0;\n        int t;\n        for(int i=0; i<n;i++) {\n            v[i] = in.nextInt();\n            s+=v[i];\n        }\n\n        for(int i=0; i<n-1;i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (v[j] > v[i]) {\n                    t = v[i];\n                    v[i] = v[j];\n                    v[j] = t;\n                }\n            }\n        }\n\n        for(int i=0; i<n-1; i++){\n            if(v[i] > v[i+1]){\n                ans[i] = v[i]-v[i+1];\n            }\n\n            if(v[i] == v[i+1] && v[i]!=1){\n                ans[i]=1;\n                v[i+1]--;\n            }\n\n            if(v[i] < v[i+1]){\n                ans[i]=1;\n                v[i+1] = v[i]-1;\n                if(v[i+1] == 0){\n                    v[i+1] = 1;\n                }\n            }\n            if(v[i] == 0 || v[i] == 1){\n                ans[i] = 1;\n                v[i] = 1;\n            }\n        }\n        if (v[n-1] > 1){\n            ans[n-1] = v[n-1];\n        }\n        else{\n            ans[n-1] = 1;\n        }\n\n        for (int i=0; i<n; i++){\n            s-=ans[i];\n        }\n        System.out.print(s);\n\n    }\n}", "src": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] v = new int[n];\n        int[] ans = new int[n];\n        long s = 0;\n        int t;\n        for(int i=0; i<n;i++) {\n            v[i] = in.nextInt();\n            s+=v[i];\n        }\n\n        for(int i=0; i<n-1;i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (v[j] > v[i]) {\n                    t = v[i];\n                    v[i] = v[j];\n                    v[j] = t;\n                }\n            }\n        }\n\n        for(int i=0; i<n-1; i++){\n            if(v[i] > v[i+1]){\n                    ans[i] = v[i]-v[i+1];\n            }\n\n            if(v[i] == v[i+1] && v[i]!=1){\n                ans[i]=1;\n                v[i+1]--;\n            }\n\n            if(v[i] < v[i+1]){\n                ans[i]=1;\n                v[i+1] = v[i]-1;\n                if(v[i+1] == 0){\n                    v[i+1] = 1;\n                }\n            }\n            if(v[i] == 0 || v[i] == 1){\n                ans[i] = 1;\n                v[i] = 1;\n            }\n        }\n        if (v[n-1] > 1){\n            ans[n-1] = v[n-1];\n        }\n        else{\n            ans[n-1] = 1;\n        }\n\n        for (int i=0; i<n; i++){\n                s-=ans[i];\n\n        }\n        System.out.print(s);\n\n\n    }\n}", "index": 435, "complexity": 5}
{"back-translation": "class LBS { static int lbs(int arr[], int n) { int i, j; int[] lis = new int[n]; for (i = 0; i < n; i++) lis[i] = 1; for (i = 1; i < n; i++) for (j = 0; j < i; j++) if (arr[i] > arr[j] && lis[i] < lis[j] + 1) lis[i] = lis[j] + 1; int[] lds = new int[n]; for (i = 0; i < n; i++) lds[i] = 1; for (i = n - 2; i >= 0; i--) for (j = n - 1; j > i; j--) if (arr[i] > arr[j] && lds[i] < lds[j] + 1) lds[i] = lds[j] + 1; int max = lis[0] + lds[0] - 1; for (i = 1; i < n; i++) if (lis[i] + lds[i] - 1 > max) max = lis[i] + lds[i] - 1; return max; } public static void main(String[] args) { int arr[] = { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 }; int n = arr.length; System.out.println(\"Length of LBS is \" + lbs(arr, n)); } }", "src": "\n/* Dynamic Programming implementation in Java for longest bitonic \n\nsubsequence problem */\nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nLBS \n{ \n\n/* lbs() returns the length of the Longest Bitonic Subsequence in \n\narr[] of size n. The function mainly creates two temporary arrays \n\nlis[] and lds[] and returns the maximum lis[i] + lds[i] - 1. \n\n\nlis[i] ==> Longest Increasing subsequence ending with arr[i] \n\nlds[i] ==> Longest decreasing subsequence starting with arr[i] \n\n*/\n\nstatic\nint\nlbs( \nint\narr[], \nint\nn ) \n\n{ \n\nint\ni, j; \n\n\n/* Allocate memory for LIS[] and initialize LIS values as 1 for \n\nall indexes */\n\nint\n[] lis = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlis[i] = \n1\n; \n\n\n/* Compute LIS values from left to right */\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && lis[i] < lis[j] + \n1\n) \n\nlis[i] = lis[j] + \n1\n; \n\n\n/* Allocate memory for lds and initialize LDS values for \n\nall indexes */\n\nint\n[] lds = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlds[i] = \n1\n; \n\n\n/* Compute LDS values from right to left */\n\nfor\n(i = n-\n2\n; i >= \n0\n; i--) \n\nfor\n(j = n-\n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && lds[i] < lds[j] + \n1\n) \n\nlds[i] = lds[j] + \n1\n; \n\n\n\n/* Return the maximum value of lis[i] + lds[i] - 1*/\n\nint\nmax = lis[\n0\n] + lds[\n0\n] - \n1\n; \n\nfor\n(i = \n1\n; i < n; i++) \n\nif\n(lis[i] + lds[i] - \n1\n> max) \n\nmax = lis[i] + lds[i] - \n1\n; \n\n\nreturn\nmax; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n0\n, \n8\n, \n4\n, \n12\n, \n2\n, \n10\n, \n6\n, \n14\n, \n1\n, \n9\n, \n5\n, \n\n13\n, \n3\n, \n11\n, \n7\n, \n15\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of LBS is \"\n+ lbs( arr, n )); \n\n} \n} ", "index": 437, "complexity": 5}
{"back-translation": "class GFG { static int CountPS(char str[], int n) { int dp[][] = new int[n][n]; boolean P[][] = new boolean[n][n]; for (int i = 0; i < n; i++) P[i][i] = true; for (int i = 0; i < n - 1; i++) { if (str[i] == str[i + 1]) { P[i][i + 1] = true; dp[i][i + 1] = 1; } } for (int gap = 2; gap < n; gap++) { for (int i = 0; i < n - gap; i++) { int j = gap + i; if (str[i] == str[j] && P[i + 1][j - 1]) P[i][j] = true; if (P[i][j]) dp[i][j] = dp[i][j - 1] + dp[i + 1][j] + 1 - dp[i + 1][j - 1]; else dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]; } } return dp[0][n - 1]; } public static void main(String[] args) { String str = \"abaab\"; System.out.println(CountPS(str.toCharArray(), str.length())); } }", "src": "\n// Java program to find palindromic substrings of a string \n\npublic\nclass\nGFG \n{ \n\n// Returns total number of palindrome substring of \n\n// length greater then equal to 2 \n\nstatic\nint\nCountPS(\nchar\nstr[], \nint\nn) \n\n{ \n\n// create empty 2-D matrix that counts all palindrome \n\n// substring. dp[i][j] stores counts of palindromic \n\n// substrings in st[i..j] \n\nint\ndp[][] = \nnew\nint\n[n][n]; \n\n\n// P[i][j] = true if substring str[i..j] is palindrome, \n\n// else false \n\nboolean\nP[][] = \nnew\nboolean\n[n][n]; \n\n\n// palindrome of single length \n\nfor\n(\nint\ni= \n0\n; i< n; i++) \n\nP[i][i] = \ntrue\n; \n\n\n// palindrome of length 2 \n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\nif\n(str[i] == str[i+\n1\n]) \n\n{ \n\nP[i][i+\n1\n] = \ntrue\n; \n\ndp[i][i+\n1\n] = \n1\n; \n\n} \n\n} \n\n\n// Palindromes of length more than 2. This loop is similar \n\n// to Matrix Chain Multiplication. We start with a gap of \n\n// length 2 and fill the DP table in a way that gap between \n\n// starting and ending indexes increases one by one by \n\n// outer loop. \n\nfor\n(\nint\ngap=\n2\n; gap<n; gap++) \n\n{ \n\n// Pick starting point for current gap \n\nfor\n(\nint\ni=\n0\n; i<n-gap; i++) \n\n{ \n\n// Set ending point \n\nint\nj = gap + i; \n\n\n// If current string is palindrome \n\nif\n(str[i] == str[j] && P[i+\n1\n][j-\n1\n] ) \n\nP[i][j] = \ntrue\n; \n\n\n// Add current palindrome substring ( + 1) \n\n// and rest palindrome substring (dp[i][j-1] + dp[i+1][j]) \n\n// remove common palindrome substrings (- dp[i+1][j-1]) \n\nif\n(P[i][j] == \ntrue\n) \n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] + \n1\n- dp[i+\n1\n][j-\n1\n]; \n\nelse\n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] - dp[i+\n1\n][j-\n1\n]; \n\n} \n\n} \n\n\n// return total palindromic substrings \n\nreturn\ndp[\n0\n][n-\n1\n]; \n\n} \n\n\n// Driver Method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"abaab\"\n; \n\nSystem.out.println(CountPS(str.toCharArray(), str.length())); \n\n} \n} ", "index": 441, "complexity": 5}
{"back-translation": "//Atcoder\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        int maxI = 0;\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                maxI = i;\n            }\n        }\n\n        pw.println(maxI);\n        pw.close();\n    }\n}\n", "src": "//Atcoder\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}\n", "index": 443, "complexity": 5}
{"back-translation": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class TestClass {\n    public static int set_size(int[] a, int N) {\n        HashSet<Integer> newset = new HashSet<Integer>();\n        int i = 0;\n        while (i < N) {\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[]) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tk = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(tk.nextToken());\n        int x = Integer.parseInt(tk.nextToken());\n        int[] a = new int[N];\n        int[] b = new int[N];\n        StringTokenizer tb = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            a[i] = Integer.parseInt(tb.nextToken());\n        }\n        if (set_size(a, N) < N) {\n            System.out.print(\"0\");\n            System.exit(0);\n        }\n        int num = 0;\n        while (num++ < 4) {\n            for (int i = 0; i < N; i++) {\n                if ((a[i] & x) == a[i])\n                    continue;\n                else {\n                    for (int j = 0; j < N; j++) {\n                        if (i == j) {\n                            b[i] = (a[i] & x);\n                        } else {\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if (s < N) {\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for (int i = 0; i < N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class TestClass {\n    // function for finding size of set\n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "index": 446, "complexity": 5}
{"back-translation": "public class LongestCommonSubSequence { static int LCSubStr(char X[], char Y[], int m, int n) { int LCStuff[][] = new int[m + 1][n + 1]; int result = 0; for (int i = 0; i <= m; i++) { for (int j = 0; j <= n; j++) { if (i == 0 || j == 0) LCStuff[i][j] = 0; else if (X[i - 1] == Y[j - 1]) { LCStuff[i][j] = LCStuff[i - 1][j - 1] + 1; result = Integer.max(result, LCStuff[i][j]); } else LCStuff[i][j] = 0; } } return result; } public static void main(String[] args) { String X = \"OldSite:GeeksforGeeks.org\"; String Y = \"NewSite:GeeksQuiz.com\"; int m = X.length(); int n = Y.length(); System.out.println(\"Length of Longest Common Substring is \" + LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); } }", "src": "\n// Java implementation of finding length of longest \n// Common substring using Dynamic Programming \npublic\nclass\nLongestCommonSubSequence \n{ \n\n/* \n\nReturns length of longest common substring \n\nof X[0..m-1] and Y[0..n-1] \n\n*/\n\nstatic\nint\nLCSubStr(\nchar\nX[], \nchar\nY[], \nint\nm, \nint\nn) \n\n{ \n\n// Create a table to store lengths of longest common suffixes of \n\n// substrings. Note that LCSuff[i][j] contains length of longest \n\n// common suffix of X[0..i-1] and Y[0..j-1]. The first row and \n\n// first column entries have no logical meaning, they are used only \n\n// for simplicity of program \n\nint\nLCStuff[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\nint\nresult = \n0\n; \n// To store length of the longest common substring \n\n\n// Following steps build LCSuff[m+1][n+1] in bottom up fashion \n\nfor\n(\nint\ni = \n0\n; i <= m; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\n{ \n\nif\n(i == \n0\n|| j == \n0\n) \n\nLCStuff[i][j] = \n0\n; \n\nelse\nif\n(X[i - \n1\n] == Y[j - \n1\n]) \n\n{ \n\nLCStuff[i][j] = LCStuff[i - \n1\n][j - \n1\n] + \n1\n; \n\nresult = Integer.max(result, LCStuff[i][j]); \n\n} \n\nelse\n\nLCStuff[i][j] = \n0\n; \n\n} \n\n} \n\nreturn\nresult; \n\n} \n\n\n// Driver Program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString X = \n\"OldSite:GeeksforGeeks.org\"\n; \n\nString Y = \n\"NewSite:GeeksQuiz.com\"\n; \n\n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\nSystem.out.println(\n\"Length of Longest Common Substring is \"\n\n+ LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); \n\n} \n} \n\n// This code is contributed by Sumit Ghosh ", "index": 447, "complexity": 5}
{"back-translation": "public class GFG { public static void splitArr(int[] arr, int n, int k) { for (int i = 0; i < k; i++) { int x = arr[0]; for (int j = 0; j < n - 1; ++j) arr[j] = arr[j + 1]; arr[n - 1] = x; } } public static void main(String[] args) { int[] arr = { 12, 10, 5, 6, 52, 36 }; int n = arr.length; int position = 2; splitArr(arr, 6, position); for (int i = 0; i < n; ++i) System.out.print(arr[i] + \" \"); } }", "src": "\n// Java program to split array and move first \n// part to end. \n\nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nGFG { \n\npublic\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < k; i++) { \n\n\n// Rotate array by 1. \n\nint\nx = arr[\n0\n]; \n\nfor\n(\nint\nj = \n0\n; j < n - \n1\n; ++j) \n\narr[j] = arr[j + \n1\n]; \n\narr[n - \n1\n] = x; \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nsplitArr(arr, \n6\n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} \n\n// Code Contributed by Mohit Gupta_OMG <(0_o)> ", "index": 448, "complexity": 5}
{"back-translation": "class GFG { static int lookup[][] = new int[1000][1000]; static int countSeqUtil(int n, int dif) { if (Math.abs(dif) > n) return 0; if (n == 1 && dif == 0) return 2; if (n == 1 && Math.abs(dif) == 1) return 1; if (lookup[n][n + dif] != -1) return lookup[n][n + dif]; int res = countSeqUtil(n - 1, dif + 1) + 2 * countSeqUtil(n - 1, dif) + countSeqUtil(n - 1, dif - 1); return lookup[n][n + dif] = res; } static int countSeq(int n) { for (int k = 0; k < lookup.length; k++) { for (int j = 0; j < lookup.length; j++) { lookup[k][j] = -1; } } return countSeqUtil(n, 0); } public static void main(String[] args) { int n = 2; System.out.println(\"Count of sequences is \" + countSeq(2)); } }", "src": "\n// A memoization based Java program to \n// count even length binary sequences \n// such that the sum of first and \n// second half bits is same \nimport\njava.io.*; \n\nclass\nGFG { \n\n// A lookup table to store the results of \n// subproblems \nstatic\nint\nlookup[][] = \nnew\nint\n[\n1000\n][\n1000\n]; \n\n// dif is diference between sums of first \n// n bits and last n bits i.e., \n// dif = (Sum of first n bits) - (Sum of last n bits) \nstatic\nint\ncountSeqUtil(\nint\nn, \nint\ndif) \n{ \n\n// We can't cover diference of \n\n// more than n with 2n bits \n\nif\n(Math.abs(dif) > n) \n\nreturn\n0\n; \n\n\n// n == 1, i.e., 2 bit long sequences \n\nif\n(n == \n1\n&& dif == \n0\n) \n\nreturn\n2\n; \n\nif\n(n == \n1\n&& Math.abs(dif) == \n1\n) \n\nreturn\n1\n; \n\n\n// Check if this subbproblem is already \n\n// solved n is added to dif to make \n\n// sure index becomes positive \n\nif\n(lookup[n][n+dif] != -\n1\n) \n\nreturn\nlookup[n][n+dif]; \n\n\nint\nres = \n// First bit is 0 & last bit is 1 \n\ncountSeqUtil(n-\n1\n, dif+\n1\n) + \n\n\n// First and last bits are same \n\n2\n*countSeqUtil(n-\n1\n, dif) + \n\n\n// First bit is 1 & last bit is 0 \n\ncountSeqUtil(n-\n1\n, dif-\n1\n); \n\n\n// Store result in lookup table \n\n// and return the result \n\nreturn\nlookup[n][n+dif] = res; \n} \n\n// A Wrapper over countSeqUtil(). It mainly \n// initializes lookup table, then calls \n// countSeqUtil() \nstatic\nint\ncountSeq(\nint\nn) \n{ \n\n// Initialize all entries of lookup \n\n// table as not filled \n\n// memset(lookup, -1, sizeof(lookup)); \n\nfor\n(\nint\nk = \n0\n; k < lookup.length; k++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < lookup.length; j++) \n\n{ \n\nlookup[k][j] = -\n1\n; \n\n} \n\n} \n\n\n// call countSeqUtil() \n\nreturn\ncountSeqUtil(n, \n0\n); \n} \n\n// Driver program \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Count of sequences is \"\n\n+ countSeq(\n2\n)); \n} \n} \n\n// This code is contributed by Prerna Saini ", "index": 450, "complexity": 5}
{"back-translation": "import java.io.*; public class GFG { static int countNonEmptySubstr(String str) { int n = str.length(); return n + (n * (n - 1)) / 2; } public static void main(String args[]) { String s = \"abcde\"; System.out.println(countNonEmptySubstr(s)); } }", "src": "\n// Java program to count number of substrings \n// of a string \nimport\njava.io.*; \n\npublic\nclass\nGFG { \n\n\nstatic\nint\ncountNonEmptySubstr(String str) \n\n{ \n\nint\nn = str.length(); \n\nreturn\nn * (n + \n1\n) / \n2\n; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcde\"\n; \n\nSystem.out.println( \n\ncountNonEmptySubstr(s)); \n\n} \n} \n\n// This code is contributed \n// by Manish Shaw (manishshaw1) ", "index": 451, "complexity": 5}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint[] arr = new int [n];\n\t\tint maxindex=0;\n\t\tint minindex=0;\n\t\tint max;\n\t\tint min;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tarr[i]=sc.nextInt();\n\t\t}\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tfor(int j=i;j<arr.length;j++) {\n\t\t\t\tif(i!=j) {\n\t\t\t\t\tint k1=Math.min(arr[i], arr[j])/Math.abs(i-j);\n\t\t\t\t\tif(k1<k) {\n\t\t\t\t\t\tk = k1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(k);\n\t}\n\n}", "src": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint[] arr = new int [n];\n\t\tint maxindex=0;\n\t\tint minindex=0;\n\t\tint max;\n\t\tint min;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tarr[i]=sc.nextInt();\n\t\t}\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tfor(int j=i;j<arr.length;j++) {\n\t\t\t\tif(i!=j) {\n\t\t\t\t\tint k1=Math.min(arr[i], arr[j])/Math.abs(i-j);\n\t\t\t\t\tif(k1<k) {\n\t\t\t\t\t\tk = k1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(k);\n\t}\n\n}", "index": 452, "complexity": 5}
{"back-translation": "import java.util.*;\n\npublic class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '\\';\n    }\n}", "src": "//\n//                                  _oo8oo_\n//                                 o8888888o\n//                                 88\" . \"88\n//                                 (| -_- |)\n//                                 0\\  =  /0\n//                               ___/'==='\\___\n//                             .' \\\\|     |// '.\n//                            / \\\\|||  :  |||// \\\n//                           / _||||| -:- |||||_ \\\n//                          |   | \\\\\\  -  /// |   |\n//                          | \\_|  ''\\---/''  |_/ |\n//                          \\  .-\\__  '-'  __/-.  /\n//                        ___'. .'  /--.--\\  '. .'___\n//                     .\"\" '<  '.___\\_<|>_/___.'  >' \"\".\n//                    | | :  `- \\`.:`\\ _ /`:.`/ -`  : | |\n//                    \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n//                =====`-.____`.___ \\_____/ ___.`____.-`=====\n//                                  `=---=`\n//\n//\n//               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//                          \u4f5b\u7956\u4fdd\u4f51         \u6c38\u4e0d\u5b95\u673a/\u6c38\u65e0bug\n//\n\nimport java.util.*;\n\npublic class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n//        System.out.println(Arrays.toString(list.toArray()));\n//        if (list.size() < n) {\n//            System.out.println(0);\n//        } else {\n//            System.out.println(list.get(n - 1).num);\n//        }\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}\n", "index": 453, "complexity": 5}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\npublic class A01Easy {\n    private static interface Matrix {\n        boolean get(int i, int j);\n        int size();\n    }\n    private static class MData implements Matrix {\n        private final boolean[][] m;\n        MData(boolean[][] m) {\n            this.m = m;\n        }\n        @Override\n        public boolean get(int i, int j) {\n            return m[i][j];\n        }\n        @Override\n        public int size() {\n            return m.length;\n        }\n    }\n    private static abstract class MDecorator implements Matrix {\n        protected final Matrix inner;\n        MDecorator(Matrix inner) {\n            this.inner = inner;\n        }\n        @Override\n        public int size() {\n            return inner.size();\n        }\n    }\n    private static class MHFlip extends MDecorator {\n        MHFlip(Matrix inner) {\n            super(inner);\n        }\n        @Override\n        public boolean get(int i, int j) {\n            return inner.get(size() - 1 - i, j);\n        }\n    }\n    private static class MVFlip extends MDecorator {\n        MVFlip(Matrix inner) {\n            super(inner);\n        }\n        @Override\n        public boolean get(int i, int j) {\n            return inner.get(i, size() - 1 - j);\n        }\n    }\n    private static class MRot extends MDecorator {\n        MRot(Matrix inner) {\n            super(inner);\n        }\n        @Override\n        public boolean get(int i, int j) {\n            return inner.get(j, size() - 1 - i);\n        }\n    }\n    public static void main(String[] args) {\n        try (BufferedReader r = new BufferedReader(new InputStreamReader(System.in))) {\n            final int N = Integer.parseInt(r.readLine());\n            Matrix m1 = readMatrix(r, N), m2 = readMatrix(r, N);\n            boolean matched = matchesFlipped(m1, m2);\n            int i = 0;\n            while (i < 3 && !matched) {\n                m1 = new MRot(m1);\n                matched = matchesFlipped(m1, m2);\n                i++;\n            }\n            System.out.println(matched ? \"Yes\" : \"No\");\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    private static Matrix readMatrix(BufferedReader r, int n) throws IOException {\n        boolean[][] m = new boolean[n][n];\n        for (int i = 0; i < n; i++) {\n            String line = r.readLine();\n            for (int j = 0; j < n; j++) {\n                m[i][j] = line.charAt(j) == 'X';\n            }\n        }\n        return new MData(m);\n    }\n    private static boolean matches(Matrix m1, Matrix m2) {\n        int i = 0, j = 0, n = m1.size();\n        while (i < n && m1.get(i, j) == m2.get(i, j)) {\n            j++;\n            if (j == n) {\n                j = 0;\n                i++;\n            }\n        }\n        return i == n;\n    }\n    private static boolean matchesFlipped(Matrix m1, Matrix m2) {\n        return matches(m1, m2) || matches(new MHFlip(m1), m2) || matches(new MVFlip(m1), m2);\n    }\n}", "src": "/*\n * Created on 17.05.2019\n */\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * @author Wolfgang Weck\n */\npublic class A01Easy {\n\tprivate static interface Matrix {\n\t\tboolean get(int i, int j);\n\n\t\tint size();\n\t}\n\n\tprivate static class MData implements Matrix {\n\t\tprivate final boolean[][] m;\n\n\t\tMData(boolean[][] m) {\n\t\t\tthis.m = m;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn m[i][j];\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn m.length;\n\t\t}\n\t}\n\n\tprivate static abstract class MDecorator implements Matrix {\n\t\tprotected final Matrix inner;\n\n\t\tMDecorator(Matrix inner) {\n\t\t\tthis.inner = inner;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn inner.size();\n\t\t}\n\t}\n\n\tprivate static class MHFlip extends MDecorator {\n\t\tMHFlip(Matrix inner) {\n\t\t\tsuper(inner);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn inner.get(size() - 1 - i, j);\n\t\t}\n\t}\n\n\tprivate static class MVFlip extends MDecorator {\n\t\tMVFlip(Matrix inner) {\n\t\t\tsuper(inner);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn inner.get(i, size() - 1 - j);\n\t\t}\n\t}\n\n\tprivate static class MRot extends MDecorator {\n\t\tMRot(Matrix inner) {\n\t\t\tsuper(inner);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int i, int j) {\n\t\t\treturn inner.get(j, size() - 1 - i);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry (BufferedReader r = new BufferedReader(new InputStreamReader(System.in))) {\n\t\t\tfinal int N = Integer.parseInt(r.readLine());\n\t\t\tMatrix m1 = readMatrix(r, N), m2 = readMatrix(r, N);\n\t\t\tboolean matched = matchesFlipped(m1, m2);\n\t\t\tint i = 0;\n\t\t\twhile (i < 3 && !matched) {\n\t\t\t\tm1 = new MRot(m1);\n\t\t\t\tmatched = matchesFlipped(m1, m2);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tSystem.out.println(matched ? \"Yes\" : \"No\");\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate static Matrix readMatrix(BufferedReader r, int n) throws IOException {\n\t\tboolean[][] m = new boolean[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString line = r.readLine();\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tm[i][j] = line.charAt(j) == 'X';\n\t\t\t}\n\t\t}\n\t\treturn new MData(m);\n\t}\n\n\tprivate static boolean matches(Matrix m1, Matrix m2) {\n\t\tint i = 0, j = 0, n = m1.size();\n\t\twhile (i < n && m1.get(i, j) == m2.get(i, j)) {\n\t\t\tj++;\n\t\t\tif (j == n) {\n\t\t\t\tj = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn i == n;\n\t}\n\n\tprivate static boolean matchesFlipped(Matrix m1, Matrix m2) {\n\t\treturn matches(m1, m2) || matches(new MHFlip(m1), m2) || matches(new MVFlip(m1), m2);\n\t}\n}\n", "index": 454, "complexity": 5}
{"back-translation": "public class Test {\n\n    static int countPairs(String str) {\n        int result = 0;\n        int n = str.length();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(str.charAt(i) - str.charAt(j)) == Math.abs(i - j)) {\n                    result++;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String args[]) {\n        String str = \"geeksforgeeks\";\n        System.out.println(countPairs(str));\n    }\n}", "src": "\n// A Simple Java program to find pairs with distance \n// equal to English alphabet distance \nclass\nTest { \n\n\n// Method to count pairs \n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n\n// Increment count if characters \n\n// are at same distance \n\nif\n(Math.abs(str.charAt(i) - str.charAt(j)) == \n\nMath.abs(i - j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n} ", "index": 455, "complexity": 5}
{"back-translation": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class RookHome {\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tlong[] vert = new long[n + 2];\n\t\tvert[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tvert[i] = s.nextLong();\n\t\t}\n\t\tvert[n + 1] = 1000000000;\n\t\tlong[][] hor = new long[m][2];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\thor[i][0] = s.nextLong();\n\t\t\thor[i][1] = s.nextLong();\n\t\t\ts.nextLong();\n\t\t}\n\t\tlong min = Long.MAX_VALUE;\n\t\tint count;\n\t\tfor (int i = 0; i < vert.length - 1; i++) {\n\t\t\tcount = 0;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (hor[j][0] <= vert[i] && hor[j][1] >= vert[i + 1]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = Math.min(min, i + count);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}\n", "src": "import java.io.BufferedInputStream;\nimport java.util.Scanner;\n\npublic class RookHome {\n\tstatic long MAX = 1_000_000_000;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(new BufferedInputStream(System.in));\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tlong[] vert = new long[n + 2];\n\t\tvert[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tvert[i] = s.nextLong();\n\t\t}\n\t\tvert[n + 1] = MAX;\n\t\tlong[][] hor = new long[m][2];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\thor[i][0] = s.nextLong();\n\t\t\thor[i][1] = s.nextLong();\n\t\t\ts.nextLong();\n\t\t}\n\t\tlong min = Long.MAX_VALUE;\n\t\tint count;\n\t\tfor(int i = 0; i < vert.length - 1; i++) {\n\t\t\tcount = 0;\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(hor[j][0] <= vert[i] && hor[j][1] >= vert[i + 1]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = Math.min(min, i + count);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}\n", "index": 456, "complexity": 5}
{"back-translation": "//package ContestEd69;\n\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class mainD {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n    public static long[] arr;\n\n    public static void main(String[] args) throws IOException {\n        int n = enter.nextInt();\n        int m = enter.nextInt();\n        long k = enter.nextLong();\n        arr = new long[n + 1];\n\n        for (int i = 1; i < n + 1; i++) {\n            arr[i] = enter.nextLong();\n        }\n\n        long[] summ = new long[n + 1];\n\n        for (int i = 1; i < n + 1; i++) {\n            summ[i] += arr[i] + summ[i - 1];\n        }\n\n        long[] best = new long[n + 1];\n\n        for (int i = 1; i < n + 1; i++) {\n            best[i] = Math.max(0, ((i - m >= 0) ? best[i - m] + summ[i] - summ[i - m] - k : 0));\n        }\n\n        long ans = best[1];\n\n        for (int i = 1; i < n + 1; i++) {\n            ans = Math.max(ans, best[i]);\n            for (int j = 1; j < m; j++) {\n                ans = Math.max(ans, ((i - j >= 0) ? best[i - j] - k + summ[i] - summ[i - j] : 0));\n            }\n        }\n\n        System.out.println(ans);\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}", "src": "//package ContestEd69;\n\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class mainD {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n    public static long[] arr;\n    public static void main(String[] args) throws IOException {\n        int n=enter.nextInt();\n        int m=enter.nextInt();\n        long k=enter.nextLong();\n        arr=new long[n+1];\n        for (int i = 1; i <n+1 ; i++) {\n            arr[i]=enter.nextLong();\n        }\n        long[] summ=new long[n+1];\n        for (int i = 1; i <n+1 ; i++) {\n            summ[i]+=arr[i]+summ[i-1];\n        }\n\n        long[] best=new long[n+1];\n\n        for (int i = 1; i <n+1 ; i++) {\n            best[i]=Math.max(0, ((i-m>=0) ? best[i-m]+summ[i]-summ[i-m]-k:0));\n        }\n        long ans=best[1];\n\n        for (int i = 1; i <n+1 ; i++) {\n            ans=Math.max(ans,best[i]);\n            for (int j = 1; j <m ; j++) {\n                ans=Math.max(ans, ((i-j>=0) ? best[i-j] -k +summ[i]-summ[i-j]:0));\n            }\n        }\n        System.out.println(ans);\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}\n", "index": 457, "complexity": 5}
{"back-translation": "public class GFG { static void spiralPrint(int m, int n, int[][] a) { int i, k = 0, l = 0; while(k < m && l < n) { for(i = l; i < n; ++i) { System.out.print(a[k][i] + \" \"); } k++; for(i = k; i < m; ++i) { System.out.print(a[i][n - 1] + \" \"); } n--; if(k < m) { for(i = n - 1; i >= l; --i) { System.out.print(a[m - 1][i] + \" \"); } m--; } if(l < n) { for(i = m - 1; i >= k; --i) { System.out.print(a[i][l] + \" \"); } l++; } } } public static void main(String[] args) { int R = 3; int C = 6; int a[][] = { { 1, 2, 3, 4, 5, 6}, { 7, 8, 9, 10, 11, 12}, { 13, 14, 15, 16, 17, 18} }; spiralPrint(R, C, a); } }", "src": "\n// Java program to print a given matrix in spiral form \nimport\njava.io.*; \n\nclass\nGFG { \n\n// Function print matrix in spiral form \n\nstatic\nvoid\nspiralPrint(\nint\nm, \nint\nn, \nint\na[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n/* k - starting row index \n\nm - ending row index \n\nl - starting column index \n\nn - ending column index \n\ni - iterator \n\n*/\n\n\nwhile\n(k < m && l < n) { \n\n// Print the first row from the remaining rows \n\nfor\n(i = l; i < n; ++i) { \n\nSystem.out.print(a[k][i] + \n\" \"\n); \n\n} \n\nk++; \n\n\n// Print the last column from the remaining columns \n\nfor\n(i = k; i < m; ++i) { \n\nSystem.out.print(a[i][n - \n1\n] + \n\" \"\n); \n\n} \n\nn--; \n\n\n// Print the last row from the remaining rows */ \n\nif\n(k < m) { \n\nfor\n(i = n - \n1\n; i >= l; --i) { \n\nSystem.out.print(a[m - \n1\n][i] + \n\" \"\n); \n\n} \n\nm--; \n\n} \n\n\n// Print the first column from the remaining columns */ \n\nif\n(l < n) { \n\nfor\n(i = m - \n1\n; i >= k; --i) { \n\nSystem.out.print(a[i][l] + \n\" \"\n); \n\n} \n\nl++; \n\n} \n\n} \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nR = \n3\n; \n\nint\nC = \n6\n; \n\nint\na[][] = { { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}, \n\n{ \n7\n, \n8\n, \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n, \n17\n, \n18\n} }; \n\nspiralPrint(R, C, a); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "index": 458, "complexity": 5}
{"back-translation": "class Node { int data; Node left, right; public Node(int d) { data = d; left = right = null; } } class BinaryTree { Node root; void printSpiral(Node node) { int h = height(node); int i; boolean ltr = false; for (i = 1; i <= h; i++) { printGivenLevel(node, i, ltr); ltr = !ltr; } } int height(Node node) { if (node == null) return 0; else { int lheight = height(node.left); int rheight = height(node.right); if (lheight > rheight) return (lheight + 1); else return (rheight + 1); } } void printGivenLevel(Node node, int level, boolean ltr) { if (node == null) return; if (level == 1) System.out.print(node.data + \" \"); else if (level > 1) { if (ltr != false) { printGivenLevel(node.left, level - 1, ltr); printGivenLevel(node.right, level - 1, ltr); } else { printGivenLevel(node.right, level - 1, ltr); printGivenLevel(node.left, level - 1, ltr); } } } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(7); tree.root.left.right = new Node(6); tree.root.right.left = new Node(5); tree.root.right.right = new Node(4); System.out.println(\"Spiral order traversal of Binary Tree is \"); tree.printSpiral(tree.root); } }", "src": "\n// Java program for recursive level order traversal in spiral form \n\n/* A binary tree node has data, pointer to left child \n\nand a pointer to right child */\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n// Function to print the spiral traversal of tree \n\nvoid\nprintSpiral(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\n\n/* ltr -> left to right. If this variable is set then the \n\ngiven label is traversed from left to right */\n\nboolean\nltr = \nfalse\n; \n\nfor\n(i = \n1\n; i <= h; i++) { \n\nprintGivenLevel(node, i, ltr); \n\n\n/*Revert ltr to traverse next level in opposite order*/\n\nltr = !ltr; \n\n} \n\n} \n\n\n/* Compute the \"height\" of a tree -- the number of \n\nnodes along the longest path from the root node \n\ndown to the farthest leaf node.*/\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n{ \n\n\n/* compute the height of each subtree */\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n/* use the larger one */\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n/* Print nodes at a given level */\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel, \nboolean\nltr) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) { \n\nif\n(ltr != \nfalse\n) { \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\n} \n\nelse\n{ \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\n} \n\n} \n\n} \n\n/* Driver program to test the above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(tree.root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "index": 461, "complexity": 5}
{"back-translation": "class Test { static int arr1[] = {1, 2, 3, 8, 9, 10}; static int arr2[] = {5, 13, 15, 20}; static void merge(int m, int n) { for (int i = n - 1; i >= 0; i--) { int j, last = arr1[m - 1]; for (j = m - 2; j >= 0 && arr1[j] > arr2[i]; j--) arr1[j + 1] = arr1[j]; if (j != m - 2 || last > arr2[i]) { arr1[j + 1] = arr2[i]; arr2[i] = last; } } } public static void main(String[] args) { merge(arr1.length, arr2.length); System.out.print(\"After Merging First Array: \"); System.out.println(Arrays.toString(arr1)); System.out.print(\"Second Array: \"); System.out.println(Arrays.toString(arr2)); } }", "src": "\n// Java program program to merge two \n// sorted arrays with O(1) extra space. \n\nimport\njava.util.Arrays; \n\nclass\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n1\n, \n5\n, \n9\n, \n10\n, \n15\n, \n20\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n2\n, \n3\n, \n8\n, \n13\n}; \n\n\nstatic\nvoid\nmerge(\nint\nm, \nint\nn) \n\n{ \n\n// Iterate through all elements of ar2[] starting from \n\n// the last element \n\nfor\n(\nint\ni=n-\n1\n; i>=\n0\n; i--) \n\n{ \n\n/* Find the smallest element greater than ar2[i]. Move all \n\nelements one position ahead till the smallest greater \n\nelement is not found */\n\nint\nj, last = arr1[m-\n1\n]; \n\nfor\n(j=m-\n2\n; j >= \n0\n&& arr1[j] > arr2[i]; j--) \n\narr1[j+\n1\n] = arr1[j]; \n\n\n// If there was a greater element \n\nif\n(j != m-\n2\n|| last > arr2[i]) \n\n{ \n\narr1[j+\n1\n] = arr2[i]; \n\narr2[i] = last; \n\n} \n\n} \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nmerge(arr1.length,arr2.length); \n\nSystem.out.print(\n\"After Merging nFirst Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr1)); \n\nSystem.out.print(\n\"Second Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr2)); \n\n} \n} ", "index": 462, "complexity": 5}
{"back-translation": "class GFG { static int minJumps(int arr[], int n) { int[] jumps = new int[n]; int min; jumps[n - 1] = 0; for (int i = n - 2; i >= 0; i--) { if (arr[i] == 0) jumps[i] = Integer.MAX_VALUE; else if (arr[i] >= n - i - 1) jumps[i] = 1; else { min = Integer.MAX_VALUE; for (int j = i + 1; j < n && j <= arr[i] + i; j++) { if (min > jumps[j]) min = jumps[j]; } if (min != Integer.MAX_VALUE) jumps[i] = min + 1; else jumps[i] = min; } } return jumps[0]; } public static void main(String[] args) { int[] arr = {1, 3, 6, 1, 0, 9}; int size = arr.length; System.out.println(\"Minimum number of jumps to reach end is \" + minJumps(arr, size)); } }", "src": "\n// Java program to find Minimum \n// number of jumps to reach end \nclass\nGFG \n{ \n// Returns Minimum number \n// of jumps to reach end \nstatic\nint\nminJumps(\nint\narr[], \n\nint\nn) \n{ \n\n// jumps[0] will \n\n// hold the result \n\nint\n[] jumps = \nnew\nint\n[n]; \n\nint\nmin; \n\n\n// Minimum number of jumps \n\n// needed to reach last \n\n// element from last elements \n\n// itself is always 0 \n\njumps[n - \n1\n] = \n0\n; \n\n\n\n// Start from the second \n\n// element, move from right \n\n// to left and construct the \n\n// jumps[] array where jumps[i] \n\n// represents minimum number of \n\n// jumps needed to reach arr[m-1] \n\n// from arr[i] \n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\n{ \n\n// If arr[i] is 0 then arr[n-1] \n\n// can't be reached from here \n\nif\n(arr[i] == \n0\n) \n\njumps[i] = Integer.MAX_VALUE; \n\n\n// If we can direcly reach to \n\n// the end point from here then \n\n// jumps[i] is 1 \n\nelse\nif\n(arr[i] >= n - i - \n1\n) \n\njumps[i] = \n1\n; \n\n\n// Otherwise, to find out \n\n// the minimum number of \n\n// jumps needed to reach \n\n// arr[n-1], check all the \n\n// points reachable from \n\n// here and jumps[] value \n\n// for those points \n\nelse\n\n{ \n\n// initialize min value \n\nmin = Integer.MAX_VALUE; \n\n\n// following loop checks \n\n// with all reachable points \n\n// and takes the minimum \n\nfor\n(\nint\nj = i + \n1\n; j < n && \n\nj <= arr[i] + i; j++) \n\n{ \n\nif\n(min > jumps[j]) \n\nmin = jumps[j]; \n\n} \n\n\n// Handle overflow \n\nif\n(min != Integer.MAX_VALUE) \n\njumps[i] = min + \n1\n; \n\nelse\n\njumps[i] = min; \n// or Integer.MAX_VALUE \n\n} \n\n} \n\n\nreturn\njumps[\n0\n]; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\n[] arr = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Minimum number of\"\n+ \n\n\" jumps to reach end is \"\n+ \n\nminJumps(arr, size)); \n\n} \n} \n\n// This code is contributed by mits. ", "index": 463, "complexity": 5}
{"back-translation": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "src": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "index": 464, "complexity": 5}
{"back-translation": "import java.util.Comparator;import java.util.Scanner;import java.util.Arrays;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class main { static class Interval{ int start; int end; public Interval(int start,int end) { this.start=start; this.end=end; } } public static void main(String[] args) { Scanner in = new Scanner(System.in); long intervals = in.nextLong(); long x = in.nextLong(); long y = in.nextLong(); Interval []ints = new Interval[(int)intervals]; for(int i = 0;i<intervals;i++){ ints[i]=new Interval(in.nextInt(),in.nextInt()); } Arrays.sort(ints, Comparator.comparingInt(a -> a.start)); long count = 0; for(int i=0;i<ints.length;i++){ if(i>=0&&ints[i]!=null){ Interval cur1=ints[i]; for(int j=i+1;j<ints.length;j++){ if(ints[j]!=null){ Interval cur2=ints[j]; if(y*(cur2.start-cur1.end)<x){ if(cur1.start!=cur2.start&&cur1.end<cur2.start){ cur1.end=cur2.end; ints[j]=null; } }else break; } } count=(count+x)%1000000007; count+=(y*(cur1.end-cur1.start)%1000000007); count%=1000000007; } } System.out.println(count); } }", "src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class main {\nstatic\tclass Interval{\n\t\tint start;\n\t\tint end;\n\t\tpublic Interval(int start,int end) {\n\t\t\tthis.start=start;\n\t\t\tthis.end=end;\n\t\t}\n\t}\nstatic class FastReader \n{ \n    BufferedReader br; \n    StringTokenizer st; \n\n    public FastReader() \n    { \n        br = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    } \n\n    String next() \n    { \n        while (st == null || !st.hasMoreElements()) \n        { \n            try\n            { \n                st = new StringTokenizer(br.readLine()); \n            } \n            catch (IOException  e) \n            { \n                e.printStackTrace(); \n            } \n        } \n        return st.nextToken(); \n    } \n\n    int nextInt() \n    { \n        return Integer.parseInt(next()); \n    } \n\n    long nextLong() \n    { \n        return Long.parseLong(next()); \n    } \n\n    double nextDouble() \n    { \n        return Double.parseDouble(next()); \n    } \n\n    String nextLine() \n    { \n        String str = \"\"; \n        try\n        { \n            str = br.readLine(); \n        } \n        catch (IOException e) \n        { \n            e.printStackTrace(); \n        } \n        return str; \n    } \n} \n\tstatic long mod = 1000000007;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tFastReader in = new FastReader();\n\t\tlong intervals = in.nextInt();\n\t\tlong x = in.nextInt();\n\t\t long y = in.nextInt();\n\t\tInterval []ints = new Interval[(int)(int) intervals];\n\t\tfor(int i = 0;i<intervals;i++) {\n\t\t\tints[i] = new Interval(in.nextInt(),in.nextInt());\n\t\t}\n\t\tArrays.sort(ints, (a,b)->a.start-b.start);\n\t\tlong count = 0;\n\t\tfor(int i = 0;i<ints.length;i++) {\n\t\t\tif(i>=0&&ints[i]!=null) {\n\t\t\tInterval cur1 = ints[i];\n\t\t\tfor(int j = i+1;j<ints.length;j++) {\n\t\t\tif(ints[j]!=null) {\n\t\t\tInterval cur2 = ints[j];\n\t\t\tif(y*(cur2.start-cur1.end)<x) {\n\t\t\tif(cur1.start!=cur2.start&&cur1.end<cur2.start) {\n\t\t\t\tcur1.end=cur2.end;\n\t\t\t\t\n\t\t\t\tints[j]=null;\n\t\t\t//\ti--;\n\t\t\t}}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tcount = (count + x) % mod;\n\t\t\tcount += (y*(cur1.end-cur1.start)%mod);\n\t\t\tcount%=mod;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n//\t\tfor(int i = 0;i<ints.length;i++) {\n//\t\t\tif(ints[i]!=null) {\n//\t\t\tInterval cur = ints[i];\n//\t\t\tcount = (count + x) % mod;\n//\t\t\tcount += (y*(cur.end-cur.start)%mod);\n//\t\t\tcount%=mod;\n//\t\t\t}\n//\t\t}\n\t\tSystem.out.println(count);\n\t}\n\n}", "index": 465, "complexity": 5}
{"back-translation": "import java.io.*;\nclass GFG {\n    static void constructDp(int[][] dp, String str) {\n        int l = str.length();\n        int[][] isPalin = new int[l + 1][l + 1];\n        for (int i = 0; i <= l; i++) {\n            for (int j = 0; j <= l; j++) {\n                isPalin[i][j] = dp[i][j] = 0;\n            }\n        }\n        for (int i = l - 1; i >= 0; i--) {\n            isPalin[i][i] = 1;\n            dp[i][i] = 1;\n            for (int j = i + 1; j < l; j++) {\n                isPalin[i][j] = (str.charAt(i) == str.charAt(j) && (i + 1 > j - 1 || (isPalin[i + 1][j - 1]) != 0)) ? 1 : 0;\n                dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1] + isPalin[i][j];\n            }\n        }\n    }\n    static int countOfPalindromeInRange(int[][] dp, int l, int r) {\n        return dp[l][r];\n    }\n    public static void main(String args[]) {\n        int MAX = 50;\n        String str = \"xyaabax\";\n        int[][] dp = new int[MAX][MAX];\n        constructDp(dp, str);\n        int l = 3;\n        int r = 5;\n        System.out.println(countOfPalindromeInRange(dp, l, r));\n    }\n}", "src": "\n// Java program to query number of palindromic \n// substrings of a string in a range \nimport\njava.io.*; \n\nclass\nGFG { \n\n// Function to construct the dp array \n\nstatic\nvoid\nconstructDp(\nint\ndp[][], String str) \n\n{ \n\nint\nl = str.length(); \n\n\n// declare 2D array isPalin, isPalin[i][j] will \n\n// be 1 if str(i..j) is palindrome \n\nint\n[][] isPalin = \nnew\nint\n[l + \n1\n][l + \n1\n]; \n\n\n// initialize dp and isPalin array by zeros \n\nfor\n(\nint\ni = \n0\n; i <= l; i++) { \n\nfor\n(\nint\nj = \n0\n; j <= l; j++) { \n\nisPalin[i][j] = dp[i][j] = \n0\n; \n\n} \n\n} \n\n\n// loop for starting index of range \n\nfor\n(\nint\ni = l - \n1\n; i >= \n0\n; i--) { \n\n// initialize value for one character strings as 1 \n\nisPalin[i][i] = \n1\n; \n\ndp[i][i] = \n1\n; \n\n\n// loop for ending index of range \n\nfor\n(\nint\nj = i + \n1\n; j < l; j++) { \n\n/* isPalin[i][j] will be 1 if ith and \n\njth characters are equal and mid \n\nsubstring str(i+1..j-1) is also a \n\npalindrome */\n\nisPalin[i][j] = (str.charAt(i) == str.charAt(j) && (i + \n1\n> j - \n1\n|| (isPalin[i + \n1\n][j - \n1\n]) != \n0\n)) ? \n1\n: \n0\n; \n\n\n/* dp[i][j] will be addition of number \n\nof palindromes from i to j-1 and i+1 \n\nto j subtracting palindromes from i+1 \n\nto j-1 (as counted twice) plus 1 if \n\nstr(i..j) is also a palindrome */\n\ndp[i][j] = dp[i][j - \n1\n] + dp[i + \n1\n][j] - dp[i + \n1\n][j - \n1\n] + isPalin[i][j]; \n\n} \n\n} \n\n} \n\n\n// method returns count of palindromic substring in range (l, r) \n\nstatic\nint\ncountOfPalindromeInRange(\nint\ndp[][], \nint\nl, \nint\nr) \n\n{ \n\nreturn\ndp[l][r]; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nMAX = \n50\n; \n\nString str = \n\"xyaabax\"\n; \n\nint\n[][] dp = \nnew\nint\n[MAX][MAX]; \n\nconstructDp(dp, str); \n\n\nint\nl = \n3\n; \n\nint\nr = \n5\n; \n\nSystem.out.println(countOfPalindromeInRange(dp, l, r)); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "index": 467, "complexity": 5}
{"back-translation": "import java.util.Scanner; public class TaxistsnLyft { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int m = scan.nextInt(); int k = n + m; long[] arr1 = new long[k]; for (int i = 0; i < k; i++) { arr1[i] = scan.nextLong(); } long[] tax = new long[k]; long[] taxcount = new long[k]; for (int i = 0; i < k; i++) { tax[i] = scan.nextInt(); } int c; int b; for (int i = 0; i < k; i++) { if (tax[i] == 0) { c = i; while (tax[c] != 1) { if (c == 0) { c = -1; break; } c--; } b = i; while (tax[b] != 1) { if (b >= k - 1) { b = -1; break; } b++; } if (c == -1 && b >= 0) { taxcount[b]++; } else if (b == -1 && c >= 0) { taxcount[c]++; } else if (b >= 0 && c >= 0) { if (arr1[i] - arr1[c] > arr1[b] - arr1[i]) { taxcount[b]++; } if (arr1[i] - arr1[c] < arr1[b] - arr1[i]) { taxcount[c]++; } if (arr1[i] - arr1[c] == arr1[b] - arr1[i]) { taxcount[c]++; } } } } for (int j = 0; j < k; j++) { if (tax[j] == 1) { System.out.print(taxcount[j] + \" \"); } scan.close(); } } }", "src": "\nimport java.util.Scanner;\n\npublic class TaxistsnLyft {\n\tpublic static void main (String[] args){\n\t\tScanner scan = new Scanner (System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint k = n+m;\n\t\tlong[] arr1 = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tarr1[i]=scan.nextLong();\n\t\t}\n\t\tlong[] tax = new long[k];\n\t\tlong[] taxcount = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\ttax[i]=scan.nextInt();\n\t\t}\n\t\tint c;\n\t\tint b;\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tif(tax[i]==0){\n\t\t\t\tc=i;\n\t\t\t\twhile(tax[c]!=1){\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tc=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tc--;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tb=i;\n\t\t\t\twhile(tax[b]!=1){\n\t\t\t\t\tif(b>=k-1){\n\t\t\t\t\t\tb=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} \n\t\t\t\t\tb++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t//System.out.println(\">>\"+b+\">>\"+c);\n\t\t\t\tif(c==-1&&b>=0){\n\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t} else if(b==-1&&c>=0) {\n\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t} else if(b>=0&&c>=0) {\n\t\t\t\t\tif(arr1[i]-arr1[c]>arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]<arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]==arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\tfor(int j = 0; j<k; j++){\n\t\t\tif(tax[j]==1){\n\t\t\t\tSystem.out.print(taxcount[j]+\" \");\n\t\t\t}\n\t\tscan.close();\n\t\t}\n\t}\n}\n", "index": 468, "complexity": 5}
{"back-translation": "class GFG {\n    static int lps(String s) {\n        int n = s.length();\n        int[] a = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            int back_up = 0;\n            for (int j = i; j < n; j++) {\n                if (j == i)\n                    a[j] = 1;\n                else if (s.charAt(i) == s.charAt(j)) {\n                    int temp = a[j];\n                    a[j] = back_up + 2;\n                    back_up = temp;\n                } else {\n                    back_up = a[j];\n                    a[j] = Math.max(a[j - 1], a[j]);\n                }\n            }\n        }\n        return a[n - 1];\n    }\n\n    public static void main(String[] args) {\n        String str = \"GEEKSFORGEEKS\";\n        System.out.println(lps(str));\n    }\n}", "src": "\n// A Space optimized Dynamic Programming \n// based Java program for LPS problem \n\nclass\nGFG { \n\n\n// Returns the length of the longest \n\n// palindromic subsequence in str \n\nstatic\nint\nlps(String s) \n\n{ \n\nint\nn = s.length(); \n\n\n// a[i] is going to store length \n\n// of longest palindromic subsequence \n\n// of substring s[0..i] \n\nint\na[] = \nnew\nint\n[n]; \n\n\n// Pick starting point \n\nfor\n(\nint\ni = n - \n1\n; i >= \n0\n; i--) \n\n{ \n\nint\nback_up = \n0\n; \n\n\n// Pick ending points and see if s[i] \n\n// increases length of longest common \n\n// subsequence ending with s[j]. \n\nfor\n(\nint\nj = i; j < n; j++) { \n\n\n// similar to 2D array L[i][j] == 1 \n\n// i.e., handling substrings of length \n\n// one. \n\nif\n(j == i) \n\na[j] = \n1\n; \n\n\n// Similar to 2D array L[i][j] = L[i+1][j-1]+2 \n\n// i.e., handling case when corner characters \n\n// are same. \n\nelse\nif\n(s.charAt(i) == s.charAt(j)) \n\n{ \n\nint\ntemp = a[j]; \n\na[j] = back_up + \n2\n; \n\nback_up = temp; \n\n} \n\n\n// similar to 2D array L[i][j] = max(L[i][j-1], \n\n// a[i+1][j]) \n\nelse\n\n{ \n\nback_up = a[j]; \n\na[j] = Math.max(a[j - \n1\n], a[j]); \n\n} \n\n} \n\n} \n\nreturn\na[n - \n1\n]; \n\n} \n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"GEEKSFORGEEKS\"\n; \n\nSystem.out.println(lps(str)); \n\n} \n} \n\n//This article is contributed by prerna saini. ", "index": 469, "complexity": 5}
{"back-translation": "class MST { private static final int V = 5; int minKey(int[] key, Boolean[] mstSet) { int min = Integer.MAX_VALUE, min_index = -1; for (int v = 0; v < V; v++) if (mstSet[v] == false && key[v] < min) { min = key[v]; min_index = v; } return min_index; } void printMST(int[] parent, int[][] graph) { System.out.println(\"Edge \\tWeight\"); for (int i = 1; i < V; i++) System.out.println(parent[i] + \" - \" + i + \"\\t\" + graph[i][parent[i]]); } void primMST(int[][] graph) { int[] parent = new int[V]; int[] key = new int[V]; Boolean[] mstSet = new Boolean[V]; for (int i = 0; i < V; i++) { key[i] = Integer.MAX_VALUE; mstSet[i] = false; } key[0] = 0; parent[0] = -1; for (int count = 0; count < V - 1; count++) { int u = minKey(key, mstSet); mstSet[u] = true; for (int v = 0; v < V; v++) if (graph[u][v] != 0 && mstSet[v] == false && graph[u][v] < key[v]) { parent[v] = u; key[v] = graph[u][v]; } } printMST(parent, graph); } public static void main(String[] args) { MST t = new MST(); int[][] graph = new int[][] { { 0, 2, 0, 6, 0 }, { 2, 0, 3, 8, 5 }, { 0, 3, 0, 0, 7 }, { 6, 8, 0, 0, 9 }, { 0, 5, 7, 9, 0 } }; t.primMST(graph); } }", "src": "\n// A Java program for Prim's Minimum Spanning Tree (MST) algorithm. \n// The program is for adjacency matrix representation of the graph \n\nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nMST { \n\n// Number of vertices in the graph \n\nprivate\nstatic\nfinal\nint\nV = \n5\n; \n\n\n// A utility function to find the vertex with minimum key \n\n// value, from the set of vertices not yet included in MST \n\nint\nminKey(\nint\nkey[], Boolean mstSet[]) \n\n{ \n\n// Initialize min value \n\nint\nmin = Integer.MAX_VALUE, min_index = -\n1\n; \n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\nif\n(mstSet[v] == \nfalse\n&& key[v] < min) { \n\nmin = key[v]; \n\nmin_index = v; \n\n} \n\n\nreturn\nmin_index; \n\n} \n\n\n// A utility function to print the constructed MST stored in \n\n// parent[] \n\nvoid\nprintMST(\nint\nparent[], \nint\ngraph[][]) \n\n{ \n\nSystem.out.println(\n\"Edge \\tWeight\"\n); \n\nfor\n(\nint\ni = \n1\n; i < V; i++) \n\nSystem.out.println(parent[i] + \n\" - \"\n+ i + \n\"\\t\"\n+ graph[i][parent[i]]); \n\n} \n\n\n// Function to construct and print MST for a graph represented \n\n// using adjacency matrix representation \n\nvoid\nprimMST(\nint\ngraph[][]) \n\n{ \n\n// Array to store constructed MST \n\nint\nparent[] = \nnew\nint\n[V]; \n\n\n// Key values used to pick minimum weight edge in cut \n\nint\nkey[] = \nnew\nint\n[V]; \n\n\n// To represent set of vertices not yet included in MST \n\nBoolean mstSet[] = \nnew\nBoolean[V]; \n\n\n// Initialize all keys as INFINITE \n\nfor\n(\nint\ni = \n0\n; i < V; i++) { \n\nkey[i] = Integer.MAX_VALUE; \n\nmstSet[i] = \nfalse\n; \n\n} \n\n\n// Always include first 1st vertex in MST. \n\nkey[\n0\n] = \n0\n; \n// Make key 0 so that this vertex is \n\n// picked as first vertex \n\nparent[\n0\n] = -\n1\n; \n// First node is always root of MST \n\n\n// The MST will have V vertices \n\nfor\n(\nint\ncount = \n0\n; count < V - \n1\n; count++) { \n\n// Pick thd minimum key vertex from the set of vertices \n\n// not yet included in MST \n\nint\nu = minKey(key, mstSet); \n\n\n// Add the picked vertex to the MST Set \n\nmstSet[u] = \ntrue\n; \n\n\n// Update key value and parent index of the adjacent \n\n// vertices of the picked vertex. Consider only those \n\n// vertices which are not yet included in MST \n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\n\n// graph[u][v] is non zero only for adjacent vertices of m \n\n// mstSet[v] is false for vertices not yet included in MST \n\n// Update the key only if graph[u][v] is smaller than key[v] \n\nif\n(graph[u][v] != \n0\n&& mstSet[v] == \nfalse\n&& graph[u][v] < key[v]) { \n\nparent[v] = u; \n\nkey[v] = graph[u][v]; \n\n} \n\n} \n\n\n// print the constructed MST \n\nprintMST(parent, graph); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n/* Let us create the following graph \n\n2 3 \n\n(0)--(1)--(2) \n\n| / \\ | \n\n6| 8/ \\5 |7 \n\n| / \\ | \n\n(3)-------(4) \n\n9 */\n\nMST t = \nnew\nMST(); \n\nint\ngraph[][] = \nnew\nint\n[][] { { \n0\n, \n2\n, \n0\n, \n6\n, \n0\n}, \n\n{ \n2\n, \n0\n, \n3\n, \n8\n, \n5\n}, \n\n{ \n0\n, \n3\n, \n0\n, \n0\n, \n7\n}, \n\n{ \n6\n, \n8\n, \n0\n, \n0\n, \n9\n}, \n\n{ \n0\n, \n5\n, \n7\n, \n9\n, \n0\n} }; \n\n\n// Print the solution \n\nt.primMST(graph); \n\n} \n} \n// This code is contributed by Aakash Hasija ", "index": 470, "complexity": 5}
{"back-translation": "import java.util.*;\n\npublic class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "src": "import java.util.*;\n\npublic class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "index": 472, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CChessboard solver = new CChessboard();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CChessboard {\n        int[] nextPermutation(int[] array) {\n            int i = array.length - 1;\n            while (i > 0 && array[i - 1] >= array[i]) {\n                i--;\n            }\n\n            if (i <= 0) {\n                return null;\n            }\n\n            int j = array.length - 1;\n\n            while (array[j] <= array[i - 1]) {\n                j--;\n            }\n\n            int temp = array[i - 1];\n            array[i - 1] = array[j];\n            array[j] = temp;\n\n            j = array.length - 1;\n\n            while (i < j) {\n                temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n                i++;\n                j--;\n            }\n\n            return array;\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int[][][] arr = new int[4][n][n];\n            int[] sum = new int[4];\n\n            for (int k = 0; k < 4; k++) {\n                for (int i = 0; i < n; i++) {\n                    String str = in.next();\n                    for (int j = 0; j < n; j++) {\n                        arr[k][i][j] = (str.charAt(j) - '0');\n                    }\n                }\n            }\n\n            for (int k = 0; k < 4; k++) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        if ((i + j) % 2 == arr[k][i][j])\n                            sum[k]++;\n                    }\n                }\n            }\n\n            int[] perm = new int[4];\n            for (int i = 0; i < 4; i++)\n                perm[i] = i;\n\n\n            int min = Integer.MAX_VALUE;\n            while (true) {\n                perm = nextPermutation(perm);\n\n                if (perm == null)\n                    break;\n\n                int sm = 0;\n                for (int j = 0; j < 4; j++) {\n                    if (j % 2 == 0) {\n                        sm += (sum[perm[j]]);\n                    } else {\n                        sm += (n * n - sum[perm[j]]);\n                    }\n                }\n                min = Math.min(min, sm);\n\n                sm = 0;\n                for (int j = 0; j < 4; j++) {\n                    if (j % 2 == 0) {\n                        sm += (n * n - sum[perm[j]]);\n                    } else {\n                        sm += (sum[perm[j]]);\n                    }\n                }\n                min = Math.min(sm, min);\n\n\n            }\n            out.printLine(min);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n\n            while (isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n\n                res *= 10;\n                res += c & 15;\n\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public String next() {\n            int c = read();\n\n            while (isSpaceChar(c))\n                c = read();\n\n            StringBuilder res = new StringBuilder();\n\n            do {\n                res.appendCodePoint(c);\n\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author sumit\n */\npublic class Main {\n      public static void main(String[] args) {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            InputReader in = new InputReader(inputStream);\n            OutputWriter out = new OutputWriter(outputStream);\n            CChessboard solver = new CChessboard();\n            solver.solve(1, in, out);\n            out.close();\n      }\n\n      static class CChessboard {\n            int[] nextPermutation(int[] array) {\n                  int i = array.length - 1;\n                  while (i > 0 && array[i - 1] >= array[i]) {\n                        i--;\n                  }\n\n                  if (i <= 0) {\n                        return null;\n                  }\n\n                  int j = array.length - 1;\n\n                  while (array[j] <= array[i - 1]) {\n                        j--;\n                  }\n\n                  int temp = array[i - 1];\n                  array[i - 1] = array[j];\n                  array[j] = temp;\n\n                  j = array.length - 1;\n\n                  while (i < j) {\n                        temp = array[i];\n                        array[i] = array[j];\n                        array[j] = temp;\n                        i++;\n                        j--;\n                  }\n\n                  return array;\n            }\n\n            public void solve(int testNumber, InputReader in, OutputWriter out) {\n                  int n = in.nextInt();\n                  int arr[][][] = new int[4][n][n];\n                  int sum[] = new int[4];\n\n                  for (int k = 0; k < 4; k++) {\n                        for (int i = 0; i < n; i++) {\n                              String str = in.next();\n                              for (int j = 0; j < n; j++) {\n                                    arr[k][i][j] = (str.charAt(j) - '0');\n                              }\n                        }\n                  }\n\n                  for (int k = 0; k < 4; k++) {\n                        for (int i = 0; i < n; i++) {\n                              for (int j = 0; j < n; j++) {\n                                    if ((i + j) % 2 == arr[k][i][j])\n                                          sum[k]++;\n                              }\n                        }\n                  }\n\n                  int perm[] = new int[4];\n                  for (int i = 0; i < 4; i++)\n                        perm[i] = i;\n\n\n                  int min = Integer.MAX_VALUE;\n                  while (true) {\n                        perm = nextPermutation(perm);\n\n                        if (perm == null)\n                              break;\n\n                        int sm = 0;\n                        for (int j = 0; j < 4; j++) {\n                              if (j % 2 == 0) {\n                                    sm += (sum[perm[j]]);\n                              } else {\n                                    sm += (n * n - sum[perm[j]]);\n                              }\n                        }\n                        min = Math.min(min, sm);\n\n                        sm = 0;\n                        for (int j = 0; j < 4; j++) {\n                              if (j % 2 == 0) {\n                                    sm += (n * n - sum[perm[j]]);\n                              } else {\n                                    sm += (sum[perm[j]]);\n                              }\n                        }\n                        min = Math.min(sm, min);\n\n\n                  }\n                  out.printLine(min);\n\n\n            }\n\n      }\n\n      static class OutputWriter {\n            private final PrintWriter writer;\n\n            public OutputWriter(OutputStream outputStream) {\n                  writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n            }\n\n            public OutputWriter(Writer writer) {\n                  this.writer = new PrintWriter(writer);\n            }\n\n            public void close() {\n                  writer.close();\n            }\n\n            public void printLine(int i) {\n                  writer.println(i);\n            }\n\n      }\n\n      static class InputReader {\n            private InputStream stream;\n            private byte[] buf = new byte[1024];\n            private int curChar;\n            private int numChars;\n\n            public InputReader(InputStream stream) {\n                  this.stream = stream;\n            }\n\n            public int read() {\n                  if (numChars == -1)\n                        throw new InputMismatchException();\n\n                  if (curChar >= numChars) {\n                        curChar = 0;\n                        try {\n                              numChars = stream.read(buf);\n                        } catch (IOException e) {\n                              throw new InputMismatchException();\n                        }\n                        if (numChars <= 0)\n                              return -1;\n                  }\n\n                  return buf[curChar++];\n            }\n\n            public int nextInt() {\n                  int c = read();\n\n                  while (isSpaceChar(c))\n                        c = read();\n\n                  int sgn = 1;\n\n                  if (c == '-') {\n                        sgn = -1;\n                        c = read();\n                  }\n\n                  int res = 0;\n\n                  do {\n                        if (c < '0' || c > '9')\n                              throw new InputMismatchException();\n\n                        res *= 10;\n                        res += c & 15;\n\n                        c = read();\n                  } while (!isSpaceChar(c));\n\n                  return res * sgn;\n            }\n\n            public String next() {\n                  int c = read();\n\n                  while (isSpaceChar(c))\n                        c = read();\n\n                  StringBuilder res = new StringBuilder();\n\n                  do {\n                        res.appendCodePoint(c);\n\n                        c = read();\n                  } while (!isSpaceChar(c));\n\n                  return res.toString();\n            }\n\n            public boolean isSpaceChar(int c) {\n                  return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n            }\n\n      }\n}\n\n", "index": 473, "complexity": 5}
{"back-translation": "import java.io.BufferedOutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class E1180D {\n\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        for (int i = 1; i < (m / 2) + 1; i++) {\n            int i2 = m - i + 1;\n            for (int j = 1; j <= n; j++) {\n                int j2 = n - j + 1;\n                pw.println(j + \" \" + i);\n                pw.println(j2 + \" \" + i2);\n            }\n        }\n\n        if (m % 2 == 1) {\n            int i2 = m / 2 + 1;\n            for (int j = 1; j <= n / 2; j++) {\n                int j2 = n - j + 1;\n                pw.println(j + \" \" + i2);\n                pw.println(j2 + \" \" + i2);\n            }\n            if (n % 2 == 1) {\n                int j = n / 2 + 1;\n                pw.println(j + \" \" + i2);\n            }\n        }\n\n        pw.flush();\n        pw.close();\n    }\n}", "src": "\nimport java.io.BufferedOutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class E1180D {\n\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        // Move from both ends, Time limit exceeded on test 6\n        for (int i= 1; i<= m/2; i++) {\n            // String s = \"\";\n            int i2 = m -i + 1; // the other end of i\n            // i is left row, i2 is right row\n            for (int j = 1; j <= n ; j++) {\n                int j2 = n - j + 1;\n                // start with (i,j), then go thru all the cell with (,i) and (,i2)\n                pw.println(j + \" \" + i);\n                pw.println(j2+ \" \" + i2);\n                // s += j + \" \" + i + \"\\n\" + j2+ \" \" + i2 + \"\\n\";\n            }\n            // out.print(s);\n        }\n        \n        // if n is odd, there is one line in the middle\n        if (m % 2 == 1) {\n            int i2 = m /2 + 1; // this is the middle column\n            for (int j = 1; j <= n/2 ; j++) {\n                int j2 = n - j + 1;\n                // start with (i,j), then go thru all the cell with (,i) and (,i2)\n                pw.println(j + \" \" + i2);\n                pw.println(j2+ \" \" + i2);\n            }\n            if (n %2 == 1) {\n                int j = n /2 + 1;\n                pw.println(j + \" \" + i2);\n            }\n        }\n        pw.flush();\n        pw.close();\n    }    \n}\n", "index": 474, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        String[] input = br.readLine().split(\" \");\n        int n = Integer.parseInt(input[0]);\n        int m = Integer.parseInt(input[1]);\n        int ans = 0;\n\n        int[] a = new int[101];\n        String[] parts = br.readLine().split(\" \");\n        for (int i = 0; i < m; i++) {\n            a[Integer.parseInt(parts[i])]++;\n        }\n\n        for (int i = 1; i <= 100; i++) {\n            int y = 0;\n            for (int x : a) {\n                y += x / i;\n            }\n            if (y >= n) {\n                ans = i;\n            }\n        }\n\n        bw.write(Integer.toString(ans));\n        bw.newLine();\n\n        bw.flush();\n        bw.close();\n        br.close();\n    }\n}", "src": "//Atcoder\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}\n", "index": 475, "complexity": 5}
{"back-translation": "class GFG { static int maxAlternateSum(int arr[], int n) { if (n == 1) return arr[0]; int dec[] = new int[n]; int inc[] = new int[n]; dec[0] = inc[0] = arr[0]; int flag = 0; for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { if (arr[j] > arr[i]) { dec[i] = Math.max(dec[i], inc[j] + arr[i]); flag = 1; } else if (arr[j] < arr[i] && flag == 1) inc[i] = Math.max(inc[i], dec[j] + arr[i]); } } int result = Integer.MIN_VALUE; for (int i = 0; i < n; i++) { if (result < inc[i]) result = inc[i]; if (result < dec[i]) result = dec[i]; } return result; } public static void main(String[] args) { int arr[] = { 8, 2, 3, 5, 7, 9, 10 }; System.out.println(\"Maximum sum = \" + maxAlternateSum(arr, arr.length)); } }", "src": "\n// Java program to find sum of maximum \n// sum alternating sequence starting with \n// first element. \n\npublic\nclass\nGFG \n{ \n\n// Return sum of maximum sum alternating \n\n// sequence starting with arr[0] and is first \n\n// decreasing. \n\nstatic\nint\nmaxAlternateSum(\nint\narr[], \nint\nn) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\narr[\n0\n]; \n\n\n// create two empty array that store result of \n\n// maximum sum of alternate sub-sequence \n\n\n// stores sum of decreasing and increasing \n\n// sub-sequence \n\nint\ndec[] = \nnew\nint\n[n]; \n\n\n\n// store sum of increasing and decreasing sun-sequence \n\nint\ninc[] = \nnew\nint\n[n]; \n\n\n// As per question, first element must be part \n\n// of solution. \n\ndec[\n0\n] = inc[\n0\n] = arr[\n0\n]; \n\n\nint\nflag = \n0\n; \n\n\n// Traverse remaining elements of array \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<i; j++) \n\n{ \n\n// IF current sub-sequence is decreasing the \n\n// update dec[j] if needed. dec[i] by current \n\n// inc[j] + arr[i] \n\nif\n(arr[j] > arr[i]) \n\n{ \n\ndec[i] = Math.max(dec[i], inc[j]+arr[i]); \n\n\n// Revert the flag , if first decreasing \n\n// is found \n\nflag = \n1\n; \n\n} \n\n\n// If next element is greater but flag should be 1 \n\n// i.e. this element should be counted after the \n\n// first decreasing element gets counted \n\nelse\nif\n(arr[j] < arr[i] && flag == \n1\n) \n\n\n// If current sub-sequence is increasing \n\n// then update inc[i] \n\ninc[i] = Math.max(inc[i], dec[j]+arr[i]); \n\n} \n\n} \n\n\n// find maximum sum in b/w inc[] and dec[] \n\nint\nresult = Integer.MIN_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(result < inc[i]) \n\nresult = inc[i]; \n\nif\n(result < dec[i]) \n\nresult = dec[i]; \n\n} \n\n\n// return maximum sum alternate sun-sequence \n\nreturn\nresult; \n\n} \n\n\n// Driver Method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[]= {\n8\n, \n2\n, \n3\n, \n5\n, \n7\n, \n9\n, \n10\n}; \n\nSystem.out.println(\n\"Maximum sum = \"\n+ \n\nmaxAlternateSum(arr , arr.length)); \n\n} \n} ", "index": 476, "complexity": 5}
{"back-translation": "public class Solution { static void printFirstNegativeInteger(int[] arr, int n, int k) { boolean flag; for (int i = 0; i < (n - k + 1); i++) { flag = false; for (int j = 0; j < k; j++) { if (arr[i + j] < 0) { System.out.print((arr[i + j]) + \" \"); flag = true; break; } } if (!flag) System.out.print(\"0\" +\" \"); } } public static void main(String args[]) { int arr[] = { 12, -1, -7, 8, -15, 30, 16, 28 }; int n = arr.length; int k = 3; printFirstNegativeInteger(arr, n, k); } }", "src": "\n// Java implementation to find the first negative \n// integer in every window of size k \nimport\njava.util.*; \n\nclass\nsolution \n{ \n\n// function to find the first negative \n// integer in every window of size k \nstatic\nvoid\nprintFirstNegativeInteger(\nint\narr[], \nint\nn, \nint\nk) \n{ \n\n// flag to check whether window contains \n\n// a negative integer or not \n\nboolean\nflag; \n\n\n// Loop for each subarray(window) of size k \n\nfor\n(\nint\ni = \n0\n; i<(n-k+\n1\n); i++) \n\n{ \n\nflag = \nfalse\n; \n\n\n// traverse through the current window \n\nfor\n(\nint\nj = \n0\n; j<k; j++) \n\n{ \n\n// if a negative integer is found, then \n\n// it is the first negative integer for \n\n// current window. Print it, set the flag \n\n// and break \n\nif\n(arr[i+j] < \n0\n) \n\n{ \n\nSystem.out.print((arr[i+j])+\n\" \"\n); \n\nflag = \ntrue\n; \n\nbreak\n; \n\n} \n\n} \n\n\n// if the current window does not \n\n// contain a negative integer \n\nif\n(!flag) \n\nSystem.out.print(\n\"0\"\n+\n\" \"\n); \n\n} \n} \n\n// Driver program to test above functions \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n12\n, -\n1\n, -\n7\n, \n8\n, -\n15\n, \n30\n, \n16\n, \n28\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nprintFirstNegativeInteger(arr, n, k); \n\n} \n} \n// This code is contributed by \n// Shashank_Sharma ", "index": 477, "complexity": 5}
{"back-translation": "public class GFG { public static int N = 4, M = 6; static int findMaxPath(int[][] mat) { int res = -1; for (int i = 0; i < M; i++) { res = Math.max(res, mat[0][i]); } for (int i = 1; i < N; i++) { res = -1; for (int j = 0; j < M; j++) { if (j > 0 && j < M - 1) { mat[i][j] += Math.max(mat[i - 1][j], Math.max(mat[i - 1][j - 1], mat[i - 1][j + 1])); } else if (j > 0) { mat[i][j] += Math.max(mat[i - 1][j], mat[i - 1][j - 1]); } else if (j < M - 1) { mat[i][j] += Math.max(mat[i - 1][j], mat[i - 1][j + 1]); } res = Math.max(mat[i][j], res); } } return res; } public static void main(String[] args) { int mat[][] = { { 10, 10, 2, 0, 20, 4 }, { 1, 0, 0, 30, 2, 5 }, { 0, 10, 4, 0, 2, 0 }, { 1, 0, 2, 20, 0, 4 } }; System.out.println(findMaxPath(mat)); } }", "src": "\n// Java prorgam for finding max path in matrix \n\nimport\nstatic\njava.lang.Math.max; \n\nclass\nGFG \n{ \n\npublic\nstatic\nint\nN = \n4\n, M = \n6\n; \n\n\n// Function to calculate max path in matrix \n\nstatic\nint\nfindMaxPath(\nint\nmat[][]) \n\n{ \n\n// To find max val in first row \n\nint\nres = -\n1\n; \n\nfor\n(\nint\ni = \n0\n; i < M; i++) \n\nres = max(res, mat[\n0\n][i]); \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\nres = -\n1\n; \n\nfor\n(\nint\nj = \n0\n; j < M; j++) \n\n{ \n\n// When all paths are possible \n\nif\n(j > \n0\n&& j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmax(mat[i - \n1\n][j - \n1\n], \n\nmat[i - \n1\n][j + \n1\n])); \n\n\n// When diagonal right is not possible \n\nelse\nif\n(j > \n0\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j - \n1\n]); \n\n\n// When diagonal left is not possible \n\nelse\nif\n(j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j + \n1\n]); \n\n\n// Store max path sum \n\nres = max(mat[i][j], res); \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nmat[][] = { { \n10\n, \n10\n, \n2\n, \n0\n, \n20\n, \n4\n}, \n\n{ \n1\n, \n0\n, \n0\n, \n30\n, \n2\n, \n5\n}, \n\n{ \n0\n, \n10\n, \n4\n, \n0\n, \n2\n, \n0\n}, \n\n{ \n1\n, \n0\n, \n2\n, \n20\n, \n0\n, \n4\n} \n\n}; \n\n\nSystem.out.println(findMaxPath(mat)); \n\n} \n} \n\n// Contributed by Pramod Kumar ", "index": 478, "complexity": 5}
{"back-translation": "class Pair { int a; int b; public Pair(int a, int b) { this.a = a; this.b = b; } static int maxChainLength(Pair arr[], int n) { int i, j, max = 0; int mcl[] = new int[n]; for (i = 0; i < n; i++) mcl[i] = 1; for (i = 1; i < n; i++) for (j = 0; j < i; j++) if (arr[i].a > arr[j].b && mcl[i] < mcl[j] + 1) mcl[i] = mcl[j] + 1; for (i = 0; i < n; i++) if (max < mcl[i]) max = mcl[i]; return max; } public static void main(String[] args) { Pair arr[] = new Pair[] { new Pair(5, 24), new Pair(15, 25), new Pair (27, 40), new Pair(50, 60)}; System.out.println(\"Length of maximum size chain is \" + maxChainLength(arr, arr.length)); } }", "src": "\nclass\nPair{ \n\nint\na; \n\nint\nb; \n\n\npublic\nPair(\nint\na, \nint\nb) { \n\nthis\n.a = a; \n\nthis\n.b = b; \n\n} \n\n\n// This function assumes that arr[] is sorted in increasing order \n\n// according the first (or smaller) values in pairs. \n\nstatic\nint\nmaxChainLength(Pair arr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmcl[] = \nnew\nint\n[n]; \n\n\n/* Initialize MCL (max chain length) values for all indexes */\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nmcl[i] = \n1\n; \n\n\n/* Compute optimized chain length values in bottom up manner */\n\nfor\n( i = \n1\n; i < n; i++ ) \n\nfor\n( j = \n0\n; j < i; j++ ) \n\nif\n( arr[i].a > arr[j].b && mcl[i] < mcl[j] + \n1\n) \n\nmcl[i] = mcl[j] + \n1\n; \n\n\n// mcl[i] now stores the maximum chain length ending with pair i \n\n\n/* Pick maximum of all MCL values */\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nif\n( max < mcl[i] ) \n\nmax = mcl[i]; \n\n\nreturn\nmax; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nPair arr[] = \nnew\nPair[] {\nnew\nPair(\n5\n,\n24\n), \nnew\nPair(\n15\n, \n25\n), \n\nnew\nPair (\n27\n, \n40\n), \nnew\nPair(\n50\n, \n60\n)}; \n\nSystem.out.println(\n\"Length of maximum size chain is \"\n+ \n\nmaxChainLength(arr, arr.length)); \n\n} \n} ", "index": 479, "complexity": 5}
{"back-translation": "import java.util.*;\npublic class Main {\n    public static int n, m;\n    public static int[] vert, group;\n    public static int[][] horiz;\n    public static boolean ok(int a, int b, int g) {\n        int start, end;\n        switch (g) {\n            case 0:\n                start = 1;\n                end = vert.length > 0 ? vert[0] : (int)Math.pow(10, 9);\n                break;\n            case 1:\n                start = vert[g - 1];\n                end = (int)Math.pow(10, 9);\n                break;\n            default:\n                start = vert[g - 1];\n                end = vert[g];\n        }\n        return a <= start && b >= end;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        vert = new int[n];\n        for (int i = 0; i < n; i++) {\n            vert[i] = in.nextInt();\n        }\n        horiz = new int[m][3];\n        for (int i = 0; i < m; i++) {\n            horiz[i] = new int[]{in.nextInt(), in.nextInt(), in.nextInt()};\n        }\n        group = new int[n + 1];\n        Arrays.fill(group, 0);\n        for (int i = 0; i < m; i++) {\n            int a = horiz[i][0];\n            int b = horiz[i][1];\n            for (int j = 0; j < group.length; j++) {\n                if (ok(a, b, j)) {\n                    group[j]++;\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < group.length; i++) {\n            min = Math.min(min, group[i] + i);\n        }\n        System.out.println(min);\n    }\n}", "src": "import java.util.*;\npublic class Main {\n    public static int n, m;\n    public static int[] vert, group;\n    public static int[][] horiz;\n    public static boolean ok(int a, int b, int g) {\n        int start, end;\n        if (g == 0) {\n            start = 1;\n            end = vert.length > 0 ? vert[0] : (int)Math.pow(10, 9);\n        } else if (g == group.length - 1) {\n            start = vert[g - 1];\n            end = (int)Math.pow(10, 9);\n        } else {\n            start = vert[g - 1];\n            end = vert[g];\n        }\n        return a <= start && b >= end;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        vert = new int[n];\n        for (int i = 0; i < n; i++) {\n            vert[i] = in.nextInt();\n        }\n        horiz = new int[m][3];\n        for (int i = 0; i < m; i++) {\n            horiz[i] = new int[]{in.nextInt(), in.nextInt(), in.nextInt()};\n        }\n        group = new int[n + 1];\n        Arrays.fill(group, 0);\n        for (int i = 0; i < m; i++) {\n            int a = horiz[i][0];\n            int b = horiz[i][1];\n            for (int j = 0; j < group.length; j++) {\n                if (ok(a, b, j)) {\n                    group[j]++;\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < group.length; i++) {\n            min = Math.min(min, group[i] + i);\n        }\n        System.out.println(min);\n    }\n}", "index": 480, "complexity": 5}
{"back-translation": "import java.util.Scanner;\n\npublic class Transform {\n\n\tpublic static void main(String args[])\n\t{\n\t\tScanner scan=new Scanner(System.in);\n\t\tint n=scan.nextInt();\n\t\tint k=scan.nextInt();\n\t\tString t=scan.next();\n\t\tint mx=0;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint gd=1;\n\t\t\tfor(int j=0;j<i;j++)\n\t\t\t{\n\t\t\t\tif(t.charAt(j)!=t.charAt((n-i)+j))\n\t\t\t\t{\n\t\t\t\t\tgd=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(gd==1){\n\t\t\t\tmx=i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(t);\n\t\tfor(int i=2;i<=k;i++)\n\t\t{\n\t\t\tfor(int j=mx;j<n;j++)\n\t\t\t{\n\t\t\t\tSystem.out.print(t.charAt(j));\n\t\t\t}\n\t\t}\n\t}\n}", "src": "import java.util.Scanner;\n\n\npublic class FUck {\n\n\t\tpublic static void main(String args[])\n\t\t{\n\t\t\tScanner scan=new Scanner(System.in);\n\t\t\tint n=scan.nextInt();\n\t\t\tint k=scan.nextInt();\n\t\t\tString t=scan.next();\n\t\t\tint mx=0;\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tint gd=1;\n\t\t\t\tfor(int j=0;j<i;j++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif(t.charAt(j)!=t.charAt((n-i)+j))\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tgd=0;\n\t\t\t\t\t\t// i think i can break here\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(gd==1){\n\t\t\t\t\tmx=i;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(t);\n\t\t\tfor(int i=2;i<=k;i++)\n\t\t\t{\n\t\t\t\tfor(int j=mx;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(t.charAt(j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n", "index": 481, "complexity": 5}
{"back-translation": "import java.io.*; class GFG { static void SwapInts(int[] array, int position1, int position2) { int temp = array[position1]; array[position1] = array[position2]; array[position2] = temp; } static void KSwapMaximum(int[] arr, int n, int k) { for (int i = 0; i < n - 1 && k > 0; ++i) { int indexPosition = i; for (int j = i + 1; j < n; ++j) { if (k <= j - i) break; if (arr[j] > arr[indexPosition]) indexPosition = j; } for (int j = indexPosition; j > i; --j) SwapInts(arr, j, j - 1); k -= indexPosition - i; } } public static void main(String args[]) { int[] arr = {3, 5, 4, 1, 2}; int n = arr.length; int k = 3; KSwapMaximum(arr, n, k); for (int i = 0; i < n; ++i) System.out.print(arr[i] + ", "src": "\n// Java program to find \n// lexicographically \n// maximum value after \n// k swaps. \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nvoid\nSwapInts(\nint\narray[], \n\nint\nposition1, \n\nint\nposition2) \n\n{ \n\n// Swaps elements \n\n// in an array. \n\n\n// Copy the first \n\n// position's element \n\nint\ntemp = array[position1]; \n\n\n// Assign to the \n\n// second element \n\narray[position1] = array[position2]; \n\n\n// Assign to the \n\n// first element \n\narray[position2] = temp; \n\n} \n\n\n// Function which \n\n// modifies the array \n\nstatic\nvoid\nKSwapMaximum(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; \n\ni < n - \n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n// Here, indexPositionition \n\n// is set where we want to \n\n// put the current largest \n\n// integer \n\nint\nindexPosition = i; \n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\n\n// If we exceed the \n\n// Max swaps then \n\n// break the loop \n\nif\n(k <= j - i) \n\nbreak\n; \n\n\n// Find the maximum value \n\n// from i+1 to max k or n \n\n// which will replace \n\n// arr[indexPosition] \n\nif\n(arr[j] > arr[indexPosition]) \n\nindexPosition = j; \n\n} \n\n\n// Swap the elements from \n\n// Maximum indexPosition \n\n// we found till now to \n\n// the ith index \n\nfor\n(\nint\nj = indexPosition; j > i; --j) \n\nSwapInts(arr, j, j - \n1\n); \n\n\n// Updates k after swapping \n\n// indexPosition-i elements \n\nk -= indexPosition - i; \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = { \n3\n, \n5\n, \n4\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nKSwapMaximum(arr, n, k); \n\n\n// Print the final Array \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} \n\n// This code is contributed by \n// Manish Shaw(manishshaw1) ", "index": 482, "complexity": 5}
{"back-translation": "class GFG { static int LCSubStr(String X, String Y) { int m = X.length(); int n = Y.length(); int result = 0; int[][] len = new int[2][n]; int currRow = 0; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (i == 0 || j == 0) { len[currRow][j] = 0; } else if (X.charAt(i - 1) == Y.charAt(j - 1)) { len[currRow][j] = len[(1 - currRow)][(j - 1)] + 1; result = Math.max(result, len[currRow][j]); } else { len[currRow][j] = 0; } } currRow = 1 - currRow; } return result; } public static void main(String args[]) { String X = \"GeeksforGeeks\"; String Y = \"GeeksQuiz\"; System.out.print(LCSubStr(X, Y)); } }", "src": "\n// Space optimized CPP implementation of \n// longest common substring. \nimport\njava.io.*; \nimport\njava.util.*; \n\npublic\nclass\nGFG { \n\n\n// Function to find longest \n\n// common substring. \n\nstatic\nint\nLCSubStr(String X, String Y) \n\n{ \n\n\n// Find length of both the strings. \n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\n// Variable to store length of longest \n\n// common substring. \n\nint\nresult = \n0\n; \n\n\n// Matrix to store result of two \n\n// consecutive rows at a time. \n\nint\n[][]len = \nnew\nint\n[\n2\n][n]; \n\n\n// Variable to represent which row of \n\n// matrix is current row. \n\nint\ncurrRow = \n0\n; \n\n\n// For a particular value of \n\n// i and j, len[currRow][j] \n\n// stores length of longest \n\n// common substring in string \n\n// X[0..i] and Y[0..j]. \n\nfor\n(\nint\ni = \n0\n; i < m; i++) { \n\nfor\n(\nint\nj = \n0\n; j < n; j++) { \n\nif\n(i == \n0\n|| j == \n0\n) { \n\nlen[currRow][j] = \n0\n; \n\n} \n\nelse\nif\n(X.charAt(i - \n1\n) == \n\nY.charAt(j - \n1\n)) \n\n{ \n\nlen[currRow][j] = \n\nlen[(\n1\n- currRow)][(j - \n1\n)] \n\n+ \n1\n; \n\nresult = Math.max(result, \n\nlen[currRow][j]); \n\n} \n\nelse\n\n{ \n\nlen[currRow][j] = \n0\n; \n\n} \n\n} \n\n\n// Make current row as previous \n\n// row and previous row as \n\n// new current row. \n\ncurrRow = \n1\n- currRow; \n\n} \n\n\nreturn\nresult; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString X = \n\"GeeksforGeeks\"\n; \n\nString Y = \n\"GeeksQuiz\"\n; \n\n\nSystem.out.print(LCSubStr(X, Y)); \n\n} \n} \n\n// This code is contributed by \n// Manish Shaw (manishshaw1) ", "index": 483, "complexity": 5}
{"back-translation": "class RotateArray {\n    void leftRotate(int arr[], int d, int n) {\n        for (int i = 0; i < d; i++) {\n            leftRotatebyOne(arr, n);\n        }\n    }\n\n    void leftRotatebyOne(int arr[], int n) {\n        int temp = arr[0];\n        for (int i = 0; i < n - 1; i++) {\n            arr[i] = arr[i + 1];\n        }\n        arr[n - 1] = temp;\n    }\n\n    void printArray(int arr[], int n) {\n        for (int i = 0; i < n; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n\n    public static void main(String[] args) {\n        RotateArray rotate = new RotateArray();\n        int arr[] = {1, 2, 3, 4, 5, 6, 7};\n        rotate.leftRotate(arr, 2, 7);\n        rotate.printArray(arr, 7);\n    }\n}", "src": "\n// Java program to rotate an array by \n// d elements \n\nclass\nRotateArray { \n\n/*Function to left rotate arr[] of size n by d*/\n\nvoid\nleftRotate(\nint\narr[], \nint\nd, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < d; i++) \n\nleftRotatebyOne(arr, n); \n\n} \n\n\nvoid\nleftRotatebyOne(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, temp; \n\ntemp = arr[\n0\n]; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\narr[i] = arr[i + \n1\n]; \n\narr[i] = temp; \n\n} \n\n\n/* utility function to print an array */\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRotateArray rotate = \nnew\nRotateArray(); \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nrotate.leftRotate(arr, \n2\n, \n7\n); \n\nrotate.printArray(arr, \n7\n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 484, "complexity": 5}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            InputReader in = new InputReader(System.in);\n            PrintWriter out = new PrintWriter(System.out);\n            TaskD solver = new TaskD();\n            solver.solve(1, in, out);\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n            int inv = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (a[j] > a[i]) {\n                        inv++;\n                    }\n                }\n            }\n            int m = in.nextInt();\n            for (int i = 0; i < m; i++) {\n                int l = in.nextInt();\n                int r = in.nextInt();\n                int s = (r - l + 1) * (r - l) / 2;\n                inv = (inv + s) % 2;\n                out.println(inv % 2 == 0 ? \"even\" : \"odd\");\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() throws IOException {\n            return reader.readLine();\n        }\n\n        public String next() throws IOException {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n            int inv = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (a[j] > a[i]) {\n                        inv++;\n                    }\n                }\n            }\n            int m = in.nextInt();\n            for (int i = 0; i < m; i++) {\n                int l = in.nextInt();\n                int r = in.nextInt();\n                int s = (r - l + 1) * (r - l) / 2;\n                inv = (inv + s) % 2;\n                out.println(inv % 2 == 0 ? \"even\" : \"odd\");\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String next() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "index": 485, "complexity": 5}
{"back-translation": "int[][] fast(int n, int m) {\n        int[][] ans = new int[2][n * m];\n        int c = 0;\n        for (int left = 1, right = m; left < m; left++, right--) {\n            for (int l = 1, r = n; l <= n && r >= 1; l++, r--) {\n                ans[0][c] = l;\n                ans[1][c++] = left;\n                ans[0][c] = r;\n                ans[1][c++] = right;\n            }\n        }\n        if (m % 2 == 1) {\n            int x = m / 2 + 1;\n            for (int l = 1, r = n; l < r; l++, r--) {\n                ans[0][c] = l;\n                ans[1][c++] = x;\n                ans[0][c] = r;\n                ans[1][c++] = x;\n                if (n % 2 == 1 && l + 2 == r) {\n                    ans[0][c] = l + 1;\n                    ans[1][c++] = x;\n                }\n            }\n        }\n        if (n == 1 && m % 2 == 1) {\n            ans[0][c] = 1;\n            ans[1][c++] = m / 2 + 1;\n        }\n        return ans;\n    }\n\n    void stress() {\n        for (int i = 3; i <= 5; i++) {\n            for (int j = 2; j <= 5; j++) {\n                int[][] ans = new int[2][];\n                try {\n                    ans = fast(i, j);\n                } catch (Exception e) {\n                    out.println(\"\u043e\u0448\u0438\u0431\u043a\u0430\");\n                    out.print(i + \" \" + j);\n                    return;\n                }\n                boolean[][] check = new boolean[i][j];\n                for (int c = 0; c < ans[0].length; c++) {\n                    int x = ans[0][c] - 1;\n                    int y = ans[1][c] - 1;\n                    check[x][y] = true;\n                }\n                for (int c = 0; c < i; c++) {\n                    for (int q = 0; q < j; q++) {\n                        if (!check[c][q]) {\n                            out.println(i + \" \" + j);\n                            out.println(\"\u0442\u043e\u0447\u043a\u0438\");\n                            for (int w = 0; w < ans[0].length; w++) {\n                                out.println(ans[0][w] + \" \" + ans[1][w]);\n                            }\n                            return;\n                        }\n                    }\n                }\n                HashSet<String> set = new HashSet<>();\n                for (int c = 1; c < ans[0].length; c++) {\n                    int x = ans[0][c] - ans[0][c - 1];\n                    int y = ans[1][c] - ans[1][c - 1];\n                    set.add(x + \" \" + y);\n                }\n                if (set.size() < i * j - 1) {\n                    out.println(i + \" \" + j);\n                    out.println(\"\u0432\u0435\u043a\u0442\u043e\u0440\u0430\");\n                    for (int w = 0; w < ans[0].length; w++) {\n                        out.println(ans[0][w] + \" \" + ans[1][w]);\n                    }\n                    return;\n                }\n            }\n        }\n    }\n\n    void normal() {\n        int n = readInt();\n        int m = readInt();\n        int[][] ans = fast(n, m);\n        for (int i = 0; i < ans[0].length; i++) {\n            out.println(ans[0][i] + \" \" + ans[1][i]);\n        }\n    }\n\n    boolean stress = false;\n    void solve() {\n        if (stress) stress();\n        else normal();\n    }\n\n    public static void main(String[] args) {\n        new Demo().run();\n    }\n\n    void run() {\n        init();\n        solve();\n        out.close();\n    }\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init() {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n    }\n\n    String readLine() {\n        try {\n            return in.readLine();\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    String readString() {\n        while (!tok.hasMoreTokens()) {\n            String nextLine = readLine();\n            if (nextLine == null) return null;\n            tok = new StringTokenizer(nextLine);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() {\n        return Double.parseDouble(readString());\n    }\n}", "src": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n    int[][] fast(int n, int m){\n\n        int[][] ans = new int[2][n * m];\n        int c = 0;\n\n        for (int left = 1, right = m; left < right; left++, right--) {\n            for (int l = 1, r = n; l <= n && r >= 1; l++, r--) {\n                ans[0][c] = l;\n                ans[1][c++] = left;\n\n                ans[0][c] = r;\n                ans[1][c++] = right;\n            }\n        }\n\n        if (m % 2 == 1) {\n            int x = m/2 + 1;\n            for(int l = 1, r = n;l < r;l++, r--){\n                ans[0][c] = l;\n                ans[1][c++] = x;\n\n                ans[0][c] = r;\n                ans[1][c++] = x;\n                    if(n % 2 == 1 && l + 2 == r){\n                        ans[0][c] = l+1;\n                        ans[1][c++] = x;\n                    }\n            }\n        }\n\n        if(n == 1 && m % 2 == 1){\n            ans[0][c] = 1;\n            ans[1][c] = m/2 + 1;\n        }\n\n        return ans;\n    }\n\n    void stress(){\n\n        for(int i = 3;i<=5;i++){\n            for(int j = 2;j<=5;j++){\n                int[][] ans = new int[2][];\n                try{\n                    ans = fast(i, j);\n                }catch(Exception e){\n                    out.println(\"\u043e\u0448\u0438\u0431\u043a\u0430\");\n                    out.print(i + \" \" + j);\n                    return;\n                }\n\n                boolean[][] check = new boolean[i][j];\n                for(int c = 0;c<ans[0].length;c++){\n                    int x = ans[0][c] - 1;\n                    int y = ans[1][c] - 1;\n                    check[x][y] = true;\n                }\n\n                for(int c = 0;c<i;c++){\n                    for(int q = 0;q<j;q++){\n                        if(!check[c][q]){\n                            out.println(i + \" \" + j);\n                            out.println(\"\u0442\u043e\u0447\u043a\u0438\");\n                            for(int w = 0;w<ans[0].length;w++){\n                                out.println(ans[0][w] + \" \" + ans[1][w]);\n                            }\n                            return;\n                        }\n                    }\n                }\n\n                HashSet<String> set = new HashSet<>();\n                for(int c = 1;c<ans[0].length;c++){\n                    int x = ans[0][c] - ans[0][c- 1];\n                    int y = ans[1][c] - ans[1][c - 1];\n                    set.add(x + \" \" + y);\n                }\n\n                if(set.size() < i * j - 1){\n                    out.println(i + \" \" + j);\n                    out.println(\"\u0432\u0435\u043a\u0442\u043e\u0440\u0430\");\n                    for(int w = 0;w<ans[0].length;w++){\n                        out.println(ans[0][w] + \" \" + ans[1][w]);\n                    }\n                    return;\n                }\n            }\n        }\n    }\n\n    void normal(){\n        int n =readInt();\n        int m = readInt();\n        int[][] ans = fast(n, m);\n        for(int i = 0;i<ans[0].length;i++){\n            out.println(ans[0][i] + \" \" + ans[1][i]);\n        }\n    }\n\n    boolean stress = false;\n    void solve(){\n        if(stress) stress();\n        else normal();\n    }\n\n    public static void main(String[] args) {\n        new D().run();\n    }\n\n    void run(){\n        init();\n        solve();\n        out.close();\n    }\n\n    BufferedReader in;\n    PrintWriter out;\n\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init(){\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out  = new PrintWriter(System.out);\n    }\n\n    String readLine(){\n        try{\n            return in.readLine();\n        }catch(Exception ex){\n            throw new RuntimeException(ex);\n        }\n    }\n    String readString(){\n        while(!tok.hasMoreTokens()){\n            String nextLine = readLine();\n            if(nextLine == null) return null;\n            tok = new StringTokenizer(nextLine);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt(){\n        return Integer.parseInt(readString());\n    }\n\n    long readLong(){\n        return Long.parseLong(readString());\n    }\n\n    double readDouble(){\n        return Double.parseDouble(readString());\n    }\n}\n", "index": 486, "complexity": 5}
{"back-translation": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner r = new Scanner(System.in);\n        int n = r.nextInt();\n        int[] l = new int[1005];\n        int[] ri = new int[1005];\n        int[] candy = new int[1005];\n        for (int i = 1; i <= n; ++i) {\n            l[i] = r.nextInt();\n        }\n        for (int i = 1; i <= n; ++i) {\n            ri[i] = r.nextInt();\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (l[i] > i - 1 || ri[i] > n - i) {\n                System.out.println(\"NO\");\n                System.exit(0);\n            }\n            candy[i] = n - l[i] - ri[i];\n        }\n        for (int i = 1; i <= n; ++i) {\n            int left = 0, right = 0;\n            for (int j = 1; j <= i - 1; ++j) {\n                if (candy[j] > candy[i]) {\n                    ++left;\n                }\n            }\n            for (int j = i + 1; j <= n; ++j) {\n                if (candy[j] > candy[i]) {\n                    ++right;\n                }\n            }\n            if (left != l[i] || right != ri[i]) {\n                System.out.println(\"NO\");\n                System.exit(0);\n            }\n        }\n        System.out.println(\"YES\");\n        for (int i = 1; i <= n; ++i) {\n            System.out.print(candy[i] + \" \");\n        }\n    }\n}", "src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class java2 {\n    public static void main(String[] args) {\n        Scanner r = new Scanner(System.in);\n        int n=r.nextInt();\n        int []l=new int[1005];\n        int []ri=new int[1005];\n        int []candy=new int[1005];\n        for(int i=1;i<=n;++i)\n        {\n            l[i]=r.nextInt();\n        }\n        for(int i=1;i<=n;++i)\n        {\n            ri[i]=r.nextInt();\n        }\n        for(int i=1;i<=n;++i)\n        {\n            if(l[i]>i-1||ri[i]>n-i)\n            {\n                System.out.println(\"NO\");\n                System.exit(0);\n            }\n            candy[i]=n-l[i]-ri[i];\n        }\n        for(int i=1;i<=n;++i)\n        {\n            int left=0,right=0;\n            for(int j=1;j<=i-1;++j)\n            {\n                if(candy[j]>candy[i])\n                {\n                    ++left;\n                }\n            }\n            for(int j=i+1;j<=n;++j)\n            {\n                if(candy[j]>candy[i])\n                {\n                    ++right;\n                }\n            }\n            if(left!=l[i]||right!=ri[i])\n            {\n                System.out.println(\"NO\");\n                System.exit(0);\n            }\n        }\n        System.out.println(\"YES\");\n        for(int i=1;i<=n;++i)\n        {\n            System.out.print(candy[i]+\" \");\n        }\n    }\n}\n", "index": 487, "complexity": 5}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] a = new int[100005];\n\t\tint[] vis = new int[100005];\n\t\tint maxx = -1;\n\t\tint n, k;\n\t\tint e = 0, s = 0;\n\t\tint ans = 0;\n\n\t\tn = sc.nextInt();\n\t\tk = sc.nextInt();\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tif (a[i] == 1) {\n\t\t\t\te++;\n\t\t\t} else {\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint e1 = 0;\n\t\t\tint s1 = 0;\n\t\t\tfor (int j = i; j <= n; j += k) {\n\t\t\t\tif (a[j] == 1) {\n\t\t\t\t\te1++;\n\t\t\t\t} else {\n\t\t\t\t\ts1++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.abs((s - s1) - (e - e1));\n\t\t\tmaxx = Math.max(maxx, ans);\n\t\t}\n\t\tSystem.out.print(maxx);\n\t}\n\n}", "src": "import java.util.Scanner;\n\npublic class Amain {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[] = new int[100005];\n\t\tint vis[] = new int[100005];\n\t\tint maxx = -1;\n\t\tint n , k ;\n\t\tint e = 0  , s = 0 ;\n\t\tint ans = 0  ;\n\t\t\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\n\t\tfor(int i = 1 ; i<=n ; i++ )\n\t\t{\n\t\t\ta[i]=sc.nextInt() ;\n\t\t\tif(a[i]== 1 )\n\t\t\t{\n\t\t\t\te++ ; //\u8bb0\u5f55\u5e26\u6709test\u6807\u7b7e\u7684\u7f51\u9875\u4e2a\u6570 ; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts++ ;// \u8bb0\u5f55\u5e26\u6709\u793e\u4ea4\u6807\u7b7e\u7684\u7f51\u7ad9\u4e2a\u6570; \n\t\t\t}\n\t\t}\n\t    // \u9898\u76ee\u4e2d\u7684  c=b+i\u22c5k \u5927\u6982\u5c31\u662f\u6bcf\u9694 k \u7684\u5c31\u5173\u4e00\u4e2a\u7f51\u9875 \n\t\tfor(int i = 1 ; i<=k  ;i++ )\n\t\t{\n\t\t\tint e1 = 0 ; // \u8bb0\u5f55\u5e94\u8be5\u5173\u95ed\u7684\u5e26\u6709test\u6807\u7b7e\u7684\u7f51\u9875\u4e2a\u6570 \n\t\t\tint s1 = 0 ;  // \u8bb0\u5f55\u5e94\u8be5\u5173\u95ed\u7684\u5e26\u6709\u793e\u4ea4\u6807\u7b7e\u7684\u7f51\u9875\u4e2a\u6570\n\t\t\tfor(int j = i ; j<=n ;j+=k )\n\t\t\t{\n\t\t\t\tif(a[j]==1 )\n\t\t\t\t{\n\t\t\t\t\te1++ ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1++ ;\n\t\t\t\t}\n\t\t\t}\n\t        // s-s1 \u5c31\u662f\u8fd8\u5269\u7684\u5e26\u6709\u793e\u4ea4\u6807\u7b7e\u7684\u7f51\u9875\u4e2a\u6570;\n\t        // e-e1 \u5c31\u662f\u8fd8\u5269\u7684\u5e26\u6709test\u6807\u7b7e\u7684\u7f51\u9875\u4e2a\u6570; \n\t \n\t\t\tans = Math.abs(  (s-s1)-(e-e1)) ; // | s -e |\n\t\t\tmaxx = Math.max(maxx,ans) ; // \u6c42\u6700\u5927\u7684\n\t\t}\n       System.out.print(maxx);\n\t}\n\n}\n", "index": 488, "complexity": 5}
{"back-translation": "class Node {\n    int data;\n    Node left, right;\n\n    Node(int item) {\n        data = item;\n        left = right = null;\n    }\n}\n\nclass BinaryTree {\n    Node root;\n\n    void convertTree(Node node) {\n        int left_data = 0, right_data = 0, diff;\n\n        if (node == null || (node.left == null && node.right == null))\n            return;\n        else {\n            convertTree(node.left);\n            convertTree(node.right);\n\n            if (node.left != null)\n                left_data = node.left.data;\n\n            if (node.right != null)\n                right_data = node.right.data;\n\n            diff = left_data + right_data - node.data;\n\n            if (diff > 0)\n                node.data = node.data + diff;\n\n            if (diff < 0)\n                increment(node, -diff);\n        }\n    }\n\n    void increment(Node node, int diff) {\n        if (node.left != null) {\n            node.left.data = node.left.data + diff;\n            increment(node.left, diff);\n        } else if (node.right != null) {\n            node.right.data = node.right.data + diff;\n            increment(node.right, diff);\n        }\n    }\n\n    void printInorder(Node node) {\n        if (node == null)\n            return;\n\n        printInorder(node.left);\n        System.out.print(node.data + \" \");\n        printInorder(node.right);\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node(50);\n        tree.root.left = new Node(7);\n        tree.root.right = new Node(2);\n        tree.root.left.left = new Node(3);\n        tree.root.left.right = new Node(5);\n        tree.root.right.left = new Node(1);\n        tree.root.right.right = new Node(30);\n\n        System.out.println(\"Inorder traversal before conversion is :\");\n        tree.printInorder(tree.root);\n\n        tree.convertTree(tree.root);\n\n        System.out.println(\"\");\n\n        System.out.println(\"Inorder traversal after conversion is :\");\n        tree.printInorder(tree.root);\n    }\n}", "src": "\n\n// Java program to convert an arbitrary binary tree to a tree that holds \n// children sum property \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n/* This function changes a tree to hold children sum \n\nproperty */\n\n\nvoid\nconvertTree(Node node) \n\n{ \n\nint\nleft_data = \n0\n, right_data = \n0\n, diff; \n\n\n/* If tree is empty or it's a leaf node then \n\nreturn true */\n\nif\n(node == \nnull\n\n|| (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n; \n\nelse\n\n{ \n\n/* convert left and right subtrees */\n\nconvertTree(node.left); \n\nconvertTree(node.right); \n\n\n/* If left child is not present then 0 is used \n\nas data of left child */\n\nif\n(node.left != \nnull\n) \n\nleft_data = node.left.data; \n\n\n/* If right child is not present then 0 is used \n\nas data of right child */\n\nif\n(node.right != \nnull\n) \n\nright_data = node.right.data; \n\n\n/* get the diff of node's data and children sum */\n\ndiff = left_data + right_data - node.data; \n\n\n/* If node's children sum is greater than the node's data */\n\nif\n(diff > \n0\n) \n\nnode.data = node.data + diff; \n\n\n/* THIS IS TRICKY --> If node's data is greater than children \n\nsum, then increment subtree by diff */\n\nif\n(diff < \n0\n) \n\n\n// -diff is used to make diff positive \n\nincrement(node, -diff); \n\n} \n\n} \n\n\n/* This function is used to increment subtree by diff */\n\nvoid\nincrement(Node node, \nint\ndiff) \n\n{ \n\n/* IF left child is not NULL then increment it */\n\nif\n(node.left != \nnull\n) \n\n{ \n\nnode.left.data = node.left.data + diff; \n\n\n// Recursively call to fix the descendants of node->left \n\nincrement(node.left, diff); \n\n} \n\nelse\nif\n(node.right != \nnull\n) \n// Else increment right child \n\n{ \n\nnode.right.data = node.right.data + diff; \n\n\n// Recursively call to fix the descendants of node->right \n\nincrement(node.right, diff); \n\n} \n\n} \n\n\n/* Given a binary tree, printInorder() prints out its \n\ninorder traversal*/\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n/* first recur on left child */\n\nprintInorder(node.left); \n\n\n/* then print the data of node */\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n/* now recur on right child */\n\nprintInorder(node.right); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n50\n); \n\ntree.root.left = \nnew\nNode(\n7\n); \n\ntree.root.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n1\n); \n\ntree.root.right.right = \nnew\nNode(\n30\n); \n\n\nSystem.out.println(\n\"Inorder traversal before conversion is :\"\n); \n\ntree.printInorder(tree.root); \n\n\ntree.convertTree(tree.root); \n\nSystem.out.println(\n\"\"\n); \n\n\nSystem.out.println(\n\"Inorder traversal after conversion is :\"\n); \n\ntree.printInorder(tree.root); \n\n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "index": 489, "complexity": 5}
{"back-translation": "import java.util.*;\npublic class TestClass {\n    public static void main(String args[]) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int k = in.nextInt();\n        int arr[] = new int[n + 1];\n        for (int i = 0; i < n; i++)\n            arr[i + 1] = in.nextInt();\n        long sum[] = new long[n + 1];\n        for (int i = 1; i <= n; i++)\n            sum[i] = sum[i - 1] + arr[i];\n        long dp[] = new long[n + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = i; j > i - m && j >= 1; j--) {\n                long val = sum[i] - sum[j - 1] + dp[j - 1] - k;\n                dp[i] = Math.max(dp[i], val);\n            }\n        }\n        long max = 0;\n        for (int i = 1; i <= n; i++)\n            max = Math.max(max, dp[i]);\n        System.out.println(max);\n    }\n}", "src": "import java.util.*;\npublic class TestClass\n{\n   public static void main(String args[])\n   {\n   \tScanner in = new Scanner(System.in);\n   \tint n = in.nextInt();\n   \tint m = in.nextInt();\n   \tint k = in.nextInt();\n   \tint arr[] = new int[n+1];\n   \tfor(int i =0;i<n;i++)\n   \t arr[i+1]= in.nextInt();\n   \t\n   \tlong sum[] = new long [n+1];\n   \t\n   \tfor(int i=1;i<=n;i++)\n   \t sum[i]=sum[i-1]+arr[i];\n   \t\n    long dp[] = new long[n+1];\n\n    for(int i =1;i<=n;i++)\n    {\n      for(int j=i;j>i-m&&j>=1;j--)\n      {\n        long val = sum[i]-sum[j-1]+dp[j-1]-k;\n        dp[i]= Math.max(dp[i],val);\n      }\t\n    }\n    long max =0;\n    for(int i =1;i<=n;i++)\n     max=Math.max(max,dp[i]);\n    \n    System.out.println(max);\n     \n   }\t\n}", "index": 490, "complexity": 5}
{"back-translation": "class GFG { static int permutationCoeff(int n, int k) { int[][] P = new int[n + 2][k + 2]; for (int i = 0; i <= n; i++) { for (int j = 0; j <= Math.min(i, k); j++) { if (j == 0) P[i][j] = 1; else P[i][j] = P[i - 1][j] + (j * P[i - 1][j - 1]); P[i][j + 1] = 0; } } return P[n][k]; } public static void main(String args[]) { int n = 10, k = 2; System.out.println(\"Value of P( \" + n + \",\" + k + \")\" + \" is \" + permutationCoeff(n, k)); } }", "src": "\n// Java code for Dynamic Programming based \n// solution that uses table P[][] to \n// calculate the Permutation Coefficient \nimport\njava.io.*; \nimport\njava.math.*; \n\nclass\nGFG \n{ \n\n\n// Returns value of Permutation \n\n// Coefficient P(n, k) \n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nP[][] = \nnew\nint\n[n + \n2\n][k + \n2\n]; \n\n\n// Caculate value of Permutation \n\n// Coefficient in bottom up manner \n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; \n\nj <= Math.min(i, k); \n\nj++) \n\n{ \n\n// Base Cases \n\nif\n(j == \n0\n) \n\nP[i][j] = \n1\n; \n\n\n// Calculate value using previosly \n\n// stored values \n\nelse\n\nP[i][j] = P[i - \n1\n][j] + \n\n(j * P[i - \n1\n][j - \n1\n]); \n\n\n// This step is important \n\n// as P(i,j)=0 for j>i \n\nP[i][j + \n1\n] = \n0\n; \n\n} \n\n} \n\nreturn\nP[n][k]; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ k +\n\")\"\n+ \n\n\" is \"\n+ permutationCoeff(n, k) ); \n\n} \n} \n\n// This code is contributed by Nikita Tiwari. ", "index": 491, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Solution{\n    \n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    public static void main(String args[] ) {\n        \n        FastReader sc = new FastReader();\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] arr = new int[105];\n        \n        for(int i=0;i<m;i++){\n            int a = sc.nextInt();\n            arr[a]++;\n        }\n        \n        for(int i=1;i<=1000;i++){\n            int sum=0;\n            \n            for(int a:arr){\n                if(a!=0){\n                    sum+=(a/i);\n                }\n            }\n            \n            \n            if(sum<n){\n                System.out.println(i-1);\n                return;\n            }\n            \n        }\n    }\n\n}\n", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution{\n    \n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    public static void main(String args[] ) {\n        \n        FastReader sc = new FastReader();\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] arr = new int[105];\n        \n        for(int i=0;i<m;i++){\n            int a = sc.nextInt();\n            arr[a]++;\n        }\n        \n        for(int i=1;i<=1000;i++){\n            int sum=0;\n            \n            for(int a:arr){\n                if(a!=0){\n                    sum+=(a/i);\n                }\n            }\n            \n            \n            if(sum<n){\n                System.out.println(i-1);\n                return;\n            }\n            \n        }\n    }\n\n}\n", "index": 492, "complexity": 5}
{"back-translation": "public class GFG {\n\nstatic int countPS(String str) {\nint N = str.length();\nint[][] cps = new int[N+1][N+1];\nfor (int i = 0; i < N; i++) {\ncps[i][i] = 1;\n}\nfor (int L = 2; L <= N; L++) {\nfor (int i = 0; i < N; i++) {\nint k = L + i - 1;\nif (k < N) {\nif (str.charAt(i) == str.charAt(k)) {\ncps[i][k] = cps[i][k-1] + cps[i+1][k] + 1;\n} else {\ncps[i][k] = cps[i][k-1] + cps[i+1][k] - cps[i+1][k-1];\n}\n}\n}\n}\nreturn cps[0][N-1];\n}\n\npublic static void main(String args[]) {\nString str = \"abcb\";\nSystem.out.println(\"Total palindromic \" + \"subsequence are : \" + countPS(str));\n}\n}", "src": "\n// Java code to Count Palindromic Subsequence \n// in a given String \npublic\nclass\nGFG \n{ \n\n// Function return the total palindromic \n\n// subsequence \n\nstatic\nint\ncountPS(String str) \n\n{ \n\nint\nN = str.length(); \n\n\n// create a 2D array to store the count \n\n// of palindromic subsequence \n\nint\n[][] cps = \nnew\nint\n[N+\n1\n][N+\n1\n]; \n\n\n// palindromic subsequence of length 1 \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ncps[i][i] = \n1\n; \n\n\n// check subsequence of length L is \n\n// palindrome or not \n\nfor\n(\nint\nL=\n2\n; L<=N; L++) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\n{ \n\nint\nk = L + i - \n1\n; \n\nif\n(k < N){ \n\nif\n(str.charAt(i) == str.charAt(k)) \n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] + \n1\n; \n\nelse\n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] - \n\ncps[i+\n1\n][k-\n1\n]; \n\n} \n\n} \n\n} \n\n\n// return total palindromic subsequence \n\nreturn\ncps[\n0\n][N-\n1\n]; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"abcb\"\n; \n\nSystem.out.println(\n\"Total palindromic \"\n+ \n\n\"subsequence are : \"\n\n+ countPS(str)); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "index": 493, "complexity": 5}
{"back-translation": "class Node {\n    int data;\n    Node left, right;\n\n    Node(int item) {\n        data = item;\n        left = right;\n    }\n}\n\nclass BinaryTree {\n    Node root;\n\n    void reverseLevelOrder(Node node) {\n        int h = height(node);\n        for (int i = h; i >= 1; i--) {\n            printGivenLevel(node, i);\n        }\n    }\n\n    void printGivenLevel(Node node, int level) {\n        if (node == null)\n            return;\n        if (level == 1)\n            System.out.print(node.data + \" \");\n        else if (level > 1) {\n            printGivenLevel(node.left, level - 1);\n            printGivenLevel(node.right, level - 1);\n        }\n    }\n\n    int height(Node node) {\n        if (node == null)\n            return 0;\n        else {\n            int lheight = height(node.left);\n            int rheight = height(node.right);\n            if (lheight > rheight)\n                return (lheight + 1);\n            else\n                return (rheight + 1);\n        }\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node(1);\n        tree.root.left = new Node(2);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(4);\n        tree.root.left.right = new Node(5);\n        System.out.println(\"Level Order traversal of binary tree is : \");\n        tree.reverseLevelOrder(tree.root);\n    }\n}", "src": "\n// A recursive java program to print reverse level order traversal \n\n// A binary tree node \nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* Function to print REVERSE level order traversal a tree*/\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\nfor\n(i = h; i >= \n1\n; i--) \n\n//THE ONLY LINE DIFFERENT FROM NORMAL LEVEL ORDER \n\n{ \n\nprintGivenLevel(node, i); \n\n} \n\n} \n\n\n/* Print nodes at a given level */\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) \n\n{ \n\nprintGivenLevel(node.left, level - \n1\n); \n\nprintGivenLevel(node.right, level - \n1\n); \n\n} \n\n} \n\n\n/* Compute the \"height\" of a tree -- the number of \n\nnodes along the longest path from the root node \n\ndown to the farthest leaf node.*/\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n\n{ \n\n/* compute the height of each subtree */\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n/* use the larger one */\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n// Let us create trees shown in above diagram \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is : \"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 494, "complexity": 5}
{"back-translation": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        TaskG solver = new TaskG();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskG {\n        private static final long MODULO = (long) 1e9 + 7;\n        private static final long BIG = Long.MAX_VALUE - Long.MAX_VALUE % MODULO;\n        private static final int[] ONE = new int[]{1};\n        private int k;\n        private int n;\n        private long[] globalRes;\n        private int[] p2;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt();\n            k = in.nextInt();\n            globalRes = new long[k + 1];\n            p2 = new int[n + 1];\n            p2[0] = 1;\n            for (int i = 1; i <= n; ++i) {\n                p2[i] = (int) (2 * p2[i - 1] % MODULO);\n            }\n            Vertex[] vs = new Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                vs[i] = new Vertex();\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                Vertex a = vs[in.nextInt() - 1];\n                Vertex b = vs[in.nextInt() - 1];\n                a.adj.add(b);\n                b.adj.add(a);\n            }\n            vs[0].dfs(null);\n            long[][] ways = new long[k + 1][k + 1];\n            ways[0][0] = 1;\n            for (int i = 1; i <= k; ++i) {\n                for (int j = 1; j <= k; ++j) {\n                    ways[i][j] = j * (ways[i - 1][j] + ways[i - 1][j - 1]) % MODULO;\n                }\n            }\n            long sum = 0;\n            for (int i = 1; i <= k; ++i) {\n                long s = globalRes[i];\n                s %= MODULO;\n                sum = (sum + s * ways[k][i]) % MODULO;\n            }\n            out.println(sum);\n        }\n\n        class Vertex {\n            private int[] res;\n            private int subtreeSize;\n            private List<Vertex> adj = new ArrayList<>();\n\n            public void dfs(Vertex parent) {\n                subtreeSize = 1;\n                int[] prod = ONE;\n                for (Vertex child : adj) {\n                    if (child != parent) {\n                        child.dfs(this);\n                        subtreeSize += child.subtreeSize;\n                    }\n                }\n                int mult = 2;\n                for (Vertex child : adj) {\n                    if (child != parent) {\n                        int[] c = child.res;\n                        prod = mul(prod, c);\n                        subFrom(globalRes, c, 1);\n                    }\n                }\n                addTo(globalRes, prod, mult);\n                res = insertEdge(prod);\n            }\n\n            private int[] insertEdge(int[] a) {\n                int len = a.length + 1;\n                if (len > k) {\n                    len = k + 1;\n                }\n                int[] b = new int[len];\n                b[0] = a[0] * 2;\n                if (b[0] >= MODULO) {\n                    b[0] -= MODULO;\n                }\n                for (int i = 1; i < len; ++i) {\n                    long s = a[i - 1];\n                    if (i < a.length) {\n                        s += a[i];\n                    }\n                    if (s >= MODULO) {\n                        s -= MODULO;\n                    }\n                    s = s * 2;\n                    if (s >= MODULO) {\n                        s -= MODULO;\n                    }\n                    b[i] = (int) s;\n                }\n                b[1] -= 1;\n                if (b[1] < 0) {\n                    b[1] += MODULO;\n                }\n                return b;\n            }\n\n            private void addTo(long[] a, int[] b, int mult) {\n                for (int i = 0; i < b.length; ++i) {\n                    long s = a[i] + b[i] * (long) mult;\n                    if (s < 0) {\n                        s -= BIG;\n                    }\n                    a[i] = s;\n                }\n            }\n\n            private void subFrom(long[] a, int[] b, int mult) {\n                for (int i = 0; i < b.length; ++i) {\n                    long s = a[i] + (MODULO - b[i]) * (long) mult;\n                    if (s < 0) {\n                        s -= BIG;\n                    }\n                    a[i] = s;\n                }\n            }\n\n            private int[] mul(int[] a, int[] b) {\n                int len = a.length + b.length - 1;\n                if (len > k) {\n                    len = k + 1;\n                }\n                int[] c = new int[len];\n                for (int i = 0; i < len; ++i) {\n                    long s = 0;\n                    int left = Math.max(0, i - (b.length - 1));\n                    int right = Math.min(a.length - 1, i);\n                    for (int ia = left; ia <= right; ++ia) {\n                        int ib = i - ia;\n                        s += a[ia] * (long) b[ib];\n                        if (s < 0) {\n                            s -= BIG;\n                        }\n                    }\n                    c[i] = (int) (s % MODULO);\n                }\n                return c;\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskG solver = new TaskG();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskG {\n        static final long MODULO = (long) 1e9 + 7;\n        static final long BIG = Long.MAX_VALUE - Long.MAX_VALUE % MODULO;\n        static final int[] ONE = new int[]{1};\n        int k;\n        int n;\n        long[] globalRes;\n        int[] p2;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt();\n            k = in.nextInt();\n            globalRes = new long[k + 1];\n            p2 = new int[n + 1];\n            p2[0] = 1;\n            for (int i = 1; i <= n; ++i) p2[i] = (int) (2 * p2[i - 1] % MODULO);\n            Vertex[] vs = new Vertex[n];\n            for (int i = 0; i < n; ++i) vs[i] = new Vertex();\n            for (int i = 0; i < n - 1; ++i) {\n                Vertex a = vs[in.nextInt() - 1];\n                Vertex b = vs[in.nextInt() - 1];\n                a.adj.add(b);\n                b.adj.add(a);\n            }\n            vs[0].dfs(null);\n            long[][] ways = new long[k + 1][k + 1];\n            ways[0][0] = 1;\n            for (int i = 1; i <= k; ++i) {\n                for (int j = 1; j <= k; ++j) {\n                    ways[i][j] = j * (ways[i - 1][j] + ways[i - 1][j - 1]) % MODULO;\n                }\n            }\n            long sum = 0;\n            for (int i = 1; i <= k; ++i) {\n                long s = globalRes[i];\n                s %= MODULO;\n                sum = (sum + s * ways[k][i]) % MODULO;\n            }\n            out.println(sum);\n        }\n\n        class Vertex {\n            int[] res;\n            int subtreeSize;\n            List<Vertex> adj = new ArrayList<>();\n\n            public void dfs(Vertex parent) {\n                subtreeSize = 1;\n                int[] prod = ONE;\n                for (Vertex child : adj)\n                    if (child != parent) {\n                        child.dfs(this);\n                        subtreeSize += child.subtreeSize;\n                    }\n                int mult = 2;//p2[n - subtreeSize];\n                for (Vertex child : adj)\n                    if (child != parent) {\n                        int[] c = child.res;\n                        prod = mul(prod, c);\n                        subFrom(globalRes, c, 1);\n                    }\n                addTo(globalRes, prod, mult);\n                res = insertEdge(prod);\n            }\n\n            private int[] insertEdge(int[] a) {\n                int len = a.length + 1;\n                if (len > k) len = k + 1;\n                int[] b = new int[len];\n                b[0] = a[0] * 2;\n                if (b[0] >= MODULO) b[0] -= MODULO;\n                for (int i = 1; i < len; ++i) {\n                    long s = a[i - 1];\n                    if (i < a.length) s += a[i];\n                    if (s >= MODULO) s -= MODULO;\n                    s = s * 2;\n                    if (s >= MODULO) s -= MODULO;\n                    b[i] = (int) s;\n                }\n                b[1] -= 1;\n                if (b[1] < 0) b[1] += MODULO;\n                return b;\n            }\n\n            private void addTo(long[] a, int[] b, int mult) {\n                for (int i = 0; i < b.length; ++i) {\n                    long s = a[i] + b[i] * (long) mult;\n                    if (s < 0) s -= BIG;\n                    a[i] = s;\n                }\n            }\n\n            private void subFrom(long[] a, int[] b, int mult) {\n                for (int i = 0; i < b.length; ++i) {\n                    long s = a[i] + (MODULO - b[i]) * (long) mult;\n                    if (s < 0) s -= BIG;\n                    a[i] = s;\n                }\n            }\n\n            private int[] mul(int[] a, int[] b) {\n                int len = a.length + b.length - 1;\n                if (len > k) len = k + 1;\n                int[] c = new int[len];\n                for (int i = 0; i < len; ++i) {\n                    long s = 0;\n                    int left = Math.max(0, i - (b.length - 1));\n                    int right = Math.min(a.length - 1, i);\n                    for (int ia = left; ia <= right; ++ia) {\n                        int ib = i - ia;\n                        s += a[ia] * (long) b[ib];\n                        if (s < 0) s -= BIG;\n                    }\n                    c[i] = (int) (s % MODULO);\n                }\n                return c;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "index": 496, "complexity": 5}
{"back-translation": "class EDIST { static int min(int x, int y, int z) { if (x <= y && x <= z) return x; if (y <= x && y <= z) return y; else return z; } static int editDistDP(String str1, String str2, int m, int n) { int dp[][] = new int[m+1][n+1]; for (int i=0; i<=m; i++) { for (int j=0; j<=n; j++) { if (i==0) dp[i][j] = j; else if (j==0) dp[i][j] = i; else if (str1.charAt(i-1) == str2.charAt(j-1)) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]); } } return dp[m][n]; } public static void main(String args[]) { String str1 = \"sunday\"; String str2 = \"saturday\"; System.out.println( editDistDP( str1 , str2 , str1.length(), str2.length()) ); } }", "src": "\n// A Dynamic Programming based Java program to find minimum \n// number operations to convert str1 to str2 \nclass\nEDIST \n{ \n\nstatic\nint\nmin(\nint\nx,\nint\ny,\nint\nz) \n\n{ \n\nif\n(x <= y && x <= z) \nreturn\nx; \n\nif\n(y <= x && y <= z) \nreturn\ny; \n\nelse\nreturn\nz; \n\n} \n\n\nstatic\nint\neditDistDP(String str1, String str2, \nint\nm, \nint\nn) \n\n{ \n\n// Create a table to store results of subproblems \n\nint\ndp[][] = \nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\n// Fill d[][] in bottom up manner \n\nfor\n(\nint\ni=\n0\n; i<=m; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<=n; j++) \n\n{ \n\n// If first string is empty, only option is to \n\n// insert all characters of second string \n\nif\n(i==\n0\n) \n\ndp[i][j] = j; \n// Min. operations = j \n\n\n// If second string is empty, only option is to \n\n// remove all characters of second string \n\nelse\nif\n(j==\n0\n) \n\ndp[i][j] = i; \n// Min. operations = i \n\n\n// If last characters are same, ignore last char \n\n// and recur for remaining string \n\nelse\nif\n(str1.charAt(i-\n1\n) == str2.charAt(j-\n1\n)) \n\ndp[i][j] = dp[i-\n1\n][j-\n1\n]; \n\n\n// If the last character is different, consider all \n\n// possibilities and find the minimum \n\nelse\n\ndp[i][j] = \n1\n+ min(dp[i][j-\n1\n], \n// Insert \n\ndp[i-\n1\n][j], \n// Remove \n\ndp[i-\n1\n][j-\n1\n]); \n// Replace \n\n} \n\n} \n\n\nreturn\ndp[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str1 = \n\"sunday\"\n; \n\nString str2 = \n\"saturday\"\n; \n\nSystem.out.println( editDistDP( str1 , str2 , str1.length(), str2.length()) ); \n\n} \n}\n/*This code is contributed by Rajat Mishra*/", "index": 497, "complexity": 5}
{"back-translation": "class GFG { static void findMajority(int arr[], int n) { int maxCount = 0; int index = -1; for (int i = 0; i < n; i++) { int count = 0; for (int j = 0; j < n; j++) { if (arr[i] == arr[j]) count++; } if (count > maxCount) { maxCount = count; index = i; } } if (maxCount > n/2) System.out.println(arr[index]); else System.out.println(\"No Majority Element\"); } public static void main(String[] args) { int arr[] = {1, 1, 2, 1, 3, 5, 1}; int n = arr.length; findMajority(arr, n); } }", "src": "\n// Java program to find Majority \n// element in an array \n\nimport\njava.io.*; \n\nclass\nGFG { \n\n// Function to find Majority element \n// in an array \nstatic\nvoid\nfindMajority(\nint\narr[], \nint\nn) \n{ \n\nint\nmaxCount = \n0\n; \n\nint\nindex = -\n1\n; \n// sentinels \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nif\n(arr[i] == arr[j]) \n\ncount++; \n\n} \n\n\n// update maxCount if count of \n\n// current element is greater \n\nif\n(count > maxCount) \n\n{ \n\nmaxCount = count; \n\nindex = i; \n\n} \n\n} \n\n\n// if maxCount is greater than n/2 \n\n// return the corresponding element \n\nif\n(maxCount > n/\n2\n) \n\nSystem.out.println (arr[index]); \n\n\nelse\n\nSystem.out.println (\n\"No Majority Element\"\n); \n} \n\n// Driver code \n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n1\n, \n1\n, \n2\n, \n1\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n// Function calling \n\nfindMajority(arr, n); \n\n} \n//This code is contributed by ajit. \n} ", "index": 498, "complexity": 5}
{"back-translation": "import java.util.Scanner;\npublic class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n}", "src": "import java.util.Scanner;\npublic class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "index": 499, "complexity": 5}
{"back-translation": "class GFG { static void calculateSpan(int price[], int n, int S[]) { S[0] = 1; for (int i = 1; i < n; i++) { S[i] = 1; for (int j = i - 1; (j >= 0) && (price[i] >= price[j]); j--) S[i]++; } } static void printArray(int arr[]) { System.out.print(Arrays.toString(arr)); } public static void main(String[] args) { int price[] = { 10, 4, 5, 90, 120, 80 }; int n = price.length; int S[] = new int[n]; calculateSpan(price, n, S); printArray(S); } }", "src": "\n// Java implementation for brute force method to calculate stock span values \n\nimport\njava.util.Arrays; \n\nclass\nGFG { \n\n// method to calculate stock span values \n\nstatic\nvoid\ncalculateSpan(\nint\nprice[], \nint\nn, \nint\nS[]) \n\n{ \n\n// Span value of first day is always 1 \n\nS[\n0\n] = \n1\n; \n\n\n// Calculate span value of remaining days by linearly checking \n\n// previous days \n\nfor\n(\nint\ni = \n1\n; i < n; i++) { \n\nS[i] = \n1\n; \n// Initialize span value \n\n\n// Traverse left while the next element on left is smaller \n\n// than price[i] \n\nfor\n(\nint\nj = i - \n1\n; (j >= \n0\n) && (price[i] >= price[j]); j--) \n\nS[i]++; \n\n} \n\n} \n\n\n// A utility function to print elements of array \n\nstatic\nvoid\nprintArray(\nint\narr[]) \n\n{ \n\nSystem.out.print(Arrays.toString(arr)); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nprice[] = { \n10\n, \n4\n, \n5\n, \n90\n, \n120\n, \n80\n}; \n\nint\nn = price.length; \n\nint\nS[] = \nnew\nint\n[n]; \n\n\n// Fill the span values in array S[] \n\ncalculateSpan(price, n, S); \n\n\n// print the calculated span values \n\nprintArray(S); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "index": 501, "complexity": 5}
{"back-translation": "class GFG {\n    static void printArray(int A[], int size) {\n        for (int i = 0; i < size; i++)\n            System.out.print(A[i] + \" \");\n        System.out.println(\"\");\n    }\n    static void reverse(int arr[], int l, int r) {\n        if (l < r) {\n            arr = swap(arr, l, r);\n            reverse(arr, ++l, --r);\n        }\n    }\n    static void merge(int arr[], int l, int m, int r) {\n        int i = l;\n        int j = m + 1;\n        while (i <= m && arr[i] < 0)\n            i++;\n        while (j <= r && arr[j] < 0)\n            j++;\n        reverse(arr, i, m);\n        reverse(arr, m + 1, j - 1);\n        reverse(arr, i, j - 1);\n    }\n    static void RearrangePosNeg(int arr[], int l, int r) {\n        if (l < r) {\n            int m = l + (r - l) / 2;\n            RearrangePosNeg(arr, l, m);\n            RearrangePosNeg(arr, m + 1, r);\n            merge(arr, l, m, r);\n        }\n    }\n    static int[] swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        return arr;\n    }\n    public static void main(String[] args) {\n        int arr[] = { -12, 11, -13, -5, 6, -7, 5, -3, -6 };\n        int arr_size = arr.length;\n        RearrangePosNeg(arr, 0, arr_size - 1);\n        printArray(arr, arr_size);\n    }\n}", "src": "\n// Java program to Rearrange positive and negative \n// numbers in a array \nclass\nGFG { \n\n\n/* Function to print an array */\n\nstatic\nvoid\nprintArray(\nint\nA[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(A[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n; \n\n} \n\n\n/* Function to reverse an array. An array can be \nreversed in O(n) time and O(1) space. */\n\nstatic\nvoid\nreverse(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\narr = swap(arr, l, r); \n\nreverse(arr, ++l, --r); \n\n} \n\n} \n\n\n// Merges two subarrays of arr[]. \n\n// First subarray is arr[l..m] \n\n// Second subarray is arr[m+1..r] \n\nstatic\nvoid\nmerge(\nint\narr[], \nint\nl, \nint\nm, \nint\nr) \n\n{ \n\nint\ni = l; \n// Initial index of 1st subarray \n\nint\nj = m + \n1\n; \n// Initial index of IInd \n\n\nwhile\n(i <= m && arr[i] < \n0\n) \n\ni++; \n\n\n// arr[i..m] is positive \n\n\nwhile\n(j <= r && arr[j] < \n0\n) \n\nj++; \n\n\n// arr[j..r] is positive \n\n\n// reverse positive part of \n\n// left sub-array (arr[i..m]) \n\nreverse(arr, i, m); \n\n\n// reverse negative part of \n\n// right sub-array (arr[m+1..j-1]) \n\nreverse(arr, m + \n1\n, j - \n1\n); \n\n\n// reverse arr[i..j-1] \n\nreverse(arr, i, j - \n1\n); \n\n} \n\n\n// Function to Rearrange positive and negative \n\n// numbers in a array \n\nstatic\nvoid\nRearrangePosNeg(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\n// Same as (l+r)/2, but avoids overflow for \n\n// large l and h \n\nint\nm = l + (r - l) / \n2\n; \n\n\n// Sort first and second halves \n\nRearrangePosNeg(arr, l, m); \n\nRearrangePosNeg(arr, m + \n1\n, r); \n\n\nmerge(arr, l, m, r); \n\n} \n\n} \n\nstatic\nint\n[] swap(\nint\n[] arr, \nint\ni, \nint\nj) \n\n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n\n} \n\n\n/* Driver code*/\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { -\n12\n, \n11\n, -\n13\n, -\n5\n, \n6\n, -\n7\n, \n5\n, -\n3\n, -\n6\n}; \n\nint\narr_size = arr.length; \n\n\nRearrangePosNeg(arr, \n0\n, arr_size - \n1\n); \n\n\nprintArray(arr, arr_size); \n\n} \n} \n\n// This code has been contributed by 29AjayKumar ", "index": 502, "complexity": 5}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n    private void solve() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n\n        int n = nextInt(), m = nextInt(), u = 1, d = n;\n\n        while (u < d) {\n            for (int i = 1; i <= m; i++) {\n                out.println(u + \" \" + i);\n                out.println(d + \" \" + (m - i + 1));\n            }\n            u++;\n            d--;\n        }\n        if (u == d) {\n            int l = 1, r = m;\n            while (l < r) {\n                out.println(u + \" \" + l++);\n                out.println(d + \" \" + r--);\n            }\n            if (l == r) out.println(u + \" \" + l);\n        }\n\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new D().solve();\n    }\n\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter out;\n\n    private String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return st.nextToken();\n    }\n\n    private int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    private long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    private double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n    private void solve() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n\n        int n = nextInt(), m = nextInt(), u = 1, d = n;\n\n        while (u < d) {\n            for (int i = 1; i <= m; i++) {\n                out.println(u + \" \" + i);\n                out.println(d + \" \" + (m - i + 1));\n            }\n            u++;\n            d--;\n        }\n        if (u == d) {\n            int l = 1, r = m;\n            while (l < r) {\n                out.println(u + \" \" + l++);\n                out.println(d + \" \" + r--);\n            }\n            if (l == r) out.println(u + \" \" + l);\n        }\n\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new D().solve();\n    }\n\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter out;\n\n    private String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return st.nextToken();\n    }\n\n    private int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    private long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    private double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "index": 503, "complexity": 5}
{"back-translation": "import java.util.*;\n\npublic class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n]; \n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a); \n        List<Integer> list = new ArrayList<>(); \n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0); \n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2); \n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1); \n                return;\n            }\n        }\n        System.out.println(-1); \n    }\n}", "src": "import java.util.*;\n\npublic class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "index": 506, "complexity": 5}
{"back-translation": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>();\n        Set<Integer> bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>();\n        ArrayList<Integer> bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for (int i = 0; i < n; i++) {\n            int v;\n            if (!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if (!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if (contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for (int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for (int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if (i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "src": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "index": 507, "complexity": 5}
{"back-translation": "import java.util.*;\nimport java.lang.*;\n\nclass GFG {\n    public static void SplitAndAdd(int[] A, int length, int rotation) {\n        int[] tmp = new int[length*2];\n        System.arraycopy(A, 0, tmp, 0, length);\n        System.arraycopy(A, 0, tmp, length, length);\n        for (int i=rotation; i<rotation+length; i++)\n            A[i-rotation] = tmp[i];\n    }\n\n    public static void main(String[] args) {\n        int arr[] = { 12, 10, 5, 6, 52, 36 };\n        int n = arr.length;\n        int position = 2;\n\n        SplitAndAdd(arr, n, position);\n\n        for (int i = 0; i < n; ++i)\n            System.out.print(arr[i] + \" \");\n    }\n}", "src": "\n// Java program to split array and move first \n// part to end. \nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nGFG { \n\n\n// Function to spilt array and \n\n// move first part to end \n\npublic\nstatic\nvoid\nSplitAndAdd(\nint\n[] A,\nint\nlength,\nint\nrotation){ \n\n\n//make a temporary array with double the size \n\nint\n[] tmp = \nnew\nint\n[length*\n2\n]; \n\n\n// copy array element in to new array twice \n\nSystem.arraycopy(A, \n0\n, tmp, \n0\n, length); \n\nSystem.arraycopy(A, \n0\n, tmp, length, length); \n\nfor\n(\nint\ni=rotation;i<rotation+length;i++) \n\nA[i-rotation]=tmp[i]; \n\n} \n\n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nSplitAndAdd(arr, n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n} ", "index": 508, "complexity": 5}
{"back-translation": "import java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Practice {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            String[] arr1 = new String[n];\n            String[] arr2 = new String[n];\n            for (int i = 0; i < n; i++) {\n                arr1[i] = in.next();\n            }\n            for (int i = 0; i < n; i++) {\n                arr2[i] = in.next();\n            }\n            int ans = 0;\n            boolean arr[]=new boolean[n];\n            boolean found=false;\n            for (int i = 0; i < arr1.length; i++) {\n                for(int j=0;j<arr1.length;j++){\n                    found=false;\n                    if(arr1[i].equals(arr2[j]) && !arr[j]){\n                        found=true;\n                        arr[j]=true;\n                        break;\n                    }\n                }\n                if(!found){\n                    ans++;\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    public static boolean checkPrime(int n, int p) {\n        for (int i = 2; i <= Math.sqrt(n) && i <= p; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void mergeArrays(int[] arr1, int[] arr2, int n1,\n            int n2, int[] arr3) {\n        int i = 0, j = 0, k = 0;\n        while (i < n1 && j < n2) {\n            if (arr1[i] < arr2[j]) {\n                arr3[k++] = arr1[i++];\n            } else {\n                arr3[k++] = arr2[j++];\n            }\n        }\n        while (i < n1) {\n            arr3[k++] = arr1[i++];\n        }\n        while (j < n2) {\n            arr3[k++] = arr2[j++];\n        }\n    }\n\n    public long GCD(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return GCD(b, a % b);\n    }\n\n    public static long nCr(int n, int r) {\n        return n * (n - 1) / 2;\n    }\n\n    static class InputReader {\n\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n", "src": "import java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Practice {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            String[] arr1 = new String[n];\n            String[] arr2 = new String[n];\n            for (int i = 0; i < n; i++) {\n                arr1[i] = in.next();\n            }\n            for (int i = 0; i < n; i++) {\n                arr2[i] = in.next();\n            }\n            int ans = 0;\n            boolean arr[]=new boolean[n];\n            boolean found=false;\n            for (int i = 0; i < arr1.length; i++) {\n                for(int j=0;j<arr1.length;j++){\n                    found=false;\n                    if(arr1[i].equals(arr2[j]) && !arr[j]){\n                        found=true;\n                        arr[j]=true;\n                        break;\n                    }\n                }\n                if(!found){\n                    ans++;\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    public static boolean checkPrime(int n, int p) {\n        for (int i = 2; i <= Math.sqrt(n) && i <= p; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void mergeArrays(int[] arr1, int[] arr2, int n1,\n            int n2, int[] arr3) {\n        int i = 0, j = 0, k = 0;\n        while (i < n1 && j < n2) {\n            if (arr1[i] < arr2[j]) {\n                arr3[k++] = arr1[i++];\n            } else {\n                arr3[k++] = arr2[j++];\n            }\n        }\n        while (i < n1) {\n            arr3[k++] = arr1[i++];\n        }\n        while (j < n2) {\n            arr3[k++] = arr2[j++];\n        }\n    }\n\n    public long GCD(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return GCD(b, a % b);\n    }\n\n    public static long nCr(int n, int r) {\n        return n * (n - 1) / 2;\n    }\n\n    static class InputReader {\n\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n}\n", "index": 510, "complexity": 5}
{"back-translation": "public class LongestPalinSubstring { static void printSubStr(String str, int low, int high) { System.out.println(str.substring(low, high + 1)); } static int longestPalSubstr(String str) { int n = str.length(); boolean table[][] = new boolean[n][n]; int maxLength = 1; for (int i = 0; i < n; ++i) table[i][i] = true; int start = 0; for (int i = 0; i < n - 1; ++i) { if (str.charAt(i) == str.charAt(i + 1)) { table[i][i + 1] = true; start = i; maxLength = 2; } } for (int k = 3; k <= n; ++k) { for (int i = 0; i < n - k + 1; ++i) { int j = i + k - 1; if (table[i + 1][j - 1] && str.charAt(i) == str.charAt(j)) { table[i][j] = true; if (k > maxLength) { start = i; maxLength = k; } } } } System.out.print(\"Longest palindrome substring is: \"); printSubStr(str, start, start + maxLength - 1); return maxLength; } public static void main(String[] args) { String str = \"forgeeksskeegfor\"; System.out.println(\"Length is: \" + longestPalSubstr(str)); } }", "src": "\n// Java Solution \npublic\nclass\nLongestPalinSubstring \n{ \n\n// A utility function to print a substring str[low..high] \n\nstatic\nvoid\nprintSubStr(String str, \nint\nlow, \nint\nhigh) { \n\nSystem.out.println(str.substring(low, high + \n1\n)); \n\n} \n\n\n// This function prints the longest palindrome substring \n\n// of str[]. \n\n// It also returns the length of the longest palindrome \n\nstatic\nint\nlongestPalSubstr(String str) { \n\nint\nn = str.length(); \n// get length of input string \n\n\n// table[i][j] will be false if substring str[i..j] \n\n// is not palindrome. \n\n// Else table[i][j] will be true \n\nboolean\ntable[][] = \nnew\nboolean\n[n][n]; \n\n\n// All substrings of length 1 are palindromes \n\nint\nmaxLength = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\ntable[i][i] = \ntrue\n; \n\n\n// check for sub-string of length 2. \n\nint\nstart = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nif\n(str.charAt(i) == str.charAt(i + \n1\n)) { \n\ntable[i][i + \n1\n] = \ntrue\n; \n\nstart = i; \n\nmaxLength = \n2\n; \n\n} \n\n} \n\n\n// Check for lengths greater than 2. k is length \n\n// of substring \n\nfor\n(\nint\nk = \n3\n; k <= n; ++k) { \n\n\n// Fix the starting index \n\nfor\n(\nint\ni = \n0\n; i < n - k + \n1\n; ++i) \n\n{ \n\n// Get the ending index of substring from \n\n// starting index i and length k \n\nint\nj = i + k - \n1\n; \n\n\n// checking for sub-string from ith index to \n\n// jth index iff str.charAt(i+1) to \n\n// str.charAt(j-1) is a palindrome \n\nif\n(table[i + \n1\n][j - \n1\n] && str.charAt(i) == \n\nstr.charAt(j)) { \n\ntable[i][j] = \ntrue\n; \n\n\nif\n(k > maxLength) { \n\nstart = i; \n\nmaxLength = k; \n\n} \n\n} \n\n} \n\n} \n\nSystem.out.print(\n\"Longest palindrome substring is; \"\n); \n\nprintSubStr(str, start, start + maxLength - \n1\n); \n\n\nreturn\nmaxLength; \n// return length of LPS \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nString str = \n\"forgeeksskeegfor\"\n; \n\nSystem.out.println(\n\"Length is: \"\n+ \n\nlongestPalSubstr(str)); \n\n} \n} \n\n// This code is contributed by Sumit Ghosh ", "index": 511, "complexity": 5}
{"back-translation": "class GFG {\n\n    static int binomialCoeff(int n, int k) {\n        int C[] = new int[k + 1];\n        C[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = Math.min(i, k); j > 0; j--) {\n                C[j] = C[j] + C[j - 1];\n            }\n        }\n        return C[k];\n    }\n\n    public static void main(String[] args) {\n        int n = 5, k = 2;\n        System.out.printf(\"Value of C(%d, %d) is %d \", n, k, binomialCoeff(n, k));\n    }\n}", "src": "\n// JAVA Code for Dynamic Programming | \n// Set 9 (Binomial Coefficient) \nimport\njava.util.*; \n\nclass\nGFG { \n\n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[] = \nnew\nint\n[k + \n1\n]; \n\n\n// nC0 is 1 \n\nC[\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\n// Compute next row of pascal \n\n// triangle using the previous row \n\nfor\n(\nint\nj = Math.min(i, k); j > \n0\n; j--) \n\nC[j] = C[j] + C[j-\n1\n]; \n\n} \n\nreturn\nC[k]; \n\n} \n\n\n/* Driver program */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.printf(\n\"Value of C(%d, %d) is %d \"\n\n, n, k, binomialCoeff(n, k)); \n\n} \n} ", "index": 512, "complexity": 5}
{"back-translation": "import java.util.Arrays; import java.io.*; class GFG { static void findTriplets(int arr[], int n) { boolean found = false; Arrays.sort(arr); for (int i = 0; i < n - 1; i++) { int l = i + 1; int r = n - 1; int x = arr[i]; while (l < r) { if (x + arr[l] + arr[r] == 0) { System.out.print(x + \" \"); System.out.print(arr[l]+ \" \"); System.out.println(arr[r]+ \" \"); l++; r--; found = true; } else if (x + arr[l] + arr[r] < 0) l++; else r--; } } if (found == false) System.out.println(\" No Triplet Found\"); } public static void main(String[] args) { int arr[] = {0, -1, 2, -3, 1}; int n =arr.length; findTriplets(arr, n); } }", "src": "\n// Java program to find triplets in a given \n// array whose sum is zero \nimport\njava.util.Arrays; \nimport\njava.io.*; \n\nclass\nGFG { \n\n// function to print triplets with 0 sum \nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n{ \n\nboolean\nfound = \nfalse\n; \n\n\n// sort array elements \n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\n// initialize left and right \n\nint\nl = i + \n1\n; \n\nint\nr = n - \n1\n; \n\nint\nx = arr[i]; \n\nwhile\n(l < r) \n\n{ \n\nif\n(x + arr[l] + arr[r] == \n0\n) \n\n{ \n\n// print elements if it's sum is zero \n\nSystem.out.print(x + \n\" \"\n); \n\nSystem.out.print(arr[l]+ \n\" \"\n); \n\nSystem.out.println(arr[r]+ \n\" \"\n); \n\n\nl++; \n\nr--; \n\nfound = \ntrue\n; \n\n} \n\n\n// If sum of three elements is less \n\n// than zero then increment in left \n\nelse\nif\n(x + arr[l] + arr[r] < \n0\n) \n\nl++; \n\n\n// if sum is greater than zero than \n\n// decrement in right side \n\nelse\n\nr--; \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\nSystem.out.println(\n\" No Triplet Found\"\n); \n} \n\n// Driven source \n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn =arr.length; \n\nfindTriplets(arr, n); \n\n} \n//This code is contributed by Tushil.. \n} ", "index": 513, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\n    static ArrayList<Integer>[] a = new ArrayList[200001];\n    static int Count(int[][] a, int n) {\n        dsu d = new dsu(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (a[i][j] == 0) {\n                    d.union(i, j);\n                }\n            }\n        }\n        int cnt = 0;\n        boolean[] chk = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            int p = d.root(i);\n            if (!chk[p]) {\n                chk[p] = true;\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n\n    public void solve() {\n        InputReader in = new InputReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = in.nextInt();\n        int a = in.nextInt();\n        int b = in.nextInt();\n        if (a == 1 || b == 1) {\n            int[][] ans = new int[n][n];\n            int temp = (a == 1) ? b : a;\n            for (int i = 1; i <= n - temp; i++) {\n                ans[i][i - 1] = 1;\n                ans[i - 1][i] = 1;\n            }\n            int freq = Count(ans, n);\n            if (freq != 1) {\n                pw.println(\"NO\");\n            } else {\n                pw.println(\"YES\");\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        if (i == j) {\n                            pw.print(0);\n                        } else\n                            pw.print((ans[i][j] + ((temp == b) ? 1 : 0)) % 2);\n                    }\n                    pw.println();\n                }\n            }\n        } else {\n            pw.print(\"NO\");\n        }\n        pw.flush();\n        pw.close();\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        new Thread(null, new Runnable() {\n            public void run() {\n                new Main().solve();\n            }\n        }, \"1\", 1 << 26).start();\n\n    }\n\n    static void debug(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public String readString() {\n            int c = snext();\n            while (isSpaceChar(c)) {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public String nextLine() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static long mod = 1000000007;\n    public static int d;\n    public static int p;\n    public static int q;\n    public void extended(int a, int b) {\n        if (b == 0) {\n            d = a;\n            p = 1;\n            q = 0;\n        } else {\n            extended(b, a % b);\n            int temp = p;\n            p = q;\n            q = temp - (a / b) * q;\n        }\n    }\n    public static long[] shuffle(long[] a, Random gen) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int ind = gen.nextInt(n - i) + i;\n            long temp = a[ind];\n            a[ind] = a[i];\n            a[i] = temp;\n        }\n        return a;\n    }\n    public static void swap(int a, int b) {\n        int temp = a;\n        a = b;\n        b = temp;\n    }\n    public static HashSet<Integer> primeFactorization(int n) {\n        HashSet<Integer> a = new HashSet<Integer>();\n        for (int i = 2; i * i <= n; i++) {\n            while (n % i == 0) {\n                a.add(i);\n                n /= i;\n            }\n        }\n        if (n != 1)\n            a.add(n);\n        return a;\n    }\n    public static void sieve(boolean[] isPrime, int n) {\n        for (int i = 1; i < n; i++)\n            isPrime[i] = true;\n\n        isPrime[0] = false;\n        isPrime[1] = false;\n\n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i] == true) {\n                for (int j = (2 * i); j < n; j += i)\n                    isPrime[j] = false;\n            }\n        }\n    }\n    public static int GCD(int a, int b) {\n        if (b == 0)\n            return a;\n        else\n            return GCD(b, a % b);\n    }\n    static class pair implements Comparable<pair> {\n        Integer x;\n        Long y;\n        pair(int x, long y) {\n            this.x = x;\n            this.y = y;\n\n        }\n\n        public int compareTo(pair o) {\n            int result = x.compareTo(o.x);\n            if (result == 0)\n                result = y.compareTo(o.y);\n\n            return result;\n        }\n\n        public String toString() {\n            return x + \" \" + y;\n        }\n\n        public boolean equals(Object o) {\n            if (o instanceof pair) {\n                pair p = (pair) o;\n                return p.x == x && p.y == y;\n            }\n            return false;\n        }\n\n        public int hashCode() {\n            return new Long(x).hashCode() * 31 + new Long(y).hashCode();\n        }\n    }\n}\nclass dsu {\n    int parent[];\n\n    dsu(int n) {\n        parent = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int root(int n) {\n        while (parent[n] != n) {\n            parent[n] = parent[parent[n]];\n            n = parent[n];\n        }\n        return n;\n    }\n\n    void union(int _a, int _b) {\n        int p_a = root(_a);\n        int p_b = root(_b);\n\n        parent[p_a] = p_b;\n\n\n    }\n\n    boolean find(int a, int b) {\n        if (root(a) == root(b))\n            return true;\n        else\n            return false;\n    }\n\n}", "src": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.lang.*;\nimport java.math.*;\n \npublic class Main{\n\t\n\tstatic ArrayList a[]=new ArrayList[200001];\n\tstatic int Count(int a[][],int n) {\n\t\tdsu d=new dsu(n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tif(a[i][j]==0) {\n\t\t\t\t\td.union(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tboolean chk[]=new boolean [n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint p=d.root(i);\n\t\t\tif(!chk[p]) {\n\t\t\t\tchk[p]=true;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t    return cnt;\n\t}\n\tpublic void solve () {\n\t\tInputReader in = new InputReader(System.in);\n\t    PrintWriter pw = new PrintWriter(System.out); \n\t    int n=in.nextInt();\n\t    int a=in.nextInt();\n\t    int b=in.nextInt();\n\t    if(a==1 || b==1) {\n\t    \tint ans[][]=new int [n][n];\n\t    \tint temp=(a==1)?b:a;\n\t    \tfor(int i=1;i<=n-temp;i++) {\n\t    \t\tans[i][i-1]=1;\n\t    \t\tans[i-1][i]=1;\n\t    \t}\n\t    \tint freq=Count(ans,n);\n\t    \tif(freq!=1) {\n\t    \t\tpw.println(\"NO\");\n\t    \t}\n\t    \telse {\n\t    \t\tpw.println(\"YES\");\n\t    \t\tfor(int i=0;i<n;i++) {\n\t    \t\t\tfor(int j=0;j<n;j++) {\n\t    \t\t\t\tif(i==j) {\n\t    \t\t\t\t\tpw.print(0);\n\t    \t\t\t\t}\n\t    \t\t\t\telse\n\t    \t\t\t\t\tpw.print((ans[i][j]+((temp==b)?1:0))%2);\n\t    \t\t\t}\n\t    \t\t\tpw.println();\n\t    \t\t}\n\t    \t}\n\t    }\n\t    else {\n\t    \tpw.print(\"NO\");\n\t    }\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\tpublic static void main(String[] args) throws Exception {\n        \n        \n        new Thread(null,new Runnable() {\n        \tpublic void run() {\n        \t\tnew Main().solve();\n        \t}\n        },\"1\",1<<26).start();\n        \n        \n    }\n    static void debug(Object... o) {\n    \tSystem.out.println(Arrays.deepToString(o));\n        }\n        \n        static class InputReader \n        {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) \n        {\n            this.stream = stream;\n        }\n        public int snext() \n        {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) \n            {\n                curChar = 0;\n                try \n                {\n                    snumChars = stream.read(buf);\n                } \n                catch (IOException e) \n                {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public int nextInt() \n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public long nextLong()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') \n            {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public int[] nextIntArray(int n) \n        {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) \n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n \n        public String readString()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n \n        public String nextLine() \n        {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n \n        public boolean isSpaceChar(int c) \n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        private boolean isEndOfLine(int c) \n        {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n        public static long mod = 1000000007;\n        public static int d;\n        public static int p;\n        public static int q;\n        public void extended(int a,int b) {\n        \tif(b==0) {\n        \t\td=a;\n        \t\tp=1;\n        \t\tq=0;\n        \t}\n        \telse\n        \t{\n        \t\textended(b,a%b);\n        \t\tint temp=p;\n        \t\tp=q;\n        \t\tq=temp-(a/b)*q;\n        \t}\n        }\n        public static long[] shuffle(long[] a,Random gen)\n        {\n            int n = a.length;\n            for(int i=0;i<n;i++)\n            {\n                int ind = gen.nextInt(n-i)+i;\n                long temp = a[ind];\n                a[ind] = a[i];\n                a[i] = temp;\n            }\n            return a;\n        }\n        \n        public static void swap(int a, int b){\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        public static HashSet<Integer> primeFactorization(int n)\n        {\n            HashSet<Integer> a =new HashSet<Integer>();\n            for(int i=2;i*i<=n;i++)\n            {\n                while(n%i==0)\n                {\n                    a.add(i);\n                    n/=i;\n                }\n            }\n            if(n!=1)\n                a.add(n);\n            return a;\n        }\n        \n        public static void sieve(boolean[] isPrime,int n)\n        {\n            for(int i=1;i<n;i++)\n                isPrime[i] = true;\n            \n            isPrime[0] = false;\n            isPrime[1] = false;\n            \n            for(int i=2;i*i<n;i++)\n            {\n                if(isPrime[i] == true)\n                {\n                    for(int j=(2*i);j<n;j+=i)\n                        isPrime[j] = false;\n                }\n            }\n        }\n        \n        public static int GCD(int a,int b)\n        {\n            if(b==0)\n                return a;\n            else\n                return GCD(b,a%b);\n        }\n        \n        static class pair implements Comparable<pair>\n        {\n            Integer x;\n            Long y;\n            pair(int x,long y)\n            {\n                this.x=x;\n                this.y=y;\n                \n            }\n            \n           \n            public int compareTo(pair o) {\n                int result = x.compareTo(o.x);\n                if(result==0)\n                    result = y.compareTo(o.y);\n                \n                return result;\n            }  \n            \n            public String toString()\n            {\n                return x+\" \"+y;\n            }\n            \n            public boolean equals(Object o)\n            {\n                if (o instanceof pair)\n                {\n                    pair p = (pair)o;\n                    return p.x == x && p.y == y ;\n                }\n                return false;\n            }\n            \n            public int hashCode()\n            {\n                return new Long(x).hashCode()*31 + new Long(y).hashCode();\n            }\n        }\n        \n    \n}\nclass pair implements Comparable<pair>\n{\n    Integer x;\n    Long y;\n    pair(int x,long y)\n    {\n        this.x=x;\n        this.y=y;\n        \n    }\n    \n   \n    public int compareTo(pair o) {\n        int result = x.compareTo(o.x);\n        if(result==0)\n            result = y.compareTo(o.y);\n        \n        return result;\n    }  \n    \n    public String toString()\n    {\n        return x+\" \"+y;\n    }\n    \n    public boolean equals(Object o)\n    {\n        if (o instanceof pair)\n        {\n            pair p = (pair)o;\n            return p.x == x && p.y == y ;\n        }\n        return false;\n    }\n    \n    public int hashCode()\n    {\n        return new Long(x).hashCode()*31 + new Long(y).hashCode();\n    }\n}\nclass dsu{\n\tint parent[];\n\tdsu(int n){\n\t\tparent=new int[n+1];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tparent[i]=i;\n\t\t}\n\t}\n\tint root(int n) {\n\t\twhile(parent[n]!=n)\n\t\t{ \n\t\t\tparent[n]=parent[parent[n]];\n\t\t\tn=parent[n];\n\t\t}\n\t\treturn n;\n\t}\n\tvoid union(int _a,int _b) {\n\t\tint p_a=root(_a);\n\t\tint p_b=root(_b);\n\t\t\n\t\t\tparent[p_a]=p_b;\n\t\t\n\t\t\t\n\t}\n\tboolean find(int a,int b) {\n\t\tif(root(a)==root(b))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn  false;\n\t}\n\t\n\t\n}\n", "index": 515, "complexity": 5}
{"back-translation": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class D {\n    static class FastWriter {\n        private BufferedWriter bw;\n\n        public FastWriter() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        public void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        BigInteger nextBigInteger() {\n            try {\n                return new BigInteger(nextLine());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int m = fr.nextInt();\n        for (int r = 0; r < n / 2; r++) {\n            for (int c = 0; c < m; c++) {\n                fw.println((r + 1) + \" \" + (c + 1));\n                fw.println((n - r) + \" \" + (m - c));\n            }\n        }\n        if (n % 2 != 0) {\n            int r = n / 2;\n            for (int c = 0; c < m / 2; c++) {\n                fw.println((r + 1) + \" \" + (c + 1));\n                fw.println((r + 1) + \" \" + (m - c));\n            }\n            if (m % 2 != 0) fw.println((r + 1) + \" \" + (m / 2 + 1));\n        }\n        fw.close();\n    }\n}", "src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class D {\n    static class FastWriter {\n        private final BufferedWriter bw;\n\n        public FastWriter() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        public void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        BigInteger nextBigInteger() {\n            try {\n                return new BigInteger(nextLine());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int m = fr.nextInt();\n        for (int r = 0; r < n / 2; r++) {\n            for (int c = 0; c < m; c++) {\n                fw.println((r + 1) + \" \" + (c + 1));\n                fw.println((n - r) + \" \" + (m - c));\n            }\n        }\n        if (n % 2 != 0) {\n            int r = n / 2;\n            for (int c = 0; c < m / 2; c++) {\n                fw.println((r + 1) + \" \" + (c + 1));\n                fw.println((r + 1) + \" \" + (m - c));\n            }\n            if (m % 2 != 0) fw.println((r + 1) + \" \" + (m / 2 + 1));\n        }\n        fw.close();\n    }\n}\n", "index": 516, "complexity": 5}
{"back-translation": "class SubarraySum {\n    boolean subArraySum(int arr[], int n, int sum) {\n        int curr_sum, i, j;\n\n        for (i = 0; i < n; i++) {\n            curr_sum = arr[i];\n\n            for (j = i + 1; j <= n; j++) {\n                if (curr_sum == sum) {\n                    int p = j - 1;\n                    System.out.println(\"Sum found between indexes \" + i + \" and \" + p);\n                    return 1;\n                }\n\n                if (curr_sum > sum || j == n)\n                    break;\n\n                curr_sum = curr_sum + arr[j];\n            }\n        }\n\n        System.out.println(\"No subarray found\");\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        SubarraySum arraysum = new SubarraySum();\n        int arr[] = {15, 2, 4, 8, 9, 5, 10, 23};\n        int n = arr.length;\n        int sum = 23;\n        arraysum.subArraySum(arr, n, sum);\n    }\n}", "src": "\nclass\nSubarraySum \n{ \n\n/* Returns true if the there is a subarray of arr[] with a sum equal to \n\n'sum' otherwise returns false. Also, prints the result */\n\nint\nsubArraySum(\nint\narr[], \nint\nn, \nint\nsum) \n\n{ \n\nint\ncurr_sum, i, j; \n\n\n// Pick a starting point \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\ncurr_sum = arr[i]; \n\n\n// try all subarrays starting with 'i' \n\nfor\n(j = i + \n1\n; j <= n; j++) \n\n{ \n\nif\n(curr_sum == sum) \n\n{ \n\nint\np = j - \n1\n; \n\nSystem.out.println(\n\"Sum found between indexes \"\n+ i \n\n+ \n\" and \"\n+ p); \n\nreturn\n1\n; \n\n} \n\nif\n(curr_sum > sum || j == n) \n\nbreak\n; \n\ncurr_sum = curr_sum + arr[j]; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No subarray found\"\n); \n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSubarraySum arraysum = \nnew\nSubarraySum(); \n\nint\narr[] = {\n15\n, \n2\n, \n4\n, \n8\n, \n9\n, \n5\n, \n10\n, \n23\n}; \n\nint\nn = arr.length; \n\nint\nsum = \n23\n; \n\narraysum.subArraySum(arr, n, sum); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal(mayank_24) ", "index": 519, "complexity": 5}
{"back-translation": "class Test { static int arr[] = new int[] { 1, 20, 6, 4, 5 }; static int getInvCount(int n) { int inv_count = 0; for (int i = 0; i < n - 1; i++) for(int j = i + 1; j < n; j++) if(arr[i] > arr[j]) inv_count++; return inv_count; } public static void main(String[] args) { System.out.println(\"Number of inversions are \" + getInvCount(arr.length)); } }", "src": "\n// Java program to count \n// inversions in an array \nclass\nTest { \n\nstatic\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\n\nstatic\nint\ngetInvCount(\nint\nn) \n\n{ \n\nint\ninv_count = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\nif\n(arr[i] > arr[j]) \n\ninv_count++; \n\n\nreturn\ninv_count; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Number of inversions are \"\n\n+ getInvCount(arr.length)); \n\n} \n} ", "index": 520, "complexity": 5}
{"back-translation": "import java.util.*;\n\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n        final long MOD = 1000000007;\n        Scanner scan = new Scanner(System.in);\n        int now = 1;\n        int maxStatements = scan.nextInt();\n        long[] dp = new long[maxStatements + 2];\n        dp[1] = 1;\n        while (maxStatements > 0) {\n            String add = scan.next();\n            if (add.equals(\"f\")) {\n                now++;\n            } else {\n                for (int k = 1; k <= now; k++) {\n                    dp[k] = ((dp[k] + dp[k-1]) % MOD);\n                }\n            }\n            maxStatements--;\n        }\n        System.out.println(dp[now]);\n    }\n}", "src": "import java.util.*;\n\npublic class HelloWorld{\n\n     public static void main(String []args){\n        final long MOD = 1000000007;\n        Scanner scan = new Scanner(System.in);\n        int now = 1;\n        int maxStatements = scan.nextInt();\n        long[] dp = new long[maxStatements + 1];\n        dp[now] = 1;\n        while(maxStatements > 0)\n        {\n            String add = scan.next();\n            if (add.equals(\"f\"))\n            {\n                now++;\n            }\n            else\n            {\n                for (int k = 1; k <= now; k++)\n                {\n                    dp[k] = ((dp[k] + dp[k-1]) % MOD);\n                }\n            }\n            maxStatements--;\n        }\n        System.out.println(dp[now]);\n     }\n}", "index": 521, "complexity": 5}
{"back-translation": "import java.util.*;\nimport java.lang.*;\n\nclass Main {\n\n    static void minAbsSumPair(int arr[], int arr_size) {\n\n        int inv_count = 0;\n        int l, r, min_sum, sum, min_l, min_r;\n\n        if (arr_size < 2) {\n            System.out.println(\"Invalid Input\");\n            return;\n        }\n\n        min_l = 0;\n        min_r = 1;\n        min_sum = arr[0] + arr[1];\n\n        for (l = 0; l < arr_size - 1; l++) {\n            for (r = l + 1; r < arr_size; r++) {\n                sum = arr[l] + arr[r];\n                if (Math.abs(min_sum) > Math.abs(sum)) {\n                    min_sum = sum;\n                    min_l = l;\n                    min_r = r;\n                }\n            }\n        }\n\n        System.out.println(\" The two elements whose \" + \"sum is minimum are \" + arr[min_l]+ \" and \" + arr[min_r]);\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {1, 60, -10, 70, -80, 85};\n        minAbsSumPair(arr, 6);\n    }\n}", "src": "\nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n/* Array should have at least two elements*/\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n/* Initialization of values */\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n} ", "index": 523, "complexity": 5}
{"back-translation": "class GFG { static void minimizeWithKSwaps(int arr[], int n, int k) { for (int i = 0; i < n - 1 && k > 0; ++i) { int pos = i; for (int j = i + 1; j < n; ++j) { if (j - i > k) break; if (arr[j] < arr[pos]) pos = j; } int temp; for (int j = pos; j > i; --j) { temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; } k -= pos - i; } } public static void main(String[] args) { int arr[] = { 7, 6, 9, 2, 1 }; int n = arr.length; int k = 3; minimizeWithKSwaps(arr, n, k); for (int i = 0; i < n; ++i) System.out.print(arr[i] + \" \"); } }", "src": "\n// Java program to find lexicographically minimum \n// value after k swaps. \nclass\nGFG { \n\n\n// Modifies arr[0..n-1] to lexicographically \n\n// smallest with k swaps. \n\nstatic\nvoid\nminimizeWithKSwaps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n-\n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n// Set the position where we want \n\n// to put the smallest integer \n\nint\npos = i; \n\nfor\n(\nint\nj = i+\n1\n; j < n ; ++j) \n\n{ \n\n\n// If we exceed the Max swaps \n\n// then terminate the loop \n\nif\n(j - i > k) \n\nbreak\n; \n\n\n// Find the minimum value from i+1 to \n\n// max k or n \n\nif\n(arr[j] < arr[pos]) \n\npos = j; \n\n} \n\n\n// Swap the elements from Minimum position \n\n// we found till now to the i index \n\nint\ntemp; \n\n\nfor\n(\nint\nj = pos; j>i; --j) \n\n{ \n\ntemp=arr[j]; \n\narr[j]=arr[j-\n1\n]; \n\narr[j-\n1\n]=temp; \n\n} \n\n\n// Set the final value after swapping pos-i \n\n// elements \n\nk -= pos-i; \n\n} \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\narr[] = {\n7\n, \n6\n, \n9\n, \n2\n, \n1\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nminimizeWithKSwaps(arr, n, k); \n\n\n//Print the final Array \n\nfor\n(\nint\ni=\n0\n; i<n; ++i) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "index": 524, "complexity": 5}
{"back-translation": "class GFG { static final int MAX = 100; static int getMaxGold(int gold[][], int m, int n) { int goldTable[][] = new int[m][n]; for (int rows[] : goldTable) Arrays.fill(rows, 0); for (int col = n - 1; col >= 0; col--) { for (int row = 0; row < m; row++) { int right = (col == n - 1) ? 0 : goldTable[row][col + 1]; int right_up = (row == 0 || col == n - 1) ? 0 : goldTable[row - 1][col + 1]; int right_down = (row == m - 1 || col == n - 1) ? 0 : goldTable[row + 1][col + 1]; goldTable[row][col] = gold[row][col] + Math.max(right, Math.max(right_up, right_down)); } } int res = goldTable[0][0]; for (int i = 1; i < m; i++) res = Math.max(res, goldTable[i][0]); return res; } public static void main(String arg[]) { int gold[][] = { { 1, 3, 1, 5 }, { 2, 2, 4, 1 }, { 5, 0, 2, 3 }, { 0, 6, 1, 2 } }; int m = 4, n = 4; System.out.print(getMaxGold(gold, m, n)); } }", "src": "\n// Java program to solve Gold Mine problem \nimport\njava.util.Arrays; \n\nclass\nGFG { \n\n\nstatic\nfinal\nint\nMAX = \n100\n; \n\n\n// Returns maximum amount of gold that \n\n// can be collected when journey started \n\n// from first column and moves allowed \n\n// are right, right-up and right-down \n\nstatic\nint\ngetMaxGold(\nint\ngold[][], \n\nint\nm, \nint\nn) \n\n{ \n\n\n// Create a table for storing \n\n// intermediate results and initialize \n\n// all cells to 0. The first row of \n\n// goldMineTable gives the maximum \n\n// gold that the miner can collect \n\n// when starts that row \n\nint\ngoldTable[][] = \nnew\nint\n[m][n]; \n\n\nfor\n(\nint\n[] rows:goldTable) \n\nArrays.fill(rows, \n0\n); \n\n\nfor\n(\nint\ncol = n-\n1\n; col >= \n0\n; col--) \n\n{ \n\nfor\n(\nint\nrow = \n0\n; row < m; row++) \n\n{ \n\n\n// Gold collected on going to \n\n// the cell on the right(->) \n\nint\nright = (col == n-\n1\n) ? \n0\n\n: goldTable[row][col+\n1\n]; \n\n\n// Gold collected on going to \n\n// the cell to right up (/) \n\nint\nright_up = (row == \n0\n|| \n\ncol == n-\n1\n) ? \n0\n: \n\ngoldTable[row-\n1\n][col+\n1\n]; \n\n\n// Gold collected on going to \n\n// the cell to right down (\\) \n\nint\nright_down = (row == m-\n1\n\n|| col == n-\n1\n) ? \n0\n: \n\ngoldTable[row+\n1\n][col+\n1\n]; \n\n\n// Max gold collected from taking \n\n// either of the above 3 paths \n\ngoldTable[row][col] = gold[row][col] \n\n+ Math.max(right, Math.max(right_up, \n\nright_down)); \n\n; \n\n} \n\n} \n\n\n// The max amount of gold collected will be \n\n// the max value in first column of all rows \n\nint\nres = goldTable[\n0\n][\n0\n]; \n\n\nfor\n(\nint\ni = \n1\n; i < m; i++) \n\nres = Math.max(res, goldTable[i][\n0\n]); \n\n\nreturn\nres; \n\n} \n\n\n//driver code \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ngold[][]= { {\n1\n, \n3\n, \n1\n, \n5\n}, \n\n{\n2\n, \n2\n, \n4\n, \n1\n}, \n\n{\n5\n, \n0\n, \n2\n, \n3\n}, \n\n{\n0\n, \n6\n, \n1\n, \n2\n} }; \n\n\nint\nm = \n4\n, n = \n4\n; \n\n\nSystem.out.print(getMaxGold(gold, m, n)); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "index": 525, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.Scanner;\npublic class DivideCandies {\n\tpublic static void main(String[] args){\n\t\tScanner input = new Scanner(System.in);\n\t\tlong n = input.nextLong();\n\t\tint m = input.nextInt();\n\t\tlong[] a = new long[m];\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tif(i <= (n%m) && i != 0){\n\t\t\t\ta[i] = n/m + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta[i] = n/m;\n\t\t\t}\n\t\t}\n\t\tlong result = 0L;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tif((i * i + j * j) % m == 0){\n\t\t\t\t\tresult += a[i] * a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}", "src": "import java.io.*;\nimport java.util.Scanner;\npublic class DivideCandies {\n\tpublic static void main(String[] args){\n\t\tScanner input = new Scanner(System.in);\n\t\tlong n = input.nextLong();\n\t\tint m = input.nextInt();\n\t\tlong[] a = new long[m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tif(i <= (n%m) && i != 0)\n\t\t\t{\n\t\t\t\ta[i] = n/m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[i] = n/m;\n\t\t\t}\n\t\t}\n\t\tlong result = 0L;\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif((i * i + j * j) % m == 0)\n\t\t\t\t{\n\t\t\t\t\tresult += a[i] * a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}\n\n\n\n", "index": 526, "complexity": 5}
{"back-translation": "public class GFG { public static int maxCost(int[][] mat, int N) { int[][] dp = new int[N][N]; dp[0][0] = mat[0][0]; for (int i = 1; i < N; i++) dp[i][0] = mat[i][0] + dp[i - 1][0]; for (int i = 1; i < N; i++) for (int j = 1; j < i + 1 && j < N; j++) dp[i][j] = mat[i][j] + Math.max(dp[i - 1][j - 1], dp[i - 1][j]); int result = 0; for (int i = 0; i < N; i++) if (result < dp[N - 1][i]) result = dp[N - 1][i]; return result; } public static void main(String[] args) { int[][] mat = { { 4, 1, 5, 6, 1 }, { 2, 9, 2, 11, 10 }, { 15, 1, 3, 15, 2 }, { 16, 92, 41, 4, 3 }, { 8, 142, 6, 4, 8 } }; int N = 5; System.out.println(\"Maximum Path Sum : \" + maxCost(mat, N)); } }", "src": "\n// Java Code for Maximum weight path ending at \n// any element of last row in a matrix \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n/* Function which return the maximum weight \n\npath sum */\n\npublic\nstatic\nint\nmaxCost(\nint\nmat[][], \nint\nN) \n\n{ \n\n// create 2D matrix to store the sum of \n\n// the path \n\nint\ndp[][]=\nnew\nint\n[N][N]; \n\n\ndp[\n0\n][\n0\n] = mat[\n0\n][\n0\n]; \n\n\n// Initialize first column of total \n\n// weight array (dp[i to N][0]) \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\ndp[i][\n0\n] = mat[i][\n0\n] + dp[i-\n1\n][\n0\n]; \n\n\n// Calculate rest path sum of weight matrix \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j < i + \n1\n&& j < N; j++) \n\ndp[i][j] = mat[i][j] + \n\nMath.max(dp[i-\n1\n][j-\n1\n], \n\ndp[i-\n1\n][j]); \n\n\n// find the max weight path sum to reach \n\n// the last row \n\nint\nresult = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\nif\n(result < dp[N-\n1\n][i]) \n\nresult = dp[N-\n1\n][i]; \n\n\n// return maximum weight path sum \n\nreturn\nresult; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n4\n, \n1\n,\n5\n,\n6\n, \n1\n}, \n\n{ \n2\n,\n9\n,\n2\n,\n11\n,\n10\n}, \n\n{ \n15\n,\n1\n,\n3\n,\n15\n, \n2\n}, \n\n{ \n16\n, \n92\n, \n41\n,\n4\n,\n3\n}, \n\n{ \n8\n, \n142\n, \n6\n, \n4\n, \n8\n} \n\n}; \n\nint\nN = \n5\n; \n\nSystem.out.println(\n\"Maximum Path Sum : \"\n+ \n\nmaxCost(mat, N)); \n\n} \n} \n// This code is contributed by Arnav Kr. Mandal. ", "index": 527, "complexity": 5}
{"back-translation": "public static void counterClockspiralPrint(int m, int n, int[][] arr) { int i, k = 0, l = 0; int cnt = 0; int total = m * n; while (k < m && l < n) { if (cnt == total) break; for (i = k; i < m; ++i) { System.out.print(arr[i][l] + \" \"); cnt++; } l++; if (cnt == total) break; for (i = l; i < n; ++i) { System.out.print(arr[m - 1][i] + \" \"); cnt++; } m--; if (cnt == total) break; if (k < m) { for (i = m - 1; i >= k; --i) { System.out.print(arr[i][n - 1] + \" \"); cnt++; } n--; } if (cnt == total) break; if (l < n) { for (i = n - 1; i >= l; --i) { System.out.print(arr[k][i] + \" \"); cnt++; } k++; } } } public static void main(String[] args) { int arr[][] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } }; counterClockspiralPrint(4, 4, arr); } }", "src": "\n// Java implementation to print \n// the counter clock wise \n// spiral traversal of matrix \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nint\nR = \n4\n; \n\nstatic\nint\nC = \n4\n; \n\n\n// function to print the \n\n// required traversal \n\nstatic\nvoid\ncounterClockspiralPrint(\nint\nm, \n\nint\nn, \n\nint\narr[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n\n/* k - starting row index \n\nm - ending row index \n\nl - starting column index \n\nn - ending column index \n\ni - iterator */\n\n\n// initialize the count \n\nint\ncnt = \n0\n; \n\n\n// total number of \n\n// elements in matrix \n\nint\ntotal = m * n; \n\n\nwhile\n(k < m && l < n) \n\n{ \n\nif\n(cnt == total) \n\nbreak\n; \n\n\n// Print the first column \n\n// from the remaining columns \n\nfor\n(i = k; i < m; ++i) \n\n{ \n\nSystem.out.print(arr[i][l] + \n\" \"\n); \n\ncnt++; \n\n} \n\nl++; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n// Print the last row from \n\n// the remaining rows \n\nfor\n(i = l; i < n; ++i) \n\n{ \n\nSystem.out.print(arr[m - \n1\n][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nm--; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n// Print the last column \n\n// from the remaining columns \n\nif\n(k < m) \n\n{ \n\nfor\n(i = m - \n1\n; i >= k; --i) \n\n{ \n\nSystem.out.print(arr[i][n - \n1\n] + \n\" \"\n); \n\ncnt++; \n\n} \n\nn--; \n\n} \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n// Print the first row \n\n// from the remaining rows \n\nif\n(l < n) \n\n{ \n\nfor\n(i = n - \n1\n; i >= l; --i) \n\n{ \n\nSystem.out.print(arr[k][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nk++; \n\n} \n\n} \n\n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[][] = { { \n1\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n5\n, \n6\n, \n7\n, \n8\n}, \n\n{ \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n} }; \n\n\n// Function calling \n\ncounterClockspiralPrint(R, C, arr); \n} \n} \n\n// This code is contributed by vt_m ", "index": 529, "complexity": 5}
{"back-translation": "class GFG { static int zzis(int arr[], int n) { int las[][] = new int[n][2]; for (int i = 0; i < n; i++) las[i][0] = las[i][1] = 1; int res = 1; for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { if (arr[j] < arr[i] && las[i][0] < las[j][1] + 1) las[i][0] = las[j][1] + 1; if (arr[j] > arr[i] && las[i][1] < las[j][0] + 1) las[i][1] = las[j][0] + 1; } if (res < Math.max(las[i][0], las[i][1])) res = Math.max(las[i][0], las[i][1]); } return res; } public static void main(String[] args) { int arr[] = { 10, 22, 9, 33, 49, 50, 31, 60 }; int n = arr.length; System.out.println(\"Length of Longest \" + \"alternating subsequence is \" + zzis(arr, n)); } }", "src": "\n// Java program to find longest \n// alternating subsequence in an array \nimport\njava.io.*; \n\nclass\nGFG { \n\n// Function to return longest \n// alternating subsequence length \nstatic\nint\nzzis(\nint\narr[], \nint\nn) \n{ \n\n/*las[i][0] = Length of the longest \n\nalternating subsequence ending at \n\nindex i and last element is \n\ngreater than its previous element \n\nlas[i][1] = Length of the longest \n\nalternating subsequence ending at \n\nindex i and last element is \n\nsmaller than its previous \n\nelement */\n\nint\nlas[][] = \nnew\nint\n[n][\n2\n]; \n\n\n/* Initialize all values from 1 */\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nlas[i][\n0\n] = las[i][\n1\n] = \n1\n; \n\n\nint\nres = \n1\n; \n// Initialize result \n\n\n/* Compute values in bottom up manner */\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n// Consider all elements as \n\n// previous of arr[i] \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n// If arr[i] is greater, then \n\n// check with las[j][1] \n\nif\n(arr[j] < arr[i] && \n\nlas[i][\n0\n] < las[j][\n1\n] + \n1\n) \n\nlas[i][\n0\n] = las[j][\n1\n] + \n1\n; \n\n\n// If arr[i] is smaller, then \n\n// check with las[j][0] \n\nif\n( arr[j] > arr[i] && \n\nlas[i][\n1\n] < las[j][\n0\n] + \n1\n) \n\nlas[i][\n1\n] = las[j][\n0\n] + \n1\n; \n\n} \n\n\n/* Pick maximum of both values at \n\nindex i */\n\nif\n(res < Math.max(las[i][\n0\n], las[i][\n1\n])) \n\nres = Math.max(las[i][\n0\n], las[i][\n1\n]); \n\n} \n\n\nreturn\nres; \n} \n\n/* Driver program */\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = { \n10\n, \n22\n, \n9\n, \n33\n, \n49\n, \n\n50\n, \n31\n, \n60\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of Longest \"\n+ \n\n\"alternating subsequence is \"\n+ \n\nzzis(arr, n)); \n} \n} \n// This code is contributed by Prerna Saini ", "index": 531, "complexity": 5}
{"back-translation": "class GFG { static int findSubsequenceCount(String S, String T) { int m = T.length(); int n = S.length(); if (m > n) return 0; int mat[][] = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) mat[i][0] = 0; for (int j = 0; j <= n; j++) mat[0][j] = 1; for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { if (T.charAt(i - 1) != S.charAt(j - 1)) mat[i][j] = mat[i][j - 1]; else mat[i][j] = mat[i][j - 1] + mat[i - 1][j - 1]; } } return mat[m][n]; } public static void main(String[] args) { String T = \"ge\"; String S = \"geeksforgeeks\"; System.out.println(findSubsequenceCount(S, T)); } }", "src": "\n// Java program to count number of times \n// S appears as a subsequence in T \nimport\njava.io.*; \n\nclass\nGFG { \n\nstatic\nint\nfindSubsequenceCount(String S, String T) \n\n{ \n\nint\nm = T.length(); \n\nint\nn = S.length(); \n\n\n// T can't appear as a subsequence in S \n\nif\n(m > n) \n\nreturn\n0\n; \n\n\n// mat[i][j] stores the count of \n\n// occurrences of T(1..i) in S(1..j). \n\nint\nmat[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\n\n// Initializing first column with \n\n// all 0s. An emptystring can't have \n\n// another string as suhsequence \n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\nmat[i][\n0\n] = \n0\n; \n\n\n// Initializing first row with all 1s. \n\n// An empty string is subsequence of all. \n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\nmat[\n0\n][j] = \n1\n; \n\n\n// Fill mat[][] in bottom up manner \n\nfor\n(\nint\ni = \n1\n; i <= m; i++) { \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) { \n\n// If last characters don't match, \n\n// then value is same as the value \n\n// without last character in S. \n\nif\n(T.charAt(i - \n1\n) != S.charAt(j - \n1\n)) \n\nmat[i][j] = mat[i][j - \n1\n]; \n\n\n// Else value is obtained considering two cases. \n\n// a) All substrings without last character in S \n\n// b) All substrings without last characters in \n\n// both. \n\nelse\n\nmat[i][j] = mat[i][j - \n1\n] + mat[i - \n1\n][j - \n1\n]; \n\n} \n\n} \n\n\n/* uncomment this to print matrix mat \n\nfor (int i = 1; i <= m; i++, cout << endl) \n\nfor (int j = 1; j <= n; j++) \n\nSystem.out.println ( mat[i][j] +\" \"); */\n\nreturn\nmat[m][n]; \n\n} \n\n\n// Driver code to check above method \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString T = \n\"ge\"\n; \n\nString S = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(findSubsequenceCount(S, T)); \n\n} \n} \n// This code is contributed by vt_m ", "index": 533, "complexity": 5}
{"back-translation": "import javax.print.attribute.standard.RequestingUserName;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws NumberFormatException, IOException\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        int tc = in.nextInt();\n        int i = 0;\n        while (i < tc) {\n            solver.solve(i, in, out);\n            i++;\n        }\n        out.close();\n    }\n\n    static class Task {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n\n            int k = in.nextInt();\n            int[] s = getArray(in.nextToken());\n            int[] a = getArray(in.nextToken());\n            int[] b = getArray(in.nextToken());\n\n            int[] per = new int[k];\n            boolean[] used = new boolean[k];\n            Arrays.fill(per, -1);\n\n            if (!check(s, a, per.clone(), k, used)) {\n                out.println(\"NO\");\n                return;\n            }\n\n            for (int j = 0; j < s.length; j++) {\n                if (per[s[j]] != -1) {\n                    continue;\n                }\n                int l = 0;\n                while (l < k) {\n                    if (used[l]) {\n                        l++;\n                        continue;\n                    }\n                    per[s[j]] = l;\n                    used[l] = true;\n                    if (check(s, a, per.clone(), k, used)) {\n                        break;\n                    }\n                    per[s[j]] = -1;\n                    used[l] = false;\n                    l++;\n                }\n            }\n\n            for (int m = 0; m < s.length; m++) {\n                if (per[s[m]] == -1) {\n                    out.println(\"NO\");\n                    return;\n                }\n                s[m] = per[s[m]];\n            }\n\n            if (cmp(s, b) > 0) {\n                out.println(\"NO\");\n                return;\n            }\n\n            int last = 0;\n            for (int n = 0; n < k; n++) {\n                if (per[n] == -1) {\n                    while (used[last]) {\n                        last++;\n                    }\n                    per[n] = last;\n                    used[last] = true;\n                    last++;\n                }\n            }\n\n            char[] result = new char[k];\n\n            for (int o = 0; o < k; o++) {\n                result[o] = (char) ('a' + per[o]);\n            }\n            out.println(\"YES\");\n            out.println(new String(result));\n        }\n\n        private int cmp(int[] a, int[] b) {\n            for (int p = 0; p < a.length; p++) {\n                if (a[p] != b[p]) {\n                    return a[p] < b[p] ? -1 : 1;\n                }\n            }\n            return 0;\n        }\n\n        private boolean check(int[] s, int[] a, int[] per, int k, boolean[] used) {\n            int[] res = new int[s.length];\n            int last = k - 1;\n            for (int q = 0; q < res.length; q++) {\n\n                if (per[s[q]] == -1) {\n\n                    while (last >= 0 && used[last]) {\n                        last--;\n                    }\n\n                    if (last < 0) {\n                        return false;\n                    }\n\n                    per[s[q]] = last;\n                    last--;\n                }\n                res[q] = per[s[q]];\n            }\n            return cmp(a, res) <= 0;\n        }\n\n        private int[] getArray(String nextToken) {\n            int[] result = new int[nextToken.length()];\n            for (int r = 0; r < nextToken.length(); r++) {\n                result[r] = nextToken.charAt(r) - 'a';\n            }\n            return result;\n        }\n    }\n\n    static class InputReader {\n\n        BufferedReader in;\n        StringTokenizer tok;\n\n        public InputReader(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream), 32768);\n            tok = null;\n        }\n\n        String nextToken() {\n            String line = \"\";\n            while (tok == null || !tok.hasMoreTokens()) {\n                try {\n                    if ((line = in.readLine()) != null)\n                        tok = new StringTokenizer(line);\n                    else\n                        return null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return null;\n                }\n            }\n            return tok.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n}", "src": "import javax.print.attribute.standard.RequestingUserName;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws NumberFormatException, IOException\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        int tc = in.nextInt();\n        for(int i = 0; i < tc; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class Task {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n\n            int k = in.nextInt();\n            int[] s = getArray(in.nextToken());\n            int[] a = getArray(in.nextToken());\n            int[] b = getArray(in.nextToken());\n\n            int[] per = new int[k];\n            boolean[] used = new boolean[k];\n            Arrays.fill(per , -1);\n\n            if(!check(s , a, per.clone(), k, used)){\n                out.println(\"NO\");\n                return;\n            }\n\n            for(int i = 0; i < s.length; i++){\n                if(per[s[i]] != -1){\n                    continue;\n                }\n                for(int j = 0; j < k; j++){\n                    if(used[j]){\n                        continue;\n                    }\n                    per[s[i]] = j;\n                    used[j] = true;\n                    if(check(s , a , per.clone() , k, used)){\n                        break;\n                    }\n                    per[s[i]] = -1;\n                    used[j] = false;\n                }\n            }\n\n            for(int i = 0; i < s.length; i++){\n                if(per[s[i]] == -1){\n                    out.println(\"NO\");\n                    return;\n                }\n                s[i] = per[s[i]];\n            }\n\n            if(cmp(s , b) > 0){\n                out.println(\"NO\");\n                return;\n            }\n\n\n            int last = 0;\n            for(int i = 0; i < k; i++){\n                if(per[i] == -1) {\n                    while(used[last])last++;\n                    per[i] = last;\n                    used[last] = true;\n                }\n            }\n\n            char[] result = new char[k];\n\n            for(int i = 0; i < k; i++){\n                result[i] = (char)('a' + per[i]);\n            }\n            out.println(\"YES\");\n            out.println(new String(result));\n        }\n\n        private int cmp(int[] a, int[] b){\n            for(int i = 0; i < a.length; i++){\n                if(a[i] != b[i]){\n                    return a[i] < b[i] ? -1 : 1;\n                }\n            }\n            return 0;\n        }\n\n\n        private boolean check(int[] s, int[] a, int[] per, int k, boolean[] used) {\n            int res[] = new int[s.length];\n            int last = k - 1;\n            for(int i = 0; i < res.length; ++i){\n\n                if(per[s[i]] == -1){\n\n                    while(last >= 0 && used[last]){\n                        last--;\n                    }\n\n                    if(last < 0){\n                        return false;\n                    }\n\n                    per[s[i]] = last;\n                    last--;\n                }\n                res[i] = per[s[i]];\n            }\n            return cmp(a , res) <= 0;\n        }\n\n        private int[] getArray(String nextToken) {\n            int result[] = new int[nextToken.length()];\n            for(int i = 0; i < nextToken.length(); i++){\n                result[i] = nextToken.charAt(i) - 'a';\n            }\n            return result;\n        }\n    }\n\n    static class InputReader {\n\n        BufferedReader in;\n        StringTokenizer tok;\n\n        public InputReader(InputStream stream){\n            in = new BufferedReader(new InputStreamReader(stream), 32768);\n            tok = null;\n        }\n\n        String nextToken()\n        {\n            String line = \"\";\n            while(tok == null || !tok.hasMoreTokens()) {\n                try {\n                    if((line = in.readLine()) != null)\n                        tok = new StringTokenizer(line);\n                    else\n                        return null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return null;\n                }\n            }\n            return tok.nextToken();\n        }\n        int nextInt(){\n            return Integer.parseInt(nextToken());\n        }\n        long nextLong()\t{\n            return Long.parseLong(nextToken());\n        }\n        double nextDouble()\t{\n            return Double.parseDouble(nextToken());\n        }\n\n    }\n\n}", "index": 534, "complexity": 5}
{"back-translation": "ERROR", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces913F {\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner input = new Scanner(System.in);\n\t\tint n = input.nextInt();\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tinput.close();\n\t\tfinal int mod = 998244353;\n\t\t\n\t\tint frac = multiply(a, inverse(b, mod), mod);\n\t\tint reverse = (mod+1-frac)%mod;\n\t\t\n\t\tint[] fracpower = new int[n+1];\n\t\tint[] reversepower = new int[n+1];\n\t\tfracpower[0] = 1;\n\t\treversepower[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfracpower[i] = multiply(fracpower[i-1], frac, mod);\n\t\t\treversepower[i] = multiply(reversepower[i-1], reverse, mod);\n\t\t}\n\t\t\n\t\tint[][] dp1 = new int[n+1][n+1];\n\t\tdp1[2][1] = 1;\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tif (j == 1) {\n\t\t\t\t\tdp1[i][j] = fracpower[i-1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp1[i][j] = multiply(dp1[i-1][j-1], fracpower[i-j], mod);\n\t\t\t\t}\n\t\t\t\tif (j == i-1) {\n\t\t\t\t\tdp1[i][j] += reversepower[i-1];\n\t\t\t\t\tdp1[i][j] %= mod;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp1[i][j] += multiply(dp1[i-1][j], reversepower[j], mod);\n\t\t\t\t\tdp1[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] dp2 = new int[n+1][n+1];\n\t\tdp2[1][1] = 1;\n\t\tdp2[2][1] = 1;\n\t\tdp2[2][2] = 0;\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tint val = 0;\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tdp2[i][j] = multiply(dp2[j][j], dp1[i][j], mod);\n\t\t\t\tval += dp2[i][j];\n\t\t\t\tval %= mod;\n\t\t\t}\n\t\t\tdp2[i][i] = (mod+1-val)%mod;\n\t\t}\n\t\t\n\t\t/*for (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tSystem.out.print(dp2[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}*/\n\t\t\n\t\tint[] EV = new int[n+1];\n\t\tEV[1] = 0;\n\t\tEV[2] = 1;\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tint val = 0;\n\t\t\tfor (int j = 1; j < i; j++) {\n\t\t\t\tint r = j*(i-j) + (j*(j-1))/2 + EV[i-j] + EV[j];\n\t\t\t\tr %= mod;\n\t\t\t\tval += multiply(dp2[i][j], r, mod);\n\t\t\t\tval %= mod;\n\t\t\t}\n\t\t\tval += multiply((i*(i-1))/2, dp2[i][i], mod);\n\t\t\tval %= mod;\n\t\t\t\n\t\t\tint s = (mod+1-dp2[i][i])%mod;\n\t\t\tEV[i] = multiply(val, inverse(s, mod), mod);\n\t\t}\n\t\t\n\t\tSystem.out.println(EV[n]);\n\t}\n\t\n\tpublic static int multiply(int a, int b, int mod) {\n\t\tlong x = (long)a*(long)b;\n\t\treturn (int) (x%mod);\n\t}\n\t\n\tpublic static int inverse (int a, int n) {\n\t\tint m = n;\n\t\tint r1 = 1;\n\t\tint r2 = 0;\n\t\tint r3 = 0;\n\t\tint r4 = 1;\n\t\twhile ((a > 0) && (n > 0)) {\n\t\t\tif (n >= a) {\n\t\t\t\tr3 -= r1*(n/a);\n\t\t\t\tr4 -= r2*(n/a);\n\t\t\t\tn = n%a;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tmp = a;\n\t\t\t\ta = n;\n\t\t\t\tn = tmp;\n\t\t\t\ttmp = r1;\n\t\t\t\tr1 = r3;\n\t\t\t\tr3 = tmp;\n\t\t\t\ttmp = r2;\n\t\t\t\tr2 = r4;\n\t\t\t\tr4 = tmp;\n\t\t\t}\n\t\t}\n\t\tif (a == 0) {\n\t\t\tif (r3 >= 0)\n\t\t\t\treturn (r3%m);\n\t\t\telse\n\t\t\t\treturn (m+(r3%m));\n\t\t}\n\t\telse {\n\t\t\tif (r1 >= 0)\n\t\t\t\treturn (r1%m);\n\t\t\telse\n\t\t\t\treturn (m+(r1%m));\n\t\t}\n\n\t}\n}", "index": 535, "complexity": 5}
{"back-translation": "import java.util.*; class GFG { static void findTriplets(int[] arr, int n) { boolean found = false; for (int i = 0; i < n - 1; i++) { HashSet<Integer> s = new HashSet<Integer>(); for (int j = i + 1; j < n; j++) { int x = -(arr[i] + arr[j]); if (s.contains(x)) { System.out.printf(\"%d %d %d\\n\", x, arr[i], arr[j]); found = true; } else { s.add(arr[j]); } } } if (!found) { System.out.printf(\" No Triplet Found\\n\"); } } public static void main(String[] args) { int[] arr = { 0, -1, 2, -3, 1 }; int n = arr.length; findTriplets(arr, n); } }", "src": "\n// Java program to find triplets in a given \n// array whose sum is zero \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n\n// function to print triplets with 0 sum \n\nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n\n{ \n\nboolean\nfound = \nfalse\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\n{ \n\n// Find all pairs with sum equals to \n\n// \"-arr[i]\" \n\nHashSet<Integer> s = \nnew\nHashSet<Integer>(); \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n{ \n\nint\nx = -(arr[i] + arr[j]); \n\nif\n(s.contains(x)) \n\n{ \n\nSystem.out.printf(\n\"%d %d %d\\n\"\n, x, arr[i], arr[j]); \n\nfound = \ntrue\n; \n\n} \n\nelse\n\n{ \n\ns.add(arr[j]); \n\n} \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\n{ \n\nSystem.out.printf(\n\" No Triplet Found\\n\"\n); \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindTriplets(arr, n); \n\n} \n} \n\n// This code contributed by Rajput-Ji ", "index": 536, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Solution {\n    static int mod = (int) (1e9 + 7);\n    static InputReader in;\n    static PrintWriter out;\n\n    public static int n;\n    public static int m;\n\n    public static boolean valid(int i, int j) {\n        return (i < n && j < m && i >= 0 && j >= 0);\n    }\n\n    public static void main(String args[]) {\n\n        in = new InputReader(System.in);\n        out = new PrintWriter(System.out);\n\n        n = in.nextInt();\n        m = in.nextInt();\n\n        String[] s = new String[n];\n        for (int i = 0; i < n; i++) {\n            s[i] = in.readString();\n        }\n\n        int f = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < s[i].length(); j++) {\n                int val = -1;\n                if (s[i].charAt(j) == '.') {\n                    val = 0;\n                } else if (s[i].charAt(j) == '*') {\n                    continue;\n                } else {\n                    val = s[i].charAt(j) - '0';\n                }\n                int c = 0;\n                if (valid(i - 1, j) && s[i - 1].charAt(j) == '*') {\n                    c++;\n                }\n                if (valid(i - 1, j - 1) && s[i - 1].charAt(j - 1) == '*') {\n                    c++;\n                }\n                if (valid(i - 1, j + 1) && s[i - 1].charAt(j + 1) == '*') {\n                    c++;\n                }\n                if (valid(i, j - 1) && s[i].charAt(j - 1) == '*') {\n                    c++;\n                }\n                if (valid(i, j + 1) && s[i].charAt(j + 1) == '*') {\n                    c++;\n                }\n                if (valid(i + 1, j) && s[i + 1].charAt(j) == '*') {\n                    c++;\n                }\n                if (valid(i + 1, j + 1) && s[i + 1].charAt(j + 1) == '*') {\n                    c++;\n                }\n                if (valid(i + 1, j - 1) && s[i + 1].charAt(j - 1) == '*') {\n                    c++;\n                }\n                if (c != val) {\n                    f = 1;\n                    break;\n                }\n            }\n        }\n\n        if (f == 0) {\n            out.println(\"YES\");\n        } else {\n            out.println(\"NO\");\n        }\n\n        out.close();\n    }\n\n}\n\nclass InputReader {\n\n    private final InputStream stream;\n    private final byte[] buf = new byte[8192];\n    private int curChar, snumChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int snext() {\n        if (snumChars == -1) throw new InputMismatchException();\n        if (curChar >= snumChars) {\n            curChar = 0;\n            try {\n                snumChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (snumChars <= 0) return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int nextInt() {\n        int c = snext();\n        while (isSpaceChar(c)) {\n            c = snext();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = snext();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9') throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = snext();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public long nextLong() {\n        int c = snext();\n        while (isSpaceChar(c)) {\n            c = snext();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = snext();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9') throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = snext();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public int[] nextIntArray(int n) {\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    public long[] nextLongArray(int n) {\n        long a[] = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextLong();\n        }\n        return a;\n    }\n\n    public String readString() {\n        int c = snext();\n        while (isSpaceChar(c)) {\n            c = snext();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = snext();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public String nextLine() {\n        int c = snext();\n        while (isSpaceChar(c)) c = snext();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = snext();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null) return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n\n}\n", "src": "import java.io.*;\nimport java.math.BigInteger; \nimport java.util.*;\n\n\n\n//Mann Shah [ DAIICT ].\n//fast io\n\npublic class Main {\n\tstatic int mod = (int) (1e9+7);\n\tstatic InputReader in;\n    static PrintWriter out;\n    \n    \t\tpublic static int n;\n    \t\tpublic static int m;\n    \n    \t\tpublic static boolean valid(int i , int j) {\n    \t\t\t\n    \t\t\treturn ( i<n && j<m && i>=0 && j>=0);\n    \t\t}\n    \t\t\n   \n\t\tpublic static void main(String args[] )  {\n\t\t\t\n\t\t  in = new InputReader(System.in);\n\t      out = new PrintWriter(System.out);\n\t     \n\t     n = in.nextInt();\n\t    \t m = in.nextInt();\n\t    \n\t    \tString[] s = new String[n];\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\ts[i]= in.readString();\n\t    \t}\n\t    \tint f=0;\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\tfor(int j=0;j<s[i].length();j++) {\n\t    \t\t\tint val=-1;\n\t    \t\t\tif(s[i].charAt(j)=='.') {\n\t    \t\t\t\tval=0;\n\t    \t\t\t}\n\t    \t\t\telse if(s[i].charAt(j)=='*') {\n\t    \t\t\t\tcontinue;\n\t    \t\t\t}\n\t    \t\t\telse {\n\t    \t\t\t\tval = s[i].charAt(j)-'0';\n\t    \t\t\t}\n\t    \t\t\tint c=0;\n\t    \t\t\tif(valid(i-1,j) && s[i-1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j-1) && s[i-1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j+1) && s[i-1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j-1) && s[i].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j+1) && s[i].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j) && s[i+1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j+1) && s[i+1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j-1) && s[i+1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(c!=val) {\n\t    \t\t\t\tf=1;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    \tif(f==0) {\n\t    \t\tout.println(\"YES\");\n\t    \t}\n\t    \telse {\n\t    \t\tout.println(\"NO\");\n\t    \t}\n\t     \n\t     \n\t     out.close();\n\t\t}\n\t\t\n\n\t\t\n\t\tstatic class InputReader\n\t    {\n\n\t        private final InputStream stream;\n\t        private final byte[] buf = new byte[8192];\n\t        private int curChar, snumChars;\n\t        private SpaceCharFilter filter;\n\n\t        public InputReader(InputStream stream)\n\t        {\n\t                this.stream = stream;\n\t        }\n\n\t        public int snext()\n\t        {\n\t                if (snumChars == -1)\n\t                        throw new InputMismatchException();\n\t                if (curChar >= snumChars)\n\t                {\n\t                        curChar = 0;\n\t                        try\n\t                        {\n\t                                snumChars = stream.read(buf);\n\t                        } catch (IOException e)\n\t                        {\n\t                                throw new InputMismatchException();\n\t                        }\n\t                        if (snumChars <= 0)\n\t                                return -1;\n\t                }\n\t                return buf[curChar++];\n\t        }\n\n\t        public int nextInt()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                int res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public long nextLong()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                long res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public int[] nextIntArray(int n)\n\t        {\n\t                int a[] = new int[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextInt();\n\t                }\n\t                return a;\n\t        }\n\n\t        public long[] nextLongArray(int n)\n\t        {\n\t                long a[] = new long[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextLong();\n\t                }\n\t                return a;\n\t        }\n\n\t        public String readString()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res.toString();\n\t        }\n\n\t        public String nextLine()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                        c = snext();\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isEndOfLine(c));\n\t                return res.toString();\n\t        }\n\n\t        public boolean isSpaceChar(int c)\n\t        {\n\t                if (filter != null)\n\t                        return filter.isSpaceChar(c);\n\t                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t        }\n\n\t        private boolean isEndOfLine(int c)\n\t        {\n\t                return c == '\\n' || c == '\\r' || c == -1;\n\t        }\n\n\t        public interface SpaceCharFilter\n\t        {\n\t                public boolean isSpaceChar(int ch);\n\t        }\n\n\t    }\n\t\t\n}\n\n//For Pair sorting\n\n//Arrays.sort(arr,new Comparator<Pair>() {\n//\t\t@Override public int compare(Pair p1, Pair p2) \n//{ \n//    return p1.x - p2.x; \n//} \n//});\n\n\n\n//Pair arr[] = new Pair[n]; \n//arr[0] = new Pair(10, 20); \nclass Pair { \n    int x; \n    int y; \n  \n    // Constructor \npublic Pair(int x, int y) \n    { \n        this.x = x; \n        this.y = y; \n    } \n} \n// class Compare { \n//\t  //void return by default.\n//     public  Pair[] compare(Pair arr[], int n) \n//    { \n//        // Comparator to sort the pair according to first element.\n//        Arrays.sort(arr, new Comparator<Pair>() { \n//            @Override public int compare(Pair p1, Pair p2) \n//            { \n//                return p1.x - p2.x; \n//            } \n//        }); \n//        \n//        \n//        return arr;\n//       /* for (int i = 0; i < n; i++) { \n//            System.out.print(arr[i].x + \" \" + arr[i].y + \" \"); \n//        } \n//        System.out.println(); */\n//    } \n//} \n//\n\n\n\nclass couple implements Comparable<couple>\n{ int x,y;\n  public couple(int m,int f) {\n \t x=m;\n \t y=f;\n  }\n\tpublic int compareTo(couple o) {\n\t\t\n\t\t \n\t\treturn x-o.x;\n\t}  \n}\n", "index": 537, "complexity": 5}
{"back-translation": "class GFG {\n    private static int minJumps(int[] arr, int n) {\n        int jumps[] = new int[n];\n        int i, j;\n        if (n == 0 || arr[0] == 0)\n            return Integer.MAX_VALUE;\n        jumps[0] = 0;\n        for (i = 1; i < n; i++) {\n            jumps[i] = Integer.MAX_VALUE;\n            for (j = 0; j < i; j++) {\n                if (i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) {\n                    jumps[i] = Math.min(jumps[i], jumps[j] + 1);\n                    break;\n                }\n            }\n        }\n        return jumps[n - 1];\n    }\n    public static void main(String[] args) {\n        int arr[] = {1, 3, 6, 1, 0, 9};\n        System.out.println(\"Minimum number of jumps to reach end is : \" + minJumps(arr, arr.length));\n    }\n}", "src": "\n// JAVA Code for Minimum number of jumps to reach end \nclass\nGFG{ \n\nprivate\nstatic\nint\nminJumps(\nint\n[] arr, \nint\nn) { \n\nint\njumps[] = \nnew\nint\n[n]; \n// jumps[n-1] will hold the \n\n// result \n\nint\ni, j; \n\n\nif\n(n == \n0\n|| arr[\n0\n] == \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n// if first element is 0, \n\n// end cannot be reached \n\n\njumps[\n0\n] = \n0\n; \n\n\n// Find the minimum number of jumps to reach arr[i] \n\n// from arr[0], and assign this value to jumps[i] \n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\njumps[i] = Integer.MAX_VALUE; \n\nfor\n(j = \n0\n; j < i; j++) \n\n{ \n\nif\n(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) \n\n{ \n\njumps[i] = Math.min(jumps[i], jumps[j] + \n1\n); \n\nbreak\n; \n\n} \n\n} \n\n} \n\nreturn\njumps[n-\n1\n]; \n\n} \n\n// driver program to test above function \npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\n\nSystem.out.println(\n\"Minimum number of jumps to reach end is : \"\n+ \n\nminJumps(arr,arr.length)); \n\n} \n} \n\n// This code is contributed by Arnav Kr. Mandal. ", "index": 538, "complexity": 5}
{"back-translation": "class BinomialCoefficient { static int binomialCoeff(int n, int k) { int[][] C = new int[n+1][k+1]; int i, j; for (i = 0; i <= n; i++) { for (j = 0; j <= Math.min(i, k); j++) { if (j == 0 || j == i) C[i][j] = 1; else C[i][j] = C[i-1][j-1] + C[i-1][j]; } } return C[n][k]; } static int min(int a, int b) { return (a<b)? a: b; } public static void main(String args[]) { int n = 5, k = 2; System.out.println(\"Value of C(\" + n + \",\" + k + \") is \" + binomialCoeff(n, k)); } }", "src": "\n// A Dynamic Programming based solution that uses table C[][] to \n// calculate the Binomial Coefficient \n\nclass\nBinomialCoefficient \n{ \n\n// Returns value of Binomial Coefficient C(n, k) \n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[][] = \nnew\nint\n[n+\n1\n][k+\n1\n]; \n\nint\ni, j; \n\n\n// Calculate value of Binomial Coefficient in bottom up manner \n\nfor\n(i = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(j = \n0\n; j <= min(i, k); j++) \n\n{ \n\n// Base Cases \n\nif\n(j == \n0\n|| j == i) \n\nC[i][j] = \n1\n; \n\n\n// Calculate value using previously stored values \n\nelse\n\nC[i][j] = C[i-\n1\n][j-\n1\n] + C[i-\n1\n][j]; \n\n} \n\n} \n\n\nreturn\nC[n][k]; \n\n} \n\n\n// A utility function to return minimum of two integers \n\nstatic\nint\nmin(\nint\na, \nint\nb) \n\n{ \n\nreturn\n(a<b)? a: b; \n\n} \n\n\n/* Driver program to test above function*/\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of C(\"\n+n+\n\",\"\n+k+\n\") is \"\n+binomialCoeff(n, k)); \n\n} \n} \n/*This code is contributed by Rajat Mishra*/", "index": 539, "complexity": 5}
{"back-translation": "import java.util.Scanner;;\npublic class JavaApplication2 {\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n= sc.nextInt();\n        int li[]=new int[n];\n        for(int i = 0 ;i<n;i++){\n            li[i]=sc.nextInt();\n        }\n        int max=0;\n         int c=0;\n        for(int i = 0;i<n;i++){\n           c=0;\n            for(int j=i;j<n;){\n                if(j!=n-1&&j!=0&&li[j]-li[j-1]==1&&li[j+1]-li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j!=n-1&&j==0&&li[j+1]-li[j]==1&&li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j==n-1&&j!=0&&li[j]-li[j-1]==1&&li[j]==1000){\n                    c++;\n                    i++;\n                }\n                else{ break;}\n                j++;\n            }\n            if(c>max){\n                max=c;\n            }\n        }\n        if(c>max){\n                max=c;\n            }\n        System.out.println(max);\n        \n       \n    }\n    \n}\n", "src": "import java.util.Scanner;;\npublic class JavaApplication2 {\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n= sc.nextInt();\n        int li[]=new int[n];\n        for(int i = 0 ;i<n;i++){\n            li[i]=sc.nextInt();\n        }\n        int max=0;\n         int c=0;\n        for(int i = 0;i<n;i++){\n           c=0;\n            for(int j=i;j<n;j++){\n                if(j!=n-1&&j!=0&&li[j]-li[j-1]==1&&li[j+1]-li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j!=n-1&&j==0&&li[j+1]-li[j]==1&&li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j==n-1&&j!=0&&li[j]-li[j-1]==1&&li[j]==1000){\n                    c++;\n                    i++;\n                }\n                else{ break;}\n            }\n            if(c>max){\n                max=c;\n            }\n        }\n        if(c>max){\n                max=c;\n            }\n        System.out.println(max);\n        \n       \n    }\n    \n}\n", "index": 540, "complexity": 5}
{"back-translation": "import java.util.Arrays; class CountTriangles { static int findNumberOfTriangles(int arr[]) { int n = arr.length; Arrays.sort(arr); int count = 0; for (int i = 0; i < n-2; ++i) { int k = i + 2; for (int j = i+1; j < n; ++j) { while (k < n && arr[i] + arr[j] > arr[k]) ++k; if (k > j) count += k - j - 1; } } return count; } public static void main(String[] args) { int arr[] = {10, 21, 22, 100, 101, 200, 300}; System.out.println(\"Total number of triangles is \" + findNumberOfTriangles(arr)); } }", "src": "\n// Java program to count number of triangles that can be \n// formed from given array \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nCountTriangles \n{ \n\n// Function to count all possible triangles with arr[] \n\n// elements \n\nstatic\nint\nfindNumberOfTriangles(\nint\narr[]) \n\n{ \n\nint\nn = arr.length; \n\n// Sort the array elements in non-decreasing order \n\nArrays.sort(arr); \n\n\n// Initialize count of triangles \n\nint\ncount = \n0\n; \n\n\n// Fix the first element. We need to run till n-3 as \n\n// the other two elements are selected from arr[i+1...n-1] \n\nfor\n(\nint\ni = \n0\n; i < n-\n2\n; ++i) \n\n{ \n\n// Initialize index of the rightmost third element \n\nint\nk = i + \n2\n; \n\n\n// Fix the second element \n\nfor\n(\nint\nj = i+\n1\n; j < n; ++j) \n\n{ \n\n/* Find the rightmost element which is smaller \n\nthan the sum of two fixed elements \n\nThe important thing to note here is, we use \n\nthe previous value of k. If value of arr[i] + \n\narr[j-1] was greater than arr[k], then arr[i] + \n\narr[j] must be greater than k, because the \n\narray is sorted. */\n\nwhile\n(k < n && arr[i] + arr[j] > arr[k]) \n\n++k; \n\n\n/* Total number of possible triangles that can be \n\nformed with the two fixed elements is k - j - 1. \n\nThe two fixed elements are arr[i] and arr[j]. All \n\nelements between arr[j+1] to arr[k-1] can form a \n\ntriangle with arr[i] and arr[j]. One is subtracted \n\nfrom k because k is incremented one extra in above \n\nwhile loop. k will always be greater than j. If j \n\nbecomes equal to k, then above loop will increment \n\nk, because arr[k] + arr[i] is always/ greater than \n\narr[k] */\n\nif\n(k>j) \n\ncount += k - j - \n1\n; \n\n} \n\n} \n\nreturn\ncount; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n21\n, \n22\n, \n100\n, \n101\n, \n200\n, \n300\n}; \n\nSystem.out.println(\n\"Total number of triangles is \"\n+ \n\nfindNumberOfTriangles(arr)); \n\n} \n} \n/*This code is contributed by Devesh Agrawal*/", "index": 541, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Solution{\n    \n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    public static void main(String args[] ) {\n        \n        FastReader sc = new FastReader();\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] arr = new int[105];\n        \n        for(int i=0;i<m;i++){\n            int a = sc.nextInt();\n            arr[a]++;\n        }\n        \n        for(int i=1;i<=1000;i++){\n            int sum=0;\n            \n            for(int a:arr){\n                if(a!=0){\n                    sum+=(a/i);\n                }\n            }\n            \n            \n            if(sum<n){\n                System.out.println(i-1);\n                return;\n            }\n            \n        }\n    }\n\n}\n", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution{\n    \n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    public static void main(String args[] ) {\n        \n        FastReader sc = new FastReader();\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] arr = new int[105];\n        \n        for(int i=0;i<m;i++){\n            int a = sc.nextInt();\n            arr[a]++;\n        }\n        \n        for(int i=1;i<=1000;i++){\n            int sum=0;\n            \n            for(int a:arr){\n                if(a!=0){\n                    sum+=(a/i);\n                }\n            }\n            \n            \n            if(sum<n){\n                System.out.println(i-1);\n                return;\n            }\n            \n        }\n    }\n\n}\n", "index": 544, "complexity": 5}
{"back-translation": "//package contest1196;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class D {\n\n\tpublic static int[][] dp = new int[200005][3];\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tPrintWriter cout = new PrintWriter(System.out);\n\t\t\n\t\tint q = cin.nextInt();\n\t\tint[] a = new int[200005];\n\t\tint n, k;\n\t\twhile (q-- > 0) {\n\t\t\tn = cin.nextInt();\n\t\t\tk = cin.nextInt();\n\t\t\tString chuoi = cin.nextLine();\n\t\t\tchuoi = cin.nextLine();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tchar ch = chuoi.charAt(i-1);\n\t\t\t\tif (ch == 'R') a[i] = 1;\n\t\t\t\tif (ch == 'G') a[i] = 2;\n\t\t\t\tif (ch == 'B') a[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tfor (int x = 0; x < 3; x++) {\n\t\t\t\t\tdp[i][x] = dp[i-1][x];\n\t\t\t\t\tif (a[i] != (x + i)%3) dp[i][x]++;\n\t\t\t\t}\n\t\t\t\n\t\t\tint res = 1000000007;\n\t\t\tfor (int i = k; i <= n; i++) \n\t\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\t\tres = Math.min(res, dp[i][x] - dp[i-k][x]);\n\t\t\t\t\t\n\t\t\tcout.println(res);\n\t\t}\n\t\tcout.close();\n\t}\n}\n", "src": "//package contest1196;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class D {\n\n\tpublic static int[][] dp = new int[200005][3];\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tPrintWriter cout = new PrintWriter(System.out);\n\t\t\n\t\tint q = cin.nextInt();\n\t\tint[] a = new int[200005];\n\t\tint n, k;\n\t\twhile (q-- > 0) {\n\t\t\tn = cin.nextInt();\n\t\t\tk = cin.nextInt();\n\t\t\tString chuoi = cin.nextLine();\n\t\t\tchuoi = cin.nextLine();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tchar ch = chuoi.charAt(i-1);\n\t\t\t\tif (ch == 'R') a[i] = 1;\n\t\t\t\tif (ch == 'G') a[i] = 2;\n\t\t\t\tif (ch == 'B') a[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tfor (int x = 0; x < 3; x++) {\n\t\t\t\t\tdp[i][x] = dp[i-1][x];\n\t\t\t\t\tif (a[i] != (x + i)%3) dp[i][x]++;\n\t\t\t\t}\n\t\t\t\n\t\t\tint res = 1000000007;\n\t\t\tfor (int i = k; i <= n; i++) \n\t\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\t\tres = Math.min(res, dp[i][x] - dp[i-k][x]);\n\t\t\t\t\t\n\t\t\tcout.println(res);\n\t\t}\n\t\tcout.close();\n\t}\n}\n", "index": 545, "complexity": 5}
{"back-translation": "class GFG {\n    static boolean isSubsetSum(int set[], int n, int sum) {\n        boolean[][] subset = new boolean[sum + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            subset[0][i] = true;\n        }\n        for (int i = 1; i <= sum; i++) {\n            subset[i][0] = false;\n        }\n        for (int i = 1; i <= sum; i++) {\n            for (int j = 1; j <= n; j++) {\n                subset[i][j] = subset[i][j - 1];\n                if (i >= set[j - 1]) {\n                    subset[i][j] = subset[i][j] || subset[i - set[j - 1]][j - 1];\n                }\n            }\n        }\n        return subset[sum][n];\n    }\n    public static void main(String args[]) {\n        int set[] = {3, 34, 4, 12, 5, 2};\n        int sum = 9;\n        int n = set.length;\n        if (isSubsetSum(set, n, sum) == true) {\n            System.out.println(\"Found a subset\" + \" with given sum\");\n        } else {\n            System.out.println(\"No subset with\" + \" given sum\");\n        }\n    }\n}", "src": "\n// A Dynamic Programming solution for subset \n// sum problem \nclass\nGFG { \n\n\n// Returns true if there is a subset of \n\n// set[] with sun equal to given sum \n\nstatic\nboolean\nisSubsetSum(\nint\nset[], \n\nint\nn, \nint\nsum) \n\n{ \n\n// The value of subset[i][j] will be \n\n// true if there is a subset of \n\n// set[0..j-1] with sum equal to i \n\nboolean\nsubset[][] = \n\nnew\nboolean\n[sum+\n1\n][n+\n1\n]; \n\n\n// If sum is 0, then answer is true \n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nsubset[\n0\n][i] = \ntrue\n; \n\n\n// If sum is not 0 and set is empty, \n\n// then answer is false \n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\nsubset[i][\n0\n] = \nfalse\n; \n\n\n// Fill the subset table in botton \n\n// up manner \n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\n{ \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) \n\n{ \n\nsubset[i][j] = subset[i][j-\n1\n]; \n\nif\n(i >= set[j-\n1\n]) \n\nsubset[i][j] = subset[i][j] || \n\nsubset[i - set[j-\n1\n]][j-\n1\n]; \n\n} \n\n} \n\n\n/* // uncomment this code to print table \n\nfor (int i = 0; i <= sum; i++) \n\n{ \n\nfor (int j = 0; j <= n; j++) \n\nSystem.out.println (subset[i][j]); \n\n} */\n\n\nreturn\nsubset[sum][n]; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\nset[] = {\n3\n, \n34\n, \n4\n, \n12\n, \n5\n, \n2\n}; \n\nint\nsum = \n9\n; \n\nint\nn = set.length; \n\nif\n(isSubsetSum(set, n, sum) == \ntrue\n) \n\nSystem.out.println(\n\"Found a subset\"\n\n+ \n\" with given sum\"\n); \n\nelse\n\nSystem.out.println(\n\"No subset with\"\n\n+ \n\" given sum\"\n); \n\n} \n} \n\n/* This code is contributed by Rajat Mishra */", "index": 546, "complexity": 5}
{"back-translation": "class GFG {\n    public static int maxLenSub(int arr[], int n) {\n        int mls[] = new int[n], max = 0;\n        for (int i = 0; i < n; i++) {\n            mls[i] = 1;\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (Math.abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) {\n                    mls[i] = mls[j] + 1;\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (max < mls[i]) {\n                max = mls[i];\n            }\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {2, 5, 6, 3, 7, 6, 5, 8};\n        int n = arr.length;\n        System.out.println(\"Maximum length subsequence = \" + maxLenSub(arr, n));\n    }\n}", "src": "\n// JAVA Code for Maximum length subsequence \n// with difference between adjacent elements \n// as either 0 or 1 \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// function to find maximum length subsequence \n\n// with difference between adjacent elements as \n\n// either 0 or 1 \n\npublic\nstatic\nint\nmaxLenSub(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmls[] = \nnew\nint\n[n], max = \n0\n; \n\n\n// Initialize mls[] values for all indexes \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmls[i] = \n1\n; \n\n\n// Compute optimized maximum length \n\n// subsequence values in bottom up manner \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(Math.abs(arr[i] - arr[j]) <= \n1\n\n&& mls[i] < mls[j] + \n1\n) \n\nmls[i] = mls[j] + \n1\n; \n\n\n// Store maximum of all 'mls' values in 'max' \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(max < mls[i]) \n\nmax = mls[i]; \n\n\n// required maximum length subsequence \n\nreturn\nmax; \n\n} \n\n\n/* Driver program to test above function */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n5\n, \n6\n, \n3\n, \n7\n, \n6\n, \n5\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum length subsequence = \"\n+ \n\nmaxLenSub(arr, n)); \n\n\n} \n} \n\n// This code is contributed by Arnav Kr. Mandal. ", "index": 547, "complexity": 5}
{"back-translation": "class GFG { static int N = 4; static int MaximumPath(int[][] Mat) { int result = 0; int[][] dp = new int[N][N + 2]; for (int[] rows : dp) Arrays.fill(rows, 0); for (int i = 0; i < N; i++) dp[0][i + 1] = Mat[0][i]; for (int i = 1; i < N; i++) for (int j = 1; j <= N; j++) dp[i][j] = Math.max(dp[i - 1][j - 1], Math.max(dp[i - 1][j], dp[i - 1][j + 1])) + Mat[i][j - 1]; for (int i = 0; i <= N; i++) result = Math.max(result, dp[N - 1][i]); return result; } public static void main(String arg[]) { int Mat[][] = { {4, 2, 3, 4}, {2, 9, 1, 10}, {15, 1, 3, 0}, {16, 92, 41, 44} }; System.out.println(MaximumPath(Mat)); } }", "src": "\n// Java program to find Maximum path sum \n// start any column in row '0' and ends \n// up to any column in row 'n-1' \nimport\njava.util.*; \n\nclass\nGFG { \n\n\nstatic\nint\nN = \n4\n; \n\n\n// function find maximum sum path \n\nstatic\nint\nMaximumPath(\nint\nMat[][]) \n\n{ \n\nint\nresult = \n0\n; \n\n\n// creat 2D matrix to store the sum \n\n// of the path \n\nint\ndp[][] = \nnew\nint\n[N][N + \n2\n]; \n\n\n// initialize all dp matrix as '0' \n\nfor\n(\nint\n[] rows : dp) \n\nArrays.fill(rows, \n0\n); \n\n\n// copy all element of first column into \n\n// 'dp' first column \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ndp[\n0\n][i + \n1\n] = Mat[\n0\n][i]; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j <= N; j++) \n\ndp[i][j] = Math.max(dp[i - \n1\n][j - \n1\n], \n\nMath.max(dp[i - \n1\n][j], \n\ndp[i - \n1\n][j + \n1\n])) + \n\nMat[i][j - \n1\n]; \n\n\n// Find maximum path sum that end ups \n\n// at any column of last row 'N-1' \n\nfor\n(\nint\ni = \n0\n; i <= N; i++) \n\nresult = Math.max(result, dp[N - \n1\n][i]); \n\n\n// return maximum sum path \n\nreturn\nresult; \n\n} \n\n\n// driver code \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nMat[][] = { { \n4\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n2\n, \n9\n, \n1\n, \n10\n}, \n\n{ \n15\n, \n1\n, \n3\n, \n0\n}, \n\n{ \n16\n, \n92\n, \n41\n, \n44\n} }; \n\n\nSystem.out.println(MaximumPath(Mat)); \n\n} \n} \n\n// This code is contributed by Anant Agarwal. ", "index": 548, "complexity": 5}
{"back-translation": "import java.util.*;\n\npublic class helloWorld {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint l = 1000, r = 0, u = 1000, b = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tString str = in.next();\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tif(str.charAt(j) == 'B') {\n\t\t\t\t\tl = Math.min(j + 1, l);\n\t\t\t\t\tr = Math.max(j + 1, r);\n\t\t\t\t\tu = Math.min(i + 1, u);\n\t\t\t\t\tb = Math.max(i + 1, b);\n\t\t\t\t}\n\t\t}\n\t\tSystem.out.println((u + b) / 2 + \" \" + (l + r) / 2);\n\t\tin.close();\n\t}\n}", "src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint l = 1000, r = 0, u = 1000, b = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++ ) {\n\t\t\tString str = in.next();\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\tif(str.charAt(j) == 'B') {\n\t\t\t\t\tl = Math.min(j+1, l);\n\t\t\t\t\tr = Math.max(j+1, r);\n\t\t\t\t\tu = Math.min(i+1, u);\n\t\t\t\t\tb = Math.max(i+1, b);\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println((u+b)/2 + \" \" + (l+r)/2);\n\t\t\n\t\tin.close();\n\t}\n}\n\n\n\n", "index": 549, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Newbie {\n\n    static InputReader sc = new InputReader(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        solver s = new solver();\n        int t = 1;\n        while (t > 0) {\n            s.solve();\n            t--;\n        }\n        out.close();\n    }\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n            token = null;\n        }\n\n        public String next() {\n            while (token == null || !token.hasMoreTokens()) {\n                try {\n                    token = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class card {\n        long a;\n        int cnt;\n        int i;\n\n        public card(long a, int cnt, int i) {\n            this.a = a;\n            this.cnt = cnt;\n            this.i = i;\n        }\n    }\n\n    static class ascend implements Comparator<pair> {\n        public int compare(pair o1, pair o2) {\n            return o1.a - o2.a;\n        }\n    }\n\n    static class extra {\n\n        static boolean v[] = new boolean[100001];\n        static List<Integer> l = new ArrayList<>();\n        static int t;\n\n        static void shuffle(long a[]) {\n            List<Long> l = new ArrayList<>();\n            for (int i = 0; i < a.length; i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for (int i = 0; i < a.length; i++)\n                a[i] = l.get(i);\n        }\n\n        static long gcd(long a, long b) {\n            if (b == 0)\n                return a;\n            else\n                return gcd(b, a % b);\n        }\n\n        static boolean valid(int i, int j, int r, int c) {\n            if (i >= 0 && i < r && j >= 0 && j < c)\n                return true;\n            else\n                return false;\n        }\n\n        static void seive() {\n            for (int i = 2; i < 100001; i++) {\n                if (!v[i]) {\n                    t++;\n                    l.add(i);\n                    for (int j = 2 * i; j < 100001; j += i)\n                        v[j] = true;\n                }\n            }\n        }\n\n        static int binary(long a[], long val, int n) {\n            int mid = 0, l = 0, r = n - 1, ans = 0;\n            while (l <= r) {\n                mid = (l + r) >> 1;\n                if (a[mid] == val) {\n                    r = mid - 1;\n                    ans = mid;\n                } else if (a[mid] > val)\n                    r = mid - 1;\n                else {\n                    l = mid + 1;\n                    ans = l;\n                }\n            }\n            return (ans + 1);\n        }\n\n        static long fastexpo(int x, int y) {\n            long res = 1;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res *= x;\n                }\n                y = y >> 1;\n                x = x * x;\n            }\n            return res;\n        }\n\n        static long lfastexpo(int x, int y, int p) {\n            long res = 1;\n            x = x % p;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res = (res * x) % p;\n                }\n                y = y >> 1;\n                x = (x * x) % p;\n            }\n            return res;\n        }\n    }\n\n    static class pair {\n        int a;\n        int b;\n\n        public pair(int a, int i) {\n            this.a = a;\n            this.b = i;\n        }\n    }\n\n    static class pair1 {\n        pair p;\n        int in;\n\n        public pair1(pair a, int n) {\n            this.p = a;\n            this.in = n;\n        }\n    }\n\n    static long m = (long) 1e9 + 7;\n\n    static class solver {\n        void solve() {\n            int n = sc.nextInt();\n            int ans=0;\n            int a[]=new int[2*n];\n            for (int i = 0; i < 2 * n; i++) {\n               a[i]=sc.nextInt();\n            }\n            for(int i=0;i<2*n;i++)\n            {\n                if(a[i]>0)\n                {\n                    int j=0;\n                    for(j=i+1;a[i]!=a[j];j++)\n                    {\n                        if(a[j]>0)\n                            ans++;\n                    }\n                    a[j]=0;\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n}", "src": "import com.sun.org.apache.xerces.internal.util.SynchronizedSymbolTable;\nimport jdk.management.cmm.SystemResourcePressureMXBean;\n\nimport java.awt.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.List;\nimport java.math.*;\n\npublic class Newbie {\n\n    static InputReader sc = new InputReader(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        solver s = new solver();\n        int t = 1;\n        while (t > 0) {\n            s.solve();\n            t--;\n        }\n        out.close();\n    }\n\n   /* static class descend implements Comparator<pair1> {\n        public int compare(pair1 o1, pair1 o2) {\n            if (o1.pop != o2.pop)\n                return (int) (o1.pop - o2.pop);\n            else\n                return o1.in - o2.in;\n        }\n    }*/\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n            token = null;\n        }\n\n        public String next() {\n            while (token == null || !token.hasMoreTokens()) {\n                try {\n                    token = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class card {\n        long a;\n        int cnt;\n        int i;\n\n        public card(long a, int cnt, int i) {\n            this.a = a;\n            this.cnt = cnt;\n            this.i = i;\n        }\n    }\n\n    static class ascend implements Comparator<pair> {\n        public int compare(pair o1, pair o2) {\n            return o1.a - o2.a;\n        }\n    }\n\n    static class extra {\n\n        static boolean v[] = new boolean[100001];\n        static List<Integer> l = new ArrayList<>();\n        static int t;\n\n        static void shuffle(long a[]) {\n            List<Long> l = new ArrayList<>();\n            for (int i = 0; i < a.length; i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for (int i = 0; i < a.length; i++)\n                a[i] = l.get(i);\n        }\n\n        static long gcd(long a, long b) {\n            if (b == 0)\n                return a;\n            else\n                return gcd(b, a % b);\n        }\n\n        static boolean valid(int i, int j, int r, int c) {\n            if (i >= 0 && i < r && j >= 0 && j < c)\n                return true;\n            else\n                return false;\n        }\n\n        static void seive() {\n            for (int i = 2; i < 100001; i++) {\n                if (!v[i]) {\n                    t++;\n                    l.add(i);\n                    for (int j = 2 * i; j < 100001; j += i)\n                        v[j] = true;\n                }\n            }\n        }\n\n        static int binary(long a[], long val, int n) {\n            int mid = 0, l = 0, r = n - 1, ans = 0;\n            while (l <= r) {\n                mid = (l + r) >> 1;\n                if (a[mid] == val) {\n                    r = mid - 1;\n                    ans = mid;\n                } else if (a[mid] > val)\n                    r = mid - 1;\n                else {\n                    l = mid + 1;\n                    ans = l;\n                }\n            }\n            return (ans + 1);\n        }\n\n        static long fastexpo(int x, int y) {\n            long res = 1;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res *= x;\n                }\n                y = y >> 1;\n                x = x * x;\n            }\n            return res;\n        }\n\n        static long lfastexpo(int x, int y, int p) {\n            long res = 1;\n            x = x % p;\n            while (y > 0) {\n                if ((y & 1) == 1) {\n                    res = (res * x) % p;\n                }\n                y = y >> 1;\n                x = (x * x) % p;\n            }\n            return res;\n        }\n    }\n\n    static class pair {\n        int a;\n        int b;\n\n        public pair(int a, int i) {\n            this.a = a;\n            this.b = i;\n        }\n    }\n\n    static class pair1 {\n        pair p;\n        int in;\n\n        public pair1(pair a, int n) {\n            this.p = a;\n            this.in = n;\n        }\n    }\n\n    static long m = (long) 1e9 + 7;\n\n    static class solver {\n        void solve() {\n            int n = sc.nextInt();\n            int ans=0;\n            int a[]=new int[2*n];\n            for (int i = 0; i < 2 * n; i++) {\n               a[i]=sc.nextInt();\n            }\n            for(int i=0;i<2*n;i++)\n            {\n                if(a[i]>0)\n                {\n                    int j=0;\n                    for(j=i+1;a[i]!=a[j];j++)\n                    {\n                        if(a[j]>0)\n                            ans++;\n                    }\n                    a[j]=0;\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n}", "index": 551, "complexity": 5}
{"back-translation": "class GFG { static int lis(int[] arr, int n) { int[] mpis = new int[n]; int max = Integer.MIN_VALUE; for (int i = 0; i < n; i++) mpis[i] = arr[i]; for (int i = 1; i < n; i++) for (int j = 0; j < i; j++) if (arr[i] > arr[j] && mpis[i] < (mpis[j] * arr[i])) mpis[i] = mpis[j] * arr[i]; for (int k = 0; k < mpis.length; k++) { if (mpis[k] > max) { max = mpis[k]; } } return max; } public static void main(String[] args) { int[] arr = { 3, 100, 4, 5, 150, 6 }; int n = arr.length; System.out.println(lis(arr, n)); } }", "src": "\n/* Dynamic programming Java implementation \nof maximum product of an increasing \nsubsequence */\nimport\njava.util.Arrays; \nimport\njava.util.Collections; \n\nclass\nGFG { \n\n\n// Returns product of maximum product \n\n// increasing subsequence. \n\nstatic\nint\nlis(\nint\n[] arr, \nint\nn) \n\n{ \n\nint\n[] mpis = \nnew\nint\n[n]; \n\nint\nmax = Integer.MIN_VALUE; \n\n\n/* Initialize MPIS values */\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmpis[i] = arr[i]; \n\n\n/* Compute optimized MPIS values \n\nconsidering every element as ending \n\nelement of sequence */\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && mpis[i] \n\n< (mpis[j] * arr[i])) \n\nmpis[i] = mpis[j] * arr[i]; \n\n\n/* Pick maximum of all product values \n\nusing for loop*/\n\nfor\n(\nint\nk = \n0\n; k < mpis.length; k++) \n\n{ \n\nif\n(mpis[k] > max) { \n\nmax = mpis[k]; \n\n} \n\n} \n\n\nreturn\nmax; \n\n} \n\n\n// Driver program to test above function \n\nstatic\npublic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] arr = { \n3\n, \n100\n, \n4\n, \n5\n, \n150\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(lis(arr, n)); \n\n} \n} \n\n// This code is contributed by parashar. ", "index": 552, "complexity": 5}
{"back-translation": "import java.util.Scanner;\n\npublic class New_Year_and_Curling {\n    static final double E = 0.00001;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int r = sc.nextInt();\n        double[] y = new double[n];\n        int arr[] = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n            double top = r;\n            int x = arr[i];\n            for (int j = 0; j < i; j++) {\n                if (Math.abs(arr[j] - x) <= 2 * r) {\n                    top = Math.max(top, y[j] + Math.sqrt((4 * r * r) - ((arr[j] - x) * (arr[j] - x))));\n                }\n            }\n            y[i] = top;\n            double res = y[i];\n            System.out.print(res + \" \");\n        }\n    }\n}", "src": " import java.util.Scanner;\n    public class New_Year_and_Curling {\n        static final double E = 0.00001;\n \n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n \n            int n = sc.nextInt();\n            int r = sc.nextInt();\n            double[] y = new double[n];\n            int arr[] = new int[n];\n \n            for (int i = 0; i < n; i++) {\n                arr[i] =sc.nextInt();\n                double top = r; // if we make it 0 and subtract from the result will get WA (do not know why!!!)\n                int x = arr[i];\n                for(int  j =0 ;j<i;j++)\n                {\n                    if(Math.abs(arr[j] -x )<=2*r) {\n \n                            top = Math.max(top  , y[j] + Math.sqrt((4 * r * r) - ((arr[j] - x) * (arr[j] - x))));\n \n                    }\n                }\n                y[i] = top ;\n                double res = y[i] ;\n                System.out.print(res+\" \");\n            }\n \n        }\n \n    }", "index": 553, "complexity": 5}
{"back-translation": "class LeadersInArray { void printLeaders(int arr[], int size) { for (int i = 0; i < size; i++) { int j; for (j = i + 1; j < size; j++) { if (arr[i] <= arr[j]) break; } if (j == size) { System.out.print(arr[i] + \" \"); } } } public static void main(String[] args) { LeadersInArray lead = new LeadersInArray(); int arr[] = new int[]{16, 17, 4, 3, 5, 2}; int n = arr.length; lead.printLeaders(arr, n); } }", "src": "\nclass\nLeadersInArray \n{ \n\n/*Java Function to print leaders in an array */\n\nvoid\nprintLeaders(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nint\nj; \n\nfor\n(j = i + \n1\n; j < size; j++) \n\n{ \n\nif\n(arr[i] <= arr[j]) \n\nbreak\n; \n\n} \n\nif\n(j == size) \n// the loop didn't break \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nLeadersInArray lead = \nnew\nLeadersInArray(); \n\nint\narr[] = \nnew\nint\n[]{\n16\n, \n17\n, \n4\n, \n3\n, \n5\n, \n2\n}; \n\nint\nn = arr.length; \n\nlead.printLeaders(arr, n); \n\n} \n} ", "index": 554, "complexity": 5}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class PartySweet {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt(), m = nextInt();\n\t\tint[] b = new int[n];\n\t\tint[] g = new int[m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tb[i] = nextInt();\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tg[i] = nextInt();\n\t\tint total = 0;\n\t\tint max = 0, max2 = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (b[i] > b[max]) {\n\t\t\t\tmax2 = max;\n\t\t\t\tmax = i;\n\t\t\t} else if (b[max2] < b[i])\n\t\t\t\tmax2 = i;\n\t\t}\n\t\ttotal += b[max] - b[max2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (b[i] > g[j]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (i != max)\n\t\t\t\t\ttotal += b[i];\n\t\t\t\telse\n\t\t\t\t\ttotal += g[j];\n\t\t\t\t}\n\t\t\t}\n\t\tSystem.out.println(total);\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "src": "import java.util.*;\nimport java.io.*;\n\npublic class PartySweet {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt(), m = nextInt();\n\t\tint[] b = new int[n];\n\t\tint[] g = new int[m];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tb[i] = nextInt();\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tg[i] = nextInt();\n\t\tint total = 0;\n\t\tint max = 0, max2 = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(b[i] > b[max]) {\n\t\t\t\tmax2 = max;\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t\telse if(b[max2] < b[i])\n\t\t\t\tmax2 = i;\n\t\t}\n\t\ttotal += b[max] - b[max2];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(b[i] > g[j]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(i != max)\n\t\t\t\t\ttotal += b[i];\n\t\t\t\telse\n\t\t\t\t\ttotal += g[j];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(total);\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n", "index": 559, "complexity": 5}
{"back-translation": "public class Main { static void minAbsSumPair(int[] arr, int arr_size) { int inv_count = 0; int l, r, min_sum, sum, min_l, min_r; if (arr_size < 2) { System.out.println(\"Invalid Input\"); return; } min_l = 0; min_r = 1; min_sum = arr[0] + arr[1]; for (l = 0; l < arr_size - 1; l++) { for (r = l + 1; r < arr_size; r++) { sum = arr[l] + arr[r]; if (Math.abs(min_sum) > Math.abs(sum)) { min_sum = sum; min_l = l; min_r = r; } } } System.out.println(\" The two elements whose \" + \"sum is minimum are \" + arr[min_l] + \" and \" + arr[min_r]); } public static void main(String[] args) { int[] arr = {1, 60, -10, 70, -80, 85}; minAbsSumPair(arr, 6); } }", "src": "\nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n/* Array should have at least two elements*/\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n/* Initialization of values */\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n} ", "index": 560, "complexity": 5}
{"back-translation": "class GFG {\n    static int maxSumIS(int arr[], int n) {\n        int i, j, max = 0;\n        int msis[] = new int[n];\n\n        for (i = 0; i < n; i++)\n            msis[i] = arr[i];\n\n        for (i = 1; i < n; i++)\n            for (j = 0; j < i; j++)\n                if (arr[i] > arr[j] && msis[i] < msis[j] + arr[i])\n                    msis[i] = msis[j] + arr[i];\n\n        for (i = 0; i < n; i++)\n            if (max < msis[i])\n                max = msis[i];\n\n        return max;\n    }\n\n    public static void main(String args[]) {\n        int arr[] = new int[]{1, 101, 2, 3, 100, 4, 5};\n        int n = arr.length;\n        System.out.println(\"Sum of the maximum sum \" + \"increasing subsequence is \" + maxSumIS(arr, n));\n    }\n}\n", "src": "\n/* Dynamic Programming Java \n\nimplementation of Maximum Sum \n\nIncreasing Subsequence (MSIS) \n\nproblem */\nclass\nGFG \n{ \n\n/* maxSumIS() returns the \n\nmaximum sum of increasing \n\nsubsequence in arr[] of size n */\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n/* Initialize msis values \n\nfor all indexes */\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n/* Compute maximum sum values \n\nin bottom up manner */\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n/* Pick maximum of all \n\nmsis values */\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n} \n\n// This code is contributed \n// by Rajat Mishra ", "index": 561, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.util.*;\npublic class Codechef{\n      \n\n    public static void main(String[] args){\n       Scanner sc = new Scanner(System.in);\n       int n = sc.nextInt();\n       Set<HashSet> s3 = new HashSet<>();\n\n             for (int j = 0; j < n; j++) {\n                 String a = sc.next();\n                 HashSet<Character> t = new HashSet<Character>();\n                 for (char c : a.toCharArray()) {\n                     t.add(c);\n                 }\n\n                 s3.add(t);\n             }\n             System.out.println(s3.size());\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\npublic class Codechef{\n      \n\n    public static void main(String []args){\n       Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n\t\tSet<HashSet> s3 = new HashSet<>();\n\n      \n         for(int j=0;j<n;j++){\n         \tString a=sc.next();\n         HashSet<Character> t = new HashSet<Character>();\n\t\t\tfor(char c:a.toCharArray()){\n\t\t\tt.add(c);\n\t\t\t}\n\n        s3.add(t);\n    \n          \n\n         }\n         System.out.println(s3.size());\n    }\n}", "index": 562, "complexity": 5}
{"back-translation": "class GFG { static void printEqualSumSets(int[] arr, int n) { int i, currSum, sum = 0; for (i = 0; i < arr.length; i++) sum += arr[i]; if ((sum & 1) == 1) { System.out.print(\"-1\"); return; } int k = sum >> 1; boolean[][] dp = new boolean[n + 1][k + 1]; for (i = 1; i <= k; i++) dp[0][i] = false; for (i = 0; i <= n; i++) dp[i][0] = true; for (i = 1; i <= n; i++) { for (currSum = 1; currSum <= k; currSum++) { dp[i][currSum] = dp[i - 1][currSum]; if (arr[i - 1] <= currSum) dp[i][currSum] = dp[i][currSum] | dp[i - 1][currSum - arr[i - 1]]; } } List<Integer> set1 = new ArrayList<Integer>(); List<Integer> set2 = new ArrayList<Integer>(); if (!dp[n][k]) { System.out.print(\"-1\\n\"); return; } i = n; currSum = k; while (i > 0 && currSum >= 0) { if (dp[i - 1][currSum]) { i--; set2.add(arr[i]); } else if (dp[i - 1][currSum - arr[i - 1]]) { i--; currSum -= arr[i]; set1.add(arr[i]); } } System.out.print(\"Set 1 elements: \"); for (i = 0; i < set1.size(); i++) System.out.print(set1.get(i) + \" \"); System.out.print(\"\\nSet 2 elements: \"); for (i = 0; i < set2.size(); i++) System.out.print(set2.get(i) + \" \"); } public static void main(String args[]) { int[] arr = new int[]{5, 5, 1, 11}; int n = arr.length; printEqualSumSets(arr, n); } }", "src": "\n// Java program to print \n// equal sum sets of array. \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n// Function to print equal \n\n// sum sets of array. \n\nstatic\nvoid\nprintEqualSumSets(\nint\n[]arr, \n\nint\nn) \n\n{ \n\nint\ni, currSum, sum = \n0\n; \n\n\n// Finding sum of array elements \n\nfor\n(i = \n0\n; i < arr.length; i++) \n\nsum += arr[i]; \n\n\n// Check sum is even or odd. \n\n// If odd then array cannot \n\n// be partitioned. Print -1 \n\n// and return. \n\nif\n((sum & \n1\n) == \n1\n) \n\n{ \n\nSystem.out.print(\n\"-1\"\n); \n\nreturn\n; \n\n} \n\n\n// Divide sum by 2 to find \n\n// sum of two possible subsets. \n\nint\nk = sum >> \n1\n; \n\n\n// Boolean DP table to store \n\n// result of states. \n\n// dp[i,j] = true if there is a \n\n// subset of elements in first i \n\n// elements of array that has sum \n\n// equal to j. \n\nboolean\n[][]dp = \nnew\nboolean\n[n + \n1\n][k + \n1\n]; \n\n\n// If number of elements are zero, \n\n// then no sum can be obtained. \n\nfor\n(i = \n1\n; i <= k; i++) \n\ndp[\n0\n][i] = \nfalse\n; \n\n\n// Sum 0 can be obtained by \n\n// not selecting any element. \n\nfor\n(i = \n0\n; i <= n; i++) \n\ndp[i][\n0\n] = \ntrue\n; \n\n\n// Fill the DP table \n\n// in bottom up manner. \n\nfor\n(i = \n1\n; i <= n; i++) \n\n{ \n\nfor\n(currSum = \n1\n; \n\ncurrSum <= k; \n\ncurrSum++) \n\n{ \n\n\n// Excluding current element. \n\ndp[i][currSum] = dp[i - \n1\n][currSum]; \n\n\n// Including current element \n\nif\n(arr[i - \n1\n] <= currSum) \n\ndp[i][currSum] = dp[i][currSum] | \n\ndp[i - \n1\n][currSum - arr[i - \n1\n]]; \n\n} \n\n} \n\n\n// Required sets set1 and set2. \n\nList<Integer> set1 = \nnew\nArrayList<Integer>(); \n\nList<Integer> set2 = \nnew\nArrayList<Integer>(); \n\n\n// If partition is not possible \n\n// print -1 and return. \n\nif\n(!dp[n][k]) \n\n{ \n\nSystem.out.print(\n\"-1\\n\"\n); \n\nreturn\n; \n\n} \n\n\n// Start from last \n\n// element in dp table. \n\ni = n; \n\ncurrSum = k; \n\n\nwhile\n(i > \n0\n&& currSum >= \n0\n) \n\n{ \n\n\n// If current element does \n\n// not contribute to k, then \n\n// it belongs to set 2. \n\nif\n(dp[i - \n1\n][currSum]) \n\n{ \n\ni--; \n\nset2.add(arr[i]); \n\n} \n\n\n// If current element contribute \n\n// to k then it belongs to set 1. \n\nelse\nif\n(dp[i - \n1\n][currSum - arr[i - \n1\n]]) \n\n{ \n\ni--; \n\ncurrSum -= arr[i]; \n\nset1.add(arr[i]); \n\n} \n\n} \n\n\n// Print elements of both the sets. \n\nSystem.out.print(\n\"Set 1 elements: \"\n); \n\nfor\n(i = \n0\n; i < set1.size(); i++) \n\nSystem.out.print(set1.get(i) + \n\" \"\n); \n\n\nSystem.out.print(\n\"\\nSet 2 elements: \"\n); \n\n\nfor\n(i = \n0\n; i < set2.size(); i++) \n\nSystem.out.print(set2.get(i) + \n\" \"\n); \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = \nnew\nint\n[]{ \n5\n, \n5\n, \n1\n, \n11\n}; \n\nint\nn = arr.length; \n\nprintEqualSumSets(arr, n); \n\n} \n} \n\n// This code is contributed by \n// Manish Shaw(manishshaw1) ", "index": 563, "complexity": 5}
{"back-translation": "class GFG { public static int minIndex(Queue<Integer> list, int sortIndex) { int min_index = -1; int min_value = Integer.MAX_VALUE; int s = list.size(); for (int i = 0; i < s; i++) { int current = list.peek(); list.poll(); if (current <= min_value && i <= sortIndex) { min_index = i; min_value = current; } list.add(current); } return min_index; } public static void insertMinToRear(Queue<Integer> list, int min_index) { int min_value = 0; int s = list.size(); for (int i = 0; i < s; i++) { int current = list.peek(); list.poll(); if (i != min_index) list.add(current); else min_value = current; } list.add(min_value); } public static void sortQueue(Queue<Integer> list) { for (int i = 1; i <= list.size(); i++) { int min_index = minIndex(list, list.size() - i); insertMinToRear(list, min_index); } } public static void main(String[] args) { Queue<Integer> list = new LinkedList<Integer>(); list.add(30); list.add(11); list.add(15); list.add(4); sortQueue(list); while (list.isEmpty() == false) { System.out.print(list.peek() + \" \"); list.poll(); } } }", "src": "\n// Java program to implement sorting a \n// queue data structure \nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \nclass\nGFG \n{ \n\n// Queue elements after sortIndex are \n\n// already sorted. This function returns \n\n// index of minimum element from front to \n\n// sortIndex \n\npublic\nstatic\nint\nminIndex(Queue<Integer> list, \n\nint\nsortIndex) \n\n{ \n\nint\nmin_index = -\n1\n; \n\nint\nmin_value = Integer.MAX_VALUE; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\n\n// This is dequeue() in Java STL \n\nlist.poll(); \n\n\n// we add the condition i <= sortIndex \n\n// because we don't want to traverse \n\n// on the sorted part of the queue, \n\n// which is the right part. \n\nif\n(current <= min_value && i <= sortIndex) \n\n{ \n\nmin_index = i; \n\nmin_value = current; \n\n} \n\nlist.add(current); \n\n} \n\nreturn\nmin_index; \n} \n\n\n// Moves given minimum element \n\n// to rear of queue \n\npublic\nstatic\nvoid\ninsertMinToRear(Queue<Integer> list, \n\nint\nmin_index) \n\n{ \n\nint\nmin_value = \n0\n; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\nlist.poll(); \n\nif\n(i != min_index) \n\nlist.add(current); \n\nelse\n\nmin_value = current; \n\n} \n\nlist.add(min_value); \n\n} \n\n\npublic\nstatic\nvoid\nsortQueue(Queue<Integer> list) \n\n{ \n\nfor\n(\nint\ni = \n1\n; i <= list.size(); i++) \n\n{ \n\nint\nmin_index = minIndex(list,list.size() - i); \n\ninsertMinToRear(list, min_index); \n\n} \n\n} \n\n\n//Driver function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nQueue<Integer> list = \nnew\nLinkedList<Integer>(); \n\nlist.add(\n30\n); \n\nlist.add(\n11\n); \n\nlist.add(\n15\n); \n\nlist.add(\n4\n); \n\n\n//Sort Queue \n\nsortQueue(list); \n\n\n//print sorted Queue \n\nwhile\n(list.isEmpty()== \nfalse\n) \n\n{ \n\nSystem.out.print(list.peek() + \n\" \"\n); \n\nlist.poll(); \n\n} \n\n} \n} \n\n// This code is contributed by akash1295 ", "index": 564, "complexity": 5}
{"back-translation": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\nimport java.nio.charset.Charset;\nimport java.util.*;\n\nimport static java.lang.System.gc;\nimport static java.lang.System.out;\n\npublic class Main {\n\n    Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n\n    void solve() {\n\n        int n = scanner.nextInt();\n        scanner.nextLine();\n        String s1 = scanner.nextLine();\n        String s2 = scanner.nextLine();\n\n\n        int ans = 0;\n        boolean a[] = new boolean[30];\n        boolean b[] = new boolean[30];\n\n        for (int i = 0; i < n; i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                ans ++;\n                a[s1.charAt(i)  - 'a'] = true;\n                b[s2.charAt(i)  - 'a'] = true;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (s1.charAt(i) != s2.charAt(i) && a[s2.charAt(i) - 'a'] && b[s1.charAt(i) - 'a']) {\n                for (int j = i + 1; j < n; j ++) {\n                    if (s1.charAt(i) == s2.charAt(j) && s1.charAt(j) == s2.charAt(i)) {\n                        out.println(ans - 2);\n                        out.println((i + 1) + \" \" + (j + 1));\n                        return;\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (s1.charAt(i) != s2.charAt(i) && (a[s2.charAt(i) - 'a'] || b[s1.charAt(i) - 'a'])) {\n                for (int j = i + 1; j < n; j ++) {\n                    if (s1.charAt(j) != s2.charAt(j) && (s1.charAt(i) == s2.charAt(j) || s1.charAt(j) == s2.charAt(i))) {\n                        out.println(ans - 1);\n                        out.println((i + 1) + \" \" + (j + 1));\n                        return;\n                    }\n                }\n            }\n        }\n\n        out.println(ans);\n        out.println(-1 + \" \" + -1);\n    }\n}", "src": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\nimport java.nio.charset.Charset;\nimport java.util.*;\n\nimport static java.lang.System.gc;\nimport static java.lang.System.out;\n\npublic class Main {\n\n    Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n\n    void solve() {\n\n        int n = scanner.nextInt();\n        scanner.nextLine();\n        String s1 = scanner.nextLine();\n        String s2 = scanner.nextLine();\n\n\n        int ans = 0;\n        boolean a[] = new boolean[30];\n        boolean b[] = new boolean[30];\n\n        for (int i = 0; i < n; i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                ans ++;\n                a[s1.charAt(i)  - 'a'] = true;\n                b[s2.charAt(i)  - 'a'] = true;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (s1.charAt(i) != s2.charAt(i) && a[s2.charAt(i) - 'a'] && b[s1.charAt(i) - 'a']) {\n                for (int j = i + 1; j < n; j ++) {\n                    if (s1.charAt(i) == s2.charAt(j) && s1.charAt(j) == s2.charAt(i)) {\n                        out.println(ans - 2);\n                        out.println((i + 1) + \" \" + (j + 1));\n                        return;\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (s1.charAt(i) != s2.charAt(i) && (a[s2.charAt(i) - 'a'] || b[s1.charAt(i) - 'a'])) {\n                for (int j = i + 1; j < n; j ++) {\n                    if (s1.charAt(j) != s2.charAt(j) && (s1.charAt(i) == s2.charAt(j) || s1.charAt(j) == s2.charAt(i))) {\n                        out.println(ans - 1);\n                        out.println((i + 1) + \" \" + (j + 1));\n                        return;\n                    }\n                }\n            }\n        }\n\n        out.println(ans);\n        out.println(-1 + \" \" + -1);\n    }\n}", "index": 565, "complexity": 5}
{"back-translation": "import java.util.Scanner;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Solution {\n    private static final int[] dx = {\n            -1, -1, -1,\n            0, 0,\n            1, 1, 1\n    };\n    private static final int[] dy = {\n            -1, 0, 1,\n            -1, 1,\n            -1, 0, 1\n    };\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n        int r = in.nextInt();\n        int c = in.nextInt();\n        boolean[][] m = new boolean[r + 1][c + 1];\n        boolean[][] inp = new boolean[r + 1][c + 1];\n        for (int i = 0; i < r; i++) {\n            String s = in.next();\n            for (int j = 0; j < s.length(); j++) {\n                if (s.charAt(j) == '#') {\n                    m[i][j] = true;\n                    inp[i][j] = true;\n                }\n            }\n        }\n\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                if (canPress(i, j, r, c, inp)) {\n                    for (int k = 0; k < 8; k++) {\n                        int xi = i + dx[k];\n                        int yi = j + dy[k];\n                        m[xi][yi] = false;\n                    }\n                }\n            }\n        }\n        boolean isLeftAny = false;\n        for (int i = 0; i < r && !isLeftAny; i++) {\n            for (int j = 0; j < c && !isLeftAny; j++) {\n                if (m[i][j]) {\n                    isLeftAny = true;\n                    break;\n                }\n            }\n        }\n        if (isLeftAny) {\n            System.out.println(\"NO\");\n        } else {\n            System.out.println(\"YES\");\n        }\n    }\n\n    private static boolean canPress(int x, int y, int r, int c, boolean[][] inp) {\n        for (int i = 0; i < 8; i++) {\n            int xi = x + dx[i];\n            int yi = y + dy[i];\n            if (xi < 0 || yi < 0) {\n                return false;\n            }\n            if (xi >= r || yi >= c) {\n                return false;\n            }\n            if (!inp[xi][yi]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Solution {\n    private static int[] dx = {\n            -1, -1, -1,\n            0, 0,\n            1, 1, 1};\n    private static int[] dy = {\n            -1, 0, 1,\n            -1, 1,\n            -1, 0, 1};\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\n        int r = in.nextInt();\n        int c = in.nextInt();\n        boolean[][] m = new boolean[r + 1][c + 1];\n        boolean[][] inp = new boolean[r + 1][c + 1];\n        for (int i = 0; i < r; i++) {\n            String s = in.next();\n            //System.out.println(m[i]);\n            for (int j = 0; j < s.length(); j++) {\n                if (s.charAt(j) == '#') {\n                    m[i][j] = true;\n                    inp[i][j] = true;\n                }\n            }\n        }\n\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                if (canPress(i, j, r, c, inp)) {\n\n                    // make press\n                    for (int k = 0; k < 8; k++) {\n                        int xi = i + dx[k];\n                        int yi = j + dy[k];\n                        m[xi][yi] = false;\n                    }\n\n                }\n            }\n        }\n        boolean isLeftAny = false;\n        for (int i = 0; i < r && !isLeftAny; i++) {\n            for (int j = 0; j < c && !isLeftAny; j++) {\n                if (m[i][j]) {\n                    isLeftAny = true;\n                    break;\n                }\n            }\n        }\n        if(isLeftAny){\n            System.out.println(\"NO\");\n        }else{\n            System.out.println(\"YES\");\n        }\n    }\n\n    private static boolean canPress(int x, int y, int r, int c, boolean[][] inp) {\n        for (int i = 0; i < 8; i++) {\n            int xi = x + dx[i];\n            int yi = y + dy[i];\n            if (xi < 0 || yi < 0) {\n                return false;\n            }\n            if (xi >= r || yi >= c) {\n                return false;\n            }\n            if(!inp[xi][yi]){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n", "index": 566, "complexity": 5}
{"back-translation": "public class CountSubString { public int countSubStr(char[] str, int n) { int res = 0; for (int i = 0; i < n; i++) { if (str[i] == '1') { for (int j = i + 1; j < n; j++) { if (str[j] == '1') res++; } } } return res; } public static void main(String[] args) { CountSubString count = new CountSubString(); String string = \"00100101\"; char[] str = string.toCharArray(); int n = str.length; System.out.println(count.countSubStr(str, n)); } }", "src": "\n// A simple C++ program to count number of \n//substrings starting and ending with 1 \n\nclass\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[],\nint\nn) \n\n{ \n\nint\nres = \n0\n; \n// Initialize result \n\n\n// Pick a starting point \n\nfor\n(\nint\ni = \n0\n; i<n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\n{ \n\n// Search for all possible ending point \n\nfor\n(\nint\nj = i + \n1\n; j< n; j++) \n\n{ \n\nif\n(str[j] == \n'1'\n) \n\nres++; \n\n} \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n// Driver program to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str,n)); \n\n} \n} ", "index": 567, "complexity": 5}
{"back-translation": "class GFG { static int longestSubseqWithDiffOne(int arr[], int n) { int dp[] = new int[n]; for (int i = 0; i < n; i++) dp[i] = 1; for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { if ((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) dp[i] = Math.max(dp[i], dp[j] + 1); } } int result = 1; for (int i = 0; i < n; i++) if (result < dp[i]) result = dp[i]; return result; } public static void main(String[] args) { int arr[] = {1, 2, 3, 4, 5, 3, 2}; int n = arr.length; System.out.println(longestSubseqWithDiffOne(arr, n)); } }", "src": "\n// Java program to find the longest subsequence \n// such that the difference between adjacent \n// elements of the subsequence is one. \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Function to find the length of longest \n\n// subsequence \n\nstatic\nint\nlongestSubseqWithDiffOne(\nint\narr[], \n\nint\nn) \n\n{ \n\n// Initialize the dp[] array with 1 as a \n\n// single element will be of 1 length \n\nint\ndp[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i< n; i++) \n\ndp[i] = \n1\n; \n\n\n// Start traversing the given array \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n// Compare with all the previous \n\n// elements \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n// If the element is consecutive \n\n// then consider this subsequence \n\n// and update dp[i] if required. \n\nif\n((arr[i] == arr[j] + \n1\n) || \n\n(arr[i] == arr[j] - \n1\n)) \n\n\ndp[i] = Math.max(dp[i], dp[j]+\n1\n); \n\n} \n\n} \n\n\n// Longest length will be the maximum \n\n// value of dp array. \n\nint\nresult = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n ; i++) \n\nif\n(result < dp[i]) \n\nresult = dp[i]; \n\nreturn\nresult; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Longest subsequence with one \n\n// difference is \n\n// {1, 2, 3, 4, 3, 2} \n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n3\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(longestSubseqWithDiffOne( \n\narr, n)); \n\n} \n} \n\n// This code is contributed by Prerna Saini ", "index": 568, "complexity": 5}
{"back-translation": "import java.io.*;\n\nclass GFG {\n\nstatic int bellNumber(int n) {\n\nint[][] bell = new int[n + 1][n + 1];\n\nbell[0][0] = 1;\n\nfor (int i = 1; i <= n; i++) {\n\nbell[i][0] = bell[i - 1][i - 1];\n\nfor (int j = 1; j <= i; j++)\n\nbell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1];\n\n}\n\nreturn bell[n][0];\n\n}\n\npublic static void main(String[] args) {\n\nfor (int n = 0; n <= 5; n++)\n\nSystem.out.println(\"Bell Number \" + n + \" is \" + bellNumber(n));\n\n}\n}", "src": "\n// Java program to find n'th Bell number \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// Function to find n'th Bell Number \n\nstatic\nint\nbellNumber(\nint\nn) \n\n{ \n\nint\n[][] bell = \nnew\nint\n[n+\n1\n][n+\n1\n]; \n\nbell[\n0\n][\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n// Explicitly fill for j = 0 \n\nbell[i][\n0\n] = bell[i-\n1\n][i-\n1\n]; \n\n\n// Fill for remaining values of j \n\nfor\n(\nint\nj=\n1\n; j<=i; j++) \n\nbell[i][j] = bell[i-\n1\n][j-\n1\n] + bell[i][j-\n1\n]; \n\n} \n\n\nreturn\nbell[n][\n0\n]; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nfor\n(\nint\nn=\n0\n; n<=\n5\n; n++) \n\nSystem.out.println(\n\"Bell Number \"\n+ n + \n\n\" is \"\n+bellNumber(n)); \n\n} \n} \n\n// This code is contributed by Pramod Kumar ", "index": 569, "complexity": 5}
{"back-translation": "import java.util.Scanner;public class q4 {public static void main(String[] args) {Scanner in = new Scanner(System.in);int query = in.nextInt();while (query-- > 0) {int n = in.nextInt();int k = in.nextInt();char[] arr = new char[n];String code = in.next();for (int i = 0; i < n; i++) {arr[i] = code.charAt(i);}int r = 0;int g = 0;int b = 0;for (int i = 0; i < k; i++) {if (i % 3 == 0) {if (arr[i] == 'R') {g++; b++;} else if (arr[i] == 'G') {r++; b++;} else {r++; g++;}} else if (i % 3 == 1) {if (arr[i] == 'G') {g++; b++;} else if (arr[i] == 'B') {r++; b++;} else {r++; g++;}} else {if (arr[i] == 'B') {g++; b++;} else if (arr[i] == 'R') {r++; b++;} else {r++; g++;}}}int rMin = r;int gMin = g;int bMin = b;for (int j = k; j < n; j++) {if ((j % 3 == 0 && arr[j] != 'R') || (j % 3 == 1 && arr[j] != 'G') || (j % 3 == 2 && arr[j] != 'B')) {r++;} if (((j - k) % 3 == 0 && arr[j - k] != 'R') || ((j - k) % 3 == 1 && arr[j - k] != 'G') || ((j - k) % 3 == 2 && arr[j - k] != 'B')) {r--;} rMin = Math.min(r, rMin);if ((j % 3 == 0 && arr[j] != 'G') || (j % 3 == 1 && arr[j] != 'B') || (j % 3 == 2 && arr[j] != 'R')) {g++;} if (((j - k) % 3 == 0 && arr[j - k] != 'G') || ((j - k) % 3 == 1 && arr[j - k] != 'B') || ((j - k) % 3 == 2 && arr[j - k] != 'R')) {g--;} gMin = Math.min(gMin, g);if ((j % 3 == 0 && arr[j] != 'B') || (j % 3 == 1 && arr[j] != 'R') || (j % 3 == 2 && arr[j] != 'G')) {b++;} if (((j - k) % 3 == 0 && arr[j - k] != 'B') || ((j - k) % 3 == 1 && arr[j - k] != 'R') || ((j - k) % 3 == 2 && arr[j - k] != 'G')) {b--;}bMin = Math.min(bMin, b);}System.out.println(Math.min(Math.min(rMin, gMin), bMin));}}}", "src": "//q4\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n\npublic class q4 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        \n        int query = in.nextInt();\n        \n        while (query -- > 0) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            \n            char[] arr = new char[n];\n            //slot all n into char array\n            String code = in.next();\n            for (int i = 0; i < n; i++) {\n                arr[i] = code.charAt(i);\n                \n            }\n            \n            //R, G, B cycle\n            int r = 0;\n            int g = 0;\n            int b = 0;\n            \n            for (int i = 0; i < k; i++) {\n                if (i % 3 == 0) {\n                    if (arr[i] == 'R') {g++; b++;}\n                    else if (arr[i] == 'G') {r++; b++;}\n                    else {r++; g++;} //if is 'B'\n                } else if (i % 3 == 1) {\n                    if (arr[i] == 'G') {g++; b++;}\n                    else if (arr[i] == 'B') {r++; b++;}\n                    else {r++; g++;} //if is 'R'\n                } else { //if mod 3 is 2\n                    if (arr[i] == 'B') {g++; b++;}\n                    else if (arr[i] == 'R') {r++; b++;}\n                    else {r++; g++;} //if is 'G'     \n                }\n            }\n            \n            //starting from kth position, if different then add 1, and check (j-k)th position\n            int rMin = r;\n            int gMin = g;\n            int bMin = b;\n            for (int j = k; j < n; j++) {\n                //R cycle\n                if ((j % 3 == 0 && arr[j] != 'R') ||  \n                    (j % 3 == 1 && arr[j] != 'G') ||\n                    (j % 3 == 2 && arr[j] != 'B')) {\n                    r++;\n                }\n                //R cycle \n                if (((j - k) % 3 == 0 && arr[j - k] != 'R') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'G') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'B')) {\n                    r--;\n                }\n                rMin = Math.min(r, rMin);\n                //G cycle\n                if ((j % 3 == 0 && arr[j] != 'G') ||  \n                    (j % 3 == 1 && arr[j] != 'B') ||\n                    (j % 3 == 2 && arr[j] != 'R')) {\n                    g++;\n                } \n                if (((j - k) % 3 == 0 && arr[j - k] != 'G') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'B') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'R')) {\n                    g--;\n                }      \n                gMin = Math.min(gMin, g);\n                //B cycle\n                if ((j % 3 == 0 && arr[j] != 'B') ||  \n                    (j % 3 == 1 && arr[j] != 'R') ||\n                    (j % 3 == 2 && arr[j] != 'G')) {\n                    b++;\n                }       \n                if (((j - k) % 3 == 0 && arr[j - k] != 'B') ||  \n                    ((j - k) % 3 == 1 && arr[j - k] != 'R') ||\n                    ((j - k) % 3 == 2 && arr[j - k] != 'G')) {\n                    b--;\n                } \n                bMin = Math.min(bMin, b);\n                \n            }\n            \n            System.out.println(Math.min(Math.min(rMin, gMin), bMin));\n            \n        }\n        \n    } \n    \n}", "index": 573, "complexity": 5}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    Scanner in = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n\n    void run() {\n        int q = in.nextInt();\n        for (int i = 0; i < q; i++) {\n            out.println(work());\n        }\n        out.flush();\n    }\n\n    int work() {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        String str = in.next();\n        char[] chs = new char[]{'R', 'G', 'B'};\n        int c1 = 0, c2 = 0, c3 = 0;\n        int ret = 99999999;\n        for (int i = 0, p1 = 0, p2 = 1, p3 = 2; i < n; i++, p1 = (p1 + 1) % 3, p2 = (p2 + 1) % 3, p3 = (p3 + 1) % 3) {\n            char ch = str.charAt(i);\n            if (ch != chs[p1]) {\n                c1++;\n            }\n            if (i >= k) {\n                char pre1 = str.charAt(i - k);\n                char pre2 = chs[((p1 - (k % 3)) + 3) % 3];\n                if (pre1 != pre2) {\n                    c1--;\n                }\n            }\n            if (i + 1 >= k) {\n                ret = Math.min(ret, c1);\n            }\n\n            if (ch != chs[p2]) {\n                c2++;\n            }\n            if (i >= k) {\n                char pre1 = str.charAt(i - k);\n                char pre2 = chs[((p2 - (k % 3)) + 3) % 3];\n                if (pre1 != pre2) {\n                    c2--;\n                }\n            }\n            if (i + 1 >= k) {\n                ret = Math.min(ret, c2);\n            }\n\n            if (ch != chs[p3]) {\n                c3++;\n            }\n            if (i >= k) {\n                char pre1 = str.charAt(i - k);\n                char pre2 = chs[((p3 - (k % 3)) + 3) % 3];\n                if (pre1 != pre2) {\n                    c3--;\n                }\n            }\n            if (i + 1 >= k) {\n                ret = Math.min(ret, c3);\n            }\n        }\n        return ret;\n    }\n}\n", "src": "import java.util.*;\nimport java.io.*;\n \npublic class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\t\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tvoid run(){\n\t    int q=in.nextInt();\n\t    for(int i=0;i<q;i++){\n\t        out.println(work());\n\t    }\n\t    out.flush();\n\t}\n\tint work() {\t\t\n\t\tint n=in.nextInt();\n\t    int k=in.nextInt();\n\t    String str=in.next();\n\t    char[] chs=new char[]{'R','G','B'};\n\t    int c1=0,c2=0,c3=0;\n\t    int ret=99999999;\n\t    for(int i=0,p1=0,p2=1,p3=2;i<n;i++,p1=(p1+1)%3,p2=(p2+1)%3,p3=(p3+1)%3){\n\t        char ch=str.charAt(i);\n\t        //c1\n\t        if(ch!=chs[p1]){\n\t            c1++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p1-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c1--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c1);\n\t        }\n\t        \n\t        //c2\n\t        if(ch!=chs[p2]){\n\t            c2++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p2-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c2--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c2);\n\t        }\n\t        \n\t        //c3\n\t        if(ch!=chs[p3]){\n\t            c3++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p3-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c3--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c3);\n\t        }\n\t    } \n\t    return ret;\n\t   \n\t}\n}\n", "index": 576, "complexity": 5}
{"back-translation": "import java.io.*;\nimport java.lang.*;\npublic class CF1003E{\n    public static void main(String args[]) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int d = Integer.parseInt(s[1]);\n        int k = Integer.parseInt(s[2]);\n        StringBuffer sb = new StringBuffer();\n        int[] rem = new int[n];\n        int[] deg = new int[n];\n        int i = 0;\n        if(k == 1){\n            if(n <= 2){\n\n            }else{\n                System.out.println(\"NO\");\n                return;\n            }\n        }\n        for(i=0;i<d;i++){\n            if(i>=n-1){\n                System.out.println(\"NO\");\n                return;\n            }\n            sb.append((i+1) +\" \" + (i+2)+\"\\n\");\n            rem[i] = Math.min(i, d-i);\n            deg[i]++;\n            if(i+1<n)\n                deg[i+1]++;\n        }\n        if(i<n){\n            rem[i] = 0;\n            deg[i] = 1;\n        }\n        i++;\n        int j  = 0;\n        for(;i<n;i++){\n            while(true){\n                if(j>=n){\n                    System.out.println(\"NO\");\n                    return;\n                }\n                if(rem[j] > 0 && deg[j]<k){\n                    deg[j]++;\n                    rem[i] = rem[j] - 1;\n                    sb.append((j+1)+\" \"+(i+1)+\"\\n\");\n                    deg[i]++;\n                    break;\n                }else{\n                    j++;\n                }\n            }\n        }\n        System.out.println(\"YES\");\n        System.out.println(sb);\n    }\n}\n", "src": "import java.io.*;\nimport java.lang.*;\npublic class CF1003E{\n    public static void main(String args[]) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int d = Integer.parseInt(s[1]);\n        int k = Integer.parseInt(s[2]);\n        StringBuffer sb = new StringBuffer();\n        int[] rem = new int[n];\n        int[] deg = new int[n];\n        int i = 0;\n        if(k == 1){\n            if(n <= 2){\n\n            }else{\n                System.out.println(\"NO\");\n                return;\n            }\n        }\n        for(i=0;i<d;i++){\n            if(i>=n-1){\n                System.out.println(\"NO\");\n                return;\n            }\n            sb.append((i+1) +\" \" + (i+2)+\"\\n\");\n            rem[i] = Math.min(i, d-i);\n            deg[i]++;\n            if(i+1<n)\n            deg[i+1]++;\n        }\n        if(i<n){\n            rem[i] = 0;\n            deg[i] = 1;\n        }\n        i++;\n        int j  = 0;\n        for(;i<n;i++){\n            //For all remaining Nodes\n            while(true){\n                if(j>=n){\n                    System.out.println(\"NO\");\n                    return;\n                }\n                if(rem[j] > 0 && deg[j]<k){\n                    deg[j]++;\n                    rem[i] = rem[j] - 1;\n                    sb.append((j+1)+\" \"+(i+1)+\"\\n\");\n                    deg[i]++;\n                    break;\n                }else{\n                    j++;\n                }\n            }\n        }\n        System.out.println(\"YES\");\n        System.out.println(sb);\n    }\n}\n", "index": 577, "complexity": 5}
{"back-translation": "import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.util.Arrays;import java.io.BufferedWriter;import java.io.Writer;import java.io.OutputStreamWriter;import java.util.InputMismatchException;import java.io.IOException;import java.io.InputStream; public class Main {public static void main(String[] args) {InputStream inputStream = System.in;OutputStream outputStream = System.out;InputReader in = new InputReader(inputStream);OutputWriter out = new OutputWriter(outputStream);TaskC solver = new TaskC();solver.solve(1, in, out);out.close();} static class TaskC {public void solve(int testNumber, InputReader in, OutputWriter out) {final int SIZE = 256;final int UNDEF = -1;int nPixels = in.nextInt();int groupSize = in.nextInt();int[] a = in.nextIntArray(nPixels);boolean[] exists = new boolean[SIZE];int[] left = new int[SIZE];int[] right = new int[SIZE];int[] ret = new int[nPixels];Arrays.fill(ret, UNDEF);for (int i = 0; i < nPixels; i++) {for (int p = 0; p < SIZE; p++) {if (exists[p] && left[p] <= a[i] && a[i] <= right[p]) {ret[i] = left[p];left[a[i]] = left[p];right[a[i]] = right[p];break;}}if (ret[i] == UNDEF) {int l = Math.max(a[i] - groupSize + 1, 0);int r = l + groupSize - 1;for (int p = a[i] - 1; p >= 0; p--) {if (exists[p]) {if (p >= l) {int d = p - l;l = p + 1;r += d + 1;}if (right[p] >= l) {right[p] = l - 1;}}}for (int p = a[i] + 1; p < SIZE; p++) {if (exists[p] && left[p] <= r) {r = left[p] - 1;}}left[a[i]] = l;right[a[i]] = r;ret[i] = l;}exists[a[i]] = true;}out.print(ret);}} static class OutputWriter {private final PrintWriter writer; public OutputWriter(OutputStream outputStream) {writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));} public OutputWriter(Writer writer) {this.writer = new PrintWriter(writer);} public void print(int[] array) {for (int i = 0; i < array.length; i++) {if (i != 0) {writer.print(' ');}writer.print(array[i]);}} public void close() {writer.close();}} static class InputReader {private InputStream stream;private byte[] buf = new byte[1024];private int curChar;private int numChars;private InputReader.SpaceCharFilter filter; public InputReader(InputStream stream) {this.stream = stream;} public int read() {if (numChars == -1) {throw new InputMismatchException();}if (curChar >= numChars) {curChar = 0;try {numChars = stream.read(buf);} catch (IOException e) {throw new InputMismatchException();}if (numChars <= 0) {return -1;}}return buf[curChar++];} public int nextInt() {int c = read();while (isSpaceChar(c)) {c = read();}int sgn = 1;if (c == '-') {sgn = -1;c = read();}int res = 0;do {if (c < '0' || c > '9') {throw new InputMismatchException();}res *= 10;res += c - '0';c = read();} while (!isSpaceChar(c));return res * sgn;} public boolean isSpaceChar(int c) {if (filter != null) {return filter.isSpaceChar(c);}return isWhitespace(c);} public static boolean isWhitespace(int c) {return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;} public int[] nextIntArray(int n) {int[] array = new int[n];for (int i = 0; i < n; ++i) array[i] = nextInt();return array;} public interface SpaceCharFilter {public boolean isSpaceChar(int ch);}}}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author gaidash\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            final int SIZE = 256;\n            final int UNDEF = -1;\n\n            int nPixels = in.nextInt();\n            int groupSize = in.nextInt();\n            int[] a = in.nextIntArray(nPixels);\n            boolean[] exists = new boolean[SIZE];\n            int[] left = new int[SIZE];\n            int[] right = new int[SIZE];\n            int[] ret = new int[nPixels];\n            Arrays.fill(ret, UNDEF);\n\n            for (int i = 0; i < nPixels; i++) {\n                for (int p = 0; p < SIZE; p++) {\n                    if (exists[p] && left[p] <= a[i] && a[i] <= right[p]) {\n                        ret[i] = left[p];\n                        left[a[i]] = left[p];\n                        right[a[i]] = right[p];\n                        break;\n                    }\n                }\n                if (ret[i] == UNDEF) {\n                    int l = Math.max(a[i] - groupSize + 1, 0);\n                    int r = l + groupSize - 1;\n                    for (int p = a[i] - 1; p >= 0; p--) {\n                        if (exists[p]) {\n                            if (p >= l) {\n                                int d = p - l;\n                                l = p + 1;\n                                r += d + 1;\n                            }\n                            if (right[p] >= l) {\n                                right[p] = l - 1;\n                            }\n                        }\n                    }\n                    for (int p = a[i] + 1; p < SIZE; p++) {\n                        if (exists[p] && left[p] <= r) {\n                            r = left[p] - 1;\n                        }\n                    }\n                    left[a[i]] = l;\n                    right[a[i]] = r;\n                    ret[i] = l;\n                }\n                exists[a[i]] = true;\n            }\n//        for (int p : a) {\n//            System.out.println(\"Segment for pixel \" + p + \" = \" + \"(\" + left[p] + \" , \" + right[p] + \")\");\n//        }\n\n            out.print(ret);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "index": 578, "complexity": 5}
{"back-translation": "public class CountKSubStr { public int countkDist(String str, int k) { int res = 0; int n = str.length(); int[] cnt = new int[26]; for (int i = 0; i < n; i++) { int dist_count = 0; Arrays.fill(cnt, 0); for (int j = i; j < n; j++) { if (cnt[str.charAt(j) - 'a'] == 0) dist_count++; cnt[str.charAt(j) - 'a']++; if (dist_count == k) res++; } } return res; } public static void main(String[] args) { CountKSubStr ob = new CountKSubStr(); String ch = \"abcbaa\"; int k = 3; System.out.println(\"Total substrings with exactly \" + k + \" distinct characters : \" + ob.countkDist(ch, k)); } }", "src": "\n// Java program to CountKSubStr number of substrings \n// with exactly distinct characters in a given string \nimport\njava.util.Arrays; \n\npublic\nclass\nCountKSubStr \n{ \n\n// Function to count number of substrings \n\n// with exactly k unique characters \n\nint\ncountkDist(String str, \nint\nk) \n\n{ \n\n// Initialize result \n\nint\nres = \n0\n; \n\n\nint\nn = str.length(); \n\n\n// To store count of characters from 'a' to 'z' \n\nint\ncnt[] = \nnew\nint\n[\n26\n]; \n\n\n// Consider all substrings beginning with \n\n// str[i] \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndist_count = \n0\n; \n\n\n// Initializing count array with 0 \n\nArrays.fill(cnt, \n0\n); \n\n\n// Consider all substrings between str[i..j] \n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\n// If this is a new character for this \n\n// substring, increment dist_count. \n\nif\n(cnt[str.charAt(j) - \n'a'\n] == \n0\n) \n\ndist_count++; \n\n\n// Increment count of current character \n\ncnt[str.charAt(j) - \n'a'\n]++; \n\n\n// If distinct character count becomes k, \n\n// then increment result. \n\nif\n(dist_count == k) \n\nres++; \n\n} \n\n} \n\n\nreturn\nres; \n\n} \n\n\n// Driver Program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountKSubStr ob = \nnew\nCountKSubStr(); \n\nString ch = \n\"abcbaa\"\n; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Total substrings with exactly \"\n+ \n\nk + \n\" distinct characters : \"\n\n+ ob.countkDist(ch, k)); \n\n} \n} ", "index": 579, "complexity": 5}
{"back-translation": "class Sequences { static int getTotalNumberOfSequences(int m, int n) { int T[][] = new int[m + 1][n + 1]; for (int i = 0; i < m + 1; i++) { for (int j = 0; j < n + 1; j++) { if (i == 0 || j == 0) T[i][j] = 0; else if (i < j) T[i][j] = 0; else if (j == 1) T[i][j] = i; else T[i][j] = T[i - 1][j] + T[i / 2][j - 1]; } } return T[m][n]; } public static void main(String[] args) { int m = 10; int n = 4; System.out.println(\"Total number of possible sequences \" + getTotalNumberOfSequences(m, n)); } }", "src": "\n// Efficient java program to count total number \n// of special sequences of length n where \nclass\nSequences \n{ \n\n// DP based function to find the number of special \n\n// sequences \n\nstatic\nint\ngetTotalNumberOfSequences(\nint\nm, \nint\nn) \n\n{ \n\n// define T and build in bottom manner to store \n\n// number of special sequences of length n and \n\n// maximum value m \n\nint\nT[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\nfor\n(\nint\ni=\n0\n; i<m+\n1\n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<n+\n1\n; j++) \n\n{ \n\n// Base case : If length of sequence is 0 \n\n// or maximum value is 0, there cannot \n\n// exist any special sequence \n\nif\n(i == \n0\n|| j == \n0\n) \n\nT[i][j] = \n0\n; \n\n\n// if length of sequence is more than \n\n// the maximum value, special sequence \n\n// cannot exist \n\nelse\nif\n(i < j) \n\nT[i][j] = \n0\n; \n\n\n// If length of sequence is 1 then the \n\n// number of special sequences is equal \n\n// to the maximum value \n\n// For example with maximum value 2 and \n\n// length 1, there can be 2 special \n\n// sequences {1}, {2} \n\nelse\nif\n(j == \n1\n) \n\nT[i][j] = i; \n\n\n// otherwise calculate \n\nelse\n\nT[i][j] = T[i-\n1\n][j] + T[i/\n2\n][j-\n1\n]; \n\n} \n\n} \n\nreturn\nT[m][n]; \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nm = \n10\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(\n\"Total number of possible sequences \"\n+ \n\ngetTotalNumberOfSequences(m, n)); \n\n} \n} ", "index": 580, "complexity": 5}
{"back-translation": "class Node {\n    int data;\n    Node left, right, nextRight;\n\n    Node(int item) {\n        data = item;\n        left = right = nextRight = null;\n    }\n}\n\nclass BinaryTree {\n    Node root;\n\n    int sum(Node node) {\n        if (node == null)\n            return 0;\n\n        return sum(node.left) + node.data + sum(node.right);\n    }\n\n    int isSumTree(Node node) {\n        int ls, rs;\n\n        if ((node == null) || (node.left == null && node.right == null))\n            return 1;\n\n        ls = sum(node.left);\n        rs = sum(node.right);\n\n        if ((node.data == ls + rs) && (isSumTree(node.left) != 0) && (isSumTree(node.right) != 0))\n            return 1;\n\n        return 0;\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n\n        tree.root = new Node(26);\n        tree.root.left = new Node(10);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(4);\n        tree.root.left.right = new Node(6);\n        tree.root.right.right = new Node(3);\n\n        if (tree.isSumTree(tree.root) != 0)\n            System.out.println(\"The given tree is a sum tree\");\n        else\n            System.out.println(\"The given tree is not a sum tree\");\n    }\n}", "src": "\n// Java program to check if Binary tree is sum tree or not \n\n/* A binary tree node has data, left child and right child */\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right, nextRight; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = nextRight = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n/* A utility function to get the sum of values in tree with root \n\nas root */\n\nint\nsum(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nreturn\nsum(node.left) + node.data + sum(node.right); \n\n} \n\n\n/* returns 1 if sum property holds for the given \n\nnode and both of its children */\n\nint\nisSumTree(Node node) \n\n{ \n\nint\nls, rs; \n\n\n/* If node is NULL or it's a leaf node then \n\nreturn true */\n\nif\n((node == \nnull\n) || (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n1\n; \n\n\n/* Get sum of nodes in left and right subtrees */\n\nls = sum(node.left); \n\nrs = sum(node.right); \n\n\n/* if the node and both of its children satisfy the \n\nproperty return 1 else 0*/\n\nif\n((node.data == ls + rs) && (isSumTree(node.left) != \n0\n) \n\n&& (isSumTree(node.right)) != \n0\n) \n\nreturn\n1\n; \n\n\nreturn\n0\n; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n26\n); \n\ntree.root.left = \nnew\nNode(\n10\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n3\n); \n\n\nif\n(tree.isSumTree(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree is a sum tree\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree is not a sum tree\"\n); \n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 581, "complexity": 5}
{"back-translation": "import java.util.*; class GFG { static boolean isPresent(List<Integer> B, int x) { for (int i = 0; i < B.size(); i++) { if (B.get(i) == x) return true; } return false; } static int findMaxSubarraySumUtil(List<Integer> A, List<Integer> B) { int max_so_far = -2147483648, curr_max = 0; for (int i = 0; i < A.size(); i++) { if (isPresent(B, A.get(i))) { curr_max = 0; continue; } curr_max = Math.max(A.get(i), curr_max + A.get(i)); max_so_far = Math.max(max_so_far, curr_max); } return max_so_far; } static void findMaxSubarraySum(List<Integer> A, List<Integer> B) { int maxSubarraySum = findMaxSubarraySumUtil(A, B); if (maxSubarraySum == -2147483648) { System.out.println(\"Maximum Subarray Sum can't be found\"); } else { System.out.println(\"The Maximum Subarray Sum = \" + maxSubarraySum); } } public static void main(String[] args) { List<Integer> A = Arrays.asList(3, 4, 5, -4, 6); List<Integer> B = Arrays.asList(1, 8, 5); findMaxSubarraySum(A, B); } }", "src": "\n// Java Program to find max subarray \n// sum excluding some elements \nimport\njava.io.*; \n\nclass\nGFG { \n\n\n// Function to check the element \n\n// present in array B \n\nstatic\nboolean\nisPresent(\nint\nB[], \n\nint\nm, \n\nint\nx) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(B[i] == x) \n\nreturn\ntrue\n; \n\n\nreturn\nfalse\n; \n\n} \n\n\n// Utility function for findMaxSubarraySum() \n\n// with the following parameters \n\n// A => Array A, \n\n// B => Array B, \n\n// n => Number of elements in Array A, \n\n// m => Number of elements in Array B \n\nstatic\nint\nfindMaxSubarraySumUtil(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n// set max_so_far to INT_MIN \n\nint\nmax_so_far = -\n2147483648\n, curr_max = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// if the element is present in B, \n\n// set current max to 0 and move to \n\n// the next element \n\nif\n(isPresent(B, m, A[i])) { \n\ncurr_max = \n0\n; \n\ncontinue\n; \n\n} \n\n\n// Proceed as in Kadane's Algorithm \n\ncurr_max = Math.max(A[i], curr_max + A[i]); \n\nmax_so_far = Math.max(max_so_far, curr_max); \n\n} \n\nreturn\nmax_so_far; \n\n} \n\n\n// Wrapper for findMaxSubarraySumUtil() \n\nstatic\nvoid\nfindMaxSubarraySum(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\nint\nmaxSubarraySum = findMaxSubarraySumUtil(A, B, \n\nn, m); \n\n\n// This case will occour when all \n\n// elements of A are are present \n\n// in B, thus no subarray can be formed \n\nif\n(maxSubarraySum == -\n2147483648\n) { \n\nSystem.out.println(\n\"Maximum Subarray Sum\"\n\n+ \n\" \"\n+ \n\"can't be found\"\n); \n\n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"The Maximum Subarray Sum = \"\n\n+ maxSubarraySum); \n\n} \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\nA[] = { \n3\n, \n4\n, \n5\n, -\n4\n, \n6\n}; \n\nint\nB[] = { \n1\n, \n8\n, \n5\n}; \n\n\nint\nn = A.length; \n\nint\nm = B.length; \n\n\n// Calling Function \n\nfindMaxSubarraySum(A, B, n, m); \n\n} \n} \n\n// This code is contributed by Ajit. ", "index": 582, "complexity": 5}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E solver = new E();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.ni(), K = in.ni();\n            long mod = 998244353;\n            long[][] dp = new long[n + 1][n + 1];\n            for (int lim = 1; lim <= n; lim++) {\n                long sum = 1;\n                dp[0][lim] = 1;\n                for (int i = 1; i <= n; i++) {\n                    dp[i][lim] = (dp[i][lim] + sum) % mod;\n                    sum = (sum + dp[i][lim]) % mod;\n                    if (i >= lim)\n                        sum = (sum - dp[i - lim][lim] + mod) % mod;\n                }\n            }\n            long ans = 0;\n            for (int k = 1; k < Math.min(K, n + 1); k++) {\n                long h = dp[n][k] - dp[n][k - 1];\n                int lim = K / k;\n                if (K % k == 0)\n                    lim--;\n                if (lim > n)\n                    lim = n;\n                ans += dp[n][lim] * h % mod;\n            }\n            out.println(2 * ans % mod);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n    }\n}\n", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E solver = new E();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.ni(), K = in.ni();\n            long mod = 998244353;\n            long[][] dp = new long[n + 1][n + 1];\n            for (int lim = 1; lim <= n; lim++) {\n                long sum = 1;\n                dp[0][lim] = 1;\n                for (int i = 1; i <= n; i++) {\n                    dp[i][lim] = (dp[i][lim] + sum) % mod;\n                    sum = (sum + dp[i][lim]) % mod;\n                    if (i >= lim)\n                        sum = (sum - dp[i - lim][lim] + mod) % mod;\n                }\n            }\n            long ans = 0;\n            for (int k = 1; k < Math.min(K, n + 1); k++) {\n                long h = dp[n][k] - dp[n][k - 1];\n                int lim = K / k;\n                if (K % k == 0)\n                    lim--;\n                if (lim > n)\n                    lim = n;\n                ans += dp[n][lim] * h % mod;\n            }\n            out.println(2 * ans % mod);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n    }\n}\n\n", "index": 583, "complexity": 5}
{"back-translation": "import java.util.Arrays; public class MaxSum { static int maxSum(int[] arr, int n) { int sum = 0; Arrays.sort(arr); for (int i = 0; i < n / 2; i++) { sum -= (2 * arr[i]); sum += (2 * arr[n - i - 1]); } return sum; } public static void main(String[] args) { int[] arr = { 4, 2, 1, 8 }; int n = arr.length; System.out.println(maxSum(arr, n)); } }", "src": "\n// Java program to maximize the sum of difference \n// between consecutive elements in circular array \nimport\njava.io.*; \nimport\njava.util.Arrays; \n\nclass\nMaxSum \n{ \n\n// Return the maximum Sum of difference between \n\n// consecutive elements. \n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n; \n\n\n// Sorting the array. \n\nArrays.sort(arr); \n\n\n// Subtracting a1, a2, a3,....., a(n/2)-1, \n\n// an/2 twice and adding a(n/2)+1, a(n/2)+2, \n\n// a(n/2)+3,....., an - 1, an twice. \n\nfor\n(\nint\ni = \n0\n; i < n/\n2\n; i++) \n\n{ \n\nsum -= (\n2\n* arr[i]); \n\nsum += (\n2\n* arr[n - i - \n1\n]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n// Driver Program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n4\n, \n2\n, \n1\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n\n} \n} \n/*This code is contributed by Prakriti Gupta*/", "index": 585, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\nclass GFG {\n\n    static int minElements(int arr[], int n) {\n        int halfSum = 0;\n        for (int i = 0; i < n; i++)\n            halfSum = halfSum + arr[i];\n        halfSum = halfSum / 2;\n\n        Arrays.sort(arr);\n\n        int res = 0, curr_sum = 0;\n\n        for (int i = n-1; i >= 0; i--) {\n            curr_sum += arr[i];\n            res++;\n\n            if (curr_sum > halfSum)\n                return res;\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {3, 1, 7, 1};\n        int n = arr.length;\n        System.out.println(minElements(arr, n));\n    }\n}", "src": "\n// Java code to find minimum number of elements \n// such that their sum is greater than sum of \n// remaining elements of the array. \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Function to find minimum elements needed \n\nstatic\nint\nminElements(\nint\narr[], \nint\nn) \n\n{ \n\n// Calculating HALF of array sum \n\nint\nhalfSum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nhalfSum = halfSum + arr[i]; \n\nhalfSum = halfSum / \n2\n; \n\n\n\n// Sort the array in ascending order and \n\n// start traversing array from the ascending \n\n// sort in descending order. \n\nArrays.sort(arr); \n\n\nint\nres = \n0\n, curr_sum = \n0\n; \n\nfor\n(\nint\ni = n-\n1\n; i >= \n0\n; i--) { \n\n\ncurr_sum += arr[i]; \n\nres++; \n\n\n// Current sum greater than sum \n\nif\n(curr_sum > halfSum) \n\nreturn\nres; \n\n} \n\nreturn\nres; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n3\n, \n1\n, \n7\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(minElements(arr, n)); \n\n} \n\n} \n\n// This code is contributed by Gitanjali ", "index": 587, "complexity": 4}
{"back-translation": "ERROR", "src": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.util.Map.*;\npublic class codeforces {\n     static int count =0;\n     static boolean f=false;\n     static int [] arr;\n\tstatic \tPrintWriter pw=new PrintWriter(System.out);\n\tstatic void solve(int index , int mask) {\n\t\tif(index==arr.length) {\n\t\t\tint sum1=0; int sum2=0;\n\t\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\t\tif((mask & 1<<i)!=0) sum1+=arr[i];\n\t\t\t\t\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsolve(index+1, mask | 1<<index);\n\t\tsolve(index+1, mask);\n\t}\n\tpublic static void main(String [] args) throws IOException, InterruptedException {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint x=sc.nextInt();\n\t\tint y=sc.nextInt();\n\t\tpair [] arr=new pair[x];\n\t\tfor(int i=0;i<x;i++) arr[i]=new pair(i, sc.nextInt(),0);\n\t\tfor(int i=0;i<x;i++) arr[i].y=sc.nextInt();\n\t\tArrays.sort(arr);\n\t\tPriorityQueue<Integer> qq=new PriorityQueue<>();\n\t\t//pw.println(Arrays.toString(arr));\n\t\tLong [] list=new Long [x];\n\t\tlong sum=0; \n\t\tfor(int i=0;i<x;i++) {\n\t\t\tpair w=arr[i];\n\t\t\tif(qq.size()<y) {\n\t\t\t\tqq.add(w.y);\n\t\t\t\tsum+=w.y;\n\t\t\t\tlist[w.i]=sum;\n\n\t\t\t}else if(!qq.isEmpty()) {\n\t\t\t\tsum+=w.y;\n\t\t\t\tlist[w.i]=sum;\n\t\t\t\tint first=qq.poll();\n\t\t\t\tif(w.y>first) {\n\t\t\t\t\tsum-=first;\n\t\t\t\t\tqq.add(w.y);\n\t\t\t\t}else {\n\t\t\t\t\tqq.add(first);\n\t\t\t\t\tsum-=w.y;\n\t\t\t\t}\n\t\t\t} else list[w.i]=(long) w.y;\n\t\t\t//pw.println(qq);\n\t\t}\n\t\tfor(Long w:list) pw.print(w+\" \"); \n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\t\n\tstatic class pair implements Comparable<pair>{\n\t\tString  name; int x,y,i ;\n\t\tpublic pair(String name , int x) {\n\t\t\tthis.name=name; this.x=x;\n\t\t}\n\t\t\n\t\tpublic pair (int i,int x,int y) {\n\t\t\tthis.i=i; this.x=x; this.y=y; \n\t\t}\n\t\tpublic int compareTo(pair o) {\n\t\t\treturn x-o.x;\n\t\t}\n\t\tpublic int compareTo1(pair o) {\n\t\t\tif(!name.equals(o.name))\n\t\t\t\treturn name.compareTo(o.name);\n\t\t\treturn x-o.x;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn i+\" \"+x+\" \"+y;\n\t\t}\n\t}\n\n   static class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n\t}", "index": 589, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader\n    {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card\n    {\n        int l;\n        int r;\n        public card(int ch, int i)\n        {\n            this.l = ch;\n            this.r = i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1, card o2)\n        {\n            if (o1.l != o2.l)\n                return (int) (o1.l - o2.l);\n            else\n                return (int) (o1.r - o2.r);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l = new ArrayList<>();\n        for (int i = 0; i < a.length; i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n    static boolean valid(int i, int j, int n, int m)\n    {\n        if (i < n && i >= 0 && j < m && j >= 0)\n            return true;\n        else\n            return false;\n    }\n    public static void main(String[] args)\n    {\n        InputReader sc = new InputReader(System.in);\n        int n = sc.nextInt();\n        int s = sc.nextInt();\n        card c[] = new card[n];\n        for (int i = 0; i < n; i++)\n        {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            c[i] = new card(x, y);\n        }\n        Arrays.sort(c, new sort());\n        int time = 0;\n        for (int i = n - 1; i >= 0; i--)\n        {\n            time += s - c[i].l;\n            if ((c[i].r - time) > 0)\n                time += c[i].r - time;\n            s = c[i].l;\n        }\n        if (c[0].l != 0)\n            time += c[0].l;\n        System.out.println(time);\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        int l;\n        int r;\n        public card(int ch,int i)\n        {\n            this.l=ch;\n            this.r=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (int)(o1.l-o2.l);\n            else\n                return (int)(o1.r-o2.r);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    /*static long gcd(long a,long b)\n    {\n    if(b==0)\n    return a;\n    else\n    return gcd(b,a%b);\n    }\n    static int ans1=Integer.MAX_VALUE,ans2=Integer.MAX_VALUE,ans3=Integer.MAX_VALUE,ans4=Integer.MAX_VALUE;\n    static boolean v[]=new boolean[101];\n    static void dfs(Integer so,Set<Integer> s[]){\n    if(!v[so.intValue()])\n    {\n    v[so]=true;\n    for(Integer h:s[so.intValue()])\n    {\n    if(!v[h.intValue()])\n    dfs(h,s);\n    }\n    }\n    }\n    static class Print{\n    public PrintWriter out;\n    Print(OutputStream o)\n    {\n    out=new PrintWriter(o);\n    }\n    }\n    static int CeilIndex(int A[], int l, int r, int key) \n    { \n    while (r - l > 1) { \n    int m = l + (r - l) / 2; \n    if (A[m] >= key) \n    r = m; \n    else\n    l = m; \n    } \n\n    return r; \n    } \n\n    static int LongestIncreasingSubsequenceLength(int A[], int size) \n    { \n    // Add boundary case, when array size is one \n    int[] tailTable = new int[size]; \n    int len; // always points empty slot \n    tailTable[0] = A[0]; \n    len = 1; \n    for (int i = 1; i < size; i++) { \n    if (A[i] < tailTable[0]) \n    // new smallest value \n    tailTable[0] = A[i]; \n\n    else if (A[i] > tailTable[len - 1]) \n    // A[i] wants to extend largest subsequence \n    tailTable[len++] = A[i]; \n\n    else\n    // A[i] wants to be current end candidate of an existing \n    // subsequence. It will replace ceil value in tailTable \n    tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]; \n    } \n    return len; \n    }*/\n    /*static int binary(int n)\n    {\n    int s=1;\n    while(n>0)\n    {\n    s=s<<1;\n    n--;\n    }\n    return s-1;\n    }\n    static StringBuilder bin(int i,int n)\n    {\n    StringBuilder s=new StringBuilder();\n    while(i>0)\n    {\n    s.append(i%2);\n    i=i/2;\n    }\n    while(s.length()!=n)\n    {\n    s.append(0);\n    }\n    return s.reverse();\n    }*/\n    static boolean valid(int i,int j,int n,int m)\n    {\n        if(i<n && i>=0 && j<m && j>=0)\n            return true;\n        else\n            return false;\n    }\n\n    public static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        int s=sc.nextInt();\n        card c[]=new card[n];\n        for(int i=0;i<n;i++)\n        {\n            int x=sc.nextInt();\n            int y=sc.nextInt();\n            c[i]=new card(x,y);\n        }\n        Arrays.sort(c,new sort());\n        int time=0;\n        for(int i=n-1;i>=0;i--)\n        {\n            time+=s-c[i].l;\n            if((c[i].r-time)>0)\n            time+=c[i].r-time;\n            s=c[i].l;\n        }\n        if(c[0].l!=0)\n        time+=c[0].l;\n        System.out.println(time);\n    }\n}", "index": 590, "complexity": 4}
{"back-translation": "import java.util.*; import java.lang.*; import java.io.*; class ActivitySelection { public static void printMaxActivities(int[] s, int[] f, int n){ int i, j; System.out.print(\"Following activities are selected : \"); i = 0; System.out.print(i + \" \"); for(j = 1; j < n; j++){ if(s[j] >= f[i]){ System.out.print(j + \" \"); i = j; } } } public static void main(String[] args){ int[] s = {1, 3, 0, 5, 8, 5}; int[] f = {2, 4, 6, 7, 9, 9}; int n = s.length; printMaxActivities(s, f, n); } }", "src": "\n// The following implementation assumes that the activities \n// are already sorted according to their finish time \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nActivitySelection \n{ \n\n// Prints a maximum set of activities that can be done by a single \n\n// person, one at a time. \n\n// n --> Total number of activities \n\n// s[] --> An array that contains start time of all activities \n\n// f[] --> An array that contains finish time of all activities \n\npublic\nstatic\nvoid\nprintMaxActivities(\nint\ns[], \nint\nf[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\nSystem.out.print(\n\"Following activities are selected : n\"\n); \n\n\n// The first activity always gets selected \n\ni = \n0\n; \n\nSystem.out.print(i+\n\" \"\n); \n\n\n// Consider rest of the activities \n\nfor\n(j = \n1\n; j < n; j++) \n\n{ \n\n// If this activity has start time greater than or \n\n// equal to the finish time of previously selected \n\n// activity, then select it \n\nif\n(s[j] >= f[i]) \n\n{ \n\nSystem.out.print(j+\n\" \"\n); \n\ni = j; \n\n} \n\n} \n\n} \n\n\n// driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ns[] = {\n1\n, \n3\n, \n0\n, \n5\n, \n8\n, \n5\n}; \n\nint\nf[] = {\n2\n, \n4\n, \n6\n, \n7\n, \n9\n, \n9\n}; \n\nint\nn = s.length; \n\n\nprintMaxActivities(s, f, n); \n\n} \n\n} ", "index": 591, "complexity": 4}
{"back-translation": "import java.util.Arrays;\n\nclass GFG {\n\nstatic void rearrangeArray(int[] arr, int n) {\nArrays.sort(arr);\nint[] tempArr = new int[n];\nint ArrIndex = 0;\nfor (int i = 0, j = n-1; i <= n / 2 || j > n / 2; i++, j--) {\nif (ArrIndex < n) {\ntempArr[ArrIndex] = arr[i];\nArrIndex++;\n}\nif (ArrIndex < n) {\ntempArr[ArrIndex] = arr[j];\nArrIndex++;\n}\n}\nfor (int i = 0; i < n; i++) {\narr[i] = tempArr[i];\n}\n}\n\npublic static void main(String args[]) {\nint[] arr = {5, 8, 1, 4, 2, 9, 3, 7, 6};\nint n = arr.length;\nrearrangeArray(arr, n);\nfor (int i = 0; i < n; i++) {\nSystem.out.print(arr[i]+\" \");\n}\n}\n}", "src": "\n// Java program to print the array in given order \nimport\njava.util.Arrays; \n\npublic\nclass\nGFG { \n\n\n// Function which arrange the array. \n\nstatic\nvoid\nrearrangeArray(\nint\narr[], \nint\nn) \n\n{ \n\n// Sorting the array elements \n\nArrays.sort(arr); \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n// To store modified array \n\n\n// Adding numbers from sorted array to \n\n// new array accordingly \n\nint\nArrIndex = \n0\n; \n\n\n// Traverse from begin and end simultaneously \n\nfor\n(\nint\ni = \n0\n, j = n-\n1\n; i <= n / \n2\n|| j > n / \n2\n; \n\ni++, j--) { \n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[i]; \n\nArrIndex++; \n\n} \n\n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[j]; \n\nArrIndex++; \n\n} \n\n} \n\n\n// Modifying original array \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = tempArr[i]; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n5\n, \n8\n, \n1\n, \n4\n, \n2\n, \n9\n, \n3\n, \n7\n, \n6\n}; \n\nint\nn = arr.length; \n\nrearrangeArray(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n} \n// This code is contributed by Sumit Ghosh ", "index": 592, "complexity": 4}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static BufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer tok;\n    \n    static boolean hasNext() {\n        while(tok==null||!tok.hasMoreTokens()) {\n            try {\n                tok=new StringTokenizer(in.readLine());\n            } catch(Exception e) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    static String next() {\n        hasNext();\n        return tok.nextToken();\n    }\n    \n    static long nextLong() {\n        return Long.parseLong(next());\n    }\n    \n    static int nextInt() {\n        return Integer.parseInt(next());\n    }\n    \n    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) {\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        map.put(0, 1);\n        int n = nextInt();\n        int m = nextInt();\n        int index = -1;\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n            if (a[i] == m)\n                index = i;\n        }\n        int sum = 0;\n        for (int i = 0; i < index; i++) {\n            if (a[i] < m)\n                sum--;\n            else\n                sum++;\n            if (map.containsKey(sum)) {\n                map.put(sum, map.get(sum) + 1);\n            } else {\n                map.put(sum, 1);\n            }\n        }\n        long ans = 0;\n        for (int i = index; i < n; i++) {\n            if (a[i] < m)\n                sum--;\n            else if (a[i] > m)\n                sum++;\n            if (map.containsKey(sum))\n                ans += map.get(sum);\n            if (map.containsKey(sum - 1))\n                ans += map.get(sum - 1);\n        }\n        out.print(ans);\n        out.flush();\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static BufferedReader in=new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer tok;\n    static boolean hasNext()\n    {\n        while(tok==null||!tok.hasMoreTokens())\n            try{\n                tok=new StringTokenizer(in.readLine());\n            }\n            catch(Exception e){\n                return false;\n            }\n        return true;\n    }\n    static String next()\n    {\n        hasNext();\n        return tok.nextToken();\n    }\n    static long nextLong()\n    {\n        return Long.parseLong(next());\n    }\n    static int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) {\n        Map<Integer,Integer> map = new HashMap();\n        map.put(0,1);\n        int n = nextInt();\n        int m = nextInt();\n        int index = -1;\n        int a[] = new int[n];\n        for(int i=0;i<n;i++){\n            a[i]=nextInt();\n            if(a[i]==m)\n                index=i;\n        }\n        int sum = 0;\n        for(int i=0;i<index;i++){\n            if (a[i]<m)\n                sum--;\n            else\n                sum++;\n            if (map.containsKey(sum)){\n                map.put(sum,map.get(sum)+1);\n            }else {\n                map.put(sum,1);\n            }\n        }\n        long ans = 0;\n        for(int i=index;i<n;i++){\n            if (a[i]<m)\n                sum--;\n            else if(a[i]>m)\n                sum++;\n            if (map.containsKey(sum))\n                ans+=map.get(sum);\n            if (map.containsKey(sum-1))\n                ans+=map.get(sum-1);\n        }\n        out.print(ans);\n        out.flush();\n    }\n}\n", "index": 593, "complexity": 4}
{"back-translation": "import java.util.*;\npublic class TransformedBox {\n\n    public static void main(String ars[]){\n\n        Scanner  s = new Scanner(System.in);\n        int n = s.nextInt();\n        int max = 0;\n\n        Map<Integer,Integer> map = new HashMap<>();\n\n        for (int i=0;i<n;i++){\n            int x = s.nextInt();\n            if(!map.containsKey(x)){\n                map.put(x,1);\n                max = Math.max(max,1);\n            }\n            else{\n                map.put(x,map.get(x)+1);\n                max = Math.max(max,map.get(x));\n            }\n        }\n\n        System.out.println(max);\n    }\n\n}\n", "src": "import java.util.*;\npublic class bOX {\n\n    public static void main(String ars[]){\n\n        Scanner  s = new Scanner(System.in);\n        int n = s.nextInt();\n        int max = 0;\n\n        Map<Integer,Integer> map = new HashMap<>();\n\n        for(int i=0;i<n;i++){\n            int x = s.nextInt();\n            if(!map.containsKey(x)){\n                map.put(x,1);\n                max = Math.max(max,1);\n            }\n            else{\n                map.put(x,map.get(x)+1);\n                max = Math.max(max,map.get(x));\n            }\n        }\n\n        System.out.println(max);\n    }\n\n}\n", "index": 595, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int T;\n\n    public static void main(String[] args) throws IOException {\n        FastScanner sc = new FastScanner(System.in);\n        T = sc.nextInt();\n\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < T; i++) {\n            int n = sc.nextInt();\n            int[] a = sc.nextIntArray(n);\n            int[] ans = solve(n, a);\n            StringJoiner j = new StringJoiner(\" \");\n            for (int each : ans) {\n                j.add(String.valueOf(each));\n            }\n            pw.println(j.toString());\n        }\n        pw.flush();\n    }\n\n    static int[] solve(int n, int[] a) {\n        // Finding numbers 'a' and 'b' such that the ratio a/b is close to 1\n        shuffle(a);\n        Arrays.sort(a);\n        int current = a[0];\n        int time = 1;\n        double ratio = 0;\n        int prev = -1;\n        int numA = -1;\n        int numB = -1;\n        for (int i = 1; i < n; i++) {\n            if (current == a[i]) {\n                time++;\n\n                if (time == 2) {\n                    if (prev != -1) {\n                        double currentRatio = (double) prev / current;\n                        if (currentRatio > ratio) {\n                            ratio = currentRatio;\n                            numA = prev;\n                            numB = current;\n                        }\n                    }\n                    prev = current;\n                }\n\n                if (time == 4) {\n                    return new int[]{current, current, current, current};\n                }\n\n            } else {\n                time = 1;\n                current = a[i];\n            }\n        }\n\n        return new int[]{numA, numA, numB, numB};\n    }\n\n    static void shuffle(int[] a) {\n        Random random = ThreadLocalRandom.current();\n        for (int i = a.length - 1; i >= 0; i--) {\n            int j = random.nextInt(i + 1);\n            int temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() throws IOException {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() throws IOException {\n            return reader.readLine();\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) throws IOException {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) throws IOException {\n        PrintWriter printWriter = new PrintWriter(System.out);\n        for (A a : as) {\n            printWriter.println(f.apply(a));\n        }\n        printWriter.flush();\n    }\n\n    static void writeLines(int[] as) throws IOException {\n        PrintWriter printWriter = new PrintWriter(System.out);\n        for (int a : as) printWriter.println(a);\n        printWriter.flush();\n    }\n\n    static void writeLines(long[] as) throws IOException {\n        PrintWriter printWriter = new PrintWriter(System.out);\n        for (long a : as) printWriter.println(a);\n        printWriter.flush();\n    }\n\n    static int max(int... as) {\n        int maximum = Integer.MIN_VALUE;\n        for (int a : as) maximum = Math.max(a, maximum);\n        return maximum;\n    }\n\n    static int min(int... as) {\n        int minimum = Integer.MAX_VALUE;\n        for (int a : as) minimum = Math.min(a, minimum);\n        return minimum;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner joiner = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) joiner.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) joiner.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) joiner.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) joiner.add(Arrays.toString((Object[]) arg));\n            else joiner.add(arg.toString());\n        }\n        System.err.println(joiner.toString());\n    }\n}", "src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int T;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        T = sc.nextInt();\n\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < T; i++) {\n            int n = sc.nextInt();\n            int[] a = sc.nextIntArray(n);\n            int[] ans = solve(n, a);\n            StringJoiner j = new StringJoiner(\" \");\n            for (int each : ans) {\n                j.add(String.valueOf(each));\n            }\n            pw.println(j.toString());\n        }\n        pw.flush();\n    }\n\n    static int[] solve(int N, int[] A) {\n        // a/b \u304c1\u306b\u8fd1\u3044\u3082\u306e\u3092\u63a2\u3059\n        shuffle(A);\n        Arrays.sort(A);\n        int cur = A[0];\n        int time = 1;\n        double r = 0;\n        int prev = -1;\n        int a = -1;\n        int b = -1;\n        for (int i = 1; i < N; i++) {\n            if( cur == A[i] ) {\n                time++;\n\n                if( time == 2 ) {\n                    if( prev != -1 ) {\n                        double r1 = (double)prev/cur;\n                        if( r1 > r ) {\n                            r = r1;\n                            a = prev;\n                            b = cur;\n                        }\n                    }\n                    prev = cur;\n                }\n\n                if( time == 4 ) {\n                    return new int[]{cur, cur, cur, cur};\n                }\n\n            } else {\n                time = 1;\n                cur = A[i];\n            }\n        }\n\n        return new int[]{a, a, b, b};\n    }\n\n    static void shuffle(int[] a) {\n        Random r = ThreadLocalRandom.current();\n        for (int i = a.length-1; i >= 0; i--) {\n            int j = r.nextInt(i+1);\n            int t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n", "index": 596, "complexity": 4}
{"back-translation": "class DisjointSet{\n\tint[] parent;\n\tDisjointSet(int n){\n\t\tparent = new int[n + 1];\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\tint find(int s){\n\t\tif(s == parent[s])\n\t\t\treturn s;\n\t\treturn parent[s] = find(parent[s]);\n\t}\n\tvoid merge(int u, int v){\n\t\tparent[v] = u;\n\t}\n}\nclass Job implements Comparator<Job>{\n\tchar id;\n\tint deadline, profit;\n\tpublic Job() {\n\t}\n\tpublic Job(char id, int deadline, int profit){\n\t\tthis.id = id;\n\t\tthis.deadline = deadline;\n\t\tthis.profit = profit;\n\t}\n\tpublic static int findMaxDeadline(ArrayList<Job> arr){\n\t\tint ans = Integer.MIN_VALUE;\n\t\tfor(Job temp : arr)\n\t\t\tans = Math.max(temp.deadline, ans);\n\t\treturn ans;\n\t}\n\tpublic static void printJobScheduling(ArrayList<Job> arr){\n\t\tCollections.sort(arr, new Job());\n\t\tint maxDeadline = findMaxDeadline(arr);\n\t\tDisjointSet dsu = new DisjointSet(maxDeadline);\n\t\tfor(Job temp : arr){\n\t\t\tint availableSlot = dsu.find(temp.deadline);\n\t\t\tif(availableSlot > 0){\n\t\t\t\tdsu.merge(dsu.find(availableSlot - 1), availableSlot);\n\t\t\t\tSystem.out.print(temp.id + \" \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tpublic int compare(Job j1, Job j2){\n\t\treturn j1.profit > j2.profit? -1 : 1;\n\t}\n}\nclass Main{\n\tpublic static void main(String args[]){\n\t\tArrayList<Job> arr=new ArrayList<Job>();\n\t\tarr.add(new Job('a', 2, 100));\n\t\tarr.add(new Job('b', 1, 19));\n\t\tarr.add(new Job('c', 2, 27));\n\t\tarr.add(new Job('d', 1, 25));\n\t\tarr.add(new Job('e', 3, 15));\n\t\tSystem.out.println(\"Following jobs need to be executed for maximum profit\");\n\t\tJob.printJobScheduling(arr);\n\t}\n}", "src": "\n// Java program to find the maximum profit job sequence \n// from a given array of jobs with deadlines and profits \nimport\njava.util.*; \n\n// A Simple Disjoint Set Data Structure \nclass\nDisjointSet \n{ \n\nint\nparent[]; \n\n\n// Constructor \n\nDisjointSet(\nint\nn) \n\n{ \n\nparent = \nnew\nint\n[n + \n1\n]; \n\n\n// Every node is a parent of itself \n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nparent[i] = i; \n\n} \n\n\n// Path Compression \n\nint\nfind(\nint\ns) \n\n{ \n\n/* Make the parent of the nodes in the path \n\nfrom u--> parent[u] point to parent[u] */\n\nif\n(s == parent[s]) \n\nreturn\ns; \n\nreturn\nparent[s] = find(parent[s]); \n\n} \n\n\n// Makes u as parent of v. \n\nvoid\nmerge(\nint\nu, \nint\nv) \n\n{ \n\n//update the greatest available \n\n//free slot to u \n\nparent[v] = u; \n\n} \n} \n\nclass\nJob \nimplements\nComparator<Job> \n{ \n\n// Each job has a unique-id, profit and deadline \n\nchar\nid; \n\nint\ndeadline, profit; \n\n\n// Constructors \n\npublic\nJob() { } \n\npublic\nJob(\nchar\nid,\nint\ndeadline,\nint\nprofit) \n\n{ \n\nthis\n.id = id; \n\nthis\n.deadline = deadline; \n\nthis\n.profit = profit; \n\n} \n\n\n// Returns the maximum deadline from the set of jobs \n\npublic\nstatic\nint\nfindMaxDeadline(ArrayList<Job> arr) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n\nfor\n(Job temp : arr) \n\nans = Math.max(temp.deadline, ans); \n\nreturn\nans; \n\n} \n\n\n// Prints optimal job sequence \n\npublic\nstatic\nvoid\nprintJobScheduling(ArrayList<Job> arr) \n\n{ \n\n// Sort Jobs in descending order on the basis \n\n// of their profit \n\nCollections.sort(arr, \nnew\nJob()); \n\n\n// Find the maximum deadline among all jobs and \n\n// create a disjoint set data structure with \n\n// maxDeadline disjoint sets initially. \n\nint\nmaxDeadline = findMaxDeadline(arr); \n\nDisjointSet dsu = \nnew\nDisjointSet(maxDeadline); \n\n\n// Traverse through all the jobs \n\nfor\n(Job temp : arr) \n\n{ \n\n// Find the maximum available free slot for \n\n// this job (corresponding to its deadline) \n\nint\navailableSlot = dsu.find(temp.deadline); \n\n\n\n// If maximum available free slot is greater \n\n// than 0, then free slot available \n\nif\n(availableSlot > \n0\n) \n\n{ \n\n// This slot is taken by this job 'i' \n\n// so we need to update the greatest free \n\n// slot. Note that, in merge, we make \n\n// first parameter as parent of second \n\n// parameter. So future queries for \n\n// availableSlot will return maximum slot \n\n// from set of \"availableSlot - 1\" \n\ndsu.merge(dsu.find(availableSlot - \n1\n), \n\navailableSlot); \n\nSystem.out.print(temp.id + \n\" \"\n); \n\n} \n\n} \n\nSystem.out.println(); \n\n} \n\n\n// Used to sort in descending order on the basis \n\n// of profit for each job \n\npublic\nint\ncompare(Job j1, Job j2) \n\n{ \n\nreturn\nj1.profit > j2.profit? -\n1\n: \n1\n; \n\n} \n} \n\n// Driver code \nclass\nMain \n{ \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nArrayList<Job> arr=\nnew\nArrayList<Job>(); \n\narr.add(\nnew\nJob(\n'a'\n,\n2\n,\n100\n)); \n\narr.add(\nnew\nJob(\n'b'\n,\n1\n,\n19\n)); \n\narr.add(\nnew\nJob(\n'c'\n,\n2\n,\n27\n)); \n\narr.add(\nnew\nJob(\n'd'\n,\n1\n,\n25\n)); \n\narr.add(\nnew\nJob(\n'e'\n,\n3\n,\n15\n)); \n\nSystem.out.println(\n\"Following jobs need to be \"\n+ \n\n\"executed for maximum profit\"\n); \n\nJob.printJobScheduling(arr); \n\n} \n} ", "index": 597, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String next() {\n            if (st.hasMoreTokens())\n                return st.nextToken();\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            String line = \"\";\n            if (st.hasMoreTokens())\n                line = st.nextToken();\n            else try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            while (st.hasMoreTokens())\n                line += \" \" + st.nextToken();\n            return line;\n        }\n    }\n\n    static class Pair {\n        int a;\n        int b;\n\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int floor = sc.nextInt();\n        int time = 0;\n\n        Pair[] arr = new Pair[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = new Pair(sc.nextInt(), sc.nextInt());\n\n        Arrays.sort(arr, (Pair cur, Pair other) -> (other.a - cur.a));\n\n        for (int i = 0; i < n; i++) {\n            time += floor - arr[i].a;\n            floor = arr[i].a;\n            time = Math.max(time, arr[i].b);\n\n        }\n\n        time += arr[n - 1].a;\n\n        pw.println(time);\n        pw.close();\n    }\n}\n", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n    static class Pair {\n        int a;\n        int b;\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int floor = sc.nextInt();\n        int time = 0;\n\n        Pair[] arr = new Pair[n];\n        for(int i=0;i<n;i++) arr[i] = new Pair(sc.nextInt(), sc.nextInt());\n\n        Arrays.sort(arr, (Pair cur, Pair other) -> (other.a - cur.a));\n\n        for(int i=0;i<n;i++) {\n            time += floor - arr[i].a;\n            floor = arr[i].a;\n            time = Math.max(time, arr[i].b);\n            //pw.println(\"time: \" + time);\n        }\n\n        time += arr[n-1].a;\n\n        pw.println(time);\n        pw.close();\n    }\n}\n", "index": 598, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Four{\n    public static void main(String[] args) {\n\tScanner in = new Scanner (System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tpair[] points = new pair [3];\n\tfor (int i = 0; i < 3; ++i) {\n\t    int x = in.nextInt();\n\t    int y = in.nextInt();\n\t    points[i] = new pair (x, y);\n\t}\n\n\tArrays.sort(points);\n\n\tint MaxY = Math.max(Math.max(points[0].y, points[1].y), points[2].y);\n\tint MinY = Math.min(Math.min(points[0].y, points[1].y), points[2].y);\n\n\tout.println(MaxY - MinY + points[2].x - points[0].x + 1);\n\tfor (int i = MinY; i <= MaxY; ++i)\n\t    out.println(points[1].x + \" \" + i);\n\tfor (int i = points[0].x; i < points[1].x; ++i)\n\t    out.println(i + \" \" + points[0].y);\n\tfor (int i = points[1].x + 1; i <= points[2].x; ++i)\n\t    out.println(i + \" \" + points[2].y);\n\t\n\tout.close();\n    }\n\n    public static class pair implements Comparable<pair> {\n\tint x, y;\n\tpublic pair (int x_, int y_) {\n\t    x = x_; y = y_;\n\t}\n\n\t@Override\n\tpublic int compareTo(pair o) {\n\t    return x - o.x;\n\t}\n    }\n}\n", "src": "import java.util.*;\nimport java.io.*;\n\npublic class Three{\n    public static void main(String[] args) {\n\tScanner in = new Scanner (System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tpair[] points = new pair [3];\n\tfor (int i = 0; i < 3; ++i) {\n\t    int x = in.nextInt();\n\t    int y = in.nextInt();\n\t    points[i] = new pair (x, y);\n\t}\n\n\tArrays.sort(points);\n\n\tint MaxY = Math.max(Math.max(points[0].y, points[1].y), points[2].y);\n\tint MinY = Math.min(Math.min(points[0].y, points[1].y), points[2].y);\n\n\tout.println(MaxY - MinY + points[2].x - points[0].x + 1);\n\tfor (int i = MinY; i <= MaxY; ++i)\n\t    out.println(points[1].x + \" \" + i);\n\tfor (int i = points[0].x; i < points[1].x; ++i)\n\t    out.println(i + \" \" + points[0].y);\n\tfor (int i = points[1].x + 1; i <= points[2].x; ++i)\n\t    out.println(i + \" \" + points[2].y);\n\t\n\tout.close();\n    }\n\n    public static class pair implements Comparable<pair> {\n\tint x, y;\n\tpublic pair (int x_, int y_) {\n\t    x = x_; y = y_;\n\t}\n\n\t@Override\n\tpublic int compareTo(pair o) {\n\t    return x - o.x;\n\t}\n    }\n}\n", "index": 599, "complexity": 4}
{"back-translation": "long MOD = 1000L * 1000L * 1000L + 7;\nprivate static final int[] dx = {0, -1, 0, 1};\nprivate static final int[] dy = {1, 0, -1, 0};\nprivate static final String yes = \"Yes\";\nprivate static final String no = \"No\";\nint n;\nint m;\nchar[][] mat;\nlong base = 397;\nvoid solve() throws IOException {\nn = nextInt();\nm = nextInt();\nmat = new char[n][m];\nfor (int i = 0; i < n; i++) {\nmat[i] = nextString().toCharArray();\n}\n\nint alpha = 26;\nlong[] pow = new long[alpha];\npow[0] = 1;\nfor (int i = 1; i < alpha; i++) {\npow[i] = pow[i - 1] * base % MOD;\n}\n\nlong res = 0;\nfor (int l = 0; l < m; l++) {\n//[l, r]\nlong[] hash = new long[n];\nlong[] mask = new long[n];\nfor (int r = l; r < m; r++) {\nfor (int i = 0; i < n; i++) {\nhash[i] += pow[mat[i][r] - 'a'];\nhash[i] %= MOD;\nmask[i] = mask[i] ^ (1L << (mat[i][r] - 'a'));\n}\n\nint start = 0;\nwhile (start < n) {\nif ((mask[start] & (mask[start] - 1)) != 0) {\nstart++;\ncontinue;\n}\n\nint end = start;\nList<Long> l1 = new ArrayList<>();\nwhile (end < n && (mask[end] & (mask[end] - 1)) == 0) {\nl1.add(hash[end]);\nend++;\n}\n\nstart = end;\nres += manacher(l1);\n}\n}\n}\n\noutln(res);\n}\n\nlong manacher(List<Long> arr) {\nint len = arr.size();\nlong[] t = new long[len * 2 + 3];\nt[0] = -1;\nt[len * 2 + 2] = -2;\nfor (int i = 0; i < len; i++) {\nt[2 * i + 1] = -3;\nt[2 * i + 2] = arr.get(i);\n}\n\nt[len * 2 + 1] = -3;\nint[] p = new int[t.length];\nint center = 0, right = 0;\nfor (int i = 1; i < t.length - 1; i++) {\nint mirror = 2 * center - i;\nif (right > i) {\np[i] = Math.min(right - i, p[mirror]);\n}\n\nwhile (t[i + (1 + p[i])] == t[i - (1 + p[i])]) {\np[i]++;\n}\n\nif (i + p[i] > right) {\ncenter = i;\nright = i + p[i];\n}\n}\n\nlong res = 0;\nfor (int i = 0; i < 2 * len; i++) {\nint parLength = p[i + 2];\nif (i % 2 == 0) {\nres += (parLength + 1) / 2;\n}\nelse {\nres += parLength / 2;\n}\n}\n\nreturn res;\n}\n\nvoid shuffle(int[] a) {\nint n = a.length;\nfor(int i = 0; i < n; i++) {\nint r = i + (int) (Math.random() * (n - i));\nint tmp = a[i];\na[i] = a[r];\na[r] = tmp;\n}\n}\nlong gcd(long a, long b) {\nwhile(a != 0 && b != 0) {\nlong c = b;\nb = a % b;\na = c;\n}\nreturn a + b;\n}\nprivate void outln(Object o) {\nout.println(o);\n}\nprivate void out(Object o) {\nout.print(o);\n}\nprivate void formatPrint(double val) {\noutln(String.format(\"%.9f%n\", val);\n}\npublic CFA() throws IOException {\nbr = new BufferedReader(new InputStreamReader(System.in));\nout = new PrintWriter(System.out);\nsolve();\nout.close();\n}\npublic static void main(String[] args) throws IOException {\nnew CFA();\n}\npublic long[] nextLongArr(int n) throws IOException{\nlong[] res = new long[n];\nfor(int i = 0; i < n; i++)\nres[i] = nextLong();\nreturn res;\n}\npublic int[] nextIntArr(int n) throws IOException {\nint[] res = new int[n];\nfor(int i = 0; i < n; i++)\nres[i] = nextInt();\nreturn res;\n}\npublic String nextToken() {\nwhile (st == null || !st.hasMoreTokens()) {\ntry {\nst = new StringTokenizer(br.readLine());\n} catch (Exception e) {\neof = true;\nreturn null;\n}\n}\nreturn st.nextToken();\n}\npublic String nextString() {\ntry {\nreturn br.readLine();\n} catch (IOException e) {\neof = true;\nreturn null;\n}\n}\npublic int nextInt() throws IOException {\nreturn Integer.parseInt(nextToken());\n}\npublic long nextLong() throws IOException {\nreturn Long.parseLong(nextToken());\n}\npublic double nextDouble() throws IOException {\nreturn Double.parseDouble(nextToken());\n}\n}", "src": "/*\nKeep solving problems.\n*/\n\nimport java.util.*;\nimport java.io.*;\n\npublic class CFA {\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    private static long MOD = 1000L * 1000L * 1000L + 7;\n    private static final int[] dx = {0, -1, 0, 1};\n    private static final int[] dy = {1, 0, -1, 0};\n    private static final String yes = \"Yes\";\n    private static final String no = \"No\";\n\n    int n;\n    int m;\n    char[][] mat;\n    long base = 397;\n    void solve() throws IOException {\n        n = nextInt();\n        m = nextInt();\n        mat = new char[n][m];\n        for (int i = 0; i < n; i++) {\n            mat[i] = nextString().toCharArray();\n        }\n\n        int alpha = 26;\n        long[] pow = new long[alpha];\n        pow[0] = 1;\n        for (int i = 1; i < alpha; i++) {\n            pow[i] = pow[i - 1] * base % MOD;\n        }\n\n        long res = 0;\n        for (int l = 0; l < m; l++) {\n            //[l, r]\n            long[] hash = new long[n];\n            long[] mask = new long[n];\n            for (int r = l; r < m; r++) {\n                for (int i = 0; i < n; i++) {\n                    hash[i] += pow[mat[i][r] - 'a'];\n                    hash[i] %= MOD;\n                    mask[i] = mask[i] ^ (1L << (mat[i][r] - 'a'));\n                }\n\n                int start = 0;\n                while (start < n) {\n                    if ((mask[start] & (mask[start] - 1)) != 0) {\n                        start++;\n                        continue;\n                    }\n\n                    int end = start;\n                    List<Long> l1 = new ArrayList<>();\n                    while (end < n && (mask[end] & (mask[end] - 1)) == 0) {\n                        l1.add(hash[end]);\n                        end++;\n                    }\n\n                    start = end;\n                    res += manacher(l1);\n                }\n            }\n        }\n\n        outln(res);\n    }\n\n    long manacher(List<Long> arr) {\n        int len = arr.size();\n        long[] t = new long[len * 2 + 3];\n        t[0] = -1;\n        t[len * 2 + 2] = -2;\n        for (int i = 0; i < len; i++) {\n            t[2 * i + 1] = -3;\n            t[2 * i + 2] = arr.get(i);\n        }\n\n        t[len * 2 + 1] = -3;\n        int[] p = new int[t.length];\n        int center = 0, right = 0;\n        for (int i = 1; i < t.length - 1; i++) {\n            int mirror = 2 * center - i;\n            if (right > i) {\n                p[i] = Math.min(right - i, p[mirror]);\n            }\n\n            // attempt to expand palindrome centered at i\n            while (t[i + (1 + p[i])] == t[i - (1 + p[i])]) {\n                p[i]++;\n            }\n\n            // if palindrome centered at i expands past right,\n            // adjust center based on expanded palindrome.\n            if (i + p[i] > right) {\n                center = i;\n                right = i + p[i];\n            }\n        }\n\n        long res = 0;\n        for (int i = 0; i < 2 * len; i++) {\n            int parLength = p[i + 2];\n            if (i % 2 == 0) {\n                res += (parLength + 1) / 2;\n            }\n            else {\n                res += parLength / 2;\n            }\n        }\n\n        return res;\n    }\n\n    void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n    long gcd(long a, long b) {\n        while(a != 0 && b != 0) {\n            long c = b;\n            b = a % b;\n            a = c;\n        }\n        return a + b;\n    }\n    private void outln(Object o) {\n        out.println(o);\n    }\n    private void out(Object o) {\n        out.print(o);\n    }\n    private void formatPrint(double val) {\n        outln(String.format(\"%.9f%n\", val));\n    }\n    public CFA() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFA();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}", "index": 602, "complexity": 4}
{"back-translation": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n / 2];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(p));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] p) {\n\t\tint res1 = computeMoveNum(p, 1);\n\t\tint res2 = computeMoveNum(p, 2);\n\n\t\treturn Math.min(res1, res2);\n\t}\n\n\tstatic int computeMoveNum(int[] p, int offset) {\n\t\tArrays.sort(p);\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tsum += Math.abs(p[i] - (i * 2 + offset));\n\t\t}\n\t\treturn sum;\n\t}\n}", "src": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n / 2];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(p));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] p) {\n\t\treturn Math.min(computeMoveNum(p, 1), computeMoveNum(p, 2));\n\t}\n\n\tstatic int computeMoveNum(int[] p, int offset) {\n\t\tArrays.sort(p);\n\n\t\treturn IntStream.range(0, p.length).map(i -> Math.abs(p[i] - (i * 2 + offset))).sum();\n\t}\n}\n", "index": 603, "complexity": 4}
{"back-translation": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in =new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tarr[i] -= arr[i - 1];\n\t\t}\n\t\tarr[0] = 0;\n\t\tArrays.sort(arr);\n\t\tlong sum = 0;\n\t\tfor (int i = n - k; i >= 0; i--) {\n\t\t\tsum += arr[i];\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n}", "src": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in =new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tarr[i] = in.nextInt();\n\t\tfor(int i = n-1; i > 0; i--)\n\t\t\tarr[i] -= arr[i-1];\n\t\tarr[0] = 0;\n\t\tArrays.sort(arr);\n\t\tlong sum = 0;\n\t\tfor(int i = n-k; i >= 0; i--)\n\t\t\tsum += arr[i];\n\t\tSystem.out.println(sum);\n\t}\n}", "index": 604, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class cf {\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n\n    static int mod = 1000000007;\n    \n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out); \n\n        int n=sc.nextInt(), k = sc.nextInt();\n        int[] a = new int[n+1];\n\n        for(int i=0;i<n;i++) {\n            a[i] = sc.nextInt();\n        }\n        a[n] = 0;\n        Arrays.sort(a);\n\n        int i = 1;\n        while(i<=n) {\n            if(k == 0) {\n                break;\n            }\n            if(a[i] != a[i-1]) {\n                k--;\n                pw.println(a[i] - a[i-1]);\n            }\n            i++;\n        }\n        for(int j=0;j<k;j++) pw.println(0);\n        pw.close();\n    }\n}\n", "src": "import java.io.*;\nimport java.util.*;\n\npublic class cf {\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n\n    static int mod = 1000000007;\n    \n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out); \n\n        int n=sc.nextInt(), k = sc.nextInt();\n        int[] a = new int[n+1];\n\n        for(int i=0;i<n;i++) {\n            a[i] = sc.nextInt();\n        }\n        a[n] = 0;\n        Arrays.sort(a);\n\n        for(int i=1;i<=n;i++) {\n            if(k == 0) {\n                break;\n            }\n            if(a[i] != a[i-1]) {\n                k--;\n                pw.println(a[i] - a[i-1]);\n            }\n        }\n        for(int i=0;i<k;i++) pw.println(0);\n        pw.close();\n    }\n}\n", "index": 605, "complexity": 4}
{"back-translation": "class GFG { public static int kthSmallest(Integer[] arr, int k) { Arrays.sort(arr); return arr[k - 1]; } public static void main(String[] args) { Integer arr[] = new Integer[]{12, 3, 5, 7, 19}; int k = 2; System.out.print(\"K'th smallest element is \" + kthSmallest(arr, k)); } }", "src": "\n// Java code for kth smallest element \n// in an array \nimport\njava.util.Arrays; \nimport\njava.util.Collections; \n\nclass\nGFG \n{ \n\n// Function to return k'th smallest \n\n// element in a given array \n\npublic\nstatic\nint\nkthSmallest(Integer [] arr, \n\nint\nk) \n\n{ \n\n// Sort the given array \n\nArrays.sort(arr); \n\n\n// Return k'th element in \n\n// the sorted array \n\nreturn\narr[k-\n1\n]; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[]{\n12\n, \n3\n, \n5\n, \n7\n, \n19\n}; \n\nint\nk = \n2\n; \n\nSystem.out.print( \n\"K'th smallest element is \"\n+ \n\nkthSmallest(arr, k) ); \n\n} \n} \n\n// This code is contributed by Chhavi ", "index": 606, "complexity": 4}
{"back-translation": "import java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int a[] = new int[n];\n        int b[] = new int[n];\n        for (int i = 0; i < n; i++) a[i] = sc.nextInt();\n        for (int i = 0; i < n; i++) b[i] = sc.nextInt();\n        int c[] = new int[2 * n];\n        c[0] = a[0];\n        for (int i = 1; i < n; i++) {\n            c[i * 2] = a[i];\n            c[i * 2 - 1] = b[i];\n            if (a[i] == 1 || b[i] == 1) {\n                System.out.print(-1);\n                System.exit(0);\n            }\n        }\n        c[2 * n - 1] = b[0];\n        if (a[0] == 1 || b[0] == 1) {\n            System.out.print(-1);\n            System.exit(0);\n        }\n        System.out.println(bin_search(c, m));\n    }\n\n    private static double bin_search(int[] c, int m) {\n        double start = 0;\n        double end = Integer.MAX_VALUE;\n        double mid;\n        while (start + 0.0000001 < end) {\n            mid = (start + end) / 2;\n            if (test(mid, m, c)) end = mid;\n            else start = mid;\n        }\n        return end;\n    }\n\n    private static boolean test(double fuel, int m, int[] c) {\n        for (int i = 0; i < c.length; i++) {\n            fuel -= (m + fuel) / c[i];\n            if (fuel < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "src": "import java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int a[] = new int[n];\n        int b[] = new int[n];\n        for (int i = 0; i < n; i++) a[i] = sc.nextInt();\n        for (int i = 0; i < n; i++) b[i] = sc.nextInt();\n        int c[] = new int[2 * n];\n        c[0] = a[0];\n        for (int i = 1; i < n; i++) {\n            c[i * 2] = a[i];\n            c[i * 2 - 1] = b[i];\n            if (a[i] == 1 || b[i] == 1) {\n                System.out.print(-1);\n                System.exit(0);\n            }\n        }\n        c[2 * n - 1] = b[0];\n        if (a[0] == 1 || b[0] == 1) {\n            System.out.print(-1);\n            System.exit(0);\n        }\n        System.out.println(bin_search(c, m));\n    }\n\n    private static double bin_search(int[] c, int m) {\n        double start = 0;\n        double end = Integer.MAX_VALUE;\n        double mid;\n        while (start + 0.0000001 < end) {\n            mid = (start + end) / 2;\n            if (test(mid, m, c)) end = mid;\n            else start = mid;\n        }\n        return end;\n    }\n\n    private static boolean test(double fuel, int m, int[] c) {\n        for (int i = 0; i < c.length; i++) {\n            fuel -= (m + fuel) / c[i];\n            if (fuel < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "index": 608, "complexity": 4}
{"back-translation": "import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class GFG { public static int MaxSumDifference(Integer[] a, int n) { List<Integer> finalSequence = new ArrayList<Integer>(); Arrays.sort(a); for (int i = 0; i < n / 2; ++i) { finalSequence.add(a[i]); finalSequence.add(a[n - i - 1]); } int MaximumSum = 0; for (int i = 0; i < n - 1; ++i) { MaximumSum = MaximumSum + Math.abs(finalSequence.get(i) - finalSequence.get(i + 1)); } MaximumSum = MaximumSum + Math.abs(finalSequence.get(n - 1) - finalSequence.get(0)); return MaximumSum; } public static void main(String args[]) { Integer[] a = { 1, 2, 4, 8 }; int n = a.length; System.out.print(MaxSumDifference(a, n)); } }", "src": "\n// Java implementation of \n// above algorithm \nimport\njava.io.*; \nimport\njava.util.*; \n\npublic\nclass\nGFG { \n\n\nstatic\nint\nMaxSumDifference(Integer []a, \nint\nn) \n\n{ \n\n\n// final sequence stored in the vector \n\nList<Integer> finalSequence = \n\nnew\nArrayList<Integer>(); \n\n\n// sort the original array \n\n// so that we can retrieve \n\n// the large elements from \n\n// the end of array elements \n\nArrays.sort(a); \n\n\n// In this loop first we will insert \n\n// one smallest element not entered \n\n// till that time in final sequence \n\n// and then enter a highest element \n\n// (not entered till that time) in \n\n// final sequence so that we \n\n// have large difference value. This \n\n// process is repeated till all array \n\n// has completely entered in sequence. \n\n// Here, we have loop till n/2 because \n\n// we are inserting two elements at a \n\n// time in loop. \n\nfor\n(\nint\ni = \n0\n; i < n / \n2\n; ++i) { \n\nfinalSequence.add(a[i]); \n\nfinalSequence.add(a[n - i - \n1\n]); \n\n} \n\n\n// variable to store the \n\n// maximum sum of absolute \n\n// difference \n\nint\nMaximumSum = \n0\n; \n\n\n// In this loop absolute difference \n\n// of elements for the final sequence \n\n// is calculated. \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(i) \n\n- finalSequence.get(i + \n1\n)); \n\n} \n\n\n// absolute difference of last element \n\n// and 1st element \n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(n - \n1\n) \n\n- finalSequence.get(\n0\n)); \n\n\n// return the value \n\nreturn\nMaximumSum; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nInteger []a = { \n1\n, \n2\n, \n4\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxSumDifference(a, n)); \n\n} \n} \n\n// This code is contributed by \n// Manish Shaw (manishshaw1) ", "index": 609, "complexity": 4}
{"back-translation": "ERROR", "src": "import java.util.*;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tComp c1 = getComp(scanner);\n\t\tComp c2 = getComp(scanner);\n\t\tc1.sortByPrice();\n\t\tc2.sortByPrice();\t\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < c1.num || j < c2.num) {\n\t\t\tElem xi = (i < c1.num) ? c1.elems.get(i) : null;\n\t\t\tElem yj = (j < c2.num) ? c2.elems.get(j) : null;\n\t\t\tif(xi != null && yj != null) {\n\t\t\t\tif(xi.price >= yj.price) {\n\t\t\t\t\tif(!c2.resultSet.contains(xi)) {\n\t\t\t\t\t\tc1.resultSet.add(xi);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tif(!c1.resultSet.contains(yj)) {\n\t\t\t\t\t\tc2.resultSet.add(yj);\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t} else\n\t\t\tif(xi != null) {\n\t\t\t\tif(!c2.resultSet.contains(xi)) {\n\t\t\t\t\tc1.resultSet.add(xi);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tif(!c1.resultSet.contains(yj)) {\n\t\t\t\t\tc2.resultSet.add(yj);\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\t\t\t\t\n\t\t}\n\t\t\n\t\tlong result = c1.getResultPrice() + c2.getResultPrice();\n\t\tSystem.out.println(result);\n   }\n   \n   private static Comp getComp(Scanner scanner) {\n\t   Comp c = new Comp();\n\t   c.num = scanner.nextInt();\n\t   for(int i = 0; i < c.num; i++) {\n\t\t   c.addElem(scanner.nextLong(), scanner.nextLong());\n\t   }\n\t   return c;\n   }\n}\n\nclass Comp {\n\tint num;\n\tList<Elem> elems = new ArrayList<>();\n\tSet<Elem> resultSet = new HashSet<>();\n\t\n\tvoid addElem(long el, long pr) {\n\t\tElem elem = new Elem(el, pr);\n\t\telems.add(elem);\n\t}\n\t\n\tvoid sortByPrice() {\n\t\tCollections.sort(elems);\n\t}\n\t\n\tlong getResultPrice() {\n\t\tlong sumPrice = 0;\n\t\tfor(Elem elem : resultSet) {\n\t\t\tsumPrice += elem.price;\n\t\t}\n\t\t\n\t\treturn sumPrice;\n\t}\n}\n\nclass Elem implements Comparable<Elem> {\n\tlong elem;\n\tlong price;\n\t\n\tpublic Elem(long el, long pr) {\n\t\tthis.elem = el;\n\t\tthis.price = pr;\n\t}\n\t\n\tpublic int compareTo(Elem other) {\n\t\treturn (int) (other.price - price);\n\t}\n\t\n\tpublic boolean equals(Object o) {\n\t\tif(!(o instanceof Elem)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tElem other = (Elem) o;\n\t\treturn (other.elem == elem);\n\t}\n\t\n\tpublic int hashCode() {\n\t\treturn (int) elem;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn \"(\" + elem + \", \" + price + \")\";\n\t}\n}\n", "index": 611, "complexity": 4}
{"back-translation": "class MinSum {static long findMinSum(long[] a, long[] b, long n) {Arrays.sort(a);Arrays.sort(b);long sum = 0;for (int i = 0; i < n; i++) {sum = sum + Math.abs(a[i] - b[i]);}return sum;}public static void main(String[] args) {long a[] = {4, 1, 8, 7};long b[] = {2, 3, 6, 5};int n = a.length;System.out.println(findMinSum(a, b, n);}}", "src": "\n// Java program to find minimum sum of \n// absolute differences of two arrays. \nimport\njava.util.Arrays; \n\nclass\nMinSum \n{ \n\n// Returns minimum possible pairwise \n\n// absolute difference of two arrays. \n\nstatic\nlong\nfindMinSum(\nlong\na[], \nlong\nb[], \nlong\nn) \n\n{ \n\n// Sort both arrays \n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n// Find sum of absolute differences \n\nlong\nsum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nsum = sum + Math.abs(a[i] - b[i]); \n\n\nreturn\nsum; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Both a[] and b[] must be of same size. \n\nlong\na[] = {\n4\n, \n1\n, \n8\n, \n7\n}; \n\nlong\nb[] = {\n2\n, \n3\n, \n6\n, \n5\n}; \n\nint\nn = a.length; \n\nSystem.out.println(findMinSum(a, b, n)); \n\n} \n} \n\n// This code is contributed by Raghav Sharma ", "index": 613, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\nclass Main {\nstatic class FastReader {\nBufferedReader br;\nStringTokenizer st;\n\npublic FastReader() {br = new BufferedReader(new InputStreamReader(System.in));}\n\nString next() {\nwhile (st == null || !st.hasMoreElements()) {\ntry {\nst = new StringTokenizer(br.readLine());\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\nreturn st.nextToken();\n}\n\nint nextInt() {return Integer.parseInt(next());}\n\nlong nextLong() {return Long.parseLong(next());}\n\ndouble nextDouble() {return Double.parseDouble(next());}\n\nfloat nextFloat() {return Float.parseFloat(next());}\n\nboolean nextBoolean() {return Boolean.parseBoolean(next());}\n\nString nextLine() {\nString str = \"\";\ntry {\nstr = br.readLine();\n} catch (IOException e) {\ne.printStackTrace();\n}\nreturn str;\n}\n}\n\nstatic long modExp(long x, long n, long mod) {\nlong result = 1;\nwhile (n > 0) {\nif (n % 2 == 1)\nresult = (result % mod * x % mod) % mod;\nx = (x % mod * x % mod) % mod;\nn = n / 2;\n}\nreturn result;\n}\n\nstatic long gcd(long a, long b) {\nif (a == 0) return b;\nreturn gcd(b % a, a);\n}\n\npublic static void main(String[] args) {\nFastReader fr = new FastReader();\nint n = fr.nextInt();\nint q = fr.nextInt();\nlong[] a = new long[n];\nlong[] k = new long[q];\nfor (int i = 0; i < n; i++) a[i] = fr.nextLong();\nfor (int i = 0; i < q; i++) k[i] = fr.nextLong();\nlong[] pre = new long[n];\npre[0] = a[0];\nfor (int i = 1; i < n; i++) pre[i] = pre[i - 1] + a[i];\nlong pd = 0;\nfor (int i = 0; i < q; i++) {\nint l = 0;\nint r = n - 1;\nwhile (r > l) {\nint mid = (l + r) >> 1;\nif (pre[mid] - pd < k[i]) {\nl = mid + 1;\n} else if (pre[mid] - pd > k[i]) {\nr = mid - 1;\n} else {\nl = r = mid;\n}\n}\nint ans = 0;\nif (pre[l] - pd <= k[i]) {\nans = n - l - 1;\n} else {\nans = n - l;\n}\nif (ans == 0) ans = n;\npd = pd + k[i];\nif (pd >= pre[n - 1]) pd = 0;\nSystem.out.println(ans);\n}\n}\n}\nclass pair {\npublic int first;\npublic int second;\n\npublic pair(int first, int second) {\nthis.first = first;\nthis.second = second;\n}\n\npublic pair(pair p) {\nthis.first = p.first;\nthis.second = p.second;\n}\n\npublic int first() {return first;}\n\npublic int second() {return second;}\n\npublic void setFirst(int first) {\nthis.first = first;\n}\n\npublic void setSecond(int second) {\nthis.second = second;\n}\n}\nclass myComp implements Comparator<pair> {\npublic int compare(pair a, pair b) {\nif (a.first != b.first) return (a.first - b.first);\nreturn (b.second - a.second);\n}\n}\nclass BIT {\npublic long[] m_array;\n\npublic BIT(long[] dat) {\nm_array = new long[dat.length + 1];\nArrays.fill(m_array, 0);\nfor (int i = 0; i < dat.length; i++) {\nm_array[i + 1] = dat[i];\n}\nfor (int i = 1; i < m_array.length; i++) {\nint j = i + (i & -i);\nif (j < m_array.length) {\nm_array[j] = m_array[j] + m_array[i];\n}\n}\n}\n\npublic final long prefix_query(int i) {\nlong result = 0;\nfor (++i; i > 0; i = i - (i & -i)) {\nresult = result + m_array[i];\n}\nreturn result;\n}\n\npublic final long range_query(int fro, int to) {\nif (fro == 0) {\nreturn prefix_query(to);\n} else {\nreturn (prefix_query(to) - prefix_query(fro - 1));\n}\n}\n\npublic void update(int i, long add) {\nfor (++i; i < m_array.length; i = i + (i & -i)) {\nm_array[i] = m_array[i] + add;\n}\n}\n}", "src": "//Author: Patel Rag\n//Java version \"1.8.0_211\"\nimport java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n      while (st == null || !st.hasMoreElements())\n      {\n        try\n        {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n      String str = \"\";\n      try\n      {\n        str = br.readLine();\n      }\n      catch (IOException e)\n      {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    //binary Modular exponentiation\n  {\n    long result = 1;\n    while(n > 0)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    if(a==0) return b;\n    return gcd(b%a,a);\n  }\n  public static void main(String[] args)\n  throws IOException\n  {\n    FastReader fr = new FastReader();\n    int n = fr.nextInt();\n    int q = fr.nextInt();\n    long[] a = new long[n];\n    long[] k = new long[q];\n    for(int i = 0; i < n; i++) a[i] = fr.nextLong();\n    for(int i = 0; i < q; i++) k[i] = fr.nextLong();\n    long[] pre = new long[n];\n    pre[0] = a[0];\n    for(int i = 1; i < n; i++) pre[i] = pre[i-1] + a[i];\n    long pd = 0;\n    for(int i = 0; i < q; i++)\n    {\n      int l = 0;\n      int r = n - 1;\n      while(r > l)\n      {\n        int mid = (l + r) >> 1;\n\n        if(pre[mid] - pd < k[i])\n        {\n          l = mid + 1;\n        }\n        else if(pre[mid] - pd > k[i])\n        {\n          r = mid - 1;\n        }\n        else\n        {\n          l = r = mid;\n        }\n      }\n      int ans = 0;\n      if(pre[l] - pd <= k[i])\n      {\n        ans = n - l - 1;\n      }\n      else\n      {\n        ans = n - l;\n      }\n      if(ans == 0) ans  = n;\n      pd = pd + k[i];\n      if(pd >= pre[n-1]) pd = 0;\n      System.out.println(ans);\n    }\n  }\n}\nclass pair\n{\n  public int first;\n  public int second;\n  public pair(int first,int second)\n  {\n    this.first = first;\n    this.second = second;\n  }\n  public pair(pair p)\n  {\n    this.first = p.first;\n    this.second = p.second;\n  }\n  public int first() { return first; }\n  public int second() { return second; }\n  public void setFirst(int first) { this.first = first; }\n  public void setSecond(int second) { this.second = second; }\n}\nclass myComp implements Comparator<pair>\n{\n  public int compare(pair a,pair b)\n  {\n    if(a.first != b.first) return (a.first - b.first);\n    return (b.second - a.second);\n  }\n}\nclass BIT       //Binary Indexed Tree aka Fenwick Tree\n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    for(int i = 0; i < dat.length; i++)\n    {\n      m_array[i + 1] = dat[i];\n    }\n    for(int i = 1; i < m_array.length; i++)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(++i; i > 0; i = i - (i & -i))\n    {\n      result = result + m_array[i];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length; i = i + (i & -i))\n    {\n      m_array[i] = m_array[i] + add;\n    }\n  }\n}\n", "index": 614, "complexity": 4}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        TaskC.Scanner in = new TaskC.Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, Scanner in, PrintWriter out) throws IOException {\n            int n = in.nextInt();\n            int m = in.nextInt();\n\n            TaskC.pair[] songs = new TaskC.pair[n];\n            long sum = 0;\n            for (int i = 0; i < n; i++) {\n                songs[i] = new TaskC.pair(in.nextInt(), in.nextInt());\n                sum += songs[i].a;\n            }\n            Arrays.sort(songs);\n\n            int res = 0;\n            int idx = n - 1;\n            while (sum > m) {\n                if (idx < 0) {\n                    break;\n                }\n                sum -= (songs[idx].a - songs[idx].b);\n                res++;\n                idx--;\n            }\n\n            if (sum > m) {\n                out.println(-1);\n            } else {\n                out.println(res);\n            }\n        }\n\n        static class pair implements Comparable<TaskC.pair> {\n            int a;\n            int b;\n\n            pair(int a, int b) {\n                this.a = a;\n                this.b = b;\n            }\n\n            public int compareTo(pair p) {\n                return ((this.a - this.b) < (p.a - p.b)) ? -1 : ((this.a - this.b) == (p.a - p.b) ? 0 : 1);\n            }\n\n        }\n\n        static class Scanner {\n            StringTokenizer st;\n            BufferedReader br;\n\n            public Scanner(InputStream s) {\n                br = new BufferedReader(new InputStreamReader(s));\n            }\n\n            public String next() throws IOException {\n                while (st == null || !st.hasMoreTokens()) {\n                    st = new StringTokenizer(br.readLine());\n                }\n                return st.nextToken();\n            }\n\n            public int nextInt() throws IOException {\n                return Integer.parseInt(next());\n            }\n\n        }\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author \\/\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n\n            TaskC.pair[] songs = new TaskC.pair[n];\n            long sum = 0;\n            for (int i = 0; i < n; i++) {\n                songs[i] = new TaskC.pair(in.nextInt(), in.nextInt());\n                sum += songs[i].a;\n            }\n            Arrays.sort(songs);\n\n            int res = 0;\n            int idx = n - 1;\n            while (sum > m) {\n                if (idx < 0) {\n                    break;\n                }\n                sum -= (songs[idx].a - songs[idx].b);\n\n                res++;\n                idx--;\n            }\n\n            if (sum > m) {\n                out.println(-1);\n            } else {\n                out.println(res);\n            }\n        }\n\n        static class pair implements Comparable<TaskC.pair> {\n            int a;\n            int b;\n\n            pair(int a, int b) {\n                this.a = a;\n                this.b = b;\n            }\n\n            public int compareTo(TaskC.pair p) {\n                return (this.a - this.b) - (p.a - p.b);\n            }\n\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "index": 615, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int n;\n    static long TotalTime;\n    static Problem[] problems;\n    static StringBuilder sb;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        sb = new StringBuilder();\n        n = sc.nextInt();\n        TotalTime = sc.nextLong();\n        problems = new Problem[n];\n        for (int i = 0; i < n; i++) {\n            problems[i] = new Problem(sc.nextInt(), sc.nextLong(), i);\n        }\n        Arrays.sort(problems);\n        long num = -1;\n        long high = n;\n        long low = 0;\n        int iter = 0;\n        while (high - low > 1) {\n            num = (high + low) / 2;\n            if (test(num, false)) {\n                low = num;\n            } else {\n                high = num;\n            }\n        }\n        if (test(high, false)) {\n            num = high;\n        } else {\n            num = low;\n        }\n        test(num, true);\n        System.out.print(sb);\n    }\n\n    public static boolean test(long num, boolean print) {\n        int count = 0;\n        long sum = 0L;\n        if (print) {\n            sb.append(num + \"\\n\" + num + \"\\n\");\n        }\n        for (int i = 0; i < n && count < num; i++) {\n            if (problems[i].a >=  num) {\n                count++;\n                sum += problems[i].t;\n                if (print) {\n                    sb.append((problems[i].index + 1) + \" \");\n                }\n            }\n        }\n        return (count == num) && (sum <= TotalTime);\n    }\n\n    static class Problem implements Comparable<Problem> {\n        int a;\n        long t;\n        int index;\n\n        @Override\n        public int compareTo(Problem p) {\n            return Long.compare(t, p.t);\n        }\n        public Problem(int a, long t, int index) {\n            this.a = a;\n            this.t = t;\n            this.index = index;\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            this.br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastScanner(Reader in) {\n            this.br = new BufferedReader(in);\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.getStackTrace();\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n\n        public long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextLong();\n            }\n            return a;\n        }\n\n        public String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n    static int n;\n     static long TotalTime;\n    static Problem[] problems;\n    static StringBuilder sb;\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        sb = new StringBuilder();\n        n = sc.nextInt();\n        TotalTime = sc.nextLong();\n        problems = new Problem[n];\n        for (int i = 0; i < n; i++) {\n            problems[i] = new Problem (sc.nextInt(), sc.nextLong(), i);\n        }\n        Arrays.sort(problems);\n        long num = -1;\n        long high = n;\n        long low = 0;\n        int iter = 0;\n        while (high - low > 1) {\n            num = (high + low) / 2;\n            if (test(num, false)) {\n                low = num;\n            }\n            else {\n                high = num;\n            }\n        }\n        if (test(high, false))\n            num = high;\n        else\n            num = low;\n        test(num, true);\n        System.out.print(sb);\n    }\n\n    public static boolean test (long num, boolean print) {\n        int count = 0;\n        long sum = 0L;\n        if (print) sb.append(num + \"\\n\" + num + \"\\n\");\n        for (int i = 0; i < n && count < num; i++) {\n            if (problems[i].a >= num) {\n                count++;\n                sum += problems[i].t;\n                if (print) sb.append((problems[i].index + 1) + \" \");\n            }\n        }\n        return (count == num) && (sum <= TotalTime);\n    }\n\n    public static class Problem implements Comparable<Problem>  {\n        int a;\n        long t;\n        int index;\n        \n        public int compareTo(Problem o) {\n          return Long.compare(t, o.t);\n        }\n        public Problem (int a, long t, int index) {\n            this.a = a;\n            this.t = t;\n            this.index = index;\n        }\n    }\n\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n\n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextLong();\n            }\n            return a;\n        }\n    }\n}", "index": 616, "complexity": 4}
{"back-translation": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Solution {\n\n    private static int[] a;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt(), m = sc.nextInt();\n\n        a = new int[101];\n        for (int i = 0; i < m; i++) {\n            int type = sc.nextInt();\n            a[type] = a[type] + 1;\n        }\n\n        int lo = 1, hi = 100, max = 0;\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (check(n, mid)) {\n                max = mid;\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        System.out.println(max);\n    }\n\n    public static boolean check(int n, int target) {\n        int result = 0;\n        for (int i = 0; i < a.length; i++) {\n            result = (result + a[i] / target);\n        }\n        return result >= n;\n    }\n}", "src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Solution {\n\n    private static int[] a;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt(), m = sc.nextInt();\n\n        a = new int[101];\n        for (int i = 0; i < m; i++) {\n            int type = sc.nextInt();\n            a[type] = a[type] + 1;\n        }\n\n        int lo=1, hi=100, max=0;\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo)/2;\n            if (check(n, mid)) {\n                max = mid;\n                lo = mid+1;\n            } else {\n                hi = mid -1;\n            }\n        }\n        System.out.println(max);\n    }\n\n    public static boolean check(int n, int target) {\n        int result = 0;\n        for (int i=0; i <a.length; i++) {\n            result = result + (a[i] / target);\n        }\n        if (result >= n) {return true;}\n        return false;\n    }\n}", "index": 617, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Winner {\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n            token = null;\n        }\n\n        public String next() {\n            while (token == null || !token.hasMoreTokens()) {\n                try {\n                    token = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n    static class card {\n        String s;\n        int l;\n        public card(String s, int i) {\n            this.s = s;\n            this.l = i;\n        }\n    }\n    static class sort implements Comparator<card> {\n        public int compare(card o1, card o2) {\n            if (o1.l != o2.l)\n                return (o1.l - o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[]) {\n        List<Long> l = new ArrayList<>();\n        for (int i = 0; i < a.length; i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for (int i = 0; i < a.length; i++)\n            a[i] = l.get(i);\n    }\n\n    /*static long gcd(long a, long b) {\n    if (b == 0)\n    return a;\n    else\n    return gcd(b, a % b);\n    }\n    static boolean valid(int i, int j, int r, int c) {\n    if (i < r && i >= 0 && j < c && j >= 0)\n    return true;\n    else\n    return false;\n    }*/\n    static class Pair {\n        int a;\n        int b;\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n    public static void main(String[] args) {\n        InputReader sc = new InputReader(System.in);\n        int n = sc.nextInt();\n        HashMap<String, Integer> m = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            String t = sc.next();\n            if (m.containsKey(t))\n                m.put(t, m.get(t) + 1);\n            else\n                m.put(t, 1);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            String t = sc.next();\n            if (m.containsKey(t) && m.get(t) > 0) {\n                m.put(t, m.get(t) - 1);\n                ans++;\n            }\n        }\n        System.out.println(n - ans);\n    }\n}", "src": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    /*static long gcd(long a,long b)\n    {\n    if(b==0)\n    return a;\n    else\n    return gcd(b,a%b);\n    }\n    static boolean valid(int i,int j,int r,int c)\n    {\n    if(i<r && i>=0 && j<c && j>=0)\n    return true;\n    else\n    return false;\n    }*/\n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "index": 618, "complexity": 4}
{"back-translation": "public class AlternativeString {\n    static void alternateSort(int arr[], int n) {\n        Arrays.sort(arr);\n        int i = 0, j = n-1;\n        while (i < j) {\n            System.out.print(arr[j--] + \" \");\n            System.out.print(arr[i++] + \" \");\n        }\n        if (n % 2 != 0) System.out.print(arr[i]);\n    }\n    public static void main(String[] args) {\n        int arr[] = {1, 12, 4, 6, 7, 10};\n        int n = arr.length;\n        alternateSort(arr, n);\n    }\n}", "src": "\n// Java program to print an array in alternate \n// sorted manner \nimport\njava.io.*; \nimport\njava.util.Arrays; \n\nclass\nAlternativeString \n{ \n\n// Function to print alternate sorted values \n\nstatic\nvoid\nalternateSort(\nint\narr[], \nint\nn) \n\n{ \n\nArrays.sort(arr); \n\n\n// Printing the last element of array \n\n// first and then first element and then \n\n// second last element and then second \n\n// element and so on. \n\nint\ni = \n0\n, j = n-\n1\n; \n\nwhile\n(i < j) { \n\nSystem.out.print(arr[j--] + \n\" \"\n); \n\nSystem.out.print(arr[i++] + \n\" \"\n); \n\n} \n\n\n// If the total element in array is odd \n\n// then print the last middle element. \n\nif\n(n % \n2\n!= \n0\n) \n\nSystem.out.print(arr[i]); \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, \n4\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nalternateSort(arr, n); \n\n} \n} \n/*This code is contributed by Prakriti Gupta*/", "index": 620, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\nimport static java.lang.System.in;\n\npublic class Main {\n    public static void main(String[] args)throws IOException{\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] point = new int[n][];\n        for(int i=0;i<n;i++) point[i] = new int[]{sc.nextInt(),sc.nextInt()};\n        Arrays.sort(point,(a,b)->((a[0]-a[1])-(b[0]-b[1])));\n        TreeMap<Integer,Integer> tm = new TreeMap<>();\n        int ans = 0;\n        for(int i=n-1;i>=0;i--){\n            int x = point[i][0], w = point[i][1];\n            Map.Entry<Integer,Integer> cur = tm.ceilingEntry(x+w);\n            int curRes;\n            if(cur==null) curRes = 1;\n            else curRes = cur.getValue()+1;\n            ans = Math.max(ans,curRes);\n            Map.Entry<Integer,Integer> upper = tm.ceilingEntry(x-w);\n            if(upper==null||upper.getValue()<curRes) tm.put(x-w,curRes);\n            //Integer key = tm.\n        }\n        System.out.println(ans);\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\nimport static java.lang.System.in;\n\npublic class Main {\n    public static void main(String[] args)throws IOException{\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] point = new int[n][];\n        for(int i=0;i<n;i++) point[i] = new int[]{sc.nextInt(),sc.nextInt()};\n        Arrays.sort(point,(a,b)->((a[0]-a[1])-(b[0]-b[1])));\n        TreeMap<Integer,Integer> tm = new TreeMap<>();\n        int ans = 0;\n        for(int i=n-1;i>=0;i--){\n            int x = point[i][0], w = point[i][1];\n            Map.Entry<Integer,Integer> cur =  tm.ceilingEntry(x+w);\n            int curRes;\n            if(cur==null) curRes = 1;\n            else curRes = cur.getValue()+1;\n            ans = Math.max(ans,curRes);\n            Map.Entry<Integer,Integer> upper = tm.ceilingEntry(x-w);\n            if(upper==null||upper.getValue()<curRes) tm.put(x-w,curRes);\n            //Integer key = tm.\n        }\n        System.out.println(ans);\n    }\n}\n", "index": 621, "complexity": 4}
{"back-translation": "class FractionalKnapSack { static class ItemValue { Double cost; double wt, val, ind; public ItemValue(int wt, int val, int ind) { this.wt = wt; this.val = val; this.ind = ind; cost = new Double(val / wt); } } public static void main(String[] args) { int[] wt = {10, 40, 20, 30}; int[] val = {60, 40, 100, 120}; int capacity = 50; double maxValue = getMaxValue(wt, val, capacity); System.out.println(\"Maximum value we can obtain = \" + maxValue); } private static double getMaxValue(int[] wt, int[] val, int capacity) { ItemValue[] iVal = new ItemValue[wt.length]; for (int i = 0; i < wt.length; i++) { iVal[i] = new ItemValue(wt[i], val[i], i); } Arrays.sort(iVal, new Comparator<ItemValue>() { public int compare(ItemValue o1, ItemValue o2) { return o2.cost.compareTo(o1.cost); } }); double totalValue = 0d; for (ItemValue i: iVal) { int curWt = (int) i.wt; int curVal = (int) i.val; if (capacity - curWt >= 0) { capacity = capacity - curWt; totalValue += curVal; } else { double fraction = ((double)capacity / (double)curWt); totalValue += (curVal * fraction); capacity = (int)(capacity - (curWt * fraction)); break; } } return totalValue; } }", "src": "\n// Java program to solve fractional Knapsack Problem \nimport\njava.util.Arrays; \nimport\njava.util.Comparator; \n\n// Greedy approach \npublic\nclass\nFractionalKnapSack \n{ \n\n// Time complexity O(n log n) \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\n[] wt = {\n10\n, \n40\n, \n20\n, \n30\n}; \n\nint\n[] val = {\n60\n, \n40\n, \n100\n, \n120\n}; \n\nint\ncapacity = \n50\n; \n\n\ndouble\nmaxValue = getMaxValue(wt, val, capacity); \n\nSystem.out.println(\n\"Maximum value we can obtain = \"\n+ \n\nmaxValue); \n\n\n} \n\n\n// function to get maximum value \n\nprivate\nstatic\ndouble\ngetMaxValue(\nint\n[] wt, \n\nint\n[] val, \nint\ncapacity) \n\n{ \n\nItemValue[] iVal = \nnew\nItemValue[wt.length]; \n\n\nfor\n(\nint\ni = \n0\n; i < wt.length; i++) \n\n{ \n\niVal[i] = \nnew\nItemValue(wt[i], val[i], i); \n\n} \n\n\n//sorting items by value; \n\nArrays.sort(iVal, \nnew\nComparator<ItemValue>() \n\n{ \n\n@Override\n\npublic\nint\ncompare(ItemValue o1, ItemValue o2) \n\n{ \n\nreturn\no2.cost.compareTo(o1.cost) ; \n\n} \n\n}); \n\n\n\ndouble\ntotalValue = 0d; \n\n\nfor\n(ItemValue i: iVal) \n\n{ \n\n\nint\ncurWt = (\nint\n) i.wt; \n\nint\ncurVal = (\nint\n) i.val; \n\n\nif\n(capacity - curWt >= \n0\n) \n\n{ \n\n// this weight can be picked while \n\ncapacity = capacity-curWt; \n\ntotalValue += curVal; \n\n\n} \n\nelse\n\n{ \n\n// item cant be picked whole \n\ndouble\nfraction = ((\ndouble\n)capacity/(\ndouble\n)curWt); \n\ntotalValue += (curVal*fraction); \n\ncapacity = (\nint\n)(capacity - (curWt*fraction)); \n\nbreak\n; \n\n} \n\n\n\n} \n\n\nreturn\ntotalValue; \n\n} \n\n\n// item value class \n\nstatic\nclass\nItemValue \n\n{ \n\nDouble cost; \n\ndouble\nwt, val, ind; \n\n\n// item value function \n\npublic\nItemValue(\nint\nwt, \nint\nval, \nint\nind) \n\n{ \n\nthis\n.wt = wt; \n\nthis\n.val = val; \n\nthis\n.ind = ind; \n\ncost = \nnew\nDouble(val/wt ); \n\n} \n\n} \n} ", "index": 625, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n    public static void main(String ar[]) throws Exception\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        String s1[]=br.readLine().split(\" \");\n        int n=Integer.parseInt(s1[0]);\n        long x=Long.parseLong(s1[1]);\n        long y=Long.parseLong(s1[2]);\n        long S=0;\n        long mod=1000000007;\n        B a[]=new B[n];\n        TreeMap<Long,Long> tm=new TreeMap<Long,Long>();\n        long ans[]=new long[n];\n        for(int i=0;i<n;i++)\n        {\n            String s2[]=br.readLine().split(\" \");\n            long l=Long.parseLong(s2[0]);\n            long r=Long.parseLong(s2[1]);\n            B b1=new B(l,r);\n            a[i]=b1;\n        }\n        Arrays.sort(a,new The_Comp());\n        for(int i=0;i<n;i++)\n        {\n            long l=a[i].x;\n            long r=a[i].y;\n            if(tm.floorKey(l-1)!=null)\n            {\n                long u=tm.floorKey(l-1);\n                long v=l;\n                if((v-u)*y<x)\n                { ans[i]=((r-u)*y)%mod; \n                    if(tm.get(u)>1)\n                        tm.put(u,tm.get(u)-1);\n                    else\n                        tm.remove(u); \n                }\n                else\n                { ans[i]=(x+(r-l)*y)%mod; }\n            }\n            else\n                ans[i]=(x+(r-l)*y)%mod;\n            S=(S+ans[i])%mod;\n            if(tm.containsKey(r))\n                tm.put(r,1+tm.get(r));\n            else\n                tm.put(r,(long)1);\n        }\n        System.out.println(S);\n    }\n}\n\nclass The_Comp implements Comparator<B>\n{\n    public int compare(B b1,B b2)\n    {\n        if(b1.x>b2.x)\n            return 1;\n        else if(b1.x==b2.x)\n        {\n            if(b1.y>b2.y)\n                return 1;\n            else if(b1.y==b2.y)\n                return 0;\n            else\n                return -1;\n        }\n        else\n            return -1;\n    }\n}\nclass B\n{\n    long x=(long)1;\n    long y=(long)1;\n    public B(long l1,long l2)\n    { x=l1;  y=l2; }\n}", "src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            long x=Long.parseLong(s1[1]);\n            long y=Long.parseLong(s1[2]);\n            long S=0;\n            long mod=1000000007;\n            B a[]=new B[n];\n            TreeMap<Long,Long> tm=new TreeMap<Long,Long>();\n            long ans[]=new long[n];\n            for(int i=0;i<n;i++)\n            {\n              String s2[]=br.readLine().split(\" \");\n              long l=Long.parseLong(s2[0]);\n              long r=Long.parseLong(s2[1]);\n              B b1=new B(l,r);\n              a[i]=b1;\n            }\n            Arrays.sort(a,new The_Comp());\n            \n            for(int i=0;i<n;i++)\n            {\n                  long l=a[i].x;\n                  long r=a[i].y;\n                  if(tm.floorKey(l-1)!=null)\n                  {\n                        long u=tm.floorKey(l-1);\n                        long v=l;\n                        if((v-u)*y<x)\n                        { ans[i]=((r-u)*y)%mod; \n                          if(tm.get(u)>1)\n                           tm.put(u,tm.get(u)-1);\n                          else\n                          tm.remove(u); \n                        }\n                        else\n                        { ans[i]=(x+(r-l)*y)%mod; }\n                  }\n                  else\n                   ans[i]=(x+(r-l)*y)%mod;\n                  S=(S+ans[i])%mod;\n                  if(tm.containsKey(r))\n                   tm.put(r,1+tm.get(r));\n                  else\n                   tm.put(r,(long)1);\n            }\n            System.out.println(S);\n      }\n}\n\n\nclass The_Comp implements Comparator<B>\n{\n      public int compare(B b1,B b2)\n      {\n            if(b1.x>b2.x)\n             return 1;\n            else if(b1.x==b2.x)\n            {\n            if(b1.y>b2.y)\n             return 1;\n            else if(b1.y==b2.y)\n             return 0;\n            else\n             return -1;\n            }\n            else\n             return -1;\n      }\n}\nclass B\n{\n      long x=(long)1;\n      long y=(long)1;\n      public B(long l1,long l2)\n      { x=l1;  y=l2; }\n}", "index": 626, "complexity": 4}
{"back-translation": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class p1096f {\n    static long MOD = 998244353;\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        BIT invert = new BIT(n+5);\n        BIT neg = new BIT(n+5);\n        long res = 0;\n        int[] arr = new int[n];\n        boolean[] has = new boolean[n+1];\n        long num1 = 0;\n        for(int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n            if(arr[i] != -1) {\n                res += invert.read(n+5)-invert.read(arr[i]);\n                res %= MOD;\n                invert.update(arr[i], 1);\n                has[arr[i]] = true;\n            } else num1++;\n        }\n        if(num1 == 0) {\n            System.out.println(res);\n            return;\n        }\n        for(int i = 1; i <= n; i++) if(!has[i]) neg.update(i, 1);\n        long invertNum1 = modInv(num1, MOD);\n        res += ((num1*(num1-1))%MOD)*modInv(4, MOD);\n        res %= MOD;\n        long cnt = 0;\n        for(int i = 0; i < n; i++) {\n            if(arr[i] == -1) {\n                cnt++;\n                continue;\n            }\n            res += (((neg.read(n+5)-neg.read(arr[i]))*cnt)%MOD)*invertNum1;\n            res %= MOD;\n        }\n        cnt = 0;\n        for(int i = n-1; i >= 0; i--) {\n            if(arr[i] == -1) {\n                cnt++;\n                continue;\n            }\n            res += (((neg.read(arr[i]))*cnt)%MOD)*invertNum1;\n            res %= MOD;\n        }\n        System.out.println(res);\n    }\n    \n    static class BIT {\n        int n;\n        int[] tree;\n        public BIT(int n) {\n            this.n = n;\n            tree = new int[n + 1];\n        }\n\n        int read(int i) {\n            int sum = 0;\n            while (i > 0) {\n                sum += tree[i];\n                i -= i & -i;\n            }\n            return sum;\n        }\n\n        void update(int i, int val) {\n            while (i <= n) {\n                tree[i] += val;\n                i += i & -i;\n            }\n        }\n    }\n\n    static long modInv(long x, long mod) {\n        return (BigInteger.valueOf(x).modInverse(BigInteger.valueOf(mod))).longValue();\n    }\n\n    static long modInv(long a, long b, long y0, long y1, long q0, long q1) {\n        long y2 = y0 - y1*q0;\n        return b == 0 ? y2 : modInv(b, a % b, y1, y2, q1, a / b);\n    }\n    \n    static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }\n    static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n}", "src": "\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author Andy Phan\n */\npublic class p1096f {\n    static long MOD = 998244353;\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        BIT invert = new BIT(n+5);\n        BIT neg = new BIT(n+5);\n        long res = 0;\n        int[] arr = new int[n];\n        boolean[] has = new boolean[n+1];\n        long num1 = 0;\n        for(int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n            if(arr[i] != -1) {\n                res += invert.read(n+5)-invert.read(arr[i]);\n                res %= MOD;\n                invert.update(arr[i], 1);\n                has[arr[i]] = true;\n            } else num1++;\n        }\n        if(num1 == 0) {\n            System.out.println(res);\n            return;\n        }\n        for(int i = 1; i <= n; i++) if(!has[i]) neg.update(i, 1);\n        long invertNum1 = modInv(num1, MOD);\n        res += ((num1*(num1-1))%MOD)*modInv(4, MOD);\n        res %= MOD;\n        long cnt = 0;\n        for(int i = 0; i < n; i++) {\n            if(arr[i] == -1) {\n                cnt++;\n                continue;\n            }\n            res += (((neg.read(n+5)-neg.read(arr[i]))*cnt)%MOD)*invertNum1;\n            res %= MOD;\n        }\n        cnt = 0;\n        for(int i = n-1; i >= 0; i--) {\n            if(arr[i] == -1) {\n                cnt++;\n                continue;\n            }\n            res += (((neg.read(arr[i]))*cnt)%MOD)*invertNum1;\n            res %= MOD;\n        }\n        System.out.println(res);\n    }\n    \n    //@\n    static class BIT {\n            int n;\n            int[] tree;\n            public BIT(int n) {\n                    this.n = n;\n                    tree = new int[n + 1];\n            }\n\n            int read(int i) {\n                    int sum = 0;\n                    while (i > 0) {\n                            sum += tree[i];\n                            i -= i & -i;\n                    }\n                    return sum;\n            }\n\n            void update(int i, int val) {\n                    while (i <= n) {\n                            tree[i] += val;\n                            i += i & -i;\n                    }\n            }\n            //$\n    }\n\n    \n    //@\n    // Computes the modular inverse of x\n    // Returns 0 if the GCD of x and mod is not 1\n    // O(log n)  :  Can be converted to use BigIntegers\n    static long modInv(long x, long mod) {\n        return (BigInteger.valueOf(x).modInverse(BigInteger.valueOf(mod))).longValue();\n    }\n\n    static long modInv(long a, long b, long y0, long y1, long q0, long q1) {\n            long y2 = y0 - y1*q0;\n            return b == 0 ? y2 : modInv(b, a % b, y1, y2, q1, a / b);\n    }\n    \n    //@\n    static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }\n    static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n\n}\n", "index": 627, "complexity": 4}
{"back-translation": "import java.util.Arrays;\n\nclass GFG {\n\n    static int minCost(int[] coin, int n, int k) {\n        Arrays.sort(coin);\n        int coins_needed = (int) Math.ceil(1.0 * n / (k + 1));\n        int ans = 0;\n        for (int i = 0; i <= coins_needed - 1; i++) {\n            ans += coin[i];\n        }\n        return ans;\n    }\n\n    public static void main(String[] arg) {\n        int[] coin = {8, 5, 3, 10, 2, 1, 15, 25};\n        int n = coin.length;\n        int k = 3;\n        System.out.print(minCost(coin, n, k));\n    }\n}", "src": "\n// Java program to acquire \n// all n coins \nimport\njava.util.Arrays; \n\nclass\nGFG \n{ \n\n\n// function to calculate min cost \n\nstatic\nint\nminCost(\nint\ncoin[], \n\nint\nn, \nint\nk) \n\n{ \n\n\n// sort the coins value \n\nArrays.sort(coin); \n\n\n// calculate no. of \n\n// coins needed \n\nint\ncoins_needed = (\nint\n)Math.ceil(\n1.0\n* \n\nn / (k + \n1\n)); \n\n\n// calculate sum of \n\n// all selected coins \n\nint\nans = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i <= coins_needed - \n1\n; \n\ni++) \n\nans += coin[i]; \n\n\nreturn\nans; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ncoin[] = { \n8\n, \n5\n, \n3\n, \n10\n, \n\n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\nint\nk = \n3\n; \n\n\nSystem.out.print(minCost(coin, n, k)); \n\n} \n} \n\n// This code is contributed \n// by Anant Agarwal. ", "index": 628, "complexity": 4}
{"back-translation": "ERROR", "src": "// discussed with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF915E {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint q = Integer.parseInt(br.readLine());\n\t\tTreeMap<Integer, Integer> mp = new TreeMap<>();\n\t\tint ans = 0;\n\t\twhile (q-- > 0) {\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\tint l = Integer.parseInt(st.nextToken()) - 1;\n\t\t\tint r = Integer.parseInt(st.nextToken());\n\t\t\tint t = Integer.parseInt(st.nextToken());\n\t\t\tMap.Entry<Integer, Integer> e;\n\t\t\tint l_, r_;\n\t\t\tif (t == 1) {\n\t\t\t\tif ((e = mp.floorEntry(l)) != null && (r_ = e.getValue()) >= l) {\n\t\t\t\t\tl_ = e.getKey();\n\t\t\t\t\tans -= r_ - l_;\n\t\t\t\t\tl = l_;\n\t\t\t\t\tr = Math.max(r, r_);\n\t\t\t\t}\n\t\t\t\twhile ((e = mp.higherEntry(l)) != null && (l_ = e.getKey()) <= r) {\n\t\t\t\t\tr_ = e.getValue();\n\t\t\t\t\tans -= r_ - l_;\n\t\t\t\t\tr = Math.max(r, r_);\n\t\t\t\t\tmp.remove(l_);\n\t\t\t\t}\n\t\t\t\tans += r - l;\n\t\t\t\tmp.put(l, r);\n\t\t\t} else {\n\t\t\t\tr_ = l;\n\t\t\t\tif ((e = mp.floorEntry(l)) != null && (r_ = e.getValue()) > l) {\n\t\t\t\t\tl_ = e.getKey();\n\t\t\t\t\tif (l_ < l)\n\t\t\t\t\t\tmp.put(l_, l);\n\t\t\t\t\telse\n\t\t\t\t\t\tmp.remove(l_);\n\t\t\t\t\tans -= r_ - l;\n\t\t\t\t}\n\t\t\t\twhile ((e = mp.higherEntry(l)) != null && (l_ = e.getKey()) < r) {\n\t\t\t\t\tr_ = e.getValue();\n\t\t\t\t\tmp.remove(l_);\n\t\t\t\t\tans -= r_ - l_;\n\t\t\t\t}\n\t\t\t\tif (r_ > r) {\n\t\t\t\t\tmp.put(r, r_);\n\t\t\t\t\tans += r_ - r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpw.println(n - ans);\n\t\t}\n\t\tpw.close();\n\t}\n}\n", "index": 630, "complexity": 4}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeMap;\nimport java.util.Map;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CGlassCarving solver = new CGlassCarving();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CGlassCarving {\n        public void solve(int testNumber, FastReader s, PrintWriter out) {\n            TreeMap<Long, Integer> mapH = new TreeMap<>();\n            TreeMap<Long, Integer> mapV = new TreeMap<>();\n            TreeMap<Long, Integer> hDiff = new TreeMap<>();\n            TreeMap<Long, Integer> vDiff = new TreeMap<>();\n            long width = s.nextInt();\n            long height = s.nextInt();\n            mapH.put(0L, 1);\n            mapV.put(0L, 1);\n            mapV.put(width, 1);\n            mapH.put(height, 1);\n            vDiff.put(width, 1);\n            hDiff.put(height, 1);\n            long maxV = height;\n            long maxH = width;\n            int n = s.nextInt();\n            for (int i = 0; i < n; i++) {\n                char ch = s.nextCharacter();\n                long cut = s.nextInt();\n                if (ch == 'H') {\n                    Long next = mapH.higherKey(cut);\n                    Long prev = mapH.lowerKey(cut);\n                    Long diff = next - prev;\n                    int freq = hDiff.get(diff);\n                    if (freq == 1) {\n                        hDiff.remove(diff);\n                    } else {\n                        hDiff.put(diff, freq - 1);\n                    }\n                    hDiff.put(next - cut, hDiff.getOrDefault(next - cut, 0) + 1);\n                    hDiff.put(cut - prev, hDiff.getOrDefault(cut - prev, 0) + 1);\n                    mapH.put(cut, mapH.getOrDefault(cut, 0) + 1);\n                } else {\n                    Long next = mapV.higherKey(cut);\n                    Long prev = mapV.lowerKey(cut);\n                    Long diff = next - prev;\n                    int freq = vDiff.get(diff);\n                    if (freq == 1) {\n                        vDiff.remove(diff);\n                    } else {\n                        vDiff.put(diff, freq - 1);\n                    }\n                    vDiff.put(next - cut, vDiff.getOrDefault(next - cut, 0) + 1);\n                    vDiff.put(cut - prev, vDiff.getOrDefault(cut - prev, 0) + 1);\n                    mapV.put(cut, mapV.getOrDefault(cut, 0) + 1);\n                }\n\n                out.println(hDiff.lastKey() * vDiff.lastKey());\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public char nextCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeMap;\nimport java.util.Map;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Ribhav\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CGlassCarving solver = new CGlassCarving();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CGlassCarving {\n        public void solve(int testNumber, FastReader s, PrintWriter out) {\n            TreeMap<Long, Integer> mapH = new TreeMap<>();\n            TreeMap<Long, Integer> mapV = new TreeMap<>();\n            TreeMap<Long, Integer> hDiff = new TreeMap<>();\n            TreeMap<Long, Integer> vDiff = new TreeMap<>();\n            long width = s.nextInt();\n            long height = s.nextInt();\n            mapH.put(0L, 1);\n            mapV.put(0L, 1);\n            mapV.put(width, 1);\n            mapH.put(height, 1);\n            vDiff.put(width, 1);\n            hDiff.put(height, 1);\n            long maxV = height;\n            long maxH = width;\n            int n = s.nextInt();\n            for (int i = 0; i < n; i++) {\n                char ch = s.nextCharacter();\n                long cut = s.nextInt();\n                if (ch == 'H') {\n                    Long next = mapH.higherKey(cut);\n                    Long prev = mapH.lowerKey(cut);\n                    Long diff = next - prev;\n                    int freq = hDiff.get(diff);\n                    if (freq == 1) {\n                        hDiff.remove(diff);\n                    } else {\n                        hDiff.put(diff, freq - 1);\n                    }\n                    hDiff.put(next - cut, hDiff.getOrDefault(next - cut, 0) + 1);\n                    hDiff.put(cut - prev, hDiff.getOrDefault(cut - prev, 0) + 1);\n                    mapH.put(cut, mapH.getOrDefault(cut, 0) + 1);\n                } else {\n                    Long next = mapV.higherKey(cut);\n                    Long prev = mapV.lowerKey(cut);\n                    Long diff = next - prev;\n                    int freq = vDiff.get(diff);\n                    if (freq == 1) {\n                        vDiff.remove(diff);\n                    } else {\n                        vDiff.put(diff, freq - 1);\n                    }\n                    vDiff.put(next - cut, vDiff.getOrDefault(next - cut, 0) + 1);\n                    vDiff.put(cut - prev, vDiff.getOrDefault(cut - prev, 0) + 1);\n                    mapV.put(cut, mapV.getOrDefault(cut, 0) + 1);\n                }\n\n                out.println(hDiff.lastKey() * vDiff.lastKey());\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public char nextCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "index": 631, "complexity": 4}
{"back-translation": "import java.util.Arrays;\n\npublic class GFG {\n\n    static void findElements(int[] arr, int n) {\n        Arrays.sort(arr);\n\n        for (int i = 0; i < n - 2; i++)\n            System.out.print(arr[i] + \" \");\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {2, -6, 3, 5, 1};\n        int n = arr.length;\n\n        findElements(arr, n);\n    }\n}", "src": "\n// Sorting based Java program to find \n// all elements in array which have \n// atleast two greater elements itself. \nimport\njava.util.*; \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n2\n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n,\n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n\n} \n} \n\n// This code is contributed by Sahil_Bansall ", "index": 632, "complexity": 4}
{"back-translation": "import java.util.StringTokenizer;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.TreeSet;\nimport java.io.InputStream;\nimport java.io.FileReader;\nimport java.util.TreeMap;\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\n\npublic class Main {\n\n    static void insert(TreeMap<Integer, Integer> map, int v, int d) {\n        if (!map.containsKey(v)) map.put(v, 0);\n        map.put(v, d + map.get(v));\n        if (map.get(v) == 0) map.remove(v);\n    }\n\n    static void cut(TreeSet<Integer> cuts, TreeMap<Integer, Integer> segments, int v) {\n        int upper = cuts.higher(v), lower = cuts.lower(v);\n        insert(segments, upper - lower, -1);\n        insert(segments, upper - v, 1);\n        insert(segments, v - lower, 1);\n        cuts.add(v);\n    }\n\n    public static void main(String[] args) throws Throwable {\n        Scanner sc = new Scanner(System.in);\n        int w = sc.nextInt(), h = sc.nextInt(), n = sc.nextInt();\n        TreeSet<Integer> vCuts = new TreeSet<>(), hCuts = new TreeSet<>();\n        TreeMap<Integer, Integer> vSegments = new TreeMap<>(), hSegments = new TreeMap<>();\n        vCuts.add(0);\n        vCuts.add(w);\n        hCuts.add(0);\n        hCuts.add(h);\n        insert(vSegments, w, 1);\n        insert(hSegments, h, 1);\n        StringBuilder sb = new StringBuilder();\n        while (n-- > 0) {\n            if (sc.next().equals(\"H\"))\n                cut(hCuts, hSegments, sc.nextInt());\n            else\n                cut(vCuts, vSegments, sc.nextInt());\n            sb.append(1L * hSegments.lastKey() * vSegments.lastKey() + \"\\n\");\n        }\n        System.out.println(sb);\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(String file) throws FileNotFoundException {\n            br = new BufferedReader(new FileReader(file));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public int[] nexIntArray() throws Throwable {\n            st = new StringTokenizer(br.readLine());\n            int[] a = new int[st.countTokens()];\n            for (int i = 0; i < a.length; i++) a[i] = nextInt();\n            return a;\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tstatic void insert(TreeMap<Integer, Integer>map,int v,int d)\n\t{\n\t\tif(!map.containsKey(v))map.put(v, 0);\n\t\tmap.put(v, d+map.get(v));\n\t\tif(map.get(v)==0)map.remove(v);\n\t}\n\t\n\tstatic void cut(TreeSet<Integer> cuts, TreeMap<Integer, Integer>segments,int v)\n\t{\n\t\tint upper = cuts.higher(v) , lower = cuts.lower(v);\n\t\tinsert(segments, upper-lower, -1);\n\t\tinsert(segments, upper-v, 1);\n\t\tinsert(segments, v-lower, 1);\n\t\tcuts.add(v);\n\t}\n\t\n\tpublic static void main(String[] args) throws Throwable {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint w = sc.nextInt(), h = sc.nextInt() , n = sc.nextInt();\n\t\tTreeSet<Integer> vCuts = new TreeSet<>() , hCuts = new TreeSet<>();\n\t\tTreeMap<Integer, Integer> vSegments = new TreeMap<>() , hSegments = new TreeMap<>();\n\t\tvCuts.add(0);vCuts.add(w);\n\t\thCuts.add(0);hCuts.add(h);\n\t\tinsert(vSegments, w, 1);\n\t\tinsert(hSegments, h, 1);\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(n-->0)\n\t\t{\n\t\t\tif(sc.next().equals(\"H\"))\n\t\t\t\tcut(hCuts, hSegments, sc.nextInt());\n\t\t\telse\n\t\t\t\tcut(vCuts, vSegments, sc.nextInt());\n\t\t\tsb.append(1l*hSegments.lastKey() * vSegments.lastKey() + \"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s) {br = new BufferedReader(new InputStreamReader(s));}\n\t\tpublic Scanner(String file) throws FileNotFoundException {br = new BufferedReader(new FileReader(file));}\n\t\tpublic String next() throws IOException {while (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();}\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\t\tpublic int[] nexIntArray() throws Throwable {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint[] a = new int[st.countTokens()];\n\t\t\tfor (int i = 0; i < a.length; i++)a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\t}\n}", "index": 633, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[] args){\n        try {\n            new Main().solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    ArrayList<Edge>[] edge;\n    int n, m, cnt = 0;\n    int ord;\n    int[] order;\n    int[] vis;\n    Edge[] e;\n\n    private void solve() throws Exception{\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n        n = in.nextInt();\n        m = in.nextInt();\n        edge = new ArrayList[n + 1];\n        e = new Edge[m];\n        vis = new int[n + 1];\n        order = new int[n + 1];\n\n        for(int i = 1; i <= n; i++){\n            edge[i] = new ArrayList<>();\n        }\n\n        for(int i = 1; i <= m; i++){\n            int s = in.nextInt(), t = in.nextInt(), c = in.nextInt();\n            edge[s].add(new Edge(s, t, c, i));\n        }\n\n        int l = 0, r = 1000000000;\n        while (l < r) {\n            int mid = (l + r) >>> 1;\n            if(judge(mid, false)) r = mid;\n            else l = mid + 1;\n        }\n\n        out.print(l + \" \");\n        judge(l, true);\n\n        Arrays.sort(e, 0, cnt, Comparator.comparingInt(x -> x.id));\n\n        int ans = 0;\n        int[] a = new int[m];\n        for(int i = 0; i < cnt; i++){\n            if(order[e[i].s] < order[e[i].t]) a[ans++] = e[i].id;\n        }\n\n        out.println(ans);\n        for(int i = 0; i < ans; i++){\n            out.print(a[i] + \" \");\n        }\n\n        out.println();\n        out.flush();\n    }\n\n    boolean judge(int min, boolean mod){\n        Arrays.fill(vis, 0);\n        cycle = false;\n\n        for(int i = 1; i <= n; i++){\n            if(vis[i] == 0){\n                dfs(i, min, mod);\n                if(cycle) return false;\n            }\n        }\n        return true;\n    }\n\n    boolean cycle = false;\n\n    void dfs(int cur, int min, boolean mod){\n        if(cycle) return;\n\n        vis[cur] = 1;\n        for (Edge e : edge[cur]) {\n            if (e.c <= min) {\n                if (mod) this.e[cnt++] = e;\n                continue;\n            }\n            if (vis[e.t] == 1) {\n                cycle = true;\n                return;\n            }\n            else if (vis[e.t] == 0) dfs(e.t, min, mod);\n        }\n\n        vis[cur] = 2;\n        if (mod) order[cur] = ord++;\n    }\n}\n\nclass Edge{\n    int s, t, c, id;\n\n    Edge(int a, int b, int c, int d){\n        s = a;\n        t = b;\n        this.c = c;\n        id = d;\n    }\n}\n\nclass InputReader{\n    StreamTokenizer tokenizer;\n\n    public InputReader(InputStream stream){\n        tokenizer = new StreamTokenizer(new BufferedReader(new InputStreamReader(stream)));\n        tokenizer.ordinaryChars(33, 126);\n        tokenizer.wordChars(33, 126);\n    }\n\n    public String next() throws IOException {\n        tokenizer.nextToken();\n        return tokenizer.sval;\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public boolean hasNext() throws IOException {\n        int res = tokenizer.nextToken();\n        tokenizer.pushBack();\n        return res != tokenizer.TT_EOF;\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[] args){\n        try {\n            new Main().solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    ArrayList<Edge>[]edge;\n    int n,m,cnt=0;\n    int ord;\n    int[]order;int[]vis;\n    Edge[] e;\n    private void solve() throws Exception{\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        n=in.nextInt();m=in.nextInt();\n        edge=new ArrayList[n+1];\n        e=new Edge[m];\n        vis=new int[n+1];\n        order=new int[n+1];\n        for(int i=1;i<=n;i++){\n            edge[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++){\n            int s=in.nextInt(),t=in.nextInt(),c=in.nextInt();\n            edge[s].add(new Edge(s,t,c,i));\n        }\n        int l=0,r=1000000000;\n        while (l<r){\n            int mid=(l+r)>>>1;\n            if(judge(mid,false))r=mid;\n            else l=mid+1;\n        }\n        out.print(l+\" \");\n        judge(l,true);\n        Arrays.sort(e,0,cnt,Comparator.comparingInt(x->x.id));\n        int ans=0;\n        int[]a=new int[m];\n        for(int i=0;i<cnt;i++){\n            if(order[e[i].s]<order[e[i].t])a[ans++]=e[i].id;\n        }\n        out.println(ans);\n        for(int i=0;i<ans;i++){\n            out.print(a[i]+\" \");\n        }\n        out.println();\n        out.flush();\n    }\n    boolean judge(int min,boolean mod){\n        Arrays.fill(vis,0);\n        cycle=false;\n        for(int i=1;i<=n;i++){\n            if(vis[i]==0){\n                dfs(i,min,mod);\n                if(cycle)return false;\n            }\n        }\n        return true;\n    }\n    boolean cycle=false;\n    void dfs(int cur,int min,boolean mod){\n        if(cycle)return;\n        vis[cur]=1;\n        for(Edge e:edge[cur]){\n            if(e.c<=min){\n                if(mod)this.e[cnt++]=e;\n                continue;\n            }\n            if(vis[e.t]==1){\n                cycle=true;return;\n            }\n            else if(vis[e.t]==0)dfs(e.t,min,mod);\n        }\n        vis[cur]=2;\n        if(mod)order[cur]=ord++;\n    }\n}\nclass Edge{\n    int s,t,c,id;\n    Edge(int a,int b,int c,int d){\n        s=a;t=b;this.c=c;id=d;\n    }\n}\nclass InputReader{\n    StreamTokenizer tokenizer;\n    public InputReader(InputStream stream){\n        tokenizer=new StreamTokenizer(new BufferedReader(new InputStreamReader(stream)));\n        tokenizer.ordinaryChars(33,126);\n        tokenizer.wordChars(33,126);\n    }\n    public String next() throws IOException {\n        tokenizer.nextToken();\n        return tokenizer.sval;\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public boolean hasNext() throws IOException {\n        int res=tokenizer.nextToken();\n        tokenizer.pushBack();\n        return res!=tokenizer.TT_EOF;\n    }\n}", "index": 634, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class A4 {\n\n    public BufferedReader input;\n    public PrintWriter output;\n    public StringTokenizer stoken = new StringTokenizer(\"\");\n\n    public static void main(String[] args) throws IOException {\n        new A4();\n    }\n\n    A4() throws IOException {\n        input = new BufferedReader(new InputStreamReader(System.in));\n        output = new PrintWriter(System.out);\n        run();\n        input.close();\n        output.close();\n    }\n\n    private void run() throws IOException {\n        int n = Math.toIntExact(nextLong());\n        int m = Math.toIntExact(nextLong());\n        int[] coor = new int[n + 1];\n        int[] ss = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            coor[i] = Math.toIntExact(nextLong());\n        }\n        coor[n] = 1000000000;\n        Arrays.sort(coor);\n        for (int i = 0; i < m; i++) {\n            long x1 = nextLong();\n            long x2 = nextLong();\n            nextLong();\n            if (x1 == 1 && x2 >= coor[0]) {\n                int l = 0;\n                int r = n + 1;\n                while (r - l > 1) {\n                    int mi = (r + l) / 2;\n                    if (coor[mi] > x2) {\n                        r = mi;\n                    } else {\n                        l = mi;\n                    }\n                }\n                ss[l]++;\n            }\n        }\n        long[] ans = new long[n + 1];\n        ans[n] = ss[n] + n;\n        long min = ans[n];\n        for (int i = n - 1; i > -1; i--) {\n            ans[i] = ans[i + 1] - 1 + ss[i];\n            if (ans[i] < min) {\n                min = ans[i];\n            }\n        }\n        System.out.println(min);\n    }\n\n    private Long nextLong() throws NumberFormatException, IOException {\n        return Long.parseLong(nextString());\n    }\n\n    private String nextString() throws IOException {\n        while (!stoken.hasMoreTokens()) {\n            String st = input.readLine();\n            stoken = new StringTokenizer(st);\n        }\n        return stoken.nextToken();\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class A4 {\n\n    public BufferedReader input;\n    public PrintWriter output;\n    public StringTokenizer stoken = new StringTokenizer(\"\");\n\n    public static void main(String[] args) throws IOException {\n        new A4();\n    }\n\n    A4() throws IOException {\n        input = new BufferedReader(new InputStreamReader(System.in));\n        output = new PrintWriter(System.out);\n        run();\n        input.close();\n        output.close();\n    }\n\n    private void run() throws IOException {\n        int n = Math.toIntExact(nextLong());\n        int m = Math.toIntExact(nextLong());\n        int[] coor = new int[n + 1];\n        int[] ss = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            coor[i] = Math.toIntExact(nextLong());\n        }\n        coor[n] = 1000000000;\n        Arrays.sort(coor);\n        for (int i = 0; i < m; i++) {\n            long x1 = nextLong();\n            long x2 = nextLong();\n            nextLong();\n            if (x1 == 1 && x2 >= coor[0]) {\n                int l = 0;\n                int r = n + 1;\n                while (r - l > 1) {\n                    int mi = (r + l) / 2;\n                    if (coor[mi] > x2) {\n                        r = mi;\n                    } else {\n                        l = mi;\n                    }\n                }\n                ss[l]++;\n            }\n        }\n        long[] ans = new long[n + 1];\n        ans[n] = ss[n] + n;\n        long min = ans[n];\n        for (int i = n - 1; i > -1; i--) {\n            ans[i] = ans[i + 1] - 1 + ss[i];\n            if (ans[i] < min) {\n                min = ans[i];\n            }\n        }\n        System.out.println(min);\n    }\n\n    private Long nextLong() throws NumberFormatException, IOException {\n        return Long.parseLong(nextString());\n    }\n\n    private String nextString() throws IOException {\n        while (!stoken.hasMoreTokens()) {\n            String st = input.readLine();\n            stoken = new StringTokenizer(st);\n        }\n        return stoken.nextToken();\n    }\n}", "index": 636, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Solution\n{\n\tpublic static void main(String[] args) { new Solution(); }\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint t, n;\n\tint[] a;\n\t\n\tSolution()\n\t{\n\t\tt = in.nextInt();\n\t\twhile (t-- > 0)\n\t\t{\n\t\t\ta = new int[n = in.nextInt()];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = in.nextInt();\n\t\t\tshuffle(a);\n\t\t\tArrays.sort(a);\n\t\t\tout.println(Math.min(n - 2, a[n - 2] - 1));\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\t\n\tvoid shuffle(int[] x)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint swp = (int) (n * Math.random());\n\t\t\tint tmp = x[swp];\n\t\t\tx[swp] = x[i];\n\t\t\tx[i] = tmp;\n\t\t}\n\t}\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class ayyyyyy\n{\n\tpublic static void main(String[] args) { new ayyyyyy(); }\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint t, n;\n\tint[] a;\n\t\n\tayyyyyy()\n\t{\n\t\tt = in.nextInt();\n\t\twhile (t --> 0)\n\t\t{\n\t\t\ta = new int[n = in.nextInt()];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = in.nextInt();\n\t\t\tshuffle(a);\n\t\t\tArrays.sort(a);\n\t\t\tout.println(Math.min(n-2, a[n-2]-1));\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\t\n\tvoid shuffle(int[] x)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint swp = (int)(n*Math.random());\n\t\t\tint tmp = x[swp];\n\t\t\tx[swp] = x[i];\n\t\t\tx[i] = tmp;\n\t\t}\n\t}\n}", "index": 637, "complexity": 4}
{"back-translation": "import java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        long totalBlocks = 0;\n        long a[] = new long[n];\n        for (int i = 0; i < n; ++i) {\n            a[i] = sc.nextLong();\n            totalBlocks += a[i];\n        }\n\n        Arrays.sort(a);\n\n        long selected = 0;\n        for (int i = 0; i < n; ++i) {\n            if (a[i] > selected)\n                selected++;\n        }\n\n        long leftCols = a[n - 1] - selected;\n        long remBlocks = totalBlocks - leftCols - n;\n\n        System.out.print(remBlocks);\n    }\n}", "src": "import java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        long totalBlocks = 0;\n        long a[] = new long[n];\n        for(int i = 0; i < n; ++i) {\n            a[i] = sc.nextLong();\n            totalBlocks += a[i];\n        }\n\n        Arrays.sort(a);\n\n        long selected = 0;\n        for(int i = 0; i < n; ++i) {\n            if(a[i] > selected)\n                selected++;\n        }\n\n        long leftCols = a[n - 1] - selected;\n        long remBlocks = totalBlocks - leftCols - n;\n\n        System.out.print(remBlocks);\n    }\n}", "index": 639, "complexity": 4}
{"back-translation": "import java.util.Arrays; public class GFG { static int MaxTotalRectangleArea(int[] a, int n) { Arrays.sort(a); int sum = 0; boolean flag = false; int len = 0; for (int i = 0; i < n; i++) { if ((a[i] == a[i + 1] || a[i] - a[i + 1] == 1) && !flag) { flag = true; len = a[i + 1]; i++; } else if ((a[i] == a[i + 1] || a[i] - a[i + 1] == 1) && (flag)) { sum = sum + a[i + 1] * len; flag = false; i++; } } return sum; } public static void main(String[] args) { int[] a = { 10, 10, 10, 10, 11, 10, 11, 10, 9, 9, 8, 8 }; int n = a.length; System.out.print(MaxTotalRectangleArea(a, n)); } }", "src": "\n// Java code to find sum of \n// all area rectangle possible \nimport\njava.io.*; \nimport\njava.util.Arrays; \n\nclass\nGFG \n{ \n\n// Function to find \n\n// area of rectangles \n\nstatic\nint\nMaxTotalRectangleArea(\nint\n[]a, \n\nint\nn) \n\n{ \n\n\n// sorting the array in \n\n// descending order \n\nArrays.sort(a); \n\n\n// store the final sum of \n\n// all the rectangles area \n\n// possible \n\nint\nsum = \n0\n; \n\nboolean\nflag = \nfalse\n; \n\n\n// temporary variable to \n\n// store the length of rectangle \n\nint\nlen = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n// Selecting the length of \n\n// rectangle so that difference \n\n// between any two number is 1 \n\n// only. Here length is selected \n\n// so flag is set \n\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n!flag) \n\n{ \n\n// flag is set means \n\n// we have got length of \n\n// rectangle \n\nflag = \ntrue\n; \n\n\n// length is set to \n\n// a[i+1] so that if \n\n// a[i] a[i+1] is less \n\n// than by 1 then also \n\n// we have the correct \n\n// choice for length \n\nlen = a[i + \n1\n]; \n\n\n// incrementing the counter \n\n// one time more as we have \n\n// considered a[i+1] element \n\n// also so. \n\ni++; \n\n} \n\n\n// Selecting the width of rectangle \n\n// so that difference between any \n\n// two number is 1 only. Here width \n\n// is selected so now flag is again \n\n// unset for next rectangle \n\nelse\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n(flag)) \n\n{ \n\n// area is calculated for \n\n// rectangle \n\nsum = sum + a[i + \n1\n] * len; \n\n\n// flag is set false \n\n// for another rectangle \n\n// which we can get from \n\n// elements in array \n\nflag = \nfalse\n; \n\n\n// incrementing the counter \n\n// one time more as we have \n\n// considered a[i+1] element \n\n// also so. \n\ni++; \n\n} \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\n[]a = { \n10\n, \n10\n, \n10\n, \n10\n, \n\n11\n, \n10\n, \n11\n, \n10\n, \n\n9\n, \n9\n, \n8\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxTotalRectangleArea(a, n)); \n\n} \n} \n// This code is contributed by \n// Manish Shaw(manishshaw1) ", "index": 640, "complexity": 4}
{"back-translation": "ERROR", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskG solver = new TaskG();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskG {\n        static int[][] g;\n        static int n;\n        static int[] a;\n        static int[][] edges;\n        static long[] dp;\n        static long[] dpPathToRootWithDetours;\n        static int time = 0;\n        static int[] appearance;\n        static int[] firstAppearance;\n        static int[] depth;\n\n        public static void dfs(int i, int parE) {\n            firstAppearance[i] = time;\n            appearance[time++] = i;\n            dp[i] = a[i];\n            for (int eIndex : g[i]) {\n                if (eIndex == parE) continue;\n                int child = i ^ edges[eIndex][0] ^ edges[eIndex][1];\n                dfs(child, eIndex);\n                appearance[time++] = i;\n                dp[i] += Math.max(dp[child] - edges[eIndex][2] * 2, 0);\n            }\n        }\n\n        public static void dfs2(int i, int parE) {\n            if (i == 0) {\n                dpPathToRootWithDetours[i] = dp[i];\n            } else {\n                int par = i ^ edges[parE][0] ^ edges[parE][1];\n                depth[i] = depth[par] + 1;\n                dpPathToRootWithDetours[i] = dpPathToRootWithDetours[par] - Math.max(0, dp[i] - edges[parE][2] * 2);\n                dpPathToRootWithDetours[i] -= edges[parE][2];\n                dpPathToRootWithDetours[i] += dp[i];\n\n                long myPathWeight = Math.max(dp[i] - edges[parE][2] * 2, 0);\n                long change = dp[par] - myPathWeight - edges[parE][2] * 2;\n                change = Math.max(change, 0);\n                dp[i] += change;\n            }\n            for (int eIndex : g[i]) {\n                if (eIndex == parE) continue;\n                dfs2(i ^ edges[eIndex][0] ^ edges[eIndex][1], eIndex);\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.NextInt();\n            int q = in.NextInt();\n            a = in.NextIntArray(n);\n            edges = new int[n - 1][3];\n            {\n                long[] count = new long[n];\n                for (int i = 0; i < n - 1; i++) {\n                    int u = in.NextInt() - 1;\n                    int v = in.NextInt() - 1;\n                    int w = in.NextInt();\n                    edges[i][0] = u;\n                    edges[i][1] = v;\n                    edges[i][2] = w;\n                    count[u]++;\n                    count[v]++;\n                }\n\n                g = new int[n][];\n                for (int i = 0; i < n; i++) {\n                    g[i] = new int[(int) count[i]];\n                }\n                for (int i = 0; i < n - 1; i++) {\n                    for (int j = 0; j < 2; j++) {\n                        g[edges[i][j]][(int) --count[edges[i][j]]] = i;\n                    }\n                }\n            }\n            dp = new long[n];\n            dpPathToRootWithDetours = new long[n];\n            depth = new int[n];\n            firstAppearance = new int[n];\n            appearance = new int[(n - 1) * 2 + 1];\n            dfs(0, -1);\n            dfs2(0, -1);\n            GraphLowestCommonAncestor.LCA lca = GraphLowestCommonAncestor.createLCA(appearance, firstAppearance, depth);\n            firstAppearance = null;\n            depth = null;\n            appearance = null;\n            edges = null;\n            g = null;\n            for (int i = 0; i < q; i++) {\n                int u = in.NextInt() - 1;\n                int v = in.NextInt() - 1;\n                int lcaI = lca.getLCA(u, v);\n                long res = dpPathToRootWithDetours[u] + dpPathToRootWithDetours[v] - 2 * dpPathToRootWithDetours[lcaI] + dp[lcaI];\n                out.println(res);\n            }\n        }\n\n    }\n\n    static class MinRangeSparseTable implements ISearchInRange {\n        private final int[][] sparseTables;\n        private final long[] array;\n        private final boolean reverseOrdered;\n\n        public MinRangeSparseTable(long[] array, boolean reverseOrdered) {\n            this.reverseOrdered = reverseOrdered;\n            this.array = array;\n            int LCALength = IntegerExtension.getNumberOfBits(array.length);\n            sparseTables = new int[LCALength][];\n            sparseTables[0] = new int[array.length];\n            for (int i = 0; i < array.length; i++) {\n                sparseTables[0][i] = i;\n            }\n            for (int i = 1; i < LCALength; i++) {\n                int size = 1 << i;\n                int jumpSize = 1 << (i - 1);\n                sparseTables[i] = new int[sparseTables[0].length - size + 1];\n                for (int j = 0; j < sparseTables[i].length; j++) {\n                    sparseTables[i][j] = min(sparseTables[i - 1][j], sparseTables[i - 1][j + jumpSize]);\n                }\n            }\n        }\n\n        private int min(int a, int b) {\n            return ((array[a] < array[b]) ^ reverseOrdered) ? a : b;\n        }\n\n\n        public Pair<Long, Long> queryIndexValueInRange(long l, long r) {\n            int size = (int) (r - l + 1);\n            int LCAIndex = IntegerExtension.getNumberOfBits(size) - 1;\n            int sizeNeeded = 1 << LCAIndex;\n            int res = min(sparseTables[LCAIndex][(int) l], sparseTables[LCAIndex][(int) (r - sizeNeeded + 1)]);\n            return new Pair<>((long) res, array[res]);\n        }\n\n        public MinRangeSparseTable(long[] array) {\n            this(array, false);\n        }\n\n    }\n\n    static class GraphLowestCommonAncestor {\n        public static GraphLowestCommonAncestor.LCA createLCA(int[] appearances, final int[] firstAppearance, final int[] depth) {\n            return new GraphLowestCommonAncestor.LCA_MinRangeSparseTable(appearances, firstAppearance, depth);\n        }\n\n        public interface LCA {\n            int getLCA(int a, int b);\n\n        }\n\n        private static class LCA_MinRangeSparseTable implements GraphLowestCommonAncestor.LCA {\n            private final MinRangeSparseTable minRangeSparseTable;\n            private final int[] firstAppearance;\n            private final int[] indexToNode;\n\n            public LCA_MinRangeSparseTable(int[] appearances, final int[] firstAppearance, final int[] depth) {\n                this.firstAppearance = firstAppearance;\n                this.indexToNode = appearances;\n                long[] depthOrder = new long[appearances.length];\n                for (int i = 0; i < depthOrder.length; i++) {\n                    depthOrder[i] = depth[appearances[i]];\n                }\n                minRangeSparseTable = new MinRangeSparseTable(depthOrder);\n            }\n\n\n            public int getLCA(int a, int b) {\n                a = firstAppearance[a];\n                b = firstAppearance[b];\n                int l = Math.min(a, b), r = Math.max(a, b);\n                return indexToNode[(int) (long) minRangeSparseTable.queryIndexValueInRange(l, r).first];\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] NextIntArray(int n) {\n            return NextIntArray(n, 0);\n        }\n\n        public int[] NextIntArray(int n, int offset) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = NextInt() + offset;\n            }\n            return a;\n        }\n\n    }\n\n    static interface ISearchInRange {\n    }\n\n    static class Pair<T1, T2> {\n        public T1 first;\n        public T2 second;\n\n        public Pair(T1 f, T2 s) {\n            first = f;\n            second = s;\n        }\n\n    }\n\n    static class IntegerExtension {\n        public static int getNumberOfBits(long i) {\n            return 64 - Long.numberOfLeadingZeros(i);\n        }\n\n    }\n}\n\n", "index": 641, "complexity": 4}
{"back-translation": "import java.util.HashMap;\nimport java.util.Scanner;\npublic class Median_Segments_general {\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\tSystem.out.println(func(n, m, arr) - func(n, m + 1, arr));\n\t}\n\n\tpublic static long func(int n, int m, int[] arr) {\n\t\tHashMap<Long, Integer> map = new HashMap<>();\n\t\tmap.put((long) 0, 1);\n\t\tlong sum = 0;\n\t\tlong res = 0;\n\t\tlong add = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr[i] < m) {\n\t\t\t\tsum--;\n\t\t\t\tif (map.containsKey(sum)) {\n\t\t\t\t\tadd -= map.get(sum);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (map.containsKey(sum)) {\n\t\t\t\t\tadd += map.get(sum);\n\t\t\t\t}\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\tres += add;\n\t\t\tif (map.containsKey(sum)) {\n\t\t\t\tmap.put(sum, map.get(sum) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(sum, 1);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}", "src": "//package fourninetysixDiv3;\nimport java.util.HashMap;\nimport java.util.Scanner;\npublic class Median_Segments_general {\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\tSystem.out.println(func(n, m, arr)-func(n, m+1, arr));\n\t}\n\tpublic static long func(int n,int m,int[] arr) {\n\t\tHashMap<Long, Integer> map = new HashMap<>();\n\t\tmap.put((long) 0, 1);\n\t\tlong sum = 0;\n\t\tlong res = 0;\n\t\tlong add=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(arr[i]<m) {\n\t\t\t\tsum--;\n\t\t\t\tif(map.containsKey(sum)) {\n\t\t\t\t\tadd-=map.get(sum);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(map.containsKey(sum)) {\n\t\t\t\t\tadd+=map.get(sum);\n\t\t\t\t}\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\tres+=add;\n\t\t\tif(map.containsKey(sum)) {\n\t\t\t\tmap.put(sum, map.get(sum)+1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(sum,1);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n", "index": 642, "complexity": 4}
{"back-translation": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class GenerateBNo {\n\n    static void generatePrintBinary(int n) {\n        Queue<String> q = new LinkedList<String>();\n        q.add(\"1\");\n        while (n-- > 0) {\n            String s1 = q.peek();\n            q.remove();\n            System.out.println(s1);\n            String s2 = s1;\n            q.add(s1 + \"0\");\n            q.add(s2 + \"1\");\n        }\n    }\n\n    public static void main(String[] args) {\n        int n = 10;\n        generatePrintBinary(n);\n    }\n}", "src": "\n//Java program to generate binary numbers from 1 to n \n\nimport\njava.util.LinkedList; \nimport\njava.util.Queue; \n\npublic\nclass\nGenerateBNo \n{ \n\n// This function uses queue data structure to print binary numbers \n\nstatic\nvoid\ngeneratePrintBinary(\nint\nn) \n\n{ \n\n// Create an empty queue of strings \n\nQueue<String> q = \nnew\nLinkedList<String>(); \n\n\n// Enqueue the first binary number \n\nq.add(\n\"1\"\n); \n\n\n// This loops is like BFS of a tree with 1 as root \n\n// 0 as left child and 1 as right child and so on \n\nwhile\n(n-- > \n0\n) \n\n{ \n\n// print the front of queue \n\nString s1 = q.peek(); \n\nq.remove(); \n\nSystem.out.println(s1); \n\n\n// Store s1 before changing it \n\nString s2 = s1; \n\n\n// Append \"0\" to s1 and enqueue it \n\nq.add(s1 + \n\"0\"\n); \n\n\n// Append \"1\" to s2 and enqueue it. Note that s2 contains \n\n// the previous front \n\nq.add(s2 + \n\"1\"\n); \n\n} \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn=\n10\n; \n\ngeneratePrintBinary(n); \n\n} \n} \n//This code is contributed by Sumit Ghosh ", "index": 643, "complexity": 4}
{"back-translation": "class GFG {\n    static int maxSumPairWithDifferenceLessThanK(int arr[], int N, int K) {\n        Arrays.sort(arr);\n        int dp[] = new int[N];\n        dp[0] = 0;\n        for (int i = 1; i < N; i++) {\n            dp[i] = dp[i-1];\n            if (arr[i] - arr[i-1] < K) {\n                if (i >= 2)\n                    dp[i] = Math.max(dp[i], dp[i-2] + arr[i] + arr[i-1]);\n                else\n                    dp[i] = Math.max(dp[i], arr[i] + arr[i-1]);\n            }\n        }\n        return dp[N - 1];\n    }\n    public static void main(String[] args) {\n        int arr[] = {3, 5, 10, 15, 17, 12, 9};\n        int N = arr.length;\n        int K = 4;\n        System.out.println(maxSumPairWithDifferenceLessThanK(arr, N, K));\n    }\n}", "src": "\n// Java program to find maximum pair sum whose \n// difference is less than K \n\nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// method to return maximum sum we can get by \n\n// finding less than K difference pair \n\nstatic\nint\nmaxSumPairWithDifferenceLessThanK(\nint\narr[], \n\nint\nN, \nint\nK) \n\n{ \n\n\n// Sort input array in ascending order. \n\nArrays.sort(arr); \n\n\n// dp[i] denotes the maximum disjoint pair sum \n\n// we can achieve using first i elements \n\nint\ndp[] = \nnew\nint\n[N]; \n\n\n// if no element then dp value will be 0 \n\ndp[\n0\n] = \n0\n; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\n// first give previous value to dp[i] i.e. \n\n// no pairing with (i-1)th element \n\ndp[i] = dp[i-\n1\n]; \n\n\n// if current and previous element can form a pair \n\nif\n(arr[i] - arr[i-\n1\n] < K) \n\n{ \n\n\n// update dp[i] by choosing maximum between \n\n// pairing and not pairing \n\nif\n(i >= \n2\n) \n\ndp[i] = Math.max(dp[i], dp[i-\n2\n] + arr[i] + \n\narr[i-\n1\n]); \n\nelse\n\ndp[i] = Math.max(dp[i], arr[i] + arr[i-\n1\n]); \n\n} \n\n} \n\n\n// last index will have the result \n\nreturn\ndp[N - \n1\n]; \n\n} \n\n\n// Driver code to test above methods \n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n3\n, \n5\n, \n10\n, \n15\n, \n17\n, \n12\n, \n9\n}; \n\nint\nN = arr.length; \n\nint\nK = \n4\n; \n\n\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \n\narr, N, K)); \n\n\n} \n} \n\n//This code is contributed by vt_m. ", "index": 644, "complexity": 4}
{"back-translation": "import java.io.*;import java.util.*;public class p7{static class FastReader{BufferedReader br;StringTokenizer st;public FastReader(){br = new BufferedReader(new InputStreamReader(System.in));}String next(){while (st == null || !st.hasMoreElements()){try{st = new StringTokenizer(br.readLine());}catch (IOException e){e.printStackTrace();}}return st.nextToken();}int nextInt(){return Integer.parseInt(next());}long nextLong(){return Long.parseLong(next());}double nextDouble(){return Double.parseDouble(next());}String nextLine(){String str = \"\";try{str = br.readLine();}catch (IOException e){e.printStackTrace();}return str;}}public static void main(String[] args){FastReader sc = new FastReader();int n = sc.nextInt();int k = sc.nextInt();long one = (long)Math.pow(2, k) - 1;long[] arr = new long[n+1];arr[0] = 0;for(int i=1;i<=n;i++){arr[i] = sc.nextLong();arr[i] ^= arr[i-1];}Map<Long, Long> count = new HashMap<>();for(int i=0;i<=n;i++){Long key = Math.min(arr[i], (arr[i]^one));Long val = count.get(key);if(val==null) val = 0L;count.put(key, val+1);}long num = n;long ans = num*(num+1)/2;for(Map.Entry<Long, Long> ent: count.entrySet()){Long cnt = ent.getValue();long num1 = cnt/2;long num2 = (cnt+1)/2;ans -= ( (num1*(num1-1))/2 );ans -= ( (num2*(num2-1))/2 );}System.out.println(ans);}}", "src": "import java.io.*; \nimport java.util.*; \n\n\npublic class p7{\n\t\n\tstatic class FastReader{ \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n\n\t\tpublic FastReader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n\n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n\n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n\n\t\tlong nextLong() \n\t\t{ \n\t\t\treturn Long.parseLong(next()); \n\t\t} \n\n\t\tdouble nextDouble() \n\t\t{ \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n\n\t\tString nextLine() \n\t\t{ \n\t\t\tString str = \"\"; \n\t\t\ttry\n\t\t\t{ \n\t\t\t\tstr = br.readLine(); \n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{ \n\t\t\t\te.printStackTrace(); \n\t\t\t} \n\t\t\treturn str; \n\t\t} \n\t}\n\n\tpublic static void main(String[] args) \n\t{ \n        FastReader sc = new FastReader(); \n        //PrintWriter out = new PrintWriter(System.out); \n        int n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tlong one = (long)Math.pow(2, k) - 1;\n\t\t\n\t\tlong[] arr = new long[n+1];\n\t\t\n\t\tarr[0] = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tarr[i] = sc.nextLong();\n\t\t\tarr[i] ^= arr[i-1];\n\t\t}\n\n\t\tMap<Long, Long> count = new HashMap<>();\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tLong key = Math.min(arr[i], (arr[i]^one));\n\t\t\tLong val = count.get(key);\n\t\t\tif(val==null) val = 0L;\n\t\t\tcount.put(key, val+1);\n\t\t}\n\n\t\tlong num = n;\n\t\tlong ans = num*(num+1)/2;\n\t\t\n\t\tfor(Map.Entry<Long, Long> ent: count.entrySet()){\n\t\t\t\n\t\t\tLong cnt = ent.getValue();\n\t\t\t\n\t\t\tlong num1 = cnt/2;\n\t\t\tlong num2 = (cnt+1)/2;\n\t\t\t\n\t\t\tans -= ( (num1*(num1-1))/2 );\n\t\t\tans -= ( (num2*(num2-1))/2 );\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t}\n}\n", "index": 645, "complexity": 4}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ReaderFastIO in = new ReaderFastIO(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DConcatenatedMultiples solver = new DConcatenatedMultiples();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DConcatenatedMultiples {\n        public void solve(int testNumber, ReaderFastIO in, PrintWriter out) throws IOException {\n\n            Map<Integer, Integer>[] mapMods = new HashMap[11];\n\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int[] a = in.readArrayInt(n);\n\n            for (int i = 0; i < 11; i++) {\n                mapMods[i] = new HashMap<>();\n            }\n\n            for (int i = 0; i < n; i++) {\n                int pot = getPot(a[i]);\n                mapMods[pot].put(a[i] % k, mapMods[pot].getOrDefault(a[i] % k, 0) + 1);\n            }\n\n            long ct = 0;\n\n            for (int i = 0; i < n; i++) {\n\n                int ownPot = getPot(a[i]);\n                long suffix = a[i] * 10L;\n                for (int j = 1; j <= 10; j++) {\n\n                    int mod = (int) (suffix % k);\n                    int comMod = (k - mod) % k;\n                    int qt = mapMods[j].getOrDefault(comMod, 0);\n\n                    if (j == ownPot && (a[i] % k) == comMod) {\n                        qt--;\n                    }\n\n                    ct += qt;\n\n                    suffix = (suffix * 10L) % k;\n                }\n\n            }\n\n            out.println(ct);\n        }\n\n        public int getPot(int x) {\n\n            int ct = 0;\n\n            while (x != 0) {\n                x /= 10;\n                ct++;\n            }\n\n            return ct;\n        }\n\n    }\n\n    static class ReaderFastIO {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public ReaderFastIO() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public ReaderFastIO(InputStream input) {\n            br = new BufferedReader(new InputStreamReader(input));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreElements()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public int[] readArrayInt(int n) throws IOException {\n\n            int[] array = new int[n];\n\n            for (int i = 0; i < n; i++) {\n                array[i] = nextInt();\n            }\n\n            return array;\n        }\n\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ReaderFastIO in = new ReaderFastIO(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DConcatenatedMultiples solver = new DConcatenatedMultiples();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DConcatenatedMultiples {\n        public void solve(int testNumber, ReaderFastIO in, PrintWriter out) {\n\n            Map<Integer, Integer>[] mapMods = new HashMap[11];\n\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int[] a = in.readArrayInt(n);\n\n            for (int i = 0; i < 11; i++) {\n                mapMods[i] = new HashMap<>();\n            }\n\n            for (int i = 0; i < n; i++) {\n                int pot = getPot(a[i]);\n                mapMods[pot].put(a[i] % k, mapMods[pot].getOrDefault(a[i] % k, 0) + 1);\n            }\n\n            long ct = 0;\n\n            for (int i = 0; i < n; i++) {\n\n                int ownPot = getPot(a[i]);\n                long suffix = a[i] * 10L;\n                for (int j = 1; j <= 10; j++) {\n\n                    int mod = (int) (suffix % k);\n                    int comMod = (k - mod) % k;\n                    int qt = mapMods[j].getOrDefault(comMod, 0);\n\n                    if (j == ownPot && (a[i] % k) == comMod) {\n                        qt--;\n                    }\n\n                    ct += qt;\n\n                    suffix = (suffix * 10L) % k;\n                }\n\n            }\n\n            out.println(ct);\n        }\n\n        public int getPot(int x) {\n\n            int ct = 0;\n\n            while (x != 0) {\n                x /= 10;\n                ct++;\n            }\n\n            return ct;\n        }\n\n    }\n\n    static class ReaderFastIO {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public ReaderFastIO() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public ReaderFastIO(InputStream input) {\n            br = new BufferedReader(new InputStreamReader(input));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] readArrayInt(int n) {\n\n            int[] array = new int[n];\n\n            for (int i = 0; i < n; i++) {\n                array[i] = nextInt();\n            }\n\n            return array;\n        }\n\n    }\n}\n\n", "index": 647, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class TaskA implements Runnable {\n    long m = (int)1e9+7;\n    PrintWriter w;\n    InputReader c;\n    public void run() {\n        c = new InputReader(System.in);\n        w = new PrintWriter(System.out);\n        int n = c.nextInt();\n        int a[] = scanArrayI(n);\n        int maxtime = Integer.MAX_VALUE,ind = -1;\n        for(int i=0;i<n;i++){\n            int time = Integer.MAX_VALUE;\n            if(a[i]<i+1)\n                time = i;\n            else{\n                time = (int)ceil((a[i] - i)/(double)n) * n + i;\n            }\n            if(time<maxtime){\n                maxtime = time;\n                ind = i;\n            }\n        }\n        w.println(ind+1);\n        w.close();\n    }\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static void sortbyColumn(int arr[][], int col){\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    public static class DJSet {\n        public int[] upper;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n\n    public int[] scanArrayI(int n){\n        int a[] = new int[n];\n        for(int i=0;i<n;i++)\n            a[i] = c.nextInt();\n        return a;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        private Scanner sc = new Scanner(System.in);\n\n        public int nextInt() {\n            return sc.nextInt();\n        }\n\n        public long nextLong() {\n            return sc.nextLong();\n        }\n\n        public double nextDouble() { return sc.nextDouble(); }\n\n    }\n\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new TaskA(),", "src": "import org.omg.PortableServer.AdapterActivator;\n\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.net.CookieHandler;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport static java.lang.Math.*;\n\npublic class TaskA implements Runnable {\n    long m = (int)1e9+7;\n    PrintWriter w;\n    InputReader c;\n    public void run() {\n        c = new InputReader(System.in);\n        w = new PrintWriter(System.out);\n        int n = c.nextInt();\n        int a[] = scanArrayI(n);\n        int maxtime = Integer.MAX_VALUE,ind = -1;\n        for(int i=0;i<n;i++){\n            int time = Integer.MAX_VALUE;\n            if(a[i]<i+1)\n                time = i;\n            else{\n                time = (int)ceil((a[i] - i)/(double)n) * n + i;\n            }\n            if(time<maxtime){\n                maxtime = time;\n                ind = i;\n            }\n        }\n        w.println(ind+1);\n        w.close();\n    }\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static void sortbyColumn(int arr[][], int col){\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    public static class DJSet {\n        public int[] upper;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f)    {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n    public void printArray(int[] a){\n        for(int i=0;i<a.length;i++)\n            w.print(a[i]+\" \");\n        w.println();\n    }\n    public int[] scanArrayI(int n){\n        int a[] = new int[n];\n        for(int i=0;i<n;i++)\n            a[i] = c.nextInt();\n        return a;\n    }\n    public long[] scanArrayL(int n){\n        long a[] = new long[n];\n        for(int i=0;i<n;i++)\n            a[i] = c.nextLong();\n        return a;\n    }\n    public void printArray(long[] a){\n        for(int i=0;i<a.length;i++)\n            w.print(a[i]+\" \");\n        w.println();\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new TaskA(),\"TaskA\",1<<26).start();\n    }\n}", "index": 648, "complexity": 4}
{"back-translation": "import java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class BigInteger7 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).compareTo(n) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.compareTo(k) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}\n", "src": "import java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class BigInteger7 {\n    public static void main(String[] args) {\n        //https://codeforces.com/contest/1011/problem/A\n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}\n", "index": 649, "complexity": 4}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\n\npublic class Main {\n    static StreamTokenizer st=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    public static void main(String[] args) {\n        int n=nextInt();\n        int m=nextInt();\n        long b[]=new long[n];\n        long g[]=new long[m];\n        for(int i=0;i<n;i++)\n            b[i]=nextInt();\n        for(int i=0;i<m;i++)\n            g[i]=nextInt();\n        Arrays.sort(b);\n        Arrays.sort(g);\n        if(b[n-1]>g[0])\n            System.out.println(\"-1\");\n        else if(b[n-1]==g[0]){\n            long sum=0;\n            for(int i=0;i<m;i++)\n                sum+=g[i];\n            for(int i=0;i<n-1;i++){\n                sum+=(m*b[i]);\n            }\n            System.out.println(sum);\n        }else{\n            long sum=0;\n            for(int i=0;i<m;i++)\n                sum+=g[i];\n            sum+=b[n-1];\n            sum+=(b[n-2]*(m-1));\n            for(int i=0;i<n-2;i++){\n                sum+=(m*b[i]);\n            }\n            System.out.println(sum);\n        }\n    }\n    static int nextInt(){\n        try {\n            st.nextToken();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return (int)st.nval;\n    }\n}", "src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic StreamTokenizer st=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\tpublic static void main(String[] args) {\n\t\tint n=nextInt();\n\t\tint m=nextInt();\n\t\tlong b[]=new long[n];\n\t\tlong g[]=new long[m];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tb[i]=nextInt();\n\t\tfor(int i=0;i<m;i++)\n\t\t\tg[i]=nextInt();\n\t\tArrays.sort(b);\n\t\tArrays.sort(g);\n\t\tif(b[n-1]>g[0])\n\t\t\tSystem.out.println(\"-1\");\n\t\telse if(b[n-1]==g[0]){\n\t\t\tlong sum=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\tsum+=g[i];\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tsum+=(m*b[i]);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}else{\n\t\t\tlong sum=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\tsum+=g[i];\n\t\t\tsum+=b[n-1];\n\t\t\tsum+=(b[n-2]*(m-1));\n\t\t\tfor(int i=0;i<n-2;i++){\n\t\t\t\tsum+=(m*b[i]);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\tstatic int nextInt(){\n\t\ttry {\n\t\t\tst.nextToken();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (int)st.nval;\n\t}\n}\n", "index": 651, "complexity": 4}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class MicroWorld {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint k = Integer.parseInt(st.nextToken());\n\t\t\n\t\tint[] temp = new int[1000001];\n\t\t\n\t\tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\t\n\t\t\ttemp[Integer.parseInt(st1.nextToken())]++;\n\t\t}\n\t\t\n\t\tint b = k + 1;\n\t\t\n\t\tfor (int i = 1000000; i > 0; i--){\n\t\t\t\n\t\t\tif (temp[i] > 0){\n\t\t\t\tif (b <= k){\n\t\t\t\t\tn -= temp[i];\n\t\t\t\t}\n\t\t\t\tb = 1;\n\t\t\t}else{\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(n);\n\t\t\n\t}\n\n}\n", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class MicroWorld {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint k = Integer.parseInt(st.nextToken());\n\t\t\n\t\tint[] temp = new int[1000001];\n\t\t\n\t\tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\t\n\t\t\ttemp[Integer.parseInt(st1.nextToken())]++;\n\t\t}\n\t\t\n\t\tint b = k + 1;\n\t\t\n\t\tfor (int i = 1000000; i > 0; i--){\n\t\t\t\n\t\t\tif (temp[i] > 0){\n\t\t\t\tif (b <= k){\n\t\t\t\t\tn -= temp[i];\n\t\t\t\t}\n\t\t\t\tb = 1;\n\t\t\t}else{\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(n);\n\t\t\n\t}\n\n}\n", "index": 652, "complexity": 4}
{"back-translation": "class GFG {\n    void find3largest(int[] arr) {\n        Arrays.sort(arr);\n        int n = arr.length;\n        int check = 0, count = 1;\n        for (int i = 1; i <= n; i++) {\n            if (count < 4) {\n                if (check != arr[n - i]) {\n                    System.out.print(arr[n - i] + \" \");\n                    check = arr[n - i];\n                    count++;\n                }\n            } else\n                break;\n        }\n    }\n    public static void main(String[] args) {\n        GFG obj = new GFG();\n        int[] arr = {12, 45, 1, -1, 45, 54, 23, 5, 0, -10};\n        obj.find3largest(arr);\n    }\n}", "src": "\n// Java code to find largest \n// three elements in an array \n\n\nimport\njava.io.*; \nimport\njava.util.Arrays; \n\nclass\nGFG { \n\nvoid\nfind3largest(\nint\n[] arr) \n\n{ \n\nArrays.sort(arr); \n//It uses Tuned Quicksort with \n\n//avg. case Time complexity = O(nLogn) \n\nint\nn = arr.length; \n\nint\ncheck = \n0\n, count = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++){ \n\n\nif\n(count<\n4\n){ \n\nif\n(check!=arr[n-i]) \n\n{ \n\n// to handle duplicate values \n\nSystem.out.print(arr[n-i]+\n\" \"\n); \n\ncheck = arr[n-i]; \n\ncount++; \n\n} \n\n} \n\nelse\n\nbreak\n; \n\n} \n\n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nGFG obj = \nnew\nGFG(); \n\nint\n[] arr={\n12\n,\n45\n,\n1\n,-\n1\n,\n45\n,\n54\n,\n23\n,\n5\n,\n0\n,-\n10\n}; \n\nobj.find3largest(arr); \n\n} \n\n} \n//This code is contibuted by Prashant Malik ", "index": 653, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            try {\n                int n = in.readInt();\n                int[] x = new int[n], w = new int[n];\n                in.readIntArrays(x, w);\n                int[] begin = new int[n], end = new int[n];\n                Arrays.setAll(begin, i -> x[i] - w[i]);\n                Arrays.setAll(end, i -> x[i] + w[i]);\n                int m = ArrayUtils.compress(begin, end).length;\n                int[] dp = new int[m + 1], order = ArrayUtils.order(end);\n                int idx = 0;\n                for (int i = 0; i < m; i++) {\n                    if (i > 0) {\n                        dp[i] = dp[i - 1];\n                    }\n                    while (idx < n && end[order[idx]] == i) {\n                        dp[i] = Math.max(dp[i], dp[begin[order[idx]]] + 1);\n                        idx++;\n                    }\n                }\n                int res = dp[m - 1];\n                out.printLine(res);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    static class ArrayUtils {\n        public static int[] compress(int[]... arrays) {\n            int totalLength = 0;\n            for (int[] array : arrays) {\n                totalLength += array.length;\n            }\n            int[] all = new int[totalLength];\n            int delta = 0;\n            for (int[] array : arrays) {\n                System.arraycopy(array, 0, all, delta, array.length);\n                delta += array.length;\n            }\n            sort(all, IntComparator.DEFAULT);\n            all = unique(all);\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i] = Arrays.binarySearch(all, array[i]);\n                }\n            }\n            return all;\n        }\n\n        public static int[] order(final int[] array) {\n            return sort(createOrder(array.length), (first, second) -> compare(array[first], array[second]));\n        }\n\n        private static int[] createOrder(int size) {\n            return range(0, size);\n        }\n\n        public static int[] unique(int[] array) {\n            return new IntArrayList(array).unique().toArray();\n        }\n\n        public static int[] range(int from, int to) {\n            int[] result = new int[Math.abs(from - to)];\n            int current = from;\n            if (from <= to) {\n                for (int i = 0; i < result.length; i++) {\n                    result[i] = current++;\n                }\n            } else {\n                for (int i = 0; i < result.length; i++) {\n                    result[i] = current--;\n                }\n            }\n            return result;\n        }\n\n        private static int compare(int first, int second) {\n            return Integer.compare(first, second);\n        }\n\n        public static void sort(int[] array, IntComparator comparator) {\n            sort(array, 0, array.length, comparator);\n        }\n\n        public static void sort(int[] array, int from, int to, IntComparator comparator) {\n            if (from == 0 && to == array.length) {\n                new IntArray(array).sort(comparator);\n            } else {\n                new IntArray(array).subList(from, to).sort(comparator);\n            }\n        }\n\n        public static void insertionSort(IntList list, int from, int to, IntComparator comparator) {\n            for (int i = from + 1; i <= to; i++) {\n                int value = list.get(i);\n                for (int j = i - 1; j >= from; j--) {\n                    if (comparator.compare(list.get(j), value) <= 0) {\n                        break;\n                    }\n                    list.swap(j, j + 1);\n                }\n            }\n        }\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n    }\n\n    static interface IntComparator {\n        int compare(int first, int second);\n    }\n\n    static interface IntStream extends Iterable<Integer> {\n        IntIterator intIterator();\n    }\n\n    static interface IntCollection extends IntStream {\n        int size();\n    }\n\n    static interface IntList extends IntReversableCollection {\n        int get(int index);\n        void set(int index, int value);\n        void addAt(int index, int value);\n        void removeAt(int index);\n        void swap(int first, int second);\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static interface OutputWriter {\n        void printLine(int i);\n        void close();\n    }\n\n    static class InputReader {\n        InputStream stream;\n        byte[] buf = new byte[1024];\n        int curChar;\n        int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public void readIntArrays(int[]... arrays) {\n            for (int i = 0; i < arrays[0].length; i++) {\n                for (int j = 0; j < arrays.length; j++) {\n                    arrays[j][i] = readInt();\n                }\n            }\n        }\n\n        private int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        int size;\n        int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntArray c) {\n            this();\n            addAll(c);\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException();\n            }\n            return data[at];\n        }\n\n        public void addAt(int index, int value) {\n        }\n\n        public void removeAt(int index) {\n        }\n\n        public void set(int index, int value) {\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author aryssoncf\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            try {\n                int n = in.readInt();\n                int[] x = new int[n], w = new int[n];\n                in.readIntArrays(x, w);\n                int[] begin = new int[n], end = new int[n];\n                Arrays.setAll(begin, i -> x[i] - w[i]);\n                Arrays.setAll(end, i -> x[i] + w[i]);\n                int m = ArrayUtils.compress(begin, end).length;\n                int[] dp = new int[m + 1], order = ArrayUtils.order(end);\n                int idx = 0;\n                for (int i = 0; i < m; i++) {\n                    if (i > 0) {\n                        dp[i] = dp[i - 1];\n                    }\n                    while (idx < n && end[order[idx]] == i) {\n                        dp[i] = Math.max(dp[i], dp[begin[order[idx]]] + 1);\n                        idx++;\n                    }\n                }\n                int res = dp[m - 1];\n                out.printLine(res);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    static class Sorter {\n        private static final int INSERTION_THRESHOLD = 16;\n\n        private Sorter() {\n        }\n\n        public static void sort(IntList list, IntComparator comparator) {\n            quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,\n                    comparator);\n        }\n\n        private static void quickSort(IntList list, int from, int to, int remaining, IntComparator comparator) {\n            if (to - from < INSERTION_THRESHOLD) {\n                insertionSort(list, from, to, comparator);\n                return;\n            }\n            if (remaining == 0) {\n                heapSort(list, from, to, comparator);\n                return;\n            }\n            remaining--;\n            int pivotIndex = (from + to) >> 1;\n            int pivot = list.get(pivotIndex);\n            list.swap(pivotIndex, to);\n            int storeIndex = from;\n            int equalIndex = to;\n            for (int i = from; i < equalIndex; i++) {\n                int value = comparator.compare(list.get(i), pivot);\n                if (value < 0) {\n                    list.swap(storeIndex++, i);\n                } else if (value == 0) {\n                    list.swap(--equalIndex, i--);\n                }\n            }\n            quickSort(list, from, storeIndex - 1, remaining, comparator);\n            for (int i = equalIndex; i <= to; i++) {\n                list.swap(storeIndex++, i);\n            }\n            quickSort(list, storeIndex, to, remaining, comparator);\n        }\n\n        private static void heapSort(IntList list, int from, int to, IntComparator comparator) {\n            for (int i = (to + from - 1) >> 1; i >= from; i--) {\n                siftDown(list, i, to, comparator, from);\n            }\n            for (int i = to; i > from; i--) {\n                list.swap(from, i);\n                siftDown(list, from, i - 1, comparator, from);\n            }\n        }\n\n        private static void siftDown(IntList list, int start, int end, IntComparator comparator, int delta) {\n            int value = list.get(start);\n            while (true) {\n                int child = ((start - delta) << 1) + 1 + delta;\n                if (child > end) {\n                    return;\n                }\n                int childValue = list.get(child);\n                if (child + 1 <= end) {\n                    int otherValue = list.get(child + 1);\n                    if (comparator.compare(otherValue, childValue) > 0) {\n                        child++;\n                        childValue = otherValue;\n                    }\n                }\n                if (comparator.compare(value, childValue) >= 0) {\n                    return;\n                }\n                list.swap(start, child);\n                start = child;\n            }\n        }\n\n        private static void insertionSort(IntList list, int from, int to, IntComparator comparator) {\n            for (int i = from + 1; i <= to; i++) {\n                int value = list.get(i);\n                for (int j = i - 1; j >= from; j--) {\n                    if (comparator.compare(list.get(j), value) <= 0) {\n                        break;\n                    }\n                    list.swap(j, j + 1);\n                }\n            }\n        }\n\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void set(int index, int value);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public void swap(int first, int second) {\n            if (first == second) {\n                return;\n            }\n            int temp = get(first);\n            set(first, get(second));\n            set(second, temp);\n        }\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n        default public IntList sort(IntComparator comparator) {\n            Sorter.sort(this, comparator);\n            return this;\n        }\n\n        default IntList unique() {\n            int last = Integer.MIN_VALUE;\n            IntList result = new IntArrayList();\n            int size = size();\n            for (int i = 0; i < size; i++) {\n                int current = get(i);\n                if (current != last) {\n                    result.add(current);\n                    last = current;\n                }\n            }\n            return result;\n        }\n\n        default public IntList subList(final int from, final int to) {\n            return new IntList() {\n                private final int shift;\n                private final int size;\n\n                {\n                    if (from < 0 || from > to || to > IntList.this.size()) {\n                        throw new IndexOutOfBoundsException(\"from = \" + from + \", to = \" + to + \", size = \" + size());\n                    }\n                    shift = from;\n                    size = to - from;\n                }\n\n                public int size() {\n                    return size;\n                }\n\n                public int get(int at) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    return IntList.this.get(at + shift);\n                }\n\n                public void addAt(int index, int value) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void removeAt(int index) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void set(int at, int value) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    IntList.this.set(at + shift, value);\n                }\n\n                public IntList compute() {\n                    return new IntArrayList(this);\n                }\n            };\n        }\n\n    }\n\n    static interface IntComparator {\n        IntComparator DEFAULT = Integer::compare;\n\n        int compare(int first, int second);\n\n    }\n\n    static class Range {\n        public static IntList range(int from, int to) {\n            int[] result = new int[Math.abs(from - to)];\n            int current = from;\n            if (from <= to) {\n                for (int i = 0; i < result.length; i++) {\n                    result[i] = current++;\n                }\n            } else {\n                for (int i = 0; i < result.length; i++) {\n                    result[i] = current--;\n                }\n            }\n            return new IntArray(result);\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        IntIterator intIterator();\n\n        default Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public void readIntArrays(int[]... arrays) {\n            for (int i = 0; i < arrays[0].length; i++) {\n                for (int j = 0; j < arrays.length; j++) {\n                    arrays[j][i] = readInt();\n                }\n            }\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public int[] toArray() {\n            int size = size();\n            int[] array = new int[size];\n            int i = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                array[i++] = it.value();\n            }\n            return array;\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public int get(int at) {\n            return data[at];\n        }\n\n        public void addAt(int index, int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void set(int index, int value) {\n            data[index] = value;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static int[] range(int from, int to) {\n            return Range.range(from, to).toArray();\n        }\n\n        public static int[] createOrder(int size) {\n            return range(0, size);\n        }\n\n        public static int[] sort(int[] array, IntComparator comparator) {\n            return sort(array, 0, array.length, comparator);\n        }\n\n        public static int[] sort(int[] array, int from, int to, IntComparator comparator) {\n            if (from == 0 && to == array.length) {\n                new IntArray(array).sort(comparator);\n            } else {\n                new IntArray(array).subList(from, to).sort(comparator);\n            }\n            return array;\n        }\n\n        public static int[] order(final int[] array) {\n            return sort(createOrder(array.length), (first, second) -> Integer.compare(array[first], array[second]));\n        }\n\n        public static int[] unique(int[] array) {\n            return new IntArray(array).unique().toArray();\n        }\n\n        public static int[] compress(int[]... arrays) {\n            int totalLength = 0;\n            for (int[] array : arrays) {\n                totalLength += array.length;\n            }\n            int[] all = new int[totalLength];\n            int delta = 0;\n            for (int[] array : arrays) {\n                System.arraycopy(array, 0, all, delta, array.length);\n                delta += array.length;\n            }\n            sort(all, IntComparator.DEFAULT);\n            all = unique(all);\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i] = Arrays.binarySearch(all, array[i]);\n                }\n            }\n            return all;\n        }\n\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n        public void set(int index, int value) {\n            if (index >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            data[index] = value;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n}\n\n", "index": 654, "complexity": 4}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class MicroWorld {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        Integer[] a = new Integer[n];\n\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n\n        Arrays.sort(a);\n\n        int count = 1;\n        int remaining = n;\n        for (int i = 0; i < n - 1; i++) {\n            if ((int) a[i] == (int) a[i + 1]) {\n                count++;\n                continue;\n            }\n            if ((a[i] + k) >= a[i + 1]) {\n                remaining -= count;\n            }\n            count = 1;\n        }\n        System.out.println(remaining);\n    }\n}\n", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class MicroWorld {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        Integer[] a = new Integer[n];\n\n        st = new StringTokenizer(br.readLine());\n        for(int i=0; i<n; i++){\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n\n        Arrays.sort(a);\n\n        int count = 1;\n        int remaining = n;\n        for(int i=0; i<n-1; i++){\n            if((int)a[i] == (int)a[i+1]){\n                count++;\n                continue;\n            }\n            if((a[i] + k) >= a[i+1]){\n                remaining -= count;\n            }\n            count = 1;\n        }\n        System.out.println(remaining);\n    }\n}\n", "index": 655, "complexity": 4}
{"back-translation": "import java.awt.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(), m = scanner.nextInt();\n        int[] vertical = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            vertical[i] = scanner.nextInt();\n        }\n\n        Arrays.sort(vertical);\n\n\n        ArrayList<Integer> horisontal = new ArrayList<>();\n        int amount = 0;\n        for (int i = 0; i < m; i++) {\n            int x1 = scanner.nextInt(), x2 = scanner.nextInt(), y = scanner.nextInt();\n            if (x1 == 1) {\n                amount++;\n                horisontal.add(x2);\n            }\n        }\n\n        Collections.sort(horisontal);\n\n\n        if (amount == 0) {\n            System.out.println(0);\n            return;\n        }\n\n\n        int minVal = amount, horSize = horisontal.size(), verLen = vertical.length;\n        int h = 0, v = 0;\n\n        for (; v < verLen && h < horSize; ) {\n\n           while (h < horSize && horisontal.get(h) < vertical[v]){\n               h++;\n               amount--;\n           }\n           minVal = Math.min(minVal, amount + v);\n\n            while (h < horSize && v < verLen && horisontal.get(h) >= vertical[v]){\n                minVal = Math.min(minVal, amount + v);\n                v++;\n            }\n\n        }\n\n        if(horisontal.get(horSize - 1) < 1000000000){\n            minVal = Math.min(minVal, v);\n        }\n\n\n\n        System.out.println(minVal);\n\n    }\n}\n", "src": "import java.awt.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(), m = scanner.nextInt();\n        int[] vertical = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            vertical[i] = scanner.nextInt();\n        }\n\n        Arrays.sort(vertical);\n\n\n        ArrayList<Integer> horisontal = new ArrayList<>();\n        int amount = 0;\n        for (int i = 0; i < m; i++) {\n            int x1 = scanner.nextInt(), x2 = scanner.nextInt(), y = scanner.nextInt();\n            if (x1 == 1) {\n                amount++;\n                horisontal.add(x2);\n            }\n        }\n\n        Collections.sort(horisontal);\n\n\n        if (amount == 0) {\n            System.out.println(0);\n            return;\n        }\n\n\n        int minVal = amount, horSize = horisontal.size(), verLen = vertical.length;\n        int h = 0, v = 0;\n\n        for (; v < verLen && h < horSize; ) {\n\n           while (h < horSize && horisontal.get(h) < vertical[v]){\n               h++;\n               amount--;\n           }\n           minVal = Math.min(minVal, amount + v);\n\n            while (h < horSize && v < verLen && horisontal.get(h) >= vertical[v]){\n                minVal = Math.min(minVal, amount + v);\n                v++;\n            }\n\n        }\n\n        if(horisontal.get(horSize - 1) < 1E9){\n            minVal = Math.min(minVal, v);\n        }\n\n\n\n        System.out.println(minVal);\n\n    }\n}\n", "index": 656, "complexity": 4}
{"back-translation": "class GfG {\n    public static int minMaxProduct(int[] arr1, int[] arr2, int n1, int n2) {\n        Arrays.sort(arr1);\n        Arrays.sort(arr2);\n        return arr1[n1 - 1] * arr2[0];\n    }\n    public static void main(String argc[]) {\n        int[] arr1 = new int[]{10, 2, 3, 6, 4, 1};\n        int[] arr2 = new int[]{5, 1, 4, 2, 6, 9};\n        int n1 = 6;\n        int n2 = 6;\n        System.out.println(minMaxProduct(arr1, arr2, n1, n2));\n    }\n}", "src": "\n// Java program to find the \n// to calculate the product \n// of max element of first \n// array and min element of \n// second array \nimport\njava.util.*; \nimport\njava.lang.*; \n\nclass\nGfG \n{ \n\n\n// Function to calculate \n\n// the product \n\npublic\nstatic\nint\nminMaxProduct(\nint\narr1[], \n\nint\narr2[], \n\nint\nn1, \n\nint\nn2) \n\n{ \n\n\n// Sort the arrays to find the \n\n// maximum and minimum elements \n\n// in given arrays \n\nArrays.sort(arr1); \n\nArrays.sort(arr2); \n\n\n// Return product of maximum \n\n// and minimum. \n\nreturn\narr1[n1 - \n1\n] * arr2[\n0\n]; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String argc[]) \n\n{ \n\nint\n[] arr1= \nnew\nint\n[]{ \n10\n, \n2\n, \n3\n, \n\n6\n, \n4\n, \n1\n}; \n\nint\n[] arr2 = \nnew\nint\n[]{ \n5\n, \n1\n, \n4\n, \n\n2\n, \n6\n, \n9\n}; \n\nint\nn1 = \n6\n; \n\nint\nn2 = \n6\n; \n\nSystem.out.println(minMaxProduct(arr1, \n\narr2, \n\nn1, n2)); \n\n} \n} \n\n/*This code is contributed by Sagar Shukla.*/", "index": 657, "complexity": 4}
{"back-translation": "ERROR", "src": "\nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n// Variables to keep track of current sum and minimum sum \n\nint\nsum, min_sum = \n999999\n; \n\n\n// left and right index variables \n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n// variable to keep track of the left and right pair for min_sum \n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n/* Array should have at least two elements*/\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n/* Sort the elements */\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n/*If abs(sum) is less then update the result items*/\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n/* Functions for QuickSort */\n\n\n/* This function takes last element as pivot, \n\nplaces the pivot element at its correct \n\nposition in sorted array, and places all \n\nsmaller (smaller than pivot) to left of \n\npivot and all greater elements to right \n\nof pivot */\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n// index of smaller element \n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n// If current element is smaller than or \n\n// equal to pivot \n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n// swap arr[i] and arr[j] \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n// swap arr[i+1] and arr[high] (or pivot) \n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n/* The main function that implements QuickSort() \n\narr[] --> Array to be sorted, \n\nlow --> Starting index, \n\nhigh --> Ending index */\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n/* pi is partitioning index, arr[pi] is \n\nnow at right place */\n\nint\npi = partition(arr, low, high); \n\n\n// Recursively sort elements before \n\n// partition and after partition \n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n} ", "index": 659, "complexity": 4}
{"back-translation": "class Test { static int mergeSort(int arr[], int array_size) { int temp[] = new int[array_size]; return _mergeSort(arr, temp, 0, array_size - 1); } static int _mergeSort(int arr[], int temp[], int left, int right) { int mid, inv_count = 0; if (right > left) { mid = (right + left) / 2; inv_count = _mergeSort(arr, temp, left, mid); inv_count += _mergeSort(arr, temp, mid + 1, right); inv_count += merge(arr, temp, left, mid + 1, right); } return inv_count; } static int merge(int arr[], int temp[], int left, int mid, int right) { int i, j, k; int inv_count = 0; i = left; j = mid; k = left; while ((i <= mid - 1) && (j <= right)) { if (arr[i] <= arr[j]) { temp[k++] = arr[i++]; } else { temp[k++] = arr[j++]; inv_count = inv_count + (mid - i); } } while (i <= mid - 1) temp[k++] = arr[i++]; while (j <= right) temp[k++] = arr[j++]; for (i = left; i <= right; i++) arr[i] = temp[i]; return inv_count; } public static void main(String[] args) { int arr[] = new int[] { 1, 20, 6, 4, 5 }; System.out.println(\"Number of inversions are \" + mergeSort(arr, 5)); } }", "src": "\n// Java implementation of counting the \n// inversion using merge sort \n\nclass\nTest { \n\n\n/* This method sorts the input array and returns the \n\nnumber of inversions in the array */\n\nstatic\nint\nmergeSort(\nint\narr[], \nint\narray_size) \n\n{ \n\nint\ntemp[] = \nnew\nint\n[array_size]; \n\nreturn\n_mergeSort(arr, temp, \n0\n, array_size - \n1\n); \n\n} \n\n\n/* An auxiliary recursive method that sorts the input array and \n\nreturns the number of inversions in the array. */\n\nstatic\nint\n_mergeSort(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nright) \n\n{ \n\nint\nmid, inv_count = \n0\n; \n\nif\n(right > left) { \n\n/* Divide the array into two parts and call _mergeSortAndCountInv() \n\nfor each of the parts */\n\nmid = (right + left) / \n2\n; \n\n\n/* Inversion count will be the sum of inversions in left-part, right-part \n\nand number of inversions in merging */\n\ninv_count = _mergeSort(arr, temp, left, mid); \n\ninv_count += _mergeSort(arr, temp, mid + \n1\n, right); \n\n\n/*Merge the two parts*/\n\ninv_count += merge(arr, temp, left, mid + \n1\n, right); \n\n} \n\nreturn\ninv_count; \n\n} \n\n\n/* This method merges two sorted arrays and returns inversion count in \n\nthe arrays.*/\n\nstatic\nint\nmerge(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nmid, \nint\nright) \n\n{ \n\nint\ni, j, k; \n\nint\ninv_count = \n0\n; \n\n\ni = left; \n/* i is index for left subarray*/\n\nj = mid; \n/* j is index for right subarray*/\n\nk = left; \n/* k is index for resultant merged subarray*/\n\nwhile\n((i <= mid - \n1\n) && (j <= right)) { \n\nif\n(arr[i] <= arr[j]) { \n\ntemp[k++] = arr[i++]; \n\n} \n\nelse\n{ \n\ntemp[k++] = arr[j++]; \n\n\n/*this is tricky -- see above explanation/diagram for merge()*/\n\ninv_count = inv_count + (mid - i); \n\n} \n\n} \n\n\n/* Copy the remaining elements of left subarray \n\n(if there are any) to temp*/\n\nwhile\n(i <= mid - \n1\n) \n\ntemp[k++] = arr[i++]; \n\n\n/* Copy the remaining elements of right subarray \n\n(if there are any) to temp*/\n\nwhile\n(j <= right) \n\ntemp[k++] = arr[j++]; \n\n\n/*Copy back the merged elements to original array*/\n\nfor\n(i = left; i <= right; i++) \n\narr[i] = temp[i]; \n\n\nreturn\ninv_count; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\nSystem.out.println(\n\"Number of inversions are \"\n+ mergeSort(arr, \n5\n)); \n\n} \n} ", "index": 660, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new PrintStream(System.out));\n        StringTokenizer st = new StringTokenizer(f.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        long[] arrB = new long[n];\n        long[] arrG = new long[m];\n        st=new StringTokenizer(f.readLine());\n        for(int i=0;i<n;i++){\n            arrB[i]=Long.parseLong(st.nextToken());\n        }\n        st=new StringTokenizer(f.readLine());\n        for(int j=0;j<m;j++){\n            arrG[j]=Long.parseLong(st.nextToken());\n        }\n        Arrays.sort(arrB);\n        Arrays.sort(arrG);\n        long ans = 0;\n        for (int i = 0; i < n; i++) { ans = ans + arrB[i] * m; }\n        for (int i = 1; i < m; i++) { ans = ans + arrG[i] - arrB[n - 1]; }\n        if (arrB[n - 1] != arrG[0]) { if (n == 1) { ans = -1; } else { ans = ans + arrG[0] - arrB[n - 2]; } }\n        if (arrB[n - 1] > arrG[0]) { ans = -1; }\n        System.out.println(ans);\n        f.close();\n        out.close();\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new PrintStream(System.out));\n        StringTokenizer st = new StringTokenizer(f.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        long[] arrB = new long[n];\n        long[] arrG = new long[m];\n        st=new StringTokenizer(f.readLine());\n        for(int i=0;i<n;i++){\n            arrB[i]=Long.parseLong(st.nextToken());\n        }\n        st=new StringTokenizer(f.readLine());\n        for(int j=0;j<m;j++){\n            arrG[j]=Long.parseLong(st.nextToken());\n        }\n        Arrays.sort(arrB);\n        Arrays.sort(arrG);\n        long ans = 0;\n//        for (int i = 0; i < n; i++) ans += arrB[i] * m;\n//        for (int i = 0; i < m - 1; i++) ans += arrG[i] - arrB[0];\n//        if (arrB[m - 1] != arrB[0]) {\n//            if (arrB.length == 1) {\n//                ans=-1;\n//            }\n//            else ans += arrG[m - 1] - arrB[1];\n//        }\n//        if (arrG[m-1] < arrB[0]) {\n//            ans=-1;\n//        }\n        for(int i=0;i<n;i++){\n            ans+=arrB[i]*(long)m;\n        }\n        for(int i=1;i<m;i++){\n            ans+=arrG[i]-arrB[n-1];\n        }\n        if(arrB[n-1]!=arrG[0]){\n            if(n==1){\n                ans=-1;\n            }\n            else{\n                //smallest g goes to second to last\n                ans+=arrG[0]-arrB[n-2];\n            }\n        }\n        if(arrB[n-1]>arrG[0]){\n            ans=-1;\n        }\n        System.out.println(ans);\n        f.close();\n        out.close();\n    }\n}", "index": 661, "complexity": 4}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.Collection;\nimport java.util.AbstractList;\nimport java.util.InputMismatchException;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\nimport java.util.NoSuchElementException;\nimport java.util.ConcurrentModificationException;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DPairOfLines solver = new DPairOfLines();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DPairOfLines {\n        private static final int INF = (int) 2e9 + 7;\n        private InputReader in;\n        private PrintWriter out;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            int n = in.nextInt();\n            if (n <= 4) {\n                out.println(\"YES\");\n                return;\n            }\n            TreeList<PairII> list = new TreeList<>();\n            PairII[] a = new PairII[n + 1];\n            for (int i = 1; i <= n; i++) {\n                a[i] = (new PairII(in.nextInt(), in.nextInt()));\n                list.add(a[i]);\n            }\n            PairII pos1 = new PairII(INF, INF);\n            PairII pos2 = new PairII(INF, INF);\n            for (int i = 1; i <= 5; i++) {\n                for (int j = i + 1; j <= 5; j++) {\n                    for (int k = j + 1; k <= 5; k++) {\n                        int x1 = a[i].first;\n                        int y1 = a[i].second;\n                        int x2 = a[j].first;\n                        int y2 = a[j].second;\n                        int x = a[k].first;\n                        int y = a[k].second;\n                        long s = (long) (y2 - y1) * x + (long) (x1 - x2) * y + ((long) x2 * y1 - (long) x1 * y2);\n                        if (s == 0) {\n                            pos1 = a[i];\n                            pos2 = a[j];\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    static interface OrderedIterator<E> extends Iterator<E> {\n    }\n\n    static class PairII implements Comparable<PairII> {\n        public int first;\n        public int second;\n        public PairII(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n            PairII pair = (PairII) o;\n            return first == pair.first && second == pair.second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(PairII o) {\n            int value = Integer.compare(first, o.first);\n            if (value != 0) {\n                return value;\n            }\n            return Integer.compare(second, o.second);\n        }\n    }\n\n    static class TreeList<E> extends AbstractList<E> {\n    }\n\n    static class InputReader extends InputStream {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n    }\n}\n", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.Collection;\nimport java.util.AbstractList;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\nimport java.util.NoSuchElementException;\nimport java.util.ConcurrentModificationException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author cunbidun\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DPairOfLines solver = new DPairOfLines();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DPairOfLines {\n        private static final int INF = (int) 2e9 + 7;\n        private InputReader in;\n        private PrintWriter out;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            int n = in.nextInt();\n            if (n <= 4) {\n                out.println(\"YES\");\n                return;\n            }\n            TreeList<PairII> list = new TreeList<>();\n            PairII[] a = new PairII[n + 1];\n            for (int i = 1; i <= n; i++) {\n                a[i] = (new PairII(in.nextInt(), in.nextInt()));\n                list.add(a[i]);\n            }\n            PairII pos1 = new PairII(INF, INF);\n            PairII pos2 = new PairII(INF, INF);\n            for (int i = 1; i <= 5; i++) {\n                for (int j = i + 1; j <= 5; j++) {\n                    for (int k = j + 1; k <= 5; k++) {\n                        int x1 = a[i].first;\n                        int y1 = a[i].second;\n                        int x2 = a[j].first;\n                        int y2 = a[j].second;\n                        int x = a[k].first;\n                        int y = a[k].second;\n                        long s = (long) (y2 - y1) * x + (long) (x1 - x2) * y + ((long) x2 * y1 - (long) x1 * y2);\n                        if (s == 0) {\n                            pos1 = a[i];\n                            pos2 = a[j];\n                        }\n                    }\n                }\n            }\n\n            if (pos1.equals(new PairII(INF, INF))) {\n                out.println(\"NO\");\n                return;\n            }\n            int x1 = pos1.first;\n            int y1 = pos1.second;\n            int x2 = pos2.first;\n            int y2 = pos2.second;\n            for (int i = 0; i < list.size(); i++) {\n                int x = list.get(i).first;\n                int y = list.get(i).second;\n                long s = (long) (y2 - y1) * x + (long) (x1 - x2) * y + ((long) x2 * y1 - (long) x1 * y2);\n                if (s == 0) {\n                    list.remove(i);\n                    i--;\n                }\n            }\n            if (list.size() <= 2) {\n                out.println(\"YES\");\n                return;\n            }\n            x1 = list.get(0).first;\n            y1 = list.get(0).second;\n            x2 = list.get(1).first;\n            y2 = list.get(1).second;\n            for (int i = 0; i < list.size(); i++) {\n                int x = list.get(i).first;\n                int y = list.get(i).second;\n                long s = (long) (y2 - y1) * x + (long) (x1 - x2) * y + ((long) x2 * y1 - (long) x1 * y2);\n                if (s == 0) {\n                    list.remove(i);\n                    i--;\n                }\n            }\n            if (list.size() == 0) {\n                out.println(\"YES\");\n            } else out.println(\"NO\");\n        }\n\n    }\n\n    static interface OrderedIterator<E> extends Iterator<E> {\n    }\n\n    static class PairII implements Comparable<PairII> {\n        public int first;\n        public int second;\n\n        public PairII(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            PairII pair = (PairII) o;\n\n            return first == pair.first && second == pair.second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(PairII o) {\n            int value = Integer.compare(first, o.first);\n            if (value != 0) {\n                return value;\n            }\n            return Integer.compare(second, o.second);\n        }\n\n    }\n\n    static class TreeList<E> extends AbstractList<E> {\n        private TreeList.AVLNode<E> root;\n        private int size;\n\n        public TreeList() {\n            super();\n        }\n\n        public TreeList(final Collection<? extends E> coll) {\n            super();\n            if (!coll.isEmpty()) {\n                root = new TreeList.AVLNode<>(coll);\n                size = coll.size();\n            }\n        }\n\n        public E get(final int index) {\n            return root.get(index).getValue();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public Iterator<E> iterator() {\n            // override to go 75% faster\n            return listIterator(0);\n        }\n\n        public ListIterator<E> listIterator() {\n            // override to go 75% faster\n            return listIterator(0);\n        }\n\n        public ListIterator<E> listIterator(final int fromIndex) {\n            return new TreeList.TreeListIterator<>(this, fromIndex);\n        }\n\n        public int indexOf(final Object object) {\n            // override to go 75% faster\n            if (root == null) {\n                return -1;\n            }\n            return root.indexOf(object, root.relativePosition);\n        }\n\n        public boolean contains(final Object object) {\n            return indexOf(object) >= 0;\n        }\n\n        public Object[] toArray() {\n            final Object[] array = new Object[size()];\n            if (root != null) {\n                root.toArray(array, root.relativePosition);\n            }\n            return array;\n        }\n\n        public void add(final int index, final E obj) {\n            modCount++;\n            if (root == null) {\n                root = new TreeList.AVLNode<>(index, obj, null, null);\n            } else {\n                root = root.insert(index, obj);\n            }\n            size++;\n        }\n\n        public boolean addAll(final Collection<? extends E> c) {\n            if (c.isEmpty()) {\n                return false;\n            }\n            modCount += c.size();\n            final TreeList.AVLNode<E> cTree = new TreeList.AVLNode<>(c);\n            root = root == null ? cTree : root.addAll(cTree, size);\n            size += c.size();\n            return true;\n        }\n\n        public E set(final int index, final E obj) {\n            final TreeList.AVLNode<E> node = root.get(index);\n            final E result = node.value;\n            node.setValue(obj);\n            return result;\n        }\n\n        public E remove(final int index) {\n            modCount++;\n            final E result = get(index);\n            root = root.remove(index);\n            size--;\n            return result;\n        }\n\n        public void clear() {\n            modCount++;\n            root = null;\n            size = 0;\n        }\n\n        static class AVLNode<E> {\n            private TreeList.AVLNode<E> left;\n            private boolean leftIsPrevious;\n            private TreeList.AVLNode<E> right;\n            private boolean rightIsNext;\n            private int height;\n            private int relativePosition;\n            private E value;\n\n            private AVLNode(final int relativePosition, final E obj,\n                            final TreeList.AVLNode<E> rightFollower, final TreeList.AVLNode<E> leftFollower) {\n                this.relativePosition = relativePosition;\n                value = obj;\n                rightIsNext = true;\n                leftIsPrevious = true;\n                right = rightFollower;\n                left = leftFollower;\n            }\n\n            private AVLNode(final Collection<? extends E> coll) {\n                this(coll.iterator(), 0, coll.size() - 1, 0, null, null);\n            }\n\n            private AVLNode(final Iterator<? extends E> iterator, final int start, final int end,\n                            final int absolutePositionOfParent, final TreeList.AVLNode<E> prev, final TreeList.AVLNode<E> next) {\n                final int mid = start + (end - start) / 2;\n                if (start < mid) {\n                    left = new TreeList.AVLNode<>(iterator, start, mid - 1, mid, prev, this);\n                } else {\n                    leftIsPrevious = true;\n                    left = prev;\n                }\n                value = iterator.next();\n                relativePosition = mid - absolutePositionOfParent;\n                if (mid < end) {\n                    right = new TreeList.AVLNode<>(iterator, mid + 1, end, mid, this, next);\n                } else {\n                    rightIsNext = true;\n                    right = next;\n                }\n                recalcHeight();\n            }\n\n            E getValue() {\n                return value;\n            }\n\n            void setValue(final E obj) {\n                this.value = obj;\n            }\n\n            TreeList.AVLNode<E> get(final int index) {\n                final int indexRelativeToMe = index - relativePosition;\n\n                if (indexRelativeToMe == 0) {\n                    return this;\n                }\n\n                final TreeList.AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n                if (nextNode == null) {\n                    return null;\n                }\n                return nextNode.get(indexRelativeToMe);\n            }\n\n            int indexOf(final Object object, final int index) {\n                if (getLeftSubTree() != null) {\n                    final int result = left.indexOf(object, index + left.relativePosition);\n                    if (result != -1) {\n                        return result;\n                    }\n                }\n                if (value == null ? value == object : value.equals(object)) {\n                    return index;\n                }\n                if (getRightSubTree() != null) {\n                    return right.indexOf(object, index + right.relativePosition);\n                }\n                return -1;\n            }\n\n            void toArray(final Object[] array, final int index) {\n                array[index] = value;\n                if (getLeftSubTree() != null) {\n                    left.toArray(array, index + left.relativePosition);\n                }\n                if (getRightSubTree() != null) {\n                    right.toArray(array, index + right.relativePosition);\n                }\n            }\n\n            TreeList.AVLNode<E> next() {\n                if (rightIsNext || right == null) {\n                    return right;\n                }\n                return right.min();\n            }\n\n            TreeList.AVLNode<E> previous() {\n                if (leftIsPrevious || left == null) {\n                    return left;\n                }\n                return left.max();\n            }\n\n            TreeList.AVLNode<E> insert(final int index, final E obj) {\n                final int indexRelativeToMe = index - relativePosition;\n\n                if (indexRelativeToMe <= 0) {\n                    return insertOnLeft(indexRelativeToMe, obj);\n                }\n                return insertOnRight(indexRelativeToMe, obj);\n            }\n\n            private TreeList.AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {\n                if (getLeftSubTree() == null) {\n                    setLeft(new TreeList.AVLNode<>(-1, obj, this, left), null);\n                } else {\n                    setLeft(left.insert(indexRelativeToMe, obj), null);\n                }\n\n                if (relativePosition >= 0) {\n                    relativePosition++;\n                }\n                final TreeList.AVLNode<E> ret = balance();\n                recalcHeight();\n                return ret;\n            }\n\n            private TreeList.AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n                if (getRightSubTree() == null) {\n                    setRight(new TreeList.AVLNode<>(+1, obj, right, this), null);\n                } else {\n                    setRight(right.insert(indexRelativeToMe, obj), null);\n                }\n                if (relativePosition < 0) {\n                    relativePosition--;\n                }\n                final TreeList.AVLNode<E> ret = balance();\n                recalcHeight();\n                return ret;\n            }\n\n            private TreeList.AVLNode<E> getLeftSubTree() {\n                return leftIsPrevious ? null : left;\n            }\n\n            private TreeList.AVLNode<E> getRightSubTree() {\n                return rightIsNext ? null : right;\n            }\n\n            private TreeList.AVLNode<E> max() {\n                return getRightSubTree() == null ? this : right.max();\n            }\n\n            private TreeList.AVLNode<E> min() {\n                return getLeftSubTree() == null ? this : left.min();\n            }\n\n            TreeList.AVLNode<E> remove(final int index) {\n                final int indexRelativeToMe = index - relativePosition;\n\n                if (indexRelativeToMe == 0) {\n                    return removeSelf();\n                }\n                if (indexRelativeToMe > 0) {\n                    setRight(right.remove(indexRelativeToMe), right.right);\n                    if (relativePosition < 0) {\n                        relativePosition++;\n                    }\n                } else {\n                    setLeft(left.remove(indexRelativeToMe), left.left);\n                    if (relativePosition > 0) {\n                        relativePosition--;\n                    }\n                }\n                recalcHeight();\n                return balance();\n            }\n\n            private TreeList.AVLNode<E> removeMax() {\n                if (getRightSubTree() == null) {\n                    return removeSelf();\n                }\n                setRight(right.removeMax(), right.right);\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n                recalcHeight();\n                return balance();\n            }\n\n            private TreeList.AVLNode<E> removeMin() {\n                if (getLeftSubTree() == null) {\n                    return removeSelf();\n                }\n                setLeft(left.removeMin(), left.left);\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n                recalcHeight();\n                return balance();\n            }\n\n            private TreeList.AVLNode<E> removeSelf() {\n                if (getRightSubTree() == null && getLeftSubTree() == null) {\n                    return null;\n                }\n                if (getRightSubTree() == null) {\n                    if (relativePosition > 0) {\n                        left.relativePosition += relativePosition;\n                    }\n                    left.max().setRight(null, right);\n                    return left;\n                }\n                if (getLeftSubTree() == null) {\n                    right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n                    right.min().setLeft(null, left);\n                    return right;\n                }\n\n                if (heightRightMinusLeft() > 0) {\n                    // more on the right, so delete from the right\n                    final TreeList.AVLNode<E> rightMin = right.min();\n                    value = rightMin.value;\n                    if (leftIsPrevious) {\n                        left = rightMin.left;\n                    }\n                    right = right.removeMin();\n                    if (relativePosition < 0) {\n                        relativePosition++;\n                    }\n                } else {\n                    // more on the left or equal, so delete from the left\n                    final TreeList.AVLNode<E> leftMax = left.max();\n                    value = leftMax.value;\n                    if (rightIsNext) {\n                        right = leftMax.right;\n                    }\n                    final TreeList.AVLNode<E> leftPrevious = left.left;\n                    left = left.removeMax();\n                    if (left == null) {\n                        // special case where left that was deleted was a double link\n                        // only occurs when height difference is equal\n                        left = leftPrevious;\n                        leftIsPrevious = true;\n                    }\n                    if (relativePosition > 0) {\n                        relativePosition--;\n                    }\n                }\n                recalcHeight();\n                return this;\n            }\n\n            private TreeList.AVLNode<E> balance() {\n                switch (heightRightMinusLeft()) {\n                    case 1:\n                    case 0:\n                    case -1:\n                        return this;\n                    case -2:\n                        if (left.heightRightMinusLeft() > 0) {\n                            setLeft(left.rotateLeft(), null);\n                        }\n                        return rotateRight();\n                    case 2:\n                        if (right.heightRightMinusLeft() < 0) {\n                            setRight(right.rotateRight(), null);\n                        }\n                        return rotateLeft();\n                    default:\n                        throw new RuntimeException(\"tree inconsistent!\");\n                }\n            }\n\n            private int getOffset(final TreeList.AVLNode<E> node) {\n                if (node == null) {\n                    return 0;\n                }\n                return node.relativePosition;\n            }\n\n            private int setOffset(final TreeList.AVLNode<E> node, final int newOffest) {\n                if (node == null) {\n                    return 0;\n                }\n                final int oldOffset = getOffset(node);\n                node.relativePosition = newOffest;\n                return oldOffset;\n            }\n\n            private void recalcHeight() {\n                height = Math.max(\n                        getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n                        getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n            }\n\n            private int getHeight(final TreeList.AVLNode<E> node) {\n                return node == null ? -1 : node.height;\n            }\n\n            private int heightRightMinusLeft() {\n                return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n            }\n\n            private TreeList.AVLNode<E> rotateLeft() {\n                final TreeList.AVLNode<E> newTop = right; // can't be faedelung!\n                final TreeList.AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n\n                final int newTopPosition = relativePosition + getOffset(newTop);\n                final int myNewPosition = -newTop.relativePosition;\n                final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n                setRight(movedNode, newTop);\n                newTop.setLeft(this, null);\n\n                setOffset(newTop, newTopPosition);\n                setOffset(this, myNewPosition);\n                setOffset(movedNode, movedPosition);\n                return newTop;\n            }\n\n            private TreeList.AVLNode<E> rotateRight() {\n                final TreeList.AVLNode<E> newTop = left;\n                final TreeList.AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n\n                final int newTopPosition = relativePosition + getOffset(newTop);\n                final int myNewPosition = -newTop.relativePosition;\n                final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n                setLeft(movedNode, newTop);\n                newTop.setRight(this, null);\n\n                setOffset(newTop, newTopPosition);\n                setOffset(this, myNewPosition);\n                setOffset(movedNode, movedPosition);\n                return newTop;\n            }\n\n            private void setLeft(final TreeList.AVLNode<E> node, final TreeList.AVLNode<E> previous) {\n                leftIsPrevious = node == null;\n                left = leftIsPrevious ? previous : node;\n                recalcHeight();\n            }\n\n            private void setRight(final TreeList.AVLNode<E> node, final TreeList.AVLNode<E> next) {\n                rightIsNext = node == null;\n                right = rightIsNext ? next : node;\n                recalcHeight();\n            }\n\n            private TreeList.AVLNode<E> addAll(TreeList.AVLNode<E> otherTree, final int currentSize) {\n                final TreeList.AVLNode<E> maxNode = max();\n                final TreeList.AVLNode<E> otherTreeMin = otherTree.min();\n\n                // We need to efficiently merge the two AVL trees while keeping them\n                // balanced (or nearly balanced). To do this, we take the shorter\n                // tree and combine it with a similar-height subtree of the taller\n                // tree. There are two symmetric cases:\n                //   * this tree is taller, or\n                //   * otherTree is taller.\n                if (otherTree.height > height) {\n                    // CASE 1: The other tree is taller than this one. We will thus\n                    // merge this tree into otherTree.\n\n                    // STEP 1: Remove the maximum element from this tree.\n                    final TreeList.AVLNode<E> leftSubTree = removeMax();\n\n                    // STEP 2: Navigate left from the root of otherTree until we\n                    // contains a subtree, s, that is no taller than me. (While we are\n                    // navigating left, we store the nodes we encounter in a stack\n                    // so that we can re-balance them in step 4.)\n                    final Deque<TreeList.AVLNode<E>> sAncestors = new ArrayDeque<>();\n                    TreeList.AVLNode<E> s = otherTree;\n                    int sAbsolutePosition = s.relativePosition + currentSize;\n                    int sParentAbsolutePosition = 0;\n                    while (s != null && s.height > getHeight(leftSubTree)) {\n                        sParentAbsolutePosition = sAbsolutePosition;\n                        sAncestors.push(s);\n                        s = s.left;\n                        if (s != null) {\n                            sAbsolutePosition += s.relativePosition;\n                        }\n                    }\n\n                    // STEP 3: Replace s with a newly constructed subtree whose root\n                    // is maxNode, whose left subtree is leftSubTree, and whose right\n                    // subtree is s.\n                    maxNode.setLeft(leftSubTree, null);\n                    maxNode.setRight(s, otherTreeMin);\n                    if (leftSubTree != null) {\n                        leftSubTree.max().setRight(null, maxNode);\n                        leftSubTree.relativePosition -= currentSize - 1;\n                    }\n                    if (s != null) {\n                        s.min().setLeft(null, maxNode);\n                        s.relativePosition = sAbsolutePosition - currentSize + 1;\n                    }\n                    maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                    otherTree.relativePosition += currentSize;\n\n                    // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                    s = maxNode;\n                    while (!sAncestors.isEmpty()) {\n                        final TreeList.AVLNode<E> sAncestor = sAncestors.pop();\n                        sAncestor.setLeft(s, null);\n                        s = sAncestor.balance();\n                    }\n                    return s;\n                }\n                otherTree = otherTree.removeMin();\n\n                final Deque<TreeList.AVLNode<E>> sAncestors = new ArrayDeque<>();\n                TreeList.AVLNode<E> s = this;\n                int sAbsolutePosition = s.relativePosition;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(otherTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.right;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                otherTreeMin.setRight(otherTree, null);\n                otherTreeMin.setLeft(s, maxNode);\n                if (otherTree != null) {\n                    otherTree.min().setLeft(null, otherTreeMin);\n                    otherTree.relativePosition++;\n                }\n                if (s != null) {\n                    s.max().setRight(null, otherTreeMin);\n                    s.relativePosition = sAbsolutePosition - currentSize;\n                }\n                otherTreeMin.relativePosition = currentSize - sParentAbsolutePosition;\n\n                s = otherTreeMin;\n                while (!sAncestors.isEmpty()) {\n                    final TreeList.AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setRight(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n\n        }\n\n        static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n            private final TreeList<E> parent;\n            private TreeList.AVLNode<E> next;\n            private int nextIndex;\n            private TreeList.AVLNode<E> current;\n            private int currentIndex;\n            private int expectedModCount;\n\n            private TreeListIterator(final TreeList<E> parent, final int fromIndex) throws IndexOutOfBoundsException {\n                super();\n                this.parent = parent;\n                this.expectedModCount = parent.modCount;\n                this.next = parent.root == null ? null : parent.root.get(fromIndex);\n                this.nextIndex = fromIndex;\n                this.currentIndex = -1;\n            }\n\n            private void checkModCount() {\n                if (parent.modCount != expectedModCount) {\n                    throw new ConcurrentModificationException();\n                }\n            }\n\n            public boolean hasNext() {\n                return nextIndex < parent.size();\n            }\n\n            public E next() {\n                checkModCount();\n                if (!hasNext()) {\n                    throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n                }\n                if (next == null) {\n                    next = parent.root.get(nextIndex);\n                }\n                final E value = next.getValue();\n                current = next;\n                currentIndex = nextIndex++;\n                next = next.next();\n                return value;\n            }\n\n            public boolean hasPrevious() {\n                return nextIndex > 0;\n            }\n\n            public E previous() {\n                checkModCount();\n                if (!hasPrevious()) {\n                    throw new NoSuchElementException(\"Already at start of list.\");\n                }\n                if (next == null) {\n                    next = parent.root.get(nextIndex - 1);\n                } else {\n                    next = next.previous();\n                }\n                final E value = next.getValue();\n                current = next;\n                currentIndex = --nextIndex;\n                return value;\n            }\n\n            public int nextIndex() {\n                return nextIndex;\n            }\n\n            public int previousIndex() {\n                return nextIndex() - 1;\n            }\n\n            public void remove() {\n                checkModCount();\n                if (currentIndex == -1) {\n                    throw new IllegalStateException();\n                }\n                parent.remove(currentIndex);\n                if (nextIndex != currentIndex) {\n                    // remove() following next()\n                    nextIndex--;\n                }\n                // the AVL node referenced by next may have become stale after a remove\n                // reset it now: will be retrieved by next call to next()/previous() via nextIndex\n                next = null;\n                current = null;\n                currentIndex = -1;\n                expectedModCount++;\n            }\n\n            public void set(final E obj) {\n                checkModCount();\n                if (current == null) {\n                    throw new IllegalStateException();\n                }\n                current.setValue(obj);\n            }\n\n            public void add(final E obj) {\n                checkModCount();\n                parent.add(nextIndex, obj);\n                current = null;\n                currentIndex = -1;\n                nextIndex++;\n                expectedModCount++;\n            }\n\n        }\n\n    }\n\n    static class InputReader extends InputStream {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "index": 662, "complexity": 4}
{"back-translation": "class Main { static int R = 4, C = 4; static int first(int arr[], int low, int high) { if (high >= low) { int mid = low + (high - low) / 2; if ((mid == 0 || (arr[mid - 1] == 0)) && arr[mid] == 1) return mid; else if (arr[mid] == 0) return first(arr, (mid + 1), high); else return first(arr, low, (mid - 1)); } return -1; } static int rowWithMax1s(int[][] mat) { int max_row_index = 0, max = -1; int i, index; for (i = 0; i < R; i++) { index = first(mat[i], 0, C - 1); if (index != -1 && C - index > max) { max = C - index; max_row_index = i; } } return max_row_index; } public static void main(String[] args) { int mat[][] = { { 0, 0, 0, 1 }, { 0, 1, 1, 1 }, { 1, 1, 1, 1 }, { 0, 0, 0, 0 } }; System.out.println(\"Index of row with maximum 1s is \" + rowWithMax1s(mat)); } }", "src": "\n// Java program to find the row \n// with maximum number of 1s \nimport\njava.io.*; \n\nclass\nGFG { \n\nstatic\nint\nR = \n4\n, C = \n4\n; \n\n// Function to find the index of first index \n\n// of 1 in a boolean array arr[] \n\nstatic\nint\nfirst(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) { \n\n// Get the middle index \n\nint\nmid = low + (high - low) / \n2\n; \n\n\n// Check if the element at middle index is first 1 \n\nif\n((mid == \n0\n|| (arr[mid - \n1\n] == \n0\n)) && arr[mid] == \n1\n) \n\nreturn\nmid; \n\n\n// If the element is 0, recur for right side \n\nelse\nif\n(arr[mid] == \n0\n) \n\nreturn\nfirst(arr, (mid + \n1\n), high); \n\n\n// If element is not first 1, recur for left side \n\nelse\n\nreturn\nfirst(arr, low, (mid - \n1\n)); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n// Function that returns index of row \n\n// with maximum number of 1s. \n\nstatic\nint\nrowWithMax1s(\nint\nmat[][]) \n\n{ \n\n// Initialize max values \n\nint\nmax_row_index = \n0\n, max = -\n1\n; \n\n\n// Traverse for each row and count number of \n\n// 1s by finding the index of first 1 \n\nint\ni, index; \n\nfor\n(i = \n0\n; i < R; i++) { \n\nindex = first(mat[i], \n0\n, C - \n1\n); \n\nif\n(index != -\n1\n&& C - index > max) { \n\nmax = C - index; \n\nmax_row_index = i; \n\n} \n\n} \n\n\nreturn\nmax_row_index; \n\n} \n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n0\n, \n0\n, \n0\n, \n1\n}, \n\n{ \n0\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n1\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n0\n, \n0\n, \n0\n, \n0\n} }; \n\nSystem.out.println(\n\"Index of row with maximum 1s is \"\n\n+ rowWithMax1s(mat)); \n\n} \n} \n\n// This code is contributed by 'Gitanjali'. ", "index": 664, "complexity": 4}
{"back-translation": "import java.util.*;import java.io.*;import java.lang.reflect.Array;public class codeforces{public static void main(String[] args){InputReader in=new InputReader(System.in);PrintWriter pw=new PrintWriter(System.out);int n=in.nextInt();long U=in.nextLong();long[] E=new long[n];double max=-1;for(int i=0;i<n;i++)E[i]=in.nextLong();for(int k=1;k<n-1;k++){int i=k+1,j=n-1,mid=0;double T=0;while(i<j){mid=(int)Math.ceil((double)(i+j)/2);if(E[mid]-E[k-1]<=U)i=mid;else j=mid-1;}j=k;k=i;i=j-1;T=E[k]-E[j]; T/=E[k]-E[i]; if(E[k]-E[i]<=U)max=Math.max(max,T);k=j;}pw.println(max);pw.flush();pw.close();}public static ArrayList Divisors(long n){ArrayList<Long> div=new ArrayList<>();for(long i=1;i<=Math.sqrt(n);i++){if(n%i==0){div.add(i);if(n/i!=i)div.add(n/i);}}return div;}public static int BinarySearch(long[] a,long k){int n=a.length;i=0;j=n-1;mid=0;if(k<a[0])return 0;else if(k>=a[n-1])return n;else{while(j-i>1){mid=(i+j)/2;if(k>=a[mid])i=mid;else j=mid;}}return i+1;}public static long GCD(long a,long b){if(b==0)return a;else return GCD(b,a%b);}static class pair implements Comparable<pair>{Integer x,y;//constructor, compareTo, toString, equals, hashCode}static class InputReader{private final InputStream stream;private final byte[] buf=new byte[8192];private int curChar,snumChars;private SpaceCharFilter filter;public InputReader(InputStream stream){this.stream=stream;}public int snext(){if(snumChars==-1)throw new InputMismatchException();if(curChar>=snumChars){curChar=0;try{snumChars=stream.read(buf);}catch(IOException e){throw new InputMismatchException();}if(snumChars<=0)return -1;}return buf[curChar++];}public int nextInt(){int c=snext();while(isSpaceChar(c)){c=snext();}int sgn=1;if(c=='-'){sgn=-1;c=snext();}int res=0;do{if(c<'0'||c>'9')throw new InputMismatchException();res*=10;res+=c-'0';c=snext();}while(!isSpaceChar(c));return res*sgn;}public long nextLong(){int c=snext();while(isSpaceChar(c)){c=snext();}int sgn=1;if(c=='-'){sgn=-1;c=snext();}long res=0;do{if(c<'0'||c>'9')throw new InputMismatchException();res*=10;res+=c-'0';c=snext();}while(!isSpaceChar(c));return res*sgn;}public int[] nextIntArray(int n){int a[]=new int[n];for(int i=0;i<n;i++){a[i]=nextInt();}return a;}public String readString(){int c=snext();while(isSpaceChar(c)){c=snext();}StringBuilder res=new StringBuilder();do{res.appendCodePoint(c);c=snext();}while(!isSpaceChar(c));return res.toString();}public String nextLine(){int c=snext();while(isSpaceChar(c))c=snext();StringBuilder res=new StringBuilder();do{res.appendCodePoint(c);c=snext();}while(!isEndOfLine(c));return res.toString();}public boolean isSpaceChar(int c){if(filter!=null)return filter.isSpaceChar(c);return c==' '||c=='\n'||c=='\r'||c=='\t'||c==-1;}private boolean isEndOfLine(int c){return c=='\n'||c=='\r'||c==-1;}public interface SpaceCharFilter{public boolean isSpaceChar(int ch);}}static class CodeX{public static void sort(long arr[]){merge_sort(arr,0,arr.length-1);}private static void merge_sort(long A[],long start,long end){if(start<end){long mid=(start+end)/2;merge_sort(A,start,mid);merge_sort(A,mid+1,end);merge(A,start,mid,end);}}private static void merge(long A[],long start,long mid,long end){long p=start,q=mid+1;long Arr[]=new long[(int)(end-start+1)];long k=0;for(int i=(int)start;i<=end;i++){if(p>mid)Arr[(int)k++]=A[(int)q++];else if(q>end)Arr[(int)k++]=A[(int)p++];else if(A[(int)p]<A[(int)q])Arr[(int)k++]=A[(int)p++];else Arr[(int)k++]=A[(int)q++];}for(int i=0;i<k;i++){A[(int)start++]=Arr[i];}}}", "src": "import java.util.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\n\n\t\tpublic class codeforces\n\t\t{\t\n\t\t\tpublic static void main(String[] args)\n\t\t\t{\n\t\t\t\tInputReader in = new InputReader(System.in);\n\t\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tlong U = in.nextLong();\n\t\t\t\tlong[] E = new long[n];\n\t\t\t\tdouble max = -1;\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\tE[i] = in.nextLong();\n\t\t\t\t\n\t\t\t\tfor(int k=1;k<n-1;k++)\n\t\t\t\t{\n\t\t\t\t\tint i = k + 1, j = n - 1, mid = 0;\n\t\t\t\t\tdouble T = 0;\n\t\t\t\t\t\n\t\t\t\t\twhile(i < j)\n\t\t\t\t\t{\n\t\t\t\t\t\tmid = (int)Math.ceil((double)(i+j)/2);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(E[mid] - E[k-1] <= U)\n\t\t\t\t\t\t\ti = mid;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tj = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tj = k;\n\t\t\t\t\tk = i;\n\t\t\t\t\ti = j - 1;\n\t\t\t\t\t\n\t\t\t\t\tT = E[k] - E[j];\n\t\t\t\t\tT /= E[k] - E[i];\n\t\t\t\t\t\n\t\t\t\t\tif(E[k] - E[i] <= U)\n\t\t\t\t\t\tmax = Math.max(max, T);\n\t\t\t\t\t\n\t\t\t\t\tk = j;\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\tpw.println(max);\n\t\t\t\t\n\t\t\t\tpw.flush();\n\t\t\t\tpw.close();\n\t\t\t}\n\t\t\t\n\t\t/*\tpublic static void DFS(int sourse)\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tvisited[sourse] = true;\n\t\t\t\t\n\t\t\t\tfor(int u : adj[sourse])\n\t\t\t\t{\n\t\t\t\t\tif(!visited[u])\n\t\t\t\t\t{\n\t\t\t\t\t\tDFS(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}*/\n\t\t\t\n\t\t\tpublic static ArrayList Divisors(long n)\n\t\t\t{\n\t\t\t    ArrayList<Long> div = new ArrayList<>();\n\t\t\t    \n\t\t\t    for (long i=1; i<=Math.sqrt(n); i++)\n\t\t\t    {\n\t\t\t        if (n%i == 0)\n\t\t\t        {\n\t\t\t        \tdiv.add(i);\n\t\t\t                \n\t\t\t            if(n/i != i)\n\t\t\t            \tdiv.add(n/i);\n\t\t\t        }\n\t\t\t    }\n\t\t\t    return div;\n\t\t\t}\n\t\t\n\t\t\tpublic static int BinarySearch(long[] a, long k)\n\t\t\t{\n\t\t\t\tint n = a.length;\n\t\t\t\tint i = 0, j = n-1;\n\t\t\t\tint mid = 0;\n\t\t\t\t\n\t\t\t\tif(k < a[0])\n\t\t\t\t\treturn 0;\n\t\t\t\telse if(k >= a[n-1])\n\t\t\t\t\treturn n;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile(j - i > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmid = (i+j)/2;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(k >= a[mid])\n\t\t\t\t\t\t\ti = mid;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tj = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn i+1;\n\t\t\t}\n\t\t\tpublic static long GCD(long a,long b)\n\t\t\t{\n\t\t\t\tif(b==0)\n\t\t\t\t\treturn a;\n\t\t\t\telse\n\t\t\t\t\treturn GCD(b,a%b);\n\t\t\t}\n\t\t\t\n\t\t\tstatic class pair implements Comparable<pair>\n\t\t\t{\n\t\t\t\tInteger x, y;\n\t\t\t\tpair(int x,int y)\n\t\t\t\t{\n\t\t\t\t\tthis.x=x;\n\t\t\t\t\tthis.y=y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic int compareTo(pair o) {\n\t\t\t\t\tint result = x.compareTo(o.x);\n\t\t\t\t\tif(result==0)\n\t\t\t\t\t\tresult = y.compareTo(o.y);\n\t\t\t\t\t\n\t\t\t\t\treturn result;\n\t\t\t\t}  \n\t\t\t\t\n\t\t\t\tpublic String toString()\n\t\t\t\t{\n\t\t\t\t\treturn x+\" \"+y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic boolean equals(Object o)\n\t\t\t\t{\n\t\t\t\t\tif (o instanceof pair)\n\t\t\t\t    {\n\t\t\t\t\t\tpair p = (pair)o;\n\t\t\t\t\t\treturn p.x - x == 0 && p.y - y == 0 ;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic int hashCode()\n\t\t\t\t{\n\t\t\t\t\treturn new Long(x).hashCode()*31 + new Long(y).hashCode();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstatic class InputReader \n\t\t\t{\n\t\t\t\t \n\t\t\t\tprivate final InputStream stream;\n\t\t\t\tprivate final byte[] buf = new byte[8192];\n\t\t\t\tprivate int curChar, snumChars;\n\t\t\t\tprivate SpaceCharFilter filter;\n\t\t \n\t\t\t\tpublic InputReader(InputStream stream) \n\t\t\t\t{\n\t\t\t\t\tthis.stream = stream;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int snext() \n\t\t\t\t{\n\t\t\t\t\tif (snumChars == -1)\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tif (curChar >= snumChars) \n\t\t\t\t\t{\n\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\ttry \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t\t\t} \n\t\t\t\t\t\tcatch (IOException e) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int nextInt() \n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-')\n\t\t\t\t    {\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint res = 0;\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic long nextLong()\n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tint sgn = 1;\n\t\t\t\t\tif (c == '-') \n\t\t\t\t\t{\n\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tlong res = 0;\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res * sgn;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic int[] nextIntArray(int n) \n\t\t\t\t{\n\t\t\t\t\tint a[] = new int[n];\n\t\t\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t\t\t{\n\t\t\t\t\t\ta[i] = nextInt();\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic String readString()\n\t\t\t    {\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c)) \n\t\t\t\t\t{\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t}\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic String nextLine() \n\t\t\t\t{\n\t\t\t\t\tint c = snext();\n\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\tdo \n\t\t\t\t\t{\n\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\tc = snext();\n\t\t\t\t\t} while (!isEndOfLine(c));\n\t\t\t\t\treturn res.toString();\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic boolean isSpaceChar(int c) \n\t\t\t\t{\n\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t}\n\t\t \n\t\t\t\tprivate boolean isEndOfLine(int c) \n\t\t\t\t{\n\t\t\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t\t\t}\n\t\t \n\t\t\t\tpublic interface SpaceCharFilter\n\t\t\t    {\n\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstatic class CodeX {\n\t        public static void sort(long arr[]) {\n\t            merge_sort(arr, 0, arr.length - 1);\n\t        }\n\t\n\t        private static void merge_sort(long A[], long start, long end) {\n\t            if (start < end) {\n\t                long mid = (start + end) / 2;\n\t                merge_sort(A, start, mid);\n\t                merge_sort(A, mid + 1, end);\n\t                merge(A, start, mid, end);\n\t            }\n\t\n\t        }\n\t\n\t        private static void merge(long A[], long start,long mid, long end) {\n\t            long p = start, q = mid + 1;\n\t            long Arr[] = new long[(int)(end - start + 1)];\n\t            long k = 0;\n\t\n\t            for (int i = (int)start; i <= end; i++) {\n\t                if (p > mid)\n\t                    Arr[(int)k++] = A[(int)q++];\n\t\n\t                else if (q > end)\n\t                    Arr[(int)k++] = A[(int)p++];\n\t\n\t                else if (A[(int)p] < A[(int)q])\n\t                    Arr[(int)k++] = A[(int)p++];\n\t\n\t                else\n\t                    Arr[(int)k++] = A[(int)q++];\n\t            }\n\t            for (int i = 0; i < k; i++) {\n\t                A[(int)start++] = Arr[i];\n\t            }\n\t\n\t        }\n\t\n\t    }\n\t\t}\t\n\t\t\n\n\t\t\t", "index": 666, "complexity": 4}
{"back-translation": "import java.util.*;\n\nclass GFG {\n\nstatic int findPlatform(int[] arr, int[] dep, int n) {\nArrays.sort(arr);\nArrays.sort(dep);\nint plat_needed = 1, result = 1;\nint i = 1, j = 0;\nwhile (i < n && j < n) {\nif (arr[i] <= dep[j]) {\nplat_needed++;\ni++;\nif (plat_needed > result)\nresult = plat_needed;\n} else {\nplat_needed--;\nj++;\n}\n}\nreturn result;\n}\n\npublic static void main(String[] args) {\nint arr[] = {900, 940, 950, 1100, 1500, 1800};\nint dep[] = {910, 1200, 1120, 1130, 1900, 2000};\nint n = arr.length;\nSystem.out.println(\"Minimum Number of Platforms Required = \" + findPlatform(arr, dep, n));\n}\n}", "src": "\n// Program to find minimum number of platforms \n\nimport\njava.util.*; \n\nclass\nGFG { \n\n// Returns minimum number of platforms reqquired \nstatic\nint\nfindPlatform(\nint\narr[], \nint\ndep[], \nint\nn) \n{ \n\n// Sort arrival and departure arrays \n\nArrays.sort(arr); \n\nArrays.sort(dep); \n\n\n// plat_needed indicates number of platforms \n\n// needed at a time \n\nint\nplat_needed = \n1\n, result = \n1\n; \n\nint\ni = \n1\n, j = \n0\n; \n\n\n// Similar to merge in merge sort to process \n\n// all events in sorted order \n\nwhile\n(i < n && j < n) \n\n{ \n\n// If next event in sorted order is arrival, \n\n// increment count of platforms needed \n\nif\n(arr[i] <= dep[j]) \n\n{ \n\nplat_needed++; \n\ni++; \n\n\n// Update result if needed \n\nif\n(plat_needed > result) \n\nresult = plat_needed; \n\n} \n\n\n// Else decrement count of platforms needed \n\nelse\n\n{ \n\nplat_needed--; \n\nj++; \n\n} \n\n} \n\n\nreturn\nresult; \n} \n\n// Driver program to test methods of graph class \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n900\n, \n940\n, \n950\n, \n1100\n, \n1500\n, \n1800\n}; \n\nint\ndep[] = {\n910\n, \n1200\n, \n1120\n, \n1130\n, \n1900\n, \n2000\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Minimum Number of Platforms Required = \"\n\n+ findPlatform(arr, dep, n)); \n} \n} ", "index": 667, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n    static final String filename = \"\";\n    static final boolean stdin = true;\n    static FastScanner br;\n    static PrintWriter pw;\n\n    public static void main(String[] args) throws IOException {\n\n        if (stdin) {\n            br = new FastScanner();\n            pw = new PrintWriter(new OutputStreamWriter(System.out));\n        } else {\n            br = new FastScanner(filename + \".in\");\n            pw = new PrintWriter(new FileWriter(filename + \".out\"));\n        }\n\n        Solver solver = new Solver();\n        solver.solve(br, pw);\n    }\n\n    static class Solver {\n        static long mod = 10000000000L;\n\n        public void solve(FastScanner br, PrintWriter pw) throws IOException {\n            int n = br.ni();\n            Integer[] in = br.nIa(n);\n            TreeSet<Integer> ts = new TreeSet<Integer>();\n            for (int i = 0; i < n; i++) {\n                ts.add(in[i]);\n            }\n            String twoSol = \"\";\n            for (int i = 0; i <= 30; i++) {\n                for (int j : in) {\n                    if (ts.contains(j + (int) Math.pow(2, i))) {\n                        if (ts.contains(j - (int) Math.pow(2, i))) {\n                            pw.println(3);\n                            pw.println(j + \" \" + (j + (int) Math.pow(2, i)) + \" \" + (j - (int) Math.pow(2, i)));\n                            pw.close();\n                            System.exit(0);\n                        } else {\n                            twoSol = (j + \" \" + (j + (int) Math.pow(2, i)));\n                        }\n                    }\n                }\n            }\n            if (twoSol.isEmpty()) {\n                pw.println(1);\n                pw.println(in[0]);\n            } else {\n                pw.println(2);\n                pw.println(twoSol);\n            }\n            pw.close();\n        }\n\n        static long gcd(long a, long b) {\n            if (a > b)\n                return gcd(b, a);\n            if (a == 0)\n                return b;\n            return gcd(b % a, a);\n        }\n\n        static long lcm(long a, long b) {\n            return a * (b / gcd(a, b));\n        }\n\n        static long pow(long a, long b) {\n            if (b == 0)\n                return 1L;\n            long val = pow(a, b / 2);\n            if (b % 2 == 0)\n                return val * val % mod;\n            else\n                return val * val % mod * a % mod;\n        }\n\n    }\n\n    static class Point implements Comparable<Point> {\n        int a;\n        int b;\n\n        Point(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            return this.a - o.a;\n        }\n\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        ArrayList<Integer>[] ng(int n, int e) {\n            ArrayList<Integer>[] adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<Integer>();\n            }\n            for (int i = 0; i < e; i++) {\n                int a = ni() - 1;\n                int b = ni() - 1;\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n            return adj;\n        }\n\n        Integer[] nIa(int n) {\n            Integer[] arr = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = ni();\n            }\n            return arr;\n        }\n\n        int[] nia(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = ni();\n            }\n            return arr;\n        }\n\n        Long[] nLa(int n) {\n            Long[] arr = new Long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nl();\n            }\n            return arr;\n        }\n\n        long[] nla(int n) {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nl();\n            }\n            return arr;\n        }\n\n        String[] nsa(int n) {\n            String[] arr = new String[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nt();\n            }\n            return arr;\n        }\n\n        String nt() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int ni() {\n            return Integer.parseInt(nt());\n        }\n\n        long nl() {\n            return Long.parseLong(nt());\n        }\n\n        double nd() {\n            return Double.parseDouble(nt());\n        }\n\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\n\npublic class D {\n\n\tstatic final boolean stdin = true;\n\tstatic final String filename = \"\";\n\tstatic FastScanner br;\n\tstatic PrintWriter pw;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tif (stdin) {\n\t\t\tbr = new FastScanner();\n\t\t\tpw = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t} else {\n\t\t\tbr = new FastScanner(filename + \".in\");\n\t\t\tpw = new PrintWriter(new FileWriter(filename + \".out\"));\n\t\t}\n\n\t\tSolver solver = new Solver();\n\t\tsolver.solve(br, pw);\n\t}\n\n\tstatic class Solver {\n\t\tstatic long mod = (long) (1e10);\n\n\t\tpublic void solve(FastScanner br, PrintWriter pw) throws IOException {\n\t\t\tint n = br.ni();\n\t\t\tInteger[] in = br.nIa(n);\n\t\t\tTreeSet<Integer> ts = new TreeSet<Integer>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tts.add(in[i]);\n\t\t\t}\n\t\t\tString twoSol = \"\";\n\t\t\tfor (int i = 0; i <= 30; i++) {\n\t\t\t\tfor (int j : in) {\n\t\t\t\t\tif (ts.contains(j + (int) Math.pow(2, i))) {\n\t\t\t\t\t\tif (ts.contains(j - (int) Math.pow(2, i))) {\n\t\t\t\t\t\t\tpw.println(3);\n\t\t\t\t\t\t\tpw.println(j + \" \" + (j + (int) Math.pow(2, i)) + \" \" + (j - (int) Math.pow(2, i)));\n\t\t\t\t\t\t\tpw.close();\n\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttwoSol = (j + \" \" + (j + (int) Math.pow(2, i)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (twoSol.isEmpty()) {\n\t\t\t\tpw.println(1);\n\t\t\t\tpw.println(in[0]);\n\t\t\t} else {\n\t\t\t\tpw.println(2);\n\t\t\t\tpw.println(twoSol);\n\t\t\t}\n\t\t\tpw.close();\n\t\t}\n\n\t\tstatic long gcd(long a, long b) {\n\t\t\tif (a > b)\n\t\t\t\treturn gcd(b, a);\n\t\t\tif (a == 0)\n\t\t\t\treturn b;\n\t\t\treturn gcd(b % a, a);\n\t\t}\n\n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n\n\t\tstatic long pow(long a, long b) {\n\t\t\tif (b == 0)\n\t\t\t\treturn 1L;\n\t\t\tlong val = pow(a, b / 2);\n\t\t\tif (b % 2 == 0)\n\t\t\t\treturn val * val % mod;\n\t\t\telse\n\t\t\t\treturn val * val % mod * a % mod;\n\t\t}\n\n\t}\n\n\tstatic class Point implements Comparable<Point> {\n\t\tint a;\n\t\tint b;\n\n\t\tPoint(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn this.a - o.a;\n\t\t}\n\n\t}\n\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tArrayList<Integer>[] ng(int n, int e) {\n\t\t\tArrayList<Integer>[] adj = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < e; i++) {\n\t\t\t\tint a = ni() - 1;\n\t\t\t\tint b = ni() - 1;\n\t\t\t\tadj[a].add(b);\n\t\t\t\tadj[b].add(a);\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\n\t\tInteger[] nIa(int n) {\n\t\t\tInteger[] arr = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = ni();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] nia(int n) {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = ni();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tLong[] nLa(int n) {\n\t\t\tLong[] arr = new Long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nl();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] nla(int n) {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nl();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tString[] nsa(int n) {\n\t\t\tString[] arr = new String[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tString nt() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint ni() {\n\t\t\treturn Integer.parseInt(nt());\n\t\t}\n\n\t\tlong nl() {\n\t\t\treturn Long.parseLong(nt());\n\t\t}\n\n\t\tdouble nd() {\n\t\t\treturn Double.parseDouble(nt());\n\t\t}\n\n\t}\n}", "index": 668, "complexity": 4}
{"back-translation": "import java.util.Arrays; public class GFG { public static boolean ifPossible(int[] arr, int n) { int[] copy = Arrays.copyOf(arr, arr.length); Arrays.sort(copy); for (int i = 0; i < n; i++) { if (!(arr[i] == copy[i]) && !(arr[n - 1 - i] == copy[i])) return false; } return true; } public static void main(String[] args) { int[] arr = {1, 7, 6, 4, 5, 3, 2, 8}; int n = arr.length; if (ifPossible(arr, n)) System.out.println(\"Yes\"); else System.out.println(\"No\"); } }", "src": "\n// Java program to find possibility to sort \n// by multiple subarray reverse operation \nimport\njava.util.*; \nclass\nGFG { \n\n\nstatic\nboolean\nifPossible(\nint\narr[], \nint\nn) \n\n{ \n\n\n// making the copy of the original array \n\nint\ncopy[] = Arrays.copyOf(arr, arr.length); \n\n\n// sorting the copied array \n\nArrays.sort(copy); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// checking mirror image of elements of \n\n// sorted copy array and equivalent element \n\n// of original array \n\nif\n(!(arr[i] == copy[i]) && !(arr[n - \n1\n- i] == copy[i])) \n\nreturn\nfalse\n; \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n// driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n7\n, \n6\n, \n4\n, \n5\n, \n3\n, \n2\n, \n8\n}; \n\nint\nn = arr.length; \n\nif\n(ifPossible(arr, n)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n} ", "index": 670, "complexity": 4}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class CoveredPointsCount {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\n\t\tint n = Integer.parseInt(st.nextToken());\n\n\t\tlong[] myArray = new long[2 * n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\t\t\tmyArray[2 * i] = Long.parseLong(st1.nextToken()) * 2;\n\t\t\tmyArray[2 * i + 1] = Long.parseLong(st1.nextToken()) * 2 + 1;\n\t\t}\n\n\t\tArrays.sort(myArray);\n\t\tlong[] ans = new long[n + 1];\n\t\tint cnt = 0;\n\n\t\tfor (int i = 0; i < 2 * n - 1; i++) {\n\t\t\tif (myArray[i] % 2 == 0) cnt++; \n\t\t\telse cnt--;\n\t\t\tans[cnt] += (myArray[i + 1] + 1) / 2 - (myArray[i] + 1) / 2;\n\t\t}\n\n\t\tStringBuilder answer = new StringBuilder();\n\n\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\tanswer.append(ans[i]);\n\t\t\tanswer.append(\" \");\n\t\t}\n\n\t\tSystem.out.println(answer);\n\n\t}\n\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class CoveredPointsCount {\n\t\n\t//UPSOLVE\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t        \n\t\tint n = Integer.parseInt(st.nextToken());\n\t     \n\t\tlong[] myArray = new long[2 * n];\n\t        \n\t\t\tfor (int i = 0; i < n; i++)  {\n\t        \tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\t        \tmyArray[2 * i] = Long.parseLong(st1.nextToken()) * 2;\n\t        \tmyArray[2 * i + 1] = Long.parseLong(st1.nextToken()) * 2 + 1;\n\t        }  \n\t        \n\t        Arrays.sort(myArray);\n\t        long[] ans = new long[n + 1];\n\t        int cnt = 0;\n\t       \n\t        for (int i = 0; i < 2 * n - 1; i++)   {\n\t            if (myArray[i] % 2 == 0) cnt++; else cnt--;\n\t            ans[cnt] += (myArray[i + 1] + 1) / 2 - (myArray[i] + 1) / 2;\n\t        }   \n\t        \n\t        StringBuilder answer = new StringBuilder();\n\t        \n\t        for (int i = 1; i < n + 1; i++) {\n\t        \tanswer.append(ans[i]);\n\t        \tanswer.append(\" \");\n\t        }  \n\t        \n\t        System.out.println(answer);\n\n\t}\n\n}\n", "index": 671, "complexity": 4}
{"back-translation": "import java.util.Arrays; class GFG { static int getMinDiff(int arr[], int n, int k) { if (n == 1) return 0; Arrays.sort(arr); int ans = arr[n-1] - arr[0]; int small = arr[0] + k; int big = arr[n-1] - k; int temp = 0; if (small > big) { temp = small; small = big; big = temp; } for (int i = 1; i < n-1; i++) { int subtract = arr[i] - k; int add = arr[i] + k; if (subtract >= small || add <= big) continue; if (big - subtract <= add - small) small = subtract; else big = add; } return Math.min(ans, big - small); } public static void main(String[] args) { int arr[] = {4, 6}; int n = arr.length; int k = 10; System.out.println(\"Maximum difference is \" + getMinDiff(arr, n, k)); } }", "src": "\n// Java program to find the minimum possible \n// difference between maximum and minimum \n// elements when we have to add/subtract \n// every number by k \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Modifies the array by subtracting/adding \n\n// k to every element such that the difference \n\n// between maximum and minimum is minimized \n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n// Sort all elements \n\nArrays.sort(arr); \n\n\n// Initialize result \n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n// Handle corner elements \n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n// Traverse middle elements \n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n// If both subtraction and addition \n\n// do not change diff \n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n// Either subtraction causes a smaller \n\n// number or addition causes a greater \n\n// number. Update small or big using \n\n// greedy approach (If big - subtract \n\n// causes smaller diff, update small \n\n// Else update big) \n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n// Driver function to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n} \n// This code is contributed by Prerna Saini ", "index": 672, "complexity": 4}
{"back-translation": "ERROR", "src": "import java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport java.math.BigInteger;\n\npublic class stacks {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tFastIO sc = new FastIO(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tlong remove = 0;\n\t\t\n\t\tint[] heights = new int[n+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\theights[i] = sc.nextInt();\n\t\t\tremove += heights[i];\n\t\t}\n\t\t\n\t\tArrays.sort(heights);\n\t\t//System.out.println(Arrays.toString(heights));\n\t\tlong keep = 0;\n\t\tfor(int i = n; i> 0; i--) {\n\t\t\tif(heights[i-1] >= heights[i]) {\n\t\t\t\theights[i-1] = heights[i]-1;\n\t\t\t}\n\t\t\tkeep += heights[i] - heights[i-1];\n\t\t}\n\t\t//System.out.println(Arrays.toString(heights));\n\t\t\n\t\tpw.println(remove - keep);\n\t\tpw.close();\n\t}\n\n\tstatic class FastIO {\n\n\t\t//Is your Fast I/O being bad?\n\n\t\tInputStream dis;\n\t\tbyte[] buffer = new byte[1 << 17];\n\t\tint pointer = 0;\n\n\t\tpublic FastIO(String fileName) throws Exception {\n\t\t\tdis = new FileInputStream(fileName);\n\t\t}\n\n\t\tpublic FastIO(InputStream is) throws Exception {\n\t\t\tdis = is;\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\tint ret = 0;\n\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\tboolean negative = false;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = nextByte();\n\t\t\t}\n\t\t\twhile (b >= '0' && b <= '9') {\n\t\t\t\tret = 10 * ret + b - '0';\n\t\t\t\tb = nextByte();\n\t\t\t}\n\n\t\t\treturn (negative) ? -ret : ret;\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\tlong ret = 0;\n\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\tboolean negative = false;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = nextByte();\n\t\t\t}\n\t\t\twhile (b >= '0' && b <= '9') {\n\t\t\t\tret = 10 * ret + b - '0';\n\t\t\t\tb = nextByte();\n\t\t\t}\n\n\t\t\treturn (negative) ? -ret : ret;\n\t\t}\n\n\t\tbyte nextByte() throws Exception {\n\t\t\tif (pointer == buffer.length) {\n\t\t\t\tdis.read(buffer, 0, buffer.length);\n\t\t\t\tpointer = 0;\n\t\t\t}\n\t\t\treturn buffer[pointer++];\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\tStringBuffer ret = new StringBuffer();\n\n\t\t\tbyte b;\n\t\t\tdo {\n\t\t\t\tb = nextByte();\n\t\t\t} while (b <= ' ');\n\t\t\twhile (b > ' ') {\n\t\t\t\tret.appendCodePoint(b);\n\t\t\t\tb = nextByte();\n\t\t\t}\n\n\t\t\treturn ret.toString();\n\t\t}\n\n\t}\n}\n", "index": 673, "complexity": 4}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class gamblingGame {\n    public static void main(String[] args) throws IOException {\n        ReaderClass reader = new ReaderClass();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = reader.nextInt();\n        Integer[] arrayA = new Integer[n];\n        Integer[] arrayB = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            arrayA[i] = reader.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            arrayB[i] = reader.nextInt();\n        }\n        calculateResult(n, arrayA, arrayB, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void calculateResult(int n, Integer[] arrayA, Integer[] arrayB, PrintWriter out) {\n        Arrays.sort(arrayA, Collections.reverseOrder());\n        Arrays.sort(arrayB, Collections.reverseOrder());\n        int indexA = 0, indexB = 0;\n        long scoreA = 0, scoreB = 0;\n        for (int i = 0; i < n * 2; i++) {\n            if (i % 2 == 0) {\n                if (indexB == n || (indexA < n && arrayA[indexA] > arrayB[indexB])) {\n                    scoreA += arrayA[indexA];\n                    indexA++;\n                } else indexB++;\n            } else {\n                if (indexA == n || (indexB < n && arrayB[indexB] > arrayA[indexA])) {\n                    scoreB += arrayB[indexB];\n                    indexB++;\n                } else indexA++;\n            }\n        }\n        out.println(scoreA - scoreB);\n    }\n\n    static class ReaderClass {\n        final private int BUFFER_SIZE = 1 << 16;\n        private BufferedReader bufferedReader;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public ReaderClass() {\n            bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public ReaderClass(String fileName) throws IOException {\n            bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] bufferArr = new byte[64];\n            int count = 0, character;\n            while ((character = readByte()) != -1) {\n                if (character == '\\n')\n                    break;\n                bufferArr[count++] = (byte) character;\n            }\n            return new String(bufferArr, 0, count);\n        }\n\n        public int nextInt() throws IOException {\n            int returnValue = 0;\n            byte character = readByte();\n            while (character <= ' ')\n                character = readByte();\n            boolean isNegative = (character == '-');\n            if (isNegative)\n                character = readByte();\n            do {\n                returnValue = returnValue * 10 + character - '0';\n            } while ((character = readByte()) >= '0' && character <= '9');\n\n            if (isNegative)\n                return -returnValue;\n            return returnValue;\n        }\n\n        public long nextLong() throws IOException {\n            long returnValue = 0;\n            byte character = readByte();\n            while (character <= ' ')\n                character = readByte();\n            boolean isNegative = (character == '-');\n            if (isNegative)\n                character = readByte();\n            do {\n                returnValue = returnValue * 10 + character - '0';\n            }\n            while ((character = readByte()) >= '0' && character <= '9');\n            if (isNegative)\n                return -returnValue;\n            return returnValue;\n        }\n\n        public double nextDouble() throws IOException {\n            double returnValue = 0, division = 1;\n            byte character = readByte();\n            while (character <= ' ')\n                character = readByte();\n            boolean isNegative = (character == '-');\n            if (isNegative)\n                character = readByte();\n\n            do {\n                returnValue = returnValue * 10 + character - '0';\n            }\n            while ((character = readByte()) >= '0' && character <= '9');\n\n            if (character == '.') {\n                while ((character = readByte()) >= '0' && character <= '9') {\n                    returnValue += (character - '0') / (division *= 10);\n                }\n            }\n\n            if (isNegative)\n                return -returnValue;\n            return returnValue;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = bufferedReader.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte readByte() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (bufferedReader == null)\n                return;\n            bufferedReader.close();\n        }\n    }\n}", "src": "import java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class gambling {\n    public static void main(String[] args) throws IOException{\n        Reader rd = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = rd.nextInt();\n        Integer[] a = new Integer[n];\n        Integer[] b = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = rd.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = rd.nextInt();\n        }\n        solve(n, a, b, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, Integer[] a, Integer[] b, PrintWriter out) {\n        Arrays.sort(a, Collections.reverseOrder());\n        Arrays.sort(b, Collections.reverseOrder());\n        int aP = 0, bP = 0;\n        long aScore = 0, bScore = 0;\n        for (int i = 0; i < n * 2; i++) {\n                if(i % 2 == 0) {\n                    if(bP ==  n || (aP < n && a[aP] > b[bP])){\n                        aScore += a[aP];\n                        aP++;\n                    }\n                    else bP++;\n                }\n                else{\n                    if(aP == n || (bP < n && b[bP] > a[aP])) {\n                        bScore += b[bP];\n                        bP++;\n                    }\n                    else aP++;\n                }\n        }\n        out.println(aScore-bScore);\n    }\n\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}\n", "index": 674, "complexity": 4}
{"back-translation": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class ladder {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int problems = sc.nextInt();\n        int i = 0;\n        while (i < problems) {\n            int numPlanks = sc.nextInt();\n            solve(numPlanks, sc);\n            i++;\n        }\n    }\n\n    public static void solve(int numPlanks, Scanner sc) {\n        int answer;\n        ArrayList<Integer> planks = new ArrayList<>();\n        int i = 0;\n        while (i < numPlanks) {\n            planks.add(sc.nextInt());\n            i++;\n        }\n\n        Collections.sort(planks);\n\n        planks.remove(numPlanks - 1);\n        planks.add(planks.get(numPlanks - 2));\n        int base = planks.get(numPlanks - 1) - 1;\n        if ((numPlanks - 2) > base) {\n            answer = base;\n        } else {\n            answer = numPlanks - 2;\n        }\n\n        if (base == 0) {\n            answer = 0;\n        }\n\n        System.out.println(answer);\n    }\n}", "src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class ladder {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int problems = sc.nextInt();\n        for (int i = 0; i < problems; i++) {\n            int numPlanks = sc.nextInt();\n            solve(numPlanks, sc);\n        }\n\n\n\n\n\n    }\n    public static void solve(int numPlanks, Scanner sc) {\n        int answer;\n        ArrayList<Integer> planks  = new ArrayList<>();\n        for (int i = 0; i < numPlanks; i++) {\n            planks.add(sc.nextInt());\n        }\n\n        Collections.sort(planks);\n\n        planks.remove(numPlanks - 1);\n        planks.add(planks.get(numPlanks - 2));\n        int base = planks.get(numPlanks - 1) - 1;\n        if ((numPlanks - 2) > base) {\n            answer = base;\n        }\n        else {\n            answer = numPlanks - 2;\n        }\n        if (base == 0) {\n            answer = 0;\n        }\n        System.out.println(answer);\n    }\n}\n", "index": 675, "complexity": 4}
{"back-translation": "import java.util.Arrays;\n\npublic class GFG {\n\n    static int findMinimum(int[] arr, int n, int k) {\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            res += arr[i];\n            n -= k;\n        }\n        return res;\n    }\n\n    static int findMaximum(int[] arr, int n, int k) {\n        int res = 0, index = 0;\n        for (int i = n - 1; i >= index; i--) {\n            res += arr[i];\n            index += k;\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {3, 2, 1, 4};\n        int n = arr.length;\n        int k = 2;\n        Arrays.sort(arr);\n\n        System.out.println(findMinimum(arr, n, k) + \" \" + findMaximum(arr, n, k));\n    }\n}", "src": "\n// Java implementation to find the \n// minimum and maximum amount \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Function to find the minimum \n\n// amount to buy all candies \n\nstatic\nint\nfindMinimum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n// Buy current candy \n\nres += arr[i]; \n\n\n// And take k candies for free \n\n// from the last \n\nn = n - k; \n\n} \n\nreturn\nres; \n\n} \n\n\n// Function to find the maximum \n\n// amount to buy all candies \n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n, index = \n0\n; \n\n\nfor\n(\nint\ni = n - \n1\n; i >= index; i--) \n\n{ \n\n// Buy candy with maximum amount \n\nres += arr[i]; \n\n\n// And get k candies for free from \n\n// the starting \n\nindex += k; \n\n} \n\nreturn\nres; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n3\n, \n2\n, \n1\n, \n4\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\nArrays.sort(arr); \n\n\nSystem.out.println(findMinimum(arr, n, k) + \n\n\" \"\n+ findMaximum(arr, n, k)); \n\n} \n} \n\n// This code is contributed by prerna saini ", "index": 676, "complexity": 4}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\n\npublic class LessorEqual_CodeForces {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString temp[] = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(temp[0]);\n\t\tint k = Integer.parseInt(temp[1]);\n\t\ttemp = br.readLine().split(\" \");\n\t\tint[] num = new int[n];\n\t\tPriorityQueue<Integer> pq = new PriorityQueue<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnum[i] = Integer.parseInt(temp[i]);\n\t\t\tpq.add(num[i]);\n\t\t}\n\t\tif (k == 0) {\n\t\t\tint y = pq.poll();\n\t\t\tif (y == 1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(y - 1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tint max = 0;\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint x = pq.poll();\n\t\t\twhile (count <= k && !pq.isEmpty() && pq.peek() == x) {\n\t\t\t\tpq.poll();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tmax = x;\n\t\t\tif (count == k)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (count == k) {\n\t\t\tif (!pq.contains(max + 1) && max < 1e9)\n\t\t\t\tSystem.out.println(max + 1);\n\t\t\telse\n\t\t\t\tSystem.out.println(max);\n\t\t} else\n\t\t\tSystem.out.println(-1);\n\t}\n\n}", "src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\npublic class LessorEqual_CodeForces {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString temp[]=br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(temp[0]);\n\t\tint k = Integer.parseInt(temp[1]);\n\t\ttemp=br.readLine().split(\" \");\n\t\tint [] num = new int[n];\n//\t\tint [] freq = new int [1000000000];\n\t\tPriorityQueue<Integer>pq = new PriorityQueue<Integer>();  \n\t\tfor(int i=0;i<n;i++){\n\t\t\tnum[i]=Integer.parseInt(temp[i]);\n\t\t\tpq.add(num[i]);\n\t\t//\tfreq[num[i]]++;\n\t\t\t\t\t\t\n\t\t}\n\t\tif(k==0){\n\t\t\tint y= pq.poll();\n\t\t\tif(y==1){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\tSystem.out.println(y-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\t//System.out.println(pq);\n\t\tint count=0;\n\t\tint max=0;\n\t\twhile (!pq.isEmpty()){\n\t\t\tint x = pq.poll();\n\t\t\twhile(count<=k&&!pq.isEmpty()&& pq.peek()==x){\n\t\t\t\tpq.poll();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t//\tSystem.out.println(x);\n\t\t\tcount++;\n\t\t\tmax=x;\n\t\t\tif(count==k)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t//System.out.println(\"the count is \"+ count);\n\t\tif(count==k){\n\t\t\tif(!pq.contains(max+1)&& max<1e9)\n\t\t\t\tSystem.out.println(max+1);\n\t\t\telse \n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\telse \n\t\t\tSystem.out.println(-1);\n \n\t\t\n\t}\n\n}\n", "index": 677, "complexity": 4}
{"back-translation": "import java.util.*;import java.io.*;class GFG {static void rearrange(int[] arr, int n, int x) {TreeMap<Integer, ArrayList<Integer>> m = new TreeMap<>();for (int i = 0; i < n; i++) {int diff = Math.abs(x - arr[i]);if (m.containsKey(diff)){ArrayList<Integer> al = m.get(diff);al.add(arr[i]);m.put(diff, al);}else {ArrayList<Integer> al = new ArrayList<>();al.add(arr[i]);m.put(diff,al);}}int index = 0;for (Map.Entry<Integer, ArrayList<Integer>> entry : m.entrySet()) {ArrayList<Integer> al = m.get(entry.getKey());for (int i = 0; i < al.size(); i++) arr[index++] = al.get(i);}}static void printArray(int[] arr, int n) {for (int i = 0; i < n; i++) System.out.print(arr[i] + ", "src": "\n// Java program to sort an array according absolute \n// difference with x. \nimport\njava.io.*; \nimport\njava.util.*; \n\nclass\nGFG \n{ \n\n\n// Function to sort an array according absolute \n\n// difference with x. \n\nstatic\nvoid\nrearrange(\nint\n[] arr, \nint\nn, \nint\nx) \n\n{ \n\nTreeMap<Integer, ArrayList<Integer>> m = \nnew\nTreeMap<>(); \n\n\n// Store values in a map with the difference \n\n// with X as key \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndiff = Math.abs(x - arr[i]); \n\nif\n(m.containsKey(diff)) \n\n{ \n\nArrayList<Integer> al = m.get(diff); \n\nal.add(arr[i]); \n\nm.put(diff, al); \n\n} \n\nelse\n\n{ \n\nArrayList<Integer> al = \nnew\nArrayList<>(); \n\nal.add(arr[i]); \n\nm.put(diff,al); \n\n} \n\n} \n\n\n// Update the values of array \n\nint\nindex = \n0\n; \n\nfor\n(Map.Entry entry : m.entrySet()) \n\n{ \n\nArrayList<Integer> al = m.get(entry.getKey()); \n\nfor\n(\nint\ni = \n0\n; i < al.size(); i++) \n\narr[index++] = al.get(i); \n\n} \n\n} \n\n\n// Function to print the array \n\nstatic\nvoid\nprintArray(\nint\n[] arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[] arr = {\n10\n, \n5\n, \n3\n, \n9\n,\n2\n}; \n\nint\nn = arr.length; \n\nint\nx = \n7\n; \n\nrearrange(arr, n, x); \n\nprintArray(arr, n); \n\n} \n} \n\n// This code is contributed by rachana soma ", "index": 678, "complexity": 4}
{"back-translation": "import javafx.util.Pair;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Beacon8 {\n    public static void main(String[] args) throws IOException {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        Map<Integer, Integer> beacons = new TreeMap<>();\n\n        for (int i = 0; i < n; i++) {\n            int index = scan.nextInt();\n            int power = scan.nextInt();\n            beacons.put(index, power);\n        }\n\n        int[] nDestroys = new int[n];\n        int[] indicesArr = beacons.keySet().stream().mapToInt(Integer::intValue).toArray();\n\n        for (int i = 0; i < n; i++) {\n            int bIndex = Arrays.binarySearch(indicesArr, indicesArr[i] - beacons.get(indicesArr[i]));\n            if (bIndex < 0)\n                bIndex = -(bIndex + 1);\n            nDestroys[i] = i - bIndex;\n        }\n\n        int[] totalBeacons = new int[n];\n        int maxBeacons = 1;\n        totalBeacons[0] = 1;\n\n        for (int i = 1; i < n; i++) {\n            if (nDestroys[i] == 0)\n                totalBeacons[i] = totalBeacons[i - 1] + 1;\n            else {\n                if (i - nDestroys[i] - 1 >= 0)\n                    totalBeacons[i] = totalBeacons[i - nDestroys[i] - 1] + 1;\n                else\n                    totalBeacons[i] = 1;\n            }\n\n            if (totalBeacons[i] > maxBeacons)\n                maxBeacons = totalBeacons[i];\n        }\n        System.out.println(n - maxBeacons);\n    }\n}", "src": "import javafx.util.Pair;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Beacon8 {\n    public static void main(String[] args) throws IOException {\n//        int[] arr = {1, 3, 7, 18};\n//        int bIndex = Arrays.binarySearch(arr, 4);\n//        System.out.println(bIndex);\n\n\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        Map<Integer, Integer> beacons = new TreeMap<>();\n\n        for (int i = 0; i < n; i++) {\n            int index = scan.nextInt();\n            int power = scan.nextInt();\n            beacons.put(index, power);\n        }\n        int[] indicesArr = new int[n];\n        int arrInd = 0;\n        for (int index : beacons.keySet()) {\n            indicesArr[arrInd] = index;\n            arrInd++;\n        }\n       // Integer[] indicesArr = ((Integer[])beacons.keySet().toArray());\n        int[] nDestroys = new int[n];\n        for (int i = 0; i < n; i++) {\n            int bIndex = Arrays.binarySearch(indicesArr, indicesArr[i] - beacons.get(indicesArr[i]));\n            if (bIndex < 0)\n                bIndex = -(bIndex + 1);\n            nDestroys[i] = i - bIndex;\n        }\n        int[] totalBeacons = new int[n];\n        int maxBeacons = 1;\n        totalBeacons[0] = 1;\n        for (int i = 1; i < n; i++) {\n            if (nDestroys[i] == 0)\n                totalBeacons[i] = totalBeacons[i - 1] + 1;\n            else {\n                if ((i - nDestroys[i] - 1) >= 0)\n                    totalBeacons[i] = totalBeacons[i - nDestroys[i] - 1] + 1;\n                else\n                    totalBeacons[i] = 1;\n            }\n               // totalBeacons[i] = totalBeacons[i - nDestroys[i]] + 1;\n            //totalBeacons[i] = i - nDestroys[i] + totalBeacons[i - nDestroys[i]] + 1;\n            if(totalBeacons[i] > maxBeacons)\n                maxBeacons = totalBeacons[i];\n        }\n//        System.out.println(\"\\ntotalBeacons array\");\n//        for (int i = 0; i < n; i++) {\n//            System.out.print(totalBeacons[i] + \" \");\n//        }\n//        if (maxBeacons == -1)\n//            System.out.println(n);\n        System.out.println(n - maxBeacons);\n    }\n\n}\n", "index": 679, "complexity": 4}
{"back-translation": "import java.util.*;\n\npublic class HelloWorld {\n    static long SQR(long a) {\n        return a * a;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        String str = sc.next();\n        char[] s = str.toCharArray();\n        Arrays.parallelSort(s);\n        str = new String(s);\n        int d = 0;\n        int ans = 0;\n\n        for (int i = 0; i < str.length(); i++) {\n            int x = str.charAt(i) - 'a';\n            if (k == 0) continue;\n            if (x >= d) {\n                ans = ans + x + 1;\n                d = x + 2;\n                k = k - 1;\n            }\n        }\n\n        if (k > 0)\n            ans = -1;\n\n        System.out.println(ans);\n    }\n}", "src": "\nimport java.util.*;\n\n\npublic class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}\n", "index": 680, "complexity": 4}
{"back-translation": "class GFG {\n    static int MinOperation(int[] a, int[] b, int n) {\n        Arrays.sort(a);\n        Arrays.sort(b);\n        int result = 0;\n        for (int i = 0; i < n; ++i) {\n            if (a[i] > b[i])\n                result = result + Math.abs(a[i] - b[i]);\n            else if (a[i] < b[i])\n                result = result + Math.abs(a[i] - b[i]);\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n        int[] a = {3, 1, 1};\n        int[] b = {1, 2, 2};\n        int n = a.length;\n        System.out.println(MinOperation(a, b, n));\n    }\n}", "src": "\n// Java program to find minimum \n// increment/decrement operations \n// to make array elements same. \nimport\njava.util.Arrays; \nimport\njava.io.*; \n\nclass\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nb[], \n\nint\nn) \n{ \n\n// sorting both arrays \n\n// in ascending order \n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n// variable to store \n\n// the final result \n\nint\nresult = \n0\n; \n\n\n// After sorting both arrays \n\n// Now each array is in non- \n\n// decreasing order. Thus, \n\n// we will now compare each \n\n// element of the array and \n\n// do the increment or decrement \n\n// operation depending upon the \n\n// value of array b[]. \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\nif\n(a[i] > b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n\nelse\nif\n(a[i] < b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n} \n\n\nreturn\nresult; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = {\n3\n, \n1\n, \n1\n}; \n\nint\nb[] = {\n1\n, \n2\n, \n2\n}; \n\nint\nn = a.length; \n\nSystem.out.println(MinOperation(a, b, n)); \n} \n} \n\n// This code is contributed \n// by akt_mit ", "index": 681, "complexity": 4}
{"back-translation": "import java.util.*;\npublic class test{\npublic static void main(String args[]){\nScanner s=new Scanner(System.in);\nint n=s.nextInt();\nint m=s.nextInt();\nint arr[]=new int[n];\nint max = Integer.MIN_VALUE;\nlong sum = 0;\nfor(int i=0;i<n;i++){\narr[i] = s.nextInt();\nsum = sum + arr[i];\nmax = Math.max(max,arr[i]);\n}\nArrays.sort(arr);\nint i = 0;\nint count = 0;\nint d = 0;\nfor(i=0; i<n; i++){\nif(arr[i] > d){\ncount++;\nd++;\n}else if(arr[i] == d && arr[i] > 0){\ncount++;\n}\n}\n//System.out.println(count + ' ' + max);\nif(max - d > 0){\ncount = count + max - d;\n}\nSystem.out.println(sum - count);}}", "src": "import java.util.*;\npublic class test{\npublic static void main(String args[])\n{\nScanner s=new Scanner(System.in);\nint n=s.nextInt();\nint m=s.nextInt();\nint arr[]=new int[n];\nint max = Integer.MIN_VALUE;\n        long sum = 0;\n        for(int i=0;i<n;i++)\n        {\n            arr[i] = s.nextInt();\n            sum = sum + arr[i];\n            max = Math.max(max,arr[i]);\n        }\n        Arrays.sort(arr);\n        int i = 0;\n        int count = 0;\n        int d = 0;\n        for(i=0; i<n; i++)\n        {\n            if(arr[i] > d)\n            {\n                count++;\n                d++;\n            }\n            else if(arr[i] == d && arr[i] > 0)\n            {\n                count++;\n            }\n        }\n        //System.out.println(count + \" \" + max);\n        if(max - d > 0)\n        {\n            count = count + max - d;\n        }\n        System.out.println(sum - count);}}", "index": 682, "complexity": 4}
{"back-translation": "import java.util.Arrays; public class GFG { static void preprocess(int[] coin, int n) { Arrays.sort(coin); for (int i = 1; i <= n - 1; i++) coin[i] += coin[i - 1]; } static int minCost(int[] coin, int n, int k) { int coins_needed = (int) Math.ceil(1.0 * n / (k + 1)); return coin[coins_needed - 1]; } static public void main(String[] args) { int[] coin = {8, 5, 3, 10, 2, 1, 15, 25}; int n = coin.length; preprocess(coin, n); int k = 3; System.out.println(minCost(coin, n, k)); k = 7; System.out.println(minCost(coin, n, k)); } }", "src": "\n// C# program to acquire all n coins at \n// minimum cost with multiple values of k. \nimport\njava .io.*; \nimport\njava.util.Arrays; \n\npublic\nclass\nGFG { \n\n\n// Converts coin[] to prefix sum array \n\nstatic\nvoid\npreprocess(\nint\n[]coin, \nint\nn) \n\n{ \n\n\n// sort the coins value \n\nArrays.sort(coin); \n\n\n// Maintain prefix sum array \n\nfor\n(\nint\ni = \n1\n; i <= n - \n1\n; i++) \n\ncoin[i] += coin[i - \n1\n]; \n\n} \n\n\n// Function to calculate min cost when we \n\n// can get k extra coins after paying \n\n// cost of one. \n\nstatic\nint\nminCost(\nint\n[]coin, \nint\nn, \nint\nk) \n\n{ \n\n\n// calculate no. of coins needed \n\nint\ncoins_needed =(\nint\n) Math.ceil(\n1.0\n\n* n / (k + \n1\n)); \n\n\n// return sum of from prefix array \n\nreturn\ncoin[coins_needed - \n1\n]; \n\n} \n\n\n// Driver Code \n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]coin = {\n8\n, \n5\n, \n3\n, \n10\n, \n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\n\npreprocess(coin, n); \n\n\nint\nk = \n3\n; \n\nSystem.out.println(minCost(coin, n, k)); \n\n\nk = \n7\n; \n\nSystem.out.println( minCost(coin, n, k)); \n\n} \n} \n\n// This code is contributed by anuj_67. ", "index": 683, "complexity": 4}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n\npublic class pr988B {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = Integer.parseInt(br.readLine());\n\n        ArrayList<String> a = new ArrayList<String>();\n\n        for (int i = 0; i < n; i++) {\n            a.add(br.readLine());\n        }\n\n        if(isOrdered(n, a)){\n            out.println(\"YES\");\n            for (String s : a) {\n                out.println(s);\n            }\n        }\n        else\n            out.println(\"NO\");\n\n        out.flush();\n        out.close();\n    }\n\n    private static boolean isOrdered(int n, ArrayList<String> a) {\n        a.sort(Comparator.comparingInt(String::length));\n        for (int i = 0; i < n - 1; i++) {\n            if(!a.get(i + 1).contains(a.get(i))) return false;\n        }\n        return true;\n    }\n}\n", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n\npublic class pr988B {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = Integer.parseInt(br.readLine());\n\n        ArrayList<String> a = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            a.add(br.readLine());\n        }\n\n        if(solve(n, a)){\n            out.println(\"YES\");\n            for (String s : a) {\n                out.println(s);\n            }\n        }\n        else\n            out.println(\"NO\");\n\n        out.flush();\n        out.close();\n    }\n\n    private static boolean solve(int n, ArrayList<String> a) {\n        a.sort(Comparator.comparingInt(String::length));\n        for (int i = 0; i < n - 1; i++) {\n            if(!a.get(i+1).contains(a.get(i))) return false;\n        }\n        return true;\n    }\n}\n", "index": 684, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class RadioStation {\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n    public static StringTokenizer st;\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        Map<String, String> map = new HashMap<String, String>();\n        for (int i = 0; i < n; i++) {\n            String s = nextString();\n            String t = nextString();\n            map.put(t, s);\n        }\n        for (int i = 0; i < m; i++) {\n            String s = nextString();\n            String t = nextString();\n            System.out.println(s + \" \" + t + \" #\" + map.get(t.substring(0, t.length() - 1)));\n        }\n    }\n\n    public static String nextLine() throws IOException {\n        return in.readLine();\n    }\n\n    public static String nextString() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(in.readLine());\n        return st.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(nextString());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(nextString());\n    }\n\n    public static int[] intArray(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextInt();\n        return a;\n    }\n\n    public static long[] longArray(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextLong();\n        return a;\n    }\n}", "src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class RadioStation {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tmap.put(t, s);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tSystem.out.println(s + \" \" + t + \" #\" + map.get(t.substring(0, t.length()-1)));\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 685, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\npublic final class Cf\n{\n    public static void main(String[]args)\n    {\n        FastReader ob=new FastReader();\n        {\n            int n=ob.nextInt();\n            int k=ob.nextInt();\n            int a[]=new int[n];\n            for(int i=0;i<n;i++)\n                a[i]=ob.nextInt();\n            int x=a[n-1]-a[0];\n            ArrayList<Integer> b=new ArrayList<>();\n            for(int i=0;i<n-1;i++)\n                b.add(-a[i+1]+a[i]);\n            Collections.sort(b);\n            for(int i=0;i<k-1;i++)\n                x+=b.get(i);\n            System.out.println(x);\n        }\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextLine()\n    {\n        String s=\"\";\n        try {\n            s=br.readLine();\n        } catch (IOException e)  {\n            e.printStackTrace();\n        }\n        return s;\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}", "src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n//BigInteger A;\n//A= BigInteger.valueOf(54);\n//ArrayList<Integer> a=new ArrayList<>();\n//TreeSet<Integer> ts=new TreeSet<>();\n//HashMap<Integer,Integer> hm=new HashMap<>();\npublic final class Cf\n{\n    public static void main(String[]args)\n    {\n        FastReader ob=new FastReader();\n        //int t=ob.nextInt();\n        //while(t-->0)\n        {\n            int n=ob.nextInt();\n            int k=ob.nextInt();\n            int a[]=new int[n];\n            for(int i=0;i<n;i++)\n            a[i]=ob.nextInt();\n            int x=a[n-1]-a[0];\n            ArrayList<Integer> b=new ArrayList<>();\n            for(int i=0;i<n-1;i++)\n            b.add(-a[i+1]+a[i]);\n            Collections.sort(b);\n            for(int i=0;i<k-1;i++)\n            x+=b.get(i);\n            System.out.println(x);\n        }\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextLine()\n    {\n        String s=\"\";\n        try {\n        s=br.readLine();\n        } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        return s;\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}", "index": 686, "complexity": 4}
{"back-translation": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\n\npublic class ChainReaction implements Closeable {\n\n    private InputReader in = new InputReader(System.in);\n    private PrintWriter out = new PrintWriter(System.out);\n\n    private class Beacon implements Comparable<Beacon> {\n        private int position, range, score;\n\n        private Beacon(int position, int range) {\n            this.position = position;\n            this.range = range;\n        }\n\n        public void setScore(int score) {\n            this.score = score;\n        }\n\n        @Override\n        public int compareTo(Beacon o) {\n            return Integer.compare(this.position, o.position);\n        }\n    }\n\n    private List<Beacon> beacons;\n    private Integer[] dp;\n\n    public void solve() {\n        int n = in.ni();\n        if (n == 1) {\n            out.println(0);\n            return;\n        }\n        beacons = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            beacons.add(new Beacon(in.ni(), in.ni()));\n        }\n        beacons.sort(Comparator.naturalOrder());\n        for (int i = 1; i < n; i++) {\n            int left = 0, right = i - 1, position = beacons.get(i).position, range = beacons.get(i).range;\n            int leftmost = i;\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (position - range <= beacons.get(mid).position) {\n                    leftmost = Math.min(leftmost, mid);\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            beacons.get(i).setScore(i - leftmost);\n        }\n        dp = new Integer[n];\n        int ans = Integer.MAX_VALUE;\n        for (int i = n - 1; i >= 0; i--) {\n            ans = Math.min(n - 1 - i + recurse(i), ans);\n        }\n        out.println(ans);\n    }\n\n    private int recurse(int idx) {\n        if (idx <= 0) return 0;\n\n        if (dp[idx] != null) return dp[idx];\n\n        int destroyed = beacons.get(idx).score;\n        int ans = destroyed + recurse(idx - destroyed - 1);\n        return dp[idx] = ans;\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n        out.close();\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(next());\n        }\n\n        public long nl() {\n            return Long.parseLong(next());\n        }\n\n        public void close() throws IOException {\n            reader.close();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (ChainReaction instance = new ChainReaction()) {\n            instance.solve();\n        }\n    }\n}", "src": "\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class ChainReaction implements Closeable {\n\n  private InputReader in = new InputReader(System.in);\n  private PrintWriter out = new PrintWriter(System.out);\n  \n  private class Beacon implements Comparable<Beacon> {\n    private int position, range, score;\n\n    private Beacon(int position, int range) {\n      this.position = position;\n      this.range = range;\n    }\n\n    public void setScore(int score) {\n      this.score = score;\n    }\n\n    @Override\n    public int compareTo(Beacon o) {\n      return Integer.compare(this.position, o.position);\n    }\n  }\n\n  public void solve() {\n    int n = in.ni();\n    if (n == 1) {\n      out.println(0);\n      return;\n    }\n    beacons = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      beacons.add(new Beacon(in.ni(), in.ni()));\n    }\n    beacons.sort(Comparator.naturalOrder());\n    for (int i = 1; i < n; i++) {\n      int left = 0, right = i - 1, position = beacons.get(i).position, range = beacons.get(i).range;\n      int leftmost = i;\n      while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (position - range <= beacons.get(mid).position) {\n          leftmost = Math.min(leftmost, mid);\n          right = mid - 1;\n        } else {\n          left = mid + 1;\n        }\n      }\n      beacons.get(i).setScore(i - leftmost);\n    }\n    dp = new Integer[n];\n    int ans = Integer.MAX_VALUE;\n    for (int i = n - 1; i >= 0; i--) {\n      ans = Math.min(n - 1 - i + recurse(i), ans);\n    }\n    out.println(ans);\n  }\n  \n  private List<Beacon> beacons;\n  private Integer[] dp;\n  \n  private int recurse(int idx) {\n    if (idx <= 0) return 0;\n    \n    if (dp[idx] != null) return dp[idx];\n    \n    int destroyed = beacons.get(idx).score;\n    int ans = destroyed + recurse(idx - destroyed - 1);\n    return dp[idx] = ans;\n  }\n  \n  @Override\n  public void close() throws IOException {\n    in.close();\n    out.close();\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int ni() {\n      return Integer.parseInt(next());\n    }\n\n    public long nl() {\n      return Long.parseLong(next());\n    }\n\n    public void close() throws IOException {\n      reader.close();\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    try (ChainReaction instance = new ChainReaction()) {\n      instance.solve();\n    }\n  }\n}\n", "index": 690, "complexity": 4}
{"back-translation": "import java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] a = new int[n];\n        int[] b = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        for (int i = 0; i < n; i++) {\n            b[i] = sc.nextInt();\n        }\n\n        int[] c = new int[2 * n];\n        c[0] = a[0];\n\n        for (int i = 1; i < n; i++) {\n            c[i * 2] = a[i];\n            c[i * 2 - 1] = b[i];\n            if (a[i] == 1 || b[i] == 1) {\n                System.out.print(-1);\n                System.exit(0);\n            }\n        }\n\n        c[2 * n - 1] = b[0];\n\n        if (a[0] == 1 || b[0] == 1) {\n            System.out.print(-1);\n            System.exit(0);\n        }\n\n        System.out.println(bin_search(c, m));\n    }\n\n    private static double bin_search(int[] c, int m) {\n        double start = 0;\n        double end = Integer.MAX_VALUE;\n        double mid;\n\n        while (start + 0.0000001 < end) {\n            mid = (start + end) / 2;\n\n            if (test(mid, m, c)) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n\n        return end;\n    }\n\n    private static boolean test(double fuel, int m, int[] c) {\n        for (int i = 0; i < c.length; i++) {\n            fuel -= (m + fuel) / c[i];\n            if (fuel < 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}", "src": "import java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int a[] = new int[n];\n        int b[] = new int[n];\n        for (int i = 0; i < n; i++) a[i] = sc.nextInt();\n        for (int i = 0; i < n; i++) b[i] = sc.nextInt();\n        int c[] = new int[2 * n];\n        c[0] = a[0];\n        for (int i = 1; i < n; i++) {\n            c[i * 2] = a[i];\n            c[i * 2 - 1] = b[i];\n            if (a[i] == 1 || b[i] == 1) {\n                System.out.print(-1);\n                System.exit(0);\n            }\n        }\n        c[2 * n - 1] = b[0];\n        if (a[0] == 1 || b[0] == 1) {\n            System.out.print(-1);\n            System.exit(0);\n        }\n        System.out.println(bin_search(c, m));\n    }\n\n    private static double bin_search(int[] c, int m) {\n        double start = 0;\n        double end = Integer.MAX_VALUE;\n        double mid;\n        while (start + 0.0000001 < end) {\n            mid = (start + end) / 2;\n            if (test(mid, m, c)) end = mid;\n            else start = mid;\n        }\n        return end;\n    }\n\n    private static boolean test(double fuel, int m, int[] c) {\n        for (int i = 0; i < c.length; i++) {\n            fuel -= (m + fuel) / c[i];\n            if (fuel < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "index": 691, "complexity": 4}
{"back-translation": "ERROR", "src": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.*;\nimport java.security.SecureRandom;\n\npublic class WCS {\n\t\n\tpublic static class Vector implements Comparable <Vector>  {\n\t\tlong x, y;\n\t\tint position;\n\t\tVector first, second;\n\t\tboolean toReverse;\n\t\t\n\t\tpublic Vector(long xx, long yy, int p) {\n\t\t\tx = xx;\n\t\t\ty = yy;\n\t\t\tposition = p;\n\t\t\tfirst = null;\n\t\t\tsecond = null;\n\t\t\ttoReverse = false;\n\t\t}\n\t\t\n\t\tpublic Vector negate() {\n\t\t\tVector vv = new Vector(-x, -y, position);\n\t\t\tvv.first = first;\n\t\t\tvv.second = second;\n\t\t\tvv.toReverse = !toReverse;\n\t\t\treturn vv;\n\t\t}\n\t\t\n\t\tpublic Vector add(Vector v) {\n\t\t\tVector sum = new Vector(this.x + v.x, this.y + v.y, position);\n\t\t\tsum.first = this;\n\t\t\tsum.second = v;\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tpublic Vector subtract(Vector v) {\n\t\t\treturn this.add(v.negate());\n\t\t}\n\t\t\n\t\tpublic double euclideanNorm() {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Vector v) {\n\t\t\tdouble thisa = Math.atan2(this.y, this.x);\n\t\t\tdouble va = Math.atan2(v.y, v.x);\n\t\t\tif(thisa < 0)\n\t\t\t\tthisa += 2 * Math.PI;\n\t\t\tif(va < 0)\n\t\t\t\tva += 2 * Math.PI;\n\t\t\tif(thisa < va)\n\t\t\t\treturn -1;\n\t\t\tif(thisa > va)\n\t\t\t\treturn 1;\n\t\t\treturn Integer.compare(this.position, v.position);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y;\n\t\t}\n\t}\n\t\n\tpublic static void dfs(Vector curr, int[] ans) {\n\t\tif(curr.first == null) {\n\t\t\tans[curr.position] = curr.toReverse ? -1 : 1;\n\t\t\treturn;\n\t\t}\n\t\tcurr.first.toReverse ^= curr.toReverse;\n\t\tcurr.second.toReverse ^= curr.toReverse;\n\t\tdfs(curr.first, ans);\n\t\tdfs(curr.second, ans);\n\t}\n\t\n\tpublic static boolean ok(Vector v1, Vector v2) {\n\t\treturn v1.add(v2).euclideanNorm() <= Math.max(v1.euclideanNorm(), v2.euclideanNorm());\n\t}\n\t\n\tpublic static void stop(long k) {\n\t\tlong time = System.currentTimeMillis();\n\t\twhile(System.currentTimeMillis() - time < k);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = in.nextInt();\n\t\tTreeSet <Vector> vectors = new TreeSet <> ();\n\t\tfor(int i = 0; i < n; i ++) {\n\t\t\tVector v = new Vector(in.nextLong(), in.nextLong(), i);\n\t\t\tvectors.add(v);\n\t\t}\n\t\twhile(vectors.size() > 2) {\n\t\t\t//System.out.println(vectors);\n\t\t\t//stop(500);\n\t\t\t\n\t\t\tTreeSet <Vector> support = new TreeSet <> ();\n\t\t\t\n\t\t\twhile(vectors.size() > 0) {\n\t\t\t\tVector curr = vectors.pollFirst();\n\t\t\t\tVector next1 = vectors.higher(curr);\n\t\t\t\tVector next2 = vectors.lower(curr.negate());\n\t\t\t\tVector next3 = vectors.higher(curr.negate());\n\t\t\t\tVector next4 = vectors.lower(curr);\n\t\t\t\t\n\t\t\t\t//System.out.println(\"CURR: \" + curr + \"\\n\" + next1 + \"\\n\" + next2);\n\t\t\t\t\n\t\t\t\tif(next1 != null) {\n\t\t\t\t\tif(ok(curr, next1)) {\n\t\t\t\t\t\tsupport.add(curr.add(next1));\n\t\t\t\t\t\tvectors.remove(next1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next1 != null) {\n\t\t\t\t\tif(ok(curr, next1.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next1));\n\t\t\t\t\t\tvectors.remove(next1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next2 != null) {\n\t\t\t\t\tif(ok(curr, next2)) {\n\t\t\t\t\t\tsupport.add(curr.add(next2));\n\t\t\t\t\t\tvectors.remove(next2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next2 != null) {\n\t\t\t\t\tif(ok(curr, next2.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next2));\n\t\t\t\t\t\tvectors.remove(next2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next3 != null) {\n\t\t\t\t\tif(ok(curr, next3)) {\n\t\t\t\t\t\tsupport.add(curr.add(next3));\n\t\t\t\t\t\tvectors.remove(next3);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next3 != null) {\n\t\t\t\t\tif(ok(curr, next3.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next3));\n\t\t\t\t\t\tvectors.remove(next3);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next4 != null) {\n\t\t\t\t\tif(ok(curr, next4)) {\n\t\t\t\t\t\tsupport.add(curr.add(next4));\n\t\t\t\t\t\tvectors.remove(next4);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next4 != null) {\n\t\t\t\t\tif(ok(curr, next4.negate())) {\n\t\t\t\t\t\tsupport.add(curr.subtract(next4));\n\t\t\t\t\t\tvectors.remove(next4);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsupport.add(curr);\n\t\t\t}\n\t\t\t\n\t\t\tvectors = support;\n\t\t}\n\t\t\n\t\tif(vectors.size() == 2) {\n\t\t\tVector curr = vectors.pollFirst();\n\t\t\tVector next = vectors.pollFirst();\n\t\t\tVector add = curr.add(next);\n\t\t\tVector sub = curr.subtract(next);\n\t\t\tif(sub.euclideanNorm() <= add.euclideanNorm())\n\t\t\t\tvectors.add(sub);\n\t\t\telse\n\t\t\t\tvectors.add(add);\n\t\t}\n\t\t\n\t\t//System.out.println(vectors.first().euclideanNorm());\n\t\t\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint[] ans = new int[n];\n\t\tdfs(vectors.pollFirst(), ans);\n\t\tfor(int i = 0; i < n; i ++)\n\t\t\tbuffer.append(ans[i] + \" \");\n\t\tSystem.out.println(buffer);\n\t}\n    \n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        BigInteger nextBigInteger() {\n        \treturn new BigInteger(in.next());\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        char nextChar() {\n            return in.next().charAt(0);\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    static FastReader in = new FastReader();\n    static OutputStream out = new BufferedOutputStream(System.out);\n    \n    public static byte[] toByte(Object o) {\n        return String.valueOf(o).getBytes();\n    }\n    \n    public static void sop(Object o) {\n        System.out.print(o);\n    }\n}", "index": 692, "complexity": 4}
{"back-translation": "import java.util.Arrays; public class GfG { public static void rearrangeArr(int[] arr, int n) { int evenPos = n / 2; int oddPos = n - evenPos; int[] tempArr = new int[n]; for (int i = 0; i < n; i++) tempArr[i] = arr[i]; Arrays.sort(tempArr); int j = oddPos - 1; for (int i = 0; i < n; i += 2) { arr[i] = tempArr[j]; j--; } j = oddPos; for (int i = 1; i < n; i += 2) { arr[i] = tempArr[j]; j++; } for (int i = 0; i < n; i++) System.out.print(arr[i] + \" \"); } public static void main(String argc[]) { int[] arr = new int[]{1, 2, 3, 4, 5, 6, 7}; int size = 7; rearrangeArr(arr, size); } }", "src": "\n// Java program to rearrange the array \n// as per the given condition \nimport\njava.util.*; \nimport\njava.lang.*; \n\npublic\nclass\nGfG{ \n\n// function to rearrange the array \n\npublic\nstatic\nvoid\nrearrangeArr(\nint\narr[], \n\nint\nn) \n\n{ \n\n// total even positions \n\nint\nevenPos = n / \n2\n; \n\n\n// total odd positions \n\nint\noddPos = n - evenPos; \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n\n\n// copy original array in an \n\n// auxiliary array \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ntempArr[i] = arr[i]; \n\n\n// sort the auxiliary array \n\nArrays.sort(tempArr); \n\n\nint\nj = oddPos - \n1\n; \n\n\n// fill up odd position in \n\n// original array \n\nfor\n(\nint\ni = \n0\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj--; \n\n} \n\n\nj = oddPos; \n\n\n// fill up even positions in \n\n// original array \n\nfor\n(\nint\ni = \n1\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj++; \n\n} \n\n\n// display array \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n// Driver function \n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\nint\n[] arr = \nnew\nint\n[]{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n\n6\n, \n7\n}; \n\nint\nsize = \n7\n; \n\nrearrangeArr(arr, size); \n\n\n} \n} \n\n/* This code is contributed by Sagar Shukla */", "index": 694, "complexity": 4}
{"back-translation": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Solution {\n\n    private static int[] a;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt(), m = sc.nextInt();\n\n        a = new int[101];\n        for (int i = 0; i < m; i++) {\n            int type = sc.nextInt();\n            a[type] = a[type] + 1;\n        }\n\n        int lo = 1, hi = 100, max = 0;\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (check(n, mid)) {\n                max = mid;\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        System.out.println(max);\n    }\n\n    public static boolean check(int n, int target) {\n        int result = 0;\n        for (int i = 0; i < a.length; i++) {\n            result = result + (a[i] / target);\n        }\n        if (result >= n) {\n            return true;\n        }\n        return false;\n    }\n}", "src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Solution {\n\n    private static int[] a;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt(), m = sc.nextInt();\n\n        a = new int[101];\n        for (int i = 0; i < m; i++) {\n            int type = sc.nextInt();\n            a[type] = a[type] + 1;\n        }\n\n        int lo=1, hi=100, max=0;\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo)/2;\n            if (check(n, mid)) {\n                max = mid;\n                lo = mid+1;\n            } else {\n                hi = mid -1;\n            }\n        }\n        System.out.println(max);\n    }\n\n    public static boolean check(int n, int target) {\n        int result = 0;\n        for (int i=0; i <a.length; i++) {\n            result = result + (a[i] / target);\n        }\n        if (result >= n) {return true;}\n        return false;\n    }\n}", "index": 695, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    static class Data{\n        int x,i;\n        Data(int x,int i){\n            this.x = x;\n            this.i = i;\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\"\\\\s\");\n        int N = Integer.parseInt(s[0]);\n        int K = Integer.parseInt(s[1]);\n        s = br.readLine().split(\"\\\\s\");\n        int[] arr = new int[N];\n        for(int i=0;i<N;++i) arr[i] = Integer.parseInt(s[i]);\n        solve(N,K,arr);   \n    }\n    \n    private static void solve(int N,int K,int[] arr){\n       PriorityQueue<Data> pq = new PriorityQueue<Data>(2000,(a,b) -> a.x - b.x == 0 ? b.i - a.i : b.x - a.x);\n       for(int i=0;i<arr.length;++i){\n           pq.offer(new Data(arr[i],i));\n       }\n       \n       int tot_sum = 0;\n       List<Integer> ls = new ArrayList<>();\n       Set<Integer> set = new HashSet<>();\n       \n       for(int i=1;i<=K;++i){\n           Data t = pq.poll();\n           tot_sum += t.x;\n           set.add(t.i);\n       }\n       int last = -1;\n       for(int i =0;i<arr.length;++i){\n           if(set.contains(i)){\n               K--;\n               if(K == 0) ls.add(arr.length-last-1);\n               else ls.add(i-last);\n               last = i;\n           }\n       }\n       \n       System.out.println(tot_sum);\n       int size = ls.size();\n       for(int i=0;i<size;++i){\n           System.out.print(ls.get(i) + \" \");\n       }\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    static class Data{\n        int x,i;\n        Data(int x,int i){\n            this.x = x;\n            this.i = i;\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\"\\\\s\");\n        int N = Integer.parseInt(s[0]);\n        int K = Integer.parseInt(s[1]);\n        s = br.readLine().split(\"\\\\s\");\n        int[] arr = new int[N];\n        for(int i=0;i<N;++i) arr[i] = Integer.parseInt(s[i]);\n        solve(N,K,arr);   \n    }\n    \n    private static void solve(int N,int K,int[] arr){\n       PriorityQueue<Data> pq = new PriorityQueue<Data>(2000,(a,b) -> a.x - b.x == 0 ? b.i - a.i : b.x - a.x);\n       for(int i=0;i<arr.length;++i){\n           pq.offer(new Data(arr[i],i));\n       }\n       \n       int tot_sum = 0;\n       List<Integer> ls = new ArrayList<>();\n       Set<Integer> set = new HashSet<>();\n       \n       for(int i=1;i<=K;++i){\n           Data t = pq.poll();\n           tot_sum += t.x;\n           set.add(t.i);\n       }\n       int last = -1;\n       for(int i =0;i<arr.length;++i){\n           if(set.contains(i)){\n               K--;\n               //System.out.println(i);\n               if(K == 0) ls.add(arr.length-last-1);\n               else ls.add(i-last);\n               last = i;\n           }\n       }\n       \n       System.out.println(tot_sum);\n       int size = ls.size();\n       for(int i=0;i<size;++i){\n           System.out.print(ls.get(i) + \" \");\n       }\n    }\n}", "index": 696, "complexity": 4}
{"back-translation": "import java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class BigInteger7 {\n    public static void main(String[] args) {\n        //https://codeforces.com/contest/1011/problem/A\n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}", "src": "import java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class BigInteger7 {\n    public static void main(String[] args) {\n        //https://codeforces.com/contest/1011/problem/A\n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}\n", "index": 697, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class codef {\n    public static void main(String[] ar) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer nk = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(nk.nextToken());\n        int k = Integer.parseInt(nk.nextToken());\n        String[] st = br.readLine().split(\" \");\n\n        int[] ans = new int[n];\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            ans[i] = Integer.parseInt(st[i]);\n\n        for (int i = 1; i < n; i++)\n            a[i] = ans[i] - ans[i - 1];\n        a[0] = -1;\n\n        Arrays.sort(a);\n        int count = 0, sum = 0;\n        for (int i = 0; i < n; i++)\n            if (a[i] < 0)\n                count++;\n            else\n                sum = sum + a[i];\n\n        k = k - count;\n        int i = n - 1;\n        while (k > 0 && i >= 0) {\n            if (a[i] > -1) {\n                sum = sum - a[i];\n                k--;\n            }\n            i--;\n        }\n        System.out.println(sum);\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\nimport javax.lang.model.util.ElementScanner6;\npublic class codef\n{\n    public static void main(String ar[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer nk=new StringTokenizer(br.readLine());\n        int n=Integer.parseInt(nk.nextToken());\n        int k=Integer.parseInt(nk.nextToken());\n        String st[]=br.readLine().split(\" \");\n        \n        int ans[]=new int[n];\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n            ans[i]=Integer.parseInt(st[i]);  \n\n        for(int i=1;i<n;i++)\n            a[i]=ans[i]-ans[i-1];\n        a[0]=-1;\n\n        Arrays.sort(a);\n        int count=0,sum=0;\n        for(int i=0;i<n;i++)\n            if(a[i]<0)\n                count++;\n            else\n                sum=sum+a[i];\n        \n        k=k-count;\n        int i=n-1;\n        while(k>0 && i>=0)\n        {\n            if(a[i]>-1)\n            {\n                sum=sum-a[i];\n                k--;\n            }\n            i--;\n        }\n        System.out.println(sum);\n    }\n}", "index": 698, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.Arrays;\n\nclass GFG {\n\nstatic int minOps(int arr[], int n, int k) {\nArrays.sort(arr);\nint max = arr[arr.length - 1];\nint res = 0;\nfor (int i = 0; i < n; i++) {\nif ((max - arr[i]) % k != 0)\nreturn -1;\nelse\nres += (max - arr[i]) / k;\n}\nreturn res;\n}\n\npublic static void main(String[] args) {\nint arr[] = { 21, 33, 9, 45, 63 };\nint n = arr.length;\nint k = 6;\nSystem.out.println(minOps(arr, n, k));\n}\n}", "src": "\n// Program to make all array equal \nimport\njava.io.*; \nimport\njava.util.Arrays; \n\nclass\nGFG { \n\n// function for calculating min operations \n\nstatic\nint\nminOps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n// max elements of array \n\nArrays.sort(arr); \n\nint\nmax = arr[arr.length - \n1\n]; \n\nint\nres = \n0\n; \n\n\n// iterate for all elements \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// check if element can make equal to \n\n// max or not if not then return -1 \n\nif\n((max - arr[i]) % k != \n0\n) \n\nreturn\n-\n1\n; \n\n\n// else update res for required operations \n\nelse\n\nres += (max - arr[i]) / k; \n\n} \n\n\n// return result \n\nreturn\nres; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n21\n, \n33\n, \n9\n, \n45\n, \n63\n}; \n\nint\nn = arr.length; \n\nint\nk = \n6\n; \n\nSystem.out.println(minOps(arr, n, k)); \n\n} \n} \n\n// This code is contributed by vt_m ", "index": 699, "complexity": 4}
{"back-translation": "import java.util.*;import java.io.*;import java.lang.Math;class LIS{static int CeilIndex(int[]A,int l,int r,int key){while(r-l>1){int m=l+(r-l)/2;if(A[m]>=key)r=m;elsel=m;}return r;}static int LongestIncreasingSubsequenceLength(int[]A,int size){int[]tailTable=new int[size];int len;tailTable[0]=A[0];len=1;for(int i=1;i<size;i++){if(A[i]<tailTable[0])tailTable[0]=A[i];else if(A[i]>tailTable[len-1])tailTable[len++]=A[i];elsetailTable[CeilIndex(tailTable,-1,len-1,A[i])]=A[i];}return len;}public static void main(String[]args){int[]A={2,5,3,7,11,8,10,13,6};int n=A.length;System.out.println(\"Length of Longest Increasing Subsequence is \"+LongestIncreasingSubsequenceLength(A,n));}}", "src": "\n// Java program to find length of longest increasing subsequence \n// in O(n Log n) time \nimport\njava.io.*; \nimport\njava.util.*; \nimport\njava.lang.Math; \n\nclass\nLIS { \n\n// Binary search (note boundaries in the caller) \n\n// A[] is ceilIndex in the caller \n\nstatic\nint\nCeilIndex(\nint\nA[], \nint\nl, \nint\nr, \nint\nkey) \n\n{ \n\nwhile\n(r - l > \n1\n) { \n\nint\nm = l + (r - l) / \n2\n; \n\nif\n(A[m] >= key) \n\nr = m; \n\nelse\n\nl = m; \n\n} \n\n\nreturn\nr; \n\n} \n\n\nstatic\nint\nLongestIncreasingSubsequenceLength(\nint\nA[], \nint\nsize) \n\n{ \n\n// Add boundary case, when array size is one \n\n\nint\n[] tailTable = \nnew\nint\n[size]; \n\nint\nlen; \n// always points empty slot \n\n\ntailTable[\n0\n] = A[\n0\n]; \n\nlen = \n1\n; \n\nfor\n(\nint\ni = \n1\n; i < size; i++) { \n\nif\n(A[i] < tailTable[\n0\n]) \n\n// new smallest value \n\ntailTable[\n0\n] = A[i]; \n\n\nelse\nif\n(A[i] > tailTable[len - \n1\n]) \n\n// A[i] wants to extend largest subsequence \n\ntailTable[len++] = A[i]; \n\n\nelse\n\n// A[i] wants to be current end candidate of an existing \n\n// subsequence. It will replace ceil value in tailTable \n\ntailTable[CeilIndex(tailTable, -\n1\n, len - \n1\n, A[i])] = A[i]; \n\n} \n\n\nreturn\nlen; \n\n} \n\n\n// Driver program to test above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n2\n, \n5\n, \n3\n, \n7\n, \n11\n, \n8\n, \n10\n, \n13\n, \n6\n}; \n\nint\nn = A.length; \n\nSystem.out.println(\n\"Length of Longest Increasing Subsequence is \"\n+ LongestIncreasingSubsequenceLength(A, n)); \n\n} \n} \n/* This code is contributed by Devesh Agrawal*/", "index": 700, "complexity": 4}
{"back-translation": "import java.util.PriorityQueue; class GFG { public static int DecreasingArray(int[] a, int n) { int sum = 0, dif = 0; PriorityQueue<Integer> pq = new PriorityQueue<>(); for (int i = 0; i < n; i++) { if (!pq.isEmpty() && pq.peek() < a[i]) { dif = a[i] - pq.peek(); sum += dif; pq.poll(); pq.add(a[i]); } pq.add(a[i]); } return sum; } public static void main(String[] args) { int[] a = { 3, 1, 2, 1 }; int n = a.length; System.out.println(DecreasingArray(a, n)); } }", "src": "\n// Java code to count the change required to \n// convert the array into non-increasing array \nimport\njava.util.PriorityQueue; \n\nclass\nGFG \n{ \n\npublic\nstatic\nint\nDecreasingArray(\nint\na[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n, dif = \n0\n; \n\n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<>(); \n\n\n// Here in the loop we will \n\n// check that whether the upcoming \n\n// element of array is less than top \n\n// of priority queue. If yes then we \n\n// calculate the difference. After \n\n// that we will remove that element \n\n// and push the current element in \n\n// queue. And the sum is incremented \n\n// by the value of difference \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(!pq.isEmpty() && pq.element() < a[i]) \n\n{ \n\ndif = a[i] - pq.element(); \n\nsum += dif; \n\npq.remove(); \n\npq.add(a[i]); \n\n} \n\npq.add(a[i]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] a = {\n3\n, \n1\n, \n2\n, \n1\n}; \n\n\nint\nn = a.length; \n\n\nSystem.out.println(DecreasingArray(a, n)); \n\n} \n} \n\n// This Code is contributed by sanjeev2552 ", "index": 702, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = new int[n];\n        HashMap<Integer, Integer> map = new HashMap<>();\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            int x = Integer.parseInt(st.nextToken());\n            arr[i] = x;\n            if (!map.containsKey(x)) {\n                map.put(x, 1);\n            } else {\n                map.replace(x, map.get(x) + 1);\n            }\n        }\n        int[] power = new int[31];\n        for (int i = 0; i < 31; i++) {\n            power[i] = 1 << i;\n        }\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            boolean f = false;\n            for (int j = 0; j <= 30; j++) {\n                int check = power[j] - arr[i];\n                if ((map.containsKey(check) && check != arr[i])) {\n                    f = true;\n                    break;\n                }\n                if ((map.containsKey(check) && check == arr[i] && map.get(check) >= 2)) {\n                    f = true;\n                    break;\n                }\n            }\n            if (!f) {\n                c++;\n            }\n        }\n        System.out.println(c);\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = new int[n];\n        HashMap<Integer, Integer> map = new HashMap<>();\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            int x = Integer.parseInt(st.nextToken());\n            arr[i] = x;\n            if (!map.containsKey(x)) {\n                map.put(x, 1);\n            } else {\n                map.replace(x, map.get(x) + 1);\n            }\n        }\n        int[] power = new int[31];\n        for (int i = 0; i < 31; i++) {\n            power[i] = 1 << i; // 0 100=4 1000=8 10000=16\n        }\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n        boolean f = false;\n        for (int j = 0; j <= 30; j++) {\n        int check = power[j] - arr[i];\n                if ((map.containsKey(check) && check != arr[i])) {\n                f = true; break;}\n                if((map.containsKey(check) && check == arr[i] && map.get(check) >=2)) {\n                    f = true; break;\n                }\n            }\n            if (!f) {\n                c++;\n            }\n        }\n        System.out.println(c);\n    }\n}", "index": 704, "complexity": 4}
{"back-translation": "import java.util.PriorityQueue; import java.util.Scanner; import java.util.Comparator; class HuffmanNode { int data; char c; HuffmanNode left; HuffmanNode right; } class MyComparator implements Comparator<HuffmanNode> { public int compare(HuffmanNode x, HuffmanNode y) { return x.data - y.data; } } public class Huffman { public static void printCode(HuffmanNode root, String s) { if (root.left == null && root.right == null && Character.isLetter(root.c)) { System.out.println(root.c + \":\" + s); return; } printCode(root.left, s + \"0\"); printCode(root.right, s + \"1\"); } public static void main(String[] args) { Scanner s = new Scanner(System.in); int n = 6; char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' }; int[] charfreq = { 5, 9, 12, 13, 16, 45 }; PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(n, new MyComparator()); for (int i = 0; i < n; i++) { HuffmanNode hn = new HuffmanNode(); hn.c = charArray[i]; hn.data = charfreq[i]; hn.left = null; hn.right = null; q.add(hn); } HuffmanNode root = null; while (q.size() > 1) { HuffmanNode x = q.peek(); q.poll(); HuffmanNode y = q.peek(); q.poll(); HuffmanNode f = new HuffmanNode(); f.data = x.data + y.data; f.c = '-'; f.left = x; f.right = y; root = f; q.add(f); } printCode(root, \"\"); } } ", "src": "\nimport\njava.util.PriorityQueue; \nimport\njava.util.Scanner; \nimport\njava.util.Comparator; \n\n// node class is the basic structure \n// of each node present in the Huffman - tree. \nclass\nHuffmanNode { \n\n\nint\ndata; \n\nchar\nc; \n\n\nHuffmanNode left; \n\nHuffmanNode right; \n} \n\n// comparator class helps to compare the node \n// on the basis of one of its attribute. \n// Here we will be compared \n// on the basis of data values of the nodes. \nclass\nMyComparator \nimplements\nComparator<HuffmanNode> { \n\npublic\nint\ncompare(HuffmanNode x, HuffmanNode y) \n\n{ \n\n\nreturn\nx.data - y.data; \n\n} \n} \n\npublic\nclass\nHuffman { \n\n\n// recursive function to print the \n\n// huffman-code through the tree traversal. \n\n// Here s is the huffman - code generated. \n\npublic\nstatic\nvoid\nprintCode(HuffmanNode root, String s) \n\n{ \n\n\n// base case; if the left and right are null \n\n// then its a leaf node and we print \n\n// the code s generated by traversing the tree. \n\nif\n(root.left \n\n== \nnull\n\n&& root.right \n\n== \nnull\n\n&& Character.isLetter(root.c)) { \n\n\n// c is the character in the node \n\nSystem.out.println(root.c + \n\":\"\n+ s); \n\n\nreturn\n; \n\n} \n\n\n// if we go to left then add \"0\" to the code. \n\n// if we go to the right add\"1\" to the code. \n\n\n// recursive calls for left and \n\n// right sub-tree of the generated tree. \n\nprintCode(root.left, s + \n\"0\"\n); \n\nprintCode(root.right, s + \n\"1\"\n); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nScanner s = \nnew\nScanner(System.in); \n\n\n// number of characters. \n\nint\nn = \n6\n; \n\nchar\n[] charArray = { \n'a'\n, \n'b'\n, \n'c'\n, \n'd'\n, \n'e'\n, \n'f'\n}; \n\nint\n[] charfreq = { \n5\n, \n9\n, \n12\n, \n13\n, \n16\n, \n45\n}; \n\n\n// creating a priority queue q. \n\n// makes a min-priority queue(min-heap). \n\nPriorityQueue<HuffmanNode> q \n\n= \nnew\nPriorityQueue<HuffmanNode>(n, \nnew\nMyComparator()); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n// creating a Huffman node object \n\n// and add it to the priority queue. \n\nHuffmanNode hn = \nnew\nHuffmanNode(); \n\n\nhn.c = charArray[i]; \n\nhn.data = charfreq[i]; \n\n\nhn.left = \nnull\n; \n\nhn.right = \nnull\n; \n\n\n// add functions adds \n\n// the huffman node to the queue. \n\nq.add(hn); \n\n} \n\n\n// create a root node \n\nHuffmanNode root = \nnull\n; \n\n\n// Here we will extract the two minimum value \n\n// from the heap each time until \n\n// its size reduces to 1, extract until \n\n// all the nodes are extracted. \n\nwhile\n(q.size() > \n1\n) { \n\n\n// first min extract. \n\nHuffmanNode x = q.peek(); \n\nq.poll(); \n\n\n// second min extarct. \n\nHuffmanNode y = q.peek(); \n\nq.poll(); \n\n\n// new node f which is equal \n\nHuffmanNode f = \nnew\nHuffmanNode(); \n\n\n// to the sum of the frequency of the two nodes \n\n// assigning values to the f node. \n\nf.data = x.data + y.data; \n\nf.c = \n'-'\n; \n\n\n// first extracted node as left child. \n\nf.left = x; \n\n\n// second extracted node as the right child. \n\nf.right = y; \n\n\n// marking the f node as the root node. \n\nroot = f; \n\n\n// add this node to the priority-queue. \n\nq.add(f); \n\n} \n\n\n// print the codes by traversing the tree \n\nprintCode(root, \n\"\"\n); \n\n} \n} \n\n// This code is contributed by Kunwar Desh Deepak Singh ", "index": 707, "complexity": 4}
{"back-translation": "import java.util.Arrays;\nimport java.util.Collections;\n\nclass GFG {\n\n    public static void kLargest(Integer[] arr, int k) {\n\n        Arrays.sort(arr, Collections.reverseOrder());\n\n        for (int i = 0; i < k; i++)\n            System.out.print(arr[i] + \" \");\n    }\n\n    public static void main(String[] args) {\n\n        Integer arr[] = new Integer[]{1, 23, 12, 9, 30, 2, 50};\n\n        int k = 3;\n\n        kLargest(arr, k);\n    }\n}", "src": "\n// Java code for k largest elements in an array \nimport\njava.util.Arrays; \nimport\njava.util.Collections; \n\nclass\nGFG { \n\npublic\nstatic\nvoid\nkLargest(Integer[] arr, \nint\nk) \n\n{ \n\n// Sort the given array arr in reverse order \n\n// This method doesn't work with primitive data \n\n// types. So, instead of int, Integer type \n\n// array will be used \n\nArrays.sort(arr, Collections.reverseOrder()); \n\n\n// Print the first kth largest elements \n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[] { \n1\n, \n23\n, \n12\n, \n9\n, \n\n30\n, \n2\n, \n50\n}; \n\nint\nk = \n3\n; \n\nkLargest(arr, k); \n\n} \n} \n// This code is contributed by Kamal Rawal ", "index": 708, "complexity": 4}
{"back-translation": "public class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            while(isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res.toString();\n        }\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n        public String next() {\n            return readString();\n        }\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        long s = sc.nextLong();\n        long arr[] = new long[n];\n        int i = 0;\n        for (i = 0; i < n; i++) {\n            arr[i] = sc.nextLong();\n        }\n        Arrays.sort(arr);\n        long count = 0;\n        if (arr[n / 2] == s) {\n            w.print(0);\n        } else {\n            int temp = n / 2;\n            if (arr[temp] > s) {\n                while (arr[temp] > s) {\n                    count = count + (arr[temp] - s);\n                    temp--;\n                    if (temp < 0) {\n                        break;\n                    }\n                }\n            } else {\n                while (arr[temp] < s) {\n                    count = count + (s - arr[temp]);\n                    temp++;\n                    if (temp >= n) {\n                        break;\n                    }\n                }\n            }\n            w.print(count);\n        }\n        w.close();\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n             \n            int n=sc.nextInt();\n            long s=sc.nextLong();\n            long arr[]=new long[n];\n            int i=0;\n            for(i=0;i<n;i++)\n            {\n                              arr[i]=sc.nextLong();\n            }\n            Arrays.sort(arr);\n            \n            /*for(i=0;i<n;i++)\n            {\n                              w.println(arr[i]);\n            }*/\n            long count=0;\n            if(arr[n/2]==s)\n            {\n                              \n                              w.print(0);\n            }\n            else\n            {\n                              int temp=n/2;\n                              \n                              if(arr[temp]>s)\n                              {\n                                                while(arr[temp]>s)\n                                                {\n                                                                  count=count+(arr[temp]-s);\n                                                                  temp--;\n                                                                  if(temp<0)\n                                                                  {\n                                                                                    break;\n                                                                  }\n                                                }\n                              }\n                              else\n                              {\n                                               \n                                               while(arr[temp]<s)\n                                               {\n                                                                 \n                                                                 count=count+(s-arr[temp]);\n                                                                 temp++;\n                                                                 if(temp>=n)\n                                                                 {\n                                                                                   break;\n                                                                 }\n                                               }\n                              }\n                              w.print(count);\n            }\n            \n               \n               \n\n        w.close();\n    }\n}", "index": 709, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        InputReader.OutputWriter out = new InputReader.OutputWriter(outputStream);\n\n\n        int n = in.nextInt();\n        int s = in.nextInt();\n        Lift[] lifts = new Lift[n];\n        for (int i = 0; i < n; i++) {\n            lifts[i] = new Lift(in.nextInt(), in.nextInt());\n        }\n        Arrays.sort(lifts, (x, y) -> y.getLevel() - x.getLevel());\n\n        int ans = 0;\n        for (int i = 0; i < lifts.length; i++) {\n            Lift current = lifts[i];\n            ans += s - current.getLevel();\n            if (current.getTime() > ans) {\n                ans += current.getTime() - ans;\n            }\n            s = current.getLevel();\n        }\n        ans += s;\n        out.println(ans);\n        out.flush();\n    }\n}\n\nclass Lift {\n    int level;\n    int time;\n\n    public int getLevel() {\n        return level;\n    }\n\n    public int getTime() {\n        return time;\n    }\n\n    public Lift(int level, int time) {\n        this.level = level;\n        this.time = time;\n    }\n}\n\nclass InputReader extends BufferedReader {\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputStream) {\n        super(new InputStreamReader(inputStream), 32768);\n    }\n\n    public InputReader(String filename) {\n        super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(readLine());\n            } catch (IOException e) {\n                throw new RuntimeException();\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public Integer nextInt() {\n        return Integer.valueOf(next());\n    }\n\n    public Long nextLong() {\n        return Long.valueOf(next());\n    }\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        InputReader.OutputWriter out = new InputReader.OutputWriter(outputStream);\n\n\n        int n = in.nextInt();\n        int s = in.nextInt();\n        Lift [] lifts = new Lift[n];\n        for (int i = 0; i < n; i++) {\n            lifts[i] = new Lift(in.nextInt(),in.nextInt());\n        }\n        Arrays.sort(lifts,(x,y)->y.getLevel() - x.getLevel());\n        \n        int ans = 0;\n        for (int i = 0; i < lifts.length; i++) {\n            Lift current = lifts[i];\n            ans+=s-current.getLevel();\n            if(current.getTime()>ans) {\n                ans+=current.getTime() - ans;\n            }\n            s = current.getLevel();\n        }\n        ans+=s;\n        out.println(ans);\n        out.flush();\n    }\n}\n\nclass Lift {\n\n    int level;\n    int time;\n\n    public int getLevel() {\n        return level;\n    }\n\n    public int getTime() {\n        return time;\n    }\n\n    public Lift(int level, int time) {\n        this.level = level;\n        this.time = time;\n    }\n}\n\nclass InputReader extends BufferedReader {\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputStream) {\n        super(new InputStreamReader(inputStream), 32768);\n    }\n\n    public InputReader(String filename) {\n        super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(readLine());\n            } catch (IOException e) {\n                throw new RuntimeException();\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public Integer nextInt() {\n        return Integer.valueOf(next());\n    }\n    public Long nextLong() {return  Long.valueOf(next());}\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n    }\n}", "index": 710, "complexity": 4}
{"back-translation": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nclass Main {\n\n    static void minAbsSumPair(int[] arr, int n) {\n\n        int sum, min_sum = 999999;\n        int l = 0, r = n - 1;\n        int min_l = l, min_r = n - 1;\n\n        if (n < 2) {\n            System.out.println(\"Invalid Input\");\n            return;\n        }\n\n        Arrays.sort(arr, l, r);\n\n        while (l < r) {\n            sum = arr[l] + arr[r];\n\n            if (Math.abs(sum) < Math.abs(min_sum)) {\n                min_sum = sum;\n                min_l = l;\n                min_r = r;\n            }\n\n            if (sum < 0)\n                l++;\n            else\n                r--;\n        }\n\n        System.out.println(\" The two elements whose \" + \"sum is minimum are \" + arr[min_l] + \" and \" + arr[min_r]);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {1, 60, -10, 70, -80, 85};\n        int n = arr.length;\n        minAbsSumPair(arr, n);\n    }\n\n    static int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = (low - 1);\n\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n\n        return i + 1;\n    }\n\n    static void sort(int[] arr, int low, int high) {\n        if (low < high) {\n            int pi = partition(arr, low, high);\n            sort(arr, low, pi - 1);\n            sort(arr, pi + 1, high);\n        }\n    }\n}", "src": "\nimport\njava.util.*; \nimport\njava.lang.*; \nclass\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n// Variables to keep track of current sum and minimum sum \n\nint\nsum, min_sum = \n999999\n; \n\n\n// left and right index variables \n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n// variable to keep track of the left and right pair for min_sum \n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n/* Array should have at least two elements*/\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n/* Sort the elements */\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n/*If abs(sum) is less then update the result items*/\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n/* Functions for QuickSort */\n\n\n/* This function takes last element as pivot, \n\nplaces the pivot element at its correct \n\nposition in sorted array, and places all \n\nsmaller (smaller than pivot) to left of \n\npivot and all greater elements to right \n\nof pivot */\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n// index of smaller element \n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n// If current element is smaller than or \n\n// equal to pivot \n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n// swap arr[i] and arr[j] \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n// swap arr[i+1] and arr[high] (or pivot) \n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n/* The main function that implements QuickSort() \n\narr[] --> Array to be sorted, \n\nlow --> Starting index, \n\nhigh --> Ending index */\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n/* pi is partitioning index, arr[pi] is \n\nnow at right place */\n\nint\npi = partition(arr, low, high); \n\n\n// Recursively sort elements before \n\n// partition and after partition \n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n} ", "index": 711, "complexity": 4}
{"back-translation": "import java.util.Scanner; public class Fly { static double ERROR = 0.0000001; public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int m = scanner.nextInt(); int[] a = new int[n + 1]; int[] b = new int[n + 1]; for (int i = 0; i < n; i++) { a[i] = scanner.nextInt(); } for (int i = 0; i < n; i++) { b[i] = scanner.nextInt(); } b[n] = b[0]; double max = 1000000000; double min = 0; boolean found = false; while (max >= min) { double mid = max + min; mid /= 2; boolean v = isValid(a, b, m, n, mid); if (v) { max = mid; } else { min = mid; } if (max - min <= ERROR && v) { found = true; break; } if (max == min) { break; } } if (found) { System.out.println(max); } else System.out.println(-1); } static boolean isValid(int[] a, int[] b, int m, int n, double fuel) { double total = m + fuel; for (int i = 0; i < n; i++) { double lost = total; lost /= a[i]; total -= lost; lost = total; lost /= b[i + 1]; total -= lost; if ((total - m) < 0) { return false; } } if ((total - m) < 0) return false; return true; } }", "src": "\n\nimport java.util.Scanner;\n\npublic class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        for(int i =0; i< n; i++ ) {\n            a[i] = scanner.nextInt();\n        }\n\n        for(int i =0; i< n; i++ ) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             // System.out.println(\"For fuel:\" + mid + \" isValid: \" + v + \", max:\" + max + \", min:\" + min);\n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 //System.out.println(\"max: \" + max + \" , min:\" + min);\n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        //System.out.println(found);\n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;i++) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}\n", "index": 712, "complexity": 4}
{"back-translation": "import java.util.Arrays; public class GFG { static int findMinDiff(int[] arr, int n) { Arrays.sort(arr); int diff = Integer.MAX_VALUE; for (int i = 0; i < n - 1; i++) if (arr[i + 1] - arr[i] < diff) diff = arr[i + 1] - arr[i]; return diff; } public static void main(String[] args) { int[] arr = new int[]{1, 5, 3, 19, 18, 25}; System.out.println(\"Minimum difference is \" + findMinDiff(arr, arr.length)); } }", "src": "\n// Java program to find minimum difference between \n// any pair in an unsorted array \n\nimport\njava.util.Arrays; \n\nclass\nGFG \n{ \n\n// Returns minimum difference between any pair \n\nstatic\nint\nfindMinDiff(\nint\n[] arr, \nint\nn) \n\n{ \n\n// Sort array in non-decreasing order \n\nArrays.sort(arr); \n\n\n// Initialize difference as infinite \n\nint\ndiff = Integer.MAX_VALUE; \n\n\n// Find the min diff by comparing adjacent \n\n// pairs in sorted array \n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\nif\n(arr[i+\n1\n] - arr[i] < diff) \n\ndiff = arr[i+\n1\n] - arr[i]; \n\n\n// Return min diff \n\nreturn\ndiff; \n\n} \n\n\n// Driver method to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n5\n, \n3\n, \n19\n, \n18\n, \n25\n}; \n\nSystem.out.println(\n\"Minimum difference is \"\n+ \n\nfindMinDiff(arr, arr.length)); \n\n\n} \n} ", "index": 713, "complexity": 4}
{"back-translation": "class MinHeap {\n\n    int harr[];\n\n    int heap_size;\n\n    int capacity;\n\n    public MinHeap(int a[], int size) {\n        heap_size = size;\n        capacity = size;\n        harr = a;\n        int i = (heap_size - 1) / 2;\n        while (i >= 0) {\n            MinHeapify(i);\n            i--;\n        }\n    }\n\n    void MinHeapify(int i) {\n        int l = left(i);\n        int r = right(i);\n        int smallest = i;\n        if (l < heap_size && harr[l] < harr[i])\n            smallest = l;\n        if (r < heap_size && harr[r] < harr[smallest])\n            smallest = r;\n        if (smallest != i) {\n            swap(i, smallest);\n            MinHeapify(smallest);\n        }\n    }\n\n    int parent(int i) {\n        return (i - 1) / 2;\n    }\n\n    int left(int i) {\n        return (2 * i + 1);\n    }\n\n    int right(int i) {\n        return (2 * i + 2);\n    }\n\n    int extractMin() {\n        if (heap_size <= 0)\n            return Integer.MAX_VALUE;\n        if (heap_size == 1) {\n            heap_size--;\n            return harr[0];\n        }\n        int root = harr[0];\n        harr[0] = harr[heap_size - 1];\n        heap_size--;\n        MinHeapify(0);\n        return root;\n    }\n\n    void insertKey(int k) {\n        if (heap_size == capacity) {\n            System.out.println(\"Overflow: Could not insertKey\");\n            return;\n        }\n        heap_size++;\n        int i = heap_size - 1;\n        harr[i] = k;\n        while (i != 0 && harr[parent(i)] > harr[i]) {\n            swap(i, parent(i);\n            i = parent(i);\n        }\n    }\n\n    boolean isSizeOne() {\n        return (heap_size == 1);\n    }\n\n    void swap(int x, int y) {\n        int temp = harr[x];\n        harr[x] = harr[y];\n        harr[y] = temp;\n    }\n\n    static int minCost(int len[], int n) {\n        int cost = 0;\n        MinHeap minHeap = new MinHeap(len, n);\n        while (!minHeap.isSizeOne()) {\n            int min = minHeap.extractMin();\n            int sec_min = minHeap.extractMin();\n            cost += (min + sec_min);\n            minHeap.insertKey(min + sec_min);\n        }\n        return cost;\n    }\n\n    public static void main(String args[]) {\n        int len[] = { 4, 3, 2, 6 };\n        int size = len.length;\n        System.out.println(\"Total cost for connecting ropes is \" + minCost(len, size));\n    }\n};", "src": "\n// Java program to connect n ropes with minimum cost \n\n// A class for Min Heap \nclass\nMinHeap { \n\nint\n[] harr; \n// Array of elements in heap \n\nint\nheap_size; \n// Current number of elements in min heap \n\nint\ncapacity; \n// maximum possible size of min heap \n\n\n// Constructor: Builds a heap from \n\n// a given array a[] of given size \n\npublic\nMinHeap(\nint\na[], \nint\nsize) \n\n{ \n\nheap_size = size; \n\ncapacity = size; \n\nharr = a; \n\nint\ni = (heap_size - \n1\n) / \n2\n; \n\nwhile\n(i >= \n0\n) { \n\nMinHeapify(i); \n\ni--; \n\n} \n\n} \n\n\n// A recursive method to heapify a subtree \n\n// with the root at given index \n\n// This method assumes that the subtrees \n\n// are already heapified \n\nvoid\nMinHeapify(\nint\ni) \n\n{ \n\nint\nl = left(i); \n\nint\nr = right(i); \n\nint\nsmallest = i; \n\nif\n(l < heap_size && harr[l] < harr[i]) \n\nsmallest = l; \n\nif\n(r < heap_size && harr[r] < harr[smallest]) \n\nsmallest = r; \n\nif\n(smallest != i) { \n\nswap(i, smallest); \n\nMinHeapify(smallest); \n\n} \n\n} \n\n\nint\nparent(\nint\ni) { \nreturn\n(i - \n1\n) / \n2\n; } \n\n\n// to get index of left child of node at index i \n\nint\nleft(\nint\ni) { \nreturn\n(\n2\n* i + \n1\n); } \n\n\n// to get index of right child of node at index i \n\nint\nright(\nint\ni) { \nreturn\n(\n2\n* i + \n2\n); } \n\n\n// Method to remove minimum element (or root) from min heap \n\nint\nextractMin() \n\n{ \n\nif\n(heap_size <= \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\nif\n(heap_size == \n1\n) { \n\nheap_size--; \n\nreturn\nharr[\n0\n]; \n\n} \n\n\n// Store the minimum value, and remove it from heap \n\nint\nroot = harr[\n0\n]; \n\nharr[\n0\n] = harr[heap_size - \n1\n]; \n\nheap_size--; \n\nMinHeapify(\n0\n); \n\n\nreturn\nroot; \n\n} \n\n\n// Inserts a new key 'k' \n\nvoid\ninsertKey(\nint\nk) \n\n{ \n\nif\n(heap_size == capacity) { \n\nSystem.out.println(\n\"Overflow: Could not insertKey\"\n); \n\nreturn\n; \n\n} \n\n\n// First insert the new key at the end \n\nheap_size++; \n\nint\ni = heap_size - \n1\n; \n\nharr[i] = k; \n\n\n// Fix the min heap property if it is violated \n\nwhile\n(i != \n0\n&& harr[parent(i)] > harr[i]) { \n\nswap(i, parent(i)); \n\ni = parent(i); \n\n} \n\n} \n\n\n// A utility function to check \n\n// if size of heap is 1 or not \n\nboolean\nisSizeOne() \n\n{ \n\nreturn\n(heap_size == \n1\n); \n\n} \n\n\n// A utility function to swap two elements \n\nvoid\nswap(\nint\nx, \nint\ny) \n\n{ \n\nint\ntemp = harr[x]; \n\nharr[x] = harr[y]; \n\nharr[y] = temp; \n\n} \n\n\n// The main function that returns the \n\n// minimum cost to connect n ropes of \n\n// lengths stored in len[0..n-1] \n\nstatic\nint\nminCost(\nint\nlen[], \nint\nn) \n\n{ \n\nint\ncost = \n0\n; \n// Initialize result \n\n\n// Create a min heap of capacity equal \n\n// to n and put all ropes in it \n\nMinHeap minHeap = \nnew\nMinHeap(len, n); \n\n\n// Iterate while size of heap doesn't become 1 \n\nwhile\n(!minHeap.isSizeOne()) { \n\n// Extract two minimum length ropes from min heap \n\nint\nmin = minHeap.extractMin(); \n\nint\nsec_min = minHeap.extractMin(); \n\n\ncost += (min + sec_min); \n// Update total cost \n\n\n// Insert a new rope in min heap with length equal to sum \n\n// of two extracted minimum lengths \n\nminHeap.insertKey(min + sec_min); \n\n} \n\n\n// Finally return total minimum \n\n// cost for connecting all ropes \n\nreturn\ncost; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nlen[] = { \n4\n, \n3\n, \n2\n, \n6\n}; \n\nint\nsize = len.length; \n\n\nSystem.out.println(\n\"Total cost for connecting ropes is \"\n+ minCost(len, size)); \n\n} \n}; \n\n// This code is contributed by shubham96301 ", "index": 716, "complexity": 4}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\npublic class blN {\n\n    static class A {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public A(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class B{\n        long a;\n        int cnt;\n        int i;\n        public B(long a,int cnt,int i)\n        {\n            this.a=a;\n            this.cnt=cnt;\n            this.i=i;\n        }\n    }\n\n    static class C implements Comparator<D>\n    {\n        public int compare(D o1,D o2)\n        {\n            if(o1.b!=o2.b)\n                return (int)(o1.b-o2.b);\n            else \n                return (int)(o1.a-o2.a);\n        }\n    }\n\n    static class E\n    {\n\n        static void shuffle(long a[])\n        {\n            List<Long> l=new ArrayList<>();\n            for(int i=0;i<a.length;i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for(int i=0;i<a.length;i++)\n                a[i]=l.get(i);\n        }\n\n        static long gcd(long a,long b)\n        {\n            if(b==0)\n                return a;\n            else\n                return gcd(b,a%b);\n        }\n\n        static boolean valid(int i,int j,int r,int c)\n        {\n            if(i>=0 && i<r && j>=0 && j<c)\n                return true;\n            else\n                return false;\n        }\n\n        static boolean v[]=new boolean[100001];\n        static List<Integer> l=new ArrayList<>();\n        static int t;\n        static void seive()\n        {\n            for(int i=2;i<100001;i++)\n            {\n                if(!v[i])\n                {\n                    t++;\n                    l.add(i);\n                    for(int j=2*i;j<100001;j+=i)\n                        v[j]=true;\n                }\n            }\n        }\n\n        static int binary(D a[],int val,int n)\n        {\n            int mid=0,l=0,r=n-1,ans=0;\n            while(l<=r)\n            {\n                mid=(l+r)>>1;\n                if(a[mid].a==val)\n                {\n                    r=mid-1;\n                    ans=mid;\n                }\n                else if(a[mid].a>val)\n                    r=mid-1;\n                else\n                {\n                    l=mid+1;\n                    ans=l;\n                }\n            }\n            return (ans);\n        }\n    }\n\n    static class D{\n        long a;\n        int b;\n        public D(long a,int n)\n        {\n            this.a=a;\n            this.b=n;\n        }\n    }\n    static A sc=new A(System.in);\n    static PrintWriter out=new PrintWriter(System.out);\n    public static void main(String[] args) {\n        F s=new F();\n        int t=1;\n        while(t>0)\n        {\n            s.solve();\n            t--;\n        }\n    }\n    static class F\n    {\n        void solve()\n        {\n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int sum=0;\n            for(int i=0;i<n;i++)\n            {\n                a[i]=sc.nextInt();\n                sum+=a[i];\n            }\n            Arrays.sort(a);\n            int k=(int)Math.round(4.5*n)-sum;\n           // System.out.println((int)Math.round(4.5*n)+\" \"+k+\" \"+sum);\n            if(k<=0)\n            {\n                System.out.println(0);\n            }\n            else\n            {\n                int p=0,ans=0;\n                for(int i=0;i<n;i++)\n                {\n                    if(a[i]!=5)\n                    {\n                        p+=5-a[i];\n                        if(p>=k){\n                            ans++;\n                            System.out.println(ans);\n                            break;\n                        }\n                        ans++;\n                    }\n                }\n            }\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\npublic class gr1 {\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class card{\n        long a;\n        int cnt;\n        int i;\n        public card(long a,int cnt,int i)\n        {\n            this.a=a;\n            this.cnt=cnt;\n            this.i=i;\n        }\n    }\n\n    static class ascend implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.b!=o2.b)\n                return (int)(o1.b-o2.b);\n            else \n                return (int)(o1.a-o2.a);\n        }\n    }\n\n    /*static class descend implements Comparator<pair>\n    {\n    public int compare(pair o1,pair o2)\n    {\n    if(o1.a!=o2.a){\n    return (o1.a-o2.a)*-1;\n    } else {\n    return (o1.b-o2.b);\n    }\n    }\n    }*/\n\n    static class extra\n    {\n\n        static void shuffle(long a[])\n        {\n            List<Long> l=new ArrayList<>();\n            for(int i=0;i<a.length;i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for(int i=0;i<a.length;i++)\n                a[i]=l.get(i);\n        }\n\n        static long gcd(long a,long b)\n        {\n            if(b==0)\n                return a;\n            else\n                return gcd(b,a%b);\n        }\n\n        static boolean valid(int i,int j,int r,int c)\n        {\n            if(i>=0 && i<r && j>=0 && j<c)\n                return true;\n            else\n                return false;\n        }\n\n        static boolean v[]=new boolean[100001];\n        static List<Integer> l=new ArrayList<>();\n        static int t;\n        static void seive()\n        {\n            for(int i=2;i<100001;i++)\n            {\n                if(!v[i])\n                {\n                    t++;\n                    l.add(i);\n                    for(int j=2*i;j<100001;j+=i)\n                        v[j]=true;\n                }\n            }\n        }\n\n        static int binary(pair a[],int val,int n)\n        {\n            int mid=0,l=0,r=n-1,ans=0;\n            while(l<=r)\n            {\n                mid=(l+r)>>1;\n                if(a[mid].a==val)\n                {\n                    r=mid-1;\n                    ans=mid;\n                }\n                else if(a[mid].a>val)\n                    r=mid-1;\n                else\n                {\n                    l=mid+1;\n                    ans=l;\n                }\n            }\n            return (ans);\n        }\n    }\n\n    static class pair{\n        long a;\n        int b;\n        public pair(long a,int n)\n        {\n            this.a=a;\n            this.b=n;\n        }\n    }\n    static InputReader sc=new InputReader(System.in);\n    static PrintWriter out=new PrintWriter(System.out);\n    public static void main(String[] args) {\n        solver s=new solver();\n        int t=1;\n        while(t>0)\n        {\n            s.solve();\n            t--;\n        }\n    }\n    static class solver\n    {\n        void solve()\n        {\n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int sum=0;\n            for(int i=0;i<n;i++)\n            {\n                a[i]=sc.nextInt();\n                sum+=a[i];\n            }\n            Arrays.sort(a);\n            int k=(int)Math.round(4.5*n)-sum;\n           // System.out.println((int)Math.round(4.5*n)+\" \"+k+\" \"+sum);\n            if(k<=0)\n            {\n                System.out.println(0);\n            }\n            else\n            {\n                int p=0,ans=0;\n                for(int i=0;i<n;i++)\n                {\n                    if(a[i]!=5)\n                    {\n                        p+=5-a[i];\n                        if(p>=k){\n                            ans++;\n                            System.out.println(ans);\n                            break;\n                        }\n                        ans++;\n                    }\n                }\n            }\n        }\n    }\n}", "index": 718, "complexity": 4}
{"back-translation": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Vector;\n\nclass GFG {\n\n    static long calculate(long[] a, int n) {\n\n        Arrays.sort(a);\n\n        int i, j;\n\n        Vector<Long> s = new Vector<>();\n\n        for (i = 0, j = n - 1; i < j; i++, j--)\n            s.add((a[i] + a[j]);\n\n        long mini = Collections.min(s);\n\n        long maxi = Collections.max(s);\n\n        return Math.abs(maxi - mini);\n    }\n\n    public static void main(String[] args) {\n\n        long a[] = {2, 6, 4, 3};\n\n        int n = a.length;\n\n        System.out.println(calculate(a, n));\n    }\n}", "src": "\n// Java program to find minimum \n// difference between groups of \n// highest and lowest sums. \nimport\njava.util.Arrays; \nimport\njava.util.Collections; \nimport\njava.util.Vector; \n\n\nclass\nGFG { \n\nstatic\nlong\ncalculate(\nlong\na[], \nint\nn) \n{ \n\n// Sorting the whole array. \n\nArrays.sort(a); \n\nint\ni,j; \n\n\n// Generating sum groups. \n\nVector<Long> s = \nnew\nVector<>(); \n\nfor\n(i = \n0\n, j = n - \n1\n; i < j; i++, j--) \n\ns.add((a[i] + a[j])); \n\n\nlong\nmini = Collections.min(s); \n\nlong\nmaxi = Collections.max(s); \n\nreturn\nMath.abs(maxi - mini); \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nlong\na[] = { \n2\n, \n6\n, \n4\n, \n3\n}; \n\nint\nn = a.length; \n\nSystem.out.println(calculate(a, n)); \n\n} \n} \n// This code is contributed by 29AjayKumar ", "index": 719, "complexity": 4}
{"back-translation": "class LinkedList { static Node head; static class Node { int data; Node next, prev; Node(int d) { data = d; next = prev = null; } } void print(Node node) { Node temp = node; System.out.println('Forward Traversal using next pointer'); while (node != null ) { System.out.print(node.data + ' '); temp = node; node = node.next; } System.out.println('Backward Traversal using prev pointer'); while (temp != null ) { System.out.print(temp.data + ' '); temp = temp.prev; } } Node split(Node head) { Node fast = head, slow = head; while (fast.next != null && fast.next.next != null ) { fast = fast.next.next; slow = slow.next; } Node temp = slow.next; slow.next = null; return temp; } Node mergeSort(Node node) { if (node == null || node.next == null) { return node; } Node second = split(node); node = mergeSort(node); second = mergeSort(second); return merge(node, second); } Node merge(Node first, Node second) { if (first == null ) { return second; } if (second == null ) { return first; } if (first.data < second.data) { first.next = merge(first.next, second); first.next.prev = first; first.prev = null; return first; } else { second.next = merge(first, second.next); second.next.prev = second; second.prev = null; return second; } } public static void main(String[] args) { LinkedList list = new LinkedList(); list.head = new Node(10); list.head.next = new Node(30); list.head.next.next = new Node(3); list.head.next.next.next = new Node(4); list.head.next.next.next.next = new Node(20); list.head.next.next.next.next.next = new Node(5); Node node = null; node = list.mergeSort(head); System.out.println('Linked list after sorting :'); list.print(node); } }", "src": "\n// Java program to implement merge sort in singly linked list \n\n// Linked List Class \nclass\nLinkedList { \n\n\nstatic\nNode head; \n// head of list \n\n\n/* Node Class */\n\nstatic\nclass\nNode { \n\n\nint\ndata; \n\nNode next, prev; \n\n\n// Constructor to create a new node \n\nNode(\nint\nd) { \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\nvoid\nprint(Node node) { \n\nNode temp = node; \n\nSystem.out.println(\n\"Forward Traversal using next pointer\"\n); \n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\ntemp = node; \n\nnode = node.next; \n\n} \n\nSystem.out.println(\n\"\\nBackward Traversal using prev pointer\"\n); \n\nwhile\n(temp != \nnull\n) { \n\nSystem.out.print(temp.data + \n\" \"\n); \n\ntemp = temp.prev; \n\n} \n\n} \n\n\n// Split a doubly linked list (DLL) into 2 DLLs of \n\n// half sizes \n\nNode split(Node head) { \n\nNode fast = head, slow = head; \n\nwhile\n(fast.next != \nnull\n&& fast.next.next != \nnull\n) { \n\nfast = fast.next.next; \n\nslow = slow.next; \n\n} \n\nNode temp = slow.next; \n\nslow.next = \nnull\n; \n\nreturn\ntemp; \n\n} \n\n\nNode mergeSort(Node node) { \n\nif\n(node == \nnull\n|| node.next == \nnull\n) { \n\nreturn\nnode; \n\n} \n\nNode second = split(node); \n\n\n// Recur for left and right halves \n\nnode = mergeSort(node); \n\nsecond = mergeSort(second); \n\n\n// Merge the two sorted halves \n\nreturn\nmerge(node, second); \n\n} \n\n\n// Function to merge two linked lists \n\nNode merge(Node first, Node second) { \n\n// If first linked list is empty \n\nif\n(first == \nnull\n) { \n\nreturn\nsecond; \n\n} \n\n\n// If second linked list is empty \n\nif\n(second == \nnull\n) { \n\nreturn\nfirst; \n\n} \n\n\n// Pick the smaller value \n\nif\n(first.data < second.data) { \n\nfirst.next = merge(first.next, second); \n\nfirst.next.prev = first; \n\nfirst.prev = \nnull\n; \n\nreturn\nfirst; \n\n} \nelse\n{ \n\nsecond.next = merge(first, second.next); \n\nsecond.next.prev = second; \n\nsecond.prev = \nnull\n; \n\nreturn\nsecond; \n\n} \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nLinkedList list = \nnew\nLinkedList(); \n\nlist.head = \nnew\nNode(\n10\n); \n\nlist.head.next = \nnew\nNode(\n30\n); \n\nlist.head.next.next = \nnew\nNode(\n3\n); \n\nlist.head.next.next.next = \nnew\nNode(\n4\n); \n\nlist.head.next.next.next.next = \nnew\nNode(\n20\n); \n\nlist.head.next.next.next.next.next = \nnew\nNode(\n5\n); \n\n\n\nNode node = \nnull\n; \n\nnode = list.mergeSort(head); \n\nSystem.out.println(\n\"Linked list after sorting :\"\n); \n\nlist.print(node); \n\n\n} \n} \n\n// This code has been contributed by Mayank Jaiswal ", "index": 720, "complexity": 4}
{"back-translation": "import java.util.Arrays; import java.util.Collections; public class GFG { public static int kthSmallest(Integer[] arr, int k) { Arrays.sort(arr); return arr[k-1]; } public static void main(String[] args) { Integer arr[] = new Integer[]{12, 3, 5, 7, 19}; int k = 2; System.out.print(\"K'th smallest element is \"+ kthSmallest(arr, k)); } }", "src": "\n// Java code for kth smallest element \n// in an array \nimport\njava.util.Arrays; \nimport\njava.util.Collections; \n\nclass\nGFG \n{ \n\n// Function to return k'th smallest \n\n// element in a given array \n\npublic\nstatic\nint\nkthSmallest(Integer [] arr, \n\nint\nk) \n\n{ \n\n// Sort the given array \n\nArrays.sort(arr); \n\n\n// Return k'th element in \n\n// the sorted array \n\nreturn\narr[k-\n1\n]; \n\n} \n\n\n// driver program \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[]{\n12\n, \n3\n, \n5\n, \n7\n, \n19\n}; \n\nint\nk = \n2\n; \n\nSystem.out.print( \n\"K'th smallest element is \"\n+ \n\nkthSmallest(arr, k) ); \n\n} \n} \n\n// This code is contributed by Chhavi ", "index": 721, "complexity": 4}
{"back-translation": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\tSolution solution = new Solution();\n\t\tSystem.out.println(solution.solve());\n\t}\n\n\tprivate int solve() {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\n\t\tint[] a = new int[m];\n\t\tfor (int i = 0; i < m; ++i) a[i] = in.nextInt();\n\n\t\tif (n > m) return 0;\n\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tfor (int k : a) map.put(k, map.getOrDefault(k, 0) + 1);\n\n\t\tList<Integer> keySet = new ArrayList<Integer>(map.keySet());\n\t\tint end = m / n;\n\n\t\tkeySet.sort(new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer u, Integer v) {\n\t\t\t\treturn -Integer.compare(u, v);\n\t\t\t}\n\t\t});\n\t\tdo {\n\t\t\tint count = 0;\n\t\t\tfor (int k : keySet) {\n\t\t\t\tcount += map.get(k) / end;\n\t\t\t\tif (count >= n) return end;\n\t\t\t}\n\t\t} while (--end > 0);\n\n\t\treturn 0;\n\t}\n}", "src": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\tSolution solution = new Solution();\n\t\tSystem.out.println(solution.solve());\n\t}\n\n\tprivate int solve() {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\n\t\tint[] a = new int[m];\n\t\tfor (int i = 0; i < m; ++i) a[i] = in.nextInt();\n\n\t\tif (n > m) return 0;\n\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int k: a) map.put(k, map.getOrDefault(k, 0) + 1);\n\n\t\tList<Integer> keySet = new ArrayList<>(map.keySet());\n\t\tint end = m / n;\n\n\t\tkeySet.sort((u, v) -> -Integer.compare(u, v));\n\t\tdo {\n\t\t\tint count = 0;\n\t\t\tfor (int k: keySet) {\n\t\t\t\tcount += map.get(k) / end;\n\t\t\t\tif (count >= n) return end;\n\t\t\t}\n\t\t} while (--end > 0);\n\n\t\treturn 0;\n\t}\n}\n", "index": 723, "complexity": 4}
{"back-translation": "import java.util.PriorityQueue;  class MinSum { public static long solve(int[] a) { PriorityQueue<Integer> pq = new PriorityQueue<Integer>(); StringBuilder num1 = new StringBuilder(); StringBuilder num2 = new StringBuilder(); for (int x : a) pq.add(x); while (!pq.isEmpty()) { num1.append(pq.poll() + \"\"); if (!pq.isEmpty()) num2.append(pq.poll() + \"\"); } long sum = Long.parseLong(num1.toString()) + Long.parseLong(num2.toString()); return sum; } public static void main (String[] args) { int arr[] = {6, 8, 4, 5, 2, 3}; System.out.println(\"The required sum is \"+ solve(arr)); } }", "src": "\n// Java program to find minimum sum of two numbers \n// formed from all digits in a given array. \nimport\njava.util.PriorityQueue; \n\nclass\nMinSum \n{ \n\n// Returns sum of two numbers formed \n\n// from all digits in a[] \n\npublic\nstatic\nlong\nsolve(\nint\n[] a) \n\n{ \n\n// min Heap \n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<Integer>(); \n\n\n// to store the 2 numbers formed by array elements to \n\n// minimize the required sum \n\nStringBuilder num1 = \nnew\nStringBuilder(); \n\nStringBuilder num2 = \nnew\nStringBuilder(); \n\n\n// Adding elements in Priority Queue \n\nfor\n(\nint\nx : a) \n\npq.add(x); \n\n\n// checking if the priority queue is non empty \n\nwhile\n(!pq.isEmpty()) \n\n{ \n\nnum1.append(pq.poll()+ \n\"\"\n); \n\nif\n(!pq.isEmpty()) \n\nnum2.append(pq.poll()+ \n\"\"\n); \n\n} \n\n\n// the required sum calculated \n\nlong\nsum = Long.parseLong(num1.toString()) + \n\nLong.parseLong(num2.toString()); \n\n\nreturn\nsum; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n6\n, \n8\n, \n4\n, \n5\n, \n2\n, \n3\n}; \n\nSystem.out.println(\n\"The required sum is \"\n+ solve(arr)); \n\n} \n} ", "index": 724, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        MyScanner scan = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int n = scan.nextInt();\n        int[] vals = new int[n];\n        for (int i = 0; i < n; i++) {\n\n            vals[i] = scan.nextInt();\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (solve(i, vals)) {\n\n                out.print('A');\n            } else {\n                out.print('B');\n            }\n        }\n\n        out.close();\n    }\n\n    static HashMap<Integer, Boolean> dpResult = new HashMap<>();\n\n    private static boolean solve(int pos, int[] vals) {\n\n        if (dpResult.containsKey(pos)) return dpResult.get(pos);\n\n        int val = vals[pos];\n\n        boolean hasLose = false;\n\n        for (int i = pos; i < vals.length; i += val) {\n\n            if (i == pos) continue;\n\n            if (vals[i] <= vals[pos]) continue;\n\n            if (hasLose) break;\n\n            if (!solve(i, vals)) {\n                hasLose = true;\n            }\n        }\n\n        for (int i = pos; i >= 0; i -= val) {\n\n            if (i == pos) continue;\n\n            if (vals[i] <= vals[pos]) continue;\n\n            if (hasLose) break;\n\n            if (!solve(i, vals)) {\n                hasLose = true;\n            }\n        }\n\n        dpResult.put(pos, hasLose);\n\n        return hasLose;\n    }\n\n    public static PrintWriter out;\n\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) { e.printStackTrace(); }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n\n        long nextLong() { return Long.parseLong(next()); }\n\n        double nextDouble() { return Double.parseDouble(next()); }\n\n        String nextLine() { String str = \"\";\n\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            return str;\n        }\n\n    }\n}", "src": "import com.sun.org.apache.xpath.internal.operations.Bool;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        MyScanner scan = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int n = scan.nextInt();\n        int[] vals = new int[n];\n        for (int i = 0; i < n; i++) {\n            vals[i] = scan.nextInt();\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (solve(i, vals)) {\n                out.print('A');\n            } else {\n                out.print('B');\n            }\n        }\n\n        out.close();\n    }\n\n    static HashMap<Integer, Boolean> dpResult = new HashMap<>();\n\n    private static boolean solve(int pos, int[] vals) {\n        if (dpResult.containsKey(pos)) return dpResult.get(pos);\n        int val = vals[pos];\n        boolean hasLose = false;\n        for (int i = pos; i < vals.length; i += val) {\n            if (i == pos) continue;\n            if (vals[i] <= vals[pos]) continue;\n            if (hasLose) break;\n            if (!solve(i, vals)) {\n                hasLose = true;\n            }\n        }\n        for (int i = pos; i >= 0; i -= val) {\n            if (i == pos) continue;\n            if (vals[i] <= vals[pos]) continue;\n            if (hasLose) break;\n            if (!solve(i, vals)) {\n                hasLose = true;\n            }\n        }\n        dpResult.put(pos, hasLose);\n        return hasLose;\n    }\n\n\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n    //--------------------------------------------------------\n\n}", "index": 725, "complexity": 4}
{"back-translation": "class GFG { static int getMinDiff(int[] arr, int n, int k) { if (n == 1) return 0; Arrays.sort(arr); int ans = arr[n-1] - arr[0]; int small = arr[0] + k; int big = arr[n-1] - k; int temp = 0; if (small > big) { temp = small; small = big; big = temp; } for (int i = 1; i < n-1; i++) { int subtract = arr[i] - k; int add = arr[i] + k; if (subtract >= small || add <= big) continue; if (big - subtract <= add - small) small = subtract; else big = add; } return Math.min(ans, big - small); } public static void main(String[] args) { int arr[] = {4, 6}; int n = arr.length; int k = 10; System.out.println(\"Maximum difference is \" + getMinDiff(arr, n, k)); } }", "src": "\n// Java program to find the minimum possible \n// difference between maximum and minimum \n// elements when we have to add/subtract \n// every number by k \nimport\njava.util.*; \n\nclass\nGFG { \n\n\n// Modifies the array by subtracting/adding \n\n// k to every element such that the difference \n\n// between maximum and minimum is minimized \n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n// Sort all elements \n\nArrays.sort(arr); \n\n\n// Initialize result \n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n// Handle corner elements \n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n// Traverse middle elements \n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n// If both subtraction and addition \n\n// do not change diff \n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n// Either subtraction causes a smaller \n\n// number or addition causes a greater \n\n// number. Update small or big using \n\n// greedy approach (If big - subtract \n\n// causes smaller diff, update small \n\n// Else update big) \n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n// Driver function to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n} \n// This code is contributed by Prerna Saini ", "index": 727, "complexity": 4}
{"back-translation": "import java.io.*;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n    static int[] a;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        a = sc.nextIntArray(n);\n        long inversions = divide(0, n - 1);\n\n        if (n == 5) {\n            out.println(\"Petr\");\n        } else {\n            if (n % 2 == 0) {\n                out.println(inversions % 2 == 0 ? \"Petr\" : \"Um_nik\");\n            } else {\n                out.println(inversions % 2 != 0 ? \"Petr\" : \"Um_nik\");\n            }\n        }\n        out.flush();\n        out.close();\n    }\n\n    static long divide(int b, int e) {\n        if (b == e) return 0;\n        long cnt = 0;\n        int mid = b + e >> 1;\n        cnt += divide(b, mid);\n        cnt += divide(mid + 1, e);\n        cnt += merge(b, mid, e);\n        return cnt;\n    }\n\n    static long merge(int b, int mid, int e) {\n        long cnt = 0;\n        int len = e - b + 1;\n        int[] tmp = new int[len];\n        int i = b, j = mid + 1;\n        for (int k = 0; k < len; k++) {\n            if (i == mid + 1 || (j != e + 1 && a[i] > a[j])) {\n                tmp[k] = a[j++];\n                cnt += (mid + 1 - i);\n            } else {\n                tmp[k] = a[i++];\n            }\n        }\n        for (int k = 0; k < len; k++) {\n            a[b + k] = tmp[k];\n        }\n        return cnt;\n    }\n\n    static class Scanner {\n\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = nextDouble();\n            }\n            return ans;\n        }\n\n        public short nextShort() throws IOException {\n            return Short.parseShort(next());\n        }\n\n    }\n}", "src": "import java.io.*;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n    static int[] a;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        a = sc.nextIntArray(n);\n        long inversions = divide(0, n - 1);\n//        out.println(inversions);\n//        System.err.println(Arrays.toString(a));\n        if (n == 5) out.println(\"Petr\");\n        else {\n            if (n % 2 == 0) out.println(inversions % 2 == 0 ? \"Petr\" : \"Um_nik\");\n            else out.println(inversions % 2 != 0 ? \"Petr\" : \"Um_nik\");\n        }\n        out.flush();\n        out.close();\n    }\n\n    static long divide(int b, int e) {\n        if (b == e) return 0;\n        long cnt = 0;\n        int mid = b + e >> 1;\n        cnt += divide(b, mid);\n        cnt += divide(mid + 1, e);\n        cnt += merge(b, mid, e);\n        return cnt;\n    }\n\n    static long merge(int b, int mid, int e) {\n        long cnt = 0;\n        int len = e - b + 1;\n        int[] tmp = new int[len];\n        int i = b, j = mid + 1;\n        for (int k = 0; k < len; k++) {\n            if (i == mid + 1 || (j != e + 1 && a[i] > a[j])) {\n                tmp[k] = a[j++];\n                cnt += (mid + 1 - i);\n            } else tmp[k] = a[i++];\n        }\n        for (int k = 0; k < len; k++)\n            a[b + k] = tmp[k];\n        return cnt;\n    }\n\n    static class Scanner {\n\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextDouble();\n            return ans;\n        }\n\n        public short nextShort() throws IOException {\n            return Short.parseShort(next());\n        }\n\n    }\n}", "index": 728, "complexity": 4}
{"back-translation": "ERROR", "src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Div1_526C {\n\n\tstatic int nV;\n\n\tstatic ArrayList<Integer>[] chldn;\n\n\tstatic int root;\n\n\tstatic int[][] anc;\n\tstatic int[] depth;\n\n\tstatic int[] num;\n\n\tstatic int[] nLoc;\n\n\tstatic int[][] tree;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tnV = Integer.parseInt(reader.readLine());\n\n\t\tchldn = new ArrayList[nV];\n\t\tfor (int i = 0; i < nV; i++) {\n\t\t\tchldn[i] = new ArrayList<>();\n\t\t}\n\n\t\tanc = new int[nV][21];\n\t\tdepth = new int[nV];\n\n\t\tnum = new int[nV];\n\t\tnLoc = new int[nV];\n\t\ttree = new int[nV * 4][2];\n\t\tfor (int[] a : tree) {\n\t\t\ta[0] = a[1] = -1;\n\t\t}\n\n\t\troot = 0;\n\n\t\tStringTokenizer inputData = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0; i < nV; i++) {\n\t\t\tnum[i] = Integer.parseInt(inputData.nextToken());\n\t\t\tnLoc[num[i]] = i;\n\t\t}\n\n\t\tinputData = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 1; i < nV; i++) {\n\t\t\tanc[i][0] = Integer.parseInt(inputData.nextToken()) - 1;\n\t\t\tchldn[anc[i][0]].add(i);\n\t\t}\n\n\t\tpreprocess();\n\n\t\tbuild(1, 0, nV - 1);\n\n\t\tint nQ = Integer.parseInt(reader.readLine());\n\n\t\twhile (nQ-- > 0) {\n\t\t\tinputData = new StringTokenizer(reader.readLine());\n\t\t\tif (inputData.nextToken().equals(\"1\")) {\n\t\t\t\tint a = Integer.parseInt(inputData.nextToken()) - 1;\n\t\t\t\tint b = Integer.parseInt(inputData.nextToken()) - 1;\n\n\t\t\t\tint temp = num[a];\n\t\t\t\tnum[a] = num[b];\n\t\t\t\tnum[b] = temp;\n\n\t\t\t\tnLoc[num[a]] = a;\n\t\t\t\tnLoc[num[b]] = b;\n\n\t\t\t\tupdate(1, 0, nV - 1, num[a]);\n\t\t\t\tupdate(1, 0, nV - 1, num[b]);\n\t\t\t} else {\n\t\t\t\tprinter.println(query(1, 0, nV - 1, nLoc[0], nLoc[0]) + 1);\n\t\t\t}\n\t\t}\n\t\tprinter.close();\n\t}\n\n\tstatic void build(int nI, int cL, int cR) {\n\t\tif (cL == cR) {\n\t\t\ttree[nI][0] = nLoc[cL];\n\t\t\ttree[nI][1] = nLoc[cL];\n\t\t} else {\n\t\t\tint mid = (cL + cR) >> 1;\n\t\t\tbuild(nI * 2, cL, mid);\n\t\t\tbuild(nI * 2 + 1, mid + 1, cR);\n\t\t\tif (tree[nI * 2][0] != -1 && tree[nI * 2 + 1][0] != -1) {\n\t\t\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], tree[nI * 2 + 1][0], tree[nI * 2 + 1][1]);\n\t\t\t\ttree[nI][0] = mResp[0];\n\t\t\t\ttree[nI][1] = mResp[1];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int query(int nI, int cL, int cR, int e1, int e2) {\n\t\tif (cL == cR) {\n\t\t\tmerge(e1, e2, nLoc[cL], nLoc[cL]);\n\t\t\tif (mResp[0] != -1) {\n\t\t\t\treturn cL;\n\t\t\t} else {\n\t\t\t\treturn cL - 1;\n\t\t\t}\n\t\t}\n\t\tint mid = (cL + cR) >> 1;\n\n\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], e1, e2);\n\t\tif (mResp[0] != -1) {\n\t\t\treturn query(nI * 2 + 1, mid + 1, cR, mResp[0], mResp[1]);\n\t\t}\n\t\treturn query(nI * 2, cL, mid, e1, e2);\n\t}\n\n\tstatic void update(int nI, int cL, int cR, int uI) {\n\t\tif (cL == cR) {\n\t\t\ttree[nI][0] = nLoc[cL];\n\t\t\ttree[nI][1] = nLoc[cL];\n\t\t} else {\n\t\t\tint mid = (cL + cR) >> 1;\n\t\t\tif (uI <= mid) {\n\t\t\t\tupdate(nI * 2, cL, mid, uI);\n\t\t\t} else {\n\t\t\t\tupdate(nI * 2 + 1, mid + 1, cR, uI);\n\t\t\t}\n\t\t\tmerge(tree[nI * 2][0], tree[nI * 2][1], tree[nI * 2 + 1][0], tree[nI * 2 + 1][1]);\n\t\t\ttree[nI][0] = mResp[0];\n\t\t\ttree[nI][1] = mResp[1];\n\t\t}\n\t}\n\n\tstatic int[] mResp = new int[2];\n\n\tstatic void merge1(int... a) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (a[i] == -1) {\n\t\t\t\tmResp[0] = mResp[1] = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (onPath(a[0], a[1], a[2])) {\n\t\t\tmResp[0] = a[0];\n\t\t\tmResp[1] = a[1];\n\t\t\treturn;\n\t\t}\n\t\tif (onPath(a[0], a[2], a[1])) {\n\t\t\tmResp[0] = a[0];\n\t\t\tmResp[1] = a[2];\n\t\t\treturn;\n\t\t}\n\t\tif (onPath(a[1], a[2], a[0])) {\n\t\t\tmResp[0] = a[1];\n\t\t\tmResp[1] = a[2];\n\t\t\treturn;\n\t\t}\n\t\tmResp[0] = mResp[1] = -1;\n\t}\n\n\tstatic void merge(int... a) {\n\t\tmerge1(a[0], a[1], a[2]);\n\t\tmerge1(mResp[0], mResp[1], a[3]);\n\t}\n\n\tstatic boolean onPath(int a, int b, int c) {\n\t\tif (a == c || b == c) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (depth[a] > depth[c]) {\n\t\t\ta = jump(a, depth[a] - depth[c] - 1);\n\t\t}\n\t\tif (depth[b] > depth[c]) {\n\t\t\tb = jump(b, depth[b] - depth[c] - 1);\n\t\t}\n\t\tif (a == b) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (anc[a][0] == c || anc[b][0] == c) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// good for depth of up to 1_048_576 = 2^20\n\n\tstatic void preprocess() {\n\t\tanc[root][0] = root;\n\t\tfParent(root);\n\n\t\tfor (int k = 1; k <= 20; k++) {\n\t\t\tfor (int i = 0; i < nV; i++) {\n\t\t\t\tanc[i][k] = anc[anc[i][k - 1]][k - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void fParent(int cV) {\n\t\tfor (int aV : chldn[cV]) {\n\t\t\tanc[aV][0] = cV;\n\t\t\tdepth[aV] = depth[cV] + 1;\n\t\t\tfParent(aV);\n\t\t}\n\t}\n\n\tstatic int fLCA(int a, int b) {\n\t\tif (depth[a] > depth[b]) {\n\t\t\tint temp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\t\tb = jump(b, depth[b] - depth[a]);\n\t\tif (a == b) {\n\t\t\treturn a;\n\t\t}\n\t\tfor (int i = 20; i >= 0; i--) {\n\t\t\tif (anc[a][i] != anc[b][i]) {\n\t\t\t\ta = anc[a][i];\n\t\t\t\tb = anc[b][i];\n\t\t\t}\n\t\t}\n\t\treturn anc[a][0];\n\t}\n\n\tstatic int jump(int cV, int d) {\n\t\tfor (int i = 0; i <= 20; i++) {\n\t\t\tif ((d & (1 << i)) != 0) {\n\t\t\t\tcV = anc[cV][i];\n\t\t\t}\n\t\t}\n\t\treturn cV;\n\t}\n\n\tstatic Comparator<Integer> BY_DEPTH = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn -Integer.compare(depth[o1], depth[o2]); // greatest depth first\n\t\t}\n\t};\n}", "index": 730, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        long[] a = new long[n];\n        for(int i=0;i<n;i++) a[i] = Long.parseLong(st.nextToken());\n        Queue<Long> ts = new PriorityQueue<Long>();\n        for(int i=1;i<n;i++) ts.add(a[i] - a[i - 1]);\n        long sum = 0;\n        for(int i=0;i<n - k;i++){\n            sum += ts.poll();\n        }\n        System.out.println(sum);\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        long[] a = new long[n];\n        for(int i=0;i<n;i++) a[i] = Long.parseLong(st.nextToken());\n        Queue<Long> ts = new PriorityQueue<Long>();\n        for(int i=1;i<n;i++) ts.add(a[i]-a[i-1]);\n        long sum = 0;\n        for(int i=0;i<n-k;i++){\n            sum += ts.poll();\n        }\n        System.out.println(sum);\n    }\n}\n\n", "index": 731, "complexity": 4}
{"back-translation": "int n = Integer.parseInt(new Scanner(System.in).nextLine());\nList<Integer> list = new ArrayList<>();\nfor (int i = 0; i < n; i++) {\n    int temp = Integer.parseInt(new Scanner(System.in).nextLine());\n    list.add(temp);\n}\nCollections.sort(list);\nif (n % 2 == 0) {\n    System.out.println(list.get((n / 2) - 1));\n} else {\n    System.out.println(list.get(n / 2));\n}", "src": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic final class Codeforces\n{\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    Scanner sc=new Scanner(System.in);\n\t\t\tint n=sc.nextInt();\n\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint temp=sc.nextInt();\n\t\t\t\tlist.add(temp);\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\tif(n%2==0)\n\t\t\tSystem.out.println(list.get((n/2)-1));\n\t\t\telse\n\t\t\tSystem.out.println(list.get(n/2));\n\t}\n}\n", "index": 733, "complexity": 4}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    static long mod = (int) (1e9 + 7);\n    static int n;\n    static StringBuilder sol;\n\n    static class pair implements Comparable<pair> {\n        int L, R;\n\n        public pair(int x, int y) {\n            L = x;\n            R = y;\n        }\n\n        public int compareTo(pair o) {\n            if (L != o.L) return L - o.L;\n            return o.R - R;\n        }\n\n        public String toString() {\n            return L + \" \" + R;\n        }\n    }\n\n    static boolean is;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        TreeSet<Integer> length = new TreeSet<>();\n        length.add(0);\n        length.add(n);\n        TreeSet<Integer> width = new TreeSet<>();\n        width.add(0);\n        width.add(m);\n        TreeMap<Integer, Integer> len = new TreeMap<>();\n        len.put(n, 1);\n        TreeMap<Integer, Integer> wid = new TreeMap<>();\n        wid.put(m, 1);\n\n        while (q-- > 0) {\n            String t = sc.next();\n            if (t.equals(\"H\")) {\n                int x = sc.nextInt();\n                int k1 = length.ceiling(x);\n                int k2 = length.floor(x);\n                if (x != k1) {\n                    int s = k1 - k2;\n                    int con = len.get(s);\n                    if (con == 1) len.remove(s);\n                    else len.put(s, con - 1);\n                    len.put((k1 - x), len.getOrDefault((k1 - x), 0) + 1);\n                    len.put((x - k2), len.getOrDefault((x - k2), 0) + 1);\n                    length.add(x);\n                }\n            } else {\n                int x = sc.nextInt();\n                int k1 = width.ceiling(x);\n                int k2 = width.floor(x);\n                if (x != k1) {\n                    int s = k1 - k2;\n                    int con = wid.get(s);\n                    if (con == 1) wid.remove(s);\n                    else wid.put(s, con - 1);\n                    wid.put((k1 - x), wid.getOrDefault((k1 - x), 0) + 1);\n                    wid.put((x - k2), wid.getOrDefault((x - k2), 0) + 1);\n                    width.add(x);\n                }\n            }\n            pw.println(1L * len.lastKey() * wid.lastKey());\n        }\n\n        pw.flush();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == \".\") {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n    }\n\n}", "src": "import sun.reflect.generics.tree.Tree;\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.net.Inet4Address;\nimport java.util.*;\n\npublic class l {\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMMMM      MMMMMM      OOO      OOO        SSSS   SSS     EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEE           MMMM MMM  MMM MMMM    OOO          OOO    SSSS       SSS   EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM  MMMMMM  MMMM   OOO            OOO   SSSS             EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM  OOO              OOO   SSSSSSS         EEEEE          /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO      SSSSSS       EEEEEEEEEEE    /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO         SSSSSSS   EEEEEEEEEEE    /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM   OOO            OOO              SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM    OOO          OOO     SSS       SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM      OOO      OOO        SSS    SSSS    EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    static long mod = (int) (1e9 + 7);\n    static int n;\n    static StringBuilder sol;\n\n    static class pair implements Comparable<pair> {\n        int L,R;\n        public pair( int x,int y) {\n            L=x;R=y;\n        }\n\n\n        public int compareTo(pair o) {\n            if (L!=o.L)return L-o.L;\n            return o.R-R;\n        }\n        public String toString(){\n            return L+\" \"+R;\n        }\n    }\n    static boolean is;\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        //FileWriter f = new FileWriter(\"C:\\\\Users\\\\Ibrahim\\\\out.txt\");\n        PrintWriter pw = new PrintWriter(System.out);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        TreeSet<Integer>length= new TreeSet<>();\n        length.add(0);\n        length.add(n);\n        TreeSet<Integer>width= new TreeSet<>();\n        width.add(0);\n        width.add(m);\n        TreeMap<Integer,Integer>len= new TreeMap<>();\n        len.put(n,1);\n        TreeMap<Integer,Integer>wid= new TreeMap<>();\n        wid.put(m,1);\n        while (q-->0){\n            String t= sc.next();\n            if (t.equals(\"H\")) {\n                int x = sc.nextInt();\n                int k1 = length.ceiling(x);\n                int k2 = length.floor(x);\n                if (x != k1) {\n                    int s = k1 - k2;\n                    int con = len.get(s);\n                    if (con == 1) len.remove(s);\n                    else len.put(s, con - 1);\n                    len.put((k1 - x), len.getOrDefault((k1 - x), 0) + 1);\n                    len.put((x - k2), len.getOrDefault((x - k2), 0) + 1);\n                    length.add(x);\n                }\n            }\n            else {\n                int x = sc.nextInt();\n                int k1 = width.ceiling(x);\n                int k2 = width.floor(x);\n                if (x != k1) {\n                    int s = k1 - k2;\n                    //System.out.println(s+\" \"+k1+\" \"+k2);\n                    int con = wid.get(s);\n                    if (con == 1) wid.remove(s);\n                    else wid.put(s, con - 1);\n                    wid.put((k1 - x), wid.getOrDefault((k1 - x), 0) + 1);\n                    wid.put((x - k2), wid.getOrDefault((x - k2), 0) + 1);\n                    width.add(x);\n                }\n            }\n            pw.println(1l*len.lastKey()*wid.lastKey());\n        }\n\n        pw.flush();\n    }\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n    }\n\n}", "index": 734, "complexity": 4}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class DontBack {\n    static BufferedReader jin = new BufferedReader(new InputStreamReader(System.in));\n    static long n;\n    static long x, y;\n\n    public static void main(String[] args) throws Exception {\n        n = nextLong();\n        x = nextLong();\n        y = nextLong();\n        System.out.println((Math.max(n - x, n - y) < Math.max(x - 1, y - 1)) ? \"Black\" : \"White\");\n    }\n\n    static long max(long a, long b) {\n        return (a > b) ? a : b;\n    }\n\n    static long nextLong() throws Exception {\n        long res = 0;\n        int ch = jin.read();\n        while (ch < '0' || '9' < ch) ch = jin.read();\n        while ('0' <= ch && ch <= '9') {\n            res = res * 10 + ch - '0';\n            ch = jin.read();\n        }\n        return res;\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Dont {\n    static BufferedReader jin = new BufferedReader( new InputStreamReader( System.in ) );\n    static long n;\n    static long x, y;\n\n    public static void main(String[] args) throws Exception {\n        n = nextLong();\n        x = nextLong();\n        y = nextLong();\n        System.out.println( (max(n-x, n-y) < max(x-1, y-1))? \"Black\" : \"White\" );\n    }\n\n    static long max(long a, long b) {\n        return (a > b)? a : b ;\n    }\n\n    static long nextLong() throws Exception {\n        long res = 0;\n        int ch = jin.read();\n        while(ch < '0' || '9' < ch) ch = jin.read();\n        while('0'<= ch && ch <= '9') {\n            res = res*10 + ch - '0';\n            ch = jin.read();\n        }\n        return res;\n    }\n}", "index": 735, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.PrintWriter;\n\nimport java.io.InputStreamReader;\n\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    \n    static MyScanner in = new MyScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int x = in.nextInt(),\n            y = in.nextInt(),\n            z = in.nextInt(),\n            t1 = in.nextInt(),\n            t2 = in.nextInt(),\n            t3 = in.nextInt()*3,\n            d = Math.abs(x - y);\n        out.print(((Math.abs(x - z) + d) * t2 + t3 > d * t1 ? \"NO\" : \"YES\"));\n        out.close();\n    }\n    \n    static class MyScanner {\n        BufferedReader bufferedReader;\n        StringTokenizer stringTokenizer;\n        \n        public MyScanner() {\n            bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n            stringTokenizer = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!stringTokenizer.hasMoreTokens())\n                stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n            return stringTokenizer.nextToken();\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.PrintWriter;\n\nimport java.io.InputStreamReader;\n\nimport java.io.IOException;\n\nimport java.util.StringTokenizer;\n\npublic class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int x = in.nextInt(),\n            y = in.nextInt(),\n            z = in.nextInt(),\n            t1 = in.nextInt(),\n            t2 = in.nextInt(),\n            t3 = in.nextInt()*3,\n            d = Math.abs(x - y);\n        out.print(((Math.abs(x - z) + d) * t2 + t3 > d * t1 ? \"NO\" : \"YES\"));\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}", "index": 736, "complexity": 1}
{"back-translation": "class Main { static class FastReader { BufferedReader br; StringTokenizer st; public FastReader() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); } double nextDouble() { return Double.parseDouble(next()); } float nextFloat() { return Float.parseFloat(next()); } boolean nextBoolean() { return Boolean.parseBoolean(next()); } String next() { String str = \"\"; try { str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } return str; } } static long modExp(long x, long n, long mod) { long result = 1; while (n > 0) { if (n % 2 == 1) result = (result % mod * x % mod) % mod; x = (x % mod * x % mod) % mod; n = n / 2; } return result; } static long gcd(long a, long b) { if (a == 0) return b; return gcd(b % a, a); } public static void main(String[] args) throws IOException { FastReader fr = new FastReader(); System.out.println((int)(fr.nextInt() / 2) + 1); } } class pair { public int first; public int second; public pair(int first, int second) { this.first = first; this.second = second; } public int first() { return first; } public int second() { return second; } public void setFirst(int first) { this.first = first; } public void setSecond(int second) { this.second = second; } } class myComp implements Comparator<pair> { public int compare(pair a, pair b) { return a.first - b.first; } } class BIT { public long[] m_array; public BIT(long[] dat) { m_array = new long[dat.length + 1]; Arrays.fill(m_array, 0); for (int i = 0; i < dat.length; i++) { m_array[i + 1] = dat[i]; } for (int i = 1; i < m_array.length; i++) { int j = i + (i & -i); if (j < m_array.length) { m_array[j] = m_array[j] + m_array[i]; } } } public final long prefix_query(int i) { long result = 0; for (++i; i > 0; i = i - (i & -i)) { result = result + m_array[i]; } return result; } public final long range_query(int fro, int to) { if (fro == 0) { return prefix_query(to); } else { return prefix_query(to) - prefix_query(fro - 1); } } public void update(int i, long add) { for (++i; i < m_array.length; i = i + (i & -i)) { m_array[i] = m_array[i] + add; } } }", "src": "//Author: Patel Rag\n//Java version \"1.8.0_211\"\nimport java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n      while (st == null || !st.hasMoreElements())\n      {\n        try\n        {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n      String str = \"\";\n      try\n      {\n        str = br.readLine();\n      }\n      catch (IOException e)\n      {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    //binary Modular exponentiation\n  {\n    long result = 1;\n    while(n > 0)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    if(a==0) return b;\n    return gcd(b%a,a);\n  }\n  public static void main(String[] args)\n  throws IOException\n  {\n    FastReader fr = new FastReader();\n    System.out.println((int)(fr.nextInt()/2) + 1);\n\n  }\n}\nclass pair\n{\n  public int first;\n  public int second;\n  public pair(int first,int second)\n  {\n    this.first = first;\n    this.second = second;\n  }\n  public int first() { return first; }\n  public int second() { return second; }\n  public void setFirst(int first) { this.first = first; }\n  public void setSecond(int second) { this.second = second; }\n}\nclass myComp implements Comparator<pair>\n{\n  public int compare(pair a,pair b)\n  {\n    return (a.first - b.first);\n  }\n}\nclass BIT       //Binary Indexed Tree aka Fenwick Tree\n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    for(int i = 0; i < dat.length; i++)\n    {\n      m_array[i + 1] = dat[i];\n    }\n    for(int i = 1; i < m_array.length; i++)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(++i; i > 0; i = i - (i & -i))\n    {\n      result = result + m_array[i];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length; i = i + (i & -i))\n    {\n      m_array[i] = m_array[i] + add;\n    }\n  }\n}\n", "index": 737, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            String input = reader.readLine();\n            String[] parameterStringList = input.split(\" \");\n            int x = Integer.parseInt(parameterStringList[0]);\n            int y = Integer.parseInt(parameterStringList[1]);\n            int z = Integer.parseInt(parameterStringList[2]);\n            int t1 = Integer.parseInt(parameterStringList[3]);\n            int t2 = Integer.parseInt(parameterStringList[4]);\n            int t3 = Integer.parseInt(parameterStringList[5]);\n            \n            int T1 = Math.abs(x - y) * t1;\n            int T2 = Math.abs(x - z) * t2 + 3 * t3 + Math.abs(x - y) * t2;\n\n            if (T2 <= T1) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n    public static void main (String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            String parameterStringList[] = reader.readLine().split(\" \");\n            int x = Integer.parseInt(parameterStringList[0]);\n            int y = Integer.parseInt(parameterStringList[1]);\n            int z = Integer.parseInt(parameterStringList[2]);\n            int t1 = Integer.parseInt(parameterStringList[3]);\n            int t2 = Integer.parseInt(parameterStringList[4]);\n            int t3 = Integer.parseInt(parameterStringList[5]);\n\n            int T1 = Math.abs(x-y) * t1;\n            int T2 = Math.abs(x-z) * t2 + 3*t3 + Math.abs(x-y) * t2;\n\n            if(T2 <= T1) System.out.println(\"YES\");\n            else System.out.println(\"NO\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "index": 739, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.NoSuchElementException;\n\npublic class Main_1100C {\n\n    private static Scanner sc;\n    private static Printer pr;\n\n    private static void solve() {\n        int n = sc.nextInt();\n        int r = sc.nextInt();\n\n        double sin = Math.sin(Math.PI / n);\n        double ans = r * sin / (1 - sin);\n\n        pr.printf(\"%.7f%n\", ans);\n    }\n\n    // ---------------------------------------------------\n    public static void main(String[] args) {\n        sc = new Scanner(System.in);\n        pr = new Printer(System.out);\n\n        solve();\n\n        pr.close();\n        sc.close();\n    }\n\n    static class Scanner {\n        BufferedReader br;\n\n        Scanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        private boolean isPrintable(int ch) {\n            return ch >= '!' && ch <= '~';\n        }\n\n        private boolean isCRLF(int ch) {\n            return ch == '\\n' || ch == '\\r' || ch == -1;\n        }\n\n        private int nextPrintable() {\n            try {\n                int ch;\n                while (!isPrintable(ch = br.read())) {\n                    if (ch == -1) {\n                        throw new NoSuchElementException();\n                    }\n                }\n\n                return ch;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        String next() {\n            try {\n                int ch = nextPrintable();\n                StringBuilder sb = new StringBuilder();\n                do {\n                    sb.appendCodePoint(ch);\n                } while (isPrintable(ch = br.read()));\n\n                return sb.toString();\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        int nextInt() {\n            try {\n                // parseInt from Integer.parseInt()\n                boolean negative = false;\n                int res = 0;\n                int limit = -Integer.MAX_VALUE;\n                int radix = 10;\n\n                int fc = nextPrintable();\n                if (fc < '0') {\n                    if (fc == '-') {\n                        negative = true;\n                        limit = Integer.MIN_VALUE;\n                    } else if (fc != '+') {\n                        throw new NumberFormatException();\n                    }\n                    fc = br.read();\n                }\n                int multmin = limit / radix;\n\n                int ch = fc;\n                do {\n                    int digit = ch - '0';\n                    if (digit < 0 || digit >= radix) {\n                        throw new NumberFormatException();\n                    }\n                    if (res < multmin) {\n                        throw new NumberFormatException();\n                    }\n                    res *= radix;\n                    if (res < limit + digit) {\n                        throw new NumberFormatException();\n                    }\n                    res -= digit;\n\n                } while (isPrintable(ch = br.read()));\n\n                return negative ? res : -res;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        long nextLong() {\n            try {\n                // parseLong from Long.parseLong()\n                boolean negative = false;\n                long res = 0;\n                long limit = -Long.MAX_VALUE;\n                int radix = 10;\n\n                int fc = nextPrintable();\n                if (fc < '0') {\n                    if (fc == '-') {\n                        negative = true;\n                        limit = Long.MIN_VALUE;\n                    } else if (fc != '+') {\n                        throw new NumberFormatException();\n                    }\n                    fc = br.read();\n                }\n                long multmin = limit / radix;\n\n                int ch = fc;\n                do {\n                    int digit = ch - '0';\n                    if (digit < 0 || digit >= radix) {\n                        throw new NumberFormatException();\n                    }\n                    if (res < multmin) {\n                        throw new NumberFormatException();\n                    }\n                    res *= radix;\n                    if (res < limit + digit) {\n                        throw new NumberFormatException();\n                    }\n                    res -= digit;\n\n                } while (isPrintable(ch = br.read()));\n\n                return negative ? res : -res;\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            try {\n                int ch;\n                while (isCRLF(ch = br.read())) {\n                    if (ch == -1) {\n                        throw new NoSuchElementException();\n                    }\n                }\n                StringBuilder sb = new StringBuilder();\n                do {\n                    sb.appendCodePoint(ch);\n                } while (!isCRLF(ch = br.read()));\n\n                return sb.toString();\n            } catch (IOException e) {\n                throw new NoSuchElementException();\n            }\n        }\n\n        int[] nextIntArray(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = sc.nextInt();\n            }\n\n            return ret;\n        }\n\n        int[][] nextIntArrays(int n, int m) {\n            int[][] ret = new int[m][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[j][i] = sc.nextInt();\n                }\n            }\n\n            return ret;\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n//                throw new NoSuchElementException();\n            }\n        }\n    }\n\n    static class Printer extends PrintWriter {\n        Printer(OutputStream out) {\n            super(out);\n        }\n\n        void printInts(int... a) {\n            StringBuilder sb = new StringBuilder(32);\n            for (int i = 0, size = a.length; i < size; i++) {\n                if (i > 0) {\n                    sb.append(' ');\n                }\n                sb.append(a[i]);\n            }\n\n            println(sb);\n        }\n\n        void printLongs(long... a) {\n            StringBuilder sb = new StringBuilder(64);\n            for (int i = 0, size = a.length; i < size; i++) {\n                if (i > 0) {\n                    sb.append(' ');\n                }\n                sb.append(a[i]);\n            }\n\n            println(sb);\n        }\n\n        void printStrings(String... a) {\n            StringBuilder sb = new StringBuilder(32);\n            for (int i = 0, size = a.length; i < size; i++) {\n                if (i > 0) {\n                    sb.append(' ');\n                }\n                sb.append(a[i]);\n            }\n\n            println(sb);\n        }\n    }\n}", "src": "import java.io.*;\nimport java.util.NoSuchElementException;\n\n\npublic class Main_1100C {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\n\t\tdouble sin = Math.sin(Math.PI / n);\n\t\tdouble ans = r * sin / (1 - sin);\n\t\t\n\t\tpr.printf(\"%.7f%n\", ans);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\t\t\t\n\t\tsolve();\n\t\t\t\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tint[][] nextIntArrays(int n, int m) {\n\t\t\tint[][] ret = new int[m][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tret[j][i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t\t\n\t\tvoid printInts(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printLongs(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder(64);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printStrings(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t}\n}\n", "index": 740, "complexity": 1}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        ABirthday solver = new ABirthday();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ABirthday {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            long N = in.readLong(), M = in.readLong(), K = in.readLong(), L = in.readLong();\n\n            long ans = ((L + K) - 1) / M + 1;\n            if (ans * M > N || ans * M - K < L) out.printLine(-1);\n            else out.printLine(ans);\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author @Ziklon\n */\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    ABirthday solver = new ABirthday();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class ABirthday {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      long N = in.readLong(), M = in.readLong(), K = in.readLong(), L = in.readLong();\n\n      long ans = ((L + K) - 1) / M + 1;\n      if (ans * M > N || ans * M - K < L) out.printLine(-1);\n      else out.printLine(ans);\n    }\n  }\n\n  static class OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n    public void printLine(long i) {\n      writer.println(i);\n    }\n\n    public void printLine(int i) {\n      writer.println(i);\n    }\n  }\n\n  static class InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private InputReader.SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (numChars == -1) {\n        throw new InputMismatchException();\n      }\n      if (curChar >= numChars) {\n        curChar = 0;\n        try {\n          numChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (numChars <= 0) {\n          return -1;\n        }\n      }\n      return buf[curChar++];\n    }\n\n    public long readLong() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      long res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n      if (filter != null) {\n        return filter.isSpaceChar(c);\n      }\n      return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n      public boolean isSpaceChar(int ch);\n    }\n  }\n}\n", "index": 741, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Param {\n    public static void main(String[] args) {\n        MyScanner param = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int highestcoin = param.nextInt();\n        int sum = param.nextInt();\n        int remainder = sum % highestcoin;\n        if (remainder != 0) {\n            remainder = 1;\n        } else {\n            remainder = 0;\n        }\n        int count = (sum - remainder) / highestcoin;\n\n        if (highestcoin >= sum) {\n            System.out.println(\"1\");\n        } else {\n            System.out.println(count + remainder);\n        }\n        out.close();\n    }\n\n    public static PrintWriter out;\n\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n", "src": "import java.util.*;\nimport java.io.*;\n\n\n\n public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   //-----------MyScanner class for faster input----------\n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}\n   ", "index": 742, "complexity": 1}
{"back-translation": "public class Codechef { static String reverse(String s) { String reverse = \"\"; for(int i = s.length() - 1; i >= 0; i--) { reverse = reverse + s.charAt(i); } return reverse; } public static void main(String[] args) throws java.lang.Exception { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int x = m % (int)Math.pow(2, n); System.out.println(x); } }", "src": "/**\n *   Author: Ridam Nagar\n *   Date: 27 February 2019\n *   Time: 01:17:36\n**/\n/* \npackage codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Codechef\n{     \n  static String reverse(String s){\n    String reverse=\"\";\n    for(int i=s.length()-1;i>=0;i--){\n        reverse=reverse + s.charAt(i);\n    }\n    return reverse;\n  }\n\n      \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc=new Scanner(System.in);\n         int n=sc.nextInt();\n         int m=sc.nextInt();\n         int x=m%(int)Math.pow(2,n);\n         System.out.println(x);\n\n\n\n}\n}", "index": 743, "complexity": 1}
{"back-translation": "import java.io.*;\n\npublic class n5D\n{\n    public static void main(String[] args)\n    {\n        double a = 0, v = 0, l = 0, d = 0, w = 0;\n        try\n        {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] str = br.readLine().split(\" \");\n            a = Double.parseDouble(str[0]);\n            v = Double.parseDouble(str[1]);\n            str = br.readLine().split(\" \");\n            l = Double.parseDouble(str[0]);\n            d = Double.parseDouble(str[1]);\n            w = Double.parseDouble(str[2]);\n        }\n        catch(Exception e)\n        {\n            System.out.println(e);\n        }\n\n        double t1, t2, t3, t4, t5, t, D = 0;\n        \n        if (w > v) w = v;\n        t2 = d / v - v / a + w * w / 2 / a / v;\n        if (t2 >= 0)\n        {\n            t1 = v / a; \n            t3 = t1 - w / a;\n        }\n        else\n        {\n            if (Math.sqrt(2 * d / a) > (w / a))\n            {\n                t1 = Math.sqrt((2 * a * d + w * w) / (a * a * 2));\n                t3 = t1 - w / a;\n            }\n            else\n            {\n                t1 = Math.sqrt(2 * d / a);\n                t3 = 0;\n            }\n            t2 = 0;\n        }\n        t5 = (l - d - v * v / 2 / a + a * (t1 - t3) * (t1 - t3) / 2) / v;\n        if (t5 >= 0) t4 = v / a - (t1 - t3);\n        else\n        {\n            t5 = 0;\n            t4 = -t1 + t3 + Math.sqrt((t1 - t3) * (t1 - t3) + 2 * (l - d) / a);\n        }\n        t = t1 + t2 + t3 + t4 + t5;\n        System.out.println(t);\n        //System.out.println(t1 + \" \" + t2 + \" \" + t3 + \" \" + t4 + \" \" + t5);\n    }\n}", "src": "import java.io.*;\n\npublic class n5D\n{\n    public static void main(String[] args)\n    {\n        double a = 0, v = 0, l = 0, d = 0, w = 0;\n        try\n        {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] str = br.readLine().split(\" \");\n            a = Double.parseDouble(str[0]);\n            v = Double.parseDouble(str[1]);\n            str = br.readLine().split(\" \");\n            l = Double.parseDouble(str[0]);\n            d = Double.parseDouble(str[1]);\n            w = Double.parseDouble(str[2]);\n        }\n        catch(Exception e)\n        {\n            System.out.println(e);\n        }\n\n        double t1, t2, t3, t4, t5, t, D = 0;\n        \n        if (w > v) w = v;\n        t2 = d / v - v / a + w * w / 2 / a / v;\n        if (t2 >= 0)\n        {\n            t1 = v / a; \n            t3 = t1 - w / a;\n        }\n        else\n        {\n            if (Math.sqrt(2 * d / a) > (w / a))\n            {\n                t1 = Math.sqrt((2 * a * d + w * w) / (a * a * 2));\n                t3 = t1 - w / a;\n            }\n            else\n            {\n                t1 = Math.sqrt(2 * d / a);\n                t3 = 0;\n            }\n            t2 = 0;\n        }\n        t5 = (l - d - v * v / 2 / a + a * (t1 - t3) * (t1 - t3) / 2) / v;\n        if (t5 >= 0) t4 = v / a - (t1 - t3);\n        else\n        {\n            t5 = 0;\n            t4 = -t1 + t3 + Math.sqrt((t1 - t3) * (t1 - t3) + 2 * (l - d) / a);\n        }\n        t = t1 + t2 + t3 + t4 + t5;\n        System.out.println(t);\n        //System.out.println(t1 + \" \" + t2 + \" \" + t3 + \" \" + t4 + \" \" + t5);\n    }\n}", "index": 744, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        A979 solver = new A979();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A979 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            long n = in.nextLong();\n            n++;\n            if (n % 2 == 0) {\n                out.println(n / 2);\n            } else {\n                if (n != 1) {\n                    out.println(n);\n                } else {\n                    out.println(0);\n                }\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int c);\n\n        }\n\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Sid\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        A979 solver = new A979();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A979 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            long n = in.nextLong();\n            n = n + 1;\n            if (n % 2 == 0) {\n                out.println(n / 2);\n            } else {\n                if (n != 1) {\n                    out.println(n);\n                } else {\n                    out.println(0);\n                }\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "index": 745, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNextInt()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "import java.util.Scanner;\n\npublic class Main {\n//kai\n\tpublic static void main(String[] args) {\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}\n \t \t  \t\t\t\t \t \t      \t\t \t\t \t\t", "index": 746, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n % 2 == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n%2==0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\t\t \t  \t\t\t\t\t\t  \t\t\t \t\t\t   \t \t\t \t\t", "index": 747, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class TransformedClass {\n\tpublic void run() throws Exception {\n\t\tScanner file = new Scanner(System.in);\n\t\tint a = file.nextInt(), b = file.nextInt(), c = file.nextInt(), n = file.nextInt();\n\t\ta -= c;\n\t\tb -= c;\n\t\tif (a < 0 || b < 0) System.out.println(-1);\n\t\telse {\n\t\t\tint x = a + b + c;\n\t\t\tif (x >= n) System.out.println(-1);\n\t\t\telse System.out.println(n - x);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew TransformedClass().run();\n\t}\n\n}", "src": "import java.util.*;\nimport java.io.*;\n\npublic class aaaaaaaaaaaaaaaa {\n\tpublic void run() throws Exception {\n\t\tScanner file = new Scanner(System.in);\n\t\tint a = file.nextInt(), b= file.nextInt(), c = file.nextInt(), n = file.nextInt();\n\t\ta -= c;\n\t\tb -= c;\n\t\tif (a < 0 || b < 0) System.out.println(-1);\n\t\telse {\n\t\t\tint x = a + b + c;\n\t\t\tif (x >= n) System.out.println(-1);\n\t\t\telse System.out.println(n - x);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew aaaaaaaaaaaaaaaa().run();\n\t}\n\n}", "index": 749, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile (true) {\n\t\t\tif (n % 2 != 0) {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}\n\t\t\tif (!sc.hasNext()) break;\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\n}\n", "src": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n % 2 != 0) {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n\t\t\t\t\t  \t \t     \t      \t\t \t\t\t", "index": 750, "complexity": 1}
{"back-translation": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              long a[] = new long[14];\n              for(int i = 0; i < 14; i++)\n                     a[i] = sc.nextLong();\n              long cpy[] = new long[14];\n              long max = 0;\n              for(int i = 0; i < 14; i++){\n                     if(a[i] == 0)continue;\n                     long score = 0;\n                     long curr = a[i];\n                     for(int j = 0; j < 14; j++){\n                            cpy[j] = a[j];\n                     }\n                     cpy[i] = 0;\n                     long amnt = curr / 14l;\n                     for(int j = 0; j < 14; j++){\n                            cpy[j] += amnt;\n                     }\n                     amnt = curr % 14;\n                     for(int j = i + 1; j < i + 1 + amnt; j++){\n                            cpy[j % 14]++;\n                     }\n                     for(int j = 0; j < 14; j++){\n                            if(cpy[j] % 2 == 0)\n                                   score += cpy[j];\n                     }\n                     max = Math.max(max, score);\n              }\n              System.out.println(max);\n      }\n}", "src": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              long a[] = new long[14];\n              for(int i = 0; i < 14; i++)\n                     a[i] = sc.nextLong();\n              long cpy[] = new long[14];\n              long max = 0;\n              for(int i = 0; i < 14; i++){\n                     if(a[i] == 0)continue;\n                     long score = 0;\n                     long curr = a[i];\n                     for(int j = 0; j < 14; j++)\n                            cpy[j] = a[j];\n                     cpy[i] = 0;\n                     long amnt = curr / 14l;\n                     for(int j = 0; j < 14; j++){\n                            cpy[j] += amnt;\n                     }\n                     amnt = curr % 14;\n                     for(int j = i + 1; j < i + 1 + amnt; j++){\n                            cpy[j % 14]++;\n                     }\n                     for(int j = 0; j < 14; j++){\n                            if(cpy[j] % 2 == 0)\n                                   score += cpy[j];\n                     }\n                     max = Math.max(max, score);\n              }\n              System.out.println(max);\n      }\n}", "index": 751, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() { br = new BufferedReader(new InputStreamReader(System.in)); }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n\n        long nextLong() { return Long.parseLong(next()); }\n\n        double nextDouble() { return Double.parseDouble(next()); }\n\n        float nextFloat() { return Float.parseFloat(next()); }\n\n        boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static long modExp(long x, long n, long mod) {\n        long result = 1;\n        while (n > 0) {\n            if (n % 2 == 1)\n                result = (result % mod * x % mod) % mod;\n            x = (x % mod * x % mod) % mod;\n            n = n / 2;\n        }\n        return result;\n    }\n\n    static long gcd(long a, long b) {\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastReader fr = new FastReader();\n        long n = fr.nextLong();\n        long x = fr.nextLong();\n        long y = fr.nextLong();\n        long w = Long.min(x, y) - 1 + (x - Long.min(x, y)) + (y - Long.min(x, y));\n        long b = n - Long.max(x, y) + (Long.max(x, y) - x) + (Long.max(x, y) - y);\n        if (w <= b) System.out.println(\"White\");\n        else System.out.println(\"Black\");\n    }\n\n}\n\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    private Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Pair<?, ?> pair = (Pair<?, ?>) o;\n\n        if (!first.equals(pair.first)) return false;\n        return second.equals(pair.second);\n    }\n\n    @Override\n    public int hashCode() {\n        return 31 * first.hashCode() + second.hashCode();\n    }\n\n    public static <U, V> Pair<U, V> of(U a, V b) {\n        return new Pair<>(a, b);\n    }\n}\n\nclass myComp implements Comparator<Pair> {\n    public int compare(Pair a, Pair b) {\n        if (a.first != b.first) return ((int) a.first - (int) b.first);\n        if (a.second != b.second) return ((int) a.second - (int) b.second);\n        return 0;\n    }\n}\n\nclass BIT {\n    public long[] m_array;\n\n    public BIT(long[] dat) {\n        m_array = new long[dat.length + 1];\n        Arrays.fill(m_array, 0);\n        for (int i = 0; i < dat.length; i++) {\n            m_array[i + 1] = dat[i];\n        }\n        for (int i = 1; i < m_array.length; i++) {\n            int j = i + (i & -i);\n            if (j < m_array.length) {\n                m_array[j] = m_array[j] + m_array[i];\n            }\n        }\n    }\n\n    public final long prefix_query(int i) {\n        long result = 0;\n        for (++i; i > 0; i = i - (i & -i)) {\n            result = result + m_array[i];\n        }\n        return result;\n    }\n\n    public final long range_query(int fro, int to) {\n        if (fro == 0) {\n            return prefix_query(to);\n        } else {\n            return (prefix_query(to) - prefix_query(fro - 1));\n        }\n    }\n\n    public void update(int i, long add) {\n        for (++i; i < m_array.length; i = i + (i & -i)) {\n            m_array[i] = m_array[i] + add;\n        }\n    }\n}", "src": "//Author: Patel Rag\n//Java version \"1.8.0_211\"\nimport java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n      while (st == null || !st.hasMoreElements())\n      {\n        try\n        {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n      String str = \"\";\n      try\n      {\n        str = br.readLine();\n      }\n      catch (IOException e)\n      {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    //binary Modular exponentiation\n  {\n    long result = 1;\n    while(n > 0)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    if(a==0) return b;\n    return gcd(b%a,a);\n  }\n  public static void main(String[] args)\n  throws IOException\n  {\n    FastReader fr = new FastReader();\n    long n = fr.nextLong();\n    long x = fr.nextLong();\n    long y = fr.nextLong();\n    long w = Long.min(x,y) - 1 + (x - Long.min(x,y)) + (y - Long.min(x,y));\n    long b = n - Long.max(x,y) + (Long.max(x,y) - x) + (Long.max(x,y) - y);\n    if(w <= b) System.out.println(\"White\");\n    else System.out.println(\"Black\");\n\n  }\n}\nclass Pair<U, V>  // Pair class\n{\n    public final U first;       // first field of a Pair\n    public final V second;      // second field of a Pair\n\n    private Pair(U first, V second)\n    {\n      this.first = first;\n      this.second = second;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n      if (this == o) return true;\n\n      if (o == null || getClass() != o.getClass()) return false;\n\n      Pair<?, ?> pair = (Pair<?, ?>) o;\n\n      if (!first.equals(pair.first)) return false;\n      return second.equals(pair.second);\n    }\n\n    @Override\n    public int hashCode()\n    {\n      return 31 * first.hashCode() + second.hashCode();\n    }\n\n    public static <U, V> Pair <U, V> of(U a, V b)\n    {\n      return new Pair<>(a, b);\n    }\n}\nclass myComp implements Comparator<Pair>\n{\n  public int compare(Pair a,Pair b)\n  {\n    if(a.first != b.first) return ((int)a.first - (int)b.first);\n    if(a.second != b.second) return ((int)a.second - (int)b.second);\n    return 0;\n  }\n}\nclass BIT       //Binary Indexed Tree aka Fenwick Tree\n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    for(int i = 0; i < dat.length; i++)\n    {\n      m_array[i + 1] = dat[i];\n    }\n    for(int i = 1; i < m_array.length; i++)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(++i; i > 0; i = i - (i & -i))\n    {\n      result = result + m_array[i];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length; i = i + (i & -i))\n    {\n      m_array[i] = m_array[i] + add;\n    }\n  }\n}\n", "index": 753, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\n\n\n public class Param\n{\n                \n      public static  void main( String[]args) throws IOException\n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   //-----------MyScanner class for faster input----------\n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() throws IOException {\n          while (st == null || !st.hasMoreElements()) {\n              st = new StringTokenizer(br.readLine());\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() throws IOException {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() throws IOException {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() throws IOException {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine() throws IOException {\n          String str = br.readLine();\n          return str;\n      }\n}\n}", "src": "import java.util.*;\nimport java.io.*;\n\n\n\n public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   //-----------MyScanner class for faster input----------\n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}\n   ", "index": 754, "complexity": 1}
{"back-translation": "ERROR", "src": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\nimport java.math.*;\nimport static java.lang.Integer.*;\nimport static java.lang.Double.*;\nimport java.lang.Math.*;\n\npublic class two_squares {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew two_squares().run();\n\t}\n\n\tpublic void run() throws Exception {\n\t\tFastIO file = new FastIO();\n\t\tdouble x1 = file.nextInt();\n\t\tdouble y1 = file.nextInt();\n\t\tdouble x2 = file.nextInt();\n\t\tdouble y2 = file.nextInt();\n\t\tdouble x3 = file.nextInt();\n\t\tdouble y3 = file.nextInt();\n\t\tdouble x4 = file.nextInt();\n\t\tdouble y4 = file.nextInt();\n\t\tdouble minx1, maxx1, miny1, maxy1;\n\t\tminx1 = Math.min(x1, Math.min(x2, Math.min(x3, x4)));\n\t\tmaxx1 = Math.max(x1, Math.max(x2, Math.max(x3, x4)));\n\t\tminy1 = Math.min(y1, Math.min(y2, Math.min(y3, y4)));\n\t\tmaxy1 = Math.max(y1, Math.max(y2, Math.max(y3, y4)));\n\t\tdouble x5 = file.nextInt();\n\t\tdouble y5 = file.nextInt();\n\t\tdouble x6 = file.nextInt();\n\t\tdouble y6 = file.nextInt();\n\t\tdouble x7 = file.nextInt();\n\t\tdouble y7 = file.nextInt();\n\t\tdouble x8 = file.nextInt();\n\t\tdouble y8 = file.nextInt();\n\t\tdouble minx2, maxx2, miny2, maxy2;\n\t\tminx2 = Math.min(x5, Math.min(x6, Math.min(x7, x8)));\n\t\tmaxx2 = Math.max(x5, Math.max(x6, Math.max(x7, x8)));\n\t\tminy2 = Math.min(y5, Math.min(y6, Math.min(y7, y8)));\n\t\tmaxy2 = Math.max(y5, Math.max(y6, Math.max(y7, y8)));\n\t\tPoint _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16;\n\t\t_1 = new Point(x1, y1);\n\t\t_2 = new Point(x2, y2);\n\t\t_3 = new Point(x3, y3);\n\t\t_4 = new Point(x4, y4);\n\t\t_5 = new Point(x5, y5);\n\t\t_6 = new Point(x6, y6);\n\t\t_7 = new Point(x7, y7);\n\t\t_8 = new Point(x8, y8);\n\t\t_9 = new Point(minx1, maxy1);\n\t\t_10 = new Point(minx1, miny1);\n\t\t_11 = new Point(maxx1, maxy1);\n\t\t_12 = new Point(maxx1, miny1);\n\t\tdouble m1 = (minx2 + maxx2) / 2;\n\t\tdouble m2 = (miny2 + maxy2) / 2;\n\t\t_13 = new Point(minx2, m2);\n\t\t_14 = new Point(m1, miny2);\n\t\t_15 = new Point(maxx2, m2);\n\t\t_16 = new Point(m1, maxy2);\n\t\tPoint[] a = {_1, _2, _3, _4};\n\t\tPoint[] b = {_5, _6, _7, _8};\n\t\tboolean works = false;\n\t\tLine[] aa = {new Line(_9,_10), new Line(_10, _12), new Line(_12, _11), new Line(_11, _9)};\n\t\tLine[] bb = {new Line(_13, _14), new Line(_14, _15), new Line(_15, _16), new Line(_16, _13)};\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (aa[i].intersection(bb[i]) != null) {\n\t\t\t\t\tworks = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Point p : b) {\n\t\t\tif (p.x >= minx1 && p.x <= maxx1 && p.y >= miny1 && p.y <= maxy1) {\n\t\t\t\tworks = true;\n\t\t\t}\n\t\t}\n\t\tfor (Point p : a) {\n\t\t\tboolean result = false;\n\t\t      for (int i = 0, j = b.length - 1; i < b.length; j = i++) {\n\t\t        if ((b[i].y > p.y) != (b[j].y > p.y) &&\n\t\t            (p.x < (b[j].x - b[i].x) * (p.y - b[i].y) / (b[j].y-b[i].y) + b[i].x)) {\n\t\t          result = !result;\n\t\t         }\n\t\t      }\n\t\t      if (result) works = true;\n\t\t}\n\t\tSystem.out.println(works ? \"YES\" : \"NO\");\n\t}\n\tpublic static class Point {\n\t\tdouble x, y;\n\t\tpublic Point(double a, double b) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\t}\n\tpublic static class Line {\n\t\tPoint a, b;\n\t\tpublic Line(Point x, Point y) {\n\t\t\ta = x;\n\t\t\tb = y;\n\t\t}\n\t\tpublic Point intersection(Line o) {\n\t\t\tdouble x1 = a.x;\n\t\t\tdouble y1 = a.y;\n\t\t\tdouble x2 = b.x;\n\t\t\tdouble y2 = b.y;\n\t\t\tdouble x3 = o.a.x;\n\t\t\tdouble y3 = o.a.y;\n\t\t\tdouble x4 = o.b.x;\n\t\t\tdouble y4 = o.b.y;\n\t\t\tdouble denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\t\t\t  double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3))/denom;\n\t\t\t  double ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3))/denom;\n\t\t\t    if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {\n\t\t\t        return new Point((int) (x1 + ua*(x2 - x1)), (int) (y1 + ua*(y2 - y1)));\n\t\t\t    }\n\n\t\t\t  return null;\n\t\t}\n\t}\n\tpublic static class FastIO {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastIO() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\tpublic static long pow(long n, long p, long mod) {\n\t\tif (p == 0)\n\t\t\treturn 1;\n\t\tif (p == 1)\n\t\t\treturn n % mod;\n\t\tif (p % 2 == 0) {\n\t\t\tlong temp = pow(n, p / 2, mod);\n\t\t\treturn (temp * temp) % mod;\n\t\t} else {\n\t\t\tlong temp = pow(n, p / 2, mod);\n\t\t\ttemp = (temp * temp) % mod;\n\t\t\treturn (temp * n) % mod;\n\n\t\t}\n\t}\n\n\tpublic static long pow(long n, long p) {\n\t\tif (p == 0)\n\t\t\treturn 1;\n\t\tif (p == 1)\n\t\t\treturn n;\n\t\tif (p % 2 == 0) {\n\t\t\tlong temp = pow(n, p / 2);\n\t\t\treturn (temp * temp);\n\t\t} else {\n\t\t\tlong temp = pow(n, p / 2);\n\t\t\ttemp = (temp * temp);\n\t\t\treturn (temp * n);\n\n\t\t}\n\t}\n\n\tpublic static long gcd(long x, long y) {\n\t\tif (x == 0)\n\t\t\treturn y;\n\t\telse\n\t\t\treturn gcd(y % x, x);\n\t}\n\n\tpublic static boolean isPrime(int n) {\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\n\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\treturn false;\n\n\t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\n\t\treturn true;\n\t}\n}\n", "index": 755, "complexity": 1}
{"back-translation": "import java.util.*;\npublic class C {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble n = sc.nextDouble(), r = sc.nextDouble();\n\t\tSystem.out.println(r / (1 / Math.sin(Math.PI / n) - 1));\n\t\tsc.close();\n\t}\n}", "src": "import java.util.*;\npublic class C {\n\tpublic static void main(String[]args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble n=sc.nextDouble(),r=sc.nextDouble();\n\t\tSystem.out.println(r/(1/Math.sin(Math.PI/n)-1));\n\t\tsc.close();\n\t}\n}", "index": 756, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Solve4 {\n\n    public static void main(String[] args) throws IOException {\n        FastReader sc = new FastReader();\n        int x = sc.nextInt();\n        int y = sc.nextInt();\n        int z = sc.nextInt();\n        int t1 = sc.nextInt();\n        int t2 = sc.nextInt();\n        int t3 = sc.nextInt();\n        if ((Math.abs(x - y)) * t1 < ((Math.abs(x - z)) + (Math.abs(x - y))) * t2 + 3 * t3) {\n            System.out.println(\"NO\");\n        } else {\n            System.out.println(\"YES\");\n        }\n    }\n\n    static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            String s = \"\";\n            try {\n                s = br.readLine();\n            } catch (IOException ex) {\n            }\n            return s;\n        }\n    }\n\n}\n", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Solve4 {\n\n    public static void main(String[] args) throws IOException {\n      FastReader sc = new FastReader();\n      int x= sc.nextInt();\n      int y= sc.nextInt();\n      int z= sc.nextInt();\n      int t1= sc.nextInt();\n      int t2= sc.nextInt();\n      int t3= sc.nextInt();\n      if(Math.abs(x-y)*t1 < (Math.abs(x-z)+Math.abs(x-y))*t2+3*t3 ) System.out.println(\"NO\");\n      else System.out.println(\"YES\");\n    }\n\n    static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            String s = \"\";\n            try {\n                s = br.readLine();\n            } catch (IOException ex) {\n            }\n            return s;\n        }\n    }\n\n}\n", "index": 757, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.lang.Math;\npublic class tab\n{\npublic static void main(String[] args)\n{\nint n,pos,l,r;\nScanner sc=new Scanner(System.in);\nn=sc.nextInt();\npos=sc.nextInt();\nl=sc.nextInt();\nr=sc.nextInt();\nint sum;\nint a=(n-r)+(l-1);\nif((Math.abs(pos-l)<Math.abs(r-pos))&&a!=0)\n{\nif(l!=1)\n{sum=Math.abs(pos-l);\nsum++;\nif(r!=n)\nsum+=(r-l)+1;\n}\nelse\nsum=Math.abs(r-pos)+1;\n}\nelse if(a==0)\nsum=0;\nelse\n{\nif(r!=n)\n{sum=Math.abs(r-pos);\nsum++;\nif(l!=1)\nsum+=(r-l)+1;\n}\nelse\nsum=Math.abs(pos-l)+1;\n}\nSystem.out.println(sum);\n}};", "src": "import java.util.*;\nimport java.lang.Math;\npublic class tab\n{\npublic static void main(String[] args)\n{\nint n,pos,l,r;\nScanner sc=new Scanner(System.in);\nn=sc.nextInt();\npos=sc.nextInt();\nl=sc.nextInt();\nr=sc.nextInt();\nint sum;\nint a=(n-r)+(l-1);\nif((Math.abs(pos-l)<Math.abs(r-pos))&&a!=0)\n{\n if(l!=1)\n   {sum=Math.abs(pos-l);\n    sum++;\n    if(r!=n)\n      sum+=(r-l)+1;\n   }\n else\n   sum=Math.abs(r-pos)+1;\n}\nelse if(a==0)\n  sum=0; \nelse\n{\n  if(r!=n)\n  {  sum=Math.abs(r-pos);\n     sum++;\n     if(l!=1) \n     sum+=(r-l)+1;\n  }\n  else\n   sum=Math.abs(pos-l)+1;\n}\nSystem.out.println(sum);\n}}", "index": 758, "complexity": 1}
{"back-translation": "import java.io.*;\npublic class coins\n{\n public static void main(String args[])throws IOException\n {\n  InputStreamReader read=new InputStreamReader(System.in);\n  BufferedReader in=new BufferedReader(read);\n  String a;\n  int i, k, n, v;\n  a=in.readLine();\n  for(i=0;i<a.length();i++)\n  {\n   if(a.charAt(i)==' ')\n   break;\n  }\n  n=Integer.parseInt(a.substring(0,i));\n  v=Integer.parseInt(a.substring(i+1));\n  k=v%n;\n  v=v/n;\n  if(k>0)\n  v++;\n  System.out.println(v);\n }\n}\n", "src": "import java.io.*;\npublic class coins\n{\n public static void main(String args[])throws IOException\n {\n  InputStreamReader read=new InputStreamReader(System.in);\n  BufferedReader in=new BufferedReader(read);\n  int i,k,n,v;\n  String a;\n  a=in.readLine();\n  for(i=0;i<a.length();i++)\n  {\n   if(a.charAt(i)==' ')\n   break;\n  }\n  n=Integer.parseInt(a.substring(0,i));\n  v=Integer.parseInt(a.substring(i+1));\n  k=v%n;\n  v=v/n;\n  if(k>0)\n  v++;\n  System.out.println(v);\n }\n}\n", "index": 759, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\nimport java.lang.String;\npublic class Solution\n{\n    public static void main(String[] args)\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try\n        {\n            String str = br.readLine();\n            int q = Integer.parseInt(str);\n            if(q%2 == 0 && q!=2)\n                System.out.println(\"YES\");\n            else\n                System.out.println(\"NO\");\n        }\n        catch(IOException e)\n        {\n            System.out.println(\"Input Error\");\n        }\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\nimport java.lang.String;\npublic class Solution\n{\n    public static void main(String[] args)\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try\n        {\n            String str = br.readLine();\n            int q = Integer.parseInt(str);\n            //int q = 7;\n            //int q = 1345679;\n        if(q%2 == 0 && q!=2)\n                System.out.println(\"YES\");\n            else\n                System.out.println(\"NO\");\n            \n        }\n        catch(IOException e)\n        {\n            System.out.println(\"Input Error\");\n        }\n        \n        \n \n       /* String str = \"hello\";\n        String str1 = Character.toUpperCase(str.charAt(0))+str.substring(1);\n        System.out.println(str1);\n        */\n \n    }\n}", "index": 760, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int hp = scanner.nextInt();\n        int remainder = hp % 4;\n        switch (remainder) {\n            case 1:\n                System.out.println(\"0 A\");\n                break;\n            case 2:\n                System.out.println(\"1 B\");\n                break;\n            case 3:\n                System.out.println(\"2 A\");\n                break;\n            default:\n                System.out.println(\"1 A\");\n        }\n    }\n}", "src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n         int hp = scanner.nextInt();\n        if (hp%4 == 1){\n            System.out.println(\"0 A\");\n        }\n        else if (hp%4 == 2){\n            System.out.println(\"1 B\");\n        }\n        else if (hp%4 == 3){\n            System.out.println(\"2 A\");\n        }\n        else {\n            System.out.println(\"1 A\");\n        }\n\n    }\n    }\n", "index": 763, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class B {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        StringBuilder ans1 = new StringBuilder();\n        StringBuilder ans2 = new StringBuilder();\n        for(int i=0; i<2229; i++) {\n            ans1.append('5');\n        }\n        ans1.append('6');\n        for(int i=0; i<2230; i++) {\n            ans2.append('4');\n        }\n        out.println(ans1.toString());\n        out.println(ans2.toString());\n        out.close();\n        System.exit(0);\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class B {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        // int n = Integer.parseInt(bf.readLine());\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        StringBuilder ans1 = new StringBuilder();\n        StringBuilder ans2 = new StringBuilder();\n        for(int i=0; i<2229; i++) ans1.append('5');\n        ans1.append('6');\n        for(int i=0; i<2230; i++) ans2.append('4');\n        out.println(ans1.toString());\n        out.println(ans2.toString());\n        out.close(); System.exit(0);\n    }\n}\n", "index": 764, "complexity": 1}
{"back-translation": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Codechef {\n    static int max = Integer.MIN_VALUE;\n    static int res = 0;\n    \n    static int[] checkMax(int[] arr, int j) {\n        int sum = 0;\n        int x = arr[j];\n        while (x != 0) {\n            if (j + 1 == 15) {\n                j = 0;\n            } else {\n                arr[j + 1] = arr[j + 1] + 1;\n            }\n            x--;\n            j++;\n        }\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long[] a = new long[14];\n        long[] b = new long[14];\n        long p, q, r, s, max = 0;\n        for (int i = 0; i < 14; i++)\n            a[i] = sc.nextInt();\n        for (int i = 0; i < 14; i++) {\n            p = a[i] % 14;\n            q = a[i] / 14;\n            r = 0;\n            s = 0;\n            for (int j = 0; j < 14; j++)\n                b[j] = a[j];\n            b[i] = 0;\n            int j = (i + 1) % 14;\n            for (; r < p; r++) {\n                b[j]++;\n                j = (j + 1) % 14;\n            }\n            for (j = 0; j < 14; j++) {\n                b[j] += q;\n                if (b[j] % 2 == 0)\n                    s += b[j];\n            }\n            max = Math.max(max, s);\n        }\n        System.out.println(max);\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\npublic class Codechef{\n\tstatic int max=Integer.MIN_VALUE;\n\tstatic int res=0;\n\tstatic int[] checkMax(int arr[],int j){\n             int sum=0;\n             int x=arr[j];\n        \t\twhile(x!=0){\n        \t\t        if(j+1==15){\n        \t\t        \tj=0;\n        \t\t        }else{\n        \t\t        \tarr[j+1]=arr[j+1]+1;\n        \t\t        }\n        \t\t        // if(arr[j+1]%2==0){\n        \t\t        // \tsum=sum+arr[j+1];\n        \t\t        // \tif(sum>=max){\n        \t\t        // \tmax=sum;\n        \t\t        // }\n        \t\t        // }\n\n        \t\t        \n        \t\t        x--;\n        \t\t        j++;\n        \t\t}\n        \t\t     return arr;\n\n\t}\n      \n\n    public static void main(String []args){\n       Scanner sc = new Scanner (System.in);\n    long a [] = new long [14];\n    long b [] = new long [14];\n    long p,q,r,s,max = 0;\n    for(int i = 0; i < 14; i++) a[i] = sc.nextInt();\n    for(int i = 0; i < 14; i++){\n      p = a[i]%14;\n      q = a[i]/14;\n      r = 0;\n      s = 0;\n      for(int j = 0; j < 14; j++) b[j] = a[j];\n      b[i] = 0;\n      int j = (i+1)%14;\n      for(; r < p; r++) {\n        b[j]++;\n        j=(j+1)%14;\n      }\n      for( j = 0; j < 14; j++) {\n        b[j] += q;\n        if(b[j] % 2 == 0) s+= b[j];\n      }\n      max = Math.max(max,s);\n    }\n    System.out.println(max);\n\n\n\n    }\n\n}", "index": 765, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), s = sc.nextInt();\n        int coins;\n        coins = s % n != 0 ? s / n + 1 : s / n;\n\n        System.out.println(coins);\n\n    }\n}", "src": "import java.util.Scanner;\n\n/**\n * Solution\n */\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), s = sc.nextInt();\n        int coins;\n        if(s%n != 0)\n            coins = s/n + 1;\n        else\n            coins = s/n;\n\n        System.out.println(coins);\n\n    }\n}", "index": 766, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class A1008 {\n    public static void main(String[] args) {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong();\n        long k = ir.nextLong();\n        pw.print((n + k - 1) / n);\n\n    }\n\n    private static void Qsort(int[] array, int low, int high) {\n\n        int i = low;\n        int j = high;\n        int x = array[low + (high - low) / 2];\n\n        do {\n            while (array[i] < x) {\n                i++;\n            }\n            while (array[j] > x) {\n                j--;\n            }\n            if (i <= j) {\n                int tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                i++;\n                j--;\n            }\n        } while (i <= j);\n\n        if (low < j) {\n            Qsort(array, low, j);\n        }\n        if (i < high) {\n            Qsort(array, i, high);\n        }\n\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine() {\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String[] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class A1008 {\n    public static void main(String [] args) /*throws Exception*/ {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);//new InputReader(new FileInputStream(new File(\"input.txt\")));new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);//new PrintWriter(new FileOutputStream(new File(\"output.txt\")));\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        pw.print((n + k - 1) / n);\n\n    }\n\n    private static void Qsort(int[] array, int low, int high) {\n\n        int i = low;\n        int j = high;\n        int x = array[low + (high - low) / 2];\n\n        do {\n            while (array[i] < x) ++i;\n            while (array[j] > x) --j;\n            if (i <= j) {\n                int tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                i++;\n                j--;\n            }\n        } while (i <= j);\n\n        if (low < j) Qsort(array, low, j);\n        if (i < high) Qsort(array, i, high);\n\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "index": 767, "complexity": 1}
{"back-translation": "import java.util.*;\n\npublic class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int q=scan.nextInt();\n        int i=1;\n        while(i<=q)\n        {\n            int a=scan.nextInt();\n            int ans=a/7+1;\n            System.out.println(ans);\n            i++;\n        }\n    }\n}", "src": "import java.util.*;\n\npublic class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int q=scan.nextInt();\n        int i;\n        for(i=1;i<=q;i++)\n        {\n            int a=scan.nextInt();\n            int ans=a/7+1;\n            System.out.println(ans);\n        }\n    }\n}", "index": 769, "complexity": 1}
{"back-translation": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class pr1023B {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        long n = sc.nextLong();\n        long k = sc.nextLong();\n\n        out.println(solve(n, k));\n        out.flush();\n        out.close();\n    }\n\n    static long solve(long n, long k) {\n        if (k <= n) {\n            return (long) Math.floor((double) (k - 1) / 2);\n        } else {\n            long mx = n;\n            long mn = k - n;\n            return Math.max(0, (long) Math.floor((double) (mx - mn + 1) / 2));\n        }\n    }\n}", "src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class pr1023B {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        long n = sc.nextLong();\n        long k = sc.nextLong();\n\n        out.println(solve(n, k));\n        out.flush();\n        out.close();\n    }\n\n\n    static long solve(long n, long k) {\n        if(k <= n) return (long)Math.floor((double)(k-1)/2);\n        else{\n            long mx = n;\n            long mn = k-n;\n            return Math.max(0, (long)Math.floor((double)(mx-mn+1)/2));\n        }\n    }\n}\n", "index": 770, "complexity": 1}
{"back-translation": "class GFG {\n    public static int N = 1000;\n    static int prefixans[] = new int[1000];\n    public static void countIndex(int a[], int n) {\n        for (int i = 0; i < n; i++) {\n            if (i + 1 < n && a[i] == a[i + 1])\n                prefixans[i] = 1;\n            if (i != 0)\n                prefixans[i] += prefixans[i - 1];\n        }\n    }\n    public static int answer_query(int l, int r) {\n        if (l == 0)\n            return prefixans[r - 1];\n        else\n            return prefixans[r - 1] - prefixans[l - 1];\n    }\n    public static void main(String args[]) {\n        int a[] = {1, 2, 2, 2, 3, 3, 4, 4, 4};\n        int n = 9;\n        countIndex(a, n);\n        int L, R;\n        L = 1;\n        R = 8;\n        System.out.println(answer_query(L, R));\n        L = 0;\n        R = 4;\n        System.out.println(answer_query(L, R));\n    }\n}", "src": "\n// Java program to count \n// the number of indexes \n// in range L R such that \n// Ai=Ai+1 \n\nclass\nGFG { \n\npublic\nstatic\nint\nN = \n1000\n; \n\n// Array to store count \n// of index from 0 to \n// i that obey condition \nstatic\nint\nprefixans[] = \nnew\nint\n[\n1000\n]; \n\n// precomputing prefixans[] array \npublic\nstatic\nvoid\ncountIndex(\nint\na[], \nint\nn) \n{ \n\n\n// traverse to compute \n\n// the prefixans[] array \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(i + \n1\n< n && a[i] == a[i + \n1\n]) \n\nprefixans[i] = \n1\n; \n\n\nif\n(i != \n0\n) \n\nprefixans[i] += prefixans[i - \n1\n]; \n\n} \n} \n\n// function that answers \n// every query in O(1) \npublic\nstatic\nint\nanswer_query(\nint\nl, \nint\nr) \n{ \n\nif\n(l == \n0\n) \n\nreturn\nprefixans[r - \n1\n]; \n\nelse\n\nreturn\nprefixans[r - \n1\n] - \n\nprefixans[l - \n1\n]; \n} \n\n// Driver Code \npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = \n9\n; \n\n\n// pre-computation \n\ncountIndex(a, n); \n\n\nint\nL, R; \n\n\n// 1-st query \n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println(answer_query(L, R)); \n\n\n// 2nd query \n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println(answer_query(L, R)); \n} \n} \n\n// This code is contributed by Jaideep Pyne ", "index": 771, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\tpublic static void main(String[] YAHIA_MOSTAFA) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong n = sc.nextLong(), x = sc.nextLong(), y = sc.nextLong();\n\t\tlong xb, xw, yb, yw;\n\t\txw = x - 1;\n\t\tyw = y - 1;\n\t\txb = n - x;\n\t\tyb = n - y;\n\t\tif (x == n && y == n) {\n\t\t\tSystem.out.println(\"Black\");\n\t\t\treturn;\n\t\t}\n\t\tlong c1 = 0, c2 = 0;\n\t\tlong f = Math.max(xb, yb);\n\t\tlong h = Math.max(xw, yw);\n\t\tif (h <= f)\n\t\t\tSystem.out.println(\"White\");\n\t\telse\n\t\t\tSystem.out.println(\"Black\");\n\t}\n}", "src": "import java .util.*;\nimport java .io.*;\npublic class Main{\n\tpublic static void main(String[]YAHIA_MOSTAFA){\n\t\tScanner sc =new Scanner(System.in);\n\t\tlong n=sc.nextLong(),x=sc.nextLong(),y=sc.nextLong();\n\t\tlong xb,xw,yb,yw;\n\t\txw=x-1;yw=y-1;xb=n-x;yb=n-y;\n\t\tif (x==n&&y==n){\n\t\t\tSystem.out.println(\"Black\");return;\n\t\t}\n\t\tlong c1=0,c2=0;\n\t\tlong f =Math.max(xb,yb);\n\t\tlong h =Math.max(xw,yw);\n\t\t//System.out.println(h+\" \"+f+\" \"+(h-f));\n\t\tif (h<=f)\n\t\t\tSystem.out.println(\"White\");\n\t\telse\n\t\t\tSystem.out.println(\"Black\");\n\t}\n}", "index": 772, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    Reader in = new Reader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    int a, v;\n    int l, d, w;\n\n    void run() throws IOException {\n        a = in.nextInt();\n        v = in.nextInt();\n        l = in.nextInt();\n        d = in.nextInt();\n        w = in.nextInt();\n\n        double totalTime = 0.0;\n        if (v >= w) {\n            if (w*w >= 2*a*d) {\n                double x = Math.sqrt(2*a*d);\n                totalTime = x / a;\n                if ((v*v-x*x) >= 2*a*(l-d))\n                    totalTime += (-2*x+Math.sqrt(4*x*x+8*a*(l-d))) / (2*a);\n                else\n                    totalTime += (v-x)/(1.0*a) + (l-d-(v*v-x*x)/(2.0*a))/v;\n            } else {\n//                totalTime = (-2*w+Math.sqrt(4*w*w+8*a*(l-d))) / (2*a);\n                if (2*v*v-w*w <= 2*a*d) {\n                    totalTime = v / (1.0*a) + (v-w) / (1.0*a) + (d-(2*v*v-w*w)/(2.0*a)) / v;\n                } else {\n                    double x = Math.sqrt((2*a*d+w*w)/2.0);\n                    totalTime = x / a + (x-w) / a;\n                }\n                if ((v*v-w*w) >= 2*a*(l-d))\n                    totalTime += (-2*w+Math.sqrt(4*w*w+8*a*(l-d))) / (2*a);\n                else\n                    totalTime += (v-w)/(1.0*a) + (l-d-(v*v-w*w)/(2.0*a))/v;\n            }\n        } else {\n            if (v*v >= 2*a*l)\n                totalTime = Math.sqrt(l*2.0/a);\n            else\n                totalTime = v / (1.0*a) + (l-v*v/(2.0*a)) / v;\n        }\n\n        out.printf(\"%.10f\", totalTime);\n        out.flush();\n    }\n\n    void solve() throws IOException {\n\n    }\n\n    static class Reader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public Reader(InputStream input) {\n            reader = new BufferedReader(new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        String nextToken() throws IOException {\n            while ( ! tokenizer.hasMoreTokens() ) {\n                tokenizer = new StringTokenizer( reader.readLine() );\n            }\n            return tokenizer.nextToken();\n        }\n\n        String readLine() throws IOException {\n            return reader.readLine();\n        }\n\n        char nextChar() throws IOException {\n            return (char)reader.read();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt( nextToken() );\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong( nextToken() );\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble( nextToken() );\n        }\n    }\n}\n", "src": "\nimport java.io.*;\nimport java.util.StringTokenizer;\n\n/**\n * CodeForces Round 5D. Follow Traffic Rules\n * Created by Darren on 14-9-14.\n */\npublic class Main {\n    Reader in = new Reader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    int a, v;\n    int l, d, w;\n\n    void run() throws IOException {\n        a = in.nextInt();\n        v = in.nextInt();\n        l = in.nextInt();\n        d = in.nextInt();\n        w = in.nextInt();\n\n        double totalTime = 0.0;\n        if (v >= w) {\n            if (w*w >= 2*a*d) {\n                double x = Math.sqrt(2*a*d);\n                totalTime = x / a;\n                if ((v*v-x*x) >= 2*a*(l-d))\n                    totalTime += (-2*x+Math.sqrt(4*x*x+8*a*(l-d))) / (2*a);\n                else\n                    totalTime += (v-x)/(1.0*a) + (l-d-(v*v-x*x)/(2.0*a))/v;\n            } else {\n//                totalTime = (-2*w+Math.sqrt(4*w*w+8*a*(l-d))) / (2*a);\n                if (2*v*v-w*w <= 2*a*d) {\n                    totalTime = v / (1.0*a) + (v-w) / (1.0*a) + (d-(2*v*v-w*w)/(2.0*a)) / v;\n                } else {\n                    double x = Math.sqrt((2*a*d+w*w)/2.0);\n                    totalTime = x / a + (x-w) / a;\n                }\n                if ((v*v-w*w) >= 2*a*(l-d))\n                    totalTime += (-2*w+Math.sqrt(4*w*w+8*a*(l-d))) / (2*a);\n                else\n                    totalTime += (v-w)/(1.0*a) + (l-d-(v*v-w*w)/(2.0*a))/v;\n            }\n        } else {\n            if (v*v >= 2*a*l)\n                totalTime = Math.sqrt(l*2.0/a);\n            else\n                totalTime = v / (1.0*a) + (l-v*v/(2.0*a)) / v;\n        }\n\n        out.printf(\"%.10f\", totalTime);\n        out.flush();\n    }\n\n    void solve() throws IOException {\n\n    }\n\n    static class Reader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public Reader(InputStream input) {\n            reader = new BufferedReader(new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        /** get next word */\n        String nextToken() throws IOException {\n            while ( ! tokenizer.hasMoreTokens() ) {\n                //TODO add check for eof if necessary\n                tokenizer = new StringTokenizer( reader.readLine() );\n            }\n            return tokenizer.nextToken();\n        }\n\n        String readLine() throws IOException {\n            return reader.readLine();\n        }\n\n        char nextChar() throws IOException {\n            return (char)reader.read();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt( nextToken() );\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong( nextToken() );\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble( nextToken() );\n        }\n    }\n}\n", "index": 773, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n    static StringBuilder st = new StringBuilder();\n    \n    public static void main(String[] args) throws Exception {\n\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int [] freq = new int[5];\n        \n        int k = 3;\n        while(k-- > 0) {\n            int x = sc.nextInt();\n            \n            if(x <= 4) freq[x]++;\n            \n        }\n        freq[2] += freq[4] / 2;\n        \n        if(freq[1] >= 1 || freq[2] >= 2 || freq[3] >= 3)\n            out.println(\"YES\");\n        else\n            out.println(\"NO\");\n        \n        out.flush();\n        out.close();\n\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        Scanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() throws Exception {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int nextInt() throws Exception {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws Exception {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws Exception {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n    static void shuffle(int[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int r = i + (int)(Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class C\n{\n\n\tstatic StringBuilder st = new StringBuilder();\n\t\n\tpublic static void main(String[] args) throws Exception \n\t{\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint [] freq = new int [5] ; \n\t\t\n\t\tint k = 3;  \n\t\twhile(k -- >0)\n\t\t{\n\t\t\tint x = sc.nextInt();\n\t\t\t\n\t\t\tif(x <= 4) freq[x]++;\n\t\t\t\n\t\t}\n\t\tfreq[2] += freq[4]/ 2 ;\n\t\t\n\t\tif(freq[1] >= 1 || freq[2] >= 2 || freq[3] >= 3)\n\t\t\tout.println(\"YES\");\n\t\telse\n\t\t\tout.println(\"NO\");\n\t\t\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in) \n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n}", "index": 774, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class A {\n    static FastReader scan;\n    static PrintWriter out;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        Solver solver = new Solver();\n        scan = new FastReader();\n        out = new PrintWriter(System.out);\n        int testCases = 1;\n        for (int i = 1; i <= testCases; i++) {\n            solver.solve();\n        }\n        out.close();\n    }\n\n    static class Solver {\n\n        void solve() {\n            int a = scan.nextInt(), b = scan.nextInt();\n            if (b <= a) out.println(1);\n            else out.println(b / a + Math.min(1, b % a));\n        }\n\n    }\n\n    // Sathvik's Template Stuff BELOW!!!!!!!!!!!!!!!!!!!!!!\n\n    static class DSU {\n        int[] root, size;\n        int n;\n\n        DSU(int n) {\n            this.n = n;\n            root = new int[n];\n            size = new int[n];\n            for (int i = 0; i < n; i++) {\n                root[i] = i;\n                size[i] = 1;\n            }\n        }\n\n        int findParent(int idx) {\n            while (root[idx] != idx) {\n                root[idx] = root[root[idx]];\n                idx = root[idx];\n            }\n            return idx;\n        }\n\n        boolean union(int x, int y) {\n            int parX = findParent(x);\n            int parY = findParent(y);\n            if (parX == parY)\n                return false;\n            if (size[parX] < size[parY]) {\n                root[parY] = parX;\n                size[parX] += size[parY];\n            } else {\n                root[parX] = parY;\n                size[parY] += size[parX];\n            }\n            return true;\n        }\n    }\n\n    static class Extra {\n        static void sort(int[] a) {\n            Integer[] aa = new Integer[a.length];\n            for (int i = 0; i < aa.length; i++)\n                aa[i] = a[i];\n            Arrays.sort(aa);\n            for (int i = 0; i < aa.length; i++)\n                a[i] = aa[i];\n        }\n\n        static void sort(long[] a) {\n            Long[] aa = new Long[a.length];\n            for (int i = 0; i < aa.length; i++)\n                aa[i] = a[i];\n            Arrays.sort(aa);\n            for (int i = 0; i < aa.length; i++)\n                a[i] = aa[i];\n        }\n\n        static void sort(double[] a) {\n            Double[] aa = new Double[a.length];\n            for (int i = 0; i < aa.length; i++)\n                aa[i] = a[i];\n            Arrays.sort(aa);\n            for (int i = 0; i < aa.length; i++)\n                a[i] = aa[i];\n        }\n\n        static void sort(char[] a) {\n            Character[] aa = new Character[a.length];\n            for (int i = 0; i < aa.length; i++)\n                aa[i] = a[i];\n            Arrays.sort(aa);\n            for (int i = 0; i < aa.length; i++)\n                a[i] = aa[i];\n        }\n\n        static long gcd(long a, long b) {\n            while (b > 0) {\n                long temp = b;\n                b = a % b;\n                a = temp;\n            }\n            return a;\n        }\n\n        static long lcm(long a, long b) {\n            return a * (b / gcd(a, b));\n        }\n\n        static boolean isPrime(long n) {\n            if (n <= 1)\n                return false;\n            if (n <= 3)\n                return true;\n            if (n % 2 == 0 || n % 3 == 0)\n                return false;\n            for (long i = 5; i * i <= n; i = i + 6) {\n                if (n % i == 0 || n % (i + 2) == 0)\n                    return false;\n            }\n            return true;\n        }\n\n        static HashSet<Integer> sieve(int n) {\n            boolean[] prime = new boolean[n + 1];\n            HashSet<Integer> res = new HashSet<>();\n            for (int p = 2; p * p <= n; p++) {\n                if (!prime[p]) {\n                    res.add(p);\n                    for (int i = p * p; i <= n; i += p)\n                        prime[i] = true;\n                }\n            }\n            return res;\n        }\n\n        static HashMap<Long, Integer> primeFactorization(long n) {\n            HashMap<Long, Integer> res = new HashMap<>();\n            while (n % 2 == 0) {\n                res.put(2L, res.getOrDefault(2L, 0) + 1);\n                n /= 2;\n            }\n            for (long i = 3; i * i <= n; i += 2) {\n                while (n % i == 0) {\n                    res.put(i, res.getOrDefault(i, 0) + 1);\n                    n /= i;\n                }\n            }\n            if (n > 2)\n                res.put(n, 1);\n            return res;\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws FileNotFoundException {\n            br = new BufferedReader(new FileReader(new File(s)));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        double[] nextDoubleArray(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextDouble();\n            return a;\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class A {\n\tstatic FastReader scan;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tSolver solver = new Solver();\n\t\tscan = new FastReader();\n\t\tout = new PrintWriter(System.out);\n\t\tint testCases = 1;\n\t\tfor(int i = 1; i <= testCases; i++) {\n//\t\t\tout.print(\"Case #\" + i + \": \");\n\t\t\tsolver.solve();\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic class Solver {\n\t\t\n\t\tvoid solve() {\n\t\t\tint a = scan.nextInt(), b = scan.nextInt();\n\t\t\tif(b <= a) out.println(1);\n\t\t\telse out.println(b/a + Math.min(1, b%a));\n\t\t}\n\t\t\n\t}\n\n\t// Sathvik's Template Stuff BELOW!!!!!!!!!!!!!!!!!!!!!!\n\n\tstatic class DSU {\n\t\tint[] root, size;\n\t\tint n;\n\n\t\tDSU(int n) {\n\t\t\tthis.n = n;\n\t\t\troot = new int[n];\n\t\t\tsize = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\troot[i] = i;\n\t\t\t\tsize[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tint findParent(int idx) {\n\t\t\twhile (root[idx] != idx) {\n\t\t\t\troot[idx] = root[root[idx]];\n\t\t\t\tidx = root[idx];\n\t\t\t}\n\t\t\treturn idx;\n\t\t}\n\n\t\tboolean union(int x, int y) {\n\t\t\tint parX = findParent(x);\n\t\t\tint parY = findParent(y);\n\t\t\tif (parX == parY)\n\t\t\t\treturn false;\n\t\t\tif (size[parX] < size[parY]) {\n\t\t\t\troot[parY] = parX;\n\t\t\t\tsize[parX] += size[parY];\n\t\t\t} else {\n\t\t\t\troot[parX] = parY;\n\t\t\t\tsize[parY] += size[parX];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic class Extra {\n\t\tstatic void sort(int[] a) {\n\t\t\tInteger[] aa = new Integer[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(long[] a) {\n\t\t\tLong[] aa = new Long[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(double[] a) {\n\t\t\tDouble[] aa = new Double[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(char[] a) {\n\t\t\tCharacter[] aa = new Character[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic long gcd(long a, long b) {\n\t\t\twhile (b > 0) {\n\t\t\t\tlong temp = b;\n\t\t\t\tb = a % b;\n\t\t\t\ta = temp;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n\n\t\tstatic boolean isPrime(long n) {\n\t\t\tif (n <= 1)\n\t\t\t\treturn false;\n\t\t\tif (n <= 3)\n\t\t\t\treturn true;\n\t\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\t\treturn false;\n\t\t\tfor (long i = 5; i * i <= n; i = i + 6) {\n\t\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tstatic HashSet<Integer> sieve(int n) {\n\t\t\tboolean[] prime = new boolean[n + 1];\n\t\t\tHashSet<Integer> res = new HashSet<>();\n\t\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\tif (!prime[p]) {\n\t\t\t\t\tres.add(p);\n\t\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\t\tprime[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic HashMap<Long, Integer> primeFactorization(long n) {\n\t\t\tHashMap<Long, Integer> res = new HashMap<>();\n\t\t\twhile (n % 2 == 0) {\n\t\t\t\tres.put(2L, res.getOrDefault(2L, 0) + 1);\n\t\t\t\tn /= 2;\n\t\t\t}\n\t\t\tfor (long i = 3; i * i <= n; i += 2) {\n\t\t\t\twhile (n % i == 0) {\n\t\t\t\t\tres.put(i, res.getOrDefault(i, 0) + 1);\n\t\t\t\t\tn /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n > 2)\n\t\t\t\tres.put(n, 1);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] a = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextDouble();\n\t\t\treturn a;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n}", "index": 775, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        SpeedScanner speedScanner = new SpeedScanner(new BufferedReader(new InputStreamReader(System.in)));\n        PrintWriter out = new PrintWriter(System.out);\n        taskSolver(speedScanner, out);\n        out.close();\n    }\n\n\n    public static void taskSolver(SpeedScanner speedScanner, PrintWriter out) {\n        long n = speedScanner.nextLong();\n        long m = speedScanner.nextLong();\n        long k = speedScanner.nextLong();\n        long l = speedScanner.nextLong();\n\n        long tempM ;\n\n        if ((k+l) < m){\n            out.print(n < m ? -1 : 1);\n        }else {\n            tempM = (k+l)/m;\n            out.print((k+l)%m == 0 ? (tempM*m <= n ? tempM : -1) : ((tempM+1)*m <= n ? tempM+1 : -1));\n        }\n    }\n\n\n    public static class SpeedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public SpeedScanner(BufferedReader bufferedReader) {\n            this.br = bufferedReader;\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n}\n", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        SpeedScanner speedScanner = new SpeedScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        taskSolver(speedScanner, out);\n        out.close();\n    }\n\n\n    public static void taskSolver(SpeedScanner speedScanner, PrintWriter out) {\n        long n = speedScanner.nextLong();\n        long m = speedScanner.nextLong();\n        long k = speedScanner.nextLong();\n        long l = speedScanner.nextLong();\n\n        long tempM ;\n\n        if ((k+l) < m){\n            if (n<m)\n                out.print(-1);\n            else\n                out.print(1);\n        }else {\n            tempM = (k+l)/m;\n            if ((k+l)%m == 0){\n                if (tempM*m <= n)\n                    out.print(tempM);\n                else\n                    out.print(-1);\n            }else {\n                if ((tempM+1)*m <= n)\n                    out.print(tempM+1);\n                else\n                    out.print(-1);\n            }\n        }\n    }\n\n\n    public static class SpeedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public SpeedScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n}\n", "index": 776, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class AlexAndARhombus {\n\tpublic static void main(String args[])\n\t{\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint result = n * n + (n - 1) * (n - 1);\n\t\tSystem.out.println(result);\n\t\tscanner.close();\n\t}\n\n}", "src": "import java.util.Scanner;\n\npublic class AlexAndARhombus {\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tSystem.out.println(n*n+(n-1)*(n-1));\n\t\tsc.close();\n\t}\n\n}\n", "index": 777, "complexity": 1}
{"back-translation": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class e {\n\n    static ArrayList<String> list1 = new ArrayList<>();\n    static ArrayList<ArrayList<Integer>> l = new ArrayList<>();\n\n    public static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static void combine(String instr, StringBuffer outstr, int index, int k) {\n        if (outstr.length() == k) {\n            list1.add(outstr.toString());\n            return;\n        }\n        if (outstr.toString().length() == 0)\n            outstr.append(instr.charAt(index));\n        for (int i = 0; i < instr.length(); i++) {\n            outstr.append(instr.charAt(i));\n            combine(instr, outstr, i + 1, k);\n            outstr.deleteCharAt(outstr.length() - 1);\n        }\n        index++;\n    }\n\n    static void comb(int n, int k, int ind, ArrayList<Integer> list) {\n        if (k == 0) {\n            l.add(new ArrayList<>(list));\n            return;\n        }\n\n        for (int i = ind; i <= n; i++) {\n            list.add(i);\n            comb(n, k - 1, ind + 1, list);\n            list.remove(list.size() - 1);\n        }\n    }\n\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n    public static void main(String[] args) {\n\n        FastReader in = new FastReader();\n        HashMap<Integer, Integer> map = new HashMap<>();\n\n        int n = in.nextInt();\n        int r = in.nextInt();\n\n        double theta = (double) 360 / (double) n;\n\n        double b = 1 - ((double) 2 / (double) (1 - Math.cos((double) 2 * Math.PI / (double) n)));\n        double x = Math.sqrt(1 - b) - 1;\n        double ans = (double) r / (double) x;\n\n        System.out.println(ans);\n    }\n}", "src": "\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class e {\n\npublic static class FastReader {\n\tBufferedReader br;\n\tStringTokenizer st;\n\t//it reads the data about the specified point and divide the data about it ,it is quite fast\n\t//than using direct \n\n\tpublic FastReader() {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tString next() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception r) {\n\t\t\t\tr.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());//converts string to integer\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tString nextLine() {\n\t\tString str = \"\";\n\t\ttry {\n\t\t\tstr = br.readLine();\n\t\t} catch (Exception r) {\n\t\t\tr.printStackTrace();\n\t\t}\n\t\treturn str;\n\t}\n}\nstatic ArrayList<String>list1=new ArrayList<String>();\nstatic void combine(String instr, StringBuffer outstr, int index,int k)\n{\n\tif(outstr.length()==k)\n\t{\n\t\tlist1.add(outstr.toString());return;\n\t}\n\tif(outstr.toString().length()==0)\n\toutstr.append(instr.charAt(index));\n    for (int i = 0; i < instr.length(); i++)\n    {\n        outstr.append(instr.charAt(i));\n       \n        combine(instr, outstr, i + 1,k);\n        outstr.deleteCharAt(outstr.length() - 1);\n    }\n   index++;\n} \nstatic ArrayList<ArrayList<Integer>>l=new ArrayList<>();\nstatic void comb(int n,int k,int ind,ArrayList<Integer>list)\n{\n\tif(k==0)\n\t{\n\t\tl.add(new ArrayList<>(list));\n\n\t\treturn;\n\t}\n\t\n\t\n\tfor(int i=ind;i<=n;i++)\n\t{\n\t\tlist.add(i);\n\t\tcomb(n,k-1,ind+1,list);\n\t\t\n\t\tlist.remove(list.size()-1);\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\t\n\n}\n\n\npublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\tFastReader in=new FastReader();\n\tHashMap<Integer,Integer>map=new HashMap<Integer,Integer>();\n\n\tint n=in.nextInt();\n\tint r=in.nextInt();\n\t \n\tdouble theta=(double)360/(double)n;\n\t \n\tdouble b=1-((double)2/(double)(1-Math.cos((double)2*Math.PI/(double)n)));\n\tdouble x=Math.sqrt(1-b)-1;\n\tdouble ans=(double)r/(double)x;\n\tSystem.out.println(ans);\n\n\n\n\n\n\t}\n}\n", "index": 778, "complexity": 1}
{"back-translation": "public class GFG { static int countStr(int n) { return 1 + (n * 2) + (n * ((n * n) - 1) / 2); } public static void main(String[] args) { int n = 3; System.out.println(countStr(n)); } }", "src": "\n// A O(1) Java program to \n// find number of strings \n// that can be made under \n// given constraints. \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\nstatic\nint\ncountStr(\nint\nn) \n\n{ \n\nreturn\n1\n+ (n * \n2\n) + \n\n(n * ((n * n) - \n1\n) / \n2\n); \n\n} \n\n// Driver code \npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\nn = \n3\n; \n\nSystem.out.println( countStr(n)); \n} \n} \n\n// This code is contributed by ajit ", "index": 779, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.math.BigInteger;\n \npublic class Main {\n \n    private static final FS scanner = new FS(System.in);\n\t//private static final Scanner scanner = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) throws Exception {\n\n        int n = scanner.nextInt();\n        int sumA = 0;\n        int sumB = 0;\n        int rem = n % 4;\n        int i = rem;\n        while (i >= 1) {\n            if (sumB <= sumA) {\n                sumB += i;\n            }\n            else {\n                sumA += i;\n            }\n            i--;\n        }\n\n        System.out.println(Math.abs(sumA - sumB));\n    }\n\t\n    static class FS {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FS(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n\n        public String next() throws IOException {\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n \n}", "src": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.math.BigInteger;\n \npublic class Main {\n \n    private static final FS scanner = new FS(System.in);\n\t//private static final Scanner scanner = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) throws Exception {\n\n        int n = scanner.nextInt();\n        int sumA = 0;\n        int sumB = 0;\n        int rem = n % 4;\n        for (int i = rem; i >= 1 ; i--) {\n            if (sumB <= sumA) {\n                sumB += i;\n            }\n            else {\n                sumA +=i;\n            }\n        }\n\n        System.out.println(Math.abs(sumA - sumB));\n    }\n\t\n    static class FS {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FS(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n\n        public String next() throws IOException {\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n \n}", "index": 780, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint k = input.nextInt();\n\t\tint n = input.nextInt();\n\t\tint s = input.nextInt();\n\t\tint p = input.nextInt();\n\n\t\tint each = n / s;\n\t\tif (n % s != 0)\n\t\t{\n\t\t\teach++;\n\t\t}\n\t\tint all = each * k;\n\n\t\tif (all % p == 0)\n\t\t{\n\t\t\tSystem.out.println(all / p);\n\t\t} else\n\t\t{\n\t\t\tSystem.out.println(all / p + 1);\n\t\t}\n\t}\n}", "src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint k = input.nextInt();\n\t\tint n = input.nextInt();\n\t\tint s = input.nextInt();\n\t\tint p = input.nextInt();\n\n\t\tint each = n / s;\n\t\tif (n % s != 0)\n\t\t{\n\t\t\teach++;\n\t\t}\n\t\tint all = each * k;\n\n\t\tif (all % p == 0)\n\t\t{\n\t\t\tSystem.out.println(all / p);\n\t\t} else\n\t\t{\n\t\t\tSystem.out.println(all / p + 1);\n\t\t}\n\t}\n}", "index": 781, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class BBB {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint m = Integer.parseInt(st.nextToken());\n\t\tString a = \"\";\n\t\tString b = \"\";\n\t\tfor (int i = 0; i < 1129; i++) {\n\t\t\ta += \"1\";\n\t\t\tb += \"8\";\n\t\t}\n\t\ta += \"9\";\n\t\tb += \"1\";\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(b);\n\t}\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class AAA {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\t\n\t\tint n=Integer.parseInt(st.nextToken());\n\t\tint m=Integer.parseInt(st.nextToken());\n\t\tString a=\"\";\n\t\tString b=\"\";\n\t\tfor(int i=0;i<1129;i++) {\n\t\t\ta+=\"1\";\n\t\t\tb+=\"8\";\n\t\t}\n\t\ta+=\"9\";\n\t\tb+=\"1\";\n\t\t\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(b);\n\t}\n\t\t\n}\n", "index": 782, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class cf {\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try { st = new StringTokenizer(br.readLine()); }\n            catch (IOException e) { e.printStackTrace(); }\n            return st.nextToken();\n        }\n\n        public int nextInt() { return Integer.parseInt(next()); }\n\n        public long nextLong() { return Long.parseLong(next()); }\n\n        public double nextDouble() { return Double.parseDouble(next()); }\n\n        public String nextLine() {\n            String line = \"\";\n            if (st.hasMoreTokens()) line = st.nextToken();\n            else try { return br.readLine(); }\n            catch (IOException e) { e.printStackTrace(); }\n            while (st.hasMoreTokens()) line += \" \" + st.nextToken();\n            return line;\n        }\n    }\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        pw.println(n / 2 + 1);\n        pw.close();\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class cf {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        pw.println(n/2+1);\n        pw.close();\n    }\n}", "index": 783, "complexity": 1}
{"back-translation": "import com.sun.org.apache.xalan.internal.xslt.Process;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class main {\n    public static void main(String[] args) throws IOException {\n        init();\n        int x = nextInt();\n        int y = nextInt();\n        int z = nextInt();\n        int t1 = nextInt();\n        int t2 = nextInt();\n        int t3 = nextInt();\n        int lift = Math.abs(z - x) * t2 + 2 * t3 + Math.abs(x - y) * t2 + t3;\n        int stair = Math.abs(x - y) * t1;\n        if (lift <= stair) {\n            pw.print(\"YES\");\n        } else {\n            pw.print(\"NO\");\n        }\n        pw.close();\n    }\n\n    static StringTokenizer st;\n    static BufferedReader sc;\n    static PrintWriter pw;\n\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreElements()) {\n            st = new StringTokenizer(sc.readLine());\n        }\n        return st.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static void init() throws IOException {\n        sc = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n    }\n}\n\nclass DSU {\n    int parent[];\n    public DSU(int n){\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int get(int i){\n        if (i == parent[i]){\n            return i;\n        }\n        int p = get(parent[i]);\n        parent[i] = p;\n        return p;\n    }\n\n    boolean union(int a, int b){\n        a = get(a);\n        b = get(b);\n        if (a == b) return false;\n        parent[a] = b;\n        return true;\n    }\n}", "src": "import com.sun.org.apache.xalan.internal.xslt.Process;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class main {\n    public static void main(String[] args) throws IOException {\n        init();//\"prizes.in\", \"prizes.out\");\n        int x = nextInt();\n        int y = nextInt();\n        int z = nextInt();\n        int t1 = nextInt();\n        int t2 = nextInt();\n        int t3 = nextInt();\n        int lift = Math.abs(z - x) * t2 + 2 * t3 + Math.abs(x - y) * t2 + t3;\n        int stair = Math.abs(x - y) * t1;\n        if (lift <= stair) {\n            pw.print(\"YES\");\n        } else {\n            pw.print(\"NO\");\n        }\n        pw.close();\n    }\n\n    static StringTokenizer st;\n    static BufferedReader sc;\n    static PrintWriter pw;\n\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreElements()) {\n            st = new StringTokenizer(sc.readLine());\n        }\n        return st.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static void init(String in, String out) throws IOException {\n        sc = new BufferedReader(new FileReader(in));\n        pw = new PrintWriter(out);\n    }\n\n    static void init() {\n        sc = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n    }\n}\n\nclass DSU {\n    int parent[];\n    public DSU(int n){\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int get(int i){\n        if (i == parent[i]){\n            return i;\n        }\n        int p = get(parent[i]);\n        parent[i] = p;\n        return p;\n    }\n\n    boolean union(int a, int b){\n        a = get(a);\n        b = get(b);\n        if (a == b) return false;\n        parent[a] = b;\n        return true;\n    }\n}", "index": 784, "complexity": 1}
{"back-translation": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class AlexAndARhombus {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tSystem.out.println(n * n + (n - 1) * (n - 1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class AlexAndARhombus {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tSystem.out.println(n*n+(n-1)*(n-1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 785, "complexity": 1}
{"back-translation": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class NEWCLASSNAME {\n\t\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tBigInteger m = sc.nextBigInteger();\n\t\t\t\n\t\t\tSystem.out.println(m.remainder(BigInteger.TWO.pow(n)));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "src": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class RENAMETHISBITCH {\n\t\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tBigInteger m = sc.nextBigInteger();\n\t\t\t\n\t\t\tSystem.out.println(m.mod(BigInteger.valueOf(2).pow(n)));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "index": 786, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class TokitsukazeAndEnhancement {\n    static char check(int n) {\n        if (n % 4 == 0)\n            return 'D';\n        if (n % 4 == 1)\n            return 'A';\n        if (n % 4 == 2)\n            return 'C';\n        return 'B';\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        StringTokenizer st;\n        int n = Integer.parseInt(br.readLine());\n        int a = n + 1;\n        int b = n + 2;\n        char n1 = check(n);\n        char a1 = check(a);\n        char b1 = check(b);\n        char sol = (char) Math.min(Math.min(a1, b1), n1);\n        if (sol == n1)\n            pw.println(0 + \" \" + sol);\n        else if (sol == a1)\n            pw.println(1 + \" \" + sol);\n        else if (sol == b1)\n            pw.println(2 + \" \" + sol);\n        pw.close();\n    }\n}", "src": "\nimport java.util.*;\nimport java.io.*;\n\npublic class TokitsukazeAndEnhancement {\n\t\n\tstatic char check(int n) {\n\t\tif(n%4 == 0)\n\t\t\treturn 'D';\n\t\tif(n%4 == 1)\n\t\t\treturn 'A';\n\t\tif(n%4 == 2)\n\t\t\treturn 'C';\n\t\treturn 'B';\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tStringTokenizer st;\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint a = n + 1;\n\t\tint b = n + 2;\n\t\tchar n1 = check(n);\n\t\tchar a1 = check(a);\n\t\tchar b1 = check(b);\n\t\tchar sol = (char) Math.min(Math.min(a1, b1),n1);\n\t\tif(sol == n1)\n\t\t\tpw.println(0 + \" \" + sol);\n\t\telse if(sol == a1)\n\t\t\tpw.println(1 + \" \" + sol);\n\t\telse if(sol == b1)\n\t\t\tpw.println(2 + \" \" + sol);\n\t\tpw.close();\n\t}\n}\n", "index": 787, "complexity": 1}
{"back-translation": "ERROR", "src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class bhaa {\n\n    InputStream is;\n    PrintWriter o;\n    /////////////////// CODED++ BY++ ++ ++ ++ BHAVYA++ ARORA++ ++ ++ ++ FROM++ JAYPEE++ INSTITUTE++ OF++ INFORMATION++ TECHNOLOGY++ ////////////////\n\n///////////////////////// Make it work, make it right, make it fast. Make it work, make it right, make it fast. Make it work, make it right, make it fast. Make it work, make it right, make it fast. /////////////////\n\n    boolean chpr(int n)\n    {\n    \tif(n==1)\n    \t{\n    \t\treturn true;\n    \t}if(n==2)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n==3)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n%2==0)\n    \t{\n    \t\treturn false;\n\n    \t}\n    \tif(n%3==0)\n    \t{\n    \t\treturn false;\n    \t}\n    \t\n    \tint w=2;\n \t\tint i=5;\n    \twhile(i*i<=n)\n    \t{\n    \t\tif(n%i==0)\n    \t\t{\n    \t\t\treturn false;\n    \t\t}\n    \t\ti+=w;\n    \t\tw=6-w;\n    \t}\n    \treturn true;\n\n    }\n    \n    void solve() {\n\n\n        int n=ni();\n        int k=ni();\n        int rr=2*n;\n        int gr=5*n;\n        int br=8*n;\n        o.println((long)(Math.ceil(rr*1.0/k)+Math.ceil(gr*1.0/k)+Math.ceil(br*1.0/k)));\n\n\n\n    \t\n\n    }\n\n\n\n\n\n   \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    //---------- I/O Template ----------\n    \n    public static void main(String[] args) { new bhaa().run(); }\n    void run() { \n        is = System.in; \n        o = new PrintWriter(System.out);\n        solve();\n        o.flush();\n    }\n    \n    byte input[] = new byte[1024];\n    int len = 0, ptr = 0;\n    \n    int readByte() { \n        if(ptr >= len) { ptr = 0; \n            try { len = is.read(input); } \n            catch(IOException e) { throw new InputMismatchException(); } \n            if(len <= 0) { return -1; } \n        } return input[ptr++];\n    }\n    boolean isSpaceChar(int c) { return !( c >= 33 && c <= 126 ); }\n    int skip() { \n        int b = readByte(); \n        while(b != -1 && isSpaceChar(b)) { b = readByte(); } \n        return b;\n    }\n    \n    char nc() { return (char)skip(); }\n    String ns() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while(!isSpaceChar(b)) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    String nLine() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while( !(isSpaceChar(b) && b != ' ') ) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    int ni() { \n        int n = 0, b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        if(b == -1) { return -1; }  //no input \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n    long nl() { \n        long n = 0L;    int b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n\n    double nd() { return Double.parseDouble(ns()); }\n    float nf() { return Float.parseFloat(ns()); }\n    int[] nia(int n) { \n        int a[] = new int[n]; \n        for(int i = 0; i < n; i++) { a[i] = ni(); } \n        return a;\n    }\n    long[] nla(int n) { \n        long a[] = new long[n]; \n        for(int i = 0; i < n; i++) { a[i] = nl(); } \n        return a;\n    }\n    int [][] nim(int n)\n    {\n        int mat[][]=new int[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=ni();\n            }\n        }\n        return mat;\n    }\n    long [][] nlm(int n)\n    {\n        long mat[][]=new long[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=nl();\n            }\n        }\n        return mat;\n    }\n    \n\n\n\n\n    \n    char[] ns(int n) { \n        char c[] = new char[n]; \n        int i, b = skip(); \n        for(i = 0; i < n; i++) { \n            if(isSpaceChar(b)) { break; } \n            c[i] = (char)b; b = readByte(); \n        } return i == n ? c : Arrays.copyOf(c,i);\n    }\n    void piarr(int arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    void plarr(long arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    \n    void pimat(int mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n    }\n    void plmat(long mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n\n    }\n\n\n\n\n    //////////////////////////////////// template finished //////////////////////////////////////\n\n\n\n}", "index": 788, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class A_KingEscape {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            int Qx = inp.nextInt(), Qy = inp.nextInt();\n            int Kx = inp.nextInt(), Ky = inp.nextInt();\n            int Tx = inp.nextInt(), Ty = inp.nextInt();\n            if (((Kx < Qx && Tx < Qx) || (Kx > Qx && Tx > Qx)) && ((Ky < Qy && Ty < Qy) || (Ky > Qy && Ty > Qy))) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class A_KingEscape {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            int Qx = inp.nextInt(), Qy = inp.nextInt();\n            int Kx = inp.nextInt(), Ky = inp.nextInt();\n            int Tx = inp.nextInt(), Ty = inp.nextInt();\n            if (((Kx < Qx && Tx < Qx) || (Kx > Qx && Tx > Qx)) && ((Ky < Qy && Ty < Qy) || (Ky > Qy && Ty > Qy))) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 789, "complexity": 1}
{"back-translation": "import java.io.PrintWriter;import java.io.OutputStream;import java.io.InputStream;import java.util.StringTokenizer;import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.File;import java.io.FileReader;import java.util.TreeMap;import java.util.Map;public class Main {static class Task {int INF = 2000000000;long INFINITY = 2000000000000000000L;int NN = 500005;int MOD = 1000000007;public void solve(InputReader in, PrintWriter out) {int t = in.nextInt();while(t-->0) {long n =in.nextLong();long m = in.nextLong();long x1 = in.nextLong();long y1 = in.nextLong();long x2 = in.nextLong();long y2 = in.nextLong();long x3 = in.nextLong();long y3 = in.nextLong();long x4 = in.nextLong();long y4 = in.nextLong();long w = white(1, 1, m, n);long b = black(1, 1, m, n);long whited = 0;if(x3 > x2 || x4 < x1 || y3 > y2 || y4 < y1) {whited = black(x1, y1, x2, y2);} else {whited = black(x1, y1, x2, y2);long xm1 = Math.max(x1, x3);long ym1 = Math.max(y1, y3);long xm2 = Math.min(x2, x4);long ym2 = Math.min(y2, y4);whited -= black(xm1, ym1, xm2, ym2);}b -= whited;w += whited;long blacked = white(x3, y3, x4, y4);w-= blacked;b += blacked;out.println(w + ", "src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n\npublic class Main {\n\n\tstatic class Task {\n\t\t\n\t\tint NN = 500005;\n\t\tint MOD = 1000000007;\n\t\tint INF = 2000000000;\n\t\tlong INFINITY = 2000000000000000000L;\n\t\t\n\t\tpublic void solve(InputReader in, PrintWriter out) {\n\t\t\tint t = in.nextInt();\n\t\t\twhile(t-->0) {\n\t\t\t\tlong n =in.nextLong();\n\t\t\t\tlong m = in.nextLong();\n\t\t\t\tlong x1 = in.nextLong();\n\t\t\t\tlong y1 = in.nextLong();\n\t\t\t\tlong x2 = in.nextLong();\n\t\t\t\tlong y2 = in.nextLong();\n\t\t\t\tlong x3 = in.nextLong();\n\t\t\t\tlong y3 = in.nextLong();\n\t\t\t\tlong x4 = in.nextLong();\n\t\t\t\tlong y4 = in.nextLong();\n\t\t\t\tlong w = white(1, 1, m, n);\n\t\t\t\tlong b = black(1, 1, m, n);\n\t\t\t\tlong whited = 0;\n\t\t\t\tif(x3 > x2 || x4 < x1 || y3 > y2 || y4 < y1) {\n\t\t\t\t\twhited = black(x1, y1, x2, y2);\n\t\t\t\t} else {\n\t\t\t\t\twhited = black(x1, y1, x2, y2);\n\t\t\t\t\tlong xm1 = Math.max(x1, x3);\n\t\t\t\t\tlong ym1 = Math.max(y1, y3);\n\t\t\t\t\tlong xm2 = Math.min(x2, x4);\n\t\t\t\t\tlong ym2 = Math.min(y2, y4);\n\t\t\t\t\twhited -= black(xm1, ym1, xm2, ym2);\n\t\t\t\t}\n\t\t\t\tb -= whited;w += whited;\n\t\t\t\tlong blacked = white(x3, y3, x4, y4);\n\t\t\t\tw-= blacked;b += blacked;\n\t\t\t\tout.println(w + \" \" + b);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong black(long x1, long y1, long x2, long y2) {\n\t\t\tlong dx = (x2 - x1) + 1;\n\t\t\tlong dy = (y2 - y1) + 1;\n\t\t\tif((x1+y1)%2!=0) {\n\t\t\t\treturn ((dy+1)/2)*((dx+1)/2)+(dy/2)*(dx/2);\n\t\t\t}\n\t\t\treturn ((dy+1)/2)*((dx)/2)+(dy/2)*((dx+1)/2);\n\t\t}\n\t\t\n\t\tlong white(long x1, long y1, long x2, long y2) {\n\t\t\tlong dx = (x2 - x1) + 1;\n\t\t\tlong dy = (y2 - y1) + 1;\n\t\t\tif((x1+y1)%2==0) {\n\t\t\t\treturn ((dy+1)/2)*((dx+1)/2)+(dy/2)*(dx/2);\n\t\t\t}\n\t\t\treturn ((dy+1)/2)*(dx/2)+(dy/2)*((dx+1)/2);\n\t\t}\n\t\t\n\t}\n\t\n\tstatic void prepareIO(boolean isFileIO) {\n\t\t//long t1 = System.currentTimeMillis();\n\t\tTask solver = new Task();\n\t\t// Standard IO\n\t\tif(!isFileIO) { \n\t\t\tInputStream inputStream = System.in;\n\t        OutputStream outputStream = System.out;\n\t        InputReader in = new InputReader(inputStream);\n\t        PrintWriter out = new PrintWriter(outputStream);\n\t        solver.solve(in, out);\n\t        //out.println(\"time(s): \" + (1.0*(System.currentTimeMillis()-t1))/1000.0);\n\t        out.close();\n\t\t}\n        // File IO\n\t\telse {\n\t\t\tString IPfilePath = System.getProperty(\"user.home\") + \"/Downloads/ip.in\";\n\t        String OPfilePath = System.getProperty(\"user.home\") + \"/Downloads/op.out\";\n\t        InputReader fin = new InputReader(IPfilePath);\n\t        PrintWriter fout = null;\n\t        try {\n\t\t\t\tfout = new PrintWriter(new File(OPfilePath));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t        solver.solve(fin, fout);\n\t        //fout.println(\"time(s): \" + (1.0*(System.currentTimeMillis()-t1))/1000.0);\n\t        fout.close();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n        prepareIO(false);\n\t}\n\t\n\tstatic class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        \n        public InputReader(String filePath) {\n        \tFile file = new File(filePath);\n            try {\n\t\t\t\treader = new BufferedReader(new FileReader(file));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n            tokenizer = null;\n        }\n        \n        public String nextLine() {\n        \tString str = \"\";\n        \ttry {\n\t\t\t\tstr = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n        \treturn str;\n        }\n        \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n        \treturn Double.parseDouble(next());\n        }\n        \n    }\n\n}", "index": 790, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.Math;\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = null;\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n\t\ttry {\n\t\t\tinput = br.readLine();\n\t\t\tlong n = Long.parseLong(input.split(\" \")[0]);\n\t        long k = Long.parseLong(input.split(\" \")[1]);\n\t        long red = (long) (Math.ceil((n * 2.0) / k));\n\t        long blue = Math.round((n * 5.0) / k);\n\t        long green = (long) (Math.ceil((n * 8.0) / k));\n\t        System.out.println(red + blue + green);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.Math;\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = null;\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n\t\ttry {\n\t\t\tinput = br.readLine();\n\t\t\tlong n = Long.parseLong(input.split(\" \")[0]);\n\t        long k = Long.parseLong(input.split(\" \")[1]);\n\t        long red = (long) (Math.ceil((n * 2.0)/k));\n\t        long blue = (long) (Math.ceil((n * 5.0)/k));\n\t        long green = (long) (Math.ceil((n * 8.0)/k));\n\t        System.out.println(red + blue +green);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n", "index": 791, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n\n    static long MOD = 1_000_000_000 + 7;\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        long n = Long.parseLong(st.nextToken());\n        long m = Long.parseLong(st.nextToken());\n        long k = Long.parseLong(st.nextToken());\n        long l = Long.parseLong(st.nextToken());\n\n        long p = (l + k) / m;\n\n        if ((l + k) % m != 0) {\n            p++;\n        }\n\n        if (m * p <= n) {\n            System.out.println(p);\n        } else {\n            System.out.println(-1);\n        }\n\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n\n\tstatic long MOD = 1_000_000_000 + 7;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tlong n = Long.parseLong(st.nextToken());\n\t\tlong m = Long.parseLong(st.nextToken());\n\t\tlong k = Long.parseLong(st.nextToken());\n\t\tlong l = Long.parseLong(st.nextToken());\n\n\t\tlong p = (l + k) / m;\n\n\t\tif (p * m != l + k) {\n\t\t\tp++;\n\t\t}\n\n\t\tif (m * p <= n) {\n\t\t\tSystem.out.println(p);\n\t\t} else {\n\t\t\tSystem.out.println(-1);\n\t\t}\n\n\t}\n}", "index": 793, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n//kai\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}\n \t   \t\t\t\t \t   \t\t\t \t\t  \t  \t \t \t", "index": 794, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner scan = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        int num = scan.nextInt();\n        int i = 0;\n        while (i < num) {\n            int a = scan.nextInt();\n            int b = scan.nextInt();\n            System.out.println(a + \" \" + 2 * a);\n            i++;\n        }\n    }\n}", "src": "\nimport java.util.Scanner;\n\npublic class Main {\n    static Scanner scan = new Scanner(System.in);\n\n    public static void main(String [] args){\n        int num = scan.nextInt();\n        for(int i=0;i<num;i++){\n            int a = scan.nextInt();\n            int b = scan.nextInt();\n            System.out.println(a+\" \"+2*a);\n        }\n    }\n}\n\t  \t    \t    \t\t \t  \t\t\t\t \t\t \t\t\t", "index": 795, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class KingEscape {\n\n    public static void main(String[] args) {\n        Reader read = new Reader();\n\n        int n = read.nextInt();\n        int a1 = read.nextInt();\n        int a2 = read.nextInt();\n        int b1 = read.nextInt();\n        int b2 = read.nextInt();\n        int c1 = read.nextInt();\n        int c2 = read.nextInt();\n\n        if (b1 > a1 && b2 > a2 && c1 > a1 && c2 > a2)\n            System.out.print(\"YES\");\n        else if (b1 > a1 && b2 < a2 && c1 > a1 && c2 < a2)\n            System.out.print(\"YES\");\n        else if (b1 < a1 && b2 > a2 && c1 < a1 && c2 > a2)\n            System.out.print(\"YES\");\n        else if (b1 < a1 && b2 < a2 && c1 < a1 && c2 < a2)\n            System.out.print(\"YES\");\n        else\n            System.out.print(\"NO\");\n    }\n\n    private static class Reader {\n\n        private final BufferedReader reader;\n        private final String separator;\n        private String ln;\n        private String[] tokens;\n        private int ptr;\n\n        Reader(String separator, InputStream input) {\n            this.reader = new BufferedReader(new InputStreamReader(input));\n            this.separator = separator;\n            this.ptr = -1;\n        }\n\n        Reader(String separator) {\n            this(separator, System.in);\n        }\n\n        Reader() {\n            this(\" \");\n        }\n\n        String nextStr() {\n            if (Objects.isNull(ln)) {\n                try {\n                    ln = reader.readLine();\n                } catch (IOException e) {\n                    System.out.println(e.getMessage());\n                }\n                if (Objects.nonNull(ln)) {\n                    tokens = ln.split(separator);\n                    ptr = 0;\n                } else {\n                    throw new NoSuchElementException(\"no next element\");\n                }\n\n            } else if (ptr == tokens.length) {\n                ln = null;\n                tokens = null;\n                ptr = -1;\n                return nextStr();\n            }\n\n            return tokens[ptr++];\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextStr());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextStr());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextStr());\n        }\n    }\n}", "src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class KingEscape {\n\n    public static void main(String[] args) {\n        Reader read = new Reader();\n\n        int n = read.nextInt();\n        int a1 = read.nextInt();\n        int a2 = read.nextInt();\n        int b1 = read.nextInt();\n        int b2 = read.nextInt();\n        int c1 = read.nextInt();\n        int c2 = read.nextInt();\n\n        if (b1 > a1 && b2 > a2 && c1 > a1 && c2 > a2)\n            System.out.print(\"YES\");\n        else if (b1 > a1 && b2 < a2 && c1 > a1 && c2 < a2)\n            System.out.print(\"YES\");\n        else if (b1 < a1 && b2 > a2 && c1 < a1 && c2 > a2)\n            System.out.print(\"YES\");\n        else if (b1 < a1 && b2 < a2 && c1 < a1 && c2 < a2)\n            System.out.print(\"YES\");\n        else\n            System.out.print(\"NO\");\n    }\n\n    private static class Reader {\n\n        private final BufferedReader reader;\n        private final String separator;\n        private String ln;\n        private String[] tokens;\n        private int ptr;\n\n        Reader(String separator, InputStream input) {\n            this.reader = new BufferedReader(new InputStreamReader(input));\n            this.separator = separator;\n            this.ptr = -1;\n        }\n\n        Reader(String separator) { this(separator, System.in); }\n\n        Reader() { this(\" \"); }\n\n        String nextStr(){\n            if (Objects.isNull(ln)) {\n                try {\n                    ln = reader.readLine();\n                } catch (IOException e) {\n                    System.out.println(e.getMessage());\n                }\n                if (Objects.nonNull(ln)) {\n                    tokens = ln.split(separator);\n                    ptr = 0;\n                } else {\n                    throw new NoSuchElementException(\"no next element\");\n                }\n\n            } else if (ptr == tokens.length) {\n                ln = null;\n                tokens = null;\n                ptr = -1;\n                return nextStr();\n            }\n\n            return tokens[ptr++];\n        }\n\n        int nextInt() { return Integer.parseInt(nextStr()); }\n\n        long nextLong() { return Long.parseLong(nextStr()); }\n\n        double nextDouble() { return Double.parseDouble(nextStr()); }\n    }\n}\n", "index": 796, "complexity": 1}
{"back-translation": "import java.io.*;\n\n\npublic class DS {\n\n    /*\n     * Complete the twoStacks function below.\n     */\n\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int x = Integer.parseInt(br.readLine());\n        if (x == 1) {\n            System.out.println(-1);\n        } else {\n            System.out.println(x + \" \" + x);\n        }\n\n    }\n\n\n}", "src": "import java.io.*;\n\n\npublic class DS {\n\n    /*\n     * Complete the twoStacks function below.\n     */\n   \n\n\n\n    public static void main(String[] args) throws IOException {\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       int x=Integer.parseInt(br.readLine());\n         \nif (x==1)\n            System.out.println(-1);\nelse\n            System.out.println(x+\" \"+x);\n\n        }\n\n        \n    }", "index": 797, "complexity": 1}
{"back-translation": "int x = enter.nextInt(); if (x % 4 == 0) { System.out.println(1 + \" A\"); } else if (x % 4 == 1) { System.out.println(0 + \" A\"); } else if (x % 4 == 2) { System.out.println(1 + \" B\"); } else if (x % 4 == 3) { System.out.println(2 + \" A\"); }", "src": "//package Contest573;\n\n\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class mainA {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        int x=enter.nextInt();\n        if(x%4==0){\n            System.out.println(1 +\" A\");\n        }\n        else if(x%4==1){\n            System.out.println(0+\" A\");\n        }\n        else if(x%4==2){\n            System.out.println(1+\" B\");\n        }\n        else if(x%4==3){\n            System.out.println(2+\" A\");\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}\n", "index": 798, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class Test3 {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint x = Integer.parseInt(br.readLine());\n\t\tint y = Integer.parseInt(br.readLine());\n\t\tSystem.out.print((int) (y % (Math.pow(2, x))));\n\t}\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Test3 {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tint x=Integer.parseInt(br.readLine());\n\t\tint y=Integer.parseInt(br.readLine());\n\t\tSystem.out.print((int)(y%(Math.pow(2, x))));\n\t}\n}\n", "index": 799, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class A1008 {\n    public static void main(String[] args) {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    public void solve(InputReader ir, PrintWriter pw) {\n        long n = ir.nextLong();\n        long k = ir.nextLong();\n        long l = Math.max(1, k - n);\n        long r = (k + 1) / 2;\n        l = Math.max(0, r - l);\n        pw.print(l);\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    public String[] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class A1008 {\n    public static void main(String [] args) /*throws Exception*/ {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);//new InputReader(new FileInputStream(new File(\"input.txt\")));new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);//new PrintWriter(new FileOutputStream(new File(\"output.txt\")));\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        long l = Math.max(1, k - n), r = (k + 1) / 2;\n        l = Math.max(0, r - l);\n        pw.print(l);\n\n    }\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "index": 800, "complexity": 1}
{"back-translation": "import java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.LinkedList;\n\npublic class Test {\n    static int pos = 0;\n    static int arr[];\n    static LinkedList l1 = new LinkedList();\n\n    static void find(int p, char[] x, int put[], String s) {\n        int c = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (x[p] == s.charAt(i)) {\n                c++;\n            }\n        }\n        put[p] = c;\n    }\n\n    static int mode(int m, int[] x) {\n        int temp = 0;\n        for (int i = x.length - 1; i >= 0; i--) {\n            if (x[i] <= m) {\n                temp = x[i];\n                return m - temp;\n            }\n        }\n        return m - temp;\n    }\n\n    static int mode2(int m, int[] x) {\n        int temp = 0;\n\n        for (int i = x.length - 1; i >= 0; i--) {\n            if (x[i] <= m) {\n                temp = x[i];\n                return x[i];\n            }\n        }\n        return 0;\n    }\n\n    static int find(int x[], int temp) {\n        int j = 0;\n        for (int i = x.length - 1; i >= 0; i--) {\n            if (x[i] == temp) return j + 1;\n            j++;\n        }\n        return -1;\n    }\n\n    static String ch(long[] x, long b) {\n        for (int i = 0; i < x.length; i++) {\n            if (x[i] == b) return \"YES\";\n        }\n        return \"NO\";\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int k = in.nextInt(), n = in.nextInt(), s = in.nextInt(), p = in.nextInt();\n        int paper = n / s;\n        if (n % s != 0) paper++;\n        paper *= k;\n        int fin = paper / p;\n        if (paper % p != 0) fin++;\n        System.out.println(fin);\n    }\n}", "src": "\n\nimport java.io.PrintWriter;\n\nimport java.util.*;\nimport java.util.Arrays ; \nimport java .lang.String.* ;\nimport java .lang.StringBuilder ;\n\n\npublic class Test{\n    static int pos = 0 ; \n    static int  arr[] ; \n  static LinkedList l1 = new  LinkedList() ; \nstatic void find(int p ,char[]x,int put[],String s){\n    int c= 0 ; \n    for (int i = 0; i < s.length(); i++) {\n        if(x[p]==s.charAt(i)){\n        c++ ; }\n    }\n    put[p] = c ;  \n}\nstatic int mode(int m ,int[]x ){\n    int temp = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return m-temp ; \n             \n        }\n    }\n     return m-temp ; \n}\nstatic int mode2(int m ,int[]x ){\n    int temp = 0 ; \n    \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return x[i] ; \n             \n        }\n    }\n     return 0 ; \n}\nstatic int find(int x[],int temp){\n    int j = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]==temp) return j+1 ; \n        j++ ; \n    }\n    return -1 ; \n}\nstatic String ch(long[]x,long b){\n    for (int i = 0; i < x.length; i++) {\n        if(x[i]==b)return \"YES\" ;\n    }\n    return \"NO\" ; \n}\n\n    public static void main(String[] args)  {\n\n        Scanner in = new Scanner(System.in) ;\n        PrintWriter pw = new PrintWriter(System.out);   \n     int k=in.nextInt(), n=in.nextInt(), s=in.nextInt(), p=in.nextInt() ;\n     int paper =n/s; \n     if(n%s!=0) paper++ ; \n     paper*=k ; \n     int fin = paper/p ; \n     if(paper%p!=0) fin++ ; \n        System.out.println( fin );\n       \n       \n }               \n}\n\n", "index": 801, "complexity": 1}
{"back-translation": "import java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n \n \n \npublic class HelloWorld {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Palindrome solver = new Palindrome();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class Palindrome {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long l = in.nextLong();\n            \n            if(l % 4 == 0 || l % 4 == 3) {\n                out.print(\"0\");\n            } else {\n                out.print(\"1\");\n            }\n        }\n \n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n \n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n \n \npublic class HelloWorld {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Palindrome solver = new Palindrome();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class Palindrome {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long l = in.nextLong();\n            \n            if(l%4 == 0 || l%4 == 3)\n            {\n                out.print(\"0\");\n            }\n            else\n            {\n                out.print(\"1\");\n            }\n        }\n \n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n \n    }\n}", "index": 802, "complexity": 1}
{"back-translation": "import java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class C {\n\n\tstatic StringBuilder st = new StringBuilder();\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tPoint[] square = new Point[4];\n\t\tPoint[] rotSquare = new Point[4];\n\t\t\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tsquare[i] = new Point(sc.nextInt(), sc.nextInt());\n\t\t\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\trotSquare[i] = new Point(sc.nextInt(), sc.nextInt());\n\t\t\n\t\tboolean can = false;\n\t\t\n\t\tfor (int x = -100; x <= 100; x++)\n\t\t\tfor (int y = -100; y <= 100; y++)\n\t\t\t\tcan |= inside(new Point(x, y), square) & inside(new Point(x, y), rotSquare);\n\t\t\n\t\tout.println(can ? \"YES\" : \"NO\");\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\n\tstatic int crossProduct(Point a, Point b) {\n\t\tint ans = a.x * b.y - a.y * b.x;\n\t\tif (ans < 0)\n\t\t\treturn -1;\n\t\tif (ans == 0)\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\n\tstatic boolean inside(Point a, Point[] points) {\n\t\tboolean allPos = true;\n\t\tboolean allNeg = true;\n\t\t\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint v1 = new Point(points[i].x - a.x, points[i].y - a.y);\n\t\t\tPoint v2 = new Point(points[(i + 1) % 4].x - a.x, points[(i + 1) % 4].y - a.y);\n\t\t\tallPos &= crossProduct(v1, v2) >= 0;\n\t\t\tallNeg &= crossProduct(v1, v2) <= 0;\n\t\t}\n\t\treturn allPos | allNeg;\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n}", "src": "import java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class C {\n\n\tstatic StringBuilder st = new StringBuilder();\n\n\t\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tPoint [] square = new Point [4] ; \n\t\tPoint [] rotSquare = new Point[4] ; \n\t\t\n\t\tfor(int i = 0 ; i < 4 ;i++)\n\t\t\tsquare[i] = new Point(sc.nextInt() , sc.nextInt());\n\t\t\n\t\tfor(int i = 0 ; i < 4 ;i++)\n\t\t\trotSquare[i] = new Point(sc.nextInt() , sc.nextInt());\n\t\t\n\t\tboolean can = false ; \n\t\t\n\t\tfor(int x = -100 ; x <= 100 ; x++)\n\t\t\tfor(int y = -100 ; y <= 100 ; y++)\n\t\t\t\tcan |= inside(new Point(x , y), square) & inside(new Point (x , y), rotSquare);\n\t\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tout.println(can ? \"YES\" : \"NO\");\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\tstatic int crossProduct(Point a , Point b)\n\t{\n\t\tint ans = a.x * b.y - a.y * b.x ; \n\t\t\n\t\tif(ans < 0)return -1 ;\n\t\tif(ans == 0) return 0 ;\n\t\treturn 1 ; \n\t}\n\t\n\tstatic boolean inside(Point a , Point [] points)\n\t{\n\t\tboolean allPos = true ; \n\t\tboolean allNeg = true ; \n\t\t\n\t\tfor(int i = 0 ; i < 4 ; i++)\n\t\t{\n\t\t\tPoint v1 = new Point (points[i].x - a.x , points[i].y - a.y) ; \n\t\t\tPoint v2 = new Point (points[(i + 1) % 4].x - a.x , points[(i + 1) % 4].y - a.y) ; \n\t\t\t\n\t\t\tallPos &= crossProduct(v1, v2) >= 0;\n\t\t\tallNeg &= crossProduct(v1, v2) <= 0;\n\t\t}\n\t\treturn allPos | allNeg ; \n\t\t\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n}", "index": 803, "complexity": 1}
{"back-translation": "import java.util.*; import java.io.*; public class A { public static void main(String ar[]) throws Exception { BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); String s1[]=br.readLine().split(\" \"); int n=Integer.parseInt(s1[0]); int S=Integer.parseInt(s1[1]); if(S%n==0) { System.out.println(S/n); } else { System.out.println(S/n+1); } } }", "src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int S=Integer.parseInt(s1[1]);\n            if(S%n==0)\n             System.out.println(S/n);\n            else\n             System.out.println(S/n+1);\n      }\n}", "index": 805, "complexity": 1}
{"back-translation": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tlong res1 = 2*x + y - a;\n\t\tlong res2 = y + 3*z - b;\n\t\tlong result = Math.max(res1, 0) + Math.max(res2, 0);\n\t\tSystem.out.println(result);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 807, "complexity": 1}
{"back-translation": "//package codeforces;\nimport java.util.Scanner;\npublic class ex5 {\npublic static void main(String[] args) {\nScanner scan = new Scanner(System.in);\nString S[] = new String[3];\nint m = 0, s = 0, p = 0;\nint temp = 0;\nfor (int i = 0; i < S.length; i++) {\nS[i]=scan.next();\nif (S[i].indexOf('m') != -1) m++;\nif (S[i].indexOf('s') != -1) s++;\nif (S[i].indexOf('p') != -1) p++;\n}\nint n1 = Integer.parseInt(S[0].substring(0, 1));\nint n2 = Integer.parseInt(S[1].substring(0, 1));\nint n3 = Integer.parseInt(S[2].substring(0, 1));\nint d3 = Math.abs(n1 - n2);\nint d4 = Math.abs(n1 - n3);\nint d5 = Math.abs(n2 - n3);\nif (m == 3 || s == 3 || p == 3) {\nif ((d3 == 1 & d5 == 1 & d4 == 2) || (d3 == 1 & d4 == 1 & d5 == 2) || (d5 == 1 & d4 == 1 & d3 == 2)) System.out.println(0);\nelse if ((d3 == 0 & d4 == 0) || (d4 == 0 & d5 == 0) || (d3 == 0 & d5 == 0)) System.out.println(0);\nelse if (d3 < d5 & d3 < d4) {\nif (d3 == 1 || d3 == 2 || d3 == 0) System.out.println(1);\nelse System.out.println(2);\n} else if (d5 < d4 & d5 < d3) {\nif (d5 == 1 || d5 == 2 || d5 == 0) System.out.println(1);\nelse System.out.println(2);\n} else if (d4 < d5 & d4 < d3) {\nif (d4 == 1 || d4 == 2 || d4 == 0) System.out.println(1);\nelse System.out.println(2);\n} else if ((d3 == 2 & d5 == 2) || (d4 == 2 & d5 == 2) || (d3 == 2 & d4 == 2) || (d3 == 1 & d5 == 1) || (d4 == 1 & d5 == 1) || (d3 == 2 & d4 == 1)) System.out.println(1);\nelse System.out.println(2);\n}\nif (m == 2 || s == 2 || p == 2) {\nchar c1 = S[0].charAt(1);\nchar c2 = S[1].charAt(1);\nchar c3 = S[2].charAt(1);\nif (c1 == c2) {\nif (n1 == n2) System.out.println(1);\nelse if (d3 == 1 || d3 == 2) System.out.println(1);\nelse System.out.println(2);\n}\nif (c1 == c3) {\nif (n1 == n3) System.out.println(1);\nelse if (d4 == 1 || d4 == 2) System.out.println(1);\nelse System.out.println(2);\n}\nif (c2 == c3) {\nif (n2 == n3) System.out.println(1);\nelse if (d5 == 1 || d5 == 2) System.out.println(1);\nelse System.out.println(2);\n}\n}\nif (m == 1 & s == 1 & p == 1) System.out.println(2);\n}\n}\n", "src": "//package codeforces;\nimport java.util.Scanner;\npublic class ex5 {\npublic static void main(String[] args) {\n\tScanner scan = new Scanner(System.in);\n\tString S [] = new String[3];\n\t\n\tint m=0,s=0,p=0;\n\tint temp=0;\n\t\n\tfor (int i = 0; i < S.length; i++) {\n\t\tS[i]=scan.next();\n\t\tif(S[i].indexOf('m')!=-1) m++;\n\t\tif(S[i].indexOf('s')!=-1) s++;\n\t\tif(S[i].indexOf('p')!=-1) p++;\n\t}\n\t\n\t\n\tint n1 = Integer.parseInt(S[0].substring(0,1));\n\tint n2 = Integer.parseInt(S[1].substring(0,1));\n\tint n3 = Integer.parseInt(S[2].substring(0,1));\n\t\n\t\n\t\n\t    int d3 = Math.abs(n1-n2);\n\t\tint d4 = Math.abs(n1-n3);\n\t\tint d5 = Math.abs(n2-n3);\n\t\t\n\t\n\tif(m==3||s==3||p==3) {\n\t\t\n\t\t    if(d3==1&d5==1&d4==2||d3==1&d4==1&d5==2||d5==1&d4==1&d3==2)\n\t\t\tSystem.out.println(0);\n\t\telse \n\t\t    if(d3==0&d4==0) System.out.println(0);\n\t\telse \n\t\t\tif(d3<d5&d3<d4) {\n\t\t\t    if(d3==1||d3==2||d3==0) System.out.println(1);\n\t\t        else                 System.out.println(2);\n\t\t\t    }\n\t\t\telse if (d5<d4&d5<d3){\n\t\t\t\t if(d5==1||d5==2||d5==0) System.out.println(1);\n\t\t\t\t\telse                 System.out.println(2);\n\t\t\t}\n\t\t\telse if(d4<d5&d4<d3) {\n\t\t\t\tif(d4==1||d4==2||d4==0) System.out.println(1);\n\t\t\t\telse                 System.out.println(2);\n\t\t\t}\n\t\t\telse if(d3==2&d5==2||d4==2&d5==2||d3==2&d4==2||d3==1&d5==1||d4==1&d5==1||d3==2&d4==1)\n\t\t\t\tSystem.out.println(1);\n\t\t\telse System.out.println(2);\n\t\t\t\n\t\t\t\n\t\t\n\t\t \n\t\t    \n\t\t    \n\t}\n\t\n\tif(m==2||s==2||p==2) {\n\t\t\n\t\t\n\t\t\n\t\tchar c1 = S[0].charAt(1);\n\t\tchar c2 = S[1].charAt(1);\n\t\tchar c3 = S[2].charAt(1);\n\t\t\n\t\t\n\t\tif(c1==c2) {\n\t\t\tif(n1==n2) System.out.println(1);\n\t\t\telse if(d3==1||d3==2) System.out.println(1);\n\t\t\telse System.out.println(2);\n\t\t}\n\t\tif(c1==c3) {\n\t\t\tif(n1==n3) System.out.println(1);\n\t\t\telse if(d4==1||d4==2) System.out.println(1);\n\t\t\telse System.out.println(2);\n\t\t}\n\t\tif(c2==c3) {\n\t\t\tif(n2==n3) System.out.println(1);\n\t\t\telse if(d5==1||d5==2) System.out.println(1);\n\t\t\telse System.out.println(2);\n\t\t}\n\t}\n\t\n\tif(m==1&s==1&p==1) System.out.println(2);\n\t\t\n\t\n\t\n}\n}\n", "index": 808, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nimport javax.print.attribute.standard.QueuedJobCount;\n\npublic class A {\n    static int n;\n    static TreeSet<Integer> Primes;\n    static int[] arr;\n    static int[] arr2;\n\n    public static int[] copyOf(int[] arr) {\n        int[] arr2 = new int[arr.length];\n        for (int i = 0; i < arr.length; i++)\n            arr2[i] = arr2[i] + arr[i];\n        return arr2;\n    }\n\n    public static long addEvens(int[] arr) {\n        long r = 0;\n        for (int i = 0; i < arr.length; i++)\n            if (arr[i] % 2 == 0)\n                r = r + arr[i];\n        return r;\n    }\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        arr = new int[14];\n        for (int i = 0; i < 14; i++) {\n            arr[i] = sc.nextInt();\n        }\n        int x = 5535;\n        int y = x;\n        int s;\n        long max = Integer.MIN_VALUE;\n        for (int i = 0; i < 14; i++) {\n            int a = arr[i];\n            arr2 = new int[14];\n            arr2 = copyOf(arr);\n            arr2[i] = 0;\n            int j = 0;\n            int rem = arr[i] / 14;\n            int steps = 0;\n            int c = 0;\n            for (j = i + 1; c < 14; j++) {\n                if (j >= 14)\n                    j = 0;\n                arr2[c] += rem;\n                c++;\n            }\n            steps = arr[i] % 14;\n            j = i;\n            c = 0;\n            int adasd;\n            for (j = i + 1; c < steps; j++) {\n                if (j >= 14)\n                    j = 0;\n                arr2[j] += 1;\n                c++;\n            }\n            max = Math.max(max, addEvens(arr2));\n        }\n        pw.print(max);\n\n        pw.flush();\n    }\n\n\n\n}", "src": "\timport java.io.BufferedReader;\n\t\n\timport java.io.IOException;\n\timport java.io.InputStream;\n\timport java.io.InputStreamReader;\n\timport java.io.PrintWriter;\n\timport java.util.*;\n\t\n\timport javax.print.attribute.standard.QueuedJobCount;\n\t\n\tpublic class A {\n\t\tstatic int n;\n\t\tstatic TreeSet<Integer> Primes;\n\t\tstatic int[] arr;\n\t\tstatic int[] arr2;\n\t\n\t\tpublic static int[] copyOf(int[] arr) {\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tarr2[i] += arr[i];\n\t\t\treturn arr2;\n\t\t}\n\t\n\t\tpublic static long addEvens(int[] arr) {\n\t\t\tlong r = 0;\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tif (arr[i] % 2 == 0)\n\t\t\t\t\tr += arr[i];\n\t\t\treturn r;\n\t\t}\n\t\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\tarr = new int[14];\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tarr[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint x = 5535;\n\t\t\tint y = x;\n\t\t\tint s;\n\t\t\tlong max = Integer.MIN_VALUE;\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tint a = arr[i];\n\t\t\t\tarr2 = new int[14];\n\t\t\t\tarr2 = copyOf(arr);\n\t\t\t\tarr2[i]=0;\n\t\t\t\tint j =0;\n\t\t\t\tint rem = arr[i] / 14;\n\t\t\t\tint steps = 0;\n\t\t\t\tint c = 0;\n\t\t\t\tfor (  j = i+1;c<14; j++) {\n\t\t\t\t\tif (j >=14 )\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[c] += rem;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tsteps = arr[i] % 14;\n\t\t\t\tj = i;\n\t\t\t\tc=0;\n\t\t\t\tint adasd;\n\t\t\t\tfor ( j = i+1;c<steps; j++) {\n\t\t\t\t\tif (j >= 14)\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[j] += 1;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, addEvens(arr2));\n\t\t\t}\n\t\t\tpw.print(max);\n\t\n\t\t\tpw.flush();\n\t\t}\n\t\n\t\n\t\n\t}\n", "index": 810, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class SashaAndHisTrip {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int v = in.nextInt();\n        if (v > N) {\n            System.out.println(N-1);\n        } else {\n            int price = v + (N * (N - v + 2) - v - 1) / 2;\n            int counter = 0;\n            System.out.println(price);\n        }\n    }\n}", "src": "import java.util.Scanner;\n\npublic class SashaAndHisTrip {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int v = in.nextInt();\n        if (v > N) {\n            System.out.println(N-1);\n        }\n        else {\n            int price = v + ((N-v-1) * (2+ N - v))/2;\n            int counter = 0;\n            System.out.println(price);\n        }\n    }\n}\n", "index": 811, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\npublic class Codechef{\n\t\n\n    public static void main(String []args){\n    \t\t\tScanner in = new Scanner(System.in);\n\n    long n=in.nextLong();\n\t\tlong m=in.nextLong();\n\t\tlong k=in.nextLong();\n\t\tlong l=in.nextLong();\n \n\t\tlong j=((k+l)/m);\n\t\tif((k+l)%m!=0)j++;\n\t\tif((k+l>n) || j*m>n) {\n\t\t\tSystem.out.println(-1);\n\t\t}else {\n\t\t\t\n\t\t\tSystem.out.println(j);\n\t\t}\n\n\n    }\n\n}", "src": "import java.io.*;\nimport java.util.*;\npublic class Codechef{\n\t\n\n    public static void main(String []args){\n    \t\t\tScanner in = new Scanner(System.in);\n\n    long n=in.nextLong();\n\t\tlong m=in.nextLong();\n\t\tlong k=in.nextLong();\n\t\tlong l=in.nextLong();\n \n\t\tlong j=((k+l)/m);\n\t\tif((k+l)%m!=0)j++;\n\t\tif((k+l>n) || j*m>n) {\n\t\t\tSystem.out.println(-1);\n\t\t}else {\n\t\t\t\n\t\t\tSystem.out.println(j);\n\t\t}\n\n\n    }\n\n}", "index": 812, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n    static StringBuilder data;\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt();\n        long answ = 0;\n        if (n * 2 > k) {\n            if ((n * 2) % k == 0) {\n                answ += (n * 2) / k;\n            } else {\n                answ += ((n * 2) / k) + 1;\n            }\n        } else {\n            answ++;\n        }\n        if (n * 5 > k) {\n            if ((n * 5) % k == 0) {\n                answ += (n * 5) / k;\n            } else {\n                answ += ((n * 5) / k) + 1;\n            }\n        } else {\n            answ++;\n        }\n        if (n * 8 > k) {\n            if ((n * 8) % k == 0) {\n                answ += (n * 8) / k;\n            } else {\n                answ += ((n * 8) / k) + 1;\n            }\n        } else {\n            answ++;\n        }\n\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "src": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n    static StringBuilder data;\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt();\n               long answ = 0;\n        if (n * 2 > k) {\n         if((n*2)%k==0){\n             answ+=(n*2)/k;\n         }else{\n             answ+=((n*2)/k)+1;\n         }\n        }else{\n            answ++;\n        }\n        if (n * 5 > k) {\n            if((n*5)%k==0){\n                answ+=(n*5)/k;\n            }else{\n                answ+=((n*5)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n        if (n * 8 > k) {\n            if((n*8)%k==0){\n                answ+=(n*8)/k;\n            }else{\n                answ+=((n*8)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 815, "complexity": 1}
{"back-translation": "public class Ideone {\n    public static void main(String[] args) throws java.lang.Exception {\n        long n, s, p;\n        Scanner in = new Scanner(System.in);\n        n = in.nextLong();\n        s = in.nextLong();\n        if (n == 1 && s <= 1) {\n            System.out.print(n - 1);\n        } else if (s < n) {\n            if (s % 2 != 0) {\n                System.out.print(s / 2);\n            } else {\n                System.out.print(s / 2 - 1);\n            }\n        } else if (s == n) {\n            if (s % 2 == 0) {\n                System.out.println((n / 2) - 1);\n            } else {\n                System.out.println(n / 2);\n            }\n        } else if (s <= (2 * n - 1)) {\n            System.out.print((2 * n + 1 - s) / 2);\n        } else {\n            System.out.print(0);\n        }\n    }\n}", "src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\t\tlong n,s,p;\n\t\t\tScanner in=new Scanner(System.in);\n\t\t\tn=in.nextLong();\n\t\t\ts=in.nextLong();\n\t\t\tif(n==1 && s<=1)\n\t\t\t{\n\t\t\t    System.out.print(n-1);\n\t\t\t}\n\t        else if(s<n)\n\t        {\n\t            if(s%2!=0)\n\t\t        {System.out.print(s/2);}\n\t\t        else\n\t\t        {System.out.print(s/2-1);}\n\t        }\n\t        else if(s==n)\n\t{\n\t    if(s%2==0)\n\t\t{System.out.println((n/2)-1);}\n\t\telse\n\t\t{System.out.println(n/2);}\n\t}\n\telse if(s<=(2*n-1))\t\n\t{\n\t\tSystem.out.print((2*n+1-s)/2);\n\t}\n\telse\n\t{\n\t\tSystem.out.print(0);\n\t}\n\t}\n}", "index": 817, "complexity": 1}
{"back-translation": "import java.util.*;\n\npublic class helloWorld {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint a = in.nextInt();\n\t\tint b = in.nextInt();\n\t\tint c = in.nextInt();\n\t\tint n = in.nextInt();\n\n\t\tint ans = n - (a + b - c);\n\t\tif(ans < 1 || a >= n || b >= n || c > a || c > b) {\n\t\t\tans = -1;\n\t\t}\n\n\t\tSystem.out.println(ans);\n\n\t\tin.close();\n\t}\n}", "src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint a = in.nextInt();\n\t\tint b = in.nextInt();\n\t\tint c = in.nextInt();\n\t\tint n = in.nextInt();\n\n\t\tint ans = n - (a + b - c);\n\t\tif(ans < 1 || a >= n || b >= n || c > a || c > b)\n\t\t\tans = -1;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 819, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class PizzaPizzaPizza {\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n    public static StringTokenizer st;\n    \n    public static void main(String[] args) throws IOException {\n        long n = nextLong();\n        if (n == 0)\n            System.out.println(0);\n        else if (n % 2 == 0)\n            System.out.println(n + 1);\n        else\n            System.out.println((n + 1) / 2);\n    }\n    \n    public static String nextLine() throws IOException {\n        return in.readLine();\n    }\n\n    public static String nextString() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(in.readLine());\n        return st.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(nextString());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(nextString());\n    }\n\n    public static int[] intArray(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextInt();\n        return a;\n    }\n\n    public static int[][] intArray(int n, int m) throws IOException {\n        int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                a[i][j] = nextInt();\n        return a;\n    }\n\n    public static long[] longArray(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextLong();\n        return a;\n    }\n}", "src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class PizzaPizzaPizza {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong n = nextLong();\n\t\tif (n == 0)\n\t\t\tSystem.out.println(0);\n\t\telse if (n % 2 == 0)\n\t\t\tSystem.out.println(n+1);\n\t\telse\n\t\t\tSystem.out.println((n+1)/2);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 820, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class DS {\n\n    /*\n     * Complete the twoStacks function below.\n     */\n   \n\n\n\n    public static void main(String[] args) throws IOException {\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       int x=Integer.parseInt(br.readLine());\n         \nif (x==1)\n            System.out.println(-1);\nelse\n            System.out.println(x+\" \"+x);\n\n        }\n\n        \n    }", "src": "import java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class DS {\n\n    /*\n     * Complete the twoStacks function below.\n     */\n   \n\n\n\n    public static void main(String[] args) throws IOException {\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       int x=Integer.parseInt(br.readLine());\n         \nif (x==1)\n            System.out.println(-1);\nelse\n            System.out.println(x+\" \"+x);\n\n        }\n\n        \n    }", "index": 821, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class Origami {\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tdouble n = input.nextInt();\n\t\tdouble k = input.nextInt();\n\t\tdouble red = 0.0;\n\t\tdouble green = 0.0;\n\t\tdouble blue = 0.0;\n\t\tdouble ans = 0.0;\n\t\tred = (2.0 * n) / k;\n\t\tgreen = (5.0 * n) / k;\n\t\tblue = (8.0 * n) / k;\n\t\tdouble red1 = Math.ceil(red);\n\t\tdouble green1 = Math.ceil(green);\n\t\tdouble blue1 = Math.ceil(blue);\n\t\tans += red1;\n\t\tans += green1;\n\t\tans += blue1;\n\t\tDouble answer = new Double(ans);\n\t\tint finished = answer.intValue();\n\t\tSystem.out.println(finished);\n\t}\n}", "src": "\nimport java.util.Scanner;\n\npublic class origami {\n\tpublic static void main(String args[]){\n\t\tScanner input = new Scanner(System.in);\n\t\tdouble n = input.nextInt();\n\t\tdouble k = input.nextInt();\n\t\tdouble red = 0;\n\t\tdouble green = 0;\n\t\tdouble blue = 0;\n\t\tdouble ans = 0;\n\t\tred = (2 * n) / k;\n\t\tgreen = (5 * n) / k;\n\t\tblue = (8 * n) / k;\n\n\t\tdouble red1 = Math.ceil(red) ;\n\t\tdouble green1 = Math.ceil(green);\n\t\tdouble blue1 = Math.ceil(blue);\n\n\t\tans+=red1;\n\t\tans+=green1;\n\t\tans+=blue1;\n\t\tDouble answer = new Double(ans);\n\t\tint finished = answer.intValue();\n\t\tSystem.out.println(finished);\n\t}\n}\n", "index": 823, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class C_NNAndTheOpticalIllusion {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            double n = inp.nextInt(), r = inp.nextInt();\n            double x = Math.cos((n - 2) * Math.PI / (2 * n));\n            out.print((r * x) / (1 - x));\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class C_NNAndTheOpticalIllusion {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            double n = inp.nextInt(), r = inp.nextInt();\n            double x = Math.cos((n - 2) * Math.PI / (2 * n));\n            out.print((r * x) / (1 - x));\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 824, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = null;\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tString input;\n\t\ttry {\n\t\t\tinput = br.readLine();\n\t\t\tint n = Integer.parseInt(input);\n\t\t\tinput = br.readLine();\n\t\t\tint qx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint qy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint kx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint ky = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint gx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint gy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tif((kx<qx && gx<qx) || (kx>qx && gx>qx)) {\n\t\t\t\tif((ky<qy && gy<qy) || (ky>qy && gy>qy))\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}else\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = null;\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n\t\ttry {\n\t\t\tinput = br.readLine();\n\t\t\tint n = Integer.parseInt(input);\n\t\t\tinput = br.readLine();\n\t\t\tint qx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint qy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint kx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint ky = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint gx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint gy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tif((kx<qx && gx<qx)||(kx>qx && gx>qx)) {\n\t\t\t\tif((ky<qy && gy<qy)||(ky>qy && gy>qy))System.out.println(\"YES\");\n\t\t\t\telse System.out.println(\"NO\");\n\t\t\t}else System.out.println(\"NO\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n", "index": 825, "complexity": 1}
{"back-translation": "import java.io.OutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.io.PrintWriter; import java.io.BufferedWriter; import java.io.Writer; import java.io.OutputStreamWriter; import java.util.InputMismatchException; import java.io.IOException; import java.io.InputStream; public class Main { public static void main(String[] args) { InputStream inputStream = System.in; OutputStream outputStream = System.out; InputReader in = new InputReader(inputStream); OutputWriter out = new OutputWriter(outputStream); KingEscape solver = new KingEscape(); solver.solve(1, in, out); out.close(); } static class KingEscape { public void solve(int testNumber, InputReader in, OutputWriter out) { int n = in.nextInt(); int qx = in.nextInt(); int qy = in.nextInt(); int kx = in.nextInt(); int ky = in.nextInt(); int safex = in.nextInt(); int safey = in.nextInt(); boolean possible = false; if ((qx > Math.max(kx, safex)) || (qx < Math.min(kx, safex))) { if ((qy > Math.max(ky, safey)) || (qy < Math.min(ky, safey))) { possible = true; } } if (possible) out.println(\"YES\"); else out.println(\"NO\"); } } static class OutputWriter { private final PrintWriter writer; public OutputWriter(OutputStream outputStream) { writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream))); } public OutputWriter(Writer writer) { this.writer = new PrintWriter(writer); } public void print(Object... objects) { for (int i = 0; i < objects.length; i++) { if (i != 0) { writer.print(' '); } writer.print(objects[i]); } } public void println(Object... objects) { print(objects); writer.println(); } public void close() { writer.close(); } } static class InputReader { private InputStream stream; private byte[] buf = new byte[1024]; private int curChar; private int numChars; private InputReader.SpaceCharFilter filter; public InputReader(InputStream stream) { this.stream = stream; } public int read() { if (numChars == -1) { throw new InputMismatchException(); } if (curChar >= numChars) { curChar = 0; try { numChars = stream.read(buf); } catch (IOException e) { throw new InputMismatchException(); } if (numChars <= 0) { return -1; } } return buf[curChar++]; } public int nextInt() { int c = read(); while (isSpaceChar(c)) { c = read(); } int sgn = 1; if (c == '-') { sgn = -1; c = read(); } int res = 0; do { if ((c < '0') || (c > '9')) { throw new InputMismatchException(); } res *= 10; res += c - '0'; c = read(); } while (!(isSpaceChar(c))); return res * sgn; } public boolean isSpaceChar(int c) { if (filter != null) { return filter.isSpaceChar(c); } return isWhitespace(c); } public static boolean isWhitespace(int c) { return ((c == ' ') || (c == '\\n') || (c == '\\r') || (c == '\\t') || (c == -1)); } public interface SpaceCharFilter { public boolean isSpaceChar(int ch); } } }", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author fintech\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        KingEscape solver = new KingEscape();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class KingEscape {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int qx = in.nextInt();\n            int qy = in.nextInt();\n            int kx = in.nextInt();\n            int ky = in.nextInt();\n            int safex = in.nextInt();\n            int safey = in.nextInt();\n            boolean possible = false;\n            if (qx > Math.max(kx, safex) || qx < Math.min(kx, safex)) {\n                if (qy > Math.max(ky, safey) || qy < Math.min(ky, safey)) {\n                    possible = true;\n                }\n            }\n            if (possible) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "index": 826, "complexity": 1}
{"back-translation": "import java.util.Scanner;import java.util.Arrays;import java.io.IOException;public class Main {static Scanner sc = new Scanner(System.in);public static char returnLetter(int n) {if(n%4==1) {return 'A';}else if(n%4==3) {return 'B';}else if(n%4==2) {return 'C';}else {return 'D';}}public static void main(String[] args) throws IOException {String[] a = new String[3];for (int i = 0; i < a.length; i++) {a[i] = sc.next();}boolean equal = true;for (int i = 1; i < a.length; i++) {if(a[i].charAt(1) != a[i - 1].charAt(1) || a[i].charAt(0) != a[i - 1].charAt(0)) {equal = false;break;}}if(equal) {System.out.println(0);}else {Arrays.sort(a);boolean ord = true;for (int i = 1; i < a.length; i++) {if(a[i].charAt(1) != a[i - 1].charAt(1) || a[i].charAt(0) - a[i - 1].charAt(0) != 1) {ord = false;break;}}if(ord) {System.out.println(0);}else {if(a[1].charAt(1) == a[0].charAt(1) && a[1].charAt(0) - a[0].charAt(0) == 2) {System.out.println(1);}else if(a[2].charAt(1) == a[1].charAt(1) && a[2].charAt(0) - a[1].charAt(0) == 2) {System.out.println(1);}else if(a[2].charAt(1) == a[0].charAt(1) && a[2].charAt(0) - a[0].charAt(0) == 2) {System.out.println(1);}else if(a[0].charAt(1) == a[1].charAt(1) && a[0].charAt(0) - a[1].charAt(0) == 2) {System.out.println(1);}else if(a[1].charAt(1) == a[2].charAt(1) && a[1].charAt(0) - a[2].charAt(0) == 2) {System.out.println(1);}else if(a[0].charAt(1) == a[2].charAt(1) && a[0].charAt(0) - a[2].charAt(0) == 2) {System.out.println(1);}else if(a[1].charAt(1) == a[0].charAt(1) && a[1].charAt(0) == a[0].charAt(0)) {System.out.println(1);}else if(a[2].charAt(1) == a[1].charAt(1) && a[1].charAt(0) == a[2].charAt(0)) {System.out.println(1);}else {System.out.println(2);}}}}}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static char returnLetter(int n)\n\t{\n\t\tif(n%4==1)\n\t\t{\n\t\t\treturn 'A';\n\t\t}\n\t\telse if(n%4==3)\n\t\t{\n\t\t\treturn 'B';\n\t\t}\n\t\telse if(n%4==2)\n\t\t{\n\t\t\treturn 'C';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'D';\n\t\t}\n\t}\n\t/*public static void main(String[] args) throws IOException {\n\t\tint n=sc.nextInt();\n\t\t\n\t\tint zero=n;\n\t\tint one=n+1;\n\t\tint two=n+2;\n\t\tchar z=returnLetter(zero);\n\t\tchar o=returnLetter(one);\n\t\tchar t=returnLetter(two);\n\t\t\n\t\tif(z<o && z<t)\n\t\t{\n\t\t\tSystem.out.println(\"0 \" + z);\n\t\t}\n\t\telse if(o<z && o<t)\n\t\t{\n\t\t\tSystem.out.println(\"1 \" + o);\n\t\t}\n\t\telse if(t<z && o>t)\n\t\t{\n\t\t\tSystem.out.println(\"2 \" + t);\n\t\t}\n\t}*/\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tString[] a= new String[3];\n\t\t\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i]=sc.next();\n\t\t}\n\t\tboolean equal=true;\n\t\t\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)!=a[i-1].charAt(0))\n\t\t\t{\n\t\t\t\tequal=false;break;\n\t\t\t}\n\t\t}\n\t\tif(equal)\n\t\t{\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tArrays.sort(a);\n\t\t\tboolean ord=true;\n\t\t\t\n\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)-a[i-1].charAt(0)!=1)\n\t\t\t\t{\n\t\t\t\t\tord=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord)\n\t\t\t{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)==a[0].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[1].charAt(0)==a[2].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tint start = 0;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t}\n}\n", "index": 827, "complexity": 1}
{"back-translation": "import java.util.*; class GfG { static class StackWithMax { static Stack<Integer> mainStack = new Stack<Integer>(); static Stack<Integer> trackStack = new Stack<Integer>(); static void push(int x) { mainStack.push(x); if (mainStack.size() == 1) { trackStack.push(x); return; } if (x > trackStack.peek()) trackStack.push(x); else trackStack.push(trackStack.peek()); } static int getMax() { return trackStack.peek(); } static void pop() { mainStack.pop(); trackStack.pop(); } }; public static void main(String[] args) { StackWithMax s = new StackWithMax(); s.push(20); System.out.println(s.getMax()); s.push(10); System.out.println(s.getMax()); s.push(50); System.out.println(s.getMax()); } }", "src": "\n// Java program to keep track of maximum \n// element in a stack \nimport\njava.util.*; \nclass\nGfG { \n\nstatic\nclass\nStackWithMax \n{ \n\n// main stack \n\nstatic\nStack<Integer> mainStack = \nnew\nStack<Integer> (); \n\n\n// tack to keep track of max element \n\nstatic\nStack<Integer> trackStack = \nnew\nStack<Integer> (); \n\nstatic\nvoid\npush(\nint\nx) \n\n{ \n\nmainStack.push(x); \n\nif\n(mainStack.size() == \n1\n) \n\n{ \n\ntrackStack.push(x); \n\nreturn\n; \n\n} \n\n\n// If current element is greater than \n\n// the top element of track stack, push \n\n// the current element to track stack \n\n// otherwise push the element at top of \n\n// track stack again into it. \n\nif\n(x > trackStack.peek()) \n\ntrackStack.push(x); \n\nelse\n\ntrackStack.push(trackStack.peek()); \n\n} \n\n\nstatic\nint\ngetMax() \n\n{ \n\nreturn\ntrackStack.peek(); \n\n} \n\n\nstatic\nvoid\npop() \n\n{ \n\nmainStack.pop(); \n\ntrackStack.pop(); \n\n} \n}; \n\n// Driver program to test above functions \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nStackWithMax s = \nnew\nStackWithMax(); \n\ns.push(\n20\n); \n\nSystem.out.println(s.getMax()); \n\ns.push(\n10\n); \n\nSystem.out.println(s.getMax()); \n\ns.push(\n50\n); \n\nSystem.out.println(s.getMax()); \n} \n} ", "index": 828, "complexity": 1}
{"back-translation": "class GFG { static int count(int n) { if (n < 4) return -1; int rem = n % 4; if (rem == 0) return n / 4; if (rem == 1) { if (n < 9) return -1; return (n - 9) / 4 + 1; } if (rem == 2) return (n - 6) / 4 + 1; if (rem == 3) { if (n < 15) return -1; return (n - 15) / 4 + 2; } return 0; } public static void main(String[] args) { int n = 90; System.out.println(count(n)); n = 143; System.out.println(count(n)); } }", "src": "\n// Java program to split a number into maximum \n// number of composite numbers. \nimport\njava.io.*; \n\nclass\nGFG \n{ \n\n// function to calculate the maximum number of \n\n// composite numbers adding upto n \n\nstatic\nint\ncount(\nint\nn) \n\n{ \n\n// 4 is the smallest composite number \n\nif\n(n < \n4\n) \n\nreturn\n-\n1\n; \n\n\n// stores the remainder when n is divided \n\n// by 4 \n\nint\nrem = n % \n4\n; \n\n\n// if remainder is 0, then it is perfectly \n\n// divisible by 4. \n\nif\n(rem == \n0\n) \n\nreturn\nn / \n4\n; \n\n\n// if the remainder is 1 \n\nif\n(rem == \n1\n) { \n\n\n// If the number is less then 9, that \n\n// is 5, then it cannot be expressed as \n\n// 4 is the only composite number less \n\n// than 5 \n\nif\n(n < \n9\n) \n\nreturn\n-\n1\n; \n\n\n// If the number is greater then 8, and \n\n// has a remainder of 1, then express n \n\n// as n-9 a and it is perfectly divisible \n\n// by 4 and for 9, count 1. \n\nreturn\n(n - \n9\n) / \n4\n+ \n1\n; \n\n} \n\n\n\n// When remainder is 2, just subtract 6 from n, \n\n// so that n is perfectly divisible by 4 and \n\n// count 1 for 6 which is subtracted. \n\nif\n(rem == \n2\n) \n\nreturn\n(n - \n6\n) / \n4\n+ \n1\n; \n\n\n\n// if the number is 7, 11 which cannot be \n\n// expressed as sum of any composite numbers \n\nif\n(rem == \n3\n) \n\n{ \n\nif\n(n < \n15\n) \n\nreturn\n-\n1\n; \n\n\n// when the remainder is 3, then subtract \n\n// 15 from it and n becomes perfectly \n\n// divisible by 4 and we add 2 for 9 and 6, \n\n// which is getting subtracted to make n \n\n// perfectly divisible by 4. \n\nreturn\n(n - \n15\n) / \n4\n+ \n2\n; \n\n} \n\nreturn\n0\n; \n\n} \n\n\n// Driver program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n90\n; \n\nSystem.out.println(count(n)); \n\n\nn = \n143\n; \n\nSystem.out.println(count(n)); \n\n} \n} \n\n// This code is contributed by vt_m. ", "index": 829, "complexity": 1}
{"back-translation": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class reversed_simple extends ReversedRunnable {\n    public void run()\n    {\n        ReversedInputReader input = new ReversedInputReader(System.in);\n        ReversedPrintWriter w = new ReversedPrintWriter(System.out);\n        int n = input.nextInt();\n\n        System.out.println((2*n*n)-(2*n)+1);\n        }\n    }\n\nclass reversed_Graph {\n    private final int v;\n    private List<List<Integer>> adj;\n    Graph(int v){\n        this.v = v;\n        adj = new ArrayList<>(v);\n        for(int i=0;i<v;i++){\n            adj.add(new LinkedList<>());\n        }\n    }\n    private void addEdge(int a,int b){\n        adj.get(a).add(b);\n    }\n    private boolean isCyclic(){\n        boolean[] visited = new boolean[v];\n        boolean[] recStack = new boolean[v];\n        for (int i = 0; i < v; i++)\n            if (isCyclicUtil(i, visited, recStack))\n                return true;\n\n        return false;\n    }\n    private boolean isCyclicUtil(int i, boolean[] visited, boolean[] recStack)\n    {\n        if (recStack[i])\n            return true;\n        if (visited[i])\n            return false;\n        visited[i] = true;\n        recStack[i] = true;\n        List<Integer> children = adj.get(i);\n        for (Integer c: children)\n            if (isCyclicUtil(c, visited, recStack))\n                return true;\n        recStack[i] = false;\n        return false;\n    }\n}\npublic static void reversed_sortbyColumn(int arr[][], int col)\n{\n\n    Arrays.sort(arr, new Comparator<int[]>()\n    {\n        public int compare(int[] o1, int[] o2){\n            return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n        }\n    });\n\n}\nstatic long reversed_gcd(long a, long b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\npublic static class reversed_DJSet {\n    public int[] upper;\n\n    public reversed_DJSet(int n) {\n        upper = new int[n];\n        Arrays.fill(upper, -1);\n    }\n\n    public int root(int x) {\n        return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n    }\n\n    public boolean equiv(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    public boolean union(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x != y) {\n            if (upper[y] < upper[x]) {\n                int d = x;\n                x = y;\n                y = d;\n            }\n            upper[x] += upper[y];\n            upper[y] = x;\n        }\n        return x == y;\n    }\n}\npublic static int[] reversed_radixSort(int[] f)\n{\n    int[] to = new int[f.length];\n    {\n        int[] b = new int[65537];\n        for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n        for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n        for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n        int[] d = f; f = to;to = d;\n    }\n    {\n        int[] b = new int[65537];\n        for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n        for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n        for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n        int[] d = f; f = to;to = d;\n    }\n    return f;\n}\nstatic class reversed_InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n    private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    public reversed_InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n    public int read() {\n        if (numChars==-1)\n            throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n        if(numChars <= 0)\n            return -1;\n        }\n        return buf[curChar++];\n    }\n    public int nextInt() {\n        int c = read();\n\n        while(isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n\n        if (c == \\\\'-\\\\') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if(c<\\\\'0\\\\'||c>\\\\'9\\\\')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - \\\\'0\\\\';\n            c = read();\n        }\n        while (!isSpaceChar(c));\n        return res * sgn;\n    }\n    public long nextLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == \\\\'-\\\\') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < \\\\'0\\\\' || c > \\\\'9\\\\')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - \\\\'0\\\\';\n            c = read();\n        }\n        while (!isSpaceChar(c));\n        return res * sgn;\n    }\n    public double nextDouble() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == \\\\'-\\\\') {\n            sgn = -1;\n            c = read();\n        }\n        double res = 0;\n        while (!isSpaceChar(c) && c != \\\\'\\\\.\\\\') {\n            if (c == \\\\'e\\\\' || c == \\\\'E\\\\')\n                return res * Math.pow(10, nextInt());\n            if (c < \\\\'0\\\\' || c > \\\\'9\\\\')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - \\\\'0\\\\';\n            c = read();\n        }\n        if (c == \\\\'\\\\.\\\\') {\n            c = read();\n            double m = 1;\n            while (!isSpaceChar(c)) {\n                if (c == \\\\'e\\\\' || c == \\\\'E\\\\')\n                    return res * Math.pow(10, nextInt());\n                if (c < \\\\'0\\\\' || c > \\\\'9\\\\')\n                    throw new InputMismatchException();\n                m /= 10;\n                res += (c - \\\\'0\\\\') * m;\n                c = read();\n            }\n        }\n        return res * sgn;\n    }\n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        }\n        while (!isSpaceChar(c));\n\n        return res.toString();\n    }\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == \\\\' \\\\' || c == \\\\'\\\\n\\\\' || c == \\\\'\\\\r\\\\' || c == \\\\'\\\\t\\\\' || c == -1;\n    }\n    public String next() {\n        return readString();\n    }\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\npublic static void main(String args[]) throws Exception {\n    new Thread(null, new reversed_simple(),\\\\\"TaskA\\\\\",1<<26).start();\n}\n}", "src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class simple implements Runnable {\n\n\n    public void run()\n    {\n\n        InputReader input = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = input.nextInt();\n\n            System.out.println((2*n*n)-(2*n)+1);\n    }\n\n\n\n    class Graph{\n        private final int v;\n        private List<List<Integer>> adj;\n        Graph(int v){\n            this.v = v;\n            adj = new ArrayList<>(v);\n            for(int i=0;i<v;i++){\n                adj.add(new LinkedList<>());\n            }\n        }\n        private void addEdge(int a,int b){\n            adj.get(a).add(b);\n        }\n        private boolean isCyclic()\n        {\n            boolean[] visited = new boolean[v];\n            boolean[] recStack = new boolean[v];\n            for (int i = 0; i < v; i++)\n                if (isCyclicUtil(i, visited, recStack))\n                    return true;\n\n            return false;\n        }\n        private boolean isCyclicUtil(int i, boolean[] visited, boolean[] recStack)\n        {\n            if (recStack[i])\n                return true;\n            if (visited[i])\n                return false;\n            visited[i] = true;\n            recStack[i] = true;\n            List<Integer> children = adj.get(i);\n            for (Integer c: children)\n                if (isCyclicUtil(c, visited, recStack))\n                    return true;\n            recStack[i] = false;\n            return false;\n        }\n    }\n    public static void sortbyColumn(int arr[][], int col)\n    {\n\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static class DJSet {\n        public int[] upper;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f)\n    {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new simple(),\"TaskA\",1<<26).start();\n    }\n}", "index": 830, "complexity": 1}
{"back-translation": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class problem2 {\n    static class tile implements Comparable<tile> {\n        int number;\n        int suit;\n\n        public int compareTo(tile b) {\n\n            return number - b.number;\n        }\n\n    }\n    public static void main(String[] args) {\n\n\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] parts = line.split(\" \");\n\n        tile[] tiles = new tile[3];\n        for (int i = 0; i < 3; i++) {\n\n            tiles[i] = new tile();\n            tiles[i].number = Character.getNumericValue(parts[i].charAt(0));\n            if (parts[i].substring(1, 2).equals(\"s\")) tiles[i].suit = 1;\n            if (parts[i].substring(1, 2).equals(\"m\")) tiles[i].suit = 2;\n            if (parts[i].substring(1, 2).equals(\"p\")) tiles[i].suit = 3;\n            //System.out.println(tiles[i].number + \" \" + tiles[i].suit);\n        }\n        Arrays.sort(tiles);\n\n        int[][] tilesObtained = new int[10][4];\n        int[][] stairCases = new int[10][4];\n        int[][] stairCases2 = new int[10][4];\n        for (int i = 0; i < 3; i++) {\n            int currNumber = tiles[i].number;\n            int currSuit = tiles[i].suit;\n\n            tilesObtained[currNumber][currSuit]++;\n            stairCases[currNumber][currSuit] = 1 + stairCases[currNumber - 1][currSuit];\n            if (currNumber != 1) {\n                if (stairCases2[currNumber - 2][currSuit] != 0) {\n                    stairCases2[currNumber][currSuit] = 2;\n                } else {\n                    stairCases2[currNumber][currSuit] = 1;\n                }\n            } else {\n                stairCases2[currNumber][currSuit]++;\n            }\n\n\n        }\n        int best = 3;\n\n        for (int i = 1; i <= 9; i++) {\n\n            for (int j = 1; j <= 3; j++) {\n\n                best = Math.min(best, 3 - tilesObtained[i][j]);\n                best = Math.min(best, 3 - stairCases[i][j]);\n                best = Math.min(best, 3 - stairCases2[i][j]);\n                if (best < 0) best = 0;\n            }\n        }\n        System.out.println(best);\n\n\n    }\n}", "src": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class problem2 {\n    static class tile implements Comparable<tile> {\n        int number;\n        int suit;\n\n        public int compareTo(tile b){\n\n            return number - b.number;\n        }\n\n    }\n    public static void main(String[] args) {\n\n\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] parts = line.split(\" \");\n\n        tile[] tiles = new tile[3];\n        for(int i = 0; i < 3; i++){\n\n            tiles[i] = new tile();\n            tiles[i].number = parts[i].charAt(0) - '0';\n            if(parts[i].substring(1,2).equals(\"s\"))tiles[i].suit = 1;\n            if(parts[i].substring(1,2).equals(\"m\"))tiles[i].suit = 2;\n            if(parts[i].substring(1,2).equals(\"p\"))tiles[i].suit = 3;\n            //System.out.println(tiles[i].number + \" \"+ tiles[i].suit);\n        }\n        Arrays.sort(tiles);\n\n        int[][] tilesObtained = new int[10][4];\n        int[][] stairCases = new int[10][4];\n        int[][] stairCases2 = new int[10][4];\n        for(int i = 0; i < 3; i++){\n            int currNumber = tiles[i].number;\n            int currSuit = tiles[i].suit;\n\n            tilesObtained[currNumber][currSuit]++;\n            stairCases[currNumber][currSuit] = 1 + stairCases[currNumber-1][currSuit];\n            if(currNumber != 1){\n                if(stairCases2[currNumber-2][currSuit] != 0){\n                    stairCases2[currNumber][currSuit] = 2;\n                }\n                else{\n                    stairCases2[currNumber][currSuit] = 1;\n                }\n            }\n            else{\n                stairCases2[currNumber][currSuit]++;\n            }\n\n\n        }\n        int best = 3;\n\n        for(int i = 1; i <= 9; i++){\n\n            for(int j = 1; j <= 3; j++){\n\n                best = Math.min(best, 3 - tilesObtained[i][j]);\n                best = Math.min(best, 3 - stairCases[i][j]);\n                best = Math.min(best, 3- stairCases2[i][j]);\n                if(best <0)best = 0;\n            }\n        }\n        System.out.println(best);\n\n\n    }\n}", "index": 831, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class B \n{\n\t\n\tstatic StringBuilder st ; \n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner sc = new Scanner () ;\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tString first = \"\" ; \n\t\tString second = \"\" ; \n\t\t\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tStringBuilder sb2 = new StringBuilder();\n\t\t\n\t\tfor(int i = 0 ; i < 126 ;i++ )\n\t\t{\n\t\t\tsb.append(\"9\");\n\t\t\tsb2.append(\"9\");\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < 125 ;i++ )\n\t\t\tsb.append(\"0\");\n\t\t\n\t\tsb.append(\"1\");\n\t\t\n\t\tout.println(sb.toString()+\" \"+sb2.toString());\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t\n\t}\n\t\n\tstatic int sumDigits(int num)\n\t{\n\t\tint ans = 0 ;\n\t\t\n\t\twhile(num > 0)\n\t\t{\n\t\t\tans += num % 10  ;\n\t\t\tnum /= 10;\n\t\t}\n\t\t\n\t\treturn ans ;\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\n\t\tString next() throws Exception \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception { return Integer.parseInt(next()); }\n\t\t\n\t\tlong nextLong() throws Exception { return Long.parseLong(next()); }\n\n\t\tdouble nextDouble() throws Exception { return Double.parseDouble(next()); }\n\n\t\tchar nextChar() throws Exception { return next().charAt(0); }\n\t\t\n\t\tchar [] nextCharArray() throws Exception{ return next().toCharArray() ; }\n\t}\n\n}\n", "src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class B \n{\n\t\n\tstatic StringBuilder st ; \n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner sc = new Scanner () ;\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tString first = \"\" ; \n\t\tString second = \"\" ; \n\t\t\n\t\t\n\t\tfor(int i = 0 ; i < 126 ;i++ )\n\t\t{\n\t\t\tfirst+= \"9\";\n\t\t\tsecond+=\"9\";\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < 125 ;i++ )\n\t\t\tfirst+= \"0\";\n\t\t\n\t\tfirst += \"1\";\n\t\t\n\t\tout.println(first+\" \"+second);\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t\n\t}\n\t\n\tstatic int sumDigits(int num)\n\t{\n\t\tint ans = 0 ;\n\t\t\n\t\twhile(num > 0)\n\t\t{\n\t\t\tans += num % 10  ;\n\t\t\t\n\t\t\tnum /= 10;\n\t\t}\n\t\t\n\t\treturn ans ;\n\t\t\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\n\t\tString next() throws Exception \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception { return Integer.parseInt(next()); }\n\t\t\n\t\tlong nextLong() throws Exception { return Long.parseLong(next()); }\n\n\t\tdouble nextDouble() throws Exception { return Double.parseDouble(next()); }\n\n\t\tchar nextChar() throws Exception { return next().charAt(0); }\n\t\t\n\t\tchar [] nextCharArray() throws Exception{ return next().toCharArray() ; }\n\t}\n\n}\n", "index": 832, "complexity": 1}
{"back-translation": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class e {\n\n\tpublic static class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception r) {\n\t\t\t\t\tr.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (Exception r) {\n\t\t\t\tr.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\tstatic ArrayList<String> list1 = new ArrayList<String>();\n\n\tpublic static void combine(String instr, StringBuffer outstr, int index, int k) {\n\t\tif (outstr.length() == k) {\n\t\t\tlist1.add(outstr.toString());\n\t\t\treturn;\n\t\t}\n\t\tif (outstr.toString().length() == 0)\n\t\t\toutstr.append(instr.charAt(index));\n\t\tfor (int i = 0; i < instr.length(); i++) {\n\t\t\toutstr.append(instr.charAt(i));\n\t\t\tcombine(instr, outstr, i + 1, k);\n\t\t\toutstr.deleteCharAt(outstr.length() - 1);\n\t\t}\n\t\tindex++;\n\t}\n\n\tstatic ArrayList<ArrayList<Integer>> l = new ArrayList<>();\n\n\tpublic static void comb(int n, int k, int ind, ArrayList<Integer> list) {\n\t\tif (k == 0) {\n\t\t\tl.add(new ArrayList<>(list));\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = ind; i <= n; i++) {\n\t\t\tlist.add(i);\n\t\t\tcomb(n, k - 1, ind + 1, list);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n\tpublic static void main(String[] args) {\n\t\tFastReader in = new FastReader();\n\t\tHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\n\t\tint n = in.nextInt();\n\t\tint r = in.nextInt();\n\t\tdouble theta = (double) 360 / (double) n;\n\t\tdouble b = 1 - ((double) 2 / (double) (1 - Math.cos((double) 2 * Math.PI / (double) n)));\n\t\tdouble x = Math.sqrt(1 - b) - 1;\n\t\tdouble ans = (double) r / (double) x;\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class e {\n\npublic static class FastReader {\n\tBufferedReader br;\n\tStringTokenizer st;\n\t//it reads the data about the specified point and divide the data about it ,it is quite fast\n\t//than using direct \n\n\tpublic FastReader() {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tString next() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception r) {\n\t\t\t\tr.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());//converts string to integer\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tString nextLine() {\n\t\tString str = \"\";\n\t\ttry {\n\t\t\tstr = br.readLine();\n\t\t} catch (Exception r) {\n\t\t\tr.printStackTrace();\n\t\t}\n\t\treturn str;\n\t}\n}\nstatic ArrayList<String>list1=new ArrayList<String>();\nstatic void combine(String instr, StringBuffer outstr, int index,int k)\n{\n\tif(outstr.length()==k)\n\t{\n\t\tlist1.add(outstr.toString());return;\n\t}\n\tif(outstr.toString().length()==0)\n\toutstr.append(instr.charAt(index));\n    for (int i = 0; i < instr.length(); i++)\n    {\n        outstr.append(instr.charAt(i));\n       \n        combine(instr, outstr, i + 1,k);\n        outstr.deleteCharAt(outstr.length() - 1);\n    }\n   index++;\n} \nstatic ArrayList<ArrayList<Integer>>l=new ArrayList<>();\nstatic void comb(int n,int k,int ind,ArrayList<Integer>list)\n{\n\tif(k==0)\n\t{\n\t\tl.add(new ArrayList<>(list));\n\n\t\treturn;\n\t}\n\t\n\t\n\tfor(int i=ind;i<=n;i++)\n\t{\n\t\tlist.add(i);\n\t\tcomb(n,k-1,ind+1,list);\n\t\t\n\t\tlist.remove(list.size()-1);\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\t\n\n}\n\n\npublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\tFastReader in=new FastReader();\n\tHashMap<Integer,Integer>map=new HashMap<Integer,Integer>();\n\n\tint n=in.nextInt();\n\tint r=in.nextInt();\n\t \n\tdouble theta=(double)360/(double)n;\n\t \n\tdouble b=1-((double)2/(double)(1-Math.cos((double)2*Math.PI/(double)n)));\n\tdouble x=Math.sqrt(1-b)-1;\n\tdouble ans=(double)r/(double)x;\n\tSystem.out.println(ans);\n\n\n\n\n\n\t}\n}\n", "index": 833, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class MargariteBestPresent_1080B {\n\n    private static int f(int x) {\n        return (x % 2 == 0) ? x / 2 : (x - 1) / 2 - x;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n, r, l;\n        n = sc.nextInt();\n        while (n-- > 0) {\n            l = sc.nextInt();\n            r = sc.nextInt();\n\n            System.out.println(f(r) - f(l - 1));\n        }\n        sc.close();\n    }\n\n}\n", "src": "import java.util.Scanner;\n\npublic class MargariteBestPresent_1080B {\n\n\tprivate static int f(int x) {\n\t\treturn (x%2==0)?x/2:(x-1)/2-x;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n,r,l;\n\t\tn = sc.nextInt();\n\t\twhile(n-->0) {\n\t\t\tl = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\n\t\t\tSystem.out.println(f(r)-f(l-1));\n\t\t}\n\t\tsc.close();\n\t}\n\n}\n", "index": 834, "complexity": 1}
{"back-translation": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class EhabAndAnotherConstructionProblem {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint x = nextInt();\n\t\tif (x == 1) {\n\t\t\tSystem.out.println(-1);\n\t\t} else {\n\t\t\tSystem.out.println(x + \" \" + x);\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}", "src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class EhabAndAnotherConstructionProblem {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint x = nextInt();\n\t\tSystem.out.println(x == 1 ? -1 : x + \" \" + x);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 835, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class FirstApp {\n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solve = new TaskA();\n        solve.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskA {\n        \n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int number = in.nextInt();\n\n            if(number > 2 && number % 2 == 0) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n        }\n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n    }\n    \n}", "src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n *\n * @author luismiguel\n */\npublic class FirstApp {\n    \n    \n \n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solve = new TaskA();\n        solve.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int number = in.nextInt();\n\n            if(number > 2 && number % 2 == 0) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n        }\n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n    }\n    \n}\n", "index": 836, "complexity": 1}
{"back-translation": "import java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedInputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 838, "complexity": 1}
{"back-translation": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint pos = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t/*if(l==r) {\n\t\t\t\tSystem.out.print(Math.abs(r-pos)+1);\n\t\t\t}*/\n\t\t\tif(l==1&&r==n) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse if(l==1&&r<n) {\n\t\t\t\tSystem.out.println(Math.abs(r-pos)+1);\n\t\t\t}\n\t\t\telse if(l>1&&r==n) {\n\t\t\t\tSystem.out.println(Math.abs(l-pos)+1);\n\t\t\t}\n\t\t\telse if(l>1&&r<n) {\n\t\t\t\tint c = Math.min(Math.abs(r-pos), Math.abs(l-pos));//Math.abs(r-pos)>Math.abs(l-pos)?Math.abs(l-pos):Math.abs(r-pos);\n\t\t\t\tSystem.out.println(c+2+r-l);\n\t\t\t}\n\t\t}\n\t}\t\n}\n", "src": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\tint n = sc.nextInt();\n\t\tint pos = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\t/*if(l==r) {\n\t\t\tSystem.out.print(Math.abs(r-pos)+1);\n\t\t}*/\n\t\tif(l==1&&r==n) {\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(l==1&&r<n) {\n\t\t\tSystem.out.println(Math.abs(r-pos)+1);\n\t\t}\n\t\telse if(l>1&&r==n) {\n\t\t\tSystem.out.println(Math.abs(l-pos)+1);\n\t\t}\n\t\telse if(l>1&&r<n) {\n\t\t\tint c = Math.min(Math.abs(r-pos), Math.abs(l-pos));//Math.abs(r-pos)>Math.abs(l-pos)?Math.abs(l-pos):Math.abs(r-pos);\n\t\t\tSystem.out.println(c+2+r-l);\n\t\t}\n\t\t}\n\t}\t\n}\n\n\n\n\n\n", "index": 839, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class programA {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint k = Integer.parseInt(st.nextToken());\n\t\tint t1 = (int) Math.ceil((double) n * 2 / k);\n\t\tint t2 = (int) Math.ceil((double) n * 5 / k);\n\t\tint t3 = (int) Math.ceil((double) n * 8 / k);\n\t\tSystem.out.println(t1 + t2 + t3);\n\t}\n}", "src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class programA {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint k = Integer.parseInt(st.nextToken());\n\t\tint t1 = (int)Math.ceil((double)n*2/k);\n\t\tint t2 = (int)Math.ceil((double)n*5/k);\n\t\tint t3 = (int)Math.ceil((double)n*8/k);\n\t\tSystem.out.println(t1+t2+t3);\n\t}\n}", "index": 840, "complexity": 1}
{"back-translation": "class DLL { Node head; class Node { int data; Node prev; Node next; Node(int d) { data = d; } } void push(int new_data) { Node new_Node = new Node(new_data); new_Node.next = head; new_Node.prev = null; if (head != null) head.prev = new_Node; head = new_Node; } void printlist(Node node) { Node last = null; while (node != null) { System.out.print(node.data + \" \"); last = node; node = node.next; } System.out.println(); } void deleteNode(Node head_ref, Node del) { if (head == null || del == null) { return; } if (head == del) { head = del.next; } if (del.next != null) { del.next.prev = del.prev; } if (del.prev != null) { del.prev.next = del.next; } return; } public static void main(String[] args) { DLL dll = new DLL(); dll.push(2); dll.push(4); dll.push(8); dll.push(10); System.out.print(\"Created DLL is: \"); dll.printlist(dll.head); dll.deleteNode(dll.head, dll.head); System.out.print(\"\\nList after deleting first node: \"); dll.printlist(dll.head); dll.deleteNode(dll.head, dll.head.next); System.out.print(\"\\nList after Deleting middle node: \"); dll.printlist(dll.head); } }", "src": "\n// Java program to delete a node from \n// Doubly Linked List \n\n// Class for Doubly Linked List \npublic\nclass\nDLL { \n\nNode head; \n// head of list \n\n\n/* Doubly Linked list Node*/\n\nclass\nNode { \n\nint\ndata; \n\nNode prev; \n\nNode next; \n\n\n// Constructor to create a new node \n\n// next and prev is by default initialized \n\n// as null \n\nNode(\nint\nd) { data = d; } \n\n} \n\n\n// Adding a node at the front of the list \n\npublic\nvoid\npush(\nint\nnew_data) \n\n{ \n\n// 1. allocate node \n\n// 2. put in the data \n\nNode new_Node = \nnew\nNode(new_data); \n\n\n// 3. Make next of new node as head \n\n// and previous as NULL \n\nnew_Node.next = head; \n\nnew_Node.prev = \nnull\n; \n\n\n// 4. change prev of head node to new node \n\nif\n(head != \nnull\n) \n\nhead.prev = new_Node; \n\n\n// 5. move the head to point to the new node \n\nhead = new_Node; \n\n} \n\n\n// This function prints contents of linked list \n\n// starting from the given node \n\npublic\nvoid\nprintlist(Node node) \n\n{ \n\nNode last = \nnull\n; \n\n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nlast = node; \n\nnode = node.next; \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n// Function to delete a node in a Doubly Linked List. \n\n// head_ref --> pointer to head node pointer. \n\n// del --> data of node to be deleted. \n\nvoid\ndeleteNode(Node head_ref, Node del) \n\n{ \n\n\n// Base case \n\nif\n(head == \nnull\n|| del == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n// If node to be deleted is head node \n\nif\n(head == del) { \n\nhead = del.next; \n\n} \n\n\n// Change next only if node to be deleted \n\n// is NOT the last node \n\nif\n(del.next != \nnull\n) { \n\ndel.next.prev = del.prev; \n\n} \n\n\n// Change prev only if node to be deleted \n\n// is NOT the first node \n\nif\n(del.prev != \nnull\n) { \n\ndel.prev.next = del.next; \n\n} \n\n\n// Finally, free the memory occupied by del \n\nreturn\n; \n\n} \n\n\n// Driver Code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n// Start with the empty list \n\nDLL dll = \nnew\nDLL(); \n\n\n// Insert 2. So linked list becomes 2->NULL \n\ndll.push(\n2\n); \n\n\n// Insert 4. So linked list becomes 4->2->NULL \n\ndll.push(\n4\n); \n\n\n// Insert 8. So linked list becomes 8->4->2->NULL \n\ndll.push(\n8\n); \n\n\n// Insert 10. So linked list becomes 10->8->4->2->NULL \n\ndll.push(\n10\n); \n\n\nSystem.out.print(\n\"Created DLL is: \"\n); \n\ndll.printlist(dll.head); \n\n\n// Deleting first node \n\ndll.deleteNode(dll.head, dll.head); \n\n\n// List after deleting first node \n\n// 8->4->2 \n\nSystem.out.print(\n\"\\nList after deleting first node: \"\n); \n\ndll.printlist(dll.head); \n\n\n// Deleting middle node from 8->4->2 \n\ndll.deleteNode(dll.head, dll.head.next); \n\n\nSystem.out.print(\n\"\\nList after Deleting middle node: \"\n); \n\ndll.printlist(dll.head); \n\n} \n} ", "index": 841, "complexity": 1}
{"back-translation": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class SashaAndHisTrip {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint v = nextInt();\n\t\t\n\t\tif (v >= n - 1)\n\t\t\tSystem.out.println(n - 1);\n\t\telse\n\t\t\tSystem.out.println((n - v) * (n - v + 1) / 2 + v - 1);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class SashaAndHisTrip {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint v = nextInt();\n\t\t\n\t\tif (v >= n-1)\n\t\t\tSystem.out.println(n-1);\n\t\telse\n\t\t\tSystem.out.println((n-v)*(n-v+1)/2+v-1);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 842, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\nclass usd {\n    static int r = 0;\n    static int c = 0;\n\n    public static void main(String[] args) throws IOException {\n        Scanner in = new Scanner(System.in);\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\n        ArrayList<Integer> list = new ArrayList<Integer>();\n\n        long n = in.nextLong();\n        long ans = Long.MAX_VALUE;\n        long sum = 0;\n        long sum2 = (n * (n + 1)) / 2;\n\n        if (sum2 % 2 == 0)\n            System.out.println(0);\n        else\n            System.out.println(1);\n    }\n\n    static void fillzero(int a[][], int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - 1; j++) {\n                if (a[j][i] == 0 && a[j + 1][i] == 0) {\n                    a[j][i] = 1;\n                    a[j + 1][i] = 1;\n                    r = j;\n                    c = i;\n                    return;\n                }\n            }\n        }\n    }\n\n    static void fillone(int a[][], int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - 1; j++) {\n                if (a[i][j] == 0 && a[i][j + 1] == 0) {\n                    a[i][j] = 1;\n                    a[i][j + 1] = 1;\n                    r = i;\n                    c = j;\n                    return;\n                }\n            }\n        }\n    }\n\n    static void check(int a[][], int n) {\n        for (int i = 0; i < 4; i++) {\n            if (a[i][0] == 1 && a[i][1] == 1 && a[i][2] == 1 && a[i][3] == 1) {\n                a[i][0] = 0;\n                a[i][1] = 0;\n                a[i][2] = 0;\n                a[i][3] = 0;\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            if (a[0][i] == 1 && a[1][i] == 1 && a[2][i] == 1 && a[3][i] == 1) {\n                a[0][i] = 0;\n                a[1][i] = 0;\n                a[2][i] = 0;\n                a[3][i] = 0;\n            }\n        }\n    }\n}", "src": "\n\t\n\t\n\timport java.io.BufferedReader;\n\timport java.io.IOException;\n\timport java.io.InputStreamReader;\n\timport java.io.PrintWriter;\n\timport java.math.BigInteger;\n\timport java.util.*;\n\t\n\t\n\tpublic class usd {\n\t\t\n\t\tstatic int r=0;static int c=0;\n\t\tstatic void fillzero(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[j][i]==0&&a[j+1][i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][i]=1;a[j+1][i]=1;\n\t\t\t\t\t\tr=j;c=i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic void fillone(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[i][j]==0&&a[i][j+1]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i][j]=1;a[i][j+1]=1;\n\t\t\t\t\t\tr=i;c=j;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void check(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[i][0]==1&&a[i][1]==1&&a[i][2]==1&&a[i][3]==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][0]=0;a[i][1]=0;a[i][2]=0;a[i][3]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[0][i]==1&&a[1][i]==1&&a[2][i]==1&&a[3][i]==1)\n\t\t\t\t{\n\t\t\t\t\ta[0][i]=0;a[1][i]=0;a[2][i]=0;a[3][i]=0;;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t\t\n\t\t\t\n\t\tScanner in=new Scanner (System.in);\n\t\tHashMap<String,Integer>map=new HashMap<String,Integer>();\n\t\tArrayList<Integer>list=new ArrayList<Integer>();\n\t\nlong n=in.nextLong();\nlong ans=Long.MAX_VALUE;\nlong sum=0;long sum2=(n*(n+1))/2;\nif(sum2%2==0)\nSystem.out.println(0);\nelse\n\tSystem.out.println(1);\n\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n", "index": 844, "complexity": 1}
{"back-translation": "ERROR", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static String conv(String str) {\n\t\tboolean[] Arr = new boolean[26];\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tArr[str.charAt(i) - 'a'] = true;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (Arr[i])\n\t\t\t\tsb.append((char) (i + 'a'));\n\t\t}\n\t\treturn \"\" + sb;\n\t}\n\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashSet<String> hs = new HashSet<String>();\n\t\tint[] Arr = new int[14];\n\t\tlong max = 0;\n\t\tfor (int i = 0; i < 14; i++) {\n\t\t\tArr[i] = sc.nextInt();\n\t\t}\n\n\t\tfor (int i = 0; i < 14; i++) {\n\t\t\tint[] arr = Arr.clone();\n\n\t\t\tlong sum = 0;\n\t\t\tint r = arr[i];\n\t\t\tarr[i] = 0;\n\t\t\tfor (int j = i + 1; j < arr.length && r > 0; j++) {\n\t\t\t\tarr[j]++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tfor (int j = 0; j < arr.length; j++) {\n\t\t\t\tarr[j] +=( r / 14);\n\t\t\t\tif (j + 1 <= (r % 14)) {\n\t\t\t\t\tarr[j]++;\n\t\t\t\t}\n\t\t\t\tif (arr[j] % 2 == 0) {\n\t\t\t\t\tsum += arr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, sum);\n\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n}\n", "index": 845, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class C994{\n    static double area(double x1,double y1,double x2,double y2,double x3,double y3){\n        return Math.abs((x1 * (y2 - y3) +  x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0); \n    }\n    public static void main(String args[])throws IOException{\n        Scanner sc=new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        PrintWriter pw=new PrintWriter(System.out);\n        int x11=sc.nextInt();\n        int y11=sc.nextInt();\n        int x12=sc.nextInt();\n        int y12=sc.nextInt();\n        int x13=sc.nextInt();\n        int y13=sc.nextInt();\n        int x14=sc.nextInt();\n        int y14=sc.nextInt();\n        double x1c=(x11+x12+x13+x14)/4.0;\n        double y1c=(y11+y12+y13+y14)/4.0;\n        int x21=sc.nextInt();\n        int y21=sc.nextInt();\n        int x22=sc.nextInt();\n        int y22=sc.nextInt();\n        int x23=sc.nextInt();\n        int y23=sc.nextInt();\n        int x24=sc.nextInt();\n        int y24=sc.nextInt();\n        double x2c=(x21+x22+x23+x24)/4.0;\n        double y2c=(y21+y22+y23+y24)/4.0;\n        double a1=area(x11,y11,x12,y12,x13,y13)+area(x11,y11,x13,y13,x14,y14);\n        double a2=area(x21,y21,x22,y22,x23,y23)+area(x21,y21,x23,y23,x24,y24);\n        if(a1==area(x11,y11,x12,y12,x21,y21)+area(x11,y11,x21,y21,x14,y14)+area(x21,y21,x12,y12,x13,y13)+area(x21,y21,x14,y14,x13,y13)){\n            pw.println(\"YES\");\n            pw.close();\n            return;\n        }\n        if(a1==area(x11,y11,x12,y12,x22,y22)+area(x11,y11,x22,y22,x14,y14)+area(x22,y22,x12,y12,x13,y13)+area(x22,y22,x14,y14,x13,y13)){\n            pw.println(\"YES\");\n            pw.close();\n            return;\n        }\n        if(a1==area(x11,y11,x12,y12,x23,y23)+area(x11,y11,x23,y23,x14,y14)+area(x23,y23,x12,y12,x13,y13)+area(x23,y23,x14,y14,x13,y13)){\n            pw.println(\"YES\");\n            pw.close();\n            return;\n        }\n        if(a1==area(x11,y11,x12,y12,x24,y24)+area(x11,y11,x24,y24,x14,y14)+area(x24,y24,x12,y12,x13,y13)+area(x24,y24,x14,y14,x13,y13)){\n            pw.println(\"YES\");\n            pw.close();\n            return;\n        }\n        if(a1==area(x11,y11,x12,y12,x2c,y2c)+area(x11,y11,x2c,y2c,x14,y14)+area(x2c,y2c,x12,y12,x13,y13)+area(x2c,y2c,x14,y14,x13,y13)){\n            pw.println(\"YES\");\n            pw.close();\n            return;\n        }\n        if(a2==area(x21,y21,x22,y22,x11,y11)+area(x21,y21,x11,y11,x24,y24)+area(x11,y11,x22,y22,x23,y23)+area(x11,y11,x24,y24,x23,y23)){\n            pw.println(\"YES\");\n            pw.close();\n            return;\n        }\n        if(a2==area(x21,y21,x22,y22,x12,y12)+area(x21,y21,x12,y12,x24,y24)+area(x12,y12,x22,y22,x23,y23)+area(x12,y12,x24,y24,x23,y23)){\n            pw.println(\"YES\");\n            pw.close();\n            return;\n        }\n        if(a2==area(x21,y21,x22,y22,x13,y13)+area(x21,y21,x13,y13,x24,y24)+area(x13,y13,x22,y22,x23,y23)+area(x13,y13,x24,y24,x23,y23)){\n            pw.println(\"YES\");\n            pw.close();\n            return;\n        }\n        if(a2==area(x21,y21,x22,y22,x14,y14)+area(x21,y21,x14,y14,x24,y24)+area(x14,y14,x22,y22,x23,y23)+area(x14,y14,x24,y24,x23,y23)){\n            pw.println(\"YES\");\n            pw.close();\n            return;\n        }\n        if(a2==area(x21,y21,x22,y22,x1c,y1c)+area(x21,y21,x14,y14,x2c,y2c)+area(x1c,y1c,x22,y22,x23,y23)+area(x1c,y1c,x24,y24,x23,y23)){\n            pw.println(\"YES\");\n            pw.close();\n            return;\n        }\n\n        pw.println(\"NO\");\n        pw.close();\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\n\n\npublic class C994{\n\tstatic double area(double x1,double y1,double x2,double y2,double x3,double y3){\n\t\treturn Math.abs((x1 * (y2 - y3) +  \n        x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0); \n\t}\n\tpublic static void main(String args[])throws IOException{\n\t\tScanner sc=new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\tint x11=sc.nextInt();\n\t\tint y11=sc.nextInt();\n\t\tint x12=sc.nextInt();\n\t\tint y12=sc.nextInt();\n\t\tint x13=sc.nextInt();\n\t\tint y13=sc.nextInt();\n\t\tint x14=sc.nextInt();\n\t\tint y14=sc.nextInt();\n\t\tdouble x1c=(x11+x12+x13+x14)/4.0;\n\t\tdouble y1c=(y11+y12+y13+y14)/4.0;\n\t\tint x21=sc.nextInt();\n\t\tint y21=sc.nextInt();\n\t\tint x22=sc.nextInt();\n\t\tint y22=sc.nextInt();\n\t\tint x23=sc.nextInt();\n\t\tint y23=sc.nextInt();\n\t\tint x24=sc.nextInt();\n\t\tint y24=sc.nextInt();\n\t\tdouble x2c=(x21+x22+x23+x24)/4.0;\n\t\tdouble y2c=(y21+y22+y23+y24)/4.0;\n\t\tdouble a1=area(x11,y11,x12,y12,x13,y13)+area(x11,y11,x13,y13,x14,y14);\n\t\tdouble a2=area(x21,y21,x22,y22,x23,y23)+area(x21,y21,x23,y23,x24,y24);\n\t\tif(a1==area(x11,y11,x12,y12,x21,y21)+area(x11,y11,x21,y21,x14,y14)+area(x21,y21,x12,y12,x13,y13)+area(x21,y21,x14,y14,x13,y13)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a1==area(x11,y11,x12,y12,x22,y22)+area(x11,y11,x22,y22,x14,y14)+area(x22,y22,x12,y12,x13,y13)+area(x22,y22,x14,y14,x13,y13)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a1==area(x11,y11,x12,y12,x23,y23)+area(x11,y11,x23,y23,x14,y14)+area(x23,y23,x12,y12,x13,y13)+area(x23,y23,x14,y14,x13,y13)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a1==area(x11,y11,x12,y12,x24,y24)+area(x11,y11,x24,y24,x14,y14)+area(x24,y24,x12,y12,x13,y13)+area(x24,y24,x14,y14,x13,y13)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a1==area(x11,y11,x12,y12,x2c,y2c)+area(x11,y11,x2c,y2c,x14,y14)+area(x2c,y2c,x12,y12,x13,y13)+area(x2c,y2c,x14,y14,x13,y13)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a2==area(x21,y21,x22,y22,x11,y11)+area(x21,y21,x11,y11,x24,y24)+area(x11,y11,x22,y22,x23,y23)+area(x11,y11,x24,y24,x23,y23)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a2==area(x21,y21,x22,y22,x12,y12)+area(x21,y21,x12,y12,x24,y24)+area(x12,y12,x22,y22,x23,y23)+area(x12,y12,x24,y24,x23,y23)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a2==area(x21,y21,x22,y22,x13,y13)+area(x21,y21,x13,y13,x24,y24)+area(x13,y13,x22,y22,x23,y23)+area(x13,y13,x24,y24,x23,y23)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a2==area(x21,y21,x22,y22,x14,y14)+area(x21,y21,x14,y14,x24,y24)+area(x14,y14,x22,y22,x23,y23)+area(x14,y14,x24,y24,x23,y23)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tif(a2==area(x21,y21,x22,y22,x1c,y1c)+area(x21,y21,x14,y14,x2c,y2c)+area(x1c,y1c,x22,y22,x23,y23)+area(x1c,y1c,x24,y24,x23,y23)){\n\t\t\tpw.println(\"YES\");\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tpw.println(\"NO\");\n\t\tpw.close();\n\t}\n}", "index": 846, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\nimport java.util.Arrays;\n\npublic class Main {\n    \n    static MyScanner in = new MyScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        long n = in.nextLong(), m = in.nextLong();\n        out.print(m / n + (m % n == 0 ? 0 : 1));\n        out.close();\n    }\n    \n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.PrintWriter;\n\nimport java.io.InputStreamReader;\n\nimport java.io.IOException;\n\nimport java.util.StringTokenizer;\n\nimport java.util.Arrays;\n\npublic class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        long n = in.nextLong(), m = in.nextLong();\n        out.print(m / n + (m % n == 0 ? 0 : 1));\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 847, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class programB {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint result = (n % 2 == 0) ? System.out.println(n / 2 + 1) : System.out.println((int) Math.ceil((double) n / 2));\n\t}\n}\n", "src": "import java.util.*;\nimport java.io.*;\n\npublic class programA {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tif(n%2 == 0)System.out.println(n/2 +1);\n\t\telse System.out.println((int)Math.ceil((double)n/2));\n\t}\n}\n\n\n\n\n", "index": 849, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\npublic class ElevatorOrStairs {\n\n    private static final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n    private static final OutputStreamWriter writer = new OutputStreamWriter(System.out);\n    \n    public static void main(String...strings) throws Exception {\n        String[] specs = reader.readLine().split(\" \");\n        \n        int x = Integer.parseInt(specs[0]);\n        int y = Integer.parseInt(specs[1]);\n        int z = Integer.parseInt(specs[2]);\n        int t1 = Integer.parseInt(specs[3]);\n        int t2 = Integer.parseInt(specs[4]);\n        int t3 = Integer.parseInt(specs[5]);\n        \n        reader.close();\n        String ans = solve(x, y, z, t1, t2, t3);\n        writer.append(ans);\n        writer.flush();\n        writer.close();\n    }\n    \n    private static String solve(int x, int y, int z, int t1, int t2, int t3) {\n        int time_using_stairs = Math.abs(x - y) * t1;\n        int elevator_time_between_floor = Math.abs(x - z) * t2;\n        int elevator_from_z_to_x = elevator_time_between_floor + 2*t3;\n        \n        int time_using_elevator = elevator_from_z_to_x + (Math.abs(x - y) * t2) + t3;\n        \n        if(time_using_elevator <= time_using_stairs) {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n}", "src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\npublic class ElevatorOrStairs {\n\n\tprivate static final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\tprivate static final OutputStreamWriter writer = new OutputStreamWriter(System.out);\n\t\n\tpublic static void main(String...strings) throws Exception {\n\t\tString[] specs = reader.readLine().split(\" \");\n\t\t\n\t\tint x = Integer.parseInt(specs[0]);\n\t\tint y = Integer.parseInt(specs[1]);\n\t\tint z = Integer.parseInt(specs[2]);\n\t\tint t1 = Integer.parseInt(specs[3]);\n\t\tint t2 = Integer.parseInt(specs[4]);\n\t\tint t3 = Integer.parseInt(specs[5]);\n\t\t\n\t\treader.close();\n\t\tString ans = solve(x, y, z, t1, t2, t3);\n\t\twriter.append(ans);\n\t\twriter.flush();\n\t\twriter.close();\n\t}\n\t\n\tprivate static String solve(int x, int y, int z, int t1, int t2, int t3) {\n\t\tint time_using_stairs = Math.abs(x - y) * t1;\n\t\tint elevator_time_between_floor = Math.abs(x - z) * t2;\n\t\tint elevator_from_z_to_x = elevator_time_between_floor + 2*t3;\n\t\t\n \t\tint time_using_elevator = elevator_from_z_to_x + (Math.abs(x - y) * t2) + t3;\n \t\t\n \t\tif(time_using_elevator <= time_using_stairs) {\n \t\t\treturn \"YES\";\n \t\t}\n \t\treturn \"NO\";\n\t}\n}", "index": 850, "complexity": 1}
{"back-translation": "import java.util.*; public class Main { public static void main(String args[]) { Scanner sc = new Scanner(System.in); long n = sc.nextLong(); long s = sc.nextLong(); long ans = (s - 1) / n + 1; System.out.print(ans); } }", "src": "import java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        long n = sc.nextLong();\n        long s = sc.nextLong();\n\n        long ans = (s - 1) / n + 1;\n        System.out.print(ans);\n    }\n}", "index": 851, "complexity": 1}
{"back-translation": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tlong m = in.nextLong();\n\t\t\n\t\tlong ans = (m + n - 1) / n;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}\n", "src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tlong m = in.nextLong();\n\t\t\n\t\tlong ans = m / n;\n\t\t\n\t\tif(m % n > 0)\n\t\t\tans++;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}\n\n", "index": 852, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\n\n\n public class Param\n{\n                \n      public static  void main( String[]args) throws IOException\n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n       long l2 =param.nextLong();\n       long dice1=param.nextLong();\n       long dice2=param.nextLong();\n      \n       long l1=1;\n       long r1=1;\n       long r2=l2;\n       long count=0;\n       long check=0;\n       count=l2-dice1;\n       count=count+(r2-dice2);\n       check=dice1-l1;\n       check=check+(dice2-r1);\n       if(check<=count){\n          System.out.println('White');\n       }\n       else{\n          System.out.println('Black');\n       }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   //-----------MyScanner class for faster input----------\n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() throws IOException {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() throws IOException {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() throws IOException {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() throws IOException {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine() throws IOException {\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}\n   ", "src": "import java.util.*;\nimport java.io.*;\n\n\n\n public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n       long l2 =param.nextLong();\n       long dice1=param.nextLong();\n       long dice2=param.nextLong();\n      \n       long l1=1;\n       long r1=1;\n       long r2=l2;\n       long count=0;\n       long check=0;\n       count=l2-dice1;\n       count=count+(r2-dice2);\n       check=dice1-l1;\n       check=check+(dice2-r1);\n       if(check<=count){\n          System.out.println(\"White\");\n       }\n       else{\n          System.out.println(\"Black\");\n       }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   //-----------MyScanner class for faster input----------\n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}\n   ", "index": 853, "complexity": 1}
{"back-translation": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\t\n\t\tlong ans = n + 1;\n\t\tif (ans == 1) \n\t\t{\n\t\t\tans = 0;\n\t\t}\n\t\tif (ans % 2 == 0) \n\t\t{\n\t\t\tans /= 2;\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tlong ans = n+1;\n\t\t\n\t\tif(ans == 1)\n\t\t\tans = 0;\n\t\tif(ans % 2 == 0)\n\t\t\tans /= 2;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 854, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class Sasha1113A {\n\n    static int solution(int n, int v) {\n        int count;\n        if (v >= n) {\n            return n - 1;\n        } else {\n            count = (v - 1) + ((n - v) * (n - v + 1)) / 2;\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int v = scan.nextInt();\n\n        System.out.print(solution(n, v));\n    }\n}\n", "src": "    import java.util.Scanner;\n\n    public class Sasha1113A {\n\n        static int solution(int n, int v){\n            int count;\n            if(v>=n)\n                return n-1;\n            else{\n                count = (v-1) + ((n-v)*(n-v+1))/2;\n            }\n            return count;\n        }\n\n        public static void main(String[] args){\n            Scanner scan = new Scanner(System.in);\n            int n = scan.nextInt();\n            int v = scan.nextInt();\n\n            System.out.print(solution(n, v));\n        }\n    }\n", "index": 855, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if (numChars <= 0) \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while (isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if (c < '0' || c > '9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    \n    static void merge(int arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(int arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    } \n    \n    static void merge(long arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        long L[] = new long [n1]; \n        long R[] = new long [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(long arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    }\n    static int gcd(int a, int b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    }\n    static long gcd(long a, long b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    } \n    public long m=(long)1e9+7;;\n    \n    public void run() {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int a=in.nextInt(),b=in.nextInt(),c=in.nextInt(),n=in.nextInt();\n        int nnew=a+b-c;\n        if((n>nnew) && (a>=c) && (b>=c))\n            out.println(n-nnew);\n        else\n            out.println(-1);\n        \n        out.close();\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    \n    static void merge(int arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(int arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    } \n    \n    static void merge(long arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        long L[] = new long [n1]; \n        long R[] = new long [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(long arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    }\n    static int gcd(int a, int b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    }\n    static long gcd(long a, long b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    } \n    public long m=(long)1e9+7;;\n    \n    public void run() {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int a=in.nextInt(),b=in.nextInt(),c=in.nextInt(),n=in.nextInt();\n        int nnew=a+b-c;\n        if((n>nnew) && (a>=c) && (b>=c))\n            out.println(n-nnew);\n        else\n            out.println(-1);\n        \n        out.close();\n    }\n}", "index": 856, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int S=Integer.parseInt(s1[1]);\n            System.out.println(S % n == 0 ? S / n : S / n + 1);\n      }\n}", "src": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int S=Integer.parseInt(s1[1]);\n            if(S%n==0)\n             System.out.println(S/n);\n            else\n             System.out.println(S/n+1);\n      }\n}", "index": 857, "complexity": 1}
{"back-translation": "import java.util.Scanner;\nimport javafx.geometry.Point2D;\n\npublic class ChessKing {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        long size = input.nextLong();\n        long a = input.nextLong();\n        long b = input.nextLong();\n        long sum = a + b;\n        long d = sum - 2;\n        long d1 = size * 2 - sum;\n        if (d < d1) {\n            System.out.println(\"White\");\n        } else if (d > d1) {\n            System.out.println(\"Black\");\n        } else {\n            System.out.println(\"White\");\n        }\n    }\n}", "src": " \n \n\n\nimport java.util.Scanner;\nimport javafx.geometry.Point2D;\n\n \npublic class ChessKing {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\nScanner input = new Scanner(System.in);\nlong size = input.nextLong();\nlong a = input.nextLong();\nlong b = input.nextLong();\n  long sum = a+b;\n   long d = sum-2;\n   long d1 = size*2 - sum;\nif(d<d1) System.out.println(\"White\");\nelse if(d>d1) System.out.println(\"Black\");\nelse System.out.println(\"White\");\n\n\n    }\n    \n}\n", "index": 858, "complexity": 1}
{"back-translation": "ERROR", "src": "import java.util.*;\n\npublic class Main {\n\tstatic int mod = 1000000007;\n  static int size = 200000;\n\tstatic long[] fac = new long[size];\n\tstatic long[] finv = new long[size];\n\tstatic long[] inv = new long[size];\n\tstatic int INF = Integer.MAX_VALUE;\n\n \tpublic static void main(String[] args){\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString[] s = new String[2];\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\ts[i] = scanner.next();\n\t\t}\n\t\tint n = s[0].length();\n\t\tchar[][] c = new char[2][n];\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tc[i][j] = s[i].charAt(j);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tif(c[0][i] == '0' && c[1][i] == '0' && c[0][i+1] == '0'){\n\t\t\t\tc[0][i] = 'X';\n\t\t\t\tc[1][i] = 'X';\n\t\t\t\tc[0][i+1] = 'X';\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(c[0][i] == '0' && c[1][i] == '0' && c[1][i+1] == '0'){\n\t\t\t\tc[0][i] = 'X';\n\t\t\t\tc[1][i] = 'X';\n\t\t\t\tc[1][i+1] = 'X';\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(c[0][i] == '0' && c[0][i+1] == '0' && c[1][i+1] == '0'){\n\t\t\t\tc[0][i] = 'X';\n\t\t\t\tc[0][i+1] = 'X';\n\t\t\t\tc[1][i+1] = 'X';\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(c[0][i+1] == '0' && c[1][i+1] == '0' && c[1][i] == '0'){\n\t\t\t\tc[1][i] = 'X';\n\t\t\t\tc[0][i+1] = 'X';\n\t\t\t\tc[1][i+1] = 'X';\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\tpublic static boolean isPrime(int n){\n\t\tif(n == 1) return false;\n\t\tif(n == 2 || n == 3) return true;\n\t\tfor(int i = 2; i <= Math.sqrt(n); i++){\n\t\t\tif(n % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t// tar \u306e\u65b9\u304c\u6570\u5b57\u304c\u5927\u304d\u3044\u304b\u3069\u3046\u304b\n\tstatic boolean compare(String tar, String src) {\n\t\tif (src == null) return true;\n\t\tif (src.length() == tar.length()) {\n\t\t\tint len = tar.length();\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tif (src.charAt(i) > tar.charAt(i)) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (src.charAt(i) < tar.charAt(i)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tar.compareTo(src) > 0 ? true : false;\n\t\t} else if (src.length() < tar.length()) {\n\t\t\treturn true;\n\t\t} else if (src.length() > tar.length()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static class Edge{\n\t\tint to;\n\t\tEdge(int to){\n\t\t\tthis.to = to;\n\t\t}\n\t}\n\tpublic static void swap(long a, long b){\n\t\tlong tmp = 0;\n\t\tif(a > b){\n\t\t\ttmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t}\n  static class Pair implements Comparable<Pair>{\n    int first, second;\n    Pair(int a, int b){\n        first = a;\n        second = b;\n    }\n    @Override\n    public boolean equals(Object o){\n        if (this == o) return true;\n        if (!(o instanceof Pair)) return false;\n        Pair p = (Pair) o;\n        return first == p.first && second == p.second;\n    }\n    @Override\n    public int compareTo(Pair p){\n        return first == p.first ? second - p.second : first - p.first; //first\u3067\u6607\u9806\u306b\u30bd\u30fc\u30c8\n        //return (first == p.first ? second - p.second : first - p.first) * -1; //first\u3067\u964d\u9806\u306b\u30bd\u30fc\u30c8\n        //return second == p.second ? first - p.first : second - p.second;//second\u3067\u6607\u9806\u306b\u30bd\u30fc\u30c8\n        //return (second == p.second ? first - p.first : second - p.second)*-1;//second\u3067\u964d\u9806\u306b\u30bd\u30fc\u30c8\n    }\n  }\n\n  //\u7e70\u308a\u8fd4\u3057\u4e8c\u4e57\u6cd5\n  public static long pow(long x, long n){\n    long ans = 1;\n    while(n > 0){\n      if((n & 1) == 1){\n        ans = ans * x;\n        ans %= mod;\n      }\n      x = x * x % mod;\n      n >>= 1;\n    }\n    return ans;\n  }\n\n\tpublic static long div(long x, long y){\n\t\treturn (x*pow(y, mod-2))%mod;\n\t}\n\n  //fac, inv, finv\u30c6\u30fc\u30d6\u30eb\u306e\u521d\u671f\u5316\u3001\u3053\u308c\u4f7f\u3046\u5834\u5408\u306finitComb()\u3067\u521d\u671f\u5316\u5fc5\u8981\n\tpublic static  void initComb(){\n\t\tfac[0] = finv[0] = inv[0] = fac[1] = finv[1] = inv[1] = 1;\n\t\tfor (int i = 2; i < size; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % mod;\n\t\t\tinv[i] = mod - (mod / i) * inv[(int) (mod % i)] % mod;\n\t\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t\t}\n\t}\n\n\t//nCk % mod\n\tpublic static long comb(int n, int k){\n\t\treturn fac[n] * finv[k] % mod * finv[n - k] % mod;\n\t}\n\n\t//n! % mod\n\tpublic static long fact(int n){\n\t\treturn fac[n];\n\t}\n\n\t//(n!)^-1 with % mod\n\tpublic static long finv(int n){\n\t\treturn finv[n];\n\t}\n\n  static class UnionFind {\n    int[] parent;\n    public UnionFind(int size) {\n      parent = new int[size];\n      Arrays.fill(parent, -1);\n    }\n    public boolean unite(int x, int y) {\n      x = root(x);\n      y = root(y);\n      if (x != y) {\n        if (parent[y] < parent[x]) {\n          int tmp = y;\n          y = x;\n          x = tmp;\n        }\n        parent[x] += parent[y];\n        parent[y] = x;\n        return true;\n      }\n      return false;\n    }\n    public boolean same(int x, int y) {\n      return root(x) == root(y);\n    }\n    public int root(int x) {\n      return parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n    }\n    public int size(int x) {\n      return -parent[root(x)];\n    }\n  }\n\tpublic static int upperBound(int[] array, int value) {\n\t\t\t int low = 0;\n\t\t\t int high = array.length;\n\t\t\t int mid;\n\t\t\t while( low < high ) {\n\t\t\t\t\t mid = ((high - low) >>> 1) + low; // (high + low) / 2\n\t\t\t\t\t if( array[mid] <= value ) {\n\t\t\t\t\t\t\t low = mid + 1;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t\t high = mid;\n\t\t\t\t\t }\n\t\t\t }\n\t\t\t return low;\n\t }\n\t public static final int lowerBound(final int[] arr, final int value) {\n    \tint low = 0;\n    \tint high = arr.length;\n    \tint mid;\n    \twhile (low < high){\n        \tmid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n        \tif (arr[mid] < value) {\n          \tlow = mid + 1;\n        \t} else {\n            high = mid;\n        \t}\n    \t}\n    \treturn low;\n\t\t}\n  //n,m\u306e\u6700\u5927\u516c\u7d04\u6570\n  public static long gcd(long n, long m){\n    if(m > n) return gcd(m,n);\n    if(m == 0) return n;\n    return gcd(m, n%m);\n  }\n\t//3\u8981\u7d20\u306e\u30bd\u30fc\u30c8\n\tprivate class Pair2 implements Comparable<Pair2> {\n\t\tString s;\n\t\tint p;\n\t\tint index;\n\t\tpublic Pair2(String s, int p, int index) {\n\t\t\t\tthis.s = s;\n\t\t\t\tthis.p = p;\n\t\t\t\tthis.index = index;\n\t\t}\n\n\t\tpublic int compareTo(Pair2 other) {\n\t\t\t\tif (s.equals(other.s)) {\n\t\t\t\t\t\treturn other.p - this.p;\n\t\t\t\t}\n\t\t\t\treturn this.s.compareTo(other.s);\n\t\t}\n\t}\n\t//c -> int\u306b\u5909\u63db\npublic static int c2i(char c){\n\tif('A' <= c && c <= 'Z'){\n\t\treturn c - 'A';\n\t}else{\n\t\treturn c - 'a' + 26;\n\t}\n}\n// int -> char\u306b\u5909\u63db\npublic static char i2c(int i){\n\tif(0 <= i && i < 26){\n\t\t\treturn (char)(i + 'A');\n\t}else{\n\t\t\treturn (char)(i + 'a' - 26);\n\t}\n}\n\n}\n", "index": 860, "complexity": 1}
{"back-translation": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner read = new Scanner(System.in);\n        double a = (double) read.nextInt();\n        double v = (double) read.nextInt();\n        double l = (double) read.nextInt();\n        double d = (double) read.nextInt();\n        double w = (double) read.nextInt();\n        double t=0;\n        if(w>=v){\n            double d1=v*v/(2*a);\n            if(d1>l){\n                t+= Math.sqrt(2*l/a);\n            }\n            else{\n                t+= v/a + (l-d1)/v;\n            }\n        }\n        else{\n            double temp = (v-w)/a;\n            double d1 = v*v/(2*a);\n            double d2 = d - v*temp + a*temp*temp/2;\n            if(d1>d2){\n                double temp2 = Math.sqrt(2*a*d);\n                if(temp2<w){\n                    w=temp2;\n                    temp=(v-w)/a;\n                    t+= temp2/a;\n                }\n                else{\n                    double vx=Math.sqrt(v*v/2+a*d2);\n                    t+= (vx/a) + ((vx-w)/a);\n                }\n            }\n            else{\n                t+= (v/a) + ((d2-d1)/v) + (temp);\n            }\n            double d3 = d + w*temp + a*temp*temp/2;\n            if(d3>l){\n                t+= (-w+Math.sqrt(w*w+2*a*(l-d)))/a;\n            }\n            else{\n                t+= (temp) + ((l-d3)/v);\n            }\n        }\n        System.out.printf(\"%.6f\", t);\n        read.close();\n    }\n}", "src": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner read = new Scanner(System.in);\n        double a = (double)read.nextInt();\n        double v = (double)read.nextInt();\n        double l = (double)read.nextInt();\n        double d = (double)read.nextInt();\n        double w = (double)read.nextInt();\n        double t=0;\n        if(w>=v){\n            double d1=v*v/(2*a);\n            if(d1>l){\n                t+= Math.sqrt(2*l/a);\n            }\n            else{\n                t+= v/a + (l-d1)/v;\n            }\n        }\n        else{\n            double temp = (v-w)/a;\n            double d1 = v*v/(2*a);\n            double d2 = d - v*temp + a*temp*temp/2;\n            if(d1>d2){\n                double temp2 = Math.sqrt(2*a*d);\n                if(temp2<w){\n                    w=temp2;\n                    temp=(v-w)/a;\n                    t+= temp2/a;\n                }\n                else{\n                    double vx=Math.sqrt(v*v/2+a*d2);\n                    t+= (vx/a) + ((vx-w)/a);\n                }\n            }\n            else{\n                t+= (v/a) + ((d2-d1)/v) + (temp);\n            }\n            double d3 = d + w*temp + a*temp*temp/2;\n            if(d3>l){\n                t+= (-w+Math.sqrt(w*w+2*a*(l-d)))/a;\n            }\n            else{\n                t+= (temp) + ((l-d3)/v);\n            }\n        }\n        System.out.printf(\"%.6f\", t);\n        read.close();\n    }\n}", "index": 861, "complexity": 1}
{"back-translation": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n    public static void main(String args[]) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int[] a = new int[1501];\n        for (int i = 0; i < 3; i++) {\n            a[sc.nextInt()]++;\n        }\n        if (a[1] > 0 || a[2] > 1 || a[3] > 2 || (a[4] == 2 && a[2] == 1)) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n}", "src": "import java.util.*;\nimport static java.lang.Math.*;\nimport java.io.*;\n\npublic class SolutionB {\n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int a[] = new int[1501];\n              for(int i = 0; i < 3; i++){\n                     a[sc.nextInt()]++;\n              }\n              if(a[1] > 0 || a[2] > 1 || a[3] > 2 || (a[4] == 2 && a[2] == 1)){\n                     System.out.println(\"YES\");\n              }else{\n                     System.out.println(\"NO\");\n              }\n      }\n}", "index": 862, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        long n = scanner.nextLong();\n        long x = scanner.nextLong(), y = scanner.nextLong();\n        long whiteSteps, blackSteps;\n\n        if(x == 1 || y == 1){\n            whiteSteps = (x - 1) + (y - 1);\n        } else {\n            whiteSteps = Math.min((x - 1) + Math.abs(y - x), (y - 1) + Math.abs(y - x));\n        }\n\n        if(x == n || y == n){\n            blackSteps = (n - x) + (n - y);\n        } else {\n            blackSteps = Math.min((n - x) + Math.abs(y - x), (n - y) + Math.abs(y - x));\n        }\n\n        if (whiteSteps <= blackSteps){\n            System.out.println(\"White\");\n        } else {\n            System.out.println(\"Black\");\n        }\n\n    }\n}\n", "src": "import java.awt.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        long n = scanner.nextLong();\n        long x = scanner.nextLong(), y = scanner.nextLong();\n        long whiteSteps, blackSteps;\n\n        if(x == 1 || y == 1){\n            whiteSteps = (x - 1) + (y - 1);\n        } else {\n            whiteSteps = Math.min((x - 1) + Math.abs(y - x), (y - 1) + Math.abs(y - x));\n        }\n\n        if(x == n || y == n){\n            blackSteps = (n - x) + (n - y);\n        } else {\n            blackSteps = Math.min((n - x) + Math.abs(y - x), (n - y) + Math.abs(y - x));\n        }\n\n        if (whiteSteps <= blackSteps){\n            System.out.println(\"White\");\n        } else {\n            System.out.println(\"Black\");\n        }\n\n    }\n}\n", "index": 863, "complexity": 1}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n    public static void main(String args[]) {\n        FastScanner scn = new FastScanner();\n        int n = scn.nextInt();\n        int s = scn.nextInt();\n        if (s <= n) {\n            System.out.println(1);\n        } else if (s > n) {\n            if (s % n == 0) {\n                System.out.println(s / n);\n            } else {\n                System.out.println(s / n + 1);\n            }\n        }\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}", "src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n    public static void main(String args[]) {\n        FastScanner scn = new FastScanner();\n        int n = scn.nextInt();\n        int s = scn.nextInt();\n        if (s <= n) {\n            System.out.println(1);\n        } else if (s > n) {\n            if(s%n == 0){\n                System.out.println(s/n);\n            } else {\n                System.out.println(s/n + 1);\n            }\n        }\n\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "index": 864, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class AAA {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint m = Integer.parseInt(st.nextToken());\n\t\tString a = \"\";\n\t\tString b = \"\";\n\t\tint i = 0;\n\t\twhile (i < 1129) {\n\t\t\ta += \"1\";\n\t\t\tb += \"8\";\n\t\t\ti++;\n\t\t}\n\t\ta += \"9\";\n\t\tb += \"1\";\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(b);\n\t}\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class AAA {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\t\n\t\tint n=Integer.parseInt(st.nextToken());\n\t\tint m=Integer.parseInt(st.nextToken());\n\t\tString a=\"\";\n\t\tString b=\"\";\n\t\tfor(int i=0;i<1129;i++) {\n\t\t\ta+=\"1\";\n\t\t\tb+=\"8\";\n\t\t}\n\t\ta+=\"9\";\n\t\tb+=\"1\";\n\t\t\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(b);\n\t}\n\t\t\n}\n", "index": 865, "complexity": 1}
{"back-translation": "import java.util.*;\npublic class A\n{\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        long n=sc.nextLong();\n        if(n==0)\n            System.out.println(0);\n        else if(n%2==1)\n            System.out.println((n+1)/2);\n        else\n            System.out.println(n+1);\n    }\n}", "src": "import java.util.*;\npublic class A\n{\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        long n=sc.nextLong();\n        if(n==0)\n        System.out.println(0);\n        else if(n%2==1)\n        System.out.println((n+1)/2);\n        else\n        System.out.println(n+1);\n    }\n}", "index": 867, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String args[]) {\n        FastReader fr = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = fr.nextInt(), v = fr.nextInt();\n        out.println(v >= n ? n - 1 : (n - v) * (n - v + 1) / 2 + v - 1);\n        out.flush();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        int[] memset(int n, int val) {\n            int ar[] = new int[n];\n            Arrays.fill(ar, val);\n            return ar;\n        }\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String args[]) {\n        FastReader fr = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = fr.nextInt(), v = fr.nextInt();\n        if (v >= n)\n            out.println(n - 1);\n        else\n            out.println((n - v) * (n - v + 1) / 2 + v - 1);\n        out.flush();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        int[] memset(int n, int val) {\n            int ar[] = new int[n];\n            Arrays.fill(ar, val);\n            return ar;\n        }\n    }\n}", "index": 868, "complexity": 1}
{"back-translation": "import java.util.*;\npublic class Pizza {\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong num = sc.nextLong() + 1;\n\t\tsc.close();\n\t\tlong result;\n\t\tif (num % 2 == 0 || num == 1) {\n\t\t\tresult = num / 2;\n\t\t} else {\n\t\t\tresult = num;\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\t\n}\n", "src": "import java.util.*;\npublic class Pizza {\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong num = sc.nextLong() + 1;\n\t\tsc.close();\n\t\tSystem.out.println(num % 2 == 0 || num == 1 ? num / 2 : num);\n\t}\n\t\n}\n", "index": 869, "complexity": 1}
{"back-translation": "import java.util.*;\n\npublic class OrangeJuice{\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint s=in.nextInt();\n\t\tif(n>=1&&n<=100000&&s>=1&&s<=1000000000){\n\t\t\tSystem.out.println(s%n==0?s/n:((s%n==0)?(s/n):((s-(s%n))/n+1)));\n\t\t}\n\t}\n}", "src": "import java.util.*;\n\npublic class OrangeJuice{\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint s=in.nextInt();\n\t\tif(n>=1&&n<=100000&&s>=1&&s<=1000000000){\n\t\t\tif(s%n==0){\n\t\t\t\tSystem.out.println(s/n);\n\t\t\t}else{\n\t\t\t\tint o=s%n;\n\t\t\t\tSystem.out.println((s-o)/n+1);\n\t\t\t}\n\t\t}\n\t}\n}", "index": 870, "complexity": 1}
{"back-translation": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\npublic class FunctionHeight {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        long n = sc.nl();\n        long k = sc.nl();\n        long ans = Math.floorDiv(n + k - 1, n);\n        System.out.println(ans);\n    }\n\n    /////////// TEMPLATE FROM HERE /////////////////\n    private static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int ni() {\n            return Integer.parseInt(next());\n        }\n\n        float nf() {\n            return Float.parseFloat(next());\n        }\n\n        long nl() {\n            return Long.parseLong(next());\n        }\n\n        double nd() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\npublic class FunctionHeight {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        long n = sc.nl();\n        long k = sc.nl();\n        long ans = (n+k-1)/n;\n        System.out.println(ans);\n    }\n\n    /////////// TEMPLATE FROM HERE /////////////////\n    private static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int ni() {\n            return Integer.parseInt(next());\n        }\n\n        float nf() {\n            return Float.parseFloat(next());\n        }\n\n        long nl() {\n            return Long.parseLong(next());\n        }\n\n        double nd() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "index": 871, "complexity": 1}
{"back-translation": "import java.io.PrintWriter;\n\nimport java.util.*;\n\npublic class Test{\n\nstatic long n;\n\nstatic long count =1 ; \nstatic long temp;\n\nstatic String ch(long[]x,long b){\n    for (int i = 0; i < x.length; i++) {\n        if(x[i]==b)return \"YES\" ;\n    }\n    return \"NO\" ; \n}\n\npublic static void main(String[] args)  {\n\nScanner in = new Scanner(System.in) ;\nPrintWriter pw = new PrintWriter(System.out);\n\nn = in.nextLong() ; \ncount = 1;\ntemp = n/2;\ntemp+=count;\n\nSystem.out.println(temp);\n }\n}\n", "src": "\nimport java.io.PrintWriter;\n\nimport java.util.*;\nimport java.util.Arrays ; \nimport java .lang.String.* ;\nimport java .lang.StringBuilder ;\n\n\npublic class Test{\n    static int pos = 0 ; \n    static int  arr[] ; \n  static LinkedList l1 = new  LinkedList() ; \nstatic void find(int p ,char[]x,int put[],String s){\n    int c= 0 ; \n    for (int i = 0; i < s.length(); i++) {\n        if(x[p]==s.charAt(i)){\n        c++ ; }\n    }\n    put[p] = c ;  \n}\nstatic int mode(int m ,int[]x ){\n    int temp = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return m-temp ; \n             \n        }\n    }\n     return m-temp ; \n}\nstatic int mode2(int m ,int[]x ){\n    int temp = 0 ; \n    \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]<=m){\n            temp= x[i] ; \n           /// break ; \n             return x[i] ; \n             \n        }\n    }\n     return 0 ; \n}\nstatic int find(int x[],int temp){\n    int j = 0 ; \n    for (int i = x.length-1; i >=0; i--) {\n        if(x[i]==temp) return j+1 ; \n        j++ ; \n    }\n    return -1 ; \n}\nstatic String ch(long[]x,long b){\n    for (int i = 0; i < x.length; i++) {\n        if(x[i]==b)return \"YES\" ;\n    }\n    return \"NO\" ; \n}\n\n    public static void main(String[] args)  {\n\n        Scanner in = new Scanner(System.in) ;\n        PrintWriter pw = new PrintWriter(System.out);   \n        long n = in.nextLong() ; \n        long count =1 ; \n        long temp =n/2;\n     temp+=count ;\n      \n       \n        System.out.println(temp);\n }               \n}\n\n", "index": 873, "complexity": 1}
{"back-translation": "import java.io.*;\n\npublic class VJudgeProblem2{\n    public static void main(String[] args) throws IOException{\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        int x = Integer.parseInt(reader.readLine());\n\n        if (x != 1)\n            System.out.println(x + \" \" + x);\n        else\n            System.out.println(-1);\n    }\n        \n}", "src": "import java.io.*;\n\npublic class VJudgeProblem2{\n    public static void main(String[] args) throws IOException{\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        int x = Integer.parseInt(reader.readLine());\n\n        if (x == 1)\n            System.out.println(-1);\n        else\n            System.out.println(x + \" \" + x);    \n    }\n        \n}", "index": 874, "complexity": 1}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    int n = Integer.parseInt(br.readLine());\n    StringTokenizer tok = new StringTokenizer(br.readLine());\n    int ax = Integer.parseInt(tok.nextToken());\n    int ay = Integer.parseInt(tok.nextToken());\n    tok = new StringTokenizer(br.readLine());\n    int bx = Integer.parseInt(tok.nextToken());\n    int by = Integer.parseInt(tok.nextToken());\n    tok = new StringTokenizer(br.readLine());\n    int cx = Integer.parseInt(tok.nextToken());\n    int cy = Integer.parseInt(tok.nextToken());\n    boolean ans = (bx < ax && cx < ax && by < ay && cy < ay) || (bx < ax && cx < ax && by > ay && cy > ay) || (bx > ax && cx > ax && by < ay && cy < ay) || (bx > ax && cx > ax && by > ay && cy > ay);\n    System.out.print(ans ? \"YES\" : \"NO\");\n  }\n}", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n \n/**\n *\n * @author Antonio \"Teo\" Alurralde\n */\npublic class Main {\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    int n = Integer.parseInt(br.readLine());\n    StringTokenizer tok = new StringTokenizer(br.readLine());\n    int ax = Integer.parseInt(tok.nextToken());\n    int ay = Integer.parseInt(tok.nextToken());\n    tok = new StringTokenizer(br.readLine());\n    int bx = Integer.parseInt(tok.nextToken());\n    int by = Integer.parseInt(tok.nextToken());\n    tok = new StringTokenizer(br.readLine());\n    int cx = Integer.parseInt(tok.nextToken());\n    int cy = Integer.parseInt(tok.nextToken());\n    boolean ans = (bx < ax && cx < ax && by < ay && cy < ay) ||\n    (bx < ax && cx < ax && by > ay && cy > ay) ||\n    (bx > ax && cx > ax && by < ay && cy < ay) ||\n    (bx > ax && cx > ax && by > ay && cy > ay);\n    System.out.print(ans?\"YES\":\"NO\");\n  }\n}\n", "index": 875, "complexity": 1}
{"back-translation": "import java.util.*;\npublic class D5 {\npublic static void main(String[] args)\n{\nScanner input = new Scanner(System.in);\nint a = input.nextInt(), v = input.nextInt();\nint l = input.nextInt(), d = input.nextInt(), w = input.nextInt();\ndouble lo = 0, hi = v;\nfor(int iter = 0; iter < 1000; iter++)\n{\ndouble mid = (lo + hi) / 2;\nif(can(mid, a, d, w)) lo = mid;\nelse hi = mid;\n}\ndouble t1 = lo / a;\ndouble gone = .5 * t1 * t1 * a;\nif (lo > w)\n{\ngone += -a * .5 * (lo - w) / a * (lo - w) / a + lo * (lo - w) / a;\nt1 += (lo - w) / a;\n}\nt1 += (d - gone) / lo;\ndouble v0 = Math.min(lo, w);\ndouble togo = l - d;\ndouble toAdd = (-v0 + Math.sqrt(v0 * v0 + 4 * togo * .5 * a)) / a;\nif (toAdd * a + v0 > v)\n{\ndouble tt = (v - v0) / a;\nt1 += tt;\ntogo -= .5 * a * tt * tt + v0 * tt;\nt1 += togo / v;\n}\nelse t1 += toAdd;\nSystem.out.println(t1);\n}\nstatic boolean can(double v, double a, double d, double max)\n{\ndouble t1 = v / a;\ndouble distGone = .5 * a * t1 * t1;\nif (v > max)\n{\nt1 = (v - max) / a;\ndistGone += -.5 * a * t1 * t1 + v * t1;\n}\nreturn distGone <= d;\n}\n}", "src": "import java.util.*;\npublic class D5 {\npublic static void main(String[] args)\n{\n    Scanner input = new Scanner(System.in);\n    int a = input.nextInt(), v = input.nextInt();\n    int l = input.nextInt(), d = input.nextInt(), w = input.nextInt();\n    double lo = 0, hi = v;\n    for(int iter = 0; iter < 1000; iter++)\n    {\n        double mid = (lo+hi)/2;\n        if(can(mid, a, d, w)) lo = mid;\n        else hi = mid;\n    }\n    //System.out.println(lo);\n    double t1 = lo / a;\n    double gone = .5 * t1 * t1 * a;\n    if(lo > w)\n    {\n        gone += -a * .5 * (lo - w) / a * (lo - w) / a + lo * (lo - w) / a;\n        t1 += (lo - w) / a;\n    }\n    t1 += (d - gone) / lo;\n    //System.out.println(t1);\n    double v0 = Math.min(lo, w);\n    double togo = l - d;\n    double toAdd = (-v0 + Math.sqrt(v0 * v0 + 4 * togo * .5 * a)) / a;\n    if(toAdd * a + v0 > v)\n    {\n        double tt = (v - v0) / a;\n        t1 += tt;\n        togo -= .5 * a * tt * tt + v0 * tt;\n        t1 += togo / v;\n    }\n    else t1 += toAdd;\n    System.out.println(t1);\n}\nstatic boolean can(double v, double a, double d, double max)\n{\n    double t1 = v / a;\n    double distGone = .5 * a * t1 * t1;\n    if(v > max)\n    {\n        t1 = (v - max) / a;\n        distGone += -.5 * a * t1 * t1 + v * t1;\n    }\n    return distGone <= d;\n}\n}\n", "index": 876, "complexity": 1}
{"back-translation": "class Ideone { public static int countOnes(int arr[], int low, int high) { if(high >= low) { int mid = low + (high - low)/2; if ((mid == high || arr[mid + 1] == 0) && (arr[mid] == 1)) return mid + 1; if (arr[mid] == 1) return countOnes(arr, (mid + 1), high); return countOnes(arr, low, (mid - 1)); } return 0; } public static void main (String[] args) throws java.lang.Exception { int arr[] = {1, 1, 1, 1, 0, 0, 0}; int n = arr.length; System.out.println(\"Count of 1's in given array is \" + countOnes(arr, 0, n - 1)); } }", "src": "/**\n* Given a binary array sorted in non-increasing order, count the number of 1\u2019s in it. \n**/\n/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Ideone\n{\tpublic static int countOnes(int arr[], int low, int high)\n\t{\n  \t\tif(high >= low)\n  \t\t{\n    \t\t// get the middle index\n    \t\tint mid = low + (high - low)/2;\n\n    \t\t// check if the element at middle index is last 1\n    \t\tif ( (mid == high || arr[mid+1] == 0) && (arr[mid] == 1))\n      \t\t\treturn mid+1;\n\n    \t\t// If element is not last 1, recur for right side\n    \t\tif (arr[mid] == 1)\n      \t\t\treturn countOnes(arr, (mid + 1), high);\n\n    \t\t// else recur for left side\n    \t\treturn countOnes(arr, low, (mid -1));\n  \t\t}\n  \t\treturn 0;\n\t}\n\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    int arr[] = {1, 1, 1, 1, 0, 0, 0};\n      int n = arr.length;\n      System.out.println(\"Count of 1's in given array is \" + countOnes(arr, 0, n-1));\n\t}\n", "index": 878, "complexity": 2}
{"back-translation": "public class FloorInSortedArray2 {\n    public static int floor(int[] A, int val) {\n        if (val < A[0]) {\n            throw new IllegalArgumentException(\"All elements are greater than val\");\n        } else if (val > A[A.length - 1]) {\n            return A[A.length - 1];\n        }\n        return floor(A, 0, A.length - 1, val);\n    }\n\n    private static int floor(int[] A, int l, int r, int val) {\n        if (l > r) {\n            throw new IllegalArgumentException(\"Not found\");\n        }\n        int mid = (l + r) / 2;\n        if (val == A[mid]) {\n            return A[mid];\n        } else if (val < A[mid]) {\n            if (val >= A[mid - 1]) {\n                return A[mid - 1];\n            }\n            return floor(A, l, mid - 1, val);\n        } else {\n            if (val < A[mid + 1]) {\n                return A[mid];\n            }\n            return floor(A, mid + 1, r, val);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] A = new int[] {1, 3, 4, 7, 8, 12, 32, 45, 78, 98};\n        System.out.println(floor(A, 11));\n        System.out.println(floor(A, 32));\n        System.out.println(floor(A, 70));\n        System.out.println(floor(A, 125));\n    }\n}", "src": "package geek.livingstone.problems.arrays;\n\n/**\n * Full problem at\n * http://www.geeksforgeeks.org/search-floor-and-ceil-in-a-sorted-array/\n * \n * @author emmanuel\n * \n */\npublic class FloorInSortedArray {\n\tpublic static int floor(int[] A, int val) throws Exception {\n\t\tif (val < A[0])\n\t\t\tthrow new Exception(\"All elements are greater than val\");\n\t\telse if (val > A[A.length - 1])\n\t\t\treturn A[A.length - 1];\n\t\treturn floor(A, 0, A.length - 1, val);\n\t}\n\n\tprivate static int floor(int[] A, int l, int r, int val) throws Exception {\n\t\tif (l > r) {\n\t\t\tthrow new Exception(\"Not found\");\n\t\t}\n\t\tint mid = (l + r) / 2;\n\t\tif (val == A[mid])\n\t\t\treturn A[mid];\n\t\telse if (val < A[mid]) {\n\t\t\tif (val >= A[mid - 1])\n\t\t\t\treturn A[mid - 1];\n\t\t\treturn floor(A, l, mid - 1, val);\n\t\t} else {\n\t\t\tif (val < A[mid + 1])\n\t\t\t\treturn A[mid];\n\t\t\treturn floor(A, mid + 1, r, val);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[] { 1, 3, 4, 7, 8, 12, 32, 45, 78, 98 };\n\t\t// System.out.println(floor(A, -45));\n\t\tSystem.out.println(floor(A, 11));\n\t\tSystem.out.println(floor(A, 32));\n\t\tSystem.out.println(floor(A, 70));\n\t\tSystem.out.println(floor(A, 125));\n\t}\n\n}", "index": 879, "complexity": 2}
{"back-translation": "class Main { static int count(int[] arr, int x, int n) { int i; int j; i = first(arr, 0, n-1, x, n); if (i == -1) return i; j = last(arr, i, n-1, x, n); return j-i+1; } static int first(int[] arr, int low, int high, int x, int n) { if (high >= low) { int mid = (low + high)/2; if ((mid == 0 || x > arr[mid-1]) && arr[mid] == x) return mid; else if (x > arr[mid]) return first(arr, mid + 1, high, x, n); else return first(arr, low, mid - 1, x, n); } return -1; } static int last(int[] arr, int low, int high, int x, int n) { if (high >= low) { int mid = (low + high)/2; if ((mid == n-1 || x < arr[mid+1]) && arr[mid] == x) return mid; else if (x < arr[mid]) return last(arr, low, mid - 1, x, n); else return last(arr, mid + 1, high, x, n); } return -1; } public static void main(String args[]) { int arr[] = {1, 2, 2, 3, 3, 3, 3}; int x = 3; int n = arr.length; int c = count(arr, x, n); System.out.println(x + \" occurs \" + c + \" times\"); } }", "src": "\n// Java program to count occurrences \n// of an element \n\nclass\nMain \n{ \n\n/* if x is present in arr[] then returns \n\nthe count of occurrences of x, \n\notherwise returns -1. */\n\nstatic\nint\ncount(\nint\narr[], \nint\nx, \nint\nn) \n\n{ \n\n// index of first occurrence of x in arr[0..n-1] \n\nint\ni; \n\n\n// index of last occurrence of x in arr[0..n-1] \n\nint\nj; \n\n\n/* get the index of first occurrence of x */\n\ni = first(arr, \n0\n, n-\n1\n, x, n); \n\n\n/* If x doesn't exist in arr[] then return -1 */\n\nif\n(i == -\n1\n) \n\nreturn\ni; \n\n\n/* Else get the index of last occurrence of x. \n\nNote that we are only looking in the \n\nsubarray after first occurrence */\n\nj = last(arr, i, n-\n1\n, x, n); \n\n\n/* return count */\n\nreturn\nj-i+\n1\n; \n\n} \n\n\n/* if x is present in arr[] then returns the \n\nindex of FIRST occurrence of x in arr[0..n-1], \n\notherwise returns -1 */\n\nstatic\nint\nfirst(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx, \nint\nn) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n/*low + (high - low)/2;*/\n\nint\nmid = (low + high)/\n2\n; \n\nif\n( ( mid == \n0\n|| x > arr[mid-\n1\n]) && arr[mid] == x) \n\nreturn\nmid; \n\nelse\nif\n(x > arr[mid]) \n\nreturn\nfirst(arr, (mid + \n1\n), high, x, n); \n\nelse\n\nreturn\nfirst(arr, low, (mid -\n1\n), x, n); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n/* if x is present in arr[] then returns the \n\nindex of LAST occurrence of x in arr[0..n-1], \n\notherwise returns -1 */\n\nstatic\nint\nlast(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx, \nint\nn) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n/*low + (high - low)/2;*/\n\nint\nmid = (low + high)/\n2\n; \n\nif\n( ( mid == n-\n1\n|| x < arr[mid+\n1\n]) && arr[mid] == x ) \n\nreturn\nmid; \n\nelse\nif\n(x < arr[mid]) \n\nreturn\nlast(arr, low, (mid -\n1\n), x, n); \n\nelse\n\nreturn\nlast(arr, (mid + \n1\n), high, x, n); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n3\n, \n3\n, \n3\n, \n3\n}; \n\n\n// Element to be counted in arr[] \n\nint\nx = \n3\n; \n\nint\nn = arr.length; \n\nint\nc = count(arr, x, n); \n\nSystem.out.println(x+\n\" occurs \"\n+c+\n\" times\"\n); \n\n} \n} ", "index": 880, "complexity": 2}
{"back-translation": "class Minimum { static int findMin(int[] arr, int low, int high) { if(high < low) return arr[0]; if(high == low) return arr[low]; int mid = (low + high) / 2; if(mid < high && arr[mid+1] < arr[mid]) return arr[mid+1]; if(mid > low && arr[mid] < arr[mid - 1]) return arr[mid]; if(arr[high] > arr[mid]) return findMin(arr, low, mid-1); return findMin(arr, mid+1, high); } public static void main(String[] args) { int arr1[] = {5, 6, 1, 2, 3, 4}; int n1 = arr1.length; System.out.println(\"The minimum element is \"+ findMin(arr1, 0, n1-1)); int arr2[] = {1, 2, 3, 4}; int n2 = arr2.length; System.out.println(\"The minimum element is \"+ findMin(arr2, 0, n2-1)); int arr3[] = {1}; int n3 = arr3.length; System.out.println(\"The minimum element is \"+ findMin(arr3, 0, n3-1)); int arr4[] = {1, 2}; int n4 = arr4.length; System.out.println(\"The minimum element is \"+ findMin(arr4, 0, n4-1)); int arr5[] = {2, 1}; int n5 = arr5.length; System.out.println(\"The minimum element is \"+ findMin(arr5, 0, n5-1)); int arr6[] = {5, 6, 7, 1, 2, 3, 4}; int n6 = arr6.length; System.out.println(\"The minimum element is \"+ findMin(arr6, 0, n6-1)); int arr7[] = {1, 2, 3, 4, 5, 6, 7}; int n7 = arr7.length; System.out.println(\"The minimum element is \"+ findMin(arr7, 0, n7-1)); int arr8[] = {2, 3, 4, 5, 6, 7, 8, 1}; int n8 = arr8.length; System.out.println(\"The minimum element is \"+ findMin(arr8, 0, n8-1)); int arr9[] = {3, 4, 5, 1, 2}; int n9 = arr9.length; System.out.println(\"The minimum element is \"+ findMin(arr9, 0, n9-1)); } }", "src": "\n// Java program to find minimum element in a sorted and rotated array \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nMinimum \n{ \n\nstatic\nint\nfindMin(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n// This condition is needed to handle the case when array \n\n// is not rotated at all \n\nif\n(high < low) \nreturn\narr[\n0\n]; \n\n\n// If there is only one element left \n\nif\n(high == low) \nreturn\narr[low]; \n\n\n// Find mid \n\nint\nmid = low + (high - low)/\n2\n; \n/*(low + high)/2;*/\n\n\n// Check if element (mid+1) is minimum element. Consider \n\n// the cases like {3, 4, 5, 1, 2} \n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\narr[mid+\n1\n]; \n\n\n// Check if mid itself is minimum element \n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n// Decide whether we need to go to left half or right half \n\nif\n(arr[high] > arr[mid]) \n\nreturn\nfindMin(arr, low, mid-\n1\n); \n\nreturn\nfindMin(arr, mid+\n1\n, high); \n\n} \n\n\n// Driver Program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr1[] = {\n5\n, \n6\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr1, \n0\n, n1-\n1\n)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr2, \n0\n, n2-\n1\n)); \n\n\nint\narr3[] = {\n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr3, \n0\n, n3-\n1\n)); \n\n\nint\narr4[] = {\n1\n, \n2\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr4, \n0\n, n4-\n1\n)); \n\n\nint\narr5[] = {\n2\n, \n1\n}; \n\nint\nn5 = arr5.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr5, \n0\n, n5-\n1\n)); \n\n\nint\narr6[] = {\n5\n, \n6\n, \n7\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn6 = arr6.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr6, \n0\n, n6-\n1\n)); \n\n\nint\narr7[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn7 = arr7.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr7, \n0\n, n7-\n1\n)); \n\n\nint\narr8[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n1\n}; \n\nint\nn8 = arr8.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr8, \n0\n, n8-\n1\n)); \n\n\nint\narr9[] = {\n3\n, \n4\n, \n5\n, \n1\n, \n2\n}; \n\nint\nn9 = arr9.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr9, \n0\n, n9-\n1\n)); \n\n} \n} ", "index": 881, "complexity": 2}
{"back-translation": "class Main { static int ceilSearch(int arr[], int low, int high, int x) { int mid; if (x <= arr[low]) return low; if (x > arr[high]) return -1; mid = (low + high)/2; if (arr[mid] == x) return mid; else if (arr[mid] < x) { if (mid + 1 <= high && x <= arr[mid+1]) return mid + 1; else return ceilSearch(arr, mid+1, high, x); } else { if (mid - 1 >= low && x > arr[mid-1]) return mid; else return ceilSearch(arr, low, mid - 1, x); } } public static void main (String[] args) { int arr[] = { 1, 2, 8, 10, 10, 12, 19 }; int n = arr.length; int x = 8; int index = ceilSearch(arr, 0, n-1, x); if (index == -1) System.out.println('Ceiling of ' + x + ' doesn\\'t exist in array'); else System.out.println('ceiling of ' + x + ' is ' + arr[index]); } }", "src": "\nclass\nMain \n{ \n\n/* Function to get index of \n\nceiling of x in arr[low..high]*/\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\nmid; \n\n\n/* If x is smaller than or equal to the \n\nfirst element, then return the first element */\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n/* If x is greater than the last \n\nelement, then return -1 */\n\nif\n(x > arr[high]) \n\nreturn\n-\n1\n; \n\n\n/* get the index of middle element \n\nof arr[low..high]*/\n\nmid = (low + high)/\n2\n; \n/* low + (high - low)/2 */\n\n\n/* If x is same as middle element, \n\nthen return mid */\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n/* If x is greater than arr[mid], then \n\neither arr[mid + 1] is ceiling of x or \n\nceiling lies in arr[mid+1...high] */\n\nelse\nif\n(arr[mid] < x) \n\n{ \n\nif\n(mid + \n1\n<= high && x <= arr[mid+\n1\n]) \n\nreturn\nmid + \n1\n; \n\nelse\n\nreturn\nceilSearch(arr, mid+\n1\n, high, x); \n\n} \n\n\n/* If x is smaller than arr[mid], \n\nthen either arr[mid] is ceiling of x \n\nor ceiling lies in arr[mid-1...high] */\n\nelse\n\n{ \n\nif\n(mid - \n1\n>= low && x > arr[mid-\n1\n]) \n\nreturn\nmid; \n\nelse\n\nreturn\nceilSearch(arr, low, mid - \n1\n, x); \n\n} \n\n} \n\n\n\n/* Driver program to check above functions */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n8\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n} ", "index": 882, "complexity": 2}
{"back-translation": "public class FirstOccurrenceOfNumberInSortedArray {\n    \n    public int firstOccurrence(int[] input, int x) {\n        int low = 0;\n        int high = input.length - 1;\n        \n        while (low <= high) {\n            int middle = (low + high) / 2;\n            if (input[middle] == x && (middle == 0 || input[middle - 1] < x)) {\n                return middle;\n            } else if (input[middle] < x) {\n                low = middle + 1;\n            } else {\n                high = middle - 1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        FirstOccurrenceOfNumberInSortedArray fos = new FirstOccurrenceOfNumberInSortedArray();\n        int[] input = {1, 2, 2, 2, 2, 2, 5, 7, 7};\n        System.out.println(fos.firstOccurrence(input, 6));\n    }\n}", "src": "package com.interview.binarysearch;\n\n/**\n * http://www.geeksforgeeks.org/check-for-majority-element-in-a-sorted-array/\n */\npublic class FirstOccurrenceOfNumberInSortedArray {\n\n    public int firstOccurrence(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        \n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x && (middle == 0 || input[middle-1] < x)){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        FirstOccurrenceOfNumberInSortedArray fos = new FirstOccurrenceOfNumberInSortedArray();\n        int input[] = {1,2,2,2,2,2,5,7,7};\n        System.out.println(fos.firstOccurrence(input, 6));\n    }\n    \n}", "index": 883, "complexity": 2}
{"back-translation": "package com.interview.binarysearch;\n\npublic class MonotonicallyIncreasingFunctionBecomesPositive {\n\n    private int f(int x){\n        return x*x - 10*x - 20;\n    }\n    \n    public int findPoint(){\n        int i=1;\n        while(f(i) <=0 ){\n            i = i*2;\n        }\n        return binarySearch(i/2, i);\n    }\n    \n    private int binarySearch(int start, int end){\n        int mid = (start+end)/2;\n        while(start < end){\n            mid = (start+end)/2;\n            if(f(mid) >0 && f(mid-1) <=0){\n                return mid;\n            }\n            if(f(mid) <=0 && f(mid+1) >0){\n                return mid+1;\n            }\n            if(f(mid) <= 0){\n                start = mid+1;\n            }else{\n                end = mid-1;\n            }\n        }\n        return mid;\n    }\n    \n    public static void main(String args[]) {\n        MonotonicallyIncreasingFunctionBecomesPositive mif = new MonotonicallyIncreasingFunctionBecomesPositive();\n        System.out.print(mif.findPoint());\n    }\n}", "src": "package com.interview.binarysearch;\n\n/**\n * http://www.geeksforgeeks.org/find-the-point-where-a-function-becomes-negative/\n */\npublic class MonotonicallyIncreasingFunctionBecomesPositive {\n\n    private int f(int x){\n        return x*x - 10*x - 20;\n    }\n    \n    public int findPoint(){\n        int i=1;\n        while(f(i) <=0 ){\n            i = i*2;\n        }\n        return binarySearch(i/2,i);\n    }\n    \n    private int binarySearch(int start,int end){\n        int mid = (start+end)/2;\n        while(start < end){\n            mid = (start+end)/2;\n            if(f(mid) >0 && f(mid-1) <=0){\n                return mid;\n            }\n            if(f(mid) <=0 && f(mid+1)>0){\n                return mid+1;\n            }\n            if(f(mid) <= 0){\n                start = mid+1;\n            }else{\n                end = mid-1;\n            }\n        }\n        return mid;\n    }\n    \n    public static void main(String args[]){\n        MonotonicallyIncreasingFunctionBecomesPositive mif = new MonotonicallyIncreasingFunctionBecomesPositive();\n        System.out.print(mif.findPoint());\n    }\n}\n", "index": 884, "complexity": 2}
{"back-translation": "import java.io.*;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void solve() {\n        int t = in.nextInt();\n\n        for (int sdfsdf = 0; sdfsdf < t; sdfsdf++) {\n            long n = in.nextLong();\n            long k = in.nextLong();\n\n            if (n == 1) {\n                if (k == 1)  {\n                    out.println(\"YES 0\");\n                } else {\n                    out.println(\"NO\");\n                }\n                continue;\n            }\n\n            if (k == 3) {\n                if (n == 2) {\n                    out.println(\"NO\");\n                } else {\n                    out.println(\"YES \" + (n - 1));\n                }\n                continue;\n            }\n\n            long cuts = 1;\n            long squares = 4;\n            int zoom = 1;\n\n            while (k > cuts + squares) {\n                cuts += squares;\n                squares *= 4;\n                zoom++;\n            }\n\n            if (zoom > n) {\n                out.println(\"NO\");\n                continue;\n            }\n\n            if (zoom == n && k > cuts) {\n                out.println(\"NO\");\n                continue;\n            }\n\n            long current_cuts = k - cuts;\n\n            if (current_cuts > squares - (2L * Math.sqrt(squares) - 1L)) {\n                out.println(\"YES \" + (n - zoom - 1L));\n            } else {\n                out.println(\"YES \" + (n - zoom));\n            }\n        }\n    }\n}", "src": "import java.io.*;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    void run() {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void solve() {\n        int t = in.nextInt();\n\n        for (int sdfsdf = 0; sdfsdf < t; sdfsdf++) {\n            long n = in.nextLong();\n            long k = in.nextLong();\n\n            if (n == 1) {\n                if (k == 1)  {\n                    out.println(\"YES 0\");\n                } else {\n                    out.println(\"NO\");\n                }\n                continue;\n            }\n\n            if (k == 3) {\n                if (n == 2) {\n                    out.println(\"NO\");\n                } else {\n                    out.println(\"YES \" + (n - 1));\n                }\n                continue;\n            }\n\n            long cuts = 1;\n            long squares = 4;\n            int zoom = 1;\n\n            while (k > cuts + squares) {\n                cuts += squares;\n                squares *= 4;\n                zoom++;\n            }\n\n            if (zoom > n) {\n                out.println(\"NO\");\n                continue;\n            }\n\n            if (zoom == n && k > cuts) {\n                out.println(\"NO\");\n                continue;\n            }\n\n            long current_cuts = k - cuts;\n\n            if (current_cuts > squares - (2L * Math.sqrt(squares) - 1L)) {\n                out.println(\"YES \" + (n - zoom - 1L));\n            } else {\n                out.println(\"YES \" + (n - zoom));\n            }\n        }\n    }\n}\n", "index": 885, "complexity": 2}
{"back-translation": "public class Main { static class TaskB { FastReader in; PrintWriter out; int n; public void solve(int testNumber, FastReader in, PrintWriter out) { this.in = in; this.out = out; n = in.nextInt(); if (n % 4 != 0) { out.println(\"! -1\"); return; } int low = 0; int high = n >> 1; if (BValue(low) == 0) { out.println(\"! \" + (low + 1)); return; } boolean value = BValue(low) > 0; while (high - low > 1) { int mid = (high + low) >> 1; int BVal = BValue(mid); if (BVal == 0) { out.println(\"! \" + (mid + 1)); return; } if (value) { if (BVal < 0) { high = mid; } else { low = mid; } } else { if (BVal > 0) { high = mid; } else { low = mid; } } } out.println(\"! -1\"); } public int BValue(int index) { out.println(\"? \" + (index + 1)); out.flush(); int f = in.nextInt(); out.println(\"? \" + (index + 1 + (n >> 1))); out.flush(); int s = in.nextInt(); return f - s; } } static class FastReader { private InputStream stream; private byte[] buf = new byte[8192]; private int curChar; private int pnumChars; public FastReader(InputStream stream) { this.stream = stream; } private int pread() { if (pnumChars == -1) { throw new InputMismatchException(); } if (curChar >= pnumChars) { curChar = 0; try { pnumChars = stream.read(buf); } catch (IOException e) { throw new InputMismatchException(); } if (pnumChars <= 0) { return -1; } } return buf[curChar++]; } public int nextInt() { int c = pread(); while (isSpaceChar(c)) c = pread(); int sgn = 1; if (c == '-') { sgn = -1; c = pread(); } int res = 0; do { if (c == ',') c = pread(); if (c < '0' || c > '9') { throw new InputMismatchException(); } res *= 10; res += c - '0'; c = pread(); } while (!isSpaceChar(c)); return res * sgn; } private boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } } public static void main(String[] args) { InputStream inputStream = System.in; OutputStream outputStream = System.out; FastReader in = new FastReader(inputStream); PrintWriter out = new PrintWriter(outputStream); TaskB solver = new TaskB(); solver.solve(1, in, out); out.close(); } }", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        FastReader in;\n        PrintWriter out;\n        int n;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.nextInt();\n            if (n % 4 != 0) {\n                out.println(\"! -1\");\n                return;\n            }\n            int low = 0;\n            int high = n >> 1;\n            if (BValue(low) == 0) {\n                out.println(\"! \" + (low + 1));\n                return;\n            }\n            boolean value = BValue(low) > 0;\n            while (high - low > 1) {\n                int mid = (high + low) >> 1;\n                int BVal = BValue(mid);\n                if (BVal == 0) {\n                    out.println(\"! \" + (mid + 1));\n                    return;\n                }\n                if (value) {\n                    if (BVal < 0) {\n                        high = mid;\n                    } else {\n                        low = mid;\n                    }\n                } else {\n                    if (BVal > 0) {\n                        high = mid;\n                    } else {\n                        low = mid;\n                    }\n                }\n            }\n            out.println(\"! -1\");\n        }\n\n        public int BValue(int index) {\n            out.println(\"? \" + (index + 1));\n            out.flush();\n            int f = in.nextInt();\n            out.println(\"? \" + (index + 1 + (n >> 1)));\n            out.flush();\n            int s = in.nextInt();\n            return f - s;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "index": 886, "complexity": 2}
{"back-translation": "private static int findCeil(int[] arr, int low, int high, int x) {if (x <= arr[low]) return low;if (x > arr[high]) return -1;int mid = low + (high - low) / 2;if (arr[mid] == x) return mid;else if (x > arr[mid]) {if (mid + 1 <= high && x <= arr[mid + 1]) return mid + 1;else return findCeil(arr, mid + 1, high, x);} else {if (mid - 1 >= low && x > arr[mid - 1]) return mid;else return findCeil(arr, low, mid - 1, x);}}", "src": "package com.interview.algorithms.array;\n\n/**\n * Given a sorted array and a value x, the ceiling of x is the smallest element\n * in array greater than or equal to x, and the floor is the greatest element\n * smaller than or equal to x. Assume than the array is sorted in non-decreasing\n * order. Write efficient functions to find floor and ceiling of x.\n * \n * For example, let the input array be {1, 2, 8, 10, 10, 12, 19}\n *  For x = 0:floor doesn't exist in array, ceil = 1\n *  For x = 1: floor = 1, ceil = 1 \n *  For x = 5: floor = 2, ceil = 8\n *   For x = 20: floor= 19, ceil doesn't exist in array\n *\n *\n * @author ajitkoti\n */\npublic class FloorAndCeilingInASortedArray {\n\n\t/**\n\t * Instead of using linear search, binary search is used here to find out\n\t * the index. Binary search reduces time complexity to O(Logn).\n\t * \n\t * @param arr\n\t * @param low\n\t * @param high\n\t * @param x\n\t * @return\n\t */\n\tprivate static int ceilSearch(int arr[], int low, int high, int x) {\n\t\tint mid;\n\n\t\t/*\n\t\t * If x is smaller than or equal to the first element, then return the\n\t\t * first element\n\t\t */\n\t\tif (x <= arr[low])\n\t\t\treturn low;\n\n\t\t/* If x is greater than the last element, then return -1 */\n\t\tif (x > arr[high])\n\t\t\treturn -1;\n\n\t\t/* get the index of middle element of arr[low..high] */\n\t\tmid = (low + high) / 2; /* low + (high - low)/2 */\n\n\t\t/* If x is same as middle element, then return mid */\n\t\tif (arr[mid] == x)\n\t\t\treturn mid;\n\n\t\t/*\n\t\t * If x is greater than arr[mid], then either arr[mid + 1] is ceiling of\n\t\t * x or ceiling lies in arr[mid+1...high]\n\t\t */\n\t\telse if (x > arr[mid]) {\n\t\t\tif (mid + 1 <= high && x <= arr[mid + 1])\n\t\t\t\treturn mid + 1;\n\t\t\telse\n\t\t\t\treturn ceilSearch(arr, mid + 1, high, x);\n\t\t}\n\n\t\t/*\n\t\t * If x is smaller than arr[mid], then either arr[mid] is ceiling of x\n\t\t * or ceiling lies in arr[mid-1...high]\n\t\t */\n\t\telse {\n\t\t\tif (mid - 1 >= low && x > arr[mid - 1])\n\t\t\t\treturn mid;\n\t\t\telse\n\t\t\t\treturn ceilSearch(arr, low, mid - 1, x);\n\t\t}\n\t}\n\n\t/* Driver program to check above functions */\n\tpublic static void main(String[] args) {\n\t\tint arr[] = { 1, 2, 8, 10, 10, 12, 19 };\n\t\tint n = arr.length;\n\t\tint x = 11;\n\t\tint index = ceilSearch(arr, 0, n - 1, x);\n\t\tif (index == -1)\n\t\t\tSystem.out.println(\"Ceiling of doesn't exist in array \" + x);\n\t\telse\n\t\t\tSystem.out.println(\"ceiling of\" + x + \" is \" + arr[index]);\n\n\t}\n\n}", "index": 887, "complexity": 2}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class NastyaWardrobe {\n    static long modulo = 1000000007;\n    static long ans = 0;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader inp = new BufferedReader(new InputStreamReader(System.in));\n        String[] s1 = inp.readLine().split(\" \");\n        long clothes = Long.parseLong(s1[0]);\n        long months = Long.parseLong(s1[1]);\n        calc(clothes, months);\n        System.out.print(ans);\n    }\n\n    static void calc(long clothes, long months) {\n        if (clothes != 0) {\n            long a;\n            long count = 0;\n            ArrayList<Long> list = new ArrayList<>();\n            if (months >= 2) {\n                a = 2;\n                long c = months;\n                while (c > 1) {\n                    if (c % 2 == 1) {\n                        count++;\n                        list.add(a);\n                    }\n                    c = c / 2;\n                    a = (a * a) % modulo;\n                }\n                while (count > 0) {\n                    long b = list.get(0);\n                    list.remove(0);\n                    a = (a * b) % modulo;\n                    count--;\n                }\n            } else {\n                a = (long) Math.pow(2, months);\n            }\n            long b = clothes;\n            b = (2 * b - 1) % modulo;\n            ans = (a * b) % modulo;\n            ans = (ans + 1) % modulo;\n        } else {\n            ans = 0;\n        }\n    }\n}", "src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\n\npublic class NastyaWardrobe {\n    static long modulo = 1000000007;\n    static long ans = 0;\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader inp = new BufferedReader(new InputStreamReader(System.in));\n        String[] s1 = inp.readLine().split(\" \");\n        long clothes = Long.parseLong(s1[0]);\n        long months = Long.parseLong(s1[1]);\n\n        //formula 2^k(2x-1)+1;\n        calc(clothes,months);\n        System.out.print(ans);\n    }\n    static void calc(long clothes,long months){\n        if(clothes!=0) {\n            long a;\n            long count = 0;\n            ArrayList<Long> list = new ArrayList<>();\n            if (months >= 2) {\n                a = 2;\n                long c = months;\n\n                while (c > 1) {\n                    if (c % 2 == 1) {\n                        count++;\n                        list.add(a);\n                    }\n                    c = c / 2;\n\n                    a = (a * a) % modulo;\n                }\n                while (count > 0) {\n                    long b = list.get(0);\n                    list.remove(0);\n                    a = (a * b) % modulo;\n                    count--;\n                }\n\n            } else {\n                a = (long) Math.pow(2, months);\n            }\n\n\n            long b = clothes;\n\n            //System.out.println(b);\n            b = (2 * b - 1) % modulo;\n            ans = (a * b) % modulo;\n            ans = (ans + 1) % modulo;\n        }else{\n            ans = 0;\n        }\n\n    }\n}\n", "index": 888, "complexity": 2}
{"back-translation": "class BinarySearch { static int countRotations(int[] arr, int low, int high) { if(low > high) return 0; if(low == high) return low; int mid = low + (high - low)/2; if(mid < high && arr[mid+1] < arr[mid]) return (mid + 1); if(mid > low && arr[mid] < arr[mid - 1]) return mid; if(arr[high] > arr[mid]) return countRotations(arr, low, mid - 1); return countRotations(arr, mid + 1, high); } public static void main(String[] args) { int arr[] = {15, 18, 2, 3, 6, 12}; int n = arr.length; System.out.println(countRotations(arr, 0, n-1)); } }", "src": "\n// Java program to find number of \n// rotations in a sorted and rotated \n// array. \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nBinarySearch \n{ \n\n// Returns count of rotations for an array \n\n// which is first sorted in ascending order, \n\n// then rotated \n\nstatic\nint\ncountRotations(\nint\narr[], \nint\nlow, \n\nint\nhigh) \n\n{ \n\n// This condition is needed to handle \n\n// the case when array is not rotated \n\n// at all \n\nif\n(high < low) \n\nreturn\n0\n; \n\n\n// If there is only one element left \n\nif\n(high == low) \n\nreturn\nlow; \n\n\n// Find mid \n\n// /*(low + high)/2;*/ \n\nint\nmid = low + (high - low)/\n2\n; \n\n\n// Check if element (mid+1) is minimum \n\n// element. Consider the cases like \n\n// {3, 4, 5, 1, 2} \n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\n(mid + \n1\n); \n\n\n// Check if mid itself is minimum element \n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\nmid; \n\n\n// Decide whether we need to go to left \n\n// half or right half \n\nif\n(arr[high] > arr[mid]) \n\nreturn\ncountRotations(arr, low, mid - \n1\n); \n\n\nreturn\ncountRotations(arr, mid + \n1\n, high); \n\n} \n\n\n// Driver program to test above functions \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n15\n, \n18\n, \n2\n, \n3\n, \n6\n, \n12\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(countRotations(arr, \n0\n, n-\n1\n)); \n\n} \n} \n// This code is contributed by Chhavi ", "index": 889, "complexity": 2}
{"back-translation": "public class SortedAndRotatedArraySearch {\n    public int search(int[] arr, int search) {\n        int low = 0;\n        int high = arr.length - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (arr[mid] == search) {\n                return mid;\n            }\n            if (arr[mid] < arr[high]) {\n                if (arr[mid] < search && search <= arr[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if (search >= arr[low] && search < arr[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return -1;\n    }\n    public boolean searchWithDuplicates(int[] arr, int search) {\n        int low = 0;\n        int high = arr.length - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (arr[mid] == search) {\n                return true;\n            }\n            if (arr[mid] == arr[low]) {\n                low++;\n            } else if (arr[mid] == arr[high]) {\n                high--;\n            } else if (arr[mid] < arr[high]) {\n                if (arr[mid] < search && search <= arr[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if (search >= arr[low] && search < arr[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        SortedAndRotatedArraySearch ras = new SortedAndRotatedArraySearch();\n        int[] arr1 = {1, 2, 5, 6, 7, 8, 11, 21};\n        System.out.print(ras.search(arr1, 1));\n        System.out.print(ras.search(arr1, 5));\n        System.out.print(ras.search(arr1, 22));\n        System.out.println();\n        int[] arr2 = {18, 21, 1, 2, 5, 6, 7, 8, 10, 15};\n        System.out.print(ras.search(arr2, 1));\n        System.out.print(ras.search(arr2, 5));\n        System.out.print(ras.search(arr2, 10));\n        System.out.print(ras.search(arr2, 14));\n        System.out.println();\n        int[] arr3 = {7, 8, 15, 17, 18, 21, 1, 2, 5, 6};\n        System.out.print(ras.search(arr3, 1));\n        System.out.print(ras.search(arr3, 5));\n        System.out.print(ras.search(arr3, 10));\n        System.out.print(ras.search(arr3, 7));\n        System.out.print(ras.search(arr3, 6));\n        System.out.print(ras.search(arr3, 16));\n    }\n}", "src": "package com.interview.binarysearch;\n\n/**\n * @author Tushar Roy\n * Date 01/22/17\n *\n * Search in sorted and rotated array. In one version duplicate is not allowed and\n * in another version duplicate is allowed.\n *\n * Time complexity with no duplicate - O(logn)\n * Time complexity with duplicates - O(n)\n *\n * https://leetcode.com/problems/search-in-rotated-sorted-array/\n * https://leetcode.com/problems/search-in-rotated-sorted-array-ii/\n */\npublic class SortedAndRotatedArraySearch {\n\n    /**\n     * Duplicates are not allowed in arr.\n     */\n    public int search(int arr[],int search){\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search){\n                return mid;\n            }\n            \n            if(arr[mid] < arr[high]){\n                if(arr[mid] < search && search <= arr[high]){\n                    low = mid+1;\n                }else{\n                    high = mid-1;\n                }\n            }else{\n                if(search >= arr[low] && search < arr[mid]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Duplicates are allowed in arr.\n     */\n    public boolean searchWithDuplicates(int[] arr, int search) {\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search) {\n                return true;\n            }\n            //if low is same as mid then increment low.\n            if (arr[mid] == arr[low]) {\n                low++;\n            } else if (arr[mid] == arr[high]) { //if high is same as mid then decrement high.\n                high--;\n            } else if (arr[mid] < arr[high]) {\n                if(arr[mid] < search && search <= arr[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if(search >= arr[low] && search < arr[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String args[]){\n        SortedAndRotatedArraySearch ras = new SortedAndRotatedArraySearch();\n        int arr1[] = {1,2,5,6,7,8,11,21};\n        System.out.print(ras.search(arr1, 1));\n        System.out.print(ras.search(arr1, 5));\n        System.out.print(ras.search(arr1, 22));\n        System.out.println();\n    \n        int arr2[] = {18,21,1,2,5,6,7,8,10,15};\n        System.out.print(ras.search(arr2, 1));\n        System.out.print(ras.search(arr2, 5));\n        System.out.print(ras.search(arr2, 10));\n        System.out.print(ras.search(arr2, 14));\n        System.out.println();\n\n        int arr3[] = {7,8,15,17,18,21,1,2,5,6};\n        System.out.print(ras.search(arr3, 1));\n        System.out.print(ras.search(arr3, 5));\n        System.out.print(ras.search(arr3, 10));\n        System.out.print(ras.search(arr3, 7));\n        System.out.print(ras.search(arr3, 6));\n        System.out.print(ras.search(arr3, 16));\n    }\n}", "index": 890, "complexity": 2}
{"back-translation": "static int getMedian(int[] ar1, int[] ar2, int n) { if (n <= 0) return -1; if (n == 1) return (ar1[0] + ar2[0]) / 2; if (n == 2) return (Math.max(ar1[0], ar2[0]) + Math.min(ar1[1], ar2[1])) / 2; int m1 = median(ar1, n); int m2 = median(ar2, n); if (m1 == m2) return m1; if (m1 < m2) { if (n % 2 == 0) return getMedian(Arrays.copyOfRange(ar1, n / 2 - 1, n), ar2, n - n / 2 + 1); return getMedian(Arrays.copyOfRange(ar1, n / 2, n), ar2, n - n / 2); } if (n % 2 == 0) return getMedian(Arrays.copyOfRange(ar2, n / 2 - 1, n), ar1, n - n / 2 + 1); return getMedian(Arrays.copyOfRange(ar2, n / 2, n), ar1, n - n / 2); } static int median(int[] arr, int n) { if (n % 2 == 0) return (arr[n / 2] + arr[n / 2 - 1]) / 2; else return arr[n / 2]; } public static void main(String[] args) { int[] ar1 = {1, 2, 3, 6}; int[] ar2 = {4, 6, 8, 10}; int n1 = ar1.length; int n2 = ar2.length; if (n1 == n2) System.out.println(\"Median is \" + getMedian(ar1, ar2, n1)); else System.out.println(\"Doesn't work for arrays \" + \"of unequal size\"); }", "src": "\n// A Java program to divide and conquer based \n// efficient solution to find \n// median of two sorted arrays \n// of same size. \nimport\njava.util.*; \nclass\nGfG { \n\n/* This function returns median \nof ar1[] and ar2[]. \nAssumptions in this function: \n\nBoth ar1[] and ar2[] are \n\nsorted arrays \n\nBoth have n elements */\nstatic\nint\ngetMedian(\nint\nar1[], \nint\nar2[], \nint\nn) \n{ \n\n/* return -1 for \n\ninvalid input */\n\nif\n(n <= \n0\n) \n\nreturn\n-\n1\n; \n\nif\n(n == \n1\n) \n\nreturn\n(ar1[\n0\n] + ar2[\n0\n]) / \n2\n; \n\nif\n(n == \n2\n) \n\nreturn\n(Math.max(ar1[\n0\n], ar2[\n0\n]) + Math.min(ar1[\n1\n], ar2[\n1\n])) / \n2\n; \n\n\n/* get the median of \n\nthe first array */\n\nint\nm1 = median(ar1, n); \n\n\n/* get the median of \n\nthe second array */\n\nint\nm2 = median(ar2, n); \n\n\n/* If medians are equal then \n\nreturn either m1 or m2 */\n\nif\n(m1 == m2) \n\nreturn\nm1; \n\n\n/* if m1 < m2 then median must \n\nexist in ar1[m1....] and \n\nar2[....m2] */\n\nif\n(m1 < m2) \n\n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar1 + n / \n2\n- \n1\n, ar2, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar1 + n / \n2\n, ar2, n - n / \n2\n); \n\n} \n\n\n/* if m1 > m2 then median must \n\nexist in ar1[....m1] and \n\nar2[m2...] */\n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar2 + n / \n2\n- \n1\n, ar1, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar2 + n / \n2\n, ar1, n - n / \n2\n); \n} \n\n/* Function to get median \nof a sorted array */\nstatic\nint\nmedian(\nint\narr[], \nint\nn) \n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\n(arr[n / \n2\n] + arr[n / \n2\n- \n1\n]) / \n2\n; \n\nelse\n\nreturn\narr[n / \n2\n]; \n} \n\n// Driver code \npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nar1[] = {\n1\n, \n2\n, \n3\n, \n6\n}; \n\nint\nar2[] = {\n4\n, \n6\n, \n8\n, \n10\n}; \n\nint\nn1 = ar1.length; \n\nint\nn2 = ar2.length; \n\nif\n(n1 == n2) \n\nSystem.out.println(\n\"Median is \"\n+ getMedian(ar1, ar2, n1)); \n\nelse\n\nSystem.out.println(\n\"Doesn't work for arrays \"\n+ \n\"of unequal size\"\n); \n} \n} ", "index": 894, "complexity": 2}
{"back-translation": "import java.util.*;\npublic class mad{\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int cura = 0,curb = 0;\n        int ver;\n        System.out.println(\"? 0 0\");\n        System.out.flush();\n        ver = sc.nextInt();\n        for(int i=29;i>=0;i--){\n            System.out.println(\"? \"+(cura+(1<<i))+\" \"+curb);\n            System.out.flush();\n            int temp1 = sc.nextInt();\n            System.out.println(\"? \"+cura+\" \"+(curb+(1<<i)));\n            System.out.flush();\n            int temp2 = sc.nextInt();\n            if(temp1!=temp2){\n                if(temp2==1){\n                    cura += (1<<i);\n                    curb += (1<<i);\n                }\n            }\n            else{\n                if(ver==1) cura += (1<<i);\n                if(ver==-1) curb += (1<<i);\n                \n                ver = temp1;\n            }\n        }\n        System.out.println(\"! \"+cura+\" \"+curb);\n    }\n    \n}", "src": "import java.util.*;\npublic class mad{\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int cura = 0,curb = 0;\n        int ver;\n        System.out.println(\"? 0 0\");\n        System.out.flush();\n        ver = sc.nextInt();\n        for(int i=29;i>=0;i--){\n            System.out.println(\"? \"+(cura+(1<<i))+\" \"+curb);\n            System.out.flush();\n            int temp1 = sc.nextInt();\n            System.out.println(\"? \"+cura+\" \"+(curb+(1<<i)));\n            System.out.flush();\n            int temp2 = sc.nextInt();\n            if(temp1!=temp2){\n                if(temp2==1){\n                    cura += (1<<i);\n                    curb += (1<<i);\n                }\n            }\n            else{\n                if(ver==1) cura += (1<<i);\n                if(ver==-1) curb += (1<<i);\n                \n                ver = temp1;\n            }\n        }\n        System.out.println(\"! \"+cura+\" \"+curb);\n    }\n    \n}", "index": 895, "complexity": 2}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BTheHat solver = new BTheHat();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BTheHat {\n        PrintWriter out;\n        InputReader in;\n        int n;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.out = out;\n            this.in = in;\n            n = in.NextInt();\n            int desiredPair = -1;\n            int result = query(1);\n            if (result != 0) {\n                int l = 2, r = 1 + n / 2;\n                while (l < r) {\n                    int m = (l + r) / 2;\n                    int mRes = query(m);\n                    if (mRes == 0) {\n                        desiredPair = m;\n                        break;\n                    } else if (mRes == result) {\n                        l = m + 1;\n                    } else {\n                        r = m;\n                    }\n                }\n            } else {\n                desiredPair = 1;\n            }\n            out.println(\"! \" + desiredPair);\n        }\n\n        private int query(int i) {\n            int iV = queryValue(i);\n            int iN2V = queryValue(i + n / 2);\n            if (iV < iN2V) {\n                return -1;\n            } else if (iV > iN2V) {\n                return 1;\n            }\n            return 0;\n        }\n\n        private int queryValue(int i) {\n            out.println(\"? \" + i);\n            out.flush();\n            return in.NextInt();\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kessido\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BTheHat solver = new BTheHat();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BTheHat {\n        PrintWriter out;\n        InputReader in;\n        int n;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.out = out;\n            this.in = in;\n            n = in.NextInt();\n            int desiredPair = -1;\n            int result = query(1);\n            if (result != 0) {\n                int l = 2, r = 1 + n / 2;\n                while (l < r) {\n                    int m = (l + r) / 2;\n                    int mRes = query(m);\n                    if (mRes == 0) {\n                        desiredPair = m;\n                        break;\n                    } else if (mRes == result) {\n                        l = m + 1;\n                    } else {\n                        r = m;\n                    }\n                }\n            } else {\n                desiredPair = 1;\n            }\n            out.println(\"! \" + desiredPair);\n        }\n\n        private int query(int i) {\n            int iV = queryValue(i);\n            int iN2V = queryValue(i + n / 2);\n            if (iV < iN2V) {\n                return -1;\n            } else if (iV > iN2V) {\n                return 1;\n            }\n            return 0;\n        }\n\n        private int queryValue(int i) {\n            out.println(\"? \" + i);\n            out.flush();\n            return in.NextInt();\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine(), \" \\t\\n\\r\\f,\");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "index": 896, "complexity": 2}
{"back-translation": "import java.util.*;\n\npublic class ehab4 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint a = 0, b = 0;\n\tSystem.out.println( \"? 0 0 \" );\n\tSystem.out.flush();\n\tint c = in.nextInt();\n\tfor ( int i = 29; i >= 0; i-- ) {\n\t    System.out.println( \"? \" + ( a + ( 1 << i ) ) + \" \" + b );\n\t    System.out.flush();\n\t    int q1 = in.nextInt();\n\t    System.out.println( \"? \" + a + \" \" + ( b + ( 1 << i ) ) );\n\t    System.out.flush();\n\t    int q2 = in.nextInt();\n\t    if ( q1 == q2 ) {\n\t\tif ( c == 1 )\n\t\t    a += ( 1 << i );\n\t\telse if ( c == -1 )\n\t\t    b += ( 1 << i );\n\t\tc = q1;\n\t    }\n\t    else if ( q1 == -1 ) {\n\t\ta += ( 1 << i );\n\t\tb += ( 1 << i );\n\t    }\n\t    else if ( q1 == -2 )\n\t\treturn;\n\t}\n\tSystem.out.println( \"! \" + a + \" \" + b );\n\tSystem.out.flush();\n    }\n}", "src": "import java.util.*;\n\npublic class ehab4 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint a = 0, b = 0;\n\tSystem.out.println( \"? 0 0 \" );\n\tSystem.out.flush();\n\tint c = in.nextInt();\n\tfor ( int i = 29; i >= 0; i-- ) {\n\t    System.out.println( \"? \" + ( a + ( 1 << i ) ) + \" \" + b );\n\t    System.out.flush();\n\t    int q1 = in.nextInt();\n\t    System.out.println( \"? \" + a + \" \" + ( b + ( 1 << i ) ) );\n\t    System.out.flush();\n\t    int q2 = in.nextInt();\n\t    if ( q1 == q2 ) {\n\t\tif ( c == 1 )\n\t\t    a += ( 1 << i );\n\t\telse if ( c == -1 )\n\t\t    b += ( 1 << i );\n\t\tc = q1;\n\t    }\n\t    else if ( q1 == -1 ) {\n\t\ta += ( 1 << i );\n\t\tb += ( 1 << i );\n\t    }\n\t    else if ( q1 == -2 )\n\t\treturn;\n\t}\n\tSystem.out.println( \"! \" + a + \" \" + b );\n\tSystem.out.flush();\n    }\n}\n", "index": 897, "complexity": 2}
{"back-translation": "class GFG { int binarySearch(int arr[], int l, int r, int x) { if (r >= l) { int mid = l + (r - l) / 2; if (arr[mid] == x) return mid; if (mid > l && arr[mid - 1] == x) return (mid - 1); if (mid < r && arr[mid + 1] == x) return (mid + 1); if (arr[mid] > x) return binarySearch(arr, l, mid - 2, x); return binarySearch(arr, mid + 2, r, x); } return -1; } public static void main(String args[]) { GFG ob = new GFG(); int arr[] = { 3, 2, 10, 4, 40 }; int n = arr.length; int x = 4; int result = ob.binarySearch(arr, 0, n - 1, x); if (result == -1) System.out.println(\"Element is not present in array\"); else System.out.println(\"Element is present at index \" + result); } }", "src": "\n// Java program to find an element \n// in an almost sorted array \nclass\nGFG \n{ \n\n// A recursive binary search based function. \n\n// It returns index of x in given array \n\n// arr[l..r] is present, otherwise -1 \n\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r >= l) \n\n{ \n\nint\nmid = l + (r - l) / \n2\n; \n\n\n// If the element is present at \n\n// one of the middle 3 positions \n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\nif\n(mid > l && arr[mid - \n1\n] == x) \n\nreturn\n(mid - \n1\n); \n\nif\n(mid < r && arr[mid + \n1\n] == x) \n\nreturn\n(mid + \n1\n); \n\n\n// If element is smaller than mid, then \n\n// it can only be present in left subarray \n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid - \n2\n, x); \n\n\n// Else the element can only be present \n\n// in right subarray \n\nreturn\nbinarySearch(arr, mid + \n2\n, r, x); \n\n} \n\n\n// We reach here when element is \n\n// not present in array \n\nreturn\n-\n1\n; \n\n} \n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nGFG ob = \nnew\nGFG(); \n\nint\narr[] = {\n3\n, \n2\n, \n10\n, \n4\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n4\n; \n\nint\nresult = ob.binarySearch(arr, \n0\n, n - \n1\n, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element is not present in array\"\n); \n\nelse\n\nSystem.out.println(\n\"Element is present at index \"\n+ \n\nresult); \n\n} \n} \n\n// This code is contributed by Rajat Mishra ", "index": 898, "complexity": 2}
{"back-translation": "import java.util.*; class Binary { public static int f(int x) { return x * x - 10 * x - 20; } public static int findFirstPositive() { if (f(0) > 0) return 0; int i = 1; while (f(i) <= 0) i = i * 2; return binarySearch(i / 2, i); } public static int binarySearch(int low, int high) { if (high >= low) { int mid = low + (high - low) / 2; if (f(mid) > 0 && (mid == low || f(mid - 1) <= 0)) return mid; if (f(mid) <= 0) return binarySearch((mid + 1), high); else return binarySearch(low, (mid - 1)); } return -1; } public static void main(String[] args) { System.out.print(\"The value n where f() \" + \"becomes positive first is \" + findFirstPositive()); } }", "src": "\n// Java program for Binary Search \nimport\njava.util.*; \n\nclass\nBinary \n{ \n\npublic\nstatic\nint\nf(\nint\nx) \n\n{ \nreturn\n(x*x - \n10\n*x - \n20\n); } \n\n\n// Returns the value x where above \n\n// function f() becomes positive \n\n// first time. \n\npublic\nstatic\nint\nfindFirstPositive() \n\n{ \n\n// When first value itself is positive \n\nif\n(f(\n0\n) > \n0\n) \n\nreturn\n0\n; \n\n\n// Find 'high' for binary search \n\n// by repeated doubling \n\nint\ni = \n1\n; \n\nwhile\n(f(i) <= \n0\n) \n\ni = i * \n2\n; \n\n\n// Call binary search \n\nreturn\nbinarySearch(i / \n2\n, i); \n\n} \n\n\n// Searches first positive value of \n\n// f(i) where low <= i <= high \n\npublic\nstatic\nint\nbinarySearch(\nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n/* mid = (low + high)/2 */\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n// If f(mid) is greater than 0 and \n\n// one of the following two \n\n// conditions is true: \n\n// a) mid is equal to low \n\n// b) f(mid-1) is negative \n\nif\n(f(mid) > \n0\n&& (mid == low || f(mid-\n1\n) <= \n0\n)) \n\nreturn\nmid; \n\n\n// If f(mid) is smaller than or equal to 0 \n\nif\n(f(mid) <= \n0\n) \n\nreturn\nbinarySearch((mid + \n1\n), high); \n\nelse\n// f(mid) > 0 \n\nreturn\nbinarySearch(low, (mid -\n1\n)); \n\n} \n\n\n/* Return -1 if there is no positive \n\nvalue in given range */\n\nreturn\n-\n1\n; \n\n} \n\n\n// driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print (\n\"The value n where f() \"\n+ \n\n\"becomes positive first is \"\n+ \n\nfindFirstPositive()); \n\n} \n} \n\n// This code is contributed by rishabh_jain ", "index": 900, "complexity": 2}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class OlyaAndMagicalSquare {\n    void solve() {\n        long[] dp = new long[32];\n        dp[0] = 0;\n        for (int i = 1; i < 32; i++) {\n            dp[i] = 4 * dp[i - 1] + 1;\n        }\n\n        int T = in.nextInt();\n        L:\n        while (T-- > 0) {\n            int n = in.nextInt();\n            long k = in.nextLong();\n\n            if (n > 31) {\n                out.println(\"YES \" + (n - 1));\n                continue;\n            }\n\n            long tot = 0;\n            for (int a = n - 1; a >= 0; a--) {\n                k -= (1L << (n - a)) - 1;\n                if (k < 0) break;\n                if (k == 0) {\n                    out.println(\"YES \" + a);\n                    continue L;\n                }\n                long limit = (1L << (n + 1 - a)) - 3;\n                if (k <= tot || dp[a] > 0 && (k - tot + dp[a] - 1) / dp[a] <= limit) {\n                    out.println(\"YES \" + a);\n                    continue L;\n                }\n                tot += dp[a] * limit;\n            }\n            out.println(\"NO\");\n        }\n    }\n\n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new OlyaAndMagicalSquare().solve();\n        out.close();\n    }\n\n    static FastScanner in;\n    static PrintWriter out;\n\n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n\n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class OlyaAndMagicalSquare {\n    void solve() {\n        long[] dp = new long[32];\n        dp[0] = 0;\n        for (int i = 1; i < 32; i++) {\n            dp[i] = 4 * dp[i - 1] + 1;\n        }\n        \n        int T = in.nextInt();\n        L:\n        while (T-- > 0) {\n            int n = in.nextInt(); long k = in.nextLong();\n            \n            if (n > 31) {\n                out.println(\"YES \" + (n - 1));\n                continue;\n            }\n            \n            long tot = 0;\n            for (int a = n - 1; a >= 0; a--) {\n                k -= (1L << (n - a)) - 1;\n                if (k < 0) break;\n                if (k == 0) {\n                    out.println(\"YES \" + a);\n                    continue L;\n                }\n                long limit = (1L << (n + 1 - a)) - 3;\n                if (k <= tot || dp[a] > 0 && (k - tot + dp[a] - 1) / dp[a] <= limit) {\n                    out.println(\"YES \" + a);\n                    continue L;\n                }\n                tot += dp[a] * limit;\n            }\n            out.println(\"NO\");\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new OlyaAndMagicalSquare().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "index": 901, "complexity": 2}
{"back-translation": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class EhabAndAnotherAnotherXorProblem implements Closeable {\n\n    private BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n    private PrintWriter writer = new PrintWriter(System.out);\n    private StringTokenizer tokenizer;\n\n    public void solve() throws IOException {\n        int initial = ask(0, 0);\n        int a = 0, b = 0;\n        if (initial == 0) {\n            for (int i = 0; i < 30; i++) {\n                int response = ask(1 << i, 0);\n                if (response == -1) {\n                    a |= (1 << i);\n                }\n            }\n            b = a;\n        } else {\n            for (int i = 29; i >= 0; i--) {\n                int response = ask(a | (1 << i), b | (1 << i));\n                if (response != initial) {\n                    if (response == 1) {\n                        b |= (1 << i);\n                    } else {\n                        a |= (1 << i);\n                    }\n                    initial = ask(a, b);\n                } else {\n                    response = ask(a | (1 << i), b);\n                    if (response == -1) {\n                        a |= (1 << i);\n                        b |= (1 << i);\n                    }\n                }\n            }\n        }\n        answer(a, b);\n    }\n\n    private int ask(int c, int d) throws IOException {\n        writer.printf(\"? %d %d\\n\", c, d);\n        writer.flush();\n        return Integer.parseInt(nextToken());\n    }\n\n    private void answer(int a, int b) {\n        writer.printf(\"! %d %d\\n\", a, b);\n        writer.flush();\n    }\n\n    private String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    @Override\n    public void close() throws IOException {\n        reader.close();\n        writer.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (EhabAndAnotherAnotherXorProblem instance = new EhabAndAnotherAnotherXorProblem()) {\n            instance.solve();\n        }\n    }\n}", "src": "\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class EhabAndAnotherAnotherXorProblem implements Closeable {\n\n  private InputReader in = new InputReader(System.in);\n  private PrintWriter out = new PrintWriter(System.out);\n\n  public void solve() {\n    int initial = ask(0, 0);\n    int a = 0, b = 0;\n    if (initial == 0) {\n      for (int i = 0; i < 30; i++) {\n        int response = ask(1 << i, 0);\n        if (response == -1) {\n          a |= (1 << i);\n        }\n      }\n      b = a;\n    } else {\n      for (int i = 29; i >= 0; i--) {\n        int response = ask(a | (1 << i), b | (1 << i));\n        if (response != initial) {\n          if (response == 1) {\n            b |= (1 << i);\n          } else {\n            a |= (1 << i);\n          }\n          initial = ask(a, b);\n        } else {\n          response = ask(a | (1 << i), b);\n          if (response == -1) {\n            a |= (1 << i);\n            b |= (1 << i);\n          }\n        }\n        \n      }\n    }\n    answer(a, b);\n  }\n\n  private int ask(int c, int d) {\n    out.printf(\"? %d %d\\n\", c, d);\n    out.flush();\n    return in.ni();\n  }\n\n  private void answer(int a, int b) {\n    out.printf(\"! %d %d\\n\", a, b);\n    out.flush();\n  }\n\n  @Override\n  public void close() throws IOException {\n    in.close();\n    out.close();\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int ni() {\n      return Integer.parseInt(next());\n    }\n\n    public long nl() {\n      return Long.parseLong(next());\n    }\n\n    public void close() throws IOException {\n      reader.close();\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    try (EhabAndAnotherAnotherXorProblem instance = new EhabAndAnotherAnotherXorProblem()) {\n      instance.solve();\n    }\n  }\n}\n", "index": 902, "complexity": 2}
{"back-translation": "public class Search {\n\n    public static boolean find2(int[] array, int begin, int end, int element) {\n        if (begin <= end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return true;\n            else if (medium > begin && array[medium - 1] == element) return true;\n            else if (medium < end && array[medium + 1] == element) return true;\n\n            if (array[medium] > element) return find2(array, 0, medium - 2, element);\n            return find2(array, medium + 2, end, element);\n        }\n        return false;\n    }\n    \n    public static int find(int[] array, int begin, int end, int element) {\n        if (begin < end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return medium;\n            else if (medium > begin && array[medium - 1] == element) return medium - 1;\n            else if (medium < end && array[medium + 1] == element) return medium + 1;\n\n            if (array[medium] > element) return find(array, 0, medium - 2, element);\n            return find(array, medium + 2, end, element);\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] array = {12, 13, 21, 36, 3, 43, 65, 76, 88, 91, 100};\n        System.out.println(find2(array, 0, array.length - 1, 13));\n    }\n\n\n}", "src": "public class Search {\n\n    public static boolean find2(int[] array, int begin, int end, int element) {\n        if (begin <= end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return true;\n            else if (medium > begin && array[medium - 1] == element) return true;\n            else if (medium < end && array[medium + 1] == element) return true;\n\n            if (array[medium] > element) return find2(array, 0, medium - 2, element);\n            return find2(array, medium + 2, end, element);\n        }\n        return false;\n    }\n    \n    public static int find(int[] array, int begin, int end, int element) {\n        if (begin < end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return medium;\n            else if (medium > begin && array[medium - 1] == element) return medium - 1;\n            else if (medium < end && array[medium + 1] == element) return medium + 1;\n\n            if (array[medium] > element) return find(array, 0, medium - 2, element);\n            return find(array, medium + 2, end, element);\n\n\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] array = {12,13, 21, 36, 3, 43, 65, 76, 88, 91, 100};\n        System.out.println(find2(array, 0, array.length-1, 13));\n    }\n\n\n}", "index": 904, "complexity": 2}
{"back-translation": "import java.util.*; public class MajorityCheck { static int binarySearch(int arr[], int low, int high, int x) { if (high >= low) { int mid = (low + high) / 2; if ((mid == 0 || x > arr[mid - 1]) && (arr[mid] == x)) return mid; else if (x > arr[mid]) return binarySearch(arr, mid + 1, high, x); else return binarySearch(arr, low, mid - 1, x); } return -1; } static boolean isMajority(int arr[], int n, int x) { int i = binarySearch(arr, 0, n - 1, x); if (i == -1) return false; if ((i + n / 2) <= (n - 1) && arr[i + n / 2] == x) return true; else return false; } public static void main(String[] args) { int arr[] = {1, 2, 3, 3, 3, 3, 10}; int n = arr.length; int x = 3; if (isMajority(arr, n, x) == true) System.out.println(x + \" appears more than \" + n /2 + \" times in arr[]\"); else System.out.println(x + \" does not appear more than \" + n /2 + \" times in arr[]\"); } }", "src": "\n/* Program to check for majority element in a sorted array */\nimport\njava.io.*; \n\nclass\nMajority { \n\n\n/* If x is present in arr[low...high] then returns the index of \n\nfirst occurrence of x, otherwise returns -1 */\n\nstatic\nint\n_binarySearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nif\n(high >= low) \n\n{ \n\nint\nmid = (low + high)/\n2\n; \n/*low + (high - low)/2;*/\n\n\n/* Check if arr[mid] is the first occurrence of x. \n\narr[mid] is first occurrence if x is one of the following \n\nis true: \n\n(i) mid == 0 and arr[mid] == x \n\n(ii) arr[mid-1] < x and arr[mid] == x \n\n*/\n\nif\n( (mid == \n0\n|| x > arr[mid-\n1\n]) && (arr[mid] == x) ) \n\nreturn\nmid; \n\nelse\nif\n(x > arr[mid]) \n\nreturn\n_binarySearch(arr, (mid + \n1\n), high, x); \n\nelse\n\nreturn\n_binarySearch(arr, low, (mid -\n1\n), x); \n\n} \n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n/* This function returns true if the x is present more than n/2 \n\ntimes in arr[] of size n */\n\nstatic\nboolean\nisMajority(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n/* Find the index of first occurrence of x in arr[] */\n\nint\ni = _binarySearch(arr, \n0\n, n-\n1\n, x); \n\n\n/* If element is not present at all, return false*/\n\nif\n(i == -\n1\n) \n\nreturn\nfalse\n; \n\n\n/* check if the element is present more than n/2 times */\n\nif\n(((i + n/\n2\n) <= (n -\n1\n)) && arr[i + n/\n2\n] == x) \n\nreturn\ntrue\n; \n\nelse\n\nreturn\nfalse\n; \n\n} \n\n\n/*Driver function to check for above functions*/\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n3\n, \n3\n, \n3\n, \n10\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nif\n(isMajority(arr, n, x)==\ntrue\n) \n\nSystem.out.println(x + \n\" appears more than \"\n+ \n\nn/\n2\n+ \n\" times in arr[]\"\n); \n\nelse\n\nSystem.out.println(x + \n\" does not appear more than \"\n+ \n\nn/\n2\n+ \n\" times in arr[]\"\n); \n\n} \n} \n/*This code is contributed by Devesh Agrawal*/", "index": 905, "complexity": 2}
{"back-translation": "class Main { static int findMaximum(int arr[], int low, int high) { if (low == high) return arr[low]; if ((high == low + 1) && arr[low] >= arr[high]) return arr[low]; if ((high == low + 1) && arr[low] < arr[high]) return arr[high]; int mid = (low + high)/2; if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) return arr[mid]; if (arr[mid] > arr[mid + 1] && arr[mid] < arr[mid - 1]) return findMaximum(arr, low, mid - 1); else return findMaximum(arr, mid + 1, high); } public static void main(String[] args) { int arr[] = {1, 3, 50, 10, 9, 7, 6}; int n = arr.length; System.out.println(\"The maximum element is \" + findMaximum(arr, 0, n - 1)); } }", "src": "\n// java program to find maximum \n// element \n\nclass\nMain \n{ \n\n// function to find the \n\n// maximum element \n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n\n/* Base Case: Only one element is \n\npresent in arr[low..high]*/\n\nif\n(low == high) \n\nreturn\narr[low]; \n\n\n/* If there are two elements and \n\nfirst is greater then the first \n\nelement is maximum */\n\nif\n((high == low + \n1\n) && arr[low] >= arr[high]) \n\nreturn\narr[low]; \n\n\n/* If there are two elements and \n\nsecond is greater then the second \n\nelement is maximum */\n\nif\n((high == low + \n1\n) && arr[low] < arr[high]) \n\nreturn\narr[high]; \n\n\n/*low + (high - low)/2;*/\n\nint\nmid = (low + high)/\n2\n; \n\n\n/* If we reach a point where arr[mid] \n\nis greater than both of its adjacent \n\nelements arr[mid-1] and arr[mid+1], \n\nthen arr[mid] is the maximum element*/\n\nif\n( arr[mid] > arr[mid + \n1\n] && arr[mid] > arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n/* If arr[mid] is greater than the next \n\nelement and smaller than the previous \n\nelement then maximum lies on left side \n\nof mid */\n\nif\n(arr[mid] > arr[mid + \n1\n] && arr[mid] < arr[mid - \n1\n]) \n\nreturn\nfindMaximum(arr, low, mid-\n1\n); \n\nelse\n\nreturn\nfindMaximum(arr, mid + \n1\n, high); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n3\n, \n50\n, \n10\n, \n9\n, \n7\n, \n6\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"The maximum element is \"\n+ \n\nfindMaximum(arr, \n0\n, n-\n1\n)); \n\n} \n} ", "index": 907, "complexity": 2}
{"back-translation": "public class FloorAndCeilingSortedArray {\n\n    public int floor(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] < x && (middle == input.length-1 || input[middle+1] > x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n\n    public int ceiling(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] > x && (middle == 0 || input[middle-1] < x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]){\n        int input[] = {1,2,5,6,11,15};\n        FloorAndCeilingSortedArray foc = new FloorAndCeilingSortedArray();\n        System.out.println(foc.floor(input, 15));\n        System.out.println(foc.ceiling(input, 2));\n    }\n}", "src": "package com.interview.binarysearch;\n\n/**\n * http://www.geeksforgeeks.org/search-floor-and-ceil-in-a-sorted-array/\n */\npublic class FloorAndCeilingSortedArray {\n\n    public int floor(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] < x && (middle == input.length-1 || input[middle+1] > x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n\n    public int ceiling(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] > x && (middle == 0 || input[middle-1] < x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        int input[] = {1,2,5,6,11,15};\n        FloorAndCeilingSortedArray foc = new FloorAndCeilingSortedArray();\n        System.out.println(foc.floor(input, 15));\n        System.out.println(foc.ceiling(input, 2));\n    }\n}", "index": 908, "complexity": 2}
{"back-translation": "public class Main { static int pivotedBinarySearch(int arr[], int n, int key) { int pivot = findPivot(arr, 0, n-1); if (pivot == -1) return binarySearch(arr, 0, n-1, key); if (arr[pivot] == key) return pivot; if (arr[0] <= key) return binarySearch(arr, 0, pivot-1, key); return binarySearch(arr, pivot+1, n-1, key); } static int findPivot(int arr[], int low, int high) { if (high < low) return -1; if (high == low) return low; int mid = (low + high)/2; if (mid < high && arr[mid] > arr[mid + 1]) return mid; if (mid > low && arr[mid] < arr[mid - 1]) return (mid-1); if (arr[low] >= arr[mid]) return findPivot(arr, low, mid-1); return findPivot(arr, mid + 1, high); } static int binarySearch(int arr[], int low, int high, int key) { if (high < low) return -1; int mid = (low + high)/2; if (key == arr[mid]) return mid; if (key > arr[mid]) return binarySearch(arr, (mid + 1), high, key); return binarySearch(arr, low, (mid -1), key); } public static void main(String args[]) { int arr1[] = {5, 6, 7, 8, 9, 10, 1, 2, 3}; int n = arr1.length; int key = 3; System.out.println(\"Index of the element is : \" + pivotedBinarySearch(arr1, n, key)); } }", "src": "\n/* Java program to search an element \n\nin a sorted and pivoted array*/\n\nclass\nMain \n{ \n\n\n/* Searches an element key in a \n\npivoted sorted array arrp[] \n\nof size n */\n\nstatic\nint\npivotedBinarySearch(\nint\narr[], \nint\nn, \nint\nkey) \n\n{ \n\nint\npivot = findPivot(arr, \n0\n, n-\n1\n); \n\n\n// If we didn't find a pivot, then \n\n// array is not rotated at all \n\nif\n(pivot == -\n1\n) \n\nreturn\nbinarySearch(arr, \n0\n, n-\n1\n, key); \n\n\n// If we found a pivot, then first \n\n// compare with pivot and then \n\n// search in two subarrays around pivot \n\nif\n(arr[pivot] == key) \n\nreturn\npivot; \n\nif\n(arr[\n0\n] <= key) \n\nreturn\nbinarySearch(arr, \n0\n, pivot-\n1\n, key); \n\nreturn\nbinarySearch(arr, pivot+\n1\n, n-\n1\n, key); \n\n} \n\n\n/* Function to get pivot. For array \n\n3, 4, 5, 6, 1, 2 it returns \n\n3 (index of 6) */\n\nstatic\nint\nfindPivot(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n// base cases \n\nif\n(high < low) \n\nreturn\n-\n1\n; \n\nif\n(high == low) \n\nreturn\nlow; \n\n\n/* low + (high - low)/2; */\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(mid < high && arr[mid] > arr[mid + \n1\n]) \n\nreturn\nmid; \n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\n(mid-\n1\n); \n\nif\n(arr[low] >= arr[mid]) \n\nreturn\nfindPivot(arr, low, mid-\n1\n); \n\nreturn\nfindPivot(arr, mid + \n1\n, high); \n\n} \n\n\n/* Standard Binary Search function */\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nkey) \n\n{ \n\nif\n(high < low) \n\nreturn\n-\n1\n; \n\n\n/* low + (high - low)/2; */\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(key == arr[mid]) \n\nreturn\nmid; \n\nif\n(key > arr[mid]) \n\nreturn\nbinarySearch(arr, (mid + \n1\n), high, key); \n\nreturn\nbinarySearch(arr, low, (mid -\n1\n), key); \n\n} \n\n\n// main function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n// Let us search 3 in below array \n\nint\narr1[] = {\n5\n, \n6\n, \n7\n, \n8\n, \n9\n, \n10\n, \n1\n, \n2\n, \n3\n}; \n\nint\nn = arr1.length; \n\nint\nkey = \n3\n; \n\nSystem.out.println(\n\"Index of the element is : \"\n\n+ pivotedBinarySearch(arr1, n, key)); \n\n} \n} ", "index": 909, "complexity": 2}
{"back-translation": "class Codechef {\n    public static void main(String[] args) throws java.lang.Exception {\n        Scanner in = new Scanner(System.in);\n        long x = in.nextLong();\n        long k = in.nextLong();\n\n        long mod = 1000000007;\n        long get = power(2, k, mod);\n        long ans = ((get % mod) * ((2 * x) % mod)) % mod - get + 1;\n        if (ans < 0)\n            ans += mod;\n        if (x == 0)\n            ans = 0;\n        System.out.println(ans);\n\n    }\n    static long power(long x, long y, long p) {\n        long res = 1;\n\n        x = x % p;\n\n        while (y > 0) {\n            if ((y & 1) == 1)\n                res = (res * x) % p;\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n}", "src": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Codechef\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tScanner in=new Scanner(System.in);\n\t\tlong x=in.nextLong();\n\t\tlong k=in.nextLong();\n\t\t\n\t\tlong mod=1000000007;\n\t\tlong get=power(2,k,mod);\n\t\tlong ans=((get%mod)*((2*x)%mod))%mod-get+1;\n\t\tif(ans<0)\n\t\tans+=mod;\n\t\tif(x==0)\n\t\tans=0;\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\tstatic long power(long x, long y, long p)\n    {\n        // Initialize result\n        long res = 1;     \n        \n        // Update x if it is more  \n        // than or equal to p\n        x = x % p; \n     \n        while (y > 0)\n        {\n            // If y is odd, multiply x\n            // with result\n            if((y & 1)==1)\n                res = (res * x) % p;\n     \n            // y must be even now\n            // y = y / 2\n            y = y >> 1; \n            x = (x * x) % p; \n        }\n        return res;\n    }\n}\n", "index": 911, "complexity": 2}
{"back-translation": "class Minimum { static int findMin(int arr[], int low, int high) { if (high < low) return arr[0]; if (high == low) return arr[low]; int mid = low + (high - low) / 2; if (mid < high && arr[mid+1] < arr[mid]) return arr[mid+1]; if (mid > low && arr[mid] < arr[mid - 1]) return arr[mid]; if (arr[high] > arr[mid]) return findMin(arr, low, mid-1); return findMin(arr, mid+1, high); } public static void main (String[] args) { int arr1[] = {5, 6, 1, 2, 3, 4}; int n1 = arr1.length; System.out.println(\"The minimum element is \"+ findMin(arr1, 0, n1-1)); int arr2[] = {1, 2, 3, 4}; int n2 = arr2.length; System.out.println(\"The minimum element is \"+ findMin(arr2, 0, n2-1)); int arr3[] = {1}; int n3 = arr3.length; System.out.println(\"The minimum element is \"+ findMin(arr3, 0, n3-1)); int arr4[] = {1, 2}; int n4 = arr4.length; System.out.println(\"The minimum element is \"+ findMin(arr4, 0, n4-1)); int arr5[] = {2, 1}; int n5 = arr5.length; System.out.println(\"The minimum element is \"+ findMin(arr5, 0, n5-1)); int arr6[] = {5, 6, 7, 1, 2, 3, 4}; int n6 = arr6.length; System.out.println(\"The minimum element is \"+ findMin(arr6, 0, n6-1)); int arr7[] = {1, 2, 3, 4, 5, 6, 7}; int n7 = arr7.length; System.out.println(\"The minimum element is \"+ findMin(arr7, 0, n7-1)); int arr8[] = {2, 3, 4, 5, 6, 7, 8, 1}; int n8 = arr8.length; System.out.println(\"The minimum element is \"+ findMin(arr8, 0, n8-1)); int arr9[] = {3, 4, 5, 1, 2}; int n9 = arr9.length; System.out.println(\"The minimum element is \"+ findMin(arr9, 0, n9-1)); } }", "src": "\n// Java program to find minimum element in a sorted and rotated array \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nMinimum \n{ \n\nstatic\nint\nfindMin(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n// This condition is needed to handle the case when array \n\n// is not rotated at all \n\nif\n(high < low) \nreturn\narr[\n0\n]; \n\n\n// If there is only one element left \n\nif\n(high == low) \nreturn\narr[low]; \n\n\n// Find mid \n\nint\nmid = low + (high - low)/\n2\n; \n/*(low + high)/2;*/\n\n\n// Check if element (mid+1) is minimum element. Consider \n\n// the cases like {3, 4, 5, 1, 2} \n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\narr[mid+\n1\n]; \n\n\n// Check if mid itself is minimum element \n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n// Decide whether we need to go to left half or right half \n\nif\n(arr[high] > arr[mid]) \n\nreturn\nfindMin(arr, low, mid-\n1\n); \n\nreturn\nfindMin(arr, mid+\n1\n, high); \n\n} \n\n\n// Driver Program \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr1[] = {\n5\n, \n6\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr1, \n0\n, n1-\n1\n)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr2, \n0\n, n2-\n1\n)); \n\n\nint\narr3[] = {\n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr3, \n0\n, n3-\n1\n)); \n\n\nint\narr4[] = {\n1\n, \n2\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr4, \n0\n, n4-\n1\n)); \n\n\nint\narr5[] = {\n2\n, \n1\n}; \n\nint\nn5 = arr5.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr5, \n0\n, n5-\n1\n)); \n\n\nint\narr6[] = {\n5\n, \n6\n, \n7\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn6 = arr6.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr6, \n0\n, n6-\n1\n)); \n\n\nint\narr7[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn7 = arr7.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr7, \n0\n, n7-\n1\n)); \n\n\nint\narr8[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n1\n}; \n\nint\nn8 = arr8.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr8, \n0\n, n8-\n1\n)); \n\n\nint\narr9[] = {\n3\n, \n4\n, \n5\n, \n1\n, \n2\n}; \n\nint\nn9 = arr9.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr9, \n0\n, n9-\n1\n)); \n\n} \n} ", "index": 913, "complexity": 2}
{"back-translation": "class PeakElement {\n    static int findPeakUtil(int arr[], int low, int high, int n) {\n        int mid = low + (high - low) / 2;\n        if ((mid == 0 || arr[mid - 1] <= arr[mid]) && (mid == n - 1 || arr[mid + 1] <= arr[mid]))\n            return mid;\n        else if (mid > 0 && arr[mid - 1] > arr[mid])\n            return findPeakUtil(arr, low, (mid - 1), n);\n        else\n            return findPeakUtil(arr, (mid + 1), high, n);\n    }\n    static int findPeak(int arr[], int n) {\n        return findPeakUtil(arr, 0, n - 1, n);\n    }\n    public static void main(String[] args) {\n        int arr[] = {1, 3, 20, 4, 1, 0};\n        int n = arr.length;\n        System.out.println(\"Index of a peak point is \" + findPeak(arr, n));\n    }\n}", "src": "\n// A Java program to find a peak element element using divide and conquer \nimport\njava.util.*; \nimport\njava.lang.*; \nimport\njava.io.*; \n\nclass\nPeakElement \n{ \n\n// A binary search based function that returns index of a peak \n\n// element \n\nstatic\nint\nfindPeakUtil(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nn) \n\n{ \n\n// Find index of middle element \n\nint\nmid = low + (high - low)/\n2\n; \n/* (low + high)/2 */\n\n\n// Compare middle element with its neighbours (if neighbours \n\n// exist) \n\nif\n((mid == \n0\n|| arr[mid-\n1\n] <= arr[mid]) && (mid == n-\n1\n|| \n\narr[mid+\n1\n] <= arr[mid])) \n\nreturn\nmid; \n\n\n// If middle element is not peak and its left neighbor is \n\n// greater than it,then left half must have a peak element \n\nelse\nif\n(mid > \n0\n&& arr[mid-\n1\n] > arr[mid]) \n\nreturn\nfindPeakUtil(arr, low, (mid -\n1\n), n); \n\n\n// If middle element is not peak and its right neighbor \n\n// is greater than it, then right half must have a peak \n\n// element \n\nelse\nreturn\nfindPeakUtil(arr, (mid + \n1\n), high, n); \n\n} \n\n\n// A wrapper over recursive function findPeakUtil() \n\nstatic\nint\nfindPeak(\nint\narr[], \nint\nn) \n\n{ \n\nreturn\nfindPeakUtil(arr, \n0\n, n-\n1\n, n); \n\n} \n\n\n// Driver method \n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n3\n, \n20\n, \n4\n, \n1\n, \n0\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Index of a peak point is \"\n+ \n\nfindPeak(arr, n)); \n\n} \n} ", "index": 914, "complexity": 2}
{"back-translation": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\nimport java.util.stream.IntStream;\n\npublic class B {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\n        Solver solver = new Solver();\n        solver.solve(in, out);\n        out.close();\n    }\n\n    static class Solver {\n        int n;\n        int n2;\n        InputReader in;\n        PrintWriter out;\n\n        public void solve(InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.readInt();\n            n2 = n / 2;\n\n            int res = find();\n            out.print(\"! \");\n            out.println(res);\n        }\n\n        public int find() {\n            if (n % 4 != 0) return -1;\n            int c = compare(0);\n            if (c == 0) return 1;\n            int s = 1;\n            int f = n2 - 1;\n            if (c > 0) {\n                s = n2 + 1;\n                f = n - 1;\n            }\n            while (s <= f) {\n                int m = (s + f) / 2;\n                int v = compare(m);\n                if (v == 0) return m + 1;\n                else if (v < 0) s = m + 1;\n                else f = m - 1;\n            }\n            return -1;\n        }\n\n        public int compare(int z) {\n            out.print(\"? \");\n            out.println(z + 1);\n            out.flush();\n            int r1 = in.readInt();\n            out.print(\"? \");\n            out.println((z + n2) % n + 1);\n            out.flush();\n            int r2 = in.readInt();\n            return r1 - r2;\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            this.reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String read() {\n            try {\n                if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n            } catch (IOException ex) {\n                throw new RuntimeException(ex);\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int readInt() {\n            return Integer.parseInt(read());\n        }\n\n        public long readLong() {\n            return Long.parseLong(read());\n        }\n\n        public void readIntArrays(int[]... arrays) {\n            for (int i = 0; i < arrays[0].length; i++) {\n                for (int j = 0; j < arrays.length; j++) {\n                    arrays[j][i] = readInt();\n                }\n            }\n        }\n    }\n\n}", "src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\nimport java.util.stream.IntStream;\n\npublic class B {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\n        Solver solver = new Solver();\n        solver.solve(in, out);\n        out.close();\n    }\n\n    static class Solver {\n        int n;\n        int n2;\n        InputReader in;\n        PrintWriter out;\n\n        public void solve(InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.readInt();\n            n2 = n/2;\n\n            int res = find();\n            out.print(\"! \");\n            out.println(res);\n        }\n\n        public int find() {\n            if (n%4 != 0) return -1;\n            int c = compare(0);\n            if (c == 0) return 1;\n            int s = 1;\n            int f = n2-1;\n            if (c > 0) {\n                s = n2+1;\n                f = n-1;\n            }\n            while (s <= f) {\n                int m = (s+f)/2;\n                int v = compare(m);\n                if (v == 0) return m+1;\n                else if (v < 0) s = m+1;\n                else f = m-1;\n            }\n            return -1;\n        }\n\n        public int compare(int z) {\n            out.print(\"? \");\n            out.println(z+1);\n            out.flush();\n            int r1 = in.readInt();\n            out.print(\"? \");\n            out.println((z+n2)%n+1);\n            out.flush();\n            int r2 = in.readInt();\n            return r1-r2;\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            this.reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String read() {\n            try {\n                if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n            } catch (IOException ex) {\n                throw new RuntimeException(ex);\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int readInt() {\n            return Integer.parseInt(read());\n        }\n\n        public long readLong() {\n            return Long.parseLong(read());\n        }\n\n        public void readIntArrays(int[]... arrays) {\n            for (int i = 0; i < arrays[0].length; i++) {\n                for (int j = 0; j < arrays.length; j++) {\n                    arrays[j][i] = readInt();\n                }\n            }\n        }\n    }\n\n}", "index": 915, "complexity": 2}
{"back-translation": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        BigInteger mod = new BigInteger(\"1000000007\");\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            BigInteger x = new BigInteger(in.next());\n            BigInteger k = new BigInteger(in.next());\n            if (x.longValue() == 0) {\n                out.print(x);\n                return;\n            }\n            BigInteger pow = powerWithMod(new BigInteger(\"2\"), k);\n            BigInteger current = x.mod(mod).multiply(pow).mod(mod);\n            BigInteger result = current.multiply(new BigInteger(\"2\")).mod(mod)\n                    .subtract(pow.subtract(new BigInteger(\"1\")).mod(mod))\n                    .mod(mod);\n            out.print(result);\n        }\n\n        BigInteger powerWithMod(BigInteger base, BigInteger exponent) {\n            if (exponent.longValue() == 0) {\n                return new BigInteger(\"1\");\n            }\n            BigInteger temp = powerWithMod(base, exponent.divide(new BigInteger(\"2\")));\n            BigInteger term = temp.mod(mod);\n            if (exponent.mod(new BigInteger(\"2\")).intValue() == 0) {\n                return term.multiply(term.mod(mod)).mod(mod);\n            } else {\n                return term.multiply(term.mod(mod)).multiply(base.mod(mod)).mod(mod);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() throws IOException {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author programajor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        BigInteger mod = new BigInteger(\"1000000007\");\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            BigInteger x = new BigInteger(in.next());\n            BigInteger k = new BigInteger(in.next());\n            if (x.longValue() == 0) {\n                out.print(x);\n                return;\n            }\n            BigInteger pow = powerWithMod(new BigInteger(\"2\"), k);\n            BigInteger current = x.mod(mod).multiply(pow).mod(mod);\n            BigInteger result = current.multiply(new BigInteger(\"2\")).mod(mod)\n                    .subtract(pow.subtract(new BigInteger(\"1\")).mod(mod))\n                    .mod(mod);\n            out.print(result);\n        }\n\n        BigInteger powerWithMod(BigInteger base, BigInteger exponent) {\n            if (exponent.longValue() == 0) {\n                return new BigInteger(\"1\");\n            }\n            BigInteger temp = powerWithMod(base, exponent.divide(new BigInteger(\"2\")));\n            BigInteger term = temp.mod(mod);\n            if (exponent.mod(new BigInteger(\"2\")).intValue() == 0) {\n                return term.multiply(term.mod(mod)).mod(mod);\n            } else {\n                return term.multiply(term.mod(mod)).multiply(base.mod(mod)).mod(mod);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n    }\n}\n\n", "index": 917, "complexity": 2}
{"back-translation": "public class CountOnes {\n\n    int countOnes(int[] arr, int low, int high) {\n        if (high >= low) {\n            int mid = low + (high - low) / 2;\n            if ((mid == high || arr[mid + 1] == 0) && (arr[mid] == 1))\n                return mid + 1;\n            if (arr[mid] == 1)\n                return countOnes(arr, (mid + 1), high);\n            return countOnes(arr, low, (mid - 1));\n        }\n        return 0;\n    }\n\n    public static void main(String args[]) {\n        CountOnes ob = new CountOnes();\n        int arr[] = {1, 1, 1, 1, 0, 0, 0};\n        int n = arr.length;\n        System.out.println(\"Count of 1's in given array is \" + ob.countOnes(arr, 0, n - 1));\n    }\n}", "src": "\n// Java program to count 1's in a sorted array \nclass\nCountOnes \n{ \n\n/* Returns counts of 1's in arr[low..high]. The \n\narray is assumed to be sorted in non-increasing \n\norder */\n\nint\ncountOnes(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n// get the middle index \n\nint\nmid = low + (high - low)/\n2\n; \n\n\n// check if the element at middle index is last 1 \n\nif\n( (mid == high || arr[mid+\n1\n] == \n0\n) && \n\n(arr[mid] == \n1\n)) \n\nreturn\nmid+\n1\n; \n\n\n// If element is not last 1, recur for right side \n\nif\n(arr[mid] == \n1\n) \n\nreturn\ncountOnes(arr, (mid + \n1\n), high); \n\n\n// else recur for left side \n\nreturn\ncountOnes(arr, low, (mid -\n1\n)); \n\n} \n\nreturn\n0\n; \n\n} \n\n\n/* Driver program to test above functions */\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nCountOnes ob = \nnew\nCountOnes(); \n\nint\narr[] = {\n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n0\n, \n0\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Count of 1's in given array is \"\n+ \n\nob.countOnes(arr, \n0\n, n-\n1\n) ); \n\n} \n} \n/* This code is contributed by Rajat Mishra */", "index": 918, "complexity": 2}
{"back-translation": "class Main { static int binarySearch(int arr[], int low, int high) { if (high >= low) { int mid = (low + high) / 2; if (mid == arr[mid]) return mid; if (mid > arr[mid]) return binarySearch(arr, mid + 1, high); else return binarySearch(arr, low, mid - 1); } return -1; } public static void main(String args[]) { int arr[] = {-10, -1, 0, 3, 10, 11, 30, 50, 100}; int n = arr.length; System.out.println(\"Fixed Point is \" + binarySearch(arr, 0, n - 1)); } }", "src": "\n// Java program to check fixed point \n// in an array using binary search \n\nclass\nMain \n{ \n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n/* low + (high - low)/2; */\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(mid == arr[mid]) \n\nreturn\nmid; \n\nif\n(mid > arr[mid]) \n\nreturn\nbinarySearch(arr, (mid + \n1\n), high); \n\nelse\n\nreturn\nbinarySearch(arr, low, (mid -\n1\n)); \n\n} \n\n\n/* Return -1 if there is \n\nno Fixed Point */\n\nreturn\n-\n1\n; \n\n} \n\n\n//main function \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {-\n10\n, -\n1\n, \n0\n, \n3\n, \n10\n, \n11\n, \n30\n, \n50\n, \n100\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Fixed Point is \"\n\n+ binarySearch(arr,\n0\n, n-\n1\n)); \n\n} \n} ", "index": 919, "complexity": 2}
{"back-translation": "class FindMedianTwoArrays {\n    public static double findMedian(int[] arr1, int start1, int end1, int[] arr2, int start2, int end2) {\n        if (end1 - start1 == 1 && end2 - start2 == 1) {\n            return (Math.max(arr1[start1], arr2[start2]) + Math.min(arr1[end1], arr2[end2])) / 2;\n        }\n\n        int median1Index = (int) Math.floor((start1 + end1) / 2);\n        int median2Index = (int) Math.floor((start2 + end2) / 2);\n\n        int median1 = arr1[median1Index];\n        int median2 = arr2[median2Index];\n\n        if (median1 == median2) {\n            return median1;\n        }\n\n        if (median1 < median2) {\n            start1 = median1Index;\n            if (end2 - start2 > 1) {\n                end2 = median2Index;\n            }\n        } else {\n            start2 = median2Index;\n            if (end1 - start1 > 1) {\n                end1 = median1Index;\n            }\n        }\n\n        return findMedian(arr1, start1, end1, arr2, start2, end2);\n    }\n}\n\nclass Test {\n    public static void main(String[] args) {\n        int[] A = {1, 2, 3, 4, 4};\n        int[] B = {6, 9, 10, 11, 15};\n        FindMedianTwoArrays findMedian = new FindMedianTwoArrays();\n        System.out.println(\"Hello Java\");\n        System.out.println(findMedian.findMedian(A, 0, 4, B, 0, 4));\n    }\n}", "src": "class findMedianTwoArrays\n{\n  public static double main(\n    int[] arr1, int start1, int end1, int[] arr2, int start2, int end2) {\n    if ( end1 - start1 == 1 && end2 - start2 == 1 ) {\n        return ( Math.max(arr1[start1], arr2[start2]) + Math.min(arr1[end1], arr2[end2]) ) / 2;\n    }    \n  \n  int median1Index = Math.floor((start1 + end1 ) / 2);\n  int median2Index = Math.floor((start2 + end2 ) / 2);\n  int median1 = arr1[median1Index];\n  int median2 = arr2[median2Index];\n\n  if ( median1 == median2 ) {\n    return median1;\n  }    \n\n  if ( median1 < median2 ) {\n    start1 = median1Index;\n    if ( end2 - start2 > 1 ) { \n        end2 = median2Index;\n    }        \n  } else {\n    start2 = median2Index;\n    if ( end1 - start1 > 1 ) { \n        end1 = median1Index;\n    }    \n  }            \n\n  return main(arr1, start1, end1, arr2, start2, end2);\n  }\n}\n\nclass test {\n  public static void main(String[] args) {\n    int[] A = { 1, 2, 3, 4, 4 };\n    int[] B = { 6, 9, 10, 11, 15};\n    findMedianTwoArrays findMedian = new findMedianTwoArrays();\n    System.out.println(\"Hello Java\");\n    System.out.println(findMedian.main(A, 0, 4, B, 0, 4));\n  }    \n} ", "index": 920, "complexity": 2}
{"back-translation": "class Main { static int ceilSearch(int arr[], int low, int high, int x) { int mid; if (x <= arr[low]) return low; if (x > arr[high]) return -1; mid = (low + high)/2; if (arr[mid] == x) return mid; else if (arr[mid] < x) { if (mid + 1 <= high && x <= arr[mid+1]) return mid + 1; else return ceilSearch(arr, mid+1, high, x); } else { if (mid - 1 >= low && x > arr[mid-1]) return mid; else return ceilSearch(arr, low, mid - 1, x); } } public static void main(String[] args) { int arr[] = { 1, 2, 8, 10, 10, 12, 19 }; int n = arr.length; int x = 8; int index = ceilSearch(arr, 0, n-1, x); if (index == -1) System.out.println(\"Ceiling of \" + x + \" doesn't exist in array\"); else System.out.println(\"ceiling of \" + x + \" is \" + arr[index]); } }", "src": "\nclass\nMain \n{ \n\n/* Function to get index of \n\nceiling of x in arr[low..high]*/\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\nmid; \n\n\n/* If x is smaller than or equal to the \n\nfirst element, then return the first element */\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n/* If x is greater than the last \n\nelement, then return -1 */\n\nif\n(x > arr[high]) \n\nreturn\n-\n1\n; \n\n\n/* get the index of middle element \n\nof arr[low..high]*/\n\nmid = (low + high)/\n2\n; \n/* low + (high - low)/2 */\n\n\n/* If x is same as middle element, \n\nthen return mid */\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n/* If x is greater than arr[mid], then \n\neither arr[mid + 1] is ceiling of x or \n\nceiling lies in arr[mid+1...high] */\n\nelse\nif\n(arr[mid] < x) \n\n{ \n\nif\n(mid + \n1\n<= high && x <= arr[mid+\n1\n]) \n\nreturn\nmid + \n1\n; \n\nelse\n\nreturn\nceilSearch(arr, mid+\n1\n, high, x); \n\n} \n\n\n/* If x is smaller than arr[mid], \n\nthen either arr[mid] is ceiling of x \n\nor ceiling lies in arr[mid-1...high] */\n\nelse\n\n{ \n\nif\n(mid - \n1\n>= low && x > arr[mid-\n1\n]) \n\nreturn\nmid; \n\nelse\n\nreturn\nceilSearch(arr, low, mid - \n1\n, x); \n\n} \n\n} \n\n\n\n/* Driver program to check above functions */\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n8\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n} ", "index": 921, "complexity": 2}
{"back-translation": "class BinarySearch {\n    int binarySearch(int arr[], int x) {\n        int l = 0, r = arr.length - 1;\n        while (l <= r) {\n            int m = l + (r - l) / 2;\n            if (arr[m] == x)\n                return m;\n            if (arr[m] < x)\n                l = m + 1;\n            else\n                r = m - 1;\n        }\n        return -1;\n    }\n    public static void main(String args[]) {\n        BinarySearch ob = new BinarySearch();\n        int arr[] = {2, 3, 4, 10, 40};\n        int n = arr.length;\n        int x = 10;\n        int result = ob.binarySearch(arr, x);\n        if(result == -1)\n            System.out.println(\"Element not present\");\n        else\n            System.out.println(\"Element found at \" + \"index \" + result);\n    }\n}", "src": "\n// Java implementation of iterative Binary Search \nclass\nBinarySearch { \n\n// Returns index of x if it is present in arr[], \n\n// else return -1 \n\nint\nbinarySearch(\nint\narr[], \nint\nx) \n\n{ \n\nint\nl = \n0\n, r = arr.length - \n1\n; \n\nwhile\n(l <= r) { \n\nint\nm = l + (r - l) / \n2\n; \n\n\n// Check if x is present at mid \n\nif\n(arr[m] == x) \n\nreturn\nm; \n\n\n// If x greater, ignore left half \n\nif\n(arr[m] < x) \n\nl = m + \n1\n; \n\n\n// If x is smaller, ignore right half \n\nelse\n\nr = m - \n1\n; \n\n} \n\n\n// if we reach here, then element was \n\n// not present \n\nreturn\n-\n1\n; \n\n} \n\n\n// Driver method to test above \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinarySearch ob = \nnew\nBinarySearch(); \n\nint\narr[] = { \n2\n, \n3\n, \n4\n, \n10\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n10\n; \n\nint\nresult = ob.binarySearch(arr, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element not present\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at \"\n\n+ \n\"index \"\n+ result); \n\n} \n} ", "index": 922, "complexity": 2}
{"back-translation": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\nimport java.util.PriorityQueue;\nimport static java.lang.Math.*;\n\npublic class solution implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars == -1) throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\"; try { str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } return str;\n        }\n\n        public int nextInt() {\n            int c = read(); while (isSpaceChar(c)) c = read(); int sgn = 1; if (c == '-') { sgn = -1; c = read(); } int res = 0; do { if (c < '0' || c > '9') throw new InputMismatchException(); res *= 10; res += c - '0'; c = read(); } while (!isSpaceChar(c)); return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read(); while (isSpaceChar(c)) c = read(); int sgn = 1; if (c == '-') { sgn = -1; c = read(); } long res = 0; do { if (c < '0' || c > '9') throw new InputMismatchException(); res *= 10; res += c - '0'; c = read(); } while (!isSpaceChar(c)); return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read(); while (isSpaceChar(c)) c = read(); int sgn = 1; if (c == '-') { sgn = -1; c = read(); } double res = 0; while (!isSpaceChar(c) && c != '.') { if (c == 'e' || c == 'E') return res * Math.pow(10, nextInt()); if (c < '0' || c > '9') throw new InputMismatchException(); res *= 10; res += c - '0'; c = read(); } if (c == '.') { c = read(); double m = 1; while (!isSpaceChar(c)) { if (c == 'e' || c == 'E') return res * Math.pow(10, nextInt()); if (c < '0' || c > '9') throw new InputMismatchException(); m /= 10; res += (c - '0') * m; c = read(); } } return res * sgn;\n        }\n\n        public String readString() {\n            int c = read(); while (isSpaceChar(c)) c = read(); StringBuilder res = new StringBuilder(); do { res.appendCodePoint(c); c = read(); } while (!isSpaceChar(c)); return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) { if (filter != null) return filter.isSpaceChar(c); return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    static int mod = (int) 1e9 + 7;\n    public static long fastexpo(long pow) {\n        long expo = 2; long ans = 1; while (pow != 0) { if ((pow & 1) == 1) { ans = (ans * expo) % mod; } expo = (expo * expo) % mod; pow = pow >> 1; } return ans;\n    }\n\n    public static void main(String args[]) throws Exception { new Thread(null, new solution(), \"Main\", 1 << 26).start(); }\n\n    public void run() { InputReader sc = new InputReader(System.in); PrintWriter out = new PrintWriter(System.out); long x = sc.nextLong(); if (x == 0) { out.println(0); out.close(); return; } long k = sc.nextLong(); long a = ((fastexpo(k + 1) % mod) * (x % mod)) % mod; long b = (-1 * fastexpo(k) % mod + mod) % mod; long ans = (a + b + 1) % mod; out.println(ans); out.close(); }\n}", "src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\nimport java.util.PriorityQueue;\nimport static java.lang.Math.*;\n\npublic class solution implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\tstatic int mod = (int)1e9+7;\n\tpublic static long fastexpo(long pow)\n\t{\n\t\tlong expo = 2;\n\t\tlong ans = 1;\n\t\twhile(pow!=0)\n\t\t{\n\t\t\tif((pow&1)==1)\n\t\t\t{\n\t\t\t\tans = (ans*expo)%mod;\n\t\t\t}\n\t\t\texpo = (expo*expo)%mod;\n\t\t\tpow = pow>>1;\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic static void main(String args[]) throws Exception {\n        new Thread(null, new solution(),\"Main\",1<<26).start();\n    }\n\tpublic void run() {\n        InputReader sc  = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong x = sc.nextLong();\n\t\tif(x==0)\n\t\t{\n\t\t\tout.println(0);\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\tlong k = sc.nextLong();\n\t\tlong a = ((fastexpo(k+1)%mod)*(x%mod))%mod;\n\t\tlong b = (-1*fastexpo(k)%mod+mod)%mod;\n\t\tlong ans = (a+b+1)%mod;\n\t\tout.println(ans);\n\t\tout.close();\n    }\n}", "index": 923, "complexity": 2}
{"back-translation": "class GFG {\n    static int binarySearch(int[] arr, int l, int r, int x) {\n        if (r < l) return -1;\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x) return mid;\n        if (arr[mid] > x) return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    static int countOccurrences(int[] arr, int n, int x) {\n        int ind = binarySearch(arr, 0, n - 1, x);\n        if (ind == -1) return 0;\n        int count = 1;\n        int left = ind - 1;\n        while (left >= 0 && arr[left] == x) {\n            count++;\n            left--;\n        }\n        int right = ind + 1;\n        while (right < n && arr[right] == x) {\n            count++;\n            right++;\n        }\n        return count;\n    }\n    public static void main(String[] args) {\n        int arr[] = {1, 2, 2, 2, 2, 3, 4, 7, 8, 8};\n        int n = arr.length;\n        int x = 2;\n        System.out.print(countOccurrences(arr, n, x));\n    }\n}", "src": "\n// Java program to count \n// occurrences of an element \nclass\nGFG \n{ \n\n\n// A recursive binary search \n\n// function. It returns location \n\n// of x in given array arr[l..r] \n\n// is present, otherwise -1 \n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n\n{ \n\nif\n(r < l) \n\nreturn\n-\n1\n; \n\n\nint\nmid = l + (r - l) / \n2\n; \n\n\n// If the element is present \n\n// at the middle itself \n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n// If element is smaller than \n\n// mid, then it can only be \n\n// present in left subarray \n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, \n\nmid - \n1\n, x); \n\n\n// Else the element can \n\n// only be present in \n\n// right subarray \n\nreturn\nbinarySearch(arr, mid + \n1\n, r, x); \n\n} \n\n\n// Returns number of times x \n\n// occurs in arr[0..n-1] \n\nstatic\nint\ncountOccurrences(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\nint\nind = binarySearch(arr, \n0\n, \n\nn - \n1\n, x); \n\n\n// If element is not present \n\nif\n(ind == -\n1\n) \n\nreturn\n0\n; \n\n\n// Count elements on left side. \n\nint\ncount = \n1\n; \n\nint\nleft = ind - \n1\n; \n\nwhile\n(left >= \n0\n&& \n\narr[left] == x) \n\n{ \n\ncount++; \n\nleft--; \n\n} \n\n\n// Count elements \n\n// on right side. \n\nint\nright = ind + \n1\n; \n\nwhile\n(right < n && \n\narr[right] == x) \n\n{ \n\ncount++; \n\nright++; \n\n} \n\n\nreturn\ncount; \n\n} \n\n\n\n// Driver code \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n\n3\n, \n4\n, \n7\n, \n8\n, \n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.print(countOccurrences(arr, n, x)); \n\n} \n} \n\n// This code is contributed \n// by ChitraNayal ", "index": 924, "complexity": 2}
{"back-translation": "class SmallestMissing {\n\n    int findFirstMissing(int[] array, int start, int end) {\n        if (start > end)\n            return end + 1;\n\n        if (start != array[start])\n            return start;\n\n        int mid = (start + end) / 2;\n\n        if (array[mid] == mid)\n            return findFirstMissing(array, mid+1, end);\n\n        return findFirstMissing(array, start, mid);\n    }\n\n    public static void main(String[] args) {\n        SmallestMissing small = new SmallestMissing();\n\n        int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 10 };\n        int n = arr.length;\n\n        System.out.println(\"First Missing element is : \" + small.findFirstMissing(arr, 0, n - 1));\n    }\n}", "src": "\nclass\nSmallestMissing \n{ \n\nint\nfindFirstMissing(\nint\narray[], \nint\nstart, \nint\nend) \n\n{ \n\nif\n(start > end) \n\nreturn\nend + \n1\n; \n\n\nif\n(start != array[start]) \n\nreturn\nstart; \n\n\nint\nmid = (start + end) / \n2\n; \n\n\n// Left half has all elements from 0 to mid \n\nif\n(array[mid] == mid) \n\nreturn\nfindFirstMissing(array, mid+\n1\n, end); \n\n\nreturn\nfindFirstMissing(array, start, mid); \n\n} \n\n\n// Driver program to test the above function \n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSmallestMissing small = \nnew\nSmallestMissing(); \n\nint\narr[] = {\n0\n, \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"First Missing element is : \"\n\n+ small.findFirstMissing(arr, \n0\n, n - \n1\n)); \n\n} \n} ", "index": 925, "complexity": 2}
{"back-translation": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        FastReader in;\n        PrintWriter out;\n        int n;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.nextInt();\n            if (n % 4 != 0) {\n                out.println(\"! -1\");\n                return;\n            }\n            int low = 0;\n            int high = n >> 1;\n            int fSign = Integer.signum(BValue(low));\n            if (fSign == 0) {\n                out.println(\"! \" + (low + 1));\n                return;\n            }\n            while (high - low > 1) {\n                int mid = (high + low) >> 1;\n                int mSign = Integer.signum(BValue(mid));\n                if (mSign == 0) {\n                    out.println(\"! \" + (mid + 1));\n                    return;\n                }\n                if (mSign == -fSign) {\n                    high = mid;\n                } else {\n                    low = mid;\n                }\n            }\n            out.println(\"! -1\");\n        }\n\n        public int BValue(int index) {\n            out.println(\"? \" + (index + 1));\n            out.flush();\n            int f = in.nextInt();\n            out.println(\"? \" + (index + 1 + (n >> 1)));\n            out.flush();\n            int s = in.nextInt();\n            return f - s;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        FastReader in;\n        PrintWriter out;\n        int n;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.nextInt();\n            if (n % 4 != 0) {\n                out.println(\"! -1\");\n                return;\n            }\n            int low = 0;\n            int high = n >> 1;\n            int fSign = Integer.signum(BValue(low));\n            if (fSign == 0) {\n                out.println(\"! \" + (low + 1));\n                return;\n            }\n            while (high - low > 1) {\n                int mid = (high + low) >> 1;\n                int mSign = Integer.signum(BValue(mid));\n                if (mSign == 0) {\n                    out.println(\"! \" + (mid + 1));\n                    return;\n                }\n                if (mSign == -fSign) {\n                    high = mid;\n                } else {\n                    low = mid;\n                }\n            }\n            out.println(\"! -1\");\n        }\n\n        public int BValue(int index) {\n            out.println(\"? \" + (index + 1));\n            out.flush();\n            int f = in.nextInt();\n            out.println(\"? \" + (index + 1 + (n >> 1)));\n            out.flush();\n            int s = in.nextInt();\n            return f - s;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "index": 928, "complexity": 2}
{"back-translation": "public class CircularBinarySearch {\n    public int search(int[] arr) {\n        int low = 0;\n        int high = arr.length - 1;\n        int mid = 0;\n        while (low < high) {\n            mid = (low + high) / 2;\n            if ((low == mid || arr[mid] < arr[mid - 1]) && arr[mid] < arr[mid + 1]) {\n                return arr[mid];\n            }\n            if ((arr[mid] >= arr[low] && arr[mid] >= arr[high])) {\n                if (arr[low] < arr[high]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            } else {\n                if (arr[mid - 1] < arr[mid + 1]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return arr[low];\n    }\n\n    public static void main(String[] args) {\n        CircularBinarySearch cbs = new CircularBinarySearch();\n        int[] arr = {7, 10, 8, 5, 2, 3, 5};\n        System.out.print(cbs.search(arr));\n        int[] arr1 = {5, 8, 10, 7, 5, 3, 2};\n        System.out.print(cbs.search(arr1));\n        int[] arr2 = {3, 5, 7, 10, 8, 5, 2};\n        System.out.print(cbs.search(arr2));\n        int[] arr3 = {8, 5, 2, 3, 5, 7, 10};\n        System.out.print(cbs.search(arr3));\n        int[] arr4 = {5, 3, 2, 5, 8, 10, 7};\n        System.out.print(cbs.search(arr4));\n        int[] arr5 = {100, 20, 10, 5, 2, 8, 11, 16, 19};\n        System.out.print(cbs.search(arr5));\n        int[] arr6 = {200, 2, 10, 15, 20, 80, 110, 160, 190};\n        System.out.print(cbs.search(arr6));\n        int[] arr7 = {5, 10, 20, 50, 200, 800, 1100, 1600, 1900, 2};\n        System.out.print(cbs.search(arr7));\n        int[] arr8 = {2, 5, 10, 20, 50, 200, 800, 1100, 1600, 1900};\n        System.out.print(cbs.search(arr8));\n        int[] arr9 = {3, 1, 8, 5, 4};\n        System.out.print(cbs.search(arr9));\n    }\n}", "src": "package com.interview.binarysearch;\n\n/**\n * http://www.careercup.com/question?id=4877486110277632\n * Given a circle with N defined points and a point M outside the circle, \n * find the point that is closest to M among the set of N. O(LogN)\n * Test cases\n * 1) smallest element at center\n * 2) smallest element at left/right end\n * 3) largest element at center\n * 4) smallest element at left side\n * 5) smallest element at right side\n */\npublic class CircularBinarySearch {\n\n    //if mid is greater than both ends than result is low of two ends else move in direction\n    //where either mid-1 or mid+1 is less\n    public int search(int arr[]) {\n        int low = 0;\n        int high = arr.length - 1;\n        int mid = 0;\n        while (low < high) {\n            mid = (low + high) / 2;\n            //if middle is less than both mid-1 and mid+1 then mid is the answer\n            if((low == mid || arr[mid] < arr[mid-1])&& arr[mid] < arr[mid+1]){\n                return arr[mid];\n            }\n            if ((arr[mid] >= arr[low] && arr[mid] >= arr[high])){\n                if(arr[low] < arr[high]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }else{\n                if(arr[mid-1] < arr[mid+1]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return arr[low];\n    }\n\n    public static void main(String args[]) {\n        CircularBinarySearch cbs = new CircularBinarySearch();\n        int arr[] = { 7, 10, 8, 5, 2, 3, 5 };\n        System.out.print(cbs.search(arr));\n\n        int arr1[] = { 5, 8, 10, 7, 5, 3, 2 };\n        System.out.print(cbs.search(arr1));\n\n        int arr2[] = { 3, 5, 7, 10, 8, 5, 2 };\n        System.out.print(cbs.search(arr2));\n\n        int arr3[] = { 8, 5, 2, 3, 5, 7, 10 };\n        System.out.print(cbs.search(arr3));\n\n        int arr4[] = { 5, 3, 2, 5, 8, 10, 7 };\n        System.out.print(cbs.search(arr4));\n\n        int arr5[] = {100,20,10,5,2,8,11,16,19};\n        System.out.print(cbs.search(arr5));\n\n        int arr6[] = {200,2,10,15,20,80,110,160,190};\n        System.out.print(cbs.search(arr6));\n\n        int arr7[] = {5,10,20,50,200,800,1100,1600,1900,2};\n        System.out.print(cbs.search(arr7));\n\n        int arr8[] = {2,5,10,20,50,200,800,1100,1600,1900};\n        System.out.print(cbs.search(arr8));\n        \n        int arr9[] = {3,1,8,5,4};\n        System.out.print(cbs.search(arr9));\n        \n    }\n}", "index": 929, "complexity": 2}
{"back-translation": "class PeakElement {\n    int findPeakElement(int[] nums) {\n        int low = 0;\n        int high = nums.length - 1;\n        int middle = 0;\n        while (low <= high) {\n            middle = (low + high) / 2;\n            int before = Integer.MIN_VALUE;\n            if (middle > 0) {\n                before = nums[middle - 1];\n            }\n            int after = Integer.MIN_VALUE;\n            if (middle < nums.length - 1) {\n                after = nums[middle + 1];\n            }\n            if (nums[middle] > before && nums[middle] > after) {\n                return middle;\n            } else if (before > after) {\n                high = middle - 1;\n            } else {\n                low = middle + 1;\n            }\n        }\n        return middle;\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {10, 5, 15, 2, 23, 90, 67};\n        PeakElement pe = new PeakElement();\n        System.out.println(pe.findPeakElement(arr));\n        int arr1[] = {10, 20, 30, 40, 50};\n        System.out.println(pe.findPeakElement(arr1));\n        int arr2[] = {100, 90, 80, 70, 60};\n        System.out.println(pe.findPeakElement(arr2));\n    }\n}", "src": "package com.interview.binarysearch;\n\n/**\n * @author Tushar Roy\n * Date 01/17/2107\n * A peak element is an element that is greater than its neighbors. Find index of peak element in the array.\n *\n * Space complexity is O(1)\n * Time complexity is O(n)\n *\n * https://leetcode.com/problems/find-peak-element/\n */\npublic class PeakElement {\n\n    public int findPeakElement(int[] nums) {\n        int low = 0;\n        int high = nums.length - 1;\n        int middle = 0;\n        while (low <= high) {\n            middle = (low + high)/2;\n            int before = Integer.MIN_VALUE;\n            if (middle > 0) {\n                before = nums[middle - 1];\n            }\n            int after = Integer.MIN_VALUE;\n            if (middle < nums.length - 1) {\n                after = nums[middle + 1];\n            }\n            if (nums[middle] > before && nums[middle] > after) {\n                return middle;\n            } else if (before > after) {\n                high = middle - 1;\n            } else {\n                low = middle + 1;\n            }\n        }\n        return middle;\n    }\n\n    public static void main(String args[]){\n        int arr[] = {10,5,15,2,23,90,67};\n        PeakElement pe = new PeakElement();\n        System.out.println(pe.findPeakElement(arr));\n        int arr1[] = {10,20,30,40,50};\n        System.out.println(pe.findPeakElement(arr1));\n        int arr2[] = {100,90,80,70,60};\n        System.out.println(pe.findPeakElement(arr2));\n                \n    }\n}\n", "index": 930, "complexity": 2}
{"back-translation": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        FastReader in;\n        PrintWriter out;\n        int n;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.nextInt();\n            if (n % 4 != 0) {\n                out.println(\"! -1\");\n                return;\n            }\n            int low = 0;\n            int high = n >> 1;\n            if (BValue(low) == 0) {\n                out.println(\"! \" + (low + 1));\n                return;\n            }\n            int fSign = Integer.signum(BValue(low));\n            while (high - low > 1) {\n                int mid = (high + low) >> 1;\n                int mSign = Integer.signum(BValue(mid));\n                if (mSign == 0) {\n                    out.println(\"! \" + (mid + 1));\n                    return;\n                }\n                if (mSign == -fSign) {\n                    high = mid;\n                } else {\n                    low = mid;\n                }\n            }\n            out.println(\"! -1\");\n        }\n\n        public int BValue(int index) {\n            out.println(\"? \" + (index + 1));\n            out.flush();\n            int f = in.nextInt();\n            out.println(\"? \" + (index + 1 + (n >> 1)));\n            out.flush();\n            int s = in.nextInt();\n            return f - s;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}", "src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        FastReader in;\n        PrintWriter out;\n        int n;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            n = in.nextInt();\n            if (n % 4 != 0) {\n                out.println(\"! -1\");\n                return;\n            }\n            int low = 0;\n            int high = n >> 1;\n            if (BValue(low) == 0) {\n                out.println(\"! \" + (low + 1));\n                return;\n            }\n            int fSign = Integer.signum(BValue(low));\n            while (high - low > 1) {\n                int mid = (high + low) >> 1;\n                int mSign = Integer.signum(BValue(mid));\n                if (mSign == 0) {\n                    out.println(\"! \" + (mid + 1));\n                    return;\n                }\n                if (mSign == -fSign) {\n                    high = mid;\n                } else {\n                    low = mid;\n                }\n            }\n            out.println(\"! -1\");\n        }\n\n        public int BValue(int index) {\n            out.println(\"? \" + (index + 1));\n            out.flush();\n            int f = in.nextInt();\n            out.println(\"? \" + (index + 1 + (n >> 1)));\n            out.flush();\n            int s = in.nextInt();\n            return f - s;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "index": 931, "complexity": 2}
{"back-translation": "class BinarySearch { int binarySearch(int arr[], int l, int r, int x) { if (r >= l) { int mid = l + (r - l) / 2; if (arr[mid] == x) return mid; if (arr[mid] > x) return binarySearch(arr, l, mid - 1, x); return binarySearch(arr, mid + 1, r, x); } return -1; } public static void main(String args[]) { BinarySearch ob = new BinarySearch(); int arr[] = { 2, 3, 4, 10, 40 }; int n = arr.length; int x = 10; int result = ob.binarySearch(arr, 0, n - 1, x); if (result == -1) System.out.println(", "src": "\n// Java implementation of recursive Binary Search \nclass\nBinarySearch { \n\n// Returns index of x if it is present in arr[l.. \n\n// r], else return -1 \n\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r >= l) { \n\nint\nmid = l + (r - l) / \n2\n; \n\n\n// If the element is present at the \n\n// middle itself \n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n// If element is smaller than mid, then \n\n// it can only be present in left subarray \n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid - \n1\n, x); \n\n\n// Else the element can only be present \n\n// in right subarray \n\nreturn\nbinarySearch(arr, mid + \n1\n, r, x); \n\n} \n\n\n// We reach here when element is not present \n\n// in array \n\nreturn\n-\n1\n; \n\n} \n\n\n// Driver method to test above \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinarySearch ob = \nnew\nBinarySearch(); \n\nint\narr[] = { \n2\n, \n3\n, \n4\n, \n10\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n10\n; \n\nint\nresult = ob.binarySearch(arr, \n0\n, n - \n1\n, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element not present\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at index \"\n+ result); \n\n} \n} \n/* This code is contributed by Rajat Mishra */", "index": 932, "complexity": 2}
