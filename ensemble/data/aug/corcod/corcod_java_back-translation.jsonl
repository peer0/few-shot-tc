{"back-translation": "public class TestClass1 {\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s[] = br.readLine().split(\" \");\n\n        long A, B, y, g, b;\n        A = Long.parseLong(s[0]);\n        B = Long.parseLong(s[1]);\n        s = br.readLine().split(\" \");\n\n        y = Long.parseLong(s[0]);\n        g = Long.parseLong(s[1]);\n        b = Long.parseLong(s[2]);\n\n        long ans = 0;\n        if (A - 2 * y - g < 0) {\n            ans += Math.abs(A - 2 * y - g);\n        }\n\n        if (B - g - 3 * b < 0) {\n            ans += Math.abs(B - g - 3 * b);\n        }\n        System.out.println(ans);\n\n    }\n}", "src": "public class TestClass1 {\n\n\n    public static void main(String[] args) throws  Exception{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s[] = br.readLine().split(\" \");\n\n        long A,B,y,g,b;\n        A= Long.parseLong(s[0]);\n        B= Long.parseLong(s[1]);\n        s=br.readLine().split(\" \");\n\n        y = Long.parseLong(s[0]);\n        g = Long.parseLong(s[1]);\n        b = Long.parseLong(s[2]);\n\nlong ans=0;\n        if(A-2*y-g < 0){\n            ans+=Math.abs(A-2*y-g);\n        }\n        \n        if(B-g-3*b < 0){\n            ans+=Math.abs(B-g-3*b);\n        }\n        System.out.println(ans);\n\n\n\n    }\n}", "index": 1, "complexity": "0"}
{"back-translation": "public class Codechef\n{\n    static String reverse(String s){\n        StringBuilder reverse=new StringBuilder();\n        for(int i=s.length()-1;i>=0;i--){\n            reverse.append(s.charAt(i));\n        }\n        return reverse.toString();\n    }\n\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        int x=m%(int)Math.pow(2,n);\n        System.out.println(x);\n    }\n}", "src": "public class Codechef\n{     \n  static String reverse(String s){\n    String reverse=\"\";\n    for(int i=s.length()-1;i>=0;i--){\n        reverse=reverse + s.charAt(i);\n    }\n    return reverse;\n  }\n\n      \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc=new Scanner(System.in);\n         int n=sc.nextInt();\n         int m=sc.nextInt();\n         int x=m%(int)Math.pow(2,n);\n         System.out.println(x);\n\n\n\n}\n}", "index": 2, "complexity": "0"}
{"back-translation": "public class task1 {\n    public static void main(String args[]) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int pos = in.nextInt();\n        int l = in.nextInt();\n        int r = in.nextInt();\n        boolean b = false;\n        boolean c = true;\n        if (l == 1 && r == n) {\n            c = false;\n            System.out.println(0);\n        }\n        if (c) {\n            if (l == 1) {\n                if (pos < r) {\n                    System.out.println(r - pos + 1);\n                    b = true;\n                } else {\n                    System.out.println(pos - r + 1);\n                    b = true;\n                }\n            }\n            if (r == n) {\n                if (pos > l) {\n                    System.out.println(pos - l + 1);\n                    b = true;\n                } else {\n                    System.out.println(l - pos + 1);\n                    b = true;\n                }\n            }\n        }\n        if (b == false && c) {\n            if (pos < l) {\n                System.out.println(l - pos + 1 + r - l + 1);\n            } else if (pos > r) {\n                System.out.println(pos - r + 1 + r - l + 1);\n            } else {\n                if (((pos - l) < (r - pos))) {\n                    System.out.println(pos - l + 1 + r - l + 1);\n                } else if ((pos - l) > (r - pos)) {\n                    System.out.println(r - pos + 1 + r - l + 1);\n                } else {\n                    System.out.println((r - pos) * 3 + 2);\n                }\n            }\n        }\n    }\n}", "src": "public class task1{\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        int n=in.nextInt();\n        int pos=in.nextInt();\n        int l=in.nextInt();\n        int r=in.nextInt();\n        boolean b=false;\n        boolean c=true;\n        if(l==1&&r==n){\n            c=false;\n            System.out.println(0);\n        }\n        if(c){\n            if(l==1){\n            if(pos<r){\n                System.out.println(r-pos+1);\n                b=true;}\n            else{\n                System.out.println(pos-r+1);\n                b=true;\n            }\n        }\n        if(r==n){\n            if(pos>l){\n                System.out.println(pos-l+1);\n                b=true;}\n            else{\n                System.out.println(l-pos+1);\n                b=true;\n            }\n        }\n        }\n        if(b==false&&c){\n            if(pos<l){\n            System.out.println(l-pos+1+r-l+1);\n        }\n        else if(pos>r){\n            System.out.println(pos-r+1+r-l+1);\n        }\n        else{\n            if(((pos-l)<(r-pos))){\n                System.out.println(pos-l+1+r-l+1);\n                \n            }\n            \n            else if((pos-l)>(r-pos)){\n                System.out.println(r-pos+1+r-l+1);\n                \n            }\n            else{\n                System.out.println((r-pos)*3+2);\n                \n            }\n        }\n        }\n        \n    }\n}", "index": 3, "complexity": "0"}
{"back-translation": "public class C {\n\n    static StringBuilder st = new StringBuilder();\n\n    public static void main(String[] args) throws Exception {\n\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int[] freq = new int[5];\n\n        int k = 3;\n        while (k-- > 0) {\n            int x = sc.nextInt();\n\n            if (x <= 4) freq[x]++;\n\n        }\n        freq[2] += freq[4] / 2;\n\n        if (freq[1] >= 1 || freq[2] >= 2 || freq[3] >= 3)\n            out.println(\"YES\");\n        else\n            out.println(\"NO\");\n\n        out.flush();\n        out.close();\n\n    }\n\n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        Scanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() throws Exception {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int nextInt() throws Exception {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws Exception {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws Exception {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n    static void shuffle(int[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n}", "src": "public class C\n{\n\n\tstatic StringBuilder st = new StringBuilder();\n\t\n\tpublic static void main(String[] args) throws Exception \n\t{\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint [] freq = new int [5] ; \n\t\t\n\t\tint k = 3;  \n\t\twhile(k -- >0)\n\t\t{\n\t\t\tint x = sc.nextInt();\n\t\t\t\n\t\t\tif(x <= 4) freq[x]++;\n\t\t\t\n\t\t}\n\t\tfreq[2] += freq[4]/ 2 ;\n\t\t\n\t\tif(freq[1] >= 1 || freq[2] >= 2 || freq[3] >= 3)\n\t\t\tout.println(\"YES\");\n\t\telse\n\t\t\tout.println(\"NO\");\n\t\t\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in) \n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n}", "index": 4, "complexity": "0"}
{"back-translation": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x + y - a, 0) + Math.max(y + 3*z - b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "src": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 5, "complexity": "0"}
{"back-translation": "public class A912 {\n\n\tpublic static void main(String[] args) {\n\t\t\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tint A = scan.nextInt();\n\t\tint B = scan.nextInt();\n\t\tlong x = scan.nextInt();\n\t\tlong y = scan.nextInt();\n\t\tlong z = scan.nextInt();\n\t\t\n\t\tlong requiredA = x * 2 + y;\n\t\tlong requiredB = y + z * 3;\n\t\t\n\t\tlong neededA = Math.max(0, requiredA - A);\n\t\tlong neededB = Math.max(0, requiredB - B);\n\t\tSystem.out.print(neededA + neededB);\n\t}\n\n}", "src": "public class A912 {\n\n\tpublic static void main(String[] args) {\n\t\t\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tint A = scan.nextInt();\n\t\tint B = scan.nextInt();\n\t\tlong x = scan.nextInt();\n\t\tlong y = scan.nextInt();\n\t\tlong z = scan.nextInt();\n\t\t\n\t\tlong requiredA = x * 2 + y;\n\t\tlong requiredB = y + z * 3;\n\t\t\n\t\tlong neededA = Math.max(0, requiredA - A);\n\t\tlong neededB = Math.max(0, requiredB - B);\n\t\tSystem.out.print(neededA + neededB);\n\t}\n\n}", "index": 6, "complexity": "0"}
{"back-translation": "public class Test3 {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tint x = Integer.parseInt(br.readLine());\n\t\t\tint y = Integer.parseInt(br.readLine());\n\t\t\tSystem.out.print((int) (y % (Math.pow(2, x))));\n\t\t} catch (NumberFormatException | IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "src": "public class Test3 {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tint x=Integer.parseInt(br.readLine());\n\t\tint y=Integer.parseInt(br.readLine());\n\t\tSystem.out.print((int)(y%(Math.pow(2, x))));\n\t}\n}", "index": 7, "complexity": "0"}
{"back-translation": "public class NEWCLASSNAME {\n    public static void main(String[] args) {\n        try {\n            try (Scanner sc = new Scanner(System.in)) {\n                int n = sc.nextInt();\n                BigInteger m = sc.nextBigInteger();\n                System.out.println(m.mod(BigInteger.valueOf(2).pow(n)));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "src": "public class RENAMETHISBITCH {\n\t\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tBigInteger m = sc.nextBigInteger();\n\t\t\t\n\t\t\tSystem.out.println(m.mod(BigInteger.valueOf(2).pow(n)));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "index": 8, "complexity": "0"}
{"back-translation": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint pos = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t\n\t\t\tif(l == 1 && r == n) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t} else if(l == 1 && r < n) {\n\t\t\t\tSystem.out.println(Math.abs(r - pos) + 1);\n\t\t\t} else if(l > 1 && r == n) {\n\t\t\t\tSystem.out.println(Math.abs(l - pos) + 1);\n\t\t\t} else if(l > 1 && r < n) {\n\t\t\t\tint c = Math.min(Math.abs(r - pos), Math.abs(l - pos));\n\t\t\t\tSystem.out.println(c + 2 + r - l);\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\tint n = sc.nextInt();\n\t\tint pos = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\t\n\t\tif(l==1&&r==n) {\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(l==1&&r<n) {\n\t\t\tSystem.out.println(Math.abs(r-pos)+1);\n\t\t}\n\t\telse if(l>1&&r==n) {\n\t\t\tSystem.out.println(Math.abs(l-pos)+1);\n\t\t}\n\t\telse if(l>1&&r<n) {\n\t\t\tint c = Math.min(Math.abs(r-pos), Math.abs(l-pos));\n\t\t\tSystem.out.println(c+2+r-l);\n\t\t}\n\t\t}\n\t}\t\n}", "index": 9, "complexity": "0"}
{"back-translation": "public class A {\n    static FastReader scan;\n    static PrintWriter out;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        MySolver solver = new MySolver();\n        scan = new FastReader();\n        out = new PrintWriter(System.out);\n        int testCases = 1;\n        for (int i = 1; i <= testCases; i++) {\n            solver.solve();\n        }\n        out.close();\n    }\n\n    static class MySolver {\n        void solve() {\n            int a = scan.nextInt(), b = scan.nextInt();\n            if (b <= a)\n                out.println(1);\n            else\n                out.println(b / a + Math.min(1, b % a));\n        }\n    }\n\n    static class DSU {\n        int[] root, size;\n        int n;\n\n        DSU(int n) {\n            this.n = n;\n            root = new int[n];\n            size = new int[n];\n            for (int i = 0; i < n; i++) {\n                root[i] = i;\n                size[i] = 1;\n            }\n        }\n\n        int findParent(int idx) {\n            while (root[idx] != idx) {\n                root[idx] = root[root[idx]];\n                idx = root[idx];\n            }\n            return idx;\n        }\n\n        boolean union(int x, int y) {\n            int parX = findParent(x);\n            int parY = findParent(y);\n            if (parX == parY)\n                return false;\n            if (size[parX] < size[parY]) {\n                root[parY] = parX;\n                size[parX] += size[parY];\n            } else {\n                root[parX] = parY;\n                size[parY] += size[parX];\n            }\n            return true;\n        }\n    }\n\n    // Remaining translation omitted for brevity\n}", "src": "public class A {\n\tstatic FastReader scan;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tSolver solver = new Solver();\n\t\tscan = new FastReader();\n\t\tout = new PrintWriter(System.out);\n\t\tint testCases = 1;\n\t\tfor(int i = 1; i <= testCases; i++) {\n\n\t\t\tsolver.solve();\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic class Solver {\n\t\t\n\t\tvoid solve() {\n\t\t\tint a = scan.nextInt(), b = scan.nextInt();\n\t\t\tif(b <= a) out.println(1);\n\t\t\telse out.println(b/a + Math.min(1, b%a));\n\t\t}\n\t\t\n\t}\n\n\t\n\n\tstatic class DSU {\n\t\tint[] root, size;\n\t\tint n;\n\n\t\tDSU(int n) {\n\t\t\tthis.n = n;\n\t\t\troot = new int[n];\n\t\t\tsize = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\troot[i] = i;\n\t\t\t\tsize[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tint findParent(int idx) {\n\t\t\twhile (root[idx] != idx) {\n\t\t\t\troot[idx] = root[root[idx]];\n\t\t\t\tidx = root[idx];\n\t\t\t}\n\t\t\treturn idx;\n\t\t}\n\n\t\tboolean union(int x, int y) {\n\t\t\tint parX = findParent(x);\n\t\t\tint parY = findParent(y);\n\t\t\tif (parX == parY)\n\t\t\t\treturn false;\n\t\t\tif (size[parX] < size[parY]) {\n\t\t\t\troot[parY] = parX;\n\t\t\t\tsize[parX] += size[parY];\n\t\t\t} else {\n\t\t\t\troot[parX] = parY;\n\t\t\t\tsize[parY] += size[parX];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic class Extra {\n\t\tstatic void sort(int[] a) {\n\t\t\tInteger[] aa = new Integer[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(long[] a) {\n\t\t\tLong[] aa = new Long[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(double[] a) {\n\t\t\tDouble[] aa = new Double[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(char[] a) {\n\t\t\tCharacter[] aa = new Character[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic long gcd(long a, long b) {\n\t\t\twhile (b > 0) {\n\t\t\t\tlong temp = b;\n\t\t\t\tb = a % b;\n\t\t\t\ta = temp;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n\n\t\tstatic boolean isPrime(long n) {\n\t\t\tif (n <= 1)\n\t\t\t\treturn false;\n\t\t\tif (n <= 3)\n\t\t\t\treturn true;\n\t\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\t\treturn false;\n\t\t\tfor (long i = 5; i * i <= n; i = i + 6) {\n\t\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tstatic HashSet<Integer> sieve(int n) {\n\t\t\tboolean[] prime = new boolean[n + 1];\n\t\t\tHashSet<Integer> res = new HashSet<>();\n\t\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\tif (!prime[p]) {\n\t\t\t\t\tres.add(p);\n\t\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\t\tprime[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic HashMap<Long, Integer> primeFactorization(long n) {\n\t\t\tHashMap<Long, Integer> res = new HashMap<>();\n\t\t\twhile (n % 2 == 0) {\n\t\t\t\tres.put(2L, res.getOrDefault(2L, 0) + 1);\n\t\t\t\tn /= 2;\n\t\t\t}\n\t\t\tfor (long i = 3; i * i <= n; i += 2) {\n\t\t\t\twhile (n % i == 0) {\n\t\t\t\t\tres.put(i, res.getOrDefault(i, 0) + 1);\n\t\t\t\t\tn /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n > 2)\n\t\t\t\tres.put(n, 1);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] a = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextDouble();\n\t\t\treturn a;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n}", "index": 10, "complexity": "0"}
{"back-translation": "public class Param { public static  void main( String[]args) { MyScanner param = new MyScanner(); out = new PrintWriter(new BufferedOutputStream(System.out)); int highestcoin=param.nextInt(); int sum=param.nextInt(); int remainder=sum%highestcoin; if(remainder!=0){ remainder=1; } else{ remainder=0; } int count=(sum-remainder)/highestcoin; if (highestcoin>=sum){ System.out.println(\"1\"); } else{ System.out.println(count+remainder); } out.close(); } public static PrintWriter out; public static class MyScanner { BufferedReader br; StringTokenizer st; public MyScanner() { br = new BufferedReader(new InputStreamReader(System.in)); } String next() { while (st == null || !st.hasMoreElements()) { try { st = new StringTokenizer(br.readLine()); } catch (IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong() { return Long.parseLong(next()); } double nextDouble() { return Double.parseDouble(next()); } String nextLine(){ String str = \"\"; try { str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } return str; } } }", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 11, "complexity": "0"}
{"back-translation": "public class pr1023B {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        long n = sc.nextLong();\n        long k = sc.nextLong();\n\n        out.println(solve(n, k));\n        out.flush();\n        out.close();\n    }\n\n\n    static long solve(long n, long k) {\n        return (long)Math.max(0, Math.floorDiv(n - Math.max(k - n, 0) + 1, 2));\n    }\n}", "src": "public class pr1023B {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        long n = sc.nextLong();\n        long k = sc.nextLong();\n\n        out.println(solve(n, k));\n        out.flush();\n        out.close();\n    }\n\n\n    static long solve(long n, long k) {\n        if(k <= n) return (long)Math.floor((double)(k-1)/2);\n        else{\n            long mx = n;\n            long mn = k-n;\n            return Math.max(0, (long)Math.floor((double)(mx-mn+1)/2));\n        }\n    }\n}", "index": 12, "complexity": "0"}
{"back-translation": "public class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int x = in.nextInt(),\n            y = in.nextInt(),\n            z = in.nextInt(),\n            t1 = in.nextInt(),\n            t2 = in.nextInt(),\n            t3 = in.nextInt()*3,\n            d = Math.abs(x - y);\n        if (((Math.abs(x - z) + d) * t2 + t3 > d * t1)) {\n            out.print(\"NO\");\n        } else {\n            out.print(\"YES\");\n        }\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}", "src": "public class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int x = in.nextInt(),\n            y = in.nextInt(),\n            z = in.nextInt(),\n            t1 = in.nextInt(),\n            t2 = in.nextInt(),\n            t3 = in.nextInt()*3,\n            d = Math.abs(x - y);\n        out.print(((Math.abs(x - z) + d) * t2 + t3 > d * t1 ? \"NO\" : \"YES\"));\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}", "index": 13, "complexity": "0"}
{"back-translation": "public class Solution {\n\n\tstatic long MOD = 1_000_000_000 + 7;\n\n\tpublic static long calculateValues(long n, long m, long k, long l) {\n\t\tlong p = (l + k) / m;\n\n\t\tif (p * m != l + k) {\n\t\t\tp++;\n\t\t}\n\n\t\tif (m * p <= n) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tlong n = Long.parseLong(st.nextToken());\n\t\tlong m = Long.parseLong(st.nextToken());\n\t\tlong k = Long.parseLong(st.nextToken());\n\t\tlong l = Long.parseLong(st.nextToken());\n\n\t\tSystem.out.println(calculateValues(n, m, k, l));\n\t}\n}", "src": "public class Solution {\n\n\tstatic long MOD = 1_000_000_000 + 7;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tlong n = Long.parseLong(st.nextToken());\n\t\tlong m = Long.parseLong(st.nextToken());\n\t\tlong k = Long.parseLong(st.nextToken());\n\t\tlong l = Long.parseLong(st.nextToken());\n\n\t\tlong p = (l + k) / m;\n\n\t\tif (p * m != l + k) {\n\t\t\tp++;\n\t\t}\n\n\t\tif (m * p <= n) {\n\t\t\tSystem.out.println(p);\n\t\t} else {\n\t\t\tSystem.out.println(-1);\n\t\t}\n\n\t}\n}", "index": 14, "complexity": "0"}
{"back-translation": "public class A {\n\n    public static void main(String[] args) {\n        BufferedReader br = null;\n        br = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n        try {\n            input = br.readLine();\n            long n = Long.parseLong(input.split(\" \")[0]);\n            long k = Long.parseLong(input.split(\" \")[1]);\n            long red = (long) (Math.ceil((n * 2.0) / k));\n            long blue = (long) (Math.ceil((n * 5.0) / k));\n            long green = (long) (Math.ceil((n * 8.0) / k));\n            String result = String.valueOf(red + blue + green);\n            System.out.println(result);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n}", "src": "public class A {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = null;\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n\t\ttry {\n\t\t\tinput = br.readLine();\n\t\t\tlong n = Long.parseLong(input.split(\" \")[0]);\n\t        long k = Long.parseLong(input.split(\" \")[1]);\n\t        long red = (long) (Math.ceil((n * 2.0)/k));\n\t        long blue = (long) (Math.ceil((n * 5.0)/k));\n\t        long green = (long) (Math.ceil((n * 8.0)/k));\n\t        System.out.println(red + blue +green);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}", "index": 15, "complexity": "0"}
{"back-translation": "public class EhabAndAnotherConstructionProblem {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint x = nextInt();\n\t\tif (x == 1) {\n\t\t\tSystem.out.println(-1);\n\t\t} else {\n\t\t\tSystem.out.println(x + \" \" + x);\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "src": "public class EhabAndAnotherConstructionProblem {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint x = nextInt();\n\t\tSystem.out.println(x == 1 ? -1 : x + \" \" + x);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 16, "complexity": "0"}
{"back-translation": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        long l = Math.max(1, k - n), r = (k + 1) / 2;\n        l = Math.max(0, r - l);\n        pw.print(l);\n\n    }\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "src": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        long l = Math.max(1, k - n), r = (k + 1) / 2;\n        l = Math.max(0, r - l);\n        pw.print(l);\n\n    }\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "index": 17, "complexity": "0"}
{"back-translation": "public class B {\n    \n    static StringBuilder st ; \n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        \n        String first = \"\" ; \n        String second = \"\" ; \n        \n        \n        for(int i = 0 ; i < 126 ;i++ ) {\n            first+= \"9\";\n            second+=\"9\";\n        }\n        \n        for(int i = 0 ; i < 125 ;i++ )\n            first+= \"0\";\n        \n        first += \"1\";\n        \n        out.println(first+\" \"+second);\n        \n        out.flush();\n        out.close();\n    }\n    \n    static int sumDigits(int num) {\n        int ans = 0 ;\n        \n        while(num > 0) {\n            ans += num % 10  ;\n            \n            num /= 10;\n        }\n        \n        return ans ;\n        \n    }\n    \n    static class Scanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n\n        String next() throws Exception  {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n\n            return st.nextToken();\n        }\n\n        int nextInt() throws Exception { return Integer.parseInt(next()); }\n        \n        long nextLong() throws Exception { return Long.parseLong(next()); }\n\n        double nextDouble() throws Exception { return Double.parseDouble(next()); }\n\n        char nextChar() throws Exception { return next().charAt(0); }\n        \n        char[] nextCharArray() throws Exception { return next().toCharArray(); }\n    }\n\n}", "src": "public class B \n{\n\t\n\tstatic StringBuilder st ; \n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner sc = new Scanner () ;\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tString first = \"\" ; \n\t\tString second = \"\" ; \n\t\t\n\t\t\n\t\tfor(int i = 0 ; i < 126 ;i++ )\n\t\t{\n\t\t\tfirst+= \"9\";\n\t\t\tsecond+=\"9\";\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < 125 ;i++ )\n\t\t\tfirst+= \"0\";\n\t\t\n\t\tfirst += \"1\";\n\t\t\n\t\tout.println(first+\" \"+second);\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t\n\t}\n\t\n\tstatic int sumDigits(int num)\n\t{\n\t\tint ans = 0 ;\n\t\t\n\t\twhile(num > 0)\n\t\t{\n\t\t\tans += num % 10  ;\n\t\t\t\n\t\t\tnum /= 10;\n\t\t}\n\t\t\n\t\treturn ans ;\n\t\t\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\n\t\tString next() throws Exception \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception { return Integer.parseInt(next()); }\n\t\t\n\t\tlong nextLong() throws Exception { return Long.parseLong(next()); }\n\n\t\tdouble nextDouble() throws Exception { return Double.parseDouble(next()); }\n\n\t\tchar nextChar() throws Exception { return next().charAt(0); }\n\t\t\n\t\tchar [] nextCharArray() throws Exception{ return next().toCharArray() ; }\n\t}\n\n}", "index": 18, "complexity": "0"}
{"back-translation": "public class A {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = null;\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n\t\ttry {\n\t\t\tinput = br.readLine();\n\t\t\tint n = Integer.parseInt(input);\n\t\t\tinput = br.readLine();\n\t\t\tint qx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint qy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint kx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint ky = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint gx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint gy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tif ((kx<qx && gx<qx) || (kx>qx && gx>qx)) {\n\t\t\t\tif ((ky<qy && gy<qy) || (ky>qy && gy>qy)) System.out.println(\"YES\");\n\t\t\t\telse System.out.println(\"NO\");\n\t\t\t} else System.out.println(\"NO\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}", "src": "public class A {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = null;\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n        String input;\n\t\ttry {\n\t\t\tinput = br.readLine();\n\t\t\tint n = Integer.parseInt(input);\n\t\t\tinput = br.readLine();\n\t\t\tint qx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint qy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint kx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint ky = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tinput = br.readLine();\n\t\t\tint gx = Integer.parseInt(input.split(\" \")[0]);\n\t\t\tint gy = Integer.parseInt(input.split(\" \")[1]);\n\t\t\tif((kx<qx && gx<qx)||(kx>qx && gx>qx)) {\n\t\t\t\tif((ky<qy && gy<qy)||(ky>qy && gy>qy))System.out.println(\"YES\");\n\t\t\t\telse System.out.println(\"NO\");\n\t\t\t}else System.out.println(\"NO\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}", "index": 19, "complexity": "0"}
{"back-translation": "public class A_KingEscape {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            int Qx = inp.nextInt(), Qy = inp.nextInt();\n            int Kx = inp.nextInt(), Ky = inp.nextInt();\n            int Tx = inp.nextInt(), Ty = inp.nextInt();\n            if (((Kx < Qx && Tx < Qx) || (Kx > Qx && Tx > Qx)) && ((Ky < Qy && Ty < Qy) || (Ky > Qy && Ty > Qy))) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "src": "public class A_KingEscape {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            int Qx = inp.nextInt(), Qy = inp.nextInt();\n            int Kx = inp.nextInt(), Ky = inp.nextInt();\n            int Tx = inp.nextInt(), Ty = inp.nextInt();\n            if (((Kx < Qx && Tx < Qx) || (Kx > Qx && Tx > Qx)) && ((Ky < Qy && Ty < Qy) || (Ky > Qy && Ty > Qy))) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 20, "complexity": "0"}
{"back-translation": "public class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader st = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer s = new StringTokenizer(st.readLine());\n        long n = Long.parseLong(s.nextToken());\n        long k = Long.parseLong(s.nextToken());\n        long ans = k / n;\n        if (k % n != 0) ans++;\n        System.out.println(ans + \"\");\n    }\n}", "src": "public class Main\n{\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tBufferedReader st = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer s = new StringTokenizer(st.readLine());\n\t\tlong n = Long.parseLong(s.nextToken());\n\t\tlong k = Long.parseLong(s.nextToken());\n\t\tlong ans = k/n;\n\t\tif(k%n != 0) ans++;\n\t\tSystem.out.println(ans+\"\");\n\t}\n}", "index": 21, "complexity": "0"}
{"back-translation": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        pw.print((n + k - 1) / n);\n\n    }\n\n    private static void Qsort(int[] array, int low, int high) {\n\n        int i = low;\n        int j = high;\n        int x = array[low + (high - low) / 2];\n\n        do {\n            while (array[i] < x) ++i;\n            while (array[j] > x) --j;\n            if (i <= j) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n                i++;\n                j--;\n            }\n        } while (i <= j);\n\n        if (low < j) Qsort(array, low, j);\n        if (i < high) Qsort(array, i, high);\n\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine() {\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return fullLine;\n    }\n\n    String[] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n}", "src": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        pw.print((n + k - 1) / n);\n\n    }\n\n    private static void Qsort(int[] array, int low, int high) {\n\n        int i = low;\n        int j = high;\n        int x = array[low + (high - low) / 2];\n\n        do {\n            while (array[i] < x) ++i;\n            while (array[j] > x) --j;\n            if (i <= j) {\n                int tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                i++;\n                j--;\n            }\n        } while (i <= j);\n\n        if (low < j) Qsort(array, low, j);\n        if (i < high) Qsort(array, i, high);\n\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "index": 22, "complexity": "0"}
{"back-translation": "public class Param {\n    public static void main(String[] args) {\n        MyScanner param = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int highestcoin = param.nextInt();\n        int sum = param.nextInt();\n        int remainder = sum % highestcoin;\n        if (remainder != 0) {\n            remainder = 1;\n        } else {\n            remainder = 0;\n        }\n        int count = (sum - remainder) / highestcoin;\n        if (highestcoin >= sum) {\n            System.out.println(\"1\");\n        } else {\n            System.out.println(count + remainder);\n        }\n        out.close();\n    }\n    public static PrintWriter out;\n\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 23, "complexity": "0"}
{"back-translation": "public class Main {\n\n    public static void main(String[] args) {\n        SpeedScanner speedScanner = new SpeedScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        taskSolver(speedScanner, out);\n        out.close();\n    }\n\n\n    public static void taskSolver(SpeedScanner speedScanner, PrintWriter out) {\n        long n = speedScanner.nextLong();\n        long m = speedScanner.nextLong();\n        long k = speedScanner.nextLong();\n        long l = speedScanner.nextLong();\n\n        long tempM ;\n\n        if ((k+l) < m){\n            if (n<m)\n                out.print(-1);\n            else\n                out.print(1);\n        }else {\n            tempM = (k+l)/m;\n            if ((k+l)%m == 0){\n                if (tempM*m <= n)\n                    out.print(tempM);\n                else\n                    out.print(-1);\n            }else {\n                if ((tempM+1)*m <= n)\n                    out.print(tempM+1);\n                else\n                    out.print(-1);\n            }\n        }\n    }\n\n\n    public static class SpeedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public SpeedScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n}", "src": "public class Main {\n\n    public static void main(String[] args) {\n        SpeedScanner speedScanner = new SpeedScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        taskSolver(speedScanner, out);\n        out.close();\n    }\n\n\n    public static void taskSolver(SpeedScanner speedScanner, PrintWriter out) {\n        long n = speedScanner.nextLong();\n        long m = speedScanner.nextLong();\n        long k = speedScanner.nextLong();\n        long l = speedScanner.nextLong();\n\n        long tempM ;\n\n        if ((k+l) < m){\n            if (n<m)\n                out.print(-1);\n            else\n                out.print(1);\n        }else {\n            tempM = (k+l)/m;\n            if ((k+l)%m == 0){\n                if (tempM*m <= n)\n                    out.print(tempM);\n                else\n                    out.print(-1);\n            }else {\n                if ((tempM+1)*m <= n)\n                    out.print(tempM+1);\n                else\n                    out.print(-1);\n            }\n        }\n    }\n\n\n    public static class SpeedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public SpeedScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n}", "index": 24, "complexity": "0"}
{"back-translation": "public class Main {\n\n    static StringBuilder data;\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt();\n        long answ = 0;\n        if (n * 2 > k) {\n            if ((n * 2) % k == 0) {\n                answ += (n * 2) / k;\n            } else {\n                answ += ((n * 2) / k) + 1;\n            }\n        } else {\n            answ++;\n        }\n        if (n * 5 > k) {\n            if ((n * 5) % k == 0) {\n                answ += (n * 5) / k;\n            } else {\n                answ += ((n * 5) / k) + 1;\n            }\n        } else {\n            answ++;\n        }\n        if (n * 8 > k) {\n            if ((n * 8) % k == 0) {\n                answ += (n * 8) / k;\n            } else {\n                answ += ((n * 8) / k) + 1;\n            }\n        } else {\n            answ++;\n        }\n        System.out.println(answ);\n    }\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "src": "public class Main {\n\n    static StringBuilder data;\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt();\n               long answ = 0;\n        if (n * 2 > k) {\n         if((n*2)%k==0){\n             answ+=(n*2)/k;\n         }else{\n             answ+=((n*2)/k)+1;\n         }\n        }else{\n            answ++;\n        }\n        if (n * 5 > k) {\n            if((n*5)%k==0){\n                answ+=(n*5)/k;\n            }else{\n                answ+=((n*5)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n        if (n * 8 > k) {\n            if((n*8)%k==0){\n                answ+=(n*8)/k;\n            }else{\n                answ+=((n*8)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 25, "complexity": "0"}
{"back-translation": "public class TransformedProgram {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint k = Integer.parseInt(st.nextToken());\n\t\tint t1 = (int) Math.ceil((double) n * 2 / k);\n\t\tint t2 = (int) Math.ceil((double) n * 5 / k);\n\t\tint t3 = (int) Math.ceil((double) n * 8 / k);\n\t\tSystem.out.println(t1 + t2 + t3);\n\t}\n}", "src": "public class programA {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint k = Integer.parseInt(st.nextToken());\n\t\tint t1 = (int)Math.ceil((double)n*2/k);\n\t\tint t2 = (int)Math.ceil((double)n*5/k);\n\t\tint t3 = (int)Math.ceil((double)n*8/k);\n\t\tSystem.out.println(t1+t2+t3);\n\t}\n}", "index": 26, "complexity": "0"}
{"back-translation": "public class bhaa {\n\n    InputStream is;\n    PrintWriter o;\n    \n\n\n\n    boolean chpr(int n)\n    {\n    \tif(n==1)\n    \t{\n    \t\treturn true;\n    \t}if(n==2)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n==3)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n%2==0)\n    \t{\n    \t\treturn false;\n\n    \t}\n    \tif(n%3==0)\n    \t{\n    \t\treturn false;\n    \t}\n    \t\n    \tint w=2;\n \t\tint i=5;\n    \twhile(i*i<=n)\n    \t{\n    \t\tif(n%i==0)\n    \t\t{\n    \t\t\treturn false;\n    \t\t}\n    \t\ti+=w;\n    \t\tw=6-w;\n    \t}\n    \treturn true;\n\n    }\n    \n    void solve() {\n\n\n        int n=ni();\n        int k=ni();\n        int rr=2*n;\n        int gr=5*n;\n        int br=8*n;\n        o.println((long)(Math.ceil(rr*1.0/k)+Math.ceil(gr*1.0/k)+Math.ceil(br*1.0/k)));\n\n\n\n    \t\n\n    }\n\n\n\n\n\n   \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    public static void main(String[] args) { new bhaa().run(); }\n    void run() { \n        is = System.in; \n        o = new PrintWriter(System.out);\n        solve();\n        o.flush();\n    }\n    \n    byte input[] = new byte[1024];\n    int len = 0, ptr = 0;\n    \n    int readByte() { \n        if(ptr >= len) { ptr = 0; \n            try { len = is.read(input); } \n            catch(IOException e) { throw new InputMismatchException(); } \n            if(len <= 0) { return -1; } \n        } return input[ptr++];\n    }\n    boolean isSpaceChar(int c) { return !( c >= 33 && c <= 126 ); }\n    int skip() { \n        int b = readByte(); \n        while(b != -1 && isSpaceChar(b)) { b = readByte(); } \n        return b;\n    }\n    \n    char nc() { return (char)skip(); }\n    String ns() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while(!isSpaceChar(b)) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    String nLine() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while( !(isSpaceChar(b) && b != ' ') ) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    int ni() { \n        int n = 0, b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        if(b == -1) { return -1; }  \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n    long nl() { \n        long n = 0L;    int b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n\n    double nd() { return Double.parseDouble(ns()); }\n    float nf() { return Float.parseFloat(ns()); }\n    int[] nia(int n) { \n        int a[] = new int[n]; \n        for(int i = 0; i < n; i++) { a[i] = ni(); } \n        return a;\n    }\n    long[] nla(int n) { \n        long a[] = new long[n]; \n        for(int i = 0; i < n; i++) { a[i] = nl(); } \n        return a;\n    }\n    int [][] nim(int n)\n    {\n        int mat[][]=new int[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=ni();\n            }\n        }\n        return mat;\n    }\n    long [][] nlm(int n)\n    {\n        long mat[][]=new long[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=nl();\n            }\n        }\n        return mat;\n    }\n    \n\n\n\n\n    \n    char[] ns(int n) { \n        char c[] = new char[n]; \n        int i, b = skip(); \n        for(i = 0; i < n; i++) { \n            if(isSpaceChar(b)) { break; } \n            c[i] = (char)b; b = readByte(); \n        } return i == n ? c : Arrays.copyOf(c,i);\n    }\n    void piarr(int arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    void plarr(long arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    \n    void pimat(int mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n    }\n    void plmat(long mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n\n    }\n\n\n\n\n    \n\n\n\n}", "src": "public class bhaa {\n\n    InputStream is;\n    PrintWriter o;\n    \n\n\n\n    boolean chpr(int n)\n    {\n    \tif(n==1)\n    \t{\n    \t\treturn true;\n    \t}if(n==2)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n==3)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n%2==0)\n    \t{\n    \t\treturn false;\n\n    \t}\n    \tif(n%3==0)\n    \t{\n    \t\treturn false;\n    \t}\n    \t\n    \tint w=2;\n \t\tint i=5;\n    \twhile(i*i<=n)\n    \t{\n    \t\tif(n%i==0)\n    \t\t{\n    \t\t\treturn false;\n    \t\t}\n    \t\ti+=w;\n    \t\tw=6-w;\n    \t}\n    \treturn true;\n\n    }\n    \n    void solve() {\n\n\n        int n=ni();\n        int k=ni();\n        int rr=2*n;\n        int gr=5*n;\n        int br=8*n;\n        o.println((long)(Math.ceil(rr*1.0/k)+Math.ceil(gr*1.0/k)+Math.ceil(br*1.0/k)));\n\n\n\n    \t\n\n    }\n\n\n\n\n\n   \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    public static void main(String[] args) { new bhaa().run(); }\n    void run() { \n        is = System.in; \n        o = new PrintWriter(System.out);\n        solve();\n        o.flush();\n    }\n    \n    byte input[] = new byte[1024];\n    int len = 0, ptr = 0;\n    \n    int readByte() { \n        if(ptr >= len) { ptr = 0; \n            try { len = is.read(input); } \n            catch(IOException e) { throw new InputMismatchException(); } \n            if(len <= 0) { return -1; } \n        } return input[ptr++];\n    }\n    boolean isSpaceChar(int c) { return !( c >= 33 && c <= 126 ); }\n    int skip() { \n        int b = readByte(); \n        while(b != -1 && isSpaceChar(b)) { b = readByte(); } \n        return b;\n    }\n    \n    char nc() { return (char)skip(); }\n    String ns() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while(!isSpaceChar(b)) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    String nLine() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while( !(isSpaceChar(b) && b != ' ') ) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    int ni() { \n        int n = 0, b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        if(b == -1) { return -1; }  \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n    long nl() { \n        long n = 0L;    int b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n\n    double nd() { return Double.parseDouble(ns()); }\n    float nf() { return Float.parseFloat(ns()); }\n    int[] nia(int n) { \n        int a[] = new int[n]; \n        for(int i = 0; i < n; i++) { a[i] = ni(); } \n        return a;\n    }\n    long[] nla(int n) { \n        long a[] = new long[n]; \n        for(int i = 0; i < n; i++) { a[i] = nl(); } \n        return a;\n    }\n    int [][] nim(int n)\n    {\n        int mat[][]=new int[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=ni();\n            }\n        }\n        return mat;\n    }\n    long [][] nlm(int n)\n    {\n        long mat[][]=new long[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=nl();\n            }\n        }\n        return mat;\n    }\n    \n\n\n\n\n    \n    char[] ns(int n) { \n        char c[] = new char[n]; \n        int i, b = skip(); \n        for(i = 0; i < n; i++) { \n            if(isSpaceChar(b)) { break; } \n            c[i] = (char)b; b = readByte(); \n        } return i == n ? c : Arrays.copyOf(c,i);\n    }\n    void piarr(int arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    void plarr(long arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    \n    void pimat(int mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n    }\n    void plmat(long mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n\n    }\n\n\n\n\n    \n\n\n\n}", "index": 27, "complexity": "0"}
{"back-translation": "public class DS {\n\n    \n   \n\n\n\n    public static void main(String[] args) throws IOException {\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       int x=Integer.parseInt(br.readLine());\n         \nif (x==1)\n            System.out.println(-1);\nelse\n            System.out.println(x+\" \"+x);\n\n        }\n\n        \n    }", "src": "public class DS {\n\n    \n   \n\n\n\n    public static void main(String[] args) throws IOException {\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       int x=Integer.parseInt(br.readLine());\n         \nif (x==1)\n            System.out.println(-1);\nelse\n            System.out.println(x+\" \"+x);\n\n        }\n\n        \n    }", "index": 28, "complexity": "0"}
{"back-translation": "public class DS {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int x = Integer.parseInt(br.readLine());\n        if (x == 1) {\n            System.out.println(-1);\n        } else {\n            System.out.println(x + \" \" + x);\n        }\n    }\n}", "src": "public class DS {\n\n    \n   \n\n\n\n    public static void main(String[] args) throws IOException {\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       int x=Integer.parseInt(br.readLine());\n         \nif (x==1)\n            System.out.println(-1);\nelse\n            System.out.println(x+\" \"+x);\n\n        }\n\n        \n    }", "index": 29, "complexity": "0"}
{"back-translation": "class FirstApp {\n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solve = new TaskA();\n        solve.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int number = in.nextInt();\n\n            if(number > 2 && number % 2 == 0) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n        }\n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n    }\n    \n}", "src": "public class FirstApp {\n    \n    \n \n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solve = new TaskA();\n        solve.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int number = in.nextInt();\n\n            if(number > 2 && number % 2 == 0) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n        }\n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n    }\n    \n}", "index": 30, "complexity": "0"}
{"back-translation": "public class Main implements Runnable {\n    static String readLn(int maxLength) {\n        byte line[] = new byte[maxLength];\n        int length = 0;\n        int input = -1;\n        try {\n            while (length < maxLength) {\n                input = System.in.read();\n                if ((input < 0) || (input == '\\n')) {\n                    break;\n                }\n\n                line[length++] += input;\n            }\n\n            if ((input < 0) && (length == 0)) {\n                return null;\n            }\n\n            return new String(line, 0, length);\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public static void main(String args[]) {\n        Main myWork = new Main();\n        myWork.run();\n    }\n\n    public void run() {\n        new Watermelon().run();\n    }\n}\n\nclass Watermelon implements Runnable {\n    public void run() {\n        String line = Main.readLn(100).trim();\n        int weight = Integer.parseInt(line);\n        System.out.println(weight % 2 == 0 && weight > 2 ? \"YES\": \"NO\");\n    }\n}", "src": "public class Main implements Runnable {\n  static String readLn(int maxLength) {\n\n    byte line[] = new byte[maxLength];\n    int length = 0;\n    int input = -1;\n    try {\n      while (length < maxLength) {\n        input = System.in.read();\n        if ((input < 0) || (input == '\\n')) {\n          break;\n        }\n\n        line[length++] += input;\n      }\n\n      if ((input < 0) && (length == 0)) {\n        return null;\n      }\n\n      return new String(line, 0, length);\n    } catch (IOException e) {\n      return null;\n    }\n  }\n\n  public static void main(String args[]) {\n    Main myWork = new Main();\n    myWork.run();\n  }\n\n  public void run() {\n    new Watermelon().run();\n  }\n}\n\nclass Watermelon implements Runnable {\n  public void run() {\n    String line = Main.readLn(100).trim();\n    int weight = Integer.parseInt(line);\n    System.out.println(weight % 2 == 0 && weight > 2 ? \"YES\": \"NO\");\n  }\n}", "index": 31, "complexity": "0"}
{"back-translation": "public class Solution\n{\n    public static void main(String[] args)\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try\n        {\n            String str = br.readLine();\n            int q = Integer.parseInt(str);\n            if(q % 2 == 0 && q != 2)\n                System.out.println(\"YES\");\n            else\n                System.out.println(\"NO\");\n        }\n        catch (NumberFormatException e)\n        {\n            System.out.println(\"Input Error\");\n        }\n    }\n}", "src": "public class Solution\n{\n    public static void main(String[] args)\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try\n        {\n            String str = br.readLine();\n            int q = Integer.parseInt(str);\n            \n            \n        if(q%2 == 0 && q!=2)\n                System.out.println(\"YES\");\n            else\n                System.out.println(\"NO\");\n            \n        }\n        catch(IOException e)\n        {\n            System.out.println(\"Input Error\");\n        }\n        \n        \n \n       \n \n    }\n}", "index": 32, "complexity": "0"}
{"back-translation": "public class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner kai = new Scanner(System.in);\n\t\tfor (int a = kai.nextInt(); kai.hasNext(); a = kai.nextInt()) {\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 33, "complexity": "0"}
{"back-translation": "public class Main{static class FastReader{BufferedReader br;StringTokenizer st;public FastReader(){br=new BufferedReader(new InputStreamReader(System.in));}String next(){while(st==null||!st.hasMoreElements()){try{st=new StringTokenizer(br.readLine());}catch(IOException e){e.printStackTrace();}}return st.nextToken();}int nextInt(){return Integer.parseInt(next());}long nextLong(){return Long.parseLong(next());}double nextDouble(){return Double.parseDouble(next());}float nextFloat(){return Float.parseFloat(next());}boolean nextBoolean(){return Boolean.parseBoolean(next());}String nextLine(){String str=\"\";try{str=br.readLine();}catch(IOException e){e.printStackTrace();}return str;}}static long modExp(long x,long n,long mod){long result=1;while(n>0){if(n%2==1)result=(result%mod*x%mod)%mod;x=(x%mod*x%mod)%mod;n=n/2;}return result;}static long gcd(long a,long b){if(a==0)return b;return gcd(b%a,a);}public static void main(String[] args) throws IOException{FastReader fr=new FastReader();System.out.println((int)(fr.nextInt()/2)+1);}}", "src": "public class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n      while (st == null || !st.hasMoreElements())\n      {\n        try\n        {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n      String str = \"\";\n      try\n      {\n        str = br.readLine();\n      }\n      catch (IOException e)\n      {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    \n  {\n    long result = 1;\n    while(n > 0)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    if(a==0) return b;\n    return gcd(b%a,a);\n  }\n  public static void main(String[] args)\n  throws IOException\n  {\n    FastReader fr = new FastReader();\n    System.out.println((int)(fr.nextInt()/2) + 1);\n\n  }\n}\nclass pair\n{\n  public int first;\n  public int second;\n  public pair(int first,int second)\n  {\n    this.first = first;\n    this.second = second;\n  }\n  public int first() { return first; }\n  public int second() { return second; }\n  public void setFirst(int first) { this.first = first; }\n  public void setSecond(int second) { this.second = second; }\n}\nclass myComp implements Comparator<pair>\n{\n  public int compare(pair a,pair b)\n  {\n    return (a.first - b.first);\n  }\n}\nclass BIT       \n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    for(int i = 0; i < dat.length; i++)\n    {\n      m_array[i + 1] = dat[i];\n    }\n    for(int i = 1; i < m_array.length; i++)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(++i; i > 0; i = i - (i & -i))\n    {\n      result = result + m_array[i];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length; i = i + (i & -i))\n    {\n      m_array[i] = m_array[i] + add;\n    }\n  }\n}", "index": 34, "complexity": "0"}
{"back-translation": "public class SolutionB {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        long[] a = new long[14];\n        for (int i = 0; i < 14; i++)\n            a[i] = sc.nextLong();\n        long[] cpy = new long[14];\n        long max = 0;\n        for (int i = 0; i < 14; i++) {\n            if (a[i] == 0) continue;\n            long score = 0;\n            long curr = a[i];\n            for (int j = 0; j < 14; j++)\n                cpy[j] = a[j];\n            cpy[i] = 0;\n            long amnt = curr / 14L;\n            for (int j = 0; j < 14; j++) {\n                cpy[j] += amnt;\n            }\n            amnt = curr % 14;\n            for (int j = i + 1; j < i + 1 + amnt; j++) {\n                cpy[j % 14]++;\n            }\n            for (int j = 0; j < 14; j++) {\n                if (cpy[j] % 2 == 0)\n                    score += cpy[j];\n            }\n            max = Math.max(max, score);\n        }\n        System.out.println(max);\n    }\n}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              long a[] = new long[14];\n              for(int i = 0; i < 14; i++)\n                     a[i] = sc.nextLong();\n              long cpy[] = new long[14];\n              long max = 0;\n              for(int i = 0; i < 14; i++){\n                     if(a[i] == 0)continue;\n                     long score = 0;\n                     long curr = a[i];\n                     for(int j = 0; j < 14; j++)\n                            cpy[j] = a[j];\n                     cpy[i] = 0;\n                     long amnt = curr / 14l;\n                     for(int j = 0; j < 14; j++){\n                            cpy[j] += amnt;\n                     }\n                     amnt = curr % 14;\n                     for(int j = i + 1; j < i + 1 + amnt; j++){\n                            cpy[j % 14]++;\n                     }\n                     for(int j = 0; j < 14; j++){\n                            if(cpy[j] % 2 == 0)\n                                   score += cpy[j];\n                     }\n                     max = Math.max(max, score);\n              }\n              System.out.println(max);\n      }\n}", "index": 35, "complexity": "0"}
{"back-translation": "class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        A979 solver = new A979();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A979 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            long n = in.nextLong();\n            n = n + 1;\n            if(n % 2 == 0) {\n                out.println(n / 2);\n            }\n            else {\n                if(n != 1) {\n                    out.println(n);\n                }\n                else {\n                    out.println(0);\n                }\n            }\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        A979 solver = new A979();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A979 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            long n = in.nextLong();\n            n = n + 1;\n            if (n % 2 == 0) {\n                out.println(n / 2);\n            } else {\n                if (n != 1) {\n                    out.println(n);\n                } else {\n                    out.println(0);\n                }\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 36, "complexity": "0"}
{"back-translation": "public class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public int nextInt() {\n            int c = read();\n\n            while (isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(), \"Main\", 1 << 26).start();\n    }\n\n    static void merge(int arr[], int l, int m, int r) {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    static void sort(int arr[], int l, int r) {\n        if (l < r) {\n            int m = (l + r) / 2;\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n            merge(arr, l, m, r);\n        }\n    }\n\n    static void merge(long arr[], int l, int m, int r) {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        long L[] = new long[n1];\n        long R[] = new long[n2];\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    static void sort(long arr[], int l, int r) {\n        if (l < r) {\n            int m = (l + r) / 2;\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n            merge(arr, l, m, r);\n        }\n    }\n\n    static int gcd(int a, int b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    public long m = (long) 1e9 + 7;\n\n    public void run() {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int a = in.nextInt(), b = in.nextInt(), c = in.nextInt(), n = in.nextInt();\n        int nnew = a + b - c;\n        if ((n > nnew) && (a >= c) && (b >= c))\n            out.println(n - nnew);\n        else\n            out.println(-1);\n\n        out.close();\n    }\n}", "src": "public class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    \n    static void merge(int arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(int arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    } \n    \n    static void merge(long arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        long L[] = new long [n1]; \n        long R[] = new long [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(long arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    }\n    static int gcd(int a, int b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    }\n    static long gcd(long a, long b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    } \n    public long m=(long)1e9+7;;\n    \n    public void run() {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int a=in.nextInt(),b=in.nextInt(),c=in.nextInt(),n=in.nextInt();\n        int nnew=a+b-c;\n        if((n>nnew) && (a>=c) && (b>=c))\n            out.println(n-nnew);\n        else\n            out.println(-1);\n        \n        out.close();\n    }\n}", "index": 37, "complexity": "0"}
{"back-translation": "public class IfAtFIrstYouDIdnt {\n\n\tpublic static void main(String[] args) {\n\t\t\n\n\t\tScanner input = new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tint c = input.nextInt();\n\t\tint n = input.nextInt();\n\t\tif (a < n && b < n && c < n && (a + b - c) < n && c <= a && c <= b) {\n\t\t\tSystem.out.println(n - (a + b - c));\n\t\t} else {\n\t\t\tSystem.out.println(\"-1\");\n\t\t}\n\t}\n\n}", "src": "public class IfAtFIrstYouDIdnt {\n\n\tpublic static void main(String[] args) {\n\t\t\n\n\t\tScanner input = new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tint c = input.nextInt();\n\t\tint n  = input.nextInt();\n\t\tif(a<n && b<n && c < n && (a+b-c)<n && c<=a && c<=b){\n\t\t\tSystem.out.println((n)-(a+b-c));\n\t\t}\n\t\telse\n\t\t\tSystem.out.println(\"-1\");\n\t}\n\n}", "index": 38, "complexity": "0"}
{"back-translation": "public class C_NNAndTheOpticalIllusion {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            double n = inp.nextInt(), r = inp.nextInt();\n            double x = Math.cos((n - 2) * Math.PI / (2 * n));\n            out.print((r * x) / (1 - x));\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "src": "public class C_NNAndTheOpticalIllusion {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            double n = inp.nextInt(), r = inp.nextInt();\n            double x = Math.cos((n - 2) * Math.PI / (2 * n));\n            out.print((r * x) / (1 - x));\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 39, "complexity": "0"}
{"back-translation": "public class HelloWorld { static class Palindrome { public void solve(int testNumber, InputReader in, PrintWriter out) { long l = in.nextLong(); if (l % 4 == 0 || l % 4 == 3) { out.print(\"0\"); } else { out.print(\"1\"); } } } static class InputReader { public BufferedReader reader; public StringTokenizer tokenizer; public InputReader(InputStream stream) { reader = new BufferedReader(new InputStreamReader(stream), 32768); tokenizer = null; } public String next() { while (tokenizer == null || !tokenizer.hasMoreTokens()) { try { tokenizer = new StringTokenizer(reader.readLine()); } catch (IOException e) { throw new RuntimeException(e); } } return tokenizer.nextToken(); } public long nextLong() { return Long.parseLong(next()); } } public static void main(String[] args) { InputStream inputStream = System.in; OutputStream outputStream = System.out; InputReader in = new InputReader(inputStream); PrintWriter out = new PrintWriter(outputStream); Palindrome solver = new Palindrome(); solver.solve(1, in, out); out.close(); } }", "src": "public class HelloWorld {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Palindrome solver = new Palindrome();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class Palindrome {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long l = in.nextLong();\n            \n            if(l%4 == 0 || l%4 == 3)\n            {\n                out.print(\"0\");\n            }\n            else\n            {\n                out.print(\"1\");\n            }\n        }\n \n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n \n    }\n}", "index": 40, "complexity": "0"}
{"back-translation": "public class Main {\n \n    private static final FS scanner = new FS(System.in);\n\t\n\t\n\tpublic static void main(String[] args) throws Exception {\n\n        int n = scanner.nextInt();\n        int sumA = 0;\n        int sumB = 0;\n        int rem = n % 4;\n        int i = rem;\n        while (i >= 1) {\n            if (sumB <= sumA) {\n                sumB += i;\n            } else {\n                sumA += i;\n            }\n            i--;\n        }\n\n        System.out.println(Math.abs(sumA - sumB));\n    }\n\t\n    static class FS {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FS(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n\n        public String next() throws IOException {\n            if (st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n \n}", "src": "public class Main {\n \n    private static final FS scanner = new FS(System.in);\n\t\n\t\n\tpublic static void main(String[] args) throws Exception {\n\n        int n = scanner.nextInt();\n        int sumA = 0;\n        int sumB = 0;\n        int rem = n % 4;\n        for (int i = rem; i >= 1 ; i--) {\n            if (sumB <= sumA) {\n                sumB += i;\n            }\n            else {\n                sumA +=i;\n            }\n        }\n\n        System.out.println(Math.abs(sumA - sumB));\n    }\n\t\n    static class FS {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FS(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n\n        public String next() throws IOException {\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n \n}", "index": 41, "complexity": "0"}
{"back-translation": "public class usd {\n\n    static int r = 0;\n    static int c = 0;\n\n    static void fillzero(int[][] a, int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - 1; j++) {\n                if (a[j][i] == 0 && a[j + 1][i] == 0) {\n                    a[j][i] = 1;\n                    a[j + 1][i] = 1;\n                    r = j;\n                    c = i;\n                    return;\n                }\n            }\n        }\n    }\n\n    static void fillone(int[][] a, int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - 1; j++) {\n                if (a[i][j] == 0 && a[i][j + 1] == 0) {\n                    a[i][j] = 1;\n                    a[i][j + 1] = 1;\n                    r = i;\n                    c = j;\n                    return;\n                }\n            }\n        }\n    }\n\n    static void check(int[][] a, int n) {\n        for (int i = 0; i < 4; i++) {\n            if (a[i][0] == 1 && a[i][1] == 1 && a[i][2] == 1 && a[i][3] == 1) {\n                a[i][0] = 0;\n                a[i][1] = 0;\n                a[i][2] = 0;\n                a[i][3] = 0;\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            if (a[0][i] == 1 && a[1][i] == 1 && a[2][i] == 1 && a[3][i] == 1) {\n                a[0][i] = 0;\n                a[1][i] = 0;\n                a[2][i] = 0;\n                a[3][i] = 0;\n            }\n        }\n    }\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n\n        Scanner in = new Scanner(System.in);\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\n        ArrayList<Integer> list = new ArrayList<Integer>();\n\n        long n = in.nextLong();\n        long ans = Long.MAX_VALUE;\n        long sum = 0;\n        long sum2 = (n * (n + 1)) / 2;\n        if (sum2 % 2 == 0)\n            System.out.println(0);\n        else\n            System.out.println(1);\n    }\n}", "src": "public class usd {\n\t\t\n\t\tstatic int r=0;static int c=0;\n\t\tstatic void fillzero(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[j][i]==0&&a[j+1][i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][i]=1;a[j+1][i]=1;\n\t\t\t\t\t\tr=j;c=i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic void fillone(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[i][j]==0&&a[i][j+1]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i][j]=1;a[i][j+1]=1;\n\t\t\t\t\t\tr=i;c=j;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void check(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[i][0]==1&&a[i][1]==1&&a[i][2]==1&&a[i][3]==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][0]=0;a[i][1]=0;a[i][2]=0;a[i][3]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[0][i]==1&&a[1][i]==1&&a[2][i]==1&&a[3][i]==1)\n\t\t\t\t{\n\t\t\t\t\ta[0][i]=0;a[1][i]=0;a[2][i]=0;a[3][i]=0;;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t\t\n\t\t\t\n\t\tScanner in=new Scanner (System.in);\n\t\tHashMap<String,Integer>map=new HashMap<String,Integer>();\n\t\tArrayList<Integer>list=new ArrayList<Integer>();\n\t\nlong n=in.nextLong();\nlong ans=Long.MAX_VALUE;\nlong sum=0;long sum2=(n*(n+1))/2;\nif(sum2%2==0)\nSystem.out.println(0);\nelse\n\tSystem.out.println(1);\n\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t}\n\t\t\n\t\t\n\t}", "index": 42, "complexity": "0"}
{"back-translation": "public class SashaAndHisTrip {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int v = in.nextInt();\n        if (v > N) {\n            System.out.println(N-1);\n        } else {\n            int price = v + (N - v - 1) * (2 + N - v) / 2;\n            int counter = 0;\n            System.out.println(price);\n        }\n    }\n}", "src": "public class SashaAndHisTrip {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int v = in.nextInt();\n        if (v > N) {\n            System.out.println(N-1);\n        }\n        else {\n            int price = v + ((N-v-1) * (2+ N - v))/2;\n            int counter = 0;\n            System.out.println(price);\n        }\n    }\n}", "index": 43, "complexity": "0"}
{"back-translation": "public class Main {\n    public static void main(String args[]) {\n        FastReader fr = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = fr.nextInt(), v = fr.nextInt();\n        if (n <= v)\n            out.println(n - 1);\n        else\n            out.println((n - v) * (n - v + 1) / 2 + v - 1);\n        out.flush();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        int[] memset(int n, int val) {\n            int ar[] = new int[n];\n            Arrays.fill(ar, val);\n            return ar;\n        }\n    }\n}", "src": "public class Main {\n    public static void main(String args[]) {\n        FastReader fr = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = fr.nextInt(), v = fr.nextInt();\n        if (v >= n)\n            out.println(n - 1);\n        else\n            out.println((n - v) * (n - v + 1) / 2 + v - 1);\n        out.flush();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        int[] memset(int n, int val) {\n            int ar[] = new int[n];\n            Arrays.fill(ar, val);\n            return ar;\n        }\n    }\n}", "index": 44, "complexity": "0"}
{"back-translation": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\twhile (sc.hasNextInt()) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n % 2 != 0) {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n % 2 != 0) {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}", "index": 45, "complexity": "0"}
{"back-translation": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\twhile(sc.hasNextInt()) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n % 2 == 0) {\n\t\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n%2==0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 46, "complexity": "0"}
{"back-translation": "public class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint k = input.nextInt();\n\t\tint n = input.nextInt();\n\t\tint s = input.nextInt();\n\t\tint p = input.nextInt();\n\n\t\tint each = n / s + (n % s != 0 ? 1 : 0);\n\t\tint all = each * k;\n\n\t\tSystem.out.println((all % p == 0) ? all / p : all / p + 1);\n\t}\n}", "src": "public class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint k = input.nextInt();\n\t\tint n = input.nextInt();\n\t\tint s = input.nextInt();\n\t\tint p = input.nextInt();\n\n\t\tint each = n / s;\n\t\tif (n % s != 0)\n\t\t{\n\t\t\teach++;\n\t\t}\n\t\tint all = each * k;\n\n\t\tif (all % p == 0)\n\t\t{\n\t\t\tSystem.out.println(all / p);\n\t\t} else\n\t\t{\n\t\t\tSystem.out.println(all / p + 1);\n\t\t}\n\t}\n}", "index": 47, "complexity": "0"}
{"back-translation": "public class A {\n\tstatic int n;\n\tstatic TreeSet<Integer> Primes;\n\tstatic int[] arr;\n\tstatic int[] arr2;\n\n\tpublic static int[] copyOf(int[] arr) {\n\t\tint[] arr2 = new int[arr.length];\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tarr2[i] = arr[i];\n\t\treturn arr2;\n\t}\n\n\tpublic static long addEvens(int[] arr) {\n\t\tlong r = 0;\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tif (arr[i] % 2 == 0)\n\t\t\t\tr += arr[i];\n\t\treturn r;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tarr = new int[14];\n\t\tfor (int i = 0; i < 14; i++) {\n\t\t\tarr[i] = sc.nextInt();\n\t\t}\n\t\tint x = 5535;\n\t\tint y = x;\n\t\tint s;\n\t\tlong max = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < 14; i++) {\n\t\t\tint a = arr[i];\n\t\t\tarr2 = new int[14];\n\t\t\tarr2 = copyOf(arr);\n\t\t\tarr2[i] = 0;\n\t\t\tint j = 0;\n\t\t\tint rem = arr[i] / 14;\n\t\t\tint steps = 0;\n\t\t\tint c = 0;\n\t\t\tfor (j = i + 1; c < 14; j++) {\n\t\t\t\tif (j >= 14)\n\t\t\t\t\tj = 0;\n\t\t\t\tarr2[c] += rem;\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tsteps = arr[i] % 14;\n\t\t\tj = i;\n\t\t\tc = 0;\n\t\t\tfor (j = i + 1; c < steps; j++) {\n\t\t\t\tif (j >= 14)\n\t\t\t\t\tj = 0;\n\t\t\t\tarr2[j] += 1;\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tmax = Math.max(max, addEvens(arr2));\n\t\t}\n\t\tpw.print(max);\n\n\t\tpw.flush();\n\t}\n}", "src": "public class A {\n\t\tstatic int n;\n\t\tstatic TreeSet<Integer> Primes;\n\t\tstatic int[] arr;\n\t\tstatic int[] arr2;\n\t\n\t\tpublic static int[] copyOf(int[] arr) {\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tarr2[i] += arr[i];\n\t\t\treturn arr2;\n\t\t}\n\t\n\t\tpublic static long addEvens(int[] arr) {\n\t\t\tlong r = 0;\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tif (arr[i] % 2 == 0)\n\t\t\t\t\tr += arr[i];\n\t\t\treturn r;\n\t\t}\n\t\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\tarr = new int[14];\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tarr[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint x = 5535;\n\t\t\tint y = x;\n\t\t\tint s;\n\t\t\tlong max = Integer.MIN_VALUE;\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tint a = arr[i];\n\t\t\t\tarr2 = new int[14];\n\t\t\t\tarr2 = copyOf(arr);\n\t\t\t\tarr2[i]=0;\n\t\t\t\tint j =0;\n\t\t\t\tint rem = arr[i] / 14;\n\t\t\t\tint steps = 0;\n\t\t\t\tint c = 0;\n\t\t\t\tfor (  j = i+1;c<14; j++) {\n\t\t\t\t\tif (j >=14 )\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[c] += rem;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tsteps = arr[i] % 14;\n\t\t\t\tj = i;\n\t\t\t\tc=0;\n\t\t\t\tint adasd;\n\t\t\t\tfor ( j = i+1;c<steps; j++) {\n\t\t\t\t\tif (j >= 14)\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[j] += 1;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, addEvens(arr2));\n\t\t\t}\n\t\t\tpw.print(max);\n\t\n\t\t\tpw.flush();\n\t\t}\n\t\n\t\n\t\n\t}", "index": 48, "complexity": "0"}
{"back-translation": "public class helloWorld { public static void main(String[] args) { Scanner in = new Scanner(System.in); long n = in.nextLong(); long ans = n + 1; if (ans == 1) ans = 0; if (ans % 2 == 0) ans /= 2; System.out.println(ans); in.close(); } }", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tlong ans = n+1;\n\t\t\n\t\tif(ans == 1)\n\t\t\tans = 0;\n\t\tif(ans % 2 == 0)\n\t\t\tans /= 2;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 49, "complexity": "0"}
{"back-translation": "public class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int a=Integer.parseInt(s1[0]);\n            int b=Integer.parseInt(s1[1]);\n            int c=Integer.parseInt(s1[2]);\n            int n=Integer.parseInt(s1[3]);\n            int S=a+b-c;\n            if(n-S<1 || c>Math.min(a,b))\n             System.out.println(\"-1\");\n            else\n             System.out.println(n-S);\n      }\n}", "src": "public class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            int a=Integer.parseInt(s1[0]);\n            int b=Integer.parseInt(s1[1]);\n            int c=Integer.parseInt(s1[2]);\n            int n=Integer.parseInt(s1[3]);\n            int S=a+b-c;\n            if(n-S<1 || c>Math.min(a,b))\n             System.out.println(\"-1\");\n            else\n             System.out.println(n-S);\n      }\n}", "index": 50, "complexity": "0"}
{"back-translation": "public class Solution {\n\tpublic void solve() throws Exception {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint a = scanner.nextInt(), b = scanner.nextInt(), c = scanner.nextInt(), n = scanner.nextInt();\n\t\ta -= c;\n\t\tb -= c;\n\t\tif (a < 0 || b < 0) System.out.println(-1);\n\t\telse {\n\t\t\tint x = a + b + c;\n\t\t\tif (x >= n) System.out.println(-1);\n\t\t\telse System.out.println(n - x);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Solution().solve();\n\t}\n}", "src": "public class aaaaaaaaaaaaaaaa {\n\tpublic void run() throws Exception {\n\t\tScanner file = new Scanner(System.in);\n\t\tint a = file.nextInt(), b= file.nextInt(), c = file.nextInt(), n = file.nextInt();\n\t\ta -= c;\n\t\tb -= c;\n\t\tif (a < 0 || b < 0) System.out.println(-1);\n\t\telse {\n\t\t\tint x = a + b + c;\n\t\t\tif (x >= n) System.out.println(-1);\n\t\t\telse System.out.println(n - x);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew aaaaaaaaaaaaaaaa().run();\n\t}\n\n}", "index": 51, "complexity": "0"}
{"back-translation": "public class C {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble n = sc.nextDouble();\n\t\tdouble r = sc.nextDouble();\n\t\tSystem.out.println(r / (1 / Math.sin(Math.PI / n) - 1));\n\t\tsc.close();\n\t}\n}", "src": "public class C {\n\tpublic static void main(String[]args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tdouble n=sc.nextDouble(),r=sc.nextDouble();\n\t\tSystem.out.println(r/(1/Math.sin(Math.PI/n)-1));\n\t\tsc.close();\n\t}\n}", "index": 52, "complexity": "0"}
{"back-translation": "class Main_1100C { private static Scanner sc; private static Printer pr; private static void solve() { int n = sc.nextInt(); int r = sc.nextInt(); double sin = Math.sin(Math.PI / n); double ans = r * sin / (1 - sin); pr.printf(\"%.7f%n\", ans); } public static void main(String[] args) { sc = new Scanner(System.in); pr = new Printer(System.out); solve(); pr.close(); sc.close(); } static class Scanner { BufferedReader br; Scanner(InputStream in) { br = new BufferedReader(new InputStreamReader(in)); } private boolean isPrintable(int ch) { return ch >= '!' && ch <= '~'; } private boolean isCRLF(int ch) { return ch == '\\n' || ch == '\\r' || ch == -1; } private int nextPrintable() { try { int ch; while (!isPrintable(ch = br.read())) { if (ch == -1) { throw new NoSuchElementException(); } } return ch; } catch (IOException e) { throw new NoSuchElementException(); } } String next() { try { int ch = nextPrintable(); StringBuilder sb = new StringBuilder(); do { sb.appendCodePoint(ch); } while (isPrintable(ch = br.read())); return sb.toString(); } catch (IOException e) { throw new NoSuchElementException(); } } int nextInt() { try { boolean negative = false; int res = 0; int limit = -Integer.MAX_VALUE; int radix = 10; int fc = nextPrintable(); if (fc < '0') { if (fc == '-') { negative = true; limit = Integer.MIN_VALUE; } else if (fc != '+') { throw new NumberFormatException(); } fc = br.read(); } int multmin = limit / radix; int ch = fc; do { int digit = ch - '0'; if (digit < 0 || digit >= radix) { throw new NumberFormatException(); } if (res < multmin) { throw new NumberFormatException(); } res *= radix; if (res < limit + digit) { throw new NumberFormatException(); } res -= digit; } while (isPrintable(ch = br.read())); return negative ? res : -res; } catch (IOException e) { throw new NoSuchElementException(); } } long nextLong() { try { boolean negative = false; long res = 0; long limit = -Long.MAX_VALUE; int radix = 10; int fc = nextPrintable(); if (fc < '0') { if (fc == '-') { negative = true; limit = Long.MIN_VALUE; } else if (fc != '+') { throw new NumberFormatException(); } fc = br.read(); } long multmin = limit / radix; int ch = fc; do { int digit = ch - '0'; if (digit < 0 || digit >= radix) { throw new NumberFormatException(); } if (res < multmin) { throw new NumberFormatException(); } res *= radix; if (res < limit + digit) { throw new NumberFormatException(); } res -= digit; } while (isPrintable(ch = br.read())); return negative ? res : -res; } catch (IOException e) { throw new NoSuchElementException(); } } float nextFloat() { return Float.parseFloat(next()); } double nextDouble() { return Double.parseDouble(next()); } String nextLine() { try { int ch; while (isCRLF(ch = br.read())) { if (ch == -1) { throw new NoSuchElementException(); } } StringBuilder sb = new StringBuilder(); do { sb.appendCodePoint(ch); } while (!isCRLF(ch = br.read())); return sb.toString(); } catch (IOException e) { throw new NoSuchElementException(); } } int[] nextIntArray(int n) { int[] ret = new int[n]; for (int i = 0; i < n; i++) { ret[i] = sc.nextInt(); } return ret; } int[][] nextIntArrays(int n, int m) { int[][] ret = new int[m][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { ret[j][i] = sc.nextInt(); } } return ret; } void close() { try { br.close(); } catch (IOException e) { } } } static class Printer extends PrintWriter { Printer(OutputStream out) { super(out); } void printInts(int... a) { StringBuilder sb = new StringBuilder(32); for (int i = 0, size = a.length; i < size; i++) { if (i > 0) { sb.append(' '); } sb.append(a[i]); } println(sb); } void printLongs(long... a) { StringBuilder sb = new StringBuilder(64); for (int i = 0, size = a.length; i < size; i++) { if (i > 0) { sb.append(' '); } sb.append(a[i]); } println(sb); } void printStrings(String... a) { StringBuilder sb = new StringBuilder(32); for (int i = 0, size = a.length; i < size; i++) { if (i > 0) { sb.append(' '); } sb.append(a[i]); } println(sb); } } }", "src": "public class Main_1100C {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\n\t\tdouble sin = Math.sin(Math.PI / n);\n\t\tdouble ans = r * sin / (1 - sin);\n\t\t\n\t\tpr.printf(\"%.7f%n\", ans);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\t\t\t\n\t\tsolve();\n\t\t\t\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tint[][] nextIntArrays(int n, int m) {\n\t\t\tint[][] ret = new int[m][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tret[j][i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t\t\n\t\tvoid printInts(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printLongs(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder(64);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printStrings(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t}\n}", "index": 53, "complexity": "0"}
{"back-translation": "public class IntegerSequenceDividing {\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n%2==0)\n\t\t{\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}else\n\t\t{\n\t\t\tn++;\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "src": "public class IntegerSequenceDividing {\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n%2==0)\n\t\t{\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}else\n\t\t{\n\t\t\tn++;\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "index": 54, "complexity": "0"}
{"back-translation": "class Codechef { static PrintWriter out = new PrintWriter(System.out); static FastScanner in = new FastScanner(System.in); static class FastScanner { BufferedReader br; StringTokenizer stok; FastScanner(InputStream is) { br = new BufferedReader(new InputStreamReader(is)); } String next() throws IOException { while (stok == null || !stok.hasMoreTokens()) { String s = br.readLine(); if (s == null) return null; stok = new StringTokenizer(s); } return stok.nextToken(); } int ni() throws IOException { return Integer.parseInt(next()); } long nl() throws IOException { return Long.parseLong(next()); } double nd() throws IOException { return Double.parseDouble(next()); } char nc() throws IOException { return (char) (br.read()); } String ns() throws IOException { return br.readLine(); } int[] nia(int n) throws IOException { int a[] = new int[n]; for (int i = 0; i < n; i++) a[i] = ni(); return a; } long[] nla(int n) throws IOException { long a[] = new long[n]; for (int i = 0; i < n; i++) a[i] = nl(); return a; } double[] nda(int n) throws IOException { double a[] = new double[n]; for (int i = 0; i < n; i++) a[i] = nd(); return a; } int[][] imat(int n, int m) throws IOException { int mat[][] = new int[n][m]; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) mat[i][j] = ni(); } return mat; } } static long mod = Long.MAX_VALUE; public static void main(String[] args) throws java.lang.Exception { int i, j; HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>(); ArrayList<Integer> arr = new ArrayList<Integer>(); HashSet<Integer> set = new HashSet<Integer>(); PriorityQueue<Integer> pq = new PriorityQueue<Integer>(); long n = in.nl(); long v = in.nl(); long temp = n - 1; long ans = 0; ans += Math.min(v, temp); temp -= v; if (temp > 0) ans += ((temp + 1) * (temp + 2)) / (long) 2 - 1; out.println(ans); out.close(); } static long gcd(long a, long b) { if (b == 0) return a; return gcd(b, a % b); } static long exponent(long a, long n) { long ans = 1; while (n != 0) { if (n % 2 == 1) ans = (ans * a) % mod; a = (a * a) % mod; n = n >> 1; } return ans; } static int binarySearch(int a[], int item, int low, int high) { if (high <= low) return (item > a[low]) ? (low + 1) : low; int mid = (low + high) / 2; if (item == a[mid]) return mid + 1; if (item > a[mid]) return binarySearch(a, item, mid + 1, high); return binarySearch(a, item, low, mid - 1); } static void merge(int arr[], int l, int m, int r) { int n1 = m - l + 1; int n2 = r - m; int L[] = new int[n1]; int R[] = new int[n2]; for (int i = 0; i < n1; ++i) L[i] = arr[l + i]; for (int j = 0; j < n2; ++j) R[j] = arr[m + 1 + j]; int i = 0, j = 0; int k = l; while (i < n1 && j < n2) { if (L[i] <= R[j]) { arr[k] = L[i]; i++; } else { arr[k] = R[j]; j++; } k++; } while (i < n1) { arr[k] = L[i]; i++; k++; } while (j < n2) { arr[k] = R[j]; j++; k++; } } static void Sort(int arr[], int l, int r) { if (l < r) { int m = (l + r) / 2; Sort(arr, l, m); Sort(arr, m + 1, r); merge(arr, l, m, r); } } static void sort(int a[]) { Sort(a, 0, a.length - 1); } }", "src": "public class Codechef\n{   static PrintWriter out=new PrintWriter(System.out);\n\tstatic FastScanner in = new FastScanner(System.in);\n     static class FastScanner {BufferedReader br;StringTokenizer stok;FastScanner(InputStream is) {br = new BufferedReader(new InputStreamReader(is));}\n        String next() throws IOException {while (stok == null || !stok.hasMoreTokens()) {String s = br.readLine();if (s == null) {return null;}\n                stok = new StringTokenizer(s);}return stok.nextToken();}\n        int ni() throws IOException {    return Integer.parseInt(next());}\n        long nl() throws IOException {return Long.parseLong(next());}\n        double nd() throws IOException {return Double.parseDouble(next());}\n        char nc() throws IOException {return (char) (br.read());}\n        String ns() throws IOException {return br.readLine();}\n        int[] nia(int n) throws IOException{int a[] = new int[n];for (int i = 0; i < n; i++)a[i] = ni();return a;}\n        long[] nla(int n) throws IOException {\n            long a[] = new long[n];for (int i = 0; i < n; i++)a[i] = nl();return a;}\n        double[] nda(int n)throws IOException {double a[] = new double[n];for (int i = 0; i < n; i++)        a[i] = nd();    return a;}\n        int [][] imat(int n,int m) throws IOException\n        {   int mat[][]=new int[n][m];for(int i=0;i<n;i++){   for(int j=0;j<m;j++)mat[i][j]=ni();}return mat;}\n    }\n        \n    \n    \n    \n    \n    \n\tstatic long mod=Long.MAX_VALUE;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{   int i,j;\n\t    HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();\n\t\t       \n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        HashSet<Integer> set=new HashSet<Integer>();\n        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\n        \n        long n=in.nl();\n        long v=in.nl();\n        long temp=n-1;\n        long ans=0;\n          \n        ans+=Math.min(v,temp);\n        temp-=v;\n\t    \n\t    if(temp>0)\n            ans+=((temp+1)*(temp+2))/(long)2-1;\n        \n        \n        out.println(ans);\n        out.close();\n\t}\n\t\n\t\n\t\n\t\n\t\n\tstatic long gcd(long a,long b)\n\t{   if(b==0)\n\t        return a;\n\t    return gcd(b,a%b);    \n\t}\n\tstatic long exponent(long a,long n)\n\t{   long ans=1;\n\t    while(n!=0)\n\t    {   if(n%2==1)\n\t            ans=(ans*a)%mod;\n\t       a=(a*a)%mod;\n\t       n=n>>1;\n\t    }\n\t    return ans;\n\t}\n\tstatic int binarySearch(int a[], int item, int low, int high) \n    {   if (high <= low) \n            return (item > a[low])?  (low + 1): low; \n        int mid = (low + high)/2; \n        if(item == a[mid]) \n            return mid+1; \n        if(item > a[mid]) \n            return binarySearch(a, item, mid+1, high); \n        return binarySearch(a, item, low, mid-1); \n    } \n   static void merge(int arr[], int l, int m, int r) \n    {   int n1 = m - l + 1; int n2 = r - m; int L[] = new int [n1]; int R[] = new int [n2]; \n        \n        for (int i=0; i<n1; ++i) L[i] = arr[l + i]; for (int j=0; j<n2; ++j) R[j] = arr[m + 1+ j]; int i = 0, j = 0; int k = l; \n        while (i < n1 && j < n2) {   if (L[i] <= R[j]) {   arr[k] = L[i]; i++; } else{   arr[k] = R[j]; j++; } k++; } while (i < n1){   arr[k] = L[i]; i++; k++; } while (j < n2) { arr[k] = R[j];   j++;     k++; } \n    } \n    static void Sort(int arr[], int l, int r) \n    {    if (l < r) {   int m = (l+r)/2; Sort(arr, l, m); Sort(arr , m+1, r); merge(arr, l, m, r); } } \n    \n    static void sort(int a[])\n    {Sort(a,0,a.length-1);}\n\n}", "index": 55, "complexity": "0"}
{"back-translation": "public class SashaAndHisTrip {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintStream out = System.out;\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint v = nextInt();\n\t\t\n\t\tif (v >= n-1)\n\t\t\tout.println(n-1);\n\t\telse\n\t\t\tout.println((n-v)*(n-v+1)/2+v-1);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "src": "public class SashaAndHisTrip {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint v = nextInt();\n\t\t\n\t\tif (v >= n-1)\n\t\t\tSystem.out.println(n-1);\n\t\telse\n\t\t\tSystem.out.println((n-v)*(n-v+1)/2+v-1);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 56, "complexity": "0"}
{"back-translation": "public class DLL { Node head; static class Node { int data; Node prev; Node next; Node( int d) { data = d; } } public void push( int new_data) { Node new_Node = new Node(new_data); new_Node.next = head; new_Node.prev = null ; if (head != null) head.prev = new_Node; head = new_Node; } public void printlist(Node node) { Node last = null ; while (node != null) { System.out.print(node.data + \" \"); last = node; node = node.next; } System.out.println(); } void deleteNode(Node head_ref, Node del) { if (head == null || del == null) { return; } if (head == del) { head = del.next; } if (del.next != null) { del.next.prev = del.prev; } if (del.prev != null) { del.prev.next = del.next; } return; } public static void main(String[] args) { DLL dll = new DLL(); dll.push( 2 ); dll.push( 4 ); dll.push( 8 ); dll.push( 10 ); System.out.print( \"Created DLL is: \"); dll.printlist(dll.head); dll.deleteNode(dll.head, dll.head); System.out.print( \"\\nList after deleting first node: \"); dll.printlist(dll.head); dll.deleteNode(dll.head, dll.head.next); System.out.print( \"\\nList after Deleting middle node: \"); dll.printlist(dll.head); } }", "src": "public\nclass\nDLL { \n\nNode head; \n\n\n\n\n\nclass\nNode { \n\nint\ndata; \n\nNode prev; \n\nNode next; \n\n\n\n\n\n\n\n\nNode(\nint\nd) { data = d; } \n\n} \n\n\n\n\npublic\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\n\n\nNode new_Node = \nnew\nNode(new_data); \n\n\n\n\n\n\nnew_Node.next = head; \n\nnew_Node.prev = \nnull\n; \n\n\n\n\nif\n(head != \nnull\n) \n\nhead.prev = new_Node; \n\n\n\n\nhead = new_Node; \n\n} \n\n\n\n\n\n\npublic\nvoid\nprintlist(Node node) \n\n{ \n\nNode last = \nnull\n; \n\n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nlast = node; \n\nnode = node.next; \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nvoid\ndeleteNode(Node head_ref, Node del) \n\n{ \n\n\n\n\nif\n(head == \nnull\n|| del == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\n\nif\n(head == del) { \n\nhead = del.next; \n\n} \n\n\n\n\n\n\nif\n(del.next != \nnull\n) { \n\ndel.next.prev = del.prev; \n\n} \n\n\n\n\n\n\nif\n(del.prev != \nnull\n) { \n\ndel.prev.next = del.next; \n\n} \n\n\n\n\nreturn\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nDLL dll = \nnew\nDLL(); \n\n\n\n\ndll.push(\n2\n); \n\n\n\n\ndll.push(\n4\n); \n\n\n\n\ndll.push(\n8\n); \n\n\n\n\ndll.push(\n10\n); \n\n\nSystem.out.print(\n\"Created DLL is: \"\n); \n\ndll.printlist(dll.head); \n\n\n\n\ndll.deleteNode(dll.head, dll.head); \n\n\n\n\n\n\nSystem.out.print(\n\"\\nList after deleting first node: \"\n); \n\ndll.printlist(dll.head); \n\n\n\n\ndll.deleteNode(dll.head, dll.head.next); \n\n\nSystem.out.print(\n\"\\nList after Deleting middle node: \"\n); \n\ndll.printlist(dll.head); \n\n} \n}", "index": 57, "complexity": "0"}
{"back-translation": "class GfG { static class StackWithMax { static Stack<Integer> mainStack = new Stack<Integer>(); static Stack<Integer> trackStack = new Stack<Integer>(); static void push(int x) { mainStack.push(x); if (mainStack.size() == 1) { trackStack.push(x); return; } if (x > trackStack.peek()) trackStack.push(x); else trackStack.push(trackStack.peek()); } static int getMax() { return trackStack.peek(); } static void pop() { mainStack.pop(); trackStack.pop(); } } public static void main(String[] args) { StackWithMax s = new StackWithMax(); s.push(20); System.out.println(s.getMax()); s.push(10); System.out.println(s.getMax()); s.push(50); System.out.println(s.getMax()); } }", "src": "class\nGfG { \n\nstatic\nclass\nStackWithMax \n{ \n\n\n\nstatic\nStack<Integer> mainStack = \nnew\nStack<Integer> (); \n\n\n\n\nstatic\nStack<Integer> trackStack = \nnew\nStack<Integer> (); \n\nstatic\nvoid\npush(\nint\nx) \n\n{ \n\nmainStack.push(x); \n\nif\n(mainStack.size() == \n1\n) \n\n{ \n\ntrackStack.push(x); \n\nreturn\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\nif\n(x > trackStack.peek()) \n\ntrackStack.push(x); \n\nelse\n\ntrackStack.push(trackStack.peek()); \n\n} \n\n\nstatic\nint\ngetMax() \n\n{ \n\nreturn\ntrackStack.peek(); \n\n} \n\n\nstatic\nvoid\npop() \n\n{ \n\nmainStack.pop(); \n\ntrackStack.pop(); \n\n} \n}; \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nStackWithMax s = \nnew\nStackWithMax(); \n\ns.push(\n20\n); \n\nSystem.out.println(s.getMax()); \n\ns.push(\n10\n); \n\nSystem.out.println(s.getMax()); \n\ns.push(\n50\n); \n\nSystem.out.println(s.getMax()); \n} \n}", "index": 58, "complexity": "0"}
{"back-translation": "class GFG { static int count(int n) { if (n < 4) return -1; int rem = n % 4; if (rem == 0) return n / 4; if (rem == 1) { if (n < 9) return -1; return (n - 9) / 4 + 1; } if (rem == 2) return (n - 6) / 4 + 1; if (rem == 3) { if (n < 15) return -1; return (n - 15) / 4 + 2; } return 0; } public static void main(String[] args) { int n = 90; System.out.println(count(n)); n = 143; System.out.println(count(n)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\ncount(\nint\nn) \n\n{ \n\n\n\nif\n(n < \n4\n) \n\nreturn\n-\n1\n; \n\n\n\n\n\n\nint\nrem = n % \n4\n; \n\n\n\n\n\n\nif\n(rem == \n0\n) \n\nreturn\nn / \n4\n; \n\n\n\n\nif\n(rem == \n1\n) { \n\n\n\n\n\n\n\n\n\n\nif\n(n < \n9\n) \n\nreturn\n-\n1\n; \n\n\n\n\n\n\n\n\n\n\nreturn\n(n - \n9\n) / \n4\n+ \n1\n; \n\n} \n\n\n\n\n\n\n\n\n\nif\n(rem == \n2\n) \n\nreturn\n(n - \n6\n) / \n4\n+ \n1\n; \n\n\n\n\n\n\n\nif\n(rem == \n3\n) \n\n{ \n\nif\n(n < \n15\n) \n\nreturn\n-\n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\nreturn\n(n - \n15\n) / \n4\n+ \n2\n; \n\n} \n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n90\n; \n\nSystem.out.println(count(n)); \n\n\nn = \n143\n; \n\nSystem.out.println(count(n)); \n\n} \n}", "index": 59, "complexity": "0"}
{"back-translation": "public class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        long n = sc.nextLong();\n        long s = sc.nextLong();\n\n        long ans = (s - 1) / n + 1;\n        System.out.println(ans);\n    }\n}", "src": "public class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        long n = sc.nextLong();\n        long s = sc.nextLong();\n\n        long ans = (s - 1) / n + 1;\n        System.out.print(ans);\n    }\n}", "index": 60, "complexity": "0"}
{"back-translation": "public class OrangeJuice{\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint s=in.nextInt();\n\t\tif(n>=1&&n<=100000&&s>=1&&s<=1000000000){\n\t\t\tif(s%n==0){\n\t\t\t\tSystem.out.println(s/n);\n\t\t\t}else{\n\t\t\t\tint o=s%n;\n\t\t\t\tSystem.out.println((s-o)/n+1);\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class OrangeJuice{\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint s=in.nextInt();\n\t\tif(n>=1&&n<=100000&&s>=1&&s<=1000000000){\n\t\t\tif(s%n==0){\n\t\t\t\tSystem.out.println(s/n);\n\t\t\t}else{\n\t\t\t\tint o=s%n;\n\t\t\t\tSystem.out.println((s-o)/n+1);\n\t\t\t}\n\t\t}\n\t}\n}", "index": 61, "complexity": "0"}
{"back-translation": "public class Result {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), s = sc.nextInt();\n        int coins;\n        coins = (s % n != 0) ? (s / n + 1) : (s / n);\n        System.out.println(coins);\n\n    }\n}", "src": "public class Solution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), s = sc.nextInt();\n        int coins;\n        if(s%n != 0)\n            coins = s/n + 1;\n        else\n            coins = s/n;\n\n        System.out.println(coins);\n\n    }\n}", "index": 62, "complexity": "0"}
{"back-translation": "public class Param {\n    public static void main(String[] args) {\n        MyScanner param = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        long l2 = param.nextLong();\n        long dice1 = param.nextLong();\n        long dice2 = param.nextLong();\n\n        long l1 = 1;\n        long r1 = 1;\n        long r2 = l2;\n        long count = 0;\n        long check = 0;\n        count = l2 - dice1;\n        count = count + (r2 - dice2);\n        check = dice1 - l1;\n        check = check + (dice2 - r1);\n        if (check <= count) {\n            System.out.println(\"White\");\n        } else {\n            System.out.println(\"Black\");\n        }\n        out.close();\n    }\n\n    public static PrintWriter out;\n\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n       long l2 =param.nextLong();\n       long dice1=param.nextLong();\n       long dice2=param.nextLong();\n      \n       long l1=1;\n       long r1=1;\n       long r2=l2;\n       long count=0;\n       long check=0;\n       count=l2-dice1;\n       count=count+(r2-dice2);\n       check=dice1-l1;\n       check=check+(dice2-r1);\n       if(check<=count){\n          System.out.println(\"White\");\n       }\n       else{\n          System.out.println(\"Black\");\n       }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 63, "complexity": "0"}
{"back-translation": "public class Dont {\n    static BufferedReader jin = new BufferedReader(new InputStreamReader(System.in));\n    static long n;\n    static long x, y;\n\n    public static void main(String[] args) throws Exception {\n        n = getNextLong();\n        x = getNextLong();\n        y = getNextLong();\n        System.out.println((maximum(n - x, n - y) < maximum(x - 1, y - 1)) ? \"Black\" : \"White\");\n    }\n\n    static long maximum(long a, long b) {\n        return (a > b) ? a : b;\n    }\n\n    static long getNextLong() throws Exception {\n        long res = 0;\n        int ch = jin.read();\n        while (ch < '0' || '9' < ch) ch = jin.read();\n        while ('0' <= ch && ch <= '9') {\n            res = res * 10 + ch - '0';\n            ch = jin.read();\n        }\n        return res;\n    }\n}", "src": "public class Dont {\n    static BufferedReader jin = new BufferedReader( new InputStreamReader( System.in ) );\n    static long n;\n    static long x, y;\n\n    public static void main(String[] args) throws Exception {\n        n = nextLong();\n        x = nextLong();\n        y = nextLong();\n        System.out.println( (max(n-x, n-y) < max(x-1, y-1))? \"Black\" : \"White\" );\n    }\n\n    static long max(long a, long b) {\n        return (a > b)? a : b ;\n    }\n\n    static long nextLong() throws Exception {\n        long res = 0;\n        int ch = jin.read();\n        while(ch < '0' || '9' < ch) ch = jin.read();\n        while('0'<= ch && ch <= '9') {\n            res = res*10 + ch - '0';\n            ch = jin.read();\n        }\n        return res;\n    }\n}", "index": 64, "complexity": "0"}
{"back-translation": "class GFG { public static int N = 1000; static int prefixans[] = new int[1000]; public static void countIndex(int a[], int n) { for (int i = 0; i < n; i++) { if (i + 1 < n && a[i] == a[i + 1]) prefixans[i] = 1; if (i != 0) prefixans[i] += prefixans[i - 1]; } } public static int answer_query(int l, int r) { if (l == 0) return prefixans[r - 1]; else return prefixans[r - 1] - prefixans[l - 1]; } public static void main(String args[]) { int a[] = {1, 2, 2, 2, 3, 3, 4, 4, 4}; int n = 9; countIndex(a, n); int L, R; L = 1; R = 8; System.out.println(answer_query(L, R)); L = 0; R = 4; System.out.println(answer_query(L, R)); } }", "src": "class\nGFG { \n\npublic\nstatic\nint\nN = \n1000\n; \n\n\n\n\nstatic\nint\nprefixans[] = \nnew\nint\n[\n1000\n]; \n\n\npublic\nstatic\nvoid\ncountIndex(\nint\na[], \nint\nn) \n{ \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(i + \n1\n< n && a[i] == a[i + \n1\n]) \n\nprefixans[i] = \n1\n; \n\n\nif\n(i != \n0\n) \n\nprefixans[i] += prefixans[i - \n1\n]; \n\n} \n} \n\n\n\npublic\nstatic\nint\nanswer_query(\nint\nl, \nint\nr) \n{ \n\nif\n(l == \n0\n) \n\nreturn\nprefixans[r - \n1\n]; \n\nelse\n\nreturn\nprefixans[r - \n1\n] - \n\nprefixans[l - \n1\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = \n9\n; \n\n\n\n\ncountIndex(a, n); \n\n\nint\nL, R; \n\n\n\n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println(answer_query(L, R)); \n\n\n\n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println(answer_query(L, R)); \n} \n}", "index": 65, "complexity": "0"}
{"back-translation": "public class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int hp = scanner.nextInt();\n        switch (hp % 4) {\n            case 1:\n                System.out.println(\"0 A\");\n                break;\n            case 2:\n                System.out.println(\"1 B\");\n                break;\n            case 3:\n                System.out.println(\"2 A\");\n                break;\n            default:\n                System.out.println(\"1 A\");\n        }\n    }\n}", "src": "public class Main {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n         int hp = scanner.nextInt();\n        if (hp%4 == 1){\n            System.out.println(\"0 A\");\n        }\n        else if (hp%4 == 2){\n            System.out.println(\"1 B\");\n        }\n        else if (hp%4 == 3){\n            System.out.println(\"2 A\");\n        }\n        else {\n            System.out.println(\"1 A\");\n        }\n\n    }\n    }", "index": 66, "complexity": "0"}
{"back-translation": "public class newMain {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        int x = enter.nextInt();\n        if (x % 4 == 0) {\n            System.out.println(1 + \" A\");\n        } else if (x % 4 == 1) {\n            System.out.println(0 + \" A\");\n        } else if (x % 4 == 2) {\n            System.out.println(1 + \" B\");\n        } else if (x % 4 == 3) {\n            System.out.println(2 + \" A\");\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}", "src": "public class mainA {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        int x=enter.nextInt();\n        if(x%4==0){\n            System.out.println(1 +\" A\");\n        }\n        else if(x%4==1){\n            System.out.println(0+\" A\");\n        }\n        else if(x%4==2){\n            System.out.println(1+\" B\");\n        }\n        else if(x%4==3){\n            System.out.println(2+\" A\");\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}", "index": 67, "complexity": "0"}
{"back-translation": "public class TokitsukazeAndEnhancement {\n\n    static char check(int n) {\n        if (n % 4 == 0)\n            return 'D';\n        if (n % 4 == 1)\n            return 'A';\n        if (n % 4 == 2)\n            return 'C';\n        return 'B';\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        StringTokenizer st;\n        int n = Integer.parseInt(br.readLine());\n        int a = n + 1;\n        int b = n + 2;\n        char n1 = check(n);\n        char a1 = check(a);\n        char b1 = check(b);\n        char sol = (char) Math.min(Math.min(a1, b1), n1);\n        if (sol == n1)\n            pw.println(0 + \" \" + sol);\n        else if (sol == a1)\n            pw.println(1 + \" \" + sol);\n        else if (sol == b1)\n            pw.println(2 + \" \" + sol);\n        pw.close();\n    }\n}", "src": "public class TokitsukazeAndEnhancement {\n\t\n\tstatic char check(int n) {\n\t\tif(n%4 == 0)\n\t\t\treturn 'D';\n\t\tif(n%4 == 1)\n\t\t\treturn 'A';\n\t\tif(n%4 == 2)\n\t\t\treturn 'C';\n\t\treturn 'B';\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tStringTokenizer st;\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint a = n + 1;\n\t\tint b = n + 2;\n\t\tchar n1 = check(n);\n\t\tchar a1 = check(a);\n\t\tchar b1 = check(b);\n\t\tchar sol = (char) Math.min(Math.min(a1, b1),n1);\n\t\tif(sol == n1)\n\t\t\tpw.println(0 + \" \" + sol);\n\t\telse if(sol == a1)\n\t\t\tpw.println(1 + \" \" + sol);\n\t\telse if(sol == b1)\n\t\t\tpw.println(2 + \" \" + sol);\n\t\tpw.close();\n\t}\n}", "index": 68, "complexity": "0"}
{"back-translation": "public class Solution {\n    static class Tile implements Comparable<Tile> {\n        int number;\n        int suit;\n\n        public int compareTo(Tile b) {\n\n            return number - b.number;\n        }\n\n    }\n    public static void main(String[] args) {\n\n\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] parts = line.split(\" \");\n\n        Tile[] tiles = new Tile[3];\n        for (int i = 0; i < 3; i++) {\n\n            tiles[i] = new Tile();\n            tiles[i].number = parts[i].charAt(0) - '0';\n            if (parts[i].substring(1, 2).equals(\"s\")) tiles[i].suit = 1;\n            if (parts[i].substring(1, 2).equals(\"m\")) tiles[i].suit = 2;\n            if (parts[i].substring(1, 2).equals(\"p\")) tiles[i].suit = 3;\n\n        }\n        Arrays.sort(tiles);\n\n        int[][] tilesObtained = new int[10][4];\n        int[][] stairCases = new int[10][4];\n        int[][] stairCases2 = new int[10][4];\n        for (int i = 0; i < 3; i++) {\n            int currNumber = tiles[i].number;\n            int currSuit = tiles[i].suit;\n\n            tilesObtained[currNumber][currSuit]++;\n            stairCases[currNumber][currSuit] = 1 + stairCases[currNumber - 1][currSuit];\n            if (currNumber != 1) {\n                if (stairCases2[currNumber - 2][currSuit] != 0) {\n                    stairCases2[currNumber][currSuit] = 2;\n                } else {\n                    stairCases2[currNumber][currSuit] = 1;\n                }\n            } else {\n                stairCases2[currNumber][currSuit]++;\n            }\n\n\n        }\n        int best = 3;\n\n        for (int i = 1; i <= 9; i++) {\n\n            for (int j = 1; j <= 3; j++) {\n\n                best = Math.min(best, 3 - tilesObtained[i][j]);\n                best = Math.min(best, 3 - stairCases[i][j]);\n                best = Math.min(best, 3 - stairCases2[i][j]);\n                if (best < 0) best = 0;\n            }\n        }\n        System.out.println(best);\n\n\n    }\n}", "src": "public class problem2 {\n    static class tile implements Comparable<tile> {\n        int number;\n        int suit;\n\n        public int compareTo(tile b){\n\n            return number - b.number;\n        }\n\n    }\n    public static void main(String[] args) {\n\n\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] parts = line.split(\" \");\n\n        tile[] tiles = new tile[3];\n        for(int i = 0; i < 3; i++){\n\n            tiles[i] = new tile();\n            tiles[i].number = parts[i].charAt(0) - '0';\n            if(parts[i].substring(1,2).equals(\"s\"))tiles[i].suit = 1;\n            if(parts[i].substring(1,2).equals(\"m\"))tiles[i].suit = 2;\n            if(parts[i].substring(1,2).equals(\"p\"))tiles[i].suit = 3;\n            \n        }\n        Arrays.sort(tiles);\n\n        int[][] tilesObtained = new int[10][4];\n        int[][] stairCases = new int[10][4];\n        int[][] stairCases2 = new int[10][4];\n        for(int i = 0; i < 3; i++){\n            int currNumber = tiles[i].number;\n            int currSuit = tiles[i].suit;\n\n            tilesObtained[currNumber][currSuit]++;\n            stairCases[currNumber][currSuit] = 1 + stairCases[currNumber-1][currSuit];\n            if(currNumber != 1){\n                if(stairCases2[currNumber-2][currSuit] != 0){\n                    stairCases2[currNumber][currSuit] = 2;\n                }\n                else{\n                    stairCases2[currNumber][currSuit] = 1;\n                }\n            }\n            else{\n                stairCases2[currNumber][currSuit]++;\n            }\n\n\n        }\n        int best = 3;\n\n        for(int i = 1; i <= 9; i++){\n\n            for(int j = 1; j <= 3; j++){\n\n                best = Math.min(best, 3 - tilesObtained[i][j]);\n                best = Math.min(best, 3 - stairCases[i][j]);\n                best = Math.min(best, 3- stairCases2[i][j]);\n                if(best <0)best = 0;\n            }\n        }\n        System.out.println(best);\n\n\n    }\n}", "index": 69, "complexity": "0"}
{"back-translation": "ERROR", "src": "public class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static char returnLetter(int n)\n\t{\n\t\tif(n%4==1)\n\t\t{\n\t\t\treturn 'A';\n\t\t}\n\t\telse if(n%4==3)\n\t\t{\n\t\t\treturn 'B';\n\t\t}\n\t\telse if(n%4==2)\n\t\t{\n\t\t\treturn 'C';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'D';\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tString[] a= new String[3];\n\t\t\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i]=sc.next();\n\t\t}\n\t\tboolean equal=true;\n\t\t\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)!=a[i-1].charAt(0))\n\t\t\t{\n\t\t\t\tequal=false;break;\n\t\t\t}\n\t\t}\n\t\tif(equal)\n\t\t{\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tArrays.sort(a);\n\t\t\tboolean ord=true;\n\t\t\t\n\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)-a[i-1].charAt(0)!=1)\n\t\t\t\t{\n\t\t\t\t\tord=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord)\n\t\t\t{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)==a[0].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[1].charAt(0)==a[2].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tint start = 0;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t}\n}", "index": 70, "complexity": "0"}
{"back-translation": "static class Main { static void main(String[] args) { InputStream inputStream = System.in; OutputStream outputStream = System.out; InputReader in = new InputReader(inputStream); OutputWriter out = new OutputWriter(outputStream); KingEscape solver = new KingEscape(); solver.solve(1, in, out); out.close(); } static class KingEscape { void solve(int testNumber, InputReader in, OutputWriter out) { int n = in.nextInt(); int qx = in.nextInt(); int qy = in.nextInt(); int kx = in.nextInt(); int ky = in.nextInt(); int safex = in.nextInt(); int safey = in.nextInt(); boolean possible = false; if (qx > Math.max(kx, safex) || qx < Math.min(kx, safex)) { if (qy > Math.max(ky, safey) || qy < Math.min(ky, safey)) { possible = true; } } if (possible) out.println(\"YES\"); else out.println(\"NO\"); } } static class OutputWriter { private final PrintWriter writer; OutputWriter(OutputStream outputStream) { writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream))); } OutputWriter(Writer writer) { this.writer = new PrintWriter(writer); } void print(Object... objects) { for (int i = 0; i < objects.length; i++) { if (i != 0) { writer.print(' '); } writer.print(objects[i]); } } void println(Object... objects) { print(objects); writer.println(); } void close() { writer.close(); } } static class InputReader { private InputStream stream; private byte[] buf = new byte[1024]; private int curChar; private int numChars; private InputReader.SpaceCharFilter filter; InputReader(InputStream stream) { this.stream = stream; } int read() { if (numChars == -1) { throw new InputMismatchException(); } if (curChar >= numChars) { curChar = 0; try { numChars = stream.read(buf); } catch (IOException e) { throw new InputMismatchException(); } if (numChars <= 0) { return -1; } } return buf[curChar++]; } int nextInt() { int c = read(); while (isSpaceChar(c)) { c = read(); } int sgn = 1; if (c == '-') { sgn = -1; c = read(); } int res = 0; do { if (c < '0' || c > '9') { throw new InputMismatchException(); } res *= 10; res += c - '0'; c = read(); } while (!isSpaceChar(c)); return res * sgn; } boolean isSpaceChar(int c) { if (filter != null) { return filter.isSpaceChar(c); } return isWhitespace(c); } static boolean isWhitespace(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } } }", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        KingEscape solver = new KingEscape();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class KingEscape {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int qx = in.nextInt();\n            int qy = in.nextInt();\n            int kx = in.nextInt();\n            int ky = in.nextInt();\n            int safex = in.nextInt();\n            int safey = in.nextInt();\n            boolean possible = false;\n            if (qx > Math.max(kx, safex) || qx < Math.min(kx, safex)) {\n                if (qy > Math.max(ky, safey) || qy < Math.min(ky, safey)) {\n                    possible = true;\n                }\n            }\n            if (possible) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 71, "complexity": "0"}
{"back-translation": "public class helloWorld {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tlong m = in.nextLong();\n\t\tlong ans = m / n + (m % n > 0 ? 1 : 0);\n\t\tSystem.out.println(ans);\n\t\tin.close();\n\t}\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\tlong m = in.nextLong();\n\t\t\n\t\tlong ans = m / n;\n\t\t\n\t\tif(m % n > 0)\n\t\t\tans++;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 72, "complexity": "0"}
{"back-translation": "public class Solution {\n    public static void main(String[] args) throws IOException {\n        setup();\n        int x = readInt();\n        int y = readInt();\n        int z = readInt();\n        int t1 = readInt();\n        int t2 = readInt();\n        int t3 = readInt();\n        int lift = Math.abs(z - x) * t2 + 2 * t3 + Math.abs(x - y) * t2 + t3;\n        int stair = Math.abs(x - y) * t1;\n        if (lift <= stair) {\n            printOutput(\"YES\");\n        } else {\n            printOutput(\"NO\");\n        }\n        closeOutput();\n    }\n\n    static StringTokenizer st;\n    static BufferedReader sc;\n    static PrintWriter pw;\n\n    static String read() throws IOException {\n        while (st == null || !st.hasMoreElements()) {\n            st = new StringTokenizer(sc.readLine());\n        }\n        return st.nextToken();\n    }\n\n    static int readInt() throws IOException {\n        return Integer.parseInt(read());\n    }\n\n    static long readLong() throws IOException {\n        return Long.parseLong(read());\n    }\n\n    static void setup(String in, String out) throws IOException {\n        sc = new BufferedReader(new FileReader(in));\n        pw = new PrintWriter(out);\n    }\n\n    static void setup() {\n        sc = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n    }\n}\n\nclass DSU {\n    int parent[];\n    public DSU(int n){\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int i){\n        if (i == parent[i]){\n            return i;\n        }\n        int p = find(parent[i]);\n        parent[i] = p;\n        return p;\n    }\n\n    boolean merge(int a, int b){\n        a = find(a);\n        b = find(b);\n        if (a == b) return false;\n        parent[a] = b;\n        return true;\n    }\n}", "src": "public class main {\n    public static void main(String[] args) throws IOException {\n        init();\n        int x = nextInt();\n        int y = nextInt();\n        int z = nextInt();\n        int t1 = nextInt();\n        int t2 = nextInt();\n        int t3 = nextInt();\n        int lift = Math.abs(z - x) * t2 + 2 * t3 + Math.abs(x - y) * t2 + t3;\n        int stair = Math.abs(x - y) * t1;\n        if (lift <= stair) {\n            pw.print(\"YES\");\n        } else {\n            pw.print(\"NO\");\n        }\n        pw.close();\n    }\n\n    static StringTokenizer st;\n    static BufferedReader sc;\n    static PrintWriter pw;\n\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreElements()) {\n            st = new StringTokenizer(sc.readLine());\n        }\n        return st.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static void init(String in, String out) throws IOException {\n        sc = new BufferedReader(new FileReader(in));\n        pw = new PrintWriter(out);\n    }\n\n    static void init() {\n        sc = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n    }\n}\n\nclass DSU {\n    int parent[];\n    public DSU(int n){\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int get(int i){\n        if (i == parent[i]){\n            return i;\n        }\n        int p = get(parent[i]);\n        parent[i] = p;\n        return p;\n    }\n\n    boolean union(int a, int b){\n        a = get(a);\n        b = get(b);\n        if (a == b) return false;\n        parent[a] = b;\n        return true;\n    }\n}", "index": 73, "complexity": "0"}
{"back-translation": "public class Main { \n    public static void main(String args[]) { \n        Scanner sc = new Scanner(System.in); \n\n        long n = sc.nextLong(); \n        long s = sc.nextLong(); \n\n        long ans = (s - 1) / n + 1; \n        System.out.print(ans); \n    } \n}", "src": "public class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        long n = sc.nextLong();\n        long s = sc.nextLong();\n\n        long ans = (s - 1) / n + 1;\n        System.out.print(ans);\n    }\n}", "index": 74, "complexity": "0"}
{"back-translation": "public class PaperFolding {\n\tpublic static void main(String args[]) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tdouble n = scanner.nextInt();\n\t\tdouble k = scanner.nextInt();\n\t\tdouble red = 0;\n\t\tdouble green = 0;\n\t\tdouble blue = 0;\n\t\tdouble ans = 0;\n\t\tred = (2.0 * n) / k;\n\t\tgreen = (5.0 * n) / k;\n\t\tblue = (8.0 * n) / k;\n\n\t\tdouble red1 = Math.ceil(red);\n\t\tdouble green1 = Math.ceil(green);\n\t\tdouble blue1 = Math.ceil(blue);\n\n\t\tans += red1;\n\t\tans += green1;\n\t\tans += blue1;\n\t\tDouble answer = Double.valueOf(ans);\n\t\tint finished = answer.intValue();\n\t\tSystem.out.println(finished);\n\t}\n}", "src": "public class origami {\n\tpublic static void main(String args[]){\n\t\tScanner input = new Scanner(System.in);\n\t\tdouble n = input.nextInt();\n\t\tdouble k = input.nextInt();\n\t\tdouble red = 0;\n\t\tdouble green = 0;\n\t\tdouble blue = 0;\n\t\tdouble ans = 0;\n\t\tred = (2 * n) / k;\n\t\tgreen = (5 * n) / k;\n\t\tblue = (8 * n) / k;\n\n\t\tdouble red1 = Math.ceil(red) ;\n\t\tdouble green1 = Math.ceil(green);\n\t\tdouble blue1 = Math.ceil(blue);\n\n\t\tans+=red1;\n\t\tans+=green1;\n\t\tans+=blue1;\n\t\tDouble answer = new Double(ans);\n\t\tint finished = answer.intValue();\n\t\tSystem.out.println(finished);\n\t}\n}", "index": 75, "complexity": "0"}
{"back-translation": "public class VJudgeProblem2 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int x = Integer.parseInt(reader.readLine());\n        if (x == 1) {\n            System.out.println(-1);\n        } else {\n            System.out.println(x + \" \" + x);\n        }\n    }\n}", "src": "public class VJudgeProblem2{\n    public static void main(String[] args) throws IOException{\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        int x = Integer.parseInt(reader.readLine());\n\n        if (x == 1)\n            System.out.println(-1);\n        else\n            System.out.println(x + \" \" + x);    \n    }\n        \n}", "index": 76, "complexity": "0"}
{"back-translation": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int q=scan.nextInt();\n        int i = 1;\n        while(i<=q)\n        {\n            int a=scan.nextInt();\n            int ans=a/7+1;\n            System.out.println(ans);\n            i++;\n        }\n    }\n}", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int q=scan.nextInt();\n        int i;\n        for(i=1;i<=q;i++)\n        {\n            int a=scan.nextInt();\n            int ans=a/7+1;\n            System.out.println(ans);\n        }\n    }\n}", "index": 77, "complexity": "0"}
{"back-translation": "public class Main {\n    static Scanner scan = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        int num = scan.nextInt();\n        int i = 0;\n        while (i < num) {\n            int a = scan.nextInt();\n            int b = scan.nextInt();\n            System.out.println(a + \" \" + 2 * a);\n            i++;\n        }\n    }\n}", "src": "public class Main {\n    static Scanner scan = new Scanner(System.in);\n\n    public static void main(String [] args){\n        int num = scan.nextInt();\n        for(int i=0;i<num;i++){\n            int a = scan.nextInt();\n            int b = scan.nextInt();\n            System.out.println(a+\" \"+2*a);\n        }\n    }\n}", "index": 78, "complexity": "0"}
{"back-translation": "public class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint a = in.nextInt();\n\n\t\tif(a >= 0 && a <= 100){\n\t\t\tif(a % 2 == 0 && a > 2){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}else{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}", "src": "public class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint a = in.nextInt();\n\n\t\tif(a>=1 && a<=100){\n\t\t\tif(a>2){\n\t\t\t\tif(a%2==0){\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\n\t}\n}", "index": 79, "complexity": "0"}
{"back-translation": "ERROR", "src": "public class b {\n\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tScanner zizo = new Scanner(System.in);\n\t\tPrintWriter wr = new PrintWriter(System.out);\n\t\t\n\t\tint n1 = 0,n2 = 0,n3 = 0,n4 = 0;\n\t\tint n = 3;\n\t\twhile(n --> 0) {\n\t\t\tint x = zizo.nextInt();\n\t\t\tswitch(x) {\n\t\t\tcase 1:n1++;break;\n\t\t\tcase 4:n4++;break;\n\t\t\tcase 2:n2++;break;\n\t\t\tcase 3:n3++;break;\n\t\t\t}\n\t\t}\n\t\tn2 += n4/2;\n\t\tif(n1>0 || n2>1 || n3>2)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t\twr.close();\n\t}\n}\nclass pair{\n\tint l,r;\n\tpair(int a,int b){l = a;r = b;}\n}\n\nclass Scanner \n{\n\tStringTokenizer st;\n\tBufferedReader br;\n\n\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\tpublic String next() throws IOException \n\t{\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\tpublic double nextDouble() throws IOException\n\t{\n\t\tString x = next();\n\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\tdouble res = 0, f = 1;\n\t\tboolean dec = false, neg = false;\n\t\tint start = 0;\n\t\tif(x.charAt(0) == '-')\n\t\t{\n\t\t\tneg = true;\n\t\t\tstart++;\n\t\t}\n\t\tfor(int i = start; i < x.length(); i++)\n\t\t\tif(x.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\tdec = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\tif(dec)\n\t\t\t\t\tf *= 10;\n\t\t\t}\n\t\tres += Long.parseLong(sb.toString()) / f;\n\t\treturn res * (neg?-1:1);\n\t}\n\n\tpublic boolean ready() throws IOException {return br.ready();}\n}", "index": 80, "complexity": "0"}
{"back-translation": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tlong result1 = Math.max(2 * x + y - a, 0);\n\t\tlong result2 = Math.max(y + 3 * z - b, 0);\n\t\tSystem.out.println(result1 + result2);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "src": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 81, "complexity": "0"}
{"back-translation": "public class Main{\n    public static void main(String [] args)\n    {\n        long n=scan.nextLong();\n        long m=scan.nextLong();\n        n=(long)Math.pow(2,n);\n        long ans=m%n;\n        System.out.println(ans);\n    }\n}", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        long n=scan.nextLong();\n        long m=scan.nextLong();\n        n=(long)Math.pow(2,n);\n        long ans=m%n;\n        System.out.println(ans);\n    }\n}", "index": 82, "complexity": "0"}
{"back-translation": "public class Tab {\n    public static void main(String[] args) {\n        int n, pos, l, r;\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        pos = sc.nextInt();\n        l = sc.nextInt();\n        r = sc.nextInt();\n        int sum;\n        int a = (n - r) + (l - 1);\n        if ((Math.abs(pos - l) < Math.abs(r - pos)) && a != 0) {\n            if (l != 1) {\n                sum = Math.abs(pos - l);\n                sum++;\n                if (r != n) {\n                    sum += (r - l) + 1;\n                }\n            } else {\n                sum = Math.abs(r - pos) + 1;\n            }\n        } else if (a == 0) {\n            sum = 0;\n        } else {\n            if (r != n) {\n                sum = Math.abs(r - pos);\n                sum++;\n                if (l != 1) {\n                    sum += (r - l) + 1;\n                }\n            } else {\n                sum = Math.abs(pos - l) + 1;\n            }\n        }\n        System.out.println(sum);\n    }\n}", "src": "public class tab\n{\npublic static void main(String[] args)\n{\nint n,pos,l,r;\nScanner sc=new Scanner(System.in);\nn=sc.nextInt();\npos=sc.nextInt();\nl=sc.nextInt();\nr=sc.nextInt();\nint sum;\nint a=(n-r)+(l-1);\nif((Math.abs(pos-l)<Math.abs(r-pos))&&a!=0)\n{\n if(l!=1)\n   {sum=Math.abs(pos-l);\n    sum++;\n    if(r!=n)\n      sum+=(r-l)+1;\n   }\n else\n   sum=Math.abs(r-pos)+1;\n}\nelse if(a==0)\n  sum=0; \nelse\n{\n  if(r!=n)\n  {  sum=Math.abs(r-pos);\n     sum++;\n     if(l!=1) \n     sum+=(r-l)+1;\n  }\n  else\n   sum=Math.abs(pos-l)+1;\n}\nSystem.out.println(sum);\n}}", "index": 83, "complexity": "0"}
{"back-translation": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNextInt()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 84, "complexity": "0"}
{"back-translation": "public class PizzaPizzaPizza {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong n = nextLong();\n\t\tif (n == 0)\n\t\t\tSystem.out.println(0);\n\t\telse if (n % 2 == 0)\n\t\t\tSystem.out.println(n + 1);\n\t\telse\n\t\t\tSystem.out.println((n + 1) / 2);\n\t}\n\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "src": "public class PizzaPizzaPizza {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong n = nextLong();\n\t\tif (n == 0)\n\t\t\tSystem.out.println(0);\n\t\telse if (n % 2 == 0)\n\t\t\tSystem.out.println(n+1);\n\t\telse\n\t\t\tSystem.out.println((n+1)/2);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 85, "complexity": "0"}
{"back-translation": "public class helloWorld {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint a = in.nextInt();\n\t\tint b = in.nextInt();\n\t\tint c = in.nextInt();\n\t\tint n = in.nextInt();\n\n\t\tint ans = n - (a + b - c);\n\t\tif(ans < 1 || a >= n || b >= n || c > a || c > b) ans = -1;\n\t\tSystem.out.println(ans);\n\t\tin.close();\n\t}\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint a = in.nextInt();\n\t\tint b = in.nextInt();\n\t\tint c = in.nextInt();\n\t\tint n = in.nextInt();\n\n\t\tint ans = n - (a + b - c);\n\t\tif(ans < 1 || a >= n || b >= n || c > a || c > b)\n\t\t\tans = -1;\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 86, "complexity": "0"}
{"back-translation": "public class AlexAndARhombus {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StreamTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tSystem.out.println((long) n * n + (n - 1) * (n - 1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || st.nextToken() == StreamTokenizer.TT_EOF)\n\t\t\tst = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\treturn st.sval;\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "src": "public class AlexAndARhombus {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tSystem.out.println(n*n+(n-1)*(n-1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 87, "complexity": "0"}
{"back-translation": "class Simple implements Runnable {\n\n    public void run() {\n\n        InputReader input = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = input.nextInt();\n\n        System.out.println((2 * n * n) - (2 * n) + 1);\n    }\n\n    class Graph {\n        private final int v;\n        private List<List<Integer>> adj;\n\n        Graph(int v) {\n            this.v = v;\n            adj = new ArrayList<>(v);\n            for (int i = 0; i < v; i++) {\n                adj.add(new LinkedList<>());\n            }\n        }\n\n        private void addEdge(int a, int b) {\n            adj.get(a).add(b);\n        }\n\n        private boolean isCyclic() {\n            boolean[] visited = new boolean[v];\n            boolean[] recStack = new boolean[v];\n            for (int i = 0; i < v; i++)\n                if (isCyclicUtil(i, visited, recStack))\n                    return true;\n\n            return false;\n        }\n\n        private boolean isCyclicUtil(int i, boolean[] visited, boolean[] recStack) {\n            if (recStack[i])\n                return true;\n            if (visited[i])\n                return false;\n            visited[i] = true;\n            recStack[i] = true;\n            List<Integer> children = adj.get(i);\n            for (Integer c : children)\n                if (isCyclicUtil(c, visited, recStack))\n                    return true;\n            recStack[i] = false;\n            return false;\n        }\n    }\n\n    public static void sortbyColumn(int arr[][], int col) {\n\n        Arrays.sort(arr, new Comparator<int[]>() {\n\n            public int compare(int[] o1, int[] o2) {\n                return (Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    public static class DJSet {\n        public int[] upper;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n\n    public static int[] radixSort(int[] f) {\n        int[] to = new int[f.length];\n\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] & 0xffff)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] & 0xffff]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] >>> 16)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] >>> 16]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n\n        return f;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public int nextInt() {\n            int c = read();\n\n            while (isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Simple(), \"TaskA\", 1 << 26).start();\n    }\n}", "src": "public class simple implements Runnable {\n\n\n    public void run()\n    {\n\n        InputReader input = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = input.nextInt();\n\n            System.out.println((2*n*n)-(2*n)+1);\n    }\n\n\n\n    class Graph{\n        private final int v;\n        private List<List<Integer>> adj;\n        Graph(int v){\n            this.v = v;\n            adj = new ArrayList<>(v);\n            for(int i=0;i<v;i++){\n                adj.add(new LinkedList<>());\n            }\n        }\n        private void addEdge(int a,int b){\n            adj.get(a).add(b);\n        }\n        private boolean isCyclic()\n        {\n            boolean[] visited = new boolean[v];\n            boolean[] recStack = new boolean[v];\n            for (int i = 0; i < v; i++)\n                if (isCyclicUtil(i, visited, recStack))\n                    return true;\n\n            return false;\n        }\n        private boolean isCyclicUtil(int i, boolean[] visited, boolean[] recStack)\n        {\n            if (recStack[i])\n                return true;\n            if (visited[i])\n                return false;\n            visited[i] = true;\n            recStack[i] = true;\n            List<Integer> children = adj.get(i);\n            for (Integer c: children)\n                if (isCyclicUtil(c, visited, recStack))\n                    return true;\n            recStack[i] = false;\n            return false;\n        }\n    }\n    public static void sortbyColumn(int arr[][], int col)\n    {\n\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static class DJSet {\n        public int[] upper;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f)\n    {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new simple(),\"TaskA\",1<<26).start();\n    }\n}", "index": 88, "complexity": "0"}
{"back-translation": "class GFG { static int countStr(int n) { return 1 + n * 2 + n * ((n * n) - 1) / 2; } public static void main(String[] args) { int n = 3; System.out.println(countStr(n)); } }", "src": "class\nGFG \n{ \n\nstatic\nint\ncountStr(\nint\nn) \n\n{ \n\nreturn\n1\n+ (n * \n2\n) + \n\n(n * ((n * n) - \n1\n) / \n2\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\nn = \n3\n; \n\nSystem.out.println( countStr(n)); \n} \n}", "index": 89, "complexity": "0"}
{"back-translation": "class Test { static int binarySearch(int arr[], int l, int r, int x) { if (r>=l) { int mid = l + (r - l)/2; if (arr[mid] == x) return mid; if (arr[mid] > x) return binarySearch(arr, l, mid-1, x); return binarySearch(arr, mid+1, r, x); } return -1; } static int findPos(int arr[], int key) { int l = 0, h = 1; int val = arr[0]; while (val < key) { l = h; if (2*h < arr.length-1) h = 2*h; else h = arr.length-1; val = arr[h]; } return binarySearch(arr, l, h, key); } public static void main(String[] args) { int arr[] = new int[]{3, 5, 7, 9, 10, 90, 100, 130, 140, 160, 170}; int ans = findPos(arr, 10); if (ans==-1) System.out.println(\"Element not found\"); else System.out.println(\"Element found at index \"+ ans); } }", "src": "class\nTest \n{ \n\n\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r>=l) \n\n{ \n\nint\nmid = l + (r - l)/\n2\n; \n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid-\n1\n, x); \n\nreturn\nbinarySearch(arr, mid+\n1\n, r, x); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindPos(\nint\narr[],\nint\nkey) \n\n{ \n\nint\nl = \n0\n, h = \n1\n; \n\nint\nval = arr[\n0\n]; \n\n\n\n\nwhile\n(val < key) \n\n{ \n\nl = h; \n\n\n\n\n\n\nif\n(\n2\n*h < arr.length-\n1\n) \n\nh = \n2\n*h; \n\nelse\n\nh = arr.length-\n1\n; \n\n\nval = arr[h]; \n\n\n} \n\n\n\n\n\n\n\n\nreturn\nbinarySearch(arr, l, h, key); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n3\n, \n5\n, \n7\n, \n9\n, \n10\n, \n90\n, \n\n100\n, \n130\n, \n140\n, \n160\n, \n170\n}; \n\nint\nans = findPos(arr,\n10\n); \n\n\nif\n(ans==-\n1\n) \n\nSystem.out.println(\n\"Element not found\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at index \"\n+ ans); \n\n} \n}", "index": 90, "complexity": "2"}
{"back-translation": "class Main { static int ceilSearch(int arr[], int low, int high, int x) { int mid; if (x <= arr[low]) return low; if (x > arr[high]) return -1; mid = (low + high) / 2; if (arr[mid] == x) return mid; else if (arr[mid] < x) { if (mid + 1 <= high && x <= arr[mid + 1]) return mid + 1; else return ceilSearch(arr, mid + 1, high, x); } else { if (mid - 1 >= low && x > arr[mid - 1]) return mid; else return ceilSearch(arr, low, mid - 1, x); } } public static void main(String[] args) { int arr[] = { 1, 2, 8, 10, 10, 12, 19 }; int n = arr.length; int x = 8; int index = ceilSearch(arr, 0, n - 1, x); if (index == -1) System.out.println(\"Ceiling of \" + x + \" doesn't exist in array\"); else System.out.println(\"ceiling of \" + x + \" is \" + arr[index]); } }", "src": "class\nMain \n{ \n\n\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\nmid; \n\n\n\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n\n\nif\n(x > arr[high]) \n\nreturn\n-\n1\n; \n\n\n\n\nmid = (low + high)/\n2\n; \n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n\n\nelse\nif\n(arr[mid] < x) \n\n{ \n\nif\n(mid + \n1\n<= high && x <= arr[mid+\n1\n]) \n\nreturn\nmid + \n1\n; \n\nelse\n\nreturn\nceilSearch(arr, mid+\n1\n, high, x); \n\n} \n\n\n\n\nelse\n\n{ \n\nif\n(mid - \n1\n>= low && x > arr[mid-\n1\n]) \n\nreturn\nmid; \n\nelse\n\nreturn\nceilSearch(arr, low, mid - \n1\n, x); \n\n} \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n8\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n}", "index": 91, "complexity": "2"}
{"back-translation": "class Majority {\n\n    static int binarySearch(int arr[], int low, int high, int x) {\n        if (high >= low) {\n            int mid = (low + high) / 2;\n            if ((mid == 0 || x > arr[mid - 1]) && (arr[mid] == x))\n                return mid;\n            else if (x > arr[mid])\n                return binarySearch(arr, (mid + 1), high, x);\n            else\n                return binarySearch(arr, low, (mid - 1), x);\n        }\n        return -1;\n    }\n\n    static boolean isMajority(int arr[], int n, int x) {\n        int i = binarySearch(arr, 0, n - 1, x);\n        if (i == -1)\n            return false;\n        if (((i + n / 2) <= (n - 1)) && arr[i + n / 2] == x)\n            return true;\n        else\n            return false;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {1, 2, 3, 3, 3, 3, 10};\n        int n = arr.length;\n        int x = 3;\n        if (isMajority(arr, n, x) == true)\n            System.out.println(x + \" appears more than \" + n / 2 + \" times in arr[]\");\n        else\n            System.out.println(x + \" does not appear more than \" + n / 2 + \" times in arr[]\");\n    }\n}", "src": "class\nMajority { \n\n\n\n\nstatic\nint\n_binarySearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nif\n(high >= low) \n\n{ \n\nint\nmid = (low + high)/\n2\n; \n\n\n\n\n\nif\n( (mid == \n0\n|| x > arr[mid-\n1\n]) && (arr[mid] == x) ) \n\nreturn\nmid; \n\nelse\nif\n(x > arr[mid]) \n\nreturn\n_binarySearch(arr, (mid + \n1\n), high, x); \n\nelse\n\nreturn\n_binarySearch(arr, low, (mid -\n1\n), x); \n\n} \n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\nstatic\nboolean\nisMajority(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ni = _binarySearch(arr, \n0\n, n-\n1\n, x); \n\n\n\n\nif\n(i == -\n1\n) \n\nreturn\nfalse\n; \n\n\n\n\nif\n(((i + n/\n2\n) <= (n -\n1\n)) && arr[i + n/\n2\n] == x) \n\nreturn\ntrue\n; \n\nelse\n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n3\n, \n3\n, \n3\n, \n10\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nif\n(isMajority(arr, n, x)==\ntrue\n) \n\nSystem.out.println(x + \n\" appears more than \"\n+ \n\nn/\n2\n+ \n\" times in arr[]\"\n); \n\nelse\n\nSystem.out.println(x + \n\" does not appear more than \"\n+ \n\nn/\n2\n+ \n\" times in arr[]\"\n); \n\n} \n}", "index": 92, "complexity": "2"}
{"back-translation": "public class BinarySearch {\n\n    private static int binarySearch(int[] a, int n) {\n        return binarySearch(a, n, 0, a.length - 1);\n    }\n\n    public static int binarySearch(int[] a, int n, int low, int high) {\n\n        if (low <= high) {\n            int mid = (low + high) / 2;\n\n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                return binarySearch(a, n, 0, mid - 1);\n            } else {\n                return binarySearch(a, n, mid + 1, high);\n            }\n        } else {\n            return -1;\n        }\n    }\n\n    private static int binarySearchNonRecursive(int[] a, int n) {\n        int low = 0, high = a.length, mid;\n        while (low <= high) {\n            mid = (low + high) / 2;\n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(binarySearch(new int[]{0, 2}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearch(new int[]{0, 2}, 0));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 2, 2, 3, 3}, 2));\n        System.out.println(\"---------\");\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 0));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 2, 2, 3, 3}, 2));\n    }\n}", "src": "public class BinarySearch {\n\n    \n    private static int binarySearch(int[] a, int n) {\n        return binarySearch(a, n, 0, a.length - 1);\n    }\n\n    public static int binarySearch(int[] a, int n, int low, int high) {\n\n        if (low <= high) {\n            int mid = (low + high) / 2; \n\n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                return binarySearch(a, n, 0, mid - 1);\n            } else {\n                return binarySearch(a, n, mid + 1, high);\n            }\n        } else {\n            return -1;\n        }\n    }\n\n    \n    private static int binarySearchNonRecursive(int[] a, int n) {\n        int low = 0, high = a.length, mid;\n        while (low <= high) {\n            mid = (low + high) / 2; \n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    \n    public static void main(String[] args) {\n        System.out.println(binarySearch(new int[]{0, 2}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearch(new int[]{0, 2}, 0));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 2, 2, 3, 3}, 2)); \n        System.out.println(\"---------\");\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 0));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 2, 2, 3, 3}, 2));\n    }\n}", "index": 93, "complexity": "2"}
{"back-translation": "class findMedianTwoArrays {\n  public static double main(int[] arr1, int start1, int end1, int[] arr2, int start2, int end2) {\n    if (end1 - start1 == 1 && end2 - start2 == 1) {\n      return (Math.max(arr1[start1], arr2[start2]) + Math.min(arr1[end1], arr2[end2])) / 2;\n    }\n    int median1Index = (int) Math.floor((start1 + end1) / 2);\n    int median2Index = (int) Math.floor((start2 + end2) / 2);\n    int median1 = arr1[median1Index];\n    int median2 = arr2[median2Index];\n    if (median1 == median2) {\n      return median1;\n    }\n    if (median1 < median2) {\n      start1 = median1Index;\n      if (end2 - start2 > 1) {\n        end2 = median2Index;\n      }\n    } else {\n      start2 = median2Index;\n      if (end1 - start1 > 1) {\n        end1 = median1Index;\n      }\n    }\n    return main(arr1, start1, end1, arr2, start2, end2);\n  }\n}\n\nclass test {\n  public static void main(String[] args) {\n    int[] A = {1, 2, 3, 4, 4};\n    int[] B = {6, 9, 10, 11, 15};\n    findMedianTwoArrays findMedian = new findMedianTwoArrays();\n    System.out.println(\"Hello Java\");\n    System.out.println(findMedian.main(A, 0, 4, B, 0, 4));\n  }\n}", "src": "class findMedianTwoArrays\n{\n  public static double main(\n    int[] arr1, int start1, int end1, int[] arr2, int start2, int end2) {\n    if ( end1 - start1 == 1 && end2 - start2 == 1 ) {\n        return ( Math.max(arr1[start1], arr2[start2]) + Math.min(arr1[end1], arr2[end2]) ) / 2;\n    }    \n  \n  int median1Index = Math.floor((start1 + end1 ) / 2);\n  int median2Index = Math.floor((start2 + end2 ) / 2);\n  int median1 = arr1[median1Index];\n  int median2 = arr2[median2Index];\n\n  if ( median1 == median2 ) {\n    return median1;\n  }    \n\n  if ( median1 < median2 ) {\n    start1 = median1Index;\n    if ( end2 - start2 > 1 ) { \n        end2 = median2Index;\n    }        \n  } else {\n    start2 = median2Index;\n    if ( end1 - start1 > 1 ) { \n        end1 = median1Index;\n    }    \n  }            \n\n  return main(arr1, start1, end1, arr2, start2, end2);\n  }\n}\n\nclass test {\n  public static void main(String[] args) {\n    int[] A = { 1, 2, 3, 4, 4 };\n    int[] B = { 6, 9, 10, 11, 15};\n    findMedianTwoArrays findMedian = new findMedianTwoArrays();\n    System.out.println(\"Hello Java\");\n    System.out.println(findMedian.main(A, 0, 4, B, 0, 4));\n  }    \n}", "index": 94, "complexity": "2"}
{"back-translation": "public class MedianOfTwoSortedArrayOfDifferentLength {\n\n    public double findMedianSortedArrays(int[] input1, int[] input2) {\n        if (input1.length > input2.length) {\n            return findMedianSortedArrays(input2, input1);\n        }\n        int x = input1.length;\n        int y = input2.length;\n        int low = 0;\n        int high = x;\n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (x + y + 1) / 2 - partitionX;\n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : input1[partitionX - 1];\n            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : input1[partitionX];\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : input2[partitionY - 1];\n            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : input2[partitionY];\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                if ((x + y) % 2 == 0) {\n                    return ((double) Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n                } else {\n                    return (double) Math.max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n        throw new IllegalArgumentException();\n    }\n\n    public static void main(String[] args) {\n        int[] x = {1, 3, 8, 9, 15};\n        int[] y = {7, 11, 19, 21, 18, 25};\n\n        MedianOfTwoSortedArrayOfDifferentLength mm = new MedianOfTwoSortedArrayOfDifferentLength();\n        mm.findMedianSortedArrays(x, y);\n    }\n}", "src": "public class MedianOfTwoSortedArrayOfDifferentLength {\n\n    public double findMedianSortedArrays(int input1[], int input2[]) {\n        \n        if (input1.length > input2.length) {\n            return findMedianSortedArrays(input2, input1);\n        }\n        int x = input1.length;\n        int y = input2.length;\n\n        int low = 0;\n        int high = x;\n        while (low <= high) {\n            int partitionX = (low + high)/2;\n            int partitionY = (x + y + 1)/2 - partitionX;\n\n            \n            \n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : input1[partitionX - 1];\n            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : input1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : input2[partitionY - 1];\n            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : input2[partitionY];\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                \n                \n                \n                if ((x + y) % 2 == 0) {\n                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY))/2;\n                } else {\n                    return (double)Math.max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) { \n                high = partitionX - 1;\n            } else { \n                low = partitionX + 1;\n            }\n        }\n\n        \n        throw new IllegalArgumentException();\n    }\n\n    public static void main(String[] args) {\n        int[] x = {1, 3, 8, 9, 15};\n        int[] y = {7, 11, 19, 21, 18, 25};\n\n        MedianOfTwoSortedArrayOfDifferentLength mm = new MedianOfTwoSortedArrayOfDifferentLength();\n        mm.findMedianSortedArrays(x, y);\n    }\n}", "index": 95, "complexity": "2"}
{"back-translation": "public class FloorAndCeilingConverted {\n\n    public int search(int arr[], int x, String type) {\n        int low = 0;\n        int high = arr.length - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (arr[mid] == x || (arr[mid] < x && (mid == arr.length - 1 || arr[mid + 1] > x))) {\n                return mid;\n            } else if (arr[mid] < x) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {1, 2, 5, 6, 11, 15};\n        FloorAndCeilingConverted obj = new FloorAndCeilingConverted();\n        System.out.println(obj.search(arr, 15, \"floor\"));\n        System.out.println(obj.search(arr, 2, \"ceiling\"));\n    }\n}", "src": "public class FloorAndCeilingSortedArray {\n\n    public int floor(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] < x && (middle == input.length-1 || input[middle+1] > x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n\n    public int ceiling(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] > x && (middle == 0 || input[middle-1] < x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        int input[] = {1,2,5,6,11,15};\n        FloorAndCeilingSortedArray foc = new FloorAndCeilingSortedArray();\n        System.out.println(foc.floor(input, 15));\n        System.out.println(foc.ceiling(input, 2));\n    }\n}", "index": 96, "complexity": "2"}
{"back-translation": "public class FloorAndCeilingInASortedArray {\n\n    private static int ceilSearch(int arr[], int low, int high, int x) {\n        int mid;\n\n        if (x <= arr[low])\n            return low;\n\n        if (x > arr[high])\n            return -1;\n\n        mid = (low + high) / 2; \n\n        if (arr[mid] == x)\n            return mid;\n\n        else if (x > arr[mid]) {\n            if (mid + 1 <= high && x <= arr[mid + 1])\n                return mid + 1;\n            else\n                return ceilSearch(arr, mid + 1, high, x);\n        }\n\n        else {\n            if (mid - 1 >= low && x > arr[mid - 1])\n                return mid;\n            else\n                return ceilSearch(arr, low, mid - 1, x);\n        }\n    }\n\n    public static void main(String[] args) {\n        int arr[] = { 1, 2, 8, 10, 10, 12, 19 };\n        int n = arr.length;\n        int x = 11;\n        int index = ceilSearch(arr, 0, n - 1, x);\n        if (index == -1)\n            System.out.println(\"Ceiling of doesn't exist in array \" + x);\n        else\n            System.out.println(\"ceiling of\" + x + \" is \" + arr[index]);\n    }\n\n}", "src": "public class FloorAndCeilingInASortedArray {\n\n\t\n\tprivate static int ceilSearch(int arr[], int low, int high, int x) {\n\t\tint mid;\n\n\t\t\n\t\tif (x <= arr[low])\n\t\t\treturn low;\n\n\t\t\n\t\tif (x > arr[high])\n\t\t\treturn -1;\n\n\t\t\n\t\tmid = (low + high) / 2; \n\n\t\t\n\t\tif (arr[mid] == x)\n\t\t\treturn mid;\n\n\t\t\n\t\telse if (x > arr[mid]) {\n\t\t\tif (mid + 1 <= high && x <= arr[mid + 1])\n\t\t\t\treturn mid + 1;\n\t\t\telse\n\t\t\t\treturn ceilSearch(arr, mid + 1, high, x);\n\t\t}\n\n\t\t\n\t\telse {\n\t\t\tif (mid - 1 >= low && x > arr[mid - 1])\n\t\t\t\treturn mid;\n\t\t\telse\n\t\t\t\treturn ceilSearch(arr, low, mid - 1, x);\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tint arr[] = { 1, 2, 8, 10, 10, 12, 19 };\n\t\tint n = arr.length;\n\t\tint x = 11;\n\t\tint index = ceilSearch(arr, 0, n - 1, x);\n\t\tif (index == -1)\n\t\t\tSystem.out.println(\"Ceiling of doesn't exist in array \" + x);\n\t\telse\n\t\t\tSystem.out.println(\"ceiling of\" + x + \" is \" + arr[index]);\n\n\t}\n\n}", "index": 97, "complexity": "2"}
{"back-translation": "public class FloorInSortedArray { \n    public static int floor(int[] A, int val) throws Exception { \n        if (val < A[0]) \n            throw new Exception(\"All elements are greater than val\"); \n        else if (val > A[A.length - 1]) \n            return A[A.length - 1]; \n        return floor(A, 0, A.length - 1, val); \n    } \n\n    private static int floor(int[] A, int l, int r, int val) throws Exception { \n        if (l > r) { \n            throw new Exception(\"Not found\"); \n        } \n        int mid = (l + r) / 2; \n        if (val == A[mid]) \n            return A[mid]; \n        else if (val < A[mid]) { \n            if (val >= A[mid - 1]) \n                return A[mid - 1]; \n            return floor(A, l, mid - 1, val); \n        } else { \n            if (val < A[mid + 1]) \n                return A[mid]; \n            return floor(A, mid + 1, r, val); \n        } \n    } \n\n    public static void main(String[] args) throws Exception { \n        int[] A = new int[] {1, 3, 4, 7, 8, 12, 32, 45, 78, 98}; \n\n        System.out.println(floor(A, 11)); \n        System.out.println(floor(A, 32)); \n        System.out.println(floor(A, 70)); \n        System.out.println(floor(A, 125)); \n    } \n}", "src": "public class FloorInSortedArray {\n\tpublic static int floor(int[] A, int val) throws Exception {\n\t\tif (val < A[0])\n\t\t\tthrow new Exception(\"All elements are greater than val\");\n\t\telse if (val > A[A.length - 1])\n\t\t\treturn A[A.length - 1];\n\t\treturn floor(A, 0, A.length - 1, val);\n\t}\n\n\tprivate static int floor(int[] A, int l, int r, int val) throws Exception {\n\t\tif (l > r) {\n\t\t\tthrow new Exception(\"Not found\");\n\t\t}\n\t\tint mid = (l + r) / 2;\n\t\tif (val == A[mid])\n\t\t\treturn A[mid];\n\t\telse if (val < A[mid]) {\n\t\t\tif (val >= A[mid - 1])\n\t\t\t\treturn A[mid - 1];\n\t\t\treturn floor(A, l, mid - 1, val);\n\t\t} else {\n\t\t\tif (val < A[mid + 1])\n\t\t\t\treturn A[mid];\n\t\t\treturn floor(A, mid + 1, r, val);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint[] A = new int[] { 1, 3, 4, 7, 8, 12, 32, 45, 78, 98 };\n\t\t\n\t\tSystem.out.println(floor(A, 11));\n\t\tSystem.out.println(floor(A, 32));\n\t\tSystem.out.println(floor(A, 70));\n\t\tSystem.out.println(floor(A, 125));\n\t}\n\n}", "index": 98, "complexity": "2"}
{"back-translation": "public class BinarySearch {\n\n    public static int search(int[] input, int search) {\n        int low = 0;\n        int high = input.length - 1;\n        int mid;\n        while (low <= high) {\n            mid = low + ((high - low) / 2);\n            if (input[mid] == search) {\n                return mid;\n            } else if (input[mid] < search) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        BinarySearch bSearch = new BinarySearch();\n        int[] arr1 = {1, 2, 4, 5, 7, 8};\n        System.out.println(bSearch.search(arr1, -1));\n        System.out.println(bSearch.search(arr1, 1));\n        System.out.println(bSearch.search(arr1, 8));\n        System.out.println(bSearch.search(arr1, 2));\n    }\n}", "src": "public class BinarySearch {\n\n    public int search(final int input[], int search) {\n        int low = 0;\n        int high = input.length - 1;\n        int mid;\n        while (low <= high) {\n            mid = low + ((high - low) / 2);\n            if (input[mid] == search) {\n                return mid;\n            } else if (input[mid] < search) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        BinarySearch bSearch = new BinarySearch();\n        final int arr1[] = {1, 2, 4, 5, 7, 8};\n        System.out.println(bSearch.search(arr1, -1));\n        System.out.println(bSearch.search(arr1, 1));\n        System.out.println(bSearch.search(arr1, 8));\n        System.out.println(bSearch.search(arr1, 2));\n    }\n}", "index": 99, "complexity": "2"}
{"back-translation": "public class CircularBinarySearch {\n\n    public int search(int[] arr) {\n        int low = 0;\n        int high = arr.length - 1;\n        int mid = 0;\n        while (low < high) {\n            mid = (low + high) / 2;\n            if ((low == mid || arr[mid] < arr[mid - 1]) && arr[mid] < arr[mid + 1]) {\n                return arr[mid];\n            }\n            if ((arr[mid] >= arr[low] && arr[mid] >= arr[high])) {\n                if (arr[low] < arr[high]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            } else {\n                if (arr[mid - 1] < arr[mid + 1]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return arr[low];\n    }\n\n    public static void main(String[] args) {\n        CircularBinarySearch cbs = new CircularBinarySearch();\n        int[] arr = {7, 10, 8, 5, 2, 3, 5};\n        System.out.print(cbs.search(arr));\n        int[] arr1 = {5, 8, 10, 7, 5, 3, 2};\n        System.out.print(cbs.search(arr1));\n        int[] arr2 = {3, 5, 7, 10, 8, 5, 2};\n        System.out.print(cbs.search(arr2));\n        int[] arr3 = {8, 5, 2, 3, 5, 7, 10};\n        System.out.print(cbs.search(arr3));\n        int[] arr4 = {5, 3, 2, 5, 8, 10, 7};\n        System.out.print(cbs.search(arr4));\n        int[] arr5 = {100, 20, 10, 5, 2, 8, 11, 16, 19};\n        System.out.print(cbs.search(arr5));\n        int[] arr6 = {200, 2, 10, 15, 20, 80, 110, 160, 190};\n        System.out.print(cbs.search(arr6));\n        int[] arr7 = {5, 10, 20, 50, 200, 800, 1100, 1600, 1900, 2};\n        System.out.print(cbs.search(arr7));\n        int[] arr8 = {2, 5, 10, 20, 50, 200, 800, 1100, 1600, 1900};\n        System.out.print(cbs.search(arr8));\n        int[] arr9 = {3, 1, 8, 5, 4};\n        System.out.print(cbs.search(arr9));\n    }\n}", "src": "public class CircularBinarySearch {\n\n    \n    \n    public int search(int arr[]) {\n        int low = 0;\n        int high = arr.length - 1;\n        int mid = 0;\n        while (low < high) {\n            mid = (low + high) / 2;\n            \n            if((low == mid || arr[mid] < arr[mid-1])&& arr[mid] < arr[mid+1]){\n                return arr[mid];\n            }\n            if ((arr[mid] >= arr[low] && arr[mid] >= arr[high])){\n                if(arr[low] < arr[high]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }else{\n                if(arr[mid-1] < arr[mid+1]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return arr[low];\n    }\n\n    public static void main(String args[]) {\n        CircularBinarySearch cbs = new CircularBinarySearch();\n        int arr[] = { 7, 10, 8, 5, 2, 3, 5 };\n        System.out.print(cbs.search(arr));\n\n        int arr1[] = { 5, 8, 10, 7, 5, 3, 2 };\n        System.out.print(cbs.search(arr1));\n\n        int arr2[] = { 3, 5, 7, 10, 8, 5, 2 };\n        System.out.print(cbs.search(arr2));\n\n        int arr3[] = { 8, 5, 2, 3, 5, 7, 10 };\n        System.out.print(cbs.search(arr3));\n\n        int arr4[] = { 5, 3, 2, 5, 8, 10, 7 };\n        System.out.print(cbs.search(arr4));\n\n        int arr5[] = {100,20,10,5,2,8,11,16,19};\n        System.out.print(cbs.search(arr5));\n\n        int arr6[] = {200,2,10,15,20,80,110,160,190};\n        System.out.print(cbs.search(arr6));\n\n        int arr7[] = {5,10,20,50,200,800,1100,1600,1900,2};\n        System.out.print(cbs.search(arr7));\n\n        int arr8[] = {2,5,10,20,50,200,800,1100,1600,1900};\n        System.out.print(cbs.search(arr8));\n        \n        int arr9[] = {3,1,8,5,4};\n        System.out.print(cbs.search(arr9));\n        \n    }\n}", "index": 100, "complexity": "2"}
{"back-translation": "class MonotonicallyIncreasingFunctionBecomesPositive {\n\n    private int f(int x){\n        return x*x - 10*x - 20;\n    }\n    \n    public int findPoint(){\n        int i=1;\n        for(;f(i) <=0 ;){\n            i = i*2;\n        }\n        return binarySearch(i/2,i);\n    }\n    \n    private int binarySearch(int start,int end){\n        int mid = (start+end)/2;\n        for(;start < end;){\n            mid = (start+end)/2;\n            if(f(mid) >0 && f(mid-1) <=0){\n                return mid;\n            }\n            if(f(mid) <=0 && f(mid+1)>0){\n                return mid+1;\n            }\n            if(f(mid) <= 0){\n                start = mid+1;\n            }else{\n                end = mid-1;\n            }\n        }\n        return mid;\n    }\n    \n    public static void main(String args[]){\n        MonotonicallyIncreasingFunctionBecomesPositive mif = new MonotonicallyIncreasingFunctionBecomesPositive();\n        System.out.print(mif.findPoint());\n    }\n}", "src": "public class MonotonicallyIncreasingFunctionBecomesPositive {\n\n    private int f(int x){\n        return x*x - 10*x - 20;\n    }\n    \n    public int findPoint(){\n        int i=1;\n        while(f(i) <=0 ){\n            i = i*2;\n        }\n        return binarySearch(i/2,i);\n    }\n    \n    private int binarySearch(int start,int end){\n        int mid = (start+end)/2;\n        while(start < end){\n            mid = (start+end)/2;\n            if(f(mid) >0 && f(mid-1) <=0){\n                return mid;\n            }\n            if(f(mid) <=0 && f(mid+1)>0){\n                return mid+1;\n            }\n            if(f(mid) <= 0){\n                start = mid+1;\n            }else{\n                end = mid-1;\n            }\n        }\n        return mid;\n    }\n    \n    public static void main(String args[]){\n        MonotonicallyIncreasingFunctionBecomesPositive mif = new MonotonicallyIncreasingFunctionBecomesPositive();\n        System.out.print(mif.findPoint());\n    }\n}", "index": 101, "complexity": "2"}
{"back-translation": "public class SortedAndRotatedArraySearch {\n    public int search(int[] arr, int search) {\n        int low = 0;\n        int high = arr.length - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (arr[mid] == search) {\n                return mid;\n            }\n            if (arr[mid] < arr[high]) {\n                if (arr[mid] < search && search <= arr[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if (search >= arr[low] && search < arr[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return -1;\n    }\n\n    public boolean searchWithDuplicates(int[] arr, int search) {\n        int low = 0;\n        int high = arr.length - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (arr[mid] == search) {\n                return true;\n            }\n            if (arr[mid] == arr[low]) {\n                low++;\n            } else if (arr[mid] == arr[high]) {\n                high--;\n            } else if (arr[mid] < arr[high]) {\n                if (arr[mid] < search && search <= arr[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if (search >= arr[low] && search < arr[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        SortedAndRotatedArraySearch ras = new SortedAndRotatedArraySearch();\n        int[] arr1 = {1, 2, 5, 6, 7, 8, 11, 21};\n        System.out.print(ras.search(arr1, 1));\n        System.out.print(ras.search(arr1, 5));\n        System.out.print(ras.search(arr1, 22));\n        System.out.println();\n        int[] arr2 = {18, 21, 1, 2, 5, 6, 7, 8, 10, 15};\n        System.out.print(ras.search(arr2, 1));\n        System.out.print(ras.search(arr2, 5));\n        System.out.print(ras.search(arr2, 10));\n        System.out.print(ras.search(arr2, 14));\n        System.out.println();\n        int[] arr3 = {7, 8, 15, 17, 18, 21, 1, 2, 5, 6};\n        System.out.print(ras.search(arr3, 1));\n        System.out.print(ras.search(arr3, 5));\n        System.out.print(ras.search(arr3, 10));\n        System.out.print(ras.search(arr3, 7));\n        System.out.print(ras.search(arr3, 6));\n        System.out.print(ras.search(arr3, 16));\n    }\n}", "src": "public class SortedAndRotatedArraySearch {\n\n    \n    public int search(int arr[],int search){\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search){\n                return mid;\n            }\n            \n            if(arr[mid] < arr[high]){\n                if(arr[mid] < search && search <= arr[high]){\n                    low = mid+1;\n                }else{\n                    high = mid-1;\n                }\n            }else{\n                if(search >= arr[low] && search < arr[mid]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return -1;\n    }\n\n    \n    public boolean searchWithDuplicates(int[] arr, int search) {\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search) {\n                return true;\n            }\n            \n            if (arr[mid] == arr[low]) {\n                low++;\n            } else if (arr[mid] == arr[high]) { \n                high--;\n            } else if (arr[mid] < arr[high]) {\n                if(arr[mid] < search && search <= arr[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if(search >= arr[low] && search < arr[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String args[]){\n        SortedAndRotatedArraySearch ras = new SortedAndRotatedArraySearch();\n        int arr1[] = {1,2,5,6,7,8,11,21};\n        System.out.print(ras.search(arr1, 1));\n        System.out.print(ras.search(arr1, 5));\n        System.out.print(ras.search(arr1, 22));\n        System.out.println();\n    \n        int arr2[] = {18,21,1,2,5,6,7,8,10,15};\n        System.out.print(ras.search(arr2, 1));\n        System.out.print(ras.search(arr2, 5));\n        System.out.print(ras.search(arr2, 10));\n        System.out.print(ras.search(arr2, 14));\n        System.out.println();\n\n        int arr3[] = {7,8,15,17,18,21,1,2,5,6};\n        System.out.print(ras.search(arr3, 1));\n        System.out.print(ras.search(arr3, 5));\n        System.out.print(ras.search(arr3, 10));\n        System.out.print(ras.search(arr3, 7));\n        System.out.print(ras.search(arr3, 6));\n        System.out.print(ras.search(arr3, 16));\n    }\n}", "index": 102, "complexity": "2"}
{"back-translation": "public class SearchForRange {\n    public int[] searchRange(int[] nums, int target) {\n        int first = findFirstOccurrence(nums, target);\n        if (first == -1) {\n            return new int[]{-1, -1};\n        }\n        int last = findLastOccurrence(nums, target);\n        return new int[]{first, last};\n    }\n\n    private int findFirstOccurrence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target && (mid == 0 || nums[mid - 1] < target)) {\n                return mid;\n            } else if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    private int findLastOccurrence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target && (mid == nums.length - 1 || nums[mid + 1] > target)) {\n                return mid;\n            } else if (nums[mid] <= target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        SearchForRange searchForRange = new SearchForRange();\n        int[] nums = {0, 1, 1, 3, 6, 9, 11};\n        int[] result = searchForRange.searchRange(nums, 11);\n        System.out.println(result[0] + \" \" + result[1]);\n        result = searchForRange.searchRange(nums, 0);\n        System.out.println(result[0] + \" \" + result[1]);\n    }\n}", "src": "public class SearchForRange {\n    public int[] searchRange(int[] nums, int target) {\n        int first = firstOccurence(nums, target);\n        if (first == -1) {\n            return new int[]{-1, -1};\n        }\n        int last = lastOccurence(nums, target);\n        return new int[]{first, last};\n    }\n\n    private int firstOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == 0 || nums[mid - 1] < target)) {\n                return mid;\n            } else if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    private int lastOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == nums.length - 1 || nums[mid + 1] > target)) {\n                return mid;\n            } else if (nums[mid] <= target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        SearchForRange searchForRange = new SearchForRange();\n        int[] nums = {0, 1, 1, 3, 6, 9, 11};\n        int[] r = searchForRange.searchRange(nums, 11);\n        System.out.println(r[0] + \" \" + r[1]);\n        r = searchForRange.searchRange(nums, 0);\n        System.out.println(r[0] + \" \" + r[1]);\n    }\n}", "index": 103, "complexity": "2"}
{"back-translation": "public class PeakElement {\n\n    public int findPeakElement(int[] nums) {\n        int low = 0;\n        int high = nums.length - 1;\n        int middle = 0;\n        while (low <= high) {\n            middle = (low + high) / 2;\n            int before = Integer.MIN_VALUE;\n            if (middle > 0) {\n                before = nums[middle - 1];\n            }\n            int after = Integer.MIN_VALUE;\n            if (middle < nums.length - 1) {\n                after = nums[middle + 1];\n            }\n            if (nums[middle] > before && nums[middle] > after) {\n                return middle;\n            } else if (before > after) {\n                high = middle - 1;\n            } else {\n                low = middle + 1;\n            }\n        }\n        return middle;\n    }\n\n    public static void main(String args[]){\n        int arr[] = {10, 5, 15, 2, 23, 90, 67};\n        PeakElement pe = new PeakElement();\n        System.out.println(pe.findPeakElement(arr));\n        int arr1[] = {10, 20, 30, 40, 50};\n        System.out.println(pe.findPeakElement(arr1));\n        int arr2[] = {100, 90, 80, 70, 60};\n        System.out.println(pe.findPeakElement(arr2));\n    }\n}", "src": "public class PeakElement {\n\n    public int findPeakElement(int[] nums) {\n        int low = 0;\n        int high = nums.length - 1;\n        int middle = 0;\n        while (low <= high) {\n            middle = (low + high)/2;\n            int before = Integer.MIN_VALUE;\n            if (middle > 0) {\n                before = nums[middle - 1];\n            }\n            int after = Integer.MIN_VALUE;\n            if (middle < nums.length - 1) {\n                after = nums[middle + 1];\n            }\n            if (nums[middle] > before && nums[middle] > after) {\n                return middle;\n            } else if (before > after) {\n                high = middle - 1;\n            } else {\n                low = middle + 1;\n            }\n        }\n        return middle;\n    }\n\n    public static void main(String args[]){\n        int arr[] = {10,5,15,2,23,90,67};\n        PeakElement pe = new PeakElement();\n        System.out.println(pe.findPeakElement(arr));\n        int arr1[] = {10,20,30,40,50};\n        System.out.println(pe.findPeakElement(arr1));\n        int arr2[] = {100,90,80,70,60};\n        System.out.println(pe.findPeakElement(arr2));\n                \n    }\n}", "index": 104, "complexity": "2"}
{"back-translation": "public class FirstOccurrenceOfNumberInSortedArray {\n\n    public int firstOccurrence(int[] input, int x) {\n        int low = 0;\n        int high = input.length - 1;\n\n        while (low <= high) {\n            int middle = (low + high) / 2;\n            if (input[middle] == x && (middle == 0 || input[middle - 1] < x)) {\n                return middle;\n            } else if (input[middle] < x) {\n                low = middle + 1;\n            } else {\n                high = middle - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        FirstOccurrenceOfNumberInSortedArray fos = new FirstOccurrenceOfNumberInSortedArray();\n        int[] input = {1, 2, 2, 2, 2, 2, 5, 7, 7};\n        System.out.println(fos.firstOccurrence(input, 6));\n    }\n\n}", "src": "public class FirstOccurrenceOfNumberInSortedArray {\n\n    public int firstOccurrence(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        \n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x && (middle == 0 || input[middle-1] < x)){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        FirstOccurrenceOfNumberInSortedArray fos = new FirstOccurrenceOfNumberInSortedArray();\n        int input[] = {1,2,2,2,2,2,5,7,7};\n        System.out.println(fos.firstOccurrence(input, 6));\n    }\n    \n}", "index": 105, "complexity": "2"}
{"back-translation": "public class CountOne {\n\n    public static void main(String[] args) {\n        int[] arr = {0, 0, 0, 0, 0, 0, 0};\n\n        countOne(arr);\n    }\n\n    public static void countOne(int[] a) {\n        int l = 0;\n        int h = a.length - 1;\n        int mid = -1;\n\n        while (l <= h) {\n            mid = (l + h) / 2;\n\n            if ((mid == h || a[mid + 1] == 0) && a[mid] == 1) {\n                System.out.println(\"Count \" + (mid + 1));\n                return;\n            }\n\n            if (a[mid] < 1) {\n                h = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        System.out.println(\" No one's found \");\n        return;\n    }\n}", "src": "class CountOne {\n\n  public static void main(String[] args) {\n    int[] arr={0, 0, 0, 0, 0, 0, 0};\n    \n    \n    countOne(arr);\n  }\n\n  public static void countOne(int[] a)\n  {\n       int l = 0;\n       int h = a.length-1;\n       int mid = -1;\n      \n       while(l<=h)\n       {\n         mid = (l+h)/2;\n         \n         if( (mid == h || a[mid+1] == 0) && a[mid] == 1)\n         {\n             System.out.println(\"Count \" + (mid + 1));\n             return;\n         }\n           \n         if( a[mid] < 1)\n         {\n             h = mid - 1;\n         } else {\n             l = mid + 1;\n         } \n       }\n       System.out.println(\" No one's found \");\n       return;\n  }\n}", "index": 106, "complexity": "2"}
{"back-translation": "public class Search {\n\n    public static boolean find2(int[] array, int begin, int end, int element) {\n        if (begin <= end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return true;\n            else if (medium > begin && array[medium - 1] == element) return true;\n            else if (medium < end && array[medium + 1] == element) return true;\n\n            if (array[medium] > element) return find2(array, 0, medium - 2, element);\n            return find2(array, medium + 2, end, element);\n        }\n        return false;\n    }\n    \n    public static int find(int[] array, int begin, int end, int element) {\n        if (begin < end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return medium;\n            else if (medium > begin && array[medium - 1] == element) return medium - 1;\n            else if (medium < end && array[medium + 1] == element) return medium + 1;\n\n            if (array[medium] > element) return find(array, 0, medium - 2, element);\n            return find(array, medium + 2, end, element);\n\n\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] array = {12,13, 21, 36, 3, 43, 65, 76, 88, 91, 100};\n        System.out.println(find2(array, 0, array.length-1, 13));\n    }\n}", "src": "public class Search {\n\n    public static boolean find2(int[] array, int begin, int end, int element) {\n        if (begin <= end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return true;\n            else if (medium > begin && array[medium - 1] == element) return true;\n            else if (medium < end && array[medium + 1] == element) return true;\n\n            if (array[medium] > element) return find2(array, 0, medium - 2, element);\n            return find2(array, medium + 2, end, element);\n        }\n        return false;\n    }\n    \n    public static int find(int[] array, int begin, int end, int element) {\n        if (begin < end) {\n            int medium = begin + (end - begin) / 2;\n            if (array[medium] == element)\n                return medium;\n            else if (medium > begin && array[medium - 1] == element) return medium - 1;\n            else if (medium < end && array[medium + 1] == element) return medium + 1;\n\n            if (array[medium] > element) return find(array, 0, medium - 2, element);\n            return find(array, medium + 2, end, element);\n\n\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] array = {12,13, 21, 36, 3, 43, 65, 76, 88, 91, 100};\n        System.out.println(find2(array, 0, array.length-1, 13));\n    }\n\n\n}", "index": 107, "complexity": "2"}
{"back-translation": "public class GFG {\n\n    static Stack<Integer> st = new Stack<>();\n\n    static void push_digits(int number) {\n        while (number != 0) {\n            st.push(number % 10);\n            number = number / 10;\n        }\n    }\n\n    static int reverse_number(int number) {\n        push_digits(number);\n        int reverse = 0;\n        int i = 1;\n        while (!st.isEmpty()) {\n            reverse = reverse + (st.peek() * i);\n            st.pop();\n            i = i * 10;\n        }\n        return reverse;\n    }\n\n    public static void main(String[] args) {\n        int number = 39997;\n        System.out.println(reverse_number(number));\n    }\n}", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nStack<Integer> st= \nnew\nStack<>(); \n\n\n\n\nstatic\nvoid\npush_digits(\nint\nnumber) \n\n{ \n\nwhile\n(number != \n0\n) \n\n{ \n\nst.push(number % \n10\n); \n\nnumber = number / \n10\n; \n\n} \n\n} \n\n\n\n\nstatic\nint\nreverse_number(\nint\nnumber) \n\n{ \n\n\n\n\n\npush_digits(number); \n\nint\nreverse = \n0\n; \n\nint\ni = \n1\n; \n\n\n\n\n\n\nwhile\n(!st.isEmpty()) \n\n{ \n\nreverse = reverse + (st.peek() * i); \n\nst.pop(); \n\ni = i * \n10\n; \n\n} \n\n\n\n\nreturn\nreverse; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nnumber = \n39997\n; \n\nSystem.out.println(reverse_number(number)); \n\n} \n}", "index": 108, "complexity": "2"}
{"back-translation": "class BinarySearch { static int countRotations(int[] arr, int low, int high) { if (high < low) return 0; if (high == low) return low; int mid = low + (high - low)/2; if (mid < high && arr[mid+1] < arr[mid]) return (mid + 1); if (mid > low && arr[mid] < arr[mid - 1]) return mid; if (arr[high] > arr[mid]) return countRotations(arr, low, mid - 1); return countRotations(arr, mid + 1, high); } public static void main(String[] args) { int[] arr = {15, 18, 2, 3, 6, 12}; int n = arr.length; System.out.println(countRotations(arr, 0, n-1)); } }", "src": "class\nBinarySearch \n{ \n\n\n\n\n\n\n\nstatic\nint\ncountRotations(\nint\narr[], \nint\nlow, \n\nint\nhigh) \n\n{ \n\n\n\n\n\n\n\nif\n(high < low) \n\nreturn\n0\n; \n\n\n\n\nif\n(high == low) \n\nreturn\nlow; \n\n\n\n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\n(mid + \n1\n); \n\n\n\n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\nmid; \n\n\n\n\n\n\nif\n(arr[high] > arr[mid]) \n\nreturn\ncountRotations(arr, low, mid - \n1\n); \n\n\nreturn\ncountRotations(arr, mid + \n1\n, high); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n15\n, \n18\n, \n2\n, \n3\n, \n6\n, \n12\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(countRotations(arr, \n0\n, n-\n1\n)); \n\n} \n}", "index": 109, "complexity": "2"}
{"back-translation": "ERROR", "src": "class\nMinimum \n{ \n\nstatic\nint\nfindMin(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n\n\n\n\nif\n(high < low) \nreturn\narr[\n0\n]; \n\n\n\n\nif\n(high == low) \nreturn\narr[low]; \n\n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\narr[mid+\n1\n]; \n\n\n\n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n\n\nif\n(arr[high] > arr[mid]) \n\nreturn\nfindMin(arr, low, mid-\n1\n); \n\nreturn\nfindMin(arr, mid+\n1\n, high); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr1[] = {\n5\n, \n6\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr1, \n0\n, n1-\n1\n)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr2, \n0\n, n2-\n1\n)); \n\n\nint\narr3[] = {\n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr3, \n0\n, n3-\n1\n)); \n\n\nint\narr4[] = {\n1\n, \n2\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr4, \n0\n, n4-\n1\n)); \n\n\nint\narr5[] = {\n2\n, \n1\n}; \n\nint\nn5 = arr5.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr5, \n0\n, n5-\n1\n)); \n\n\nint\narr6[] = {\n5\n, \n6\n, \n7\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn6 = arr6.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr6, \n0\n, n6-\n1\n)); \n\n\nint\narr7[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn7 = arr7.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr7, \n0\n, n7-\n1\n)); \n\n\nint\narr8[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n1\n}; \n\nint\nn8 = arr8.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr8, \n0\n, n8-\n1\n)); \n\n\nint\narr9[] = {\n3\n, \n4\n, \n5\n, \n1\n, \n2\n}; \n\nint\nn9 = arr9.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr9, \n0\n, n9-\n1\n)); \n\n} \n}", "index": 110, "complexity": "2"}
{"back-translation": "public class BinarySearch { public int binarySearch(int[] arr, int l, int r, int x) { if (r >= l) { int mid = l + (r - l) / 2; if (arr[mid] == x) return mid; if (arr[mid] > x) return binarySearch(arr, l, mid - 1, x); return binarySearch(arr, mid + 1, r, x); } return -1; } public static void main(String args[]) { BinarySearch ob = new BinarySearch(); int arr[] = { 2, 3, 4, 10, 40}; int n = arr.length; int x = 10; int result = ob.binarySearch(arr, 0, n - 1, x); if (result == -1) System.out.println(\"Element not present\"); else System.out.println(\"Element found at index \" + result); } }", "src": "class\nBinarySearch { \n\n\n\n\n\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r >= l) { \n\nint\nmid = l + (r - l) / \n2\n; \n\n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n\n\n\n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid - \n1\n, x); \n\n\n\n\n\n\nreturn\nbinarySearch(arr, mid + \n1\n, r, x); \n\n} \n\n\n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinarySearch ob = \nnew\nBinarySearch(); \n\nint\narr[] = { \n2\n, \n3\n, \n4\n, \n10\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n10\n; \n\nint\nresult = ob.binarySearch(arr, \n0\n, n - \n1\n, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element not present\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at index \"\n+ result); \n\n} \n}", "index": 111, "complexity": "2"}
{"back-translation": "class BinarySearch { int binarySearch(int arr[], int x) { int l = 0, r = arr.length - 1; while (l <= r) { int m = l + (r - l) / 2; if (arr[m] == x) return m; if (arr[m] < x) l = m + 1; else r = m - 1; } return -1; } public static void main(String args[]) { BinarySearch ob = new BinarySearch(); int arr[] = {2, 3, 4, 10, 40}; int n = arr.length; int x = 10; int result = ob.binarySearch(arr, x); if (result == -1) System.out.println(\"Element not present\"); else System.out.println(\"Element found at \" + \"index \" + result); } }", "src": "class\nBinarySearch { \n\n\n\n\n\nint\nbinarySearch(\nint\narr[], \nint\nx) \n\n{ \n\nint\nl = \n0\n, r = arr.length - \n1\n; \n\nwhile\n(l <= r) { \n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nif\n(arr[m] == x) \n\nreturn\nm; \n\n\n\n\nif\n(arr[m] < x) \n\nl = m + \n1\n; \n\n\n\n\nelse\n\nr = m - \n1\n; \n\n} \n\n\n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinarySearch ob = \nnew\nBinarySearch(); \n\nint\narr[] = { \n2\n, \n3\n, \n4\n, \n10\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n10\n; \n\nint\nresult = ob.binarySearch(arr, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element not present\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at \"\n\n+ \n\"index \"\n+ result); \n\n} \n}", "index": 112, "complexity": "2"}
{"back-translation": "class Binary { public static int f(int x) { return (x * x - 10 * x - 20); } public static int findFirstPositive() { if (f(0) > 0) return 0; int i = 1; while (f(i) <= 0) i = i * 2; return binarySearch(i / 2, i); } public static int binarySearch(int low, int high) { if (high >= low) { int mid = low + (high - low) / 2; if (f(mid) > 0 && (mid == low || f(mid - 1) <= 0)) return mid; if (f(mid) <= 0) return binarySearch((mid + 1), high); else return binarySearch(low, (mid - 1)); } return -1; } public static void main(String[] args) { System.out.print (\"The value n where f() \" + \"becomes positive first is \" + findFirstPositive()); } }", "src": "class\nBinary \n{ \n\npublic\nstatic\nint\nf(\nint\nx) \n\n{ \nreturn\n(x*x - \n10\n*x - \n20\n); } \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nfindFirstPositive() \n\n{ \n\n\n\nif\n(f(\n0\n) > \n0\n) \n\nreturn\n0\n; \n\n\n\n\n\n\nint\ni = \n1\n; \n\nwhile\n(f(i) <= \n0\n) \n\ni = i * \n2\n; \n\n\n\n\nreturn\nbinarySearch(i / \n2\n, i); \n\n} \n\n\n\n\n\n\npublic\nstatic\nint\nbinarySearch(\nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\n\n\n\n\n\nif\n(f(mid) > \n0\n&& (mid == low || f(mid-\n1\n) <= \n0\n)) \n\nreturn\nmid; \n\n\n\n\nif\n(f(mid) <= \n0\n) \n\nreturn\nbinarySearch((mid + \n1\n), high); \n\nelse\n\n\nreturn\nbinarySearch(low, (mid -\n1\n)); \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print (\n\"The value n where f() \"\n+ \n\n\"becomes positive first is \"\n+ \n\nfindFirstPositive()); \n\n} \n}", "index": 113, "complexity": "2"}
{"back-translation": "class Main { static int pivotedBinarySearch(int arr[], int n, int key) { int pivot = findPivot(arr, 0, n-1); if (pivot == -1) return binarySearch(arr, 0, n-1, key); if (arr[pivot] == key) return pivot; if (arr[0] <= key) return binarySearch(arr, 0, pivot-1, key); return binarySearch(arr, pivot+1, n-1, key); } static int findPivot(int arr[], int low, int high) { if (high < low) return -1; if (high == low) return low; int mid = (low + high)/2; if (mid < high && arr[mid] > arr[mid + 1]) return mid; if (mid > low && arr[mid] < arr[mid - 1]) return (mid-1); if (arr[low] >= arr[mid]) return findPivot(arr, low, mid-1); return findPivot(arr, mid + 1, high); } static int binarySearch(int arr[], int low, int high, int key) { if (high < low) return -1; int mid = (low + high)/2; if (key == arr[mid]) return mid; if (key > arr[mid]) return binarySearch(arr, (mid + 1), high, key); return binarySearch(arr, low, (mid -1), key); } public static void main(String args[]) { int arr1[] = {5, 6, 7, 8, 9, 10, 1, 2, 3}; int n = arr1.length; int key = 3; System.out.println(", "src": "class\nMain \n{ \n\n\n\n\nstatic\nint\npivotedBinarySearch(\nint\narr[], \nint\nn, \nint\nkey) \n\n{ \n\nint\npivot = findPivot(arr, \n0\n, n-\n1\n); \n\n\n\n\n\n\nif\n(pivot == -\n1\n) \n\nreturn\nbinarySearch(arr, \n0\n, n-\n1\n, key); \n\n\n\n\n\n\n\n\nif\n(arr[pivot] == key) \n\nreturn\npivot; \n\nif\n(arr[\n0\n] <= key) \n\nreturn\nbinarySearch(arr, \n0\n, pivot-\n1\n, key); \n\nreturn\nbinarySearch(arr, pivot+\n1\n, n-\n1\n, key); \n\n} \n\n\n\n\nstatic\nint\nfindPivot(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n\n\nif\n(high < low) \n\nreturn\n-\n1\n; \n\nif\n(high == low) \n\nreturn\nlow; \n\n\n\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(mid < high && arr[mid] > arr[mid + \n1\n]) \n\nreturn\nmid; \n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\n(mid-\n1\n); \n\nif\n(arr[low] >= arr[mid]) \n\nreturn\nfindPivot(arr, low, mid-\n1\n); \n\nreturn\nfindPivot(arr, mid + \n1\n, high); \n\n} \n\n\n\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nkey) \n\n{ \n\nif\n(high < low) \n\nreturn\n-\n1\n; \n\n\n\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(key == arr[mid]) \n\nreturn\nmid; \n\nif\n(key > arr[mid]) \n\nreturn\nbinarySearch(arr, (mid + \n1\n), high, key); \n\nreturn\nbinarySearch(arr, low, (mid -\n1\n), key); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nint\narr1[] = {\n5\n, \n6\n, \n7\n, \n8\n, \n9\n, \n10\n, \n1\n, \n2\n, \n3\n}; \n\nint\nn = arr1.length; \n\nint\nkey = \n3\n; \n\nSystem.out.println(\n\"Index of the element is : \"\n\n+ pivotedBinarySearch(arr1, n, key)); \n\n} \n}", "index": 114, "complexity": "2"}
{"back-translation": "class GfG { static int getMedian(int[] ar1, int[] ar2, int n) { if (n <= 0) return -1; if (n == 1) return (ar1[0] + ar2[0]) / 2; if (n == 2) return (Math.max(ar1[0], ar2[0]) + Math.min(ar1[1], ar2[1])) / 2; int m1 = median(ar1, n); int m2 = median(ar2, n); if (m1 == m2) return m1; if (m1 < m2) { if (n % 2 == 0) return getMedian(searchArray(ar1, n / 2 - 1), ar2, n - n / 2 + 1); return getMedian(searchArray(ar1, n / 2), ar2, n - n / 2); } if (n % 2 == 0) return getMedian(searchArray(ar2, n / 2 - 1), ar1, n - n / 2 + 1); return getMedian(searchArray(ar2, n / 2), ar1, n - n / 2); } static int median(int[] arr, int n) { if (n % 2 == 0) return (arr[n / 2] + arr[n / 2 - 1]) / 2; else return arr[n / 2]; } public static void main(String[] args) { int ar1[] = {1, 2, 3, 6}; int ar2[] = {4, 6, 8, 10}; int n1 = ar1.length; int n2 = ar2.length; if (n1 == n2) System.out.println(", " + getMedian(ar1, ar2, n1)); else System.out.println(": " + ", " + ": "); } }", "src": "class\nGfG { \n\n\nstatic\nint\ngetMedian(\nint\nar1[], \nint\nar2[], \nint\nn) \n{ \n\n\n\nif\n(n <= \n0\n) \n\nreturn\n-\n1\n; \n\nif\n(n == \n1\n) \n\nreturn\n(ar1[\n0\n] + ar2[\n0\n]) / \n2\n; \n\nif\n(n == \n2\n) \n\nreturn\n(Math.max(ar1[\n0\n], ar2[\n0\n]) + Math.min(ar1[\n1\n], ar2[\n1\n])) / \n2\n; \n\n\n\n\nint\nm1 = median(ar1, n); \n\n\n\n\nint\nm2 = median(ar2, n); \n\n\n\n\nif\n(m1 == m2) \n\nreturn\nm1; \n\n\n\n\nif\n(m1 < m2) \n\n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar1 + n / \n2\n- \n1\n, ar2, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar1 + n / \n2\n, ar2, n - n / \n2\n); \n\n} \n\n\n\n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar2 + n / \n2\n- \n1\n, ar1, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar2 + n / \n2\n, ar1, n - n / \n2\n); \n} \n\n\nstatic\nint\nmedian(\nint\narr[], \nint\nn) \n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\n(arr[n / \n2\n] + arr[n / \n2\n- \n1\n]) / \n2\n; \n\nelse\n\nreturn\narr[n / \n2\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nar1[] = {\n1\n, \n2\n, \n3\n, \n6\n}; \n\nint\nar2[] = {\n4\n, \n6\n, \n8\n, \n10\n}; \n\nint\nn1 = ar1.length; \n\nint\nn2 = ar2.length; \n\nif\n(n1 == n2) \n\nSystem.out.println(\n\"Median is \"\n+ getMedian(ar1, ar2, n1)); \n\nelse\n\nSystem.out.println(\n\"Doesn't work for arrays \"\n+ \n\"of unequal size\"\n); \n} \n}", "index": 115, "complexity": "2"}
{"back-translation": "class Main { static int ceilSearch(int arr[], int low, int high, int x) { int mid; if (x <= arr[low]) return low; if (x > arr[high]) return -1; mid = (low + high) / 2; if (arr[mid] == x) return mid; else if (arr[mid] < x) { if (mid + 1 <= high && x <= arr[mid+1]) return mid + 1; else return ceilSearch(arr, mid+1, high, x); } else { if (mid - 1 >= low && x > arr[mid-1]) return mid; else return ceilSearch(arr, low, mid - 1, x); } } public static void main(String[] args) { int arr[] = { 1, 2, 8, 10, 10, 12, 19 }; int n = arr.length; int x = 8; int index = ceilSearch(arr, 0, n-1, x); if (index == -1) System.out.println(\"Ceiling of \" + x + \" doesn't exist in array\"); else System.out.println(\"ceiling of \" + x + \" is \" + arr[index]); } }", "src": "class\nMain \n{ \n\n\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\nmid; \n\n\n\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n\n\nif\n(x > arr[high]) \n\nreturn\n-\n1\n; \n\n\n\n\nmid = (low + high)/\n2\n; \n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n\n\nelse\nif\n(arr[mid] < x) \n\n{ \n\nif\n(mid + \n1\n<= high && x <= arr[mid+\n1\n]) \n\nreturn\nmid + \n1\n; \n\nelse\n\nreturn\nceilSearch(arr, mid+\n1\n, high, x); \n\n} \n\n\n\n\nelse\n\n{ \n\nif\n(mid - \n1\n>= low && x > arr[mid-\n1\n]) \n\nreturn\nmid; \n\nelse\n\nreturn\nceilSearch(arr, low, mid - \n1\n, x); \n\n} \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n8\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n}", "index": 116, "complexity": "2"}
{"back-translation": "class GFG { static int binarySearch(int arr[], int l, int r, int x) { if (r < l) return -1; int mid = l + (r - l) / 2; if (arr[mid] == x) return mid; if (arr[mid] > x) return binarySearch(arr, l, mid - 1, x); return binarySearch(arr, mid + 1, r, x); } static int countOccurrences(int arr[], int n, int x) { int ind = binarySearch(arr, 0, n - 1, x); if (ind == -1) return 0; int count = 1; int left = ind - 1; while (left >= 0 && arr[left] == x) { count++; left--; } int right = ind + 1; while (right < n && arr[right] == x) { count++; right++; } return count; } public static void main(String[] args) { int arr[] = { 1, 2, 2, 2, 2, 3, 4, 7, 8, 8 }; int n = arr.length; int x = 2; System.out.print(countOccurrences(arr, n, x)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n\n{ \n\nif\n(r < l) \n\nreturn\n-\n1\n; \n\n\nint\nmid = l + (r - l) / \n2\n; \n\n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n\n\n\n\n\n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, \n\nmid - \n1\n, x); \n\n\n\n\n\n\n\n\nreturn\nbinarySearch(arr, mid + \n1\n, r, x); \n\n} \n\n\n\n\n\n\nstatic\nint\ncountOccurrences(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\nint\nind = binarySearch(arr, \n0\n, \n\nn - \n1\n, x); \n\n\n\n\nif\n(ind == -\n1\n) \n\nreturn\n0\n; \n\n\n\n\nint\ncount = \n1\n; \n\nint\nleft = ind - \n1\n; \n\nwhile\n(left >= \n0\n&& \n\narr[left] == x) \n\n{ \n\ncount++; \n\nleft--; \n\n} \n\n\n\n\n\n\nint\nright = ind + \n1\n; \n\nwhile\n(right < n && \n\narr[right] == x) \n\n{ \n\ncount++; \n\nright++; \n\n} \n\n\nreturn\ncount; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n\n3\n, \n4\n, \n7\n, \n8\n, \n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.print(countOccurrences(arr, n, x)); \n\n} \n}", "index": 117, "complexity": "2"}
{"back-translation": "class Main { static int binarySearch(int arr[], int low, int high) { if (high >= low) { int mid = (low + high) / 2; if (mid == arr[mid]) return mid; if (mid > arr[mid]) return binarySearch(arr, (mid + 1), high); else return binarySearch(arr, low, (mid - 1)); } return -1; } public static void main(String args[]) { int arr[] = {-10, -1, 0, 3, 10, 11, 30, 50, 100}; int n = arr.length; System.out.println(\"Fixed Point is \" + binarySearch(arr, 0, n-1)); } }", "src": "class\nMain \n{ \n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = (low + high)/\n2\n; \n\nif\n(mid == arr[mid]) \n\nreturn\nmid; \n\nif\n(mid > arr[mid]) \n\nreturn\nbinarySearch(arr, (mid + \n1\n), high); \n\nelse\n\nreturn\nbinarySearch(arr, low, (mid -\n1\n)); \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {-\n10\n, -\n1\n, \n0\n, \n3\n, \n10\n, \n11\n, \n30\n, \n50\n, \n100\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Fixed Point is \"\n\n+ binarySearch(arr,\n0\n, n-\n1\n)); \n\n} \n}", "index": 118, "complexity": "2"}
{"back-translation": "class Main { static int findMaximum(int arr[], int low, int high) { if (low == high) return arr[low]; if ((high == low + 1) && arr[low] >= arr[high]) return arr[low]; if ((high == low + 1) && arr[low] < arr[high]) return arr[high]; int mid = (low + high) / 2; if (arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) return arr[mid]; if (arr[mid] > arr[mid + 1] && arr[mid] < arr[mid - 1]) return findMaximum(arr, low, mid - 1); else return findMaximum(arr, mid + 1, high); } public static void main(String[] args) { int arr[] = { 1, 3, 50, 10, 9, 7, 6 }; int n = arr.length; System.out.println(\"The maximum element is \" + findMaximum(arr, 0, n - 1)); } }", "src": "class\nMain \n{ \n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n\n\n\nif\n(low == high) \n\nreturn\narr[low]; \n\n\n\n\nif\n((high == low + \n1\n) && arr[low] >= arr[high]) \n\nreturn\narr[low]; \n\n\n\n\nif\n((high == low + \n1\n) && arr[low] < arr[high]) \n\nreturn\narr[high]; \n\n\n\n\nint\nmid = (low + high)/\n2\n; \n\n\n\n\nif\n( arr[mid] > arr[mid + \n1\n] && arr[mid] > arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n\n\nif\n(arr[mid] > arr[mid + \n1\n] && arr[mid] < arr[mid - \n1\n]) \n\nreturn\nfindMaximum(arr, low, mid-\n1\n); \n\nelse\n\nreturn\nfindMaximum(arr, mid + \n1\n, high); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n3\n, \n50\n, \n10\n, \n9\n, \n7\n, \n6\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"The maximum element is \"\n+ \n\nfindMaximum(arr, \n0\n, n-\n1\n)); \n\n} \n}", "index": 119, "complexity": "2"}
{"back-translation": "class PeakElement { static int findPeakUtil(int arr[], int low, int high, int n) { int mid = low + (high - low)/2; if ((mid == 0 || arr[mid-1] <= arr[mid]) && (mid == n-1 || arr[mid+1] <= arr[mid])) return mid; else if (mid > 0 && arr[mid-1] > arr[mid]) return findPeakUtil(arr, low, (mid - 1), n); else return findPeakUtil(arr, (mid + 1), high, n); } static int findPeak(int arr[], int n) { return findPeakUtil(arr, 0, n-1, n); } public static void main (String[] args) { int arr[] = {1, 3, 20, 4, 1, 0}; int n = arr.length; System.out.println(\"Index of a peak point is \"+ findPeak(arr, n)); } }", "src": "class\nPeakElement \n{ \n\n\n\n\n\nstatic\nint\nfindPeakUtil(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nn) \n\n{ \n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\nif\n((mid == \n0\n|| arr[mid-\n1\n] <= arr[mid]) && (mid == n-\n1\n|| \n\narr[mid+\n1\n] <= arr[mid])) \n\nreturn\nmid; \n\n\n\n\n\n\nelse\nif\n(mid > \n0\n&& arr[mid-\n1\n] > arr[mid]) \n\nreturn\nfindPeakUtil(arr, low, (mid -\n1\n), n); \n\n\n\n\n\n\n\n\nelse\nreturn\nfindPeakUtil(arr, (mid + \n1\n), high, n); \n\n} \n\n\n\n\nstatic\nint\nfindPeak(\nint\narr[], \nint\nn) \n\n{ \n\nreturn\nfindPeakUtil(arr, \n0\n, n-\n1\n, n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n3\n, \n20\n, \n4\n, \n1\n, \n0\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Index of a peak point is \"\n+ \n\nfindPeak(arr, n)); \n\n} \n}", "index": 120, "complexity": "2"}
{"back-translation": "class Minimum { static int findMin(int arr[], int low, int high) { if (high < low) return arr[0]; if (high == low) return arr[low]; int mid = low + (high - low)/2; if (mid < high && arr[mid+1] < arr[mid]) return arr[mid+1]; if (mid > low && arr[mid] < arr[mid - 1]) return arr[mid]; if (arr[high] > arr[mid]) return findMin(arr, low, mid-1); return findMin(arr, mid+1, high); } public static void main (String[] args) { int arr1[] = {5, 6, 1, 2, 3, 4}; int n1 = arr1.length; System.out.println(\"The minimum element is \"+ findMin(arr1, 0, n1-1)); int arr2[] = {1, 2, 3, 4}; int n2 = arr2.length; System.out.println(\"The minimum element is \"+ findMin(arr2, 0, n2-1)); int arr3[] = {1}; int n3 = arr3.length; System.out.println(\"The minimum element is \"+ findMin(arr3, 0, n3-1)); int arr4[] = {1, 2}; int n4 = arr4.length; System.out.println(\"The minimum element is \"+ findMin(arr4, 0, n4-1)); int arr5[] = {2, 1}; int n5 = arr5.length; System.out.println(\"The minimum element is \"+ findMin(arr5, 0, n5-1)); int arr6[] = {5, 6, 7, 1, 2, 3, 4}; int n6 = arr6.length; System.out.println(\"The minimum element is \"+ findMin(arr6, 0, n6-1)); int arr7[] = {1, 2, 3, 4, 5, 6, 7}; int n7 = arr7.length; System.out.println(\"The minimum element is \"+ findMin(arr7, 0, n7-1)); int arr8[] = {2, 3, 4, 5, 6, 7, 8, 1}; int n8 = arr8.length; System.out.println(\"The minimum element is \"+ findMin(arr8, 0, n8-1)); int arr9[] = {3, 4, 5, 1, 2}; int n9 = arr9.length; System.out.println(\"The minimum element is \"+ findMin(arr9, 0, n9-1)); } }", "src": "class\nMinimum \n{ \n\nstatic\nint\nfindMin(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\n\n\n\n\nif\n(high < low) \nreturn\narr[\n0\n]; \n\n\n\n\nif\n(high == low) \nreturn\narr[low]; \n\n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\nif\n(mid < high && arr[mid+\n1\n] < arr[mid]) \n\nreturn\narr[mid+\n1\n]; \n\n\n\n\nif\n(mid > low && arr[mid] < arr[mid - \n1\n]) \n\nreturn\narr[mid]; \n\n\n\n\nif\n(arr[high] > arr[mid]) \n\nreturn\nfindMin(arr, low, mid-\n1\n); \n\nreturn\nfindMin(arr, mid+\n1\n, high); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr1[] = {\n5\n, \n6\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr1, \n0\n, n1-\n1\n)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr2, \n0\n, n2-\n1\n)); \n\n\nint\narr3[] = {\n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr3, \n0\n, n3-\n1\n)); \n\n\nint\narr4[] = {\n1\n, \n2\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr4, \n0\n, n4-\n1\n)); \n\n\nint\narr5[] = {\n2\n, \n1\n}; \n\nint\nn5 = arr5.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr5, \n0\n, n5-\n1\n)); \n\n\nint\narr6[] = {\n5\n, \n6\n, \n7\n, \n1\n, \n2\n, \n3\n, \n4\n}; \n\nint\nn6 = arr6.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr6, \n0\n, n6-\n1\n)); \n\n\nint\narr7[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn7 = arr7.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr7, \n0\n, n7-\n1\n)); \n\n\nint\narr8[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n1\n}; \n\nint\nn8 = arr8.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr8, \n0\n, n8-\n1\n)); \n\n\nint\narr9[] = {\n3\n, \n4\n, \n5\n, \n1\n, \n2\n}; \n\nint\nn9 = arr9.length; \n\nSystem.out.println(\n\"The minimum element is \"\n+ findMin(arr9, \n0\n, n9-\n1\n)); \n\n} \n}", "index": 121, "complexity": "2"}
{"back-translation": "class GFG { public static void main(String args[]) { GFG ob = new GFG(); int arr[] = {3, 2, 10, 4, 40}; int n = arr.length; int x = 4; int result = ob.binarySearch(arr, 0, n - 1, x); if(result == -1) System.out.println(\"Element is not present in array\"); else System.out.println(\"Element is present at index \" + result); } int binarySearch(int arr[], int l, int r, int x) { if (r >= l) { int mid = l + (r - l) / 2; if (arr[mid] == x) return mid; if (mid > l && arr[mid - 1] == x) return (mid - 1); if (mid < r && arr[mid + 1] == x) return (mid + 1); if (arr[mid] > x) return binarySearch(arr, l, mid - 2, x); return binarySearch(arr, mid + 2, r, x); } return -1; } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r >= l) \n\n{ \n\nint\nmid = l + (r - l) / \n2\n; \n\n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\nif\n(mid > l && arr[mid - \n1\n] == x) \n\nreturn\n(mid - \n1\n); \n\nif\n(mid < r && arr[mid + \n1\n] == x) \n\nreturn\n(mid + \n1\n); \n\n\n\n\n\n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid - \n2\n, x); \n\n\n\n\n\n\nreturn\nbinarySearch(arr, mid + \n2\n, r, x); \n\n} \n\n\n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nGFG ob = \nnew\nGFG(); \n\nint\narr[] = {\n3\n, \n2\n, \n10\n, \n4\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n4\n; \n\nint\nresult = ob.binarySearch(arr, \n0\n, n - \n1\n, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element is not present in array\"\n); \n\nelse\n\nSystem.out.println(\n\"Element is present at index \"\n+ \n\nresult); \n\n} \n}", "index": 122, "complexity": "2"}
{"back-translation": "class CountOnes {\n    int countOnes(int arr[], int low, int high) {\n        if (high >= low) {\n            int mid = low + (high - low) / 2;\n            if ((mid == high || arr[mid + 1] == 0) && (arr[mid] == 1))\n                return mid + 1;\n            if (arr[mid] == 1)\n                return countOnes(arr, (mid + 1), high);\n            return countOnes(arr, low, (mid - 1));\n        }\n        return 0;\n    }\n\n    public static void main(String args[]) {\n        CountOnes ob = new CountOnes();\n        int arr[] = {1, 1, 1, 1, 0, 0, 0};\n        int n = arr.length;\n        System.out.println(\"Count of 1's in given array is \" + ob.countOnes(arr, 0, n - 1));\n    }\n}", "src": "class\nCountOnes \n{ \n\n\n\nint\ncountOnes(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\nif\n( (mid == high || arr[mid+\n1\n] == \n0\n) && \n\n(arr[mid] == \n1\n)) \n\nreturn\nmid+\n1\n; \n\n\n\n\nif\n(arr[mid] == \n1\n) \n\nreturn\ncountOnes(arr, (mid + \n1\n), high); \n\n\n\n\nreturn\ncountOnes(arr, low, (mid -\n1\n)); \n\n} \n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nCountOnes ob = \nnew\nCountOnes(); \n\nint\narr[] = {\n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n0\n, \n0\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Count of 1's in given array is \"\n+ \n\nob.countOnes(arr, \n0\n, n-\n1\n) ); \n\n} \n}", "index": 123, "complexity": "2"}
{"back-translation": "class SmallestMissing { int findFirstMissing(int[] array, int start, int end) { if (start > end) return end + 1; if (start != array[start]) return start; int mid = (start + end) / 2; if (array[mid] == mid) return findFirstMissing(array, mid+1, end); return findFirstMissing(array, start, mid); } public static void main(String[] args) { SmallestMissing small = new SmallestMissing(); int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 10}; int n = arr.length; System.out.println(\"First Missing element is : \" + small.findFirstMissing(arr, 0, n - 1)); } }", "src": "class\nSmallestMissing \n{ \n\nint\nfindFirstMissing(\nint\narray[], \nint\nstart, \nint\nend) \n\n{ \n\nif\n(start > end) \n\nreturn\nend + \n1\n; \n\n\nif\n(start != array[start]) \n\nreturn\nstart; \n\n\nint\nmid = (start + end) / \n2\n; \n\n\n\n\nif\n(array[mid] == mid) \n\nreturn\nfindFirstMissing(array, mid+\n1\n, end); \n\n\nreturn\nfindFirstMissing(array, start, mid); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSmallestMissing small = \nnew\nSmallestMissing(); \n\nint\narr[] = {\n0\n, \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"First Missing element is : \"\n\n+ small.findFirstMissing(arr, \n0\n, n - \n1\n)); \n\n} \n}", "index": 124, "complexity": "2"}
{"back-translation": "class Main { static int count(int arr[], int x, int n) { int i; int j; i = first(arr, 0 , n-1, x, n); if(i == -1) return i; j = last(arr, i, n-1, x, n); return j-i+1; } static int first(int arr[], int low, int high, int x, int n) { if(high >= low) { int mid = (low + high)/2; if((mid == 0 || x > arr[mid-1]) && arr[mid] == x) return mid; else if(x > arr[mid]) return first(arr, (mid + 1), high, x, n); else return first(arr, low, (mid -1), x, n); } return -1; } static int last(int arr[], int low, int high, int x, int n) { if(high >= low) { int mid = (low + high)/2; if((mid == n-1 || x < arr[mid+1]) && arr[mid] == x) return mid; else if(x < arr[mid]) return last(arr, low, (mid -1), x, n); else return last(arr, (mid + 1), high, x, n); } return -1; } public static void main(String args[]) { int arr[] = {1, 2, 2, 3, 3, 3, 3}; int x = 3; int n = arr.length; int c = count(arr, x, n); System.out.println(x+\" occurs \"+c+\" times\"); } }", "src": "class\nMain \n{ \n\n\n\nstatic\nint\ncount(\nint\narr[], \nint\nx, \nint\nn) \n\n{ \n\n\n\nint\ni; \n\n\n\n\nint\nj; \n\n\n\n\ni = first(arr, \n0\n, n-\n1\n, x, n); \n\n\n\n\nif\n(i == -\n1\n) \n\nreturn\ni; \n\n\n\n\nj = last(arr, i, n-\n1\n, x, n); \n\n\n\n\nreturn\nj-i+\n1\n; \n\n} \n\n\n\n\nstatic\nint\nfirst(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx, \nint\nn) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = (low + high)/\n2\n; \n\nif\n( ( mid == \n0\n|| x > arr[mid-\n1\n]) && arr[mid] == x) \n\nreturn\nmid; \n\nelse\nif\n(x > arr[mid]) \n\nreturn\nfirst(arr, (mid + \n1\n), high, x, n); \n\nelse\n\nreturn\nfirst(arr, low, (mid -\n1\n), x, n); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n\n\nstatic\nint\nlast(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx, \nint\nn) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = (low + high)/\n2\n; \n\nif\n( ( mid == n-\n1\n|| x < arr[mid+\n1\n]) && arr[mid] == x ) \n\nreturn\nmid; \n\nelse\nif\n(x < arr[mid]) \n\nreturn\nlast(arr, low, (mid -\n1\n), x, n); \n\nelse\n\nreturn\nlast(arr, (mid + \n1\n), high, x, n); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n3\n, \n3\n, \n3\n, \n3\n}; \n\n\n\n\nint\nx = \n3\n; \n\nint\nn = arr.length; \n\nint\nc = count(arr, x, n); \n\nSystem.out.println(x+\n\" occurs \"\n+c+\n\" times\"\n); \n\n} \n}", "index": 125, "complexity": "2"}
{"back-translation": "public class A1180 {\n\n    public static void main(String[] args) throws FileNotFoundException \n    { \n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint layers = n-1;\n\t\tint counter =0;\n\t\tint i =1 ;\n\t\twhile (i < layers + 1 ) {\n\t\t\tcounter += i ;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tSystem.out.println(1 + counter*4);\n    } \n}", "src": "public class A1180 {\n\n    public static void main(String[] args) throws FileNotFoundException \n    { \n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint layers = n-1;\n\t\tint counter =0;\n\t\tfor(int i =1 ;i < layers + 1 ; i ++) {\n\t\t\tcounter += i ;\n\t\t}\n\t\t\n\t\tSystem.out.println(1 + counter*4);\n    } \n}", "index": 126, "complexity": "1"}
{"back-translation": "ERROR", "src": "public class round569d2b {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tif (n % 2 == 0) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint max = Integer.MIN_VALUE;\n\t\t\tint maxIndex = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint elem = arr[i];\n\t\t\t\tif (elem < 0) {\n\t\t\t\t\telem = -1*elem-1;\n\t\t\t\t}\n\t\t\t\tif (elem > max) {\n\t\t\t\t\tmax = elem;\n\t\t\t\t\tmaxIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i == maxIndex) {\n\t\t\t\t\tif (arr[i] < 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < n ;i++) {\n\t\t\tsb.append(arr[i] + \" \");\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 127, "complexity": "1"}
{"back-translation": "public class Main {\n    \n    static InputReader in = new InputReader(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n\n    static long oo = 1000000000000L;\n    static int[][] memo;\n    \n    public static void main(String[] args) throws IOException {\n \n        int n = in.nextInt();\n        int[] a = in.nextIntArray(n);\n        if(n % 2 == 0) {\n            for(int i = 0; i < n; ++i) {\n                if(a[i] >= 0)\n                    a[i] = -a[i] - 1;\n            }\n        }\n        else {\n            int maxi = -1, max = -1;\n            for(int i = 0; i < n; ++i) {\n                int x = a[i] >= 0 ? -a[i] - 1 : a[i];\n                x = -x;\n                if(x > max) {\n                    max = x; maxi = i;\n                }\n            }\n            if(max == 1) {\n                a[0] = 0;\n            }\n            else {\n                for(int i = 0; i < n; ++i) {\n                    if(i == maxi) {\n                        if(a[i] < 0)\n                            a[i] = -a[i] - 1;\n                    }\n                    else {\n                        if(a[i] >= 0)\n                            a[i] = -a[i] - 1;\n                    }\n                }\n            }\n        }\n        for(int x : a)\n            System.out.print(x + \" \");\n        \n        out.close();\n    }\n    \n    \n    \n    static long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n    \n    static boolean nextPermutation(int[] a) {\n        for(int i = a.length - 2; i >= 0; --i) {\n            if(a[i] < a[i+1]) {\n                for(int j = a.length - 1; ; --j) {\n                    if(a[i] < a[j]) {\n                        int t = a[i];\n                        a[i] = a[j];\n                        a[j] = t;\n                        for(i++, j = a.length - 1; i < j; ++i, --j) {\n                            t = a[i];\n                            a[i] = a[j];\n                            a[j] = t;\n                        }\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \n    static void shuffle(int[] a) {\n        Random r = new Random();\n        for(int i = a.length - 1; i > 0; --i) {\n            int si = r.nextInt(i);\n            int t = a[si];\n            a[si] = a[i];\n            a[i] = t;\n        }\n    }\n    \n    static void shuffle(long[] a) {\n        Random r = new Random();\n        for(int i = a.length - 1; i > 0; --i) {\n            int si = r.nextInt(i);\n            long t = a[si];\n            a[si] = a[i];\n            a[i] = t;\n        }\n    }\n    \n    static int lower_bound(int[] a, int n, int k) {\n        int s = 0;\n        int e = n;\n        int m;\n        while (e - s > 0) {\n            m = (s + e) / 2;\n            if (a[m] < k)\n                s = m + 1;\n            else\n                e = m;\n        }\n        return e;\n    }\n    static int lower_bound(long[] a, int n, long k) {\n        int s = 0;\n        int e = n;\n        int m;\n        while (e - s > 0) {\n            m = (s + e) / 2;\n            if (a[m] < k)\n                s = m + 1;\n            else\n                e = m;\n        }\n        return e;\n    }\n    \n    static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    \n    static class Pair implements Comparable<Pair> {\n        int first, second;\n \n        public Pair(int first, int second) {\n            super();\n            this.first = first;\n            this.second = second;\n        }\n \n        @Override\n        public int compareTo(Pair o) {\n            return this.first != o.first ? this.first - o.first : this.second - o.second;\n        }\n \n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + first;\n            result = prime * result + second;\n            return result;\n        }\n \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            Pair other = (Pair) obj;\n            if (first != other.first)\n                return false;\n            if (second != other.second)\n                return false;\n            return true;\n        }\n    }\n    \n    \n}", "src": "public class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint n = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tif(n % 2 == 0) {\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint maxi = -1, max = -1;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tint x = a[i] >= 0 ? -a[i] - 1 : a[i];\n\t\t\t\tx = -x;\n\t\t\t\tif(x > max) {\n\t\t\t\t\tmax = x; maxi = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max == 1) {\n\t\t\t\ta[0] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\t\tif(i == maxi) {\n\t\t\t\t\t\tif(a[i] < 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int x : a)\n\t\t\tSystem.out.print(x + \" \");\n\t\t\n\t\tout.close();\n\t}\n\t\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "index": 128, "complexity": "1"}
{"back-translation": "public class MyClass {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        int k = 0;\n        int m = 0;\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n            if (a[i] >= 0) {\n                a[i] = -a[i] - 1;\n            }\n            if (a[i] < m) {\n                m = a[i];\n                k = i;\n            }\n        }\n        if (n % 2 == 1) {\n            a[k] = -a[k] - 1;\n        }\n        for (int i = 0; i < n; i++) {\n            System.out.print(a[i] + \" \");\n        }\n    }\n}", "src": "public class MyClass {\n    public static void main(String args[]) {\n        Scanner sc= new Scanner(System.in);\n        int n=sc.nextInt();\n        int [] a= new int[n];\n        int k=0;\n        int m=0;\n        for (int i=0;i<n;i++){\n            a[i]=sc.nextInt();\n            if (a[i]>=0){\n                a[i]=-a[i]-1;\n            }\n            if (a[i]<m){\n                m=a[i];\n                k=i;\n            }\n        }\n        if (n%2==1){\n            a[k]=-a[k]-1;\n        }\n        for (int i=0;i<n;i++){\n            System.out.print(a[i]+\" \");\n        }\n    }\n}", "index": 129, "complexity": "1"}
{"back-translation": "ERROR", "src": "public class round569d2c {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tArrayDeque<Integer> deq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdeq.addLast(in.nextInt());\n\t\t}\n\t\tlong[] queries = new long[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tqueries[i] = in.nextLong();\n\t\t}\n\t\tint[] origAs = new int[n-1];\n\t\tint[] origBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\torigAs[i] = a;\n\t\t\torigBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tint[] repeatAs = new int[n-1];\n\t\tint[] repeatBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\trepeatAs[i] = a;\n\t\t\trepeatBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tlong query = queries[i] - 1;\n\t\t\tif (query < n-1) {\n\t\t\t\tsb.append(origAs[(int)query] + \" \" + origBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquery %= (n-1);\n\t\t\t\tsb.append(repeatAs[(int)query] + \" \" + repeatBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 130, "complexity": "1"}
{"back-translation": "public class Kello {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int n, q, m, max, inp, k, i;\n        long in_q;\n        n = sc.nextInt();\n        q = sc.nextInt();\n        int a[] = new int[n - 1];\n        int b[] = new int[n - 1];\n        int c[] = new int[n - 1];\n        max = sc.nextInt();\n        for (i = 0; i < n - 1; i++) {\n            inp = sc.nextInt();\n            a[i] = max;\n            b[i] = inp;\n            if (inp > max) {\n                c[i] = max;\n                max = inp;\n            } else\n                c[i] = inp;\n        }\n        for (i = 0; i < q; i++) {\n            in_q = sc.nextLong();\n            if (in_q < n)\n                System.out.println(a[(int) in_q - 1] + \" \" + b[(int) in_q - 1]);\n            else {\n                k = (int) (in_q % (n - 1)) - 1;\n                if (k == -1)\n                    k = n - 2;\n                System.out.println(max + \" \" + c[k]);\n            }\n        }\n    }\n    public static void display(int a[], int b[]) {\n        int i;\n        for (i = 0; i < a.length; i++)\n            System.out.println(a[i] + \" \" + b[i]);\n    }\n}", "src": "public class Kello\n{\n    public static void  main(String args[])\n    {\n        Scanner sc =new Scanner(System.in);\n        int n,q,m,max,inp,k,i;\n        long in_q;\n        n=sc.nextInt();\n        q=sc.nextInt();\n        int a[]=new int[n-1];\n        int b[]=new int[n-1];\n        int c[]=new int[n-1];\n        max=sc.nextInt();\n        for(i=0;i<n-1;i++)\n        {\n            inp=sc.nextInt();\n            a[i]=max;\n            b[i]=inp;\n            if(inp>max)\n            {\n                c[i]=max;\n             max=inp;\n        }\n        else\n        c[i]=inp;\n    }\n   \n        for(i=0;i<q;i++)\n        {\n            in_q=sc.nextLong();\n            if(in_q<n)\n            System.out.println(a[(int)in_q-1]+\" \"+b[(int)in_q-1]);\n          else   {\n          k=(int)(in_q %(n-1))-1;\n          if(k==-1)\n          k=n-2;\n          System.out.println(max+\" \"+c[k]);\n            }\n        }\n    }\n    public static void display(int a[],int b[])\n    {\n        int i;\n        for(i=0;i<a.length;i++)\n        System.out.println(a[i]+\" \"+b[i]);\n}\n}", "index": 131, "complexity": "1"}
{"back-translation": "class Main { static void printUnsorted(int arr[], int n) { int s = 0, e = n-1, i, max, min; for (s = 0; s < n-1; s++) { if (arr[s] > arr[s+1]) break; } if (s == n-1) { System.out.println(\"The complete array is sorted\"); return; } for (e = n - 1; e > 0; e--) { if (arr[e] < arr[e-1]) break; } max = arr[s]; min = arr[s]; for (i = s + 1; i <= e; i++) { if (arr[i] > max) max = arr[i]; if (arr[i] < min) min = arr[i]; } for (i = 0; i < s; i++) { if (arr[i] > min) { s = i; break; } } for (i = n - 1; i >= e+1; i--) { if (arr[i] < max) { e = i; break; } } System.out.println(\" The unsorted subarray which\" + \" makes the given array sorted lies\" + \" between the indices \" + s + \" and \" + e); return; } public static void main(String args[]) { int arr[] = {10, 12, 20, 30, 25, 40, 32, 31, 35, 50, 60}; int arr_size = arr.length; printUnsorted(arr, arr_size); } }", "src": "class\nMain \n{ \n\nstatic\nvoid\nprintUnsorted(\nint\narr[], \nint\nn) \n\n{ \n\nint\ns = \n0\n, e = n-\n1\n, i, max, min; \n\n\n\n\nfor\n(s = \n0\n; s < n-\n1\n; s++) \n\n{ \n\nif\n(arr[s] > arr[s+\n1\n]) \n\nbreak\n; \n\n} \n\nif\n(s == n-\n1\n) \n\n{ \n\nSystem.out.println(\n\"The complete array is sorted\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nfor\n(e = n - \n1\n; e > \n0\n; e--) \n\n{ \n\nif\n(arr[e] < arr[e-\n1\n]) \n\nbreak\n; \n\n} \n\n\n\n\nmax = arr[s]; min = arr[s]; \n\nfor\n(i = s + \n1\n; i <= e; i++) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\nif\n(arr[i] < min) \n\nmin = arr[i]; \n\n} \n\n\n\n\nfor\n( i = \n0\n; i < s; i++) \n\n{ \n\nif\n(arr[i] > min) \n\n{ \n\ns = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nfor\n( i = n -\n1\n; i >= e+\n1\n; i--) \n\n{ \n\nif\n(arr[i] < max) \n\n{ \n\ne = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nSystem.out.println(\n\" The unsorted subarray which\"\n+ \n\n\" makes the given array sorted lies\"\n+ \n\n\" between the indices \"\n+s+\n\" and \"\n+e); \n\nreturn\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n10\n, \n12\n, \n20\n, \n30\n, \n25\n, \n40\n, \n32\n, \n31\n, \n35\n, \n50\n, \n60\n}; \n\nint\narr_size = arr.length; \n\nprintUnsorted(arr, arr_size); \n\n} \n}", "index": 132, "complexity": "1"}
{"back-translation": "public class C {\n    static class FastWriter {\n        private final BufferedWriter bw;\n\n        public FastWriter() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\").append(String.valueOf(object));\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        public void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        BigInteger nextBigInteger() throws IOException {\n            return new BigInteger(nextLine());\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int q = fr.nextInt();\n        int[] aa = new int[n - 1];\n        int[] ab = new int[n - 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) dq.addLast(fr.nextInt());\n        for (int i = 0; i < n - 1; i++) {\n            int a = dq.pollFirst();\n            int b = dq.pollFirst();\n            aa[i] = a;\n            ab[i] = b;\n            int mi = Math.min(a, b);\n            int ma = Math.max(a, b);\n            dq.addFirst(ma);\n            dq.addLast(mi);\n        }\n        int fm = dq.pollFirst();\n        int[] arr = new int[n - 1];\n        for (int i = 0; i < arr.length; i++) arr[i] = dq.pollFirst();\n        while (q-- > 0) {\n            long m = fr.nextLong() - 1;\n            if (m < n - 1) {\n                fw.println(aa[(int) m] + \" \" + ab[(int) m]);\n            } else {\n                m = m % (n - 1);\n                fw.println(fm + \" \" + arr[(int) m]);\n            }\n        }\n        fw.close();\n    }\n}", "src": "public class C {\n    static class FastWriter {\n        private final BufferedWriter bw;\n\n        public FastWriter() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        public void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        BigInteger nextBigInteger() {\n            try {\n                return new BigInteger(nextLine());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int q = fr.nextInt();\n        int[] aa = new int[n - 1];\n        int[] ab = new int[n - 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) dq.addLast(fr.nextInt());\n        for (int i = 0; i < n - 1; i++) {\n            int a = dq.removeFirst();\n            int b = dq.removeFirst();\n            aa[i] = a;\n            ab[i] = b;\n            int mi = Math.min(a, b);\n            int ma = Math.max(a, b);\n            dq.addFirst(ma);\n            dq.addLast(mi);\n        }\n        int fm = dq.removeFirst();\n        int[] arr = new int[n - 1];\n        for (int i = 0; i < arr.length; i++) arr[i] = dq.removeFirst();\n        while (q-- > 0) {\n            long m = fr.nextLong() - 1;\n            if (m < n - 1) {\n                System.out.println(aa[(int) m] + \" \" + ab[(int) m]);\n            } else {\n                m = m % (n - 1);\n                System.out.println(fm + \" \" + arr[(int) m]);\n            }\n        }\n    }\n}", "index": 133, "complexity": "1"}
{"back-translation": "public class Main {\n \n    public static void main(String[] args) {\n\t\n        Scanner scan = new Scanner(System.in);\n        int T = scan.nextInt();\n        while(T > 0) {\n            int n = scan.nextInt();\n            int[] arr = new int[n];\n            for(int i = 0; i < n; i++) {\n                arr[i] = scan.nextInt();\n            }\n            int m1 = 1;\n            int m2 = 1;\n            for(int i = 0; i < n; i++) {\n                if(arr[i] >= m1) {\n                    m2 = m1;\n                    m1 = arr[i];\n                } else if (arr[i] >= m2) {\n                    m2 = arr[i];\n                }\n            }\n            System.out.println(Math.min(Math.min(m1, m2) - 1, n - 2));\n            T--;\n        }\n    }\n}", "src": "public class Main {\n \n    public static void main(String[] args) {\n\t\n        Scanner scan = new Scanner(System.in);\n        int T = scan.nextInt();\n        for(; T > 0; T--) {\n            int n = scan.nextInt();\n            int[] arr = new int[n];\n            for(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n            int m1 = 1, m2 = 1;\n            for(int i = 0; i < n; i++) {\n                if(arr[i] >= m1) {\n                    m2 = m1;\n                    m1 = arr[i];\n                } else if (arr[i] >= m2) {\n                    m2 = arr[i];\n                }\n            }\n            System.out.println(Math.min(Math.min(m1, m2) - 1, n - 2));\n        }\n    }\n}", "index": 134, "complexity": "1"}
{"back-translation": "public class CF111111 {\n    BufferedReader in;\n    StringTokenizer as;\n    int nums[], nums2[];\n    int[][] nums1;\n    boolean con = true;\n    ArrayList<Integer> ar = new ArrayList<Integer>();\n    ArrayList<Integer> fi = new ArrayList<Integer>();\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n\n    public static void main(String[] args) {\n        new CF111111();\n    }\n\n    public int GCD(int a, int b) {\n        if (b == 0) return a;\n        return GCD(b, a % b);\n    }\n\n    public int LIS(int[] arr) {\n        int n = arr.length;\n        int[] sun = new int[n];\n        int cur = 0;\n        for (int x = 0; x < n; x++) {\n            int temp = Arrays.binarySearch(sun, 0, cur, arr[x]);\n            if (temp < 0)\n                temp = -temp - 1;\n            sun[temp] = arr[x];\n            if (temp == cur)\n                cur++;\n        }\n        return cur;\n    }\n\n    public void no() {\n        System.out.println(\"NO\");\n        System.exit(0);\n    }\n\n    public CF111111() {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            int a = nextInt();\n            nums = new int[a];\n            int max = -1;\n            int index = -1;\n            for (int x = 0; x < a; x++) {\n                nums[x] = nextInt();\n                if (nums[x] > max) {\n                    max = nums[x];\n                    index = x;\n                }\n            }\n            int lindex = index - 1;\n            int rindex = index + 1;\n            int done = 1;\n            int top = max;\n            for (; ; ) {\n                done++;\n\n                if (lindex < 0) {\n                    if (nums[rindex] > top) {\n                        no();\n                    } else\n                        top = nums[rindex];\n                    rindex++;\n                } else if (rindex >= a) {\n                    if (nums[lindex] > top)\n                        no();\n                    else\n                        top = nums[lindex];\n                    lindex--;\n                } else {\n                    if (nums[lindex] > top || nums[rindex] > top)\n                        no();\n                    else {\n                        if (nums[lindex] > nums[rindex]) {\n                            top = nums[lindex];\n                            lindex--;\n                        } else {\n                            top = nums[rindex];\n                            rindex++;\n                        }\n                    }\n                }\n                if (done == a) {\n                    System.out.println(\"YES\");\n                    System.exit(0);\n                }\n            }\n        } catch (IOException e) {\n\n        }\n    }\n\n    String next() throws IOException {\n        while (as == null || !as.hasMoreTokens()) {\n            as = new StringTokenizer(in.readLine().trim());\n        }\n\n        return as.nextToken();\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() throws IOException {\n        return in.readLine().trim();\n    }\n}", "src": "public class   CF111111\n{\n  BufferedReader in;\n  StringTokenizer as;\n  int nums[],nums2[];\n  int[] nums1[];\n  boolean con = true;\n \n  ArrayList < Integer >  ar = new ArrayList < Integer >();\n  ArrayList < Integer >  fi = new ArrayList < Integer >();\n  Map<Integer,Integer > map = new HashMap<Integer, Integer>();\n  public static void main (String[] args)\n  {\n    new CF111111  ();\n  }\n  \n  public int GCD(int a, int b) {\n    if (b==0) return a;\n    return GCD(b,a%b);\n  }\n  \n  public int LIS(int arr[])\n  {\n    int n = arr.length;\n    int sun[] = new int [n];\n    int cur = 0;\n    for(int x = 0;x<n;x++)\n    {\n      int temp = Arrays.binarySearch(sun,0,cur,arr[x]);\n      if(temp < 0)\n        temp = -temp -1;\n      sun[temp] = arr[x];\n      if(temp == cur)\n        cur++;\n    }\n    return cur;\n    \n  }\n  \n  \n  public void no()\n  {\n    System.out.println(\"NO\");\n    System.exit(0);\n  }\n  \n  public CF111111  ()\n  {\n    try\n    {\n      \n      in = new BufferedReader (new InputStreamReader (System.in));\n      int a = nextInt();\n      nums = new int [a];\n      int max = -1;\n      int index = -1;\n     for(int x = 0;x<a;x++)\n     {\n       nums[x] = nextInt();\n       if(nums[x] > max)\n       {\n         max = nums[x];\n         index = x;\n       }\n     }\n      int lindex = index-1;\n      int rindex = index+1;\n      int done = 1;\n      int top = max;\n      for(;;)\n      {\n        done++;\n      \n        if(lindex < 0)\n        {\n           if(nums[rindex] > top)\n           {\n             no();\n           }\n           else\n             top = nums[rindex];\n           rindex++;\n        }\n        else if(rindex >= a)\n        {\n          if(nums[lindex] > top)\n            no();\n          else\n            top = nums[lindex];\n          lindex--;\n        }\n        else\n        {\n          if(nums[lindex] > top || nums[rindex] > top)\n            no();\n          else\n          {\n            if(nums[lindex] > nums[rindex])\n            {\n              top = nums[lindex];\n              lindex--;\n            }\n            else\n            {\n              top = nums[rindex];\n              rindex++;\n            }\n          }\n        }\n        if(done == a)\n        {\n          System.out.println(\"YES\");\n          System.exit(0);\n        }\n      }\n    }\n    catch(IOException e)\n    {\n\n    }\n  }\n  \n  \n  \n  \n  \n  \n  \n  String next () throws IOException\n  {\n    while (as == null || !as.hasMoreTokens ())\n    {\n      as = new StringTokenizer (in.readLine ().trim ());\n    }\n    \n    \n    return as.nextToken ();\n  }\n  \n  \n  \n  long nextLong () throws IOException\n  {\n    return Long.parseLong (next ());\n  }\n  \n  \n  int nextInt () throws IOException\n  {\n    return Integer.parseInt (next ());\n  }\n  \n  \n  double nextDouble () throws IOException\n  {\n    return Double.parseDouble (next ());\n  }\n  \n  \n  String nextLine () throws IOException\n  {\n    return in.readLine ().trim ();\n  }\n}", "index": 135, "complexity": "1"}
{"back-translation": "public class codef\n{\n    public static void main(String ar[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        String st[]=br.readLine().split(\" \");\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n            a[i]=Integer.parseInt(st[i]);\n\n        int max=0;\n        for(int i=0;i<n;i++)\n        {\n            if(i!=0 && a[i]>a[max])\n                max=i;\n        }\n       \n        int maxi=max;\n        int i=max-1;\n        while(i>=0)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i--;\n        }\n        max=maxi;\n        i=max+1;\n        while(i<n)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i++;\n        }\n        System.out.println(\"YES\");\n    }\n}", "src": "public class codef\n{\n    public static void main(String ar[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        String st[]=br.readLine().split(\" \");\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n            a[i]=Integer.parseInt(st[i]);\n\n        int max=0;\n        for(int i=0;i<n;i++)\n        {\n            if(i!=0 && a[i]>a[max])\n                max=i;\n        }\n       \n        int maxi=max;\n        int i=max-1;\n        while(i>=0)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i--;\n        }\n        max=maxi;\n        i=max+1;\n        while(i<n)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i++;\n        }\n        System.out.println(\"YES\");\n    }\n}", "index": 136, "complexity": "1"}
{"back-translation": "class PairSum {\n\nstatic void constructArr(int arr[], int pair[], int n) {\narr[0] = (pair[0]+pair[1]-pair[n-1]) / 2;\nfor (int i=1; i<n; i++)\narr[i] = pair[i-1]-arr[0];\n}\n\npublic static void main(String[] args) {\nint pair[] = {15, 13, 11, 10, 12, 10, 9, 8, 7, 5};\nint n = 5;\nint[] arr = new int[n];\nconstructArr(arr, pair, n);\nfor (int i = 0; i < n; i++)\nSystem.out.print(arr[i]+\" \");\n}\n}", "src": "class\nPairSum { \n\n\n\n\n\n\nstatic\nvoid\nconstructArr(\nint\narr[], \nint\npair[], \nint\nn) \n\n{ \n\narr[\n0\n] = (pair[\n0\n]+pair[\n1\n]-pair[n-\n1\n]) / \n2\n; \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\narr[i] = pair[i-\n1\n]-arr[\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\npair[] = {\n15\n, \n13\n, \n11\n, \n10\n, \n12\n, \n10\n, \n9\n, \n8\n, \n7\n, \n5\n}; \n\nint\nn = \n5\n; \n\nint\n[] arr = \nnew\nint\n[n]; \n\nconstructArr(arr, pair, n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 137, "complexity": "1"}
{"back-translation": "class GfG { public static int minMaxProduct(int arr1[], int arr2[], int n1, int n2) { int max = arr1[0]; int min = arr2[0]; int i; for (i = 1; i < n1 && i < n2; ++i) { if (arr1[i] > max) max = arr1[i]; if (arr2[i] < min) min = arr2[i]; } while (i < n1) { if (arr1[i] > max) max = arr1[i]; i++; } while (i < n2) { if (arr2[i] < min) min = arr2[i]; i++; } return max * min; } public static void main(String argc[]) { int [] arr1= new int[]{ 10, 2, 3, 6, 4, 1}; int [] arr2 = new int[]{ 5, 1, 4, 2, 6, 9}; int n1 = 6; int n2 = 6; System.out.println(minMaxProduct(arr1, arr2, n1, n2)); } }", "src": "class\nGfG \n{ \n\n\n\n\npublic\nstatic\nint\nminMaxProduct(\nint\narr1[], \n\nint\narr2[], \n\nint\nn1, \n\nint\nn2) \n\n{ \n\n\n\n\n\n\nint\nmax = arr1[\n0\n]; \n\n\n\n\n\n\nint\nmin = arr2[\n0\n]; \n\n\nint\ni; \n\nfor\n(i = \n1\n; i < n1 && i < n2; ++i) \n\n{ \n\n\n\n\n\n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\n\n\n\n\n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\n} \n\n\n\n\nwhile\n(i < n1) \n\n{ \n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\ni++; \n\n} \n\nwhile\n(i < n2) \n\n{ \n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\ni++; \n\n} \n\n\nreturn\nmax * min; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]) \n\n{ \n\nint\n[] arr1= \nnew\nint\n[]{ \n10\n, \n2\n, \n3\n, \n\n6\n, \n4\n, \n1\n}; \n\nint\n[] arr2 = \nnew\nint\n[]{ \n5\n, \n1\n, \n4\n, \n\n2\n, \n6\n, \n9\n}; \n\nint\nn1 = \n6\n; \n\nint\nn2 = \n6\n; \n\nSystem.out.println(minMaxProduct(arr1, arr2, \n\nn1, n2)); \n\n} \n}", "index": 138, "complexity": "1"}
{"back-translation": "class GFG { static int MAX_CHAR = 26; public static void commonCharacters(String[] str, int n) { Boolean[] prim = new Boolean[MAX_CHAR]; Arrays.fill(prim, new Boolean(true)); for (int i = 0; i < n; i++) { Boolean[] sec = new Boolean[MAX_CHAR]; Arrays.fill(sec, new Boolean(false)); for (int j = 0; j < str[i].length(); j++) { if (prim[str[i].charAt(j) - 'a']) sec[str[i].charAt(j) - 'a'] = true; } System.arraycopy(sec, 0, prim, 0, MAX_CHAR); } for (int i = 0; i < 26; i++) if (prim[i]) { System.out.print(Character.toChars(i + 97)); System.out.print(", "src": "class\nGFG { \n\n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\npublic\nstatic\nvoid\ncommonCharacters(String str[], \n\nint\nn) \n\n{ \n\n\n\n\n\n\nBoolean[] prim = \nnew\nBoolean[MAX_CHAR]; \n\nArrays.fill(prim, \nnew\nBoolean(\ntrue\n)); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nBoolean[] sec = \nnew\nBoolean[MAX_CHAR]; \n\nArrays.fill(sec, \nnew\nBoolean(\nfalse\n)); \n\n\n\n\nfor\n(\nint\nj = \n0\n; j < str[i].length(); j++) \n\n{ \n\n\n\n\n\n\nif\n(prim[str[i].charAt(j) - \n'a'\n]) \n\nsec[str[i].charAt(j) - \n'a'\n] = \ntrue\n; \n\n} \n\n\n\n\nSystem.arraycopy(sec, \n0\n, prim, \n0\n, MAX_CHAR); \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < \n26\n; i++) \n\nif\n(prim[i]){ \n\nSystem.out.print(Character.toChars(i \n\n+ \n97\n)); \n\nSystem.out.print(\n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str[] = { \n\"geeksforgeeks\"\n, \n\n\"gemkstones\"\n, \n\n\"acknowledges\"\n, \n\n\"aguelikes\"\n}; \n\n\nint\nn = str.length; \n\ncommonCharacters(str, n); \n\n} \n}", "index": 139, "complexity": "1"}
{"back-translation": "class GFG { static int MAX_CHAR = 26; static void findAndPrintUncommonChars(String str1, String str2) { int present[] = new int[MAX_CHAR]; for (int i = 0; i < MAX_CHAR; i++) { present[i] = 0; } int l1 = str1.length(); int l2 = str2.length(); for (int i = 0; i < l1; i++) { present[str1.charAt(i) - 'a'] = 1; } for (int i = 0; i < l2; i++) { if (present[str2.charAt(i) - 'a'] == 1 || present[str2.charAt(i) - 'a'] == -1) { present[str2.charAt(i) - 'a'] = -1; } else { present[str2.charAt(i) - 'a'] = 2; } } for (int i = 0; i < MAX_CHAR; i++) { if (present[i] == 1 || present[i] == 2) { System.out.print((char) (i + 'a') + \" \"); } } } public static void main(String[] args) { String str1 = \"characters\"; String str2 = \"alphabets\"; findAndPrintUncommonChars(str1, str2); } }", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nvoid\nfindAndPrintUncommonChars(String str1, \n\nString str2) \n\n{ \n\n\n\n\n\nint\npresent[] = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\npresent[i] = \n0\n; \n\n} \n\n\nint\nl1 = str1.length(); \n\nint\nl2 = str2.length(); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < l1; i++) \n\n{ \n\npresent[str1.charAt(i) - \n'a'\n] = \n1\n; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < l2; i++) \n\n{ \n\n\n\n\n\n\nif\n(present[str2.charAt(i) - \n'a'\n] == \n1\n\n|| present[str2.charAt(i) - \n'a'\n] == -\n1\n) \n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = -\n1\n; \n\n} \n\n\n\n\nelse\n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = \n2\n; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\nif\n(present[i] == \n1\n|| present[i] == \n2\n) \n\n{ \n\nSystem.out.print((\nchar\n) (i + \n'a'\n) + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str1 = \n\"characters\"\n; \n\nString str2 = \n\"alphabets\"\n; \n\nfindAndPrintUncommonChars(str1, str2); \n\n} \n}", "index": 140, "complexity": "1"}
{"back-translation": "class GFG { static boolean isVowel(char ch) { if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch =='u') return true; return false; } static String createAltStr(String str1, String str2, int start, int l) { String finalStr = \"\"; for (int i = 0, j = start; j < l; i++, j++) finalStr = (finalStr + str1.charAt(i)) + str2.charAt(j); return finalStr; } static String findAltStr(String str) { int nv = 0, nc = 0; String vstr = \"\", cstr = \"\"; int l = str.length(); for (int i = 0; i < l; i++) { char ch = str.charAt(i); if (isVowel(ch)) { nv++; vstr = vstr + ch; } else { nc++; cstr = cstr + ch; } } if (Math.abs(nv - nc) >= 2) return \"no such string\"; if (nv > nc) return (vstr.charAt(0) + createAltStr(cstr, vstr, 1, nv)); if (nc > nv) return (cstr.charAt(0) + createAltStr(vstr, cstr, 1, nc)); if (cstr.charAt(0) < vstr.charAt(0)) return createAltStr(cstr, vstr, 0, nv); return createAltStr(vstr, cstr, 0, nc); } public static void main(String args[]) { String str = \"geeks\"; System.out.println(findAltStr(str)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nboolean\nisVowel(\nchar\nch) \n{ \n\nif\n(ch == \n'a'\n|| ch == \n'e'\n|| ch == \n'i'\n|| \n\nch == \n'o'\n|| ch ==\n'u'\n) \n\nreturn\ntrue\n; \n\nreturn\nfalse\n; \n} \n\n\n\nstatic\nString createAltStr(String str1, String str2, \n\nint\nstart, \nint\nl) \n{ \n\nString finalStr = \n\"\"\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n, j = start; j < l; i++, j++) \n\nfinalStr = (finalStr + str1.charAt(i)) + \n\nstr2.charAt(j); \n\nreturn\nfinalStr; \n} \n\n\n\nstatic\nString findAltStr(String str) \n{ \n\nint\nnv = \n0\n, nc = \n0\n; \n\nString vstr = \n\"\"\n, cstr = \n\"\"\n; \n\nint\nl = str.length(); \n\nfor\n(\nint\ni = \n0\n; i < l; i++) \n\n{ \n\nchar\nch = str.charAt(i); \n\n\n\n\nif\n(isVowel(ch)) \n\n{ \n\nnv++; \n\nvstr = vstr + ch; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\nnc++; \n\ncstr = cstr + ch; \n\n} \n\n} \n\n\n\n\nif\n(Math.abs(nv - nc) >= \n2\n) \n\nreturn\n\"no such string\"\n; \n\n\n\n\n\n\n\n\nif\n(nv > nc) \n\nreturn\n(vstr.charAt(\n0\n) + createAltStr(cstr, vstr, \n1\n, nv)); \n\n\n\n\n\n\n\n\nif\n(nc > nv) \n\nreturn\n(cstr.charAt(\n0\n) + createAltStr(vstr, cstr, \n1\n, nc)); \n\n\n\n\n\n\n\n\nif\n(cstr.charAt(\n0\n) < vstr.charAt(\n0\n)) \n\nreturn\ncreateAltStr(cstr, vstr, \n0\n, nv); \n\n\n\n\nreturn\ncreateAltStr(vstr, cstr, \n0\n, nc); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nString str = \n\"geeks\"\n; \n\nSystem.out.println(findAltStr(str)); \n} \n}", "index": 141, "complexity": "1"}
{"back-translation": "class CountSubString { int countSubStr(char str[], int n) { int m = 0; for (int i = 0; i < n; i++) { if (str[i] == '1') m++; } return m * (m - 1) / 2; } public static void main(String[] args) { CountSubString count = new CountSubString(); String string = \"00100101\"; char str[] = string.toCharArray(); int n = str.length; System.out.println(count.countSubStr(str, n)); } }", "src": "class\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[], \nint\nn) \n\n{ \n\nint\nm = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\nm++; \n\n} \n\n\n\n\nreturn\nm * (m - \n1\n) / \n2\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str, n)); \n\n} \n}", "index": 142, "complexity": "1"}
{"back-translation": "public class GFG {\n    static final int M = 26;\n\n    static int getIdx(char ch) {\n        return (ch - 'a');\n    }\n\n    static boolean allSame(int freq[], int N) {\n        int same = 0;\n\n        int i;\n        for (i = 0; i < N; i++) {\n            if (freq[i] > 0) {\n                same = freq[i];\n                break;\n            }\n        }\n\n        for (int j = i + 1; j < N; j++)\n            if (freq[j] > 0 && freq[j] != same)\n                return false;\n\n        return true;\n    }\n\n    static boolean possibleSameCharFreqByOneRemoval(String str) {\n        int l = str.length();\n\n        int[] freq = new int[M];\n\n        for (int i = 0; i < l; i++)\n            freq[getIdx(str.charAt(i))]++;\n\n        if (allSame(freq, M))\n            return true;\n\n        for (char c = 'a'; c <= 'z'; c++) {\n            int i = getIdx(c);\n\n            if (freq[i] > 0) {\n                freq[i]--;\n\n                if (allSame(freq, M))\n                    return true;\n\n                freq[i]++;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String args[]) {\n        String str = \"xyyzz\";\n\n        if (possibleSameCharFreqByOneRemoval(str))\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n    }\n}", "src": "public\nclass\nGFG { \n\n\nstatic\nfinal\nint\nM = \n26\n; \n\n\n\n\n\n\nstatic\nint\ngetIdx(\nchar\nch) \n\n{ \n\nreturn\n(ch - \n'a'\n); \n\n} \n\n\n\n\n\n\nstatic\nboolean\nallSame(\nint\nfreq[], \nint\nN) \n\n{ \n\nint\nsame = \n0\n; \n\n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < N; i++) { \n\nif\n(freq[i] > \n0\n) { \n\nsame = freq[i]; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < N; j++) \n\nif\n(freq[j] > \n0\n&& freq[j] != same) \n\nreturn\nfalse\n; \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\n\n\nstatic\nboolean\npossibleSameCharFreqByOneRemoval(String str) \n\n{ \n\nint\nl = str.length(); \n\n\n\n\nint\n[] freq = \nnew\nint\n[M]; \n\n\nfor\n(\nint\ni = \n0\n; i < l; i++) \n\nfreq[getIdx(str.charAt(i))]++; \n\n\n\n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\n\n\n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\ni = getIdx(c); \n\n\n\n\nif\n(freq[i] > \n0\n) { \n\nfreq[i]--; \n\n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\nfreq[i]++; \n\n} \n\n} \n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"xyyzz\"\n; \n\nif\n(possibleSameCharFreqByOneRemoval(str)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 143, "complexity": "1"}
{"back-translation": "class GFG { static void printMinIndexChar(String str, String patt) { HashMap<Character, Integer> hm = new HashMap<>(); int minIndex = Integer.MAX_VALUE; int m = str.length(); int n = patt.length(); for (int i = 0; i < m; i++) if (!hm.containsKey(str.charAt(i))) hm.put(str.charAt(i),i); for (int i = 0; i < n; i++) if (hm.containsKey(patt.charAt(i)) && hm.get(patt.charAt(i)) < minIndex) minIndex = hm.get(patt.charAt(i)); if (minIndex != Integer.MAX_VALUE) System.out.println(", "Minimum Index Character = ": "+ str.charAt(minIndex)); else System.out.println(", "No character present": "); } public static void main(String[] args) { String str = ", "geeksforgeeks": ", patt = ", "set": "; printMinIndexChar(str, patt); } }", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n\n\nHashMap<Character, Integer> hm = \nnew\nHashMap<>(); \n\n\n\n\n\n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n\n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(!hm.containsKey(str.charAt(i))) \n\nhm.put(str.charAt(i),i); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\n\n\n\nif\n(hm.containsKey(patt.charAt(i)) && \n\nhm.get(patt.charAt(i)) < minIndex) \n\nminIndex = hm.get(patt.charAt(i)); \n\n\n\n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n\n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n}", "index": 144, "complexity": "1"}
{"back-translation": "public class GFG { static final int NO_OF_CHARS = 256; static int[] getCharCountArray(String str) { int count[] = new int[NO_OF_CHARS]; for (int i = 0; i < str.length(); i++) count[str.charAt(i)]++; return count; } static String removeDirtyChars(String str, String mask_str) { int count[] = getCharCountArray(mask_str); int ip_ind = 0, res_ind = 0; char arr[] = str.toCharArray(); while (ip_ind != arr.length) { char temp = arr[ip_ind]; if (count[temp] == 0) { arr[res_ind] = arr[ip_ind]; res_ind++; } ip_ind++; } str = new String(arr); return str.substring(0, res_ind); } public static void main(String[] args) { String str = \"geeksforgeeks\"; String mask_str = \"mask\"; System.out.println(removeDirtyChars(str, mask_str)); } }", "src": "public\nclass\nGFG \n{ \n\nstatic\nfinal\nint\nNO_OF_CHARS = \n256\n; \n\n\n\n\nstatic\nint\n[] getCharCountArray(String str) \n\n{ \n\nint\ncount[] = \nnew\nint\n[NO_OF_CHARS]; \n\nfor\n(\nint\ni = \n0\n; i<str.length(); i++) \n\ncount[str.charAt(i)]++; \n\n\nreturn\ncount; \n\n} \n\n\n\n\nstatic\nString removeDirtyChars(String str, String mask_str) \n\n{ \n\nint\ncount[] = getCharCountArray(mask_str); \n\nint\nip_ind = \n0\n, res_ind = \n0\n; \n\n\nchar\narr[] = str.toCharArray(); \n\n\nwhile\n(ip_ind != arr.length) \n\n{ \n\nchar\ntemp = arr[ip_ind]; \n\nif\n(count[temp] == \n0\n) \n\n{ \n\narr[res_ind] = arr[ip_ind]; \n\nres_ind ++; \n\n} \n\nip_ind++; \n\n\n} \n\n\nstr = \nnew\nString(arr); \n\n\n\n\n\nreturn\nstr.substring(\n0\n, res_ind); \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString mask_str = \n\"mask\"\n; \n\nSystem.out.println(removeDirtyChars(str, mask_str)); \n\n} \n}", "index": 145, "complexity": "1"}
{"back-translation": "public class GFG { static class Pair { char first; int second; Pair(char first, int second) { this.first = first; this.second = second; } } static int longestNull(String str) { ArrayList<Pair> arr = new ArrayList<>(); arr.add(new Pair('@', -1)); int maxlen = 0; for (int i = 0; i < str.length(); ++i) { arr.add(new Pair(str.charAt(i), i)); while (arr.size() >= 3 && arr.get(arr.size() - 3).first == '1' && arr.get(arr.size() - 2).first == '0' && arr.get(arr.size() - 1).first == '0') { arr.remove(arr.size() - 3); arr.remove(arr.size() - 2); arr.remove(arr.size() - 1); } int tmp = arr.get(arr.size() - 1).second; maxlen = Math.max(maxlen, i - tmp); } return maxlen; } public static void main(String args[]) { System.out.println(longestNull(\"1011100000100\")); } }", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nclass\nPair{ \n\nchar\nfirst; \n\nint\nsecond; \n\nPair(\nchar\nfirst, \nint\nsecond){ \n\nthis\n.first = first; \n\nthis\n.second = second; \n\n} \n\n} \n\n\n\n\nstatic\nint\nlongestNull(String str) \n\n{ \n\nArrayList<Pair> arr = \nnew\nArrayList<>(); \n\n\n\n\n\n\narr.add(\nnew\nPair(\n'@'\n, -\n1\n)); \n\n\nint\nmaxlen = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < str.length(); ++i) \n\n{ \n\n\n\n\n\narr.add(\nnew\nPair(str.charAt(i), i)); \n\n\n\n\n\n\nwhile\n(arr.size() >= \n3\n&& \n\narr.get(arr.size()-\n3\n).first==\n'1'\n&& \n\narr.get(arr.size()-\n2\n).first==\n'0'\n&& \n\narr.get(arr.size()-\n1\n).first==\n'0'\n) \n\n{ \n\n\n\n\n\narr.remove(arr.size() - \n3\n); \n\narr.remove(arr.size() - \n2\n); \n\narr.remove(arr.size() - \n1\n); \n\n} \n\n\n\n\nint\ntmp = arr.get(arr.size() - \n1\n).second; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmaxlen = Math.max(maxlen, i - tmp); \n\n} \n\n\nreturn\nmaxlen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(longestNull(\n\"1011100000100\"\n)); \n\n} \n}", "index": 146, "complexity": "1"}
{"back-translation": "class Test { static final int MAX_CHAR = 26; static int countPairs(String str) { int result = 0; int n = str.length(); for (int i = 0; i < n; i++) for (int j = 1; (i + j) < n && j <= MAX_CHAR; j++) if ((Math.abs(str.charAt(i + j) - str.charAt(i)) == j)) result++; return result; } public static void main(String args[]) { String str = \"geeksforgeeks\"; System.out.println(countPairs(str)); } }", "src": "class\nTest { \n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\nfor\n(\nint\nj = \n1\n; (i + j) < n && j <= MAX_CHAR; j++) \n\nif\n((Math.abs(str.charAt(i + j) - str.charAt(i)) == j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n}", "index": 147, "complexity": "1"}
{"back-translation": "class ReverseArray {\n\n    static void rvereseArray(int arr[], int start, int end) {\n        int temp;\n        if (start >= end)\n            return;\n        temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        rvereseArray(arr, start+1, end-1);\n    }\n\n    static void printArray(int arr[], int size) {\n        for (int i=0; i < size; i++)\n            System.out.print(arr[i] + \" \");\n        System.out.println(\"\");\n    }\n\n    public static void main (String[] args) {\n        int arr[] = {1, 2, 3, 4, 5, 6};\n        printArray(arr, 6);\n        rvereseArray(arr, 0, 5);\n        System.out.println(\"Reversed array is \");\n        printArray(arr, 6);\n    }\n}", "src": "class\nReverseArray { \n\n\n\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n\n{ \n\nint\ntemp; \n\nif\n(start >= end) \n\nreturn\n; \n\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nrvereseArray(arr, start+\n1\n, end-\n1\n); \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nprintArray(arr, \n6\n); \n\nrvereseArray(arr, \n0\n, \n5\n); \n\nSystem.out.println(\n\"Reversed array is \"\n); \n\nprintArray(arr, \n6\n); \n\n} \n}", "index": 148, "complexity": "1"}
{"back-translation": "class GFG {\n\n    static final int MAX_CHARS = 26;\n\n    static void longestSubseqWithK(String str, int k) {\n        int n = str.length();\n\n        int[] freq = new int[MAX_CHARS];\n\n        for (int i = 0; i < n; i++) {\n            freq[str.charAt(i) - 'a']++;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (freq[str.charAt(i) - 'a'] >= k) {\n                System.out.print(str.charAt(i));\n            }\n        }\n    }\n\n    static public void main(String[] args) {\n        String str = \"geeksforgeeks\";\n        int k = 2;\n\n        longestSubseqWithK(str, k);\n    }\n}", "src": "class\nGFG { \n\n\nstatic\nfinal\nint\nMAX_CHARS = \n26\n; \n\n\nstatic\nvoid\nlongestSubseqWithK(String str, \nint\nk) { \n\nint\nn = str.length(); \n\n\n\n\nint\nfreq[] = \nnew\nint\n[MAX_CHARS]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nfreq[str.charAt(i) - \n'a'\n]++; \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(freq[str.charAt(i) - \n'a'\n] >= k) { \n\nSystem.out.print(str.charAt(i)); \n\n} \n\n} \n\n} \n\n\n\nstatic\npublic\nvoid\nmain(String[] args) { \n\nString str = \n\"geeksforgeeks\"\n; \n\nint\nk = \n2\n; \n\nlongestSubseqWithK(str, k); \n\n\n} \n}", "index": 149, "complexity": "1"}
{"back-translation": "public class No_of_subsequence { static int countSubsequences(String s) { int aCount = 0; int bCount = 0; int cCount = 0; for (int i = 0; i < s.length(); i++) { if (s.charAt(i) == 'a') aCount = (1 + 2 * aCount); else if (s.charAt(i) == 'b') bCount = (aCount + 2 * bCount); else if (s.charAt(i) == 'c') cCount = (bCount + 2 * cCount); } return cCount; } public static void main(String args[]) { String s = \"abbc\"; System.out.println(countSubsequences(s)); } }", "src": "public\nclass\nNo_of_subsequence { \n\n\n\n\n\n\nstatic\nint\ncountSubsequences(String s) \n\n{ \n\n\n\n\n\nint\naCount = \n0\n; \n\n\n\n\n\n\n\n\nint\nbCount = \n0\n; \n\n\n\n\n\n\n\n\nint\ncCount = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i< s.length(); i++) \n\n{ \n\n\n\nif\n(s.charAt(i) == \n'a'\n) \n\naCount = (\n1\n+ \n2\n* aCount); \n\n\n\n\nelse\nif\n(s.charAt(i) == \n'b'\n) \n\nbCount = (aCount + \n2\n* bCount); \n\n\n\n\nelse\nif\n(s.charAt(i) == \n'c'\n) \n\ncCount = (bCount + \n2\n* cCount); \n\n} \n\n\nreturn\ncCount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abbc\"\n; \n\nSystem.out.println(countSubsequences(s)); \n\n} \n}", "index": 150, "complexity": "1"}
{"back-translation": "class GFG { static int countOccurrences(String s, int K) { int n = s.length(); int C = 0, c1 = 0, c2 = 0; for (int i = 0; i < n; i++) { if (s.charAt(i) == 'a') c1++; if (s.charAt(i) == 'b') { c2++; C += c1; } } return C * K + (K * (K - 1) / 2) * c1 * c2; } public static void main(String[] args) { String S = \"abcb\"; int k = 2; System.out.println(countOccurrences(S, k)); } }", "src": "class\nGFG { \n\n\nstatic\nint\ncountOccurrences(String s, \nint\nK) \n\n{ \n\nint\nn = s.length(); \n\nint\nC = \n0\n, c1 = \n0\n, c2 = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(s.charAt(i) == \n'a'\n) \n\nc1++; \n\n\nif\n(s.charAt(i) == \n'b'\n) { \n\nc2++; \n\n\n\n\n\n\n\nC += c1; \n\n} \n\n} \n\n\n\n\n\n\n\n\nreturn\nC * K + (K * (K - \n1\n) / \n2\n) * c1 * c2; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString S = \n\"abcb\"\n; \n\nint\nk = \n2\n; \n\n\nSystem.out.println(countOccurrences(S, k)); \n\n} \n}", "index": 151, "complexity": "1"}
{"back-translation": "public class GFG { static int max = 100; static void countSubsequence(String s, int n) { int cntG = 0, cntF = 0, result = 0, C= 0; for (int i = 0; i < n; i++) { switch (s.charAt(i)) { case 'G' : cntG++; result+=C; break; case 'F' : cntF++; C+=cntG; break; default: continue; } } System.out.println(result); } public static void main(String args[]) { String s= \"GFGFG\"; int n = s.length(); countSubsequence(s, n); } }", "src": "public\nclass\nGFG { \n\n\nstatic\nint\nmax = \n100\n; \n\n\n\n\n\n\nstatic\nvoid\ncountSubsequence(String s, \nint\nn) \n\n{ \n\nint\ncntG = \n0\n, cntF = \n0\n, result = \n0\n, C=\n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nswitch\n(s.charAt(i)) { \n\n\n\n\n\n\n\n\n\n\ncase\n'G'\n: \n\ncntG++; \n\nresult+=C; \n\nbreak\n; \n\n\n\n\n\n\n\n\ncase\n'F'\n: \n\ncntF++; \n\nC+=cntG; \n\nbreak\n; \n\n\n\n\ndefault\n: \n\ncontinue\n; \n\n} \n\n} \n\n\nSystem.out.println(result); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nString s= \n\"GFGFG\"\n; \n\nint\nn = s.length(); \n\ncountSubsequence(s, n); \n\n} \n}", "index": 152, "complexity": "1"}
{"back-translation": "public class Count_Subsequences { static final int MAX_CHAR = 256; static int countSub(String str) { int[] last = new int[MAX_CHAR]; Arrays.fill(last, -1); int n = str.length(); int[] dp = new int[n+1]; dp[0] = 1; for (int i=1; i<=n; i++) { dp[i] = 2*dp[i-1]; if (last[(int)str.charAt(i-1)] != -1) dp[i] = dp[i] - dp[last[(int)str.charAt(i-1)]]; last[(int)str.charAt(i-1)] = (i-1); } return dp[n]; } public static void main(String args[]) { System.out.println(countSub(\"gfg\")); } }", "src": "public\nclass\nCount_Subsequences { \n\n\nstatic\nfinal\nint\nMAX_CHAR = \n256\n; \n\n\n\n\nstatic\nint\ncountSub(String str) \n\n{ \n\n\n\n\n\nint\n[] last = \nnew\nint\n[MAX_CHAR]; \n\nArrays.fill(last, -\n1\n); \n\n\n\n\nint\nn = str.length(); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\n\n\n\ndp[\n0\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n\n\n\n\ndp[i] = \n2\n*dp[i-\n1\n]; \n\n\n\n\n\n\n\n\nif\n(last[(\nint\n)str.charAt(i-\n1\n)] != -\n1\n) \n\ndp[i] = dp[i] - dp[last[(\nint\n)str.charAt(i-\n1\n)]]; \n\n\n\n\nlast[(\nint\n)str.charAt(i-\n1\n)] = (i-\n1\n); \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(countSub(\n\"gfg\"\n)); \n\n} \n}", "index": 153, "complexity": "1"}
{"back-translation": "class UglyNumber { int getNthUglyNo(int n) { int ugly[] = new int[n]; int i2 = 0, i3 = 0, i5 = 0; int next_multiple_of_2 = 2; int next_multiple_of_3 = 3; int next_multiple_of_5 = 5; int next_ugly_no = 1; ugly[0] = 1; for(int i = 1; i < n; i++) { next_ugly_no = Math.min(next_multiple_of_2, Math.min(next_multiple_of_3, next_multiple_of_5)); ugly[i] = next_ugly_no; if (next_ugly_no == next_multiple_of_2) { i2 = i2 + 1; next_multiple_of_2 = ugly[i2] * 2; } if (next_ugly_no == next_multiple_of_3) { i3 = i3 + 1; next_multiple_of_3 = ugly[i3] * 3; } if (next_ugly_no == next_multiple_of_5) { i5 = i5 + 1; next_multiple_of_5 = ugly[i5] * 5; } } return next_ugly_no; } public static void main(String args[]) { int n = 150; UglyNumber obj = new UglyNumber(); System.out.println(obj.getNthUglyNo(n)); } }", "src": "class\nUglyNumber \n{ \n\n\n\nint\ngetNthUglyNo(\nint\nn) \n\n{ \n\nint\nugly[] = \nnew\nint\n[n]; \n\n\nint\ni2 = \n0\n, i3 = \n0\n, i5 = \n0\n; \n\nint\nnext_multiple_of_2 = \n2\n; \n\nint\nnext_multiple_of_3 = \n3\n; \n\nint\nnext_multiple_of_5 = \n5\n; \n\nint\nnext_ugly_no = \n1\n; \n\n\nugly[\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nnext_ugly_no = Math.min(next_multiple_of_2, \n\nMath.min(next_multiple_of_3, \n\nnext_multiple_of_5)); \n\n\nugly[i] = next_ugly_no; \n\nif\n(next_ugly_no == next_multiple_of_2) \n\n{ \n\ni2 = i2+\n1\n; \n\nnext_multiple_of_2 = ugly[i2]*\n2\n; \n\n} \n\nif\n(next_ugly_no == next_multiple_of_3) \n\n{ \n\ni3 = i3+\n1\n; \n\nnext_multiple_of_3 = ugly[i3]*\n3\n; \n\n} \n\nif\n(next_ugly_no == next_multiple_of_5) \n\n{ \n\ni5 = i5+\n1\n; \n\nnext_multiple_of_5 = ugly[i5]*\n5\n; \n\n} \n\n} \n\n\nreturn\nnext_ugly_no; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n150\n; \n\nUglyNumber obj = \nnew\nUglyNumber(); \n\nSystem.out.println(obj.getNthUglyNo(n)); \n\n} \n}", "index": 154, "complexity": "1"}
{"back-translation": "public class GFG {\n\n    static int permutationCoeff(int n, int k) {\n        int[] fact = new int[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++)\n            fact[i] = i * fact[i - 1];\n        return fact[n] / fact[n - k];\n    }\n\n    public static void main(String[] args) {\n        int n = 10, k = 2;\n        System.out.println(\"Value of\" + \" P( \" + n + \", \" + k + \") is \" + permutationCoeff(n, k));\n    }\n}", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\n[]fact = \nnew\nint\n[n+\n1\n]; \n\n\n\n\nfact[\n0\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfact[i] = i * fact[i - \n1\n]; \n\n\n\n\nreturn\nfact[n] / fact[n - k]; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of\"\n\n+ \n\" P( \"\n+ n + \n\", \"\n+ k + \n\") is \"\n\n+ permutationCoeff(n, k) ); \n\n} \n}", "index": 155, "complexity": "1"}
{"back-translation": "class GFG { static int countFriendsPairings(int n) { int dp[] = new int[n + 1]; for (int i = 0; i <= n; i++) { if (i <= 2) dp[i] = i; else dp[i] = dp[i - 1] + (i - 1) * dp[i - 2]; } return dp[n]; } public static void main(String[] args) { int n = 4; System.out.println(countFriendsPairings(n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n + \n1\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) { \n\nif\n(i <= \n2\n) \n\ndp[i] = i; \n\nelse\n\ndp[i] = dp[i - \n1\n] + (i - \n1\n) * dp[i - \n2\n]; \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}", "index": 156, "complexity": "1"}
{"back-translation": "public class Test { static int[] arr = new int[]{1, 2, 3, 4, 5}; static void rotate() { int x = arr[arr.length - 1], i; for (i = arr.length - 1; i > 0; i--) arr[i] = arr[i - 1]; arr[0] = x; } public static void main(String[] args) { System.out.println(\"Given Array is\"); System.out.println(Arrays.toString(arr)); rotate(); System.out.println(\"Rotated Array is\"); System.out.println(Arrays.toString(arr)); } }", "src": "public\nclass\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n1\n, \n2\n, \n3\n, \n4\n, \n5\n}; \n\n\n\n\nstatic\nvoid\nrotate() \n\n{ \n\nint\nx = arr[arr.length-\n1\n], i; \n\nfor\n(i = arr.length-\n1\n; i > \n0\n; i--) \n\narr[i] = arr[i-\n1\n]; \n\narr[\n0\n] = x; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Given Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n\nrotate(); \n\n\nSystem.out.println(\n\"Rotated Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n} \n}", "index": 157, "complexity": "1"}
{"back-translation": "class GFG { static int[] dp = new int[1000]; static int countFriendsPairings(int n) { if (dp[n] != -1) return dp[n]; if (n > 2) return dp[n] = countFriendsPairings(n - 1) + (n - 1) * countFriendsPairings(n - 2); else return dp[n] = n; } public static void main(String[] args) { for (int i = 0; i < 1000; i++) dp[i] = -1; int n = 4; System.out.println(countFriendsPairings(n)); } }", "src": "class\nGFG { \n\nstatic\nint\n[] dp = \nnew\nint\n[\n1000\n]; \n\n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nif\n(dp[n] != -\n1\n) \n\nreturn\ndp[n]; \n\n\nif\n(n > \n2\n) \n\nreturn\ndp[n] = countFriendsPairings(n - \n1\n) + (n - \n1\n) * countFriendsPairings(n - \n2\n); \n\nelse\n\nreturn\ndp[n] = n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < \n1000\n; i++) \n\ndp[i] = -\n1\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}", "index": 158, "complexity": "1"}
{"back-translation": "class GFG { static int sequence(int n) { if (n == 1 || n == 2) return 1; else return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1)); } public static void main(String args[]) { int n = 10; System.out.println(sequence(n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nsequence(\nint\nn) \n\n{ \n\nif\n(n == \n1\n|| n == \n2\n) \n\nreturn\n1\n; \n\nelse\n\nreturn\nsequence(sequence(n - \n1\n)) \n\n+ sequence(n - sequence(n - \n1\n)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(sequence(n)); \n\n} \n}", "index": 159, "complexity": "1"}
{"back-translation": "class GFG { static int sequence(int n) { int f[] = new int[n + 1]; f[0] = 0; f[1] = 1; f[2] = 1; int i; for (i = 3; i <= n; i++) f[i] = f[f[i - 1]] + f[i - f[i - 1]]; return f[n]; } public static void main(String[] args) { int n = 10; System.out.println(sequence(n)); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nsequence(\nint\nn) \n\n{ \n\n\n\nint\nf[] = \nnew\nint\n[n + \n1\n]; \n\nf[\n0\n] = \n0\n; \n\nf[\n1\n] = \n1\n; \n\nf[\n2\n] = \n1\n; \n\n\nint\ni; \n\n\nfor\n(i = \n3\n; i <= n; i++) \n\nf[i] = f[f[i - \n1\n]] + \n\nf[i - f[i - \n1\n]]; \n\n\nreturn\nf[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(sequence(n)); \n\n\n} \n}", "index": 160, "complexity": "1"}
{"back-translation": "class RearrangeArray { void rearrangeNaive(int arr[], int n) { int temp[] = new int[n]; int i; for (i = 0; i < n; i++) temp[arr[i]] = i; for (i = 0; i < n; i++) arr[i] = temp[i]; } void printArray(int arr[], int n) { int i; for (i = 0; i < n; i++) { System.out.print(arr[i] + \" \"); } System.out.println(\"\"); } public static void main(String[] args) { RearrangeArray arrange = new RearrangeArray(); int arr[] = {1, 3, 0, 2}; int n = arr.length; System.out.println(\"Given array is \"); arrange.printArray(arr, n); arrange.rearrangeNaive(arr, n); System.out.println(\"Modified array is \"); arrange.printArray(arr, n); } }", "src": "class\nRearrangeArray { \n\n\n\n\n\nvoid\nrearrangeNaive(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\ntemp[] = \nnew\nint\n[n]; \n\nint\ni; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\ntemp[arr[i]] = i; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n1\n, \n3\n, \n0\n, \n2\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrangeNaive(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n}", "index": 161, "complexity": "1"}
{"back-translation": "class GFG {\n\n    static int maxSumWO3Consec(int[] arr, int n) {\n        int[] sum = new int[n];\n\n        if (n >= 1)\n            sum[0] = arr[0];\n\n        if (n >= 2)\n            sum[1] = arr[0] + arr[1];\n\n        if (n > 2)\n            sum[2] = Math.max(sum[1], Math.max(arr[1] + arr[2], arr[0] + arr[2]));\n\n        for (int i = 3; i < n; i++)\n            sum[i] = Math.max(Math.max(sum[i - 1], sum[i - 2] + arr[i]), arr[i] + arr[i - 1] + sum[i - 3]);\n\n        return sum[n - 1];\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {100, 1000, 100, 1000, 1};\n        int n = arr.length;\n\n        System.out.println(maxSumWO3Consec(arr, n));\n    }\n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumWO3Consec(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\nsum[] = \nnew\nint\n[n]; \n\n\n\n\nif\n(n >= \n1\n) \n\nsum[\n0\n] = arr[\n0\n]; \n\n\nif\n(n >= \n2\n) \n\nsum[\n1\n] = arr[\n0\n] + arr[\n1\n]; \n\n\nif\n(n > \n2\n) \n\nsum[\n2\n] = Math.max(sum[\n1\n], Math.max(arr[\n1\n] + arr[\n2\n], arr[\n0\n] + arr[\n2\n])); \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n3\n; i < n; i++) \n\nsum[i] = Math.max(Math.max(sum[i - \n1\n], sum[i - \n2\n] + arr[i]), \n\narr[i] + arr[i - \n1\n] + sum[i - \n3\n]); \n\n\nreturn\nsum[n - \n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n100\n, \n1000\n, \n100\n, \n1000\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSumWO3Consec(arr, n)); \n\n} \n}", "index": 162, "complexity": "1"}
{"back-translation": "class GFG { static int arr[] = {100, 1000, 100, 1000, 1}; static int sum[] = new int[10000]; static int maxSumWO3Consec(int n) { if (sum[n] != -1) return sum[n]; if (n == 0) return sum[n] = 0; if (n == 1) return sum[n] = arr[0]; if (n == 2) return sum[n] = arr[1] + arr[0]; return sum[n] = Math.max(Math.max(maxSumWO3Consec(n - 1), maxSumWO3Consec(n - 2) + arr[n - 1]), arr[n - 2] + arr[n - 1] + maxSumWO3Consec(n - 3)); } public static void main(String[] args) { int n = arr.length; Arrays.fill(sum, -1); System.out.println(maxSumWO3Consec(n)); } }", "src": "class\nGFG \n{ \n\nstatic\nint\narr[] = {\n100\n, \n1000\n, \n100\n, \n1000\n, \n1\n}; \nstatic\nint\nsum[] = \nnew\nint\n[\n10000\n]; \n\n\n\n\nstatic\nint\nmaxSumWO3Consec(\nint\nn) \n{ \n\nif\n(sum[n] != -\n1\n) \n\nreturn\nsum[n]; \n\n\n\n\n\nif\n(n == \n0\n) \n\nreturn\nsum[n] = \n0\n; \n\n\nif\n(n == \n1\n) \n\nreturn\nsum[n] = arr[\n0\n]; \n\n\nif\n(n == \n2\n) \n\nreturn\nsum[n] = arr[\n1\n] + arr[\n0\n]; \n\n\n\n\n\n\nreturn\nsum[n] = Math.max(Math.max(maxSumWO3Consec(n - \n1\n), \n\nmaxSumWO3Consec(n - \n2\n) + arr[n - \n1\n]), \n\narr[n - \n2\n] + arr[n - \n1\n] + maxSumWO3Consec(n - \n3\n)); \n\n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = arr.length; \n\nArrays.fill(sum, -\n1\n); \n\nSystem.out.println(maxSumWO3Consec(n)); \n} \n}", "index": 163, "complexity": "1"}
{"back-translation": "class GFG { static int maximumSegments(int n, int a, int b, int c) { int dp[] = new int[n + 10]; Arrays.fill(dp, -1); dp[0] = 0; for (int i = 0; i < n; i++) { if(dp[i] != -1) { if (i + a <= n) dp[i + a] = Math.max(dp[i] + 1, dp[i + a]); if (i + b <= n) dp[i + b] = Math.max(dp[i] + 1, dp[i + b]); if (i + c <= n) dp[i + c] = Math.max(dp[i] + 1, dp[i + c]); } } return dp[n]; } public static void main(String arg[]) { int n = 7, a = 5, b = 2, c = 5; System.out.print(maximumSegments(n, a, b, c)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\nmaximumSegments(\nint\nn, \nint\na, \n\nint\nb, \nint\nc) \n\n{ \n\n\n\n\n\nint\ndp[] = \nnew\nint\n[n + \n10\n]; \n\n\n\n\nArrays.fill(dp, -\n1\n); \n\n\n\n\n\n\ndp[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(dp[i] != -\n1\n) \n\n{ \n\n\n\n\nif\n(i + a <= n ) \n\n\ndp[i + a] = Math.max(dp[i] + \n1\n, \n\ndp[i + a]); \n\n\nif\n(i + b <= n ) \n\n\ndp[i + b] = Math.max(dp[i] + \n1\n, \n\ndp[i + b]); \n\n\nif\n(i + c <= n ) \n\n\ndp[i + c] = Math.max(dp[i] + \n1\n, \n\ndp[i + c]); \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nn = \n7\n, a = \n5\n, b = \n2\n, c = \n5\n; \n\nSystem.out.print(maximumSegments(n, a, b, c)); \n\n} \n}", "index": 164, "complexity": "1"}
{"back-translation": "class RearrangeArray { void rearrangeUtil(int arr[], int n, int i) { int val = -(i + 1); i = arr[i] - 1; while (arr[i] > 0) { int new_i = arr[i] - 1; arr[i] = val; val = -(i + 1); i = new_i; } } void rearrange(int arr[], int n) { int i; for (i = 0; i < n; i++) arr[i]++; for (i = 0; i < n; i++) { if (arr[i] > 0) rearrangeUtil(arr, n, i); } for (i = 0; i < n; i++) arr[i] = (-arr[i]) - 1; } void printArray(int arr[], int n) { int i; for (i = 0; i < n; i++) System.out.print(arr[i] + \" \"); System.out.println(\"\"); } public static void main(String[] args) { RearrangeArray arrange = new RearrangeArray(); int arr[] = { 2, 0, 1, 4, 5, 3 }; int n = arr.length; System.out.println(\"Given array is \"); arrange.printArray(arr, n); arrange.rearrange(arr, n); System.out.println(\"Modified array is \"); arrange.printArray(arr, n); } }", "src": "class\nRearrangeArray { \n\n\n\n\n\n\n\n\n\nvoid\nrearrangeUtil(\nint\narr[], \nint\nn, \nint\ni) \n\n{ \n\n\n\n\n\n\nint\nval = -(i + \n1\n); \n\n\n\n\n\n\ni = arr[i] - \n1\n; \n\n\n\n\nwhile\n(arr[i] > \n0\n) { \n\n\n\n\n\nint\nnew_i = arr[i] - \n1\n; \n\n\n\n\narr[i] = val; \n\n\n\n\nval = -(i + \n1\n); \n\ni = new_i; \n\n} \n\n} \n\n\n\n\n\n\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i]++; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\n\n\n\n\nif\n(arr[i] > \n0\n) \n\nrearrangeUtil(arr, n, i); \n\n} \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = (-arr[i]) - \n1\n; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n}", "index": 165, "complexity": "1"}
{"back-translation": "class GFG { final int MAX = 1000000; static int breakSum(int n) { int dp[] = new int[n+1]; dp[0] = 0; dp[1] = 1; for (int i = 2; i <= n; i++) dp[i] = Math.max(dp[i/2] + dp[i/3] + dp[i/4], i); return dp[n]; } public static void main(String[] args) { int n = 24; System.out.println(breakSum(n)); } }", "src": "class\nGFG { \n\n\nfinal\nint\nMAX = \n1000000\n; \n\n\n\n\nstatic\nint\nbreakSum(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n+\n1\n]; \n\n\n\n\ndp[\n0\n] = \n0\n; dp[\n1\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni=\n2\n; i<=n; i++) \n\ndp[i] = Math.max(dp[i/\n2\n] + dp[i/\n3\n] + dp[i/\n4\n], i); \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\nn = \n24\n; \n\nSystem.out.println(breakSum(n)); \n\n} \n}", "index": 166, "complexity": "1"}
{"back-translation": "class GFG { public static int maxSum(int[][] grid, int n) { int incl = Math.max(grid[0][0], grid[1][0]); int excl = 0, excl_new; for (int i = 1; i < n; i++) { excl_new = Math.max(excl, incl); incl = excl + Math.max(grid[0][i], grid[1][i]); excl = excl_new; } return Math.max(excl, incl); } public static void main(String[] args) { int grid[][] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}}; int n = 5; System.out.println(maxSum(grid, n)); } }", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nmaxSum(\nint\ngrid[][], \nint\nn) \n\n{ \n\n\n\n\n\nint\nincl = Math.max(grid[\n0\n][\n0\n], grid[\n1\n][\n0\n]); \n\n\n\n\nint\nexcl = \n0\n, excl_new; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++ ) \n\n{ \n\n\n\n\n\nexcl_new = Math.max(excl, incl); \n\n\n\n\n\n\nincl = excl + Math.max(grid[\n0\n][i], grid[\n1\n][i]); \n\n\n\n\nexcl = excl_new; \n\n} \n\n\n\n\n\n\nreturn\nMath.max(excl, incl); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ngrid[][] = {{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n}, \n\n{ \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}}; \n\n\nint\nn = \n5\n; \n\nSystem.out.println(maxSum(grid, n)); \n\n} \n\n}", "index": 167, "complexity": "1"}
{"back-translation": "class GFG { public static int findLength(String str, int n) { int current_sum = 0; int max_sum = 0; for (int i = 0; i < n; i++) { current_sum += (str.charAt(i) == '0' ? 1 : -1); if (current_sum < 0) current_sum = 0; max_sum = Math.max(current_sum, max_sum); } return max_sum == 0 ? -1 : max_sum; } public static void main(String[] args) { String str = \"11000010001\"; int n = str.length(); System.out.println(findLength(str, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nfindLength(String str, \nint\nn) \n\n{ \n\n\nint\ncurrent_sum = \n0\n; \n\nint\nmax_sum = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\ncurrent_sum += (str.charAt(i) == \n'0'\n? \n1\n: -\n1\n); \n\n\nif\n(current_sum < \n0\n) \n\ncurrent_sum = \n0\n; \n\n\n\n\nmax_sum = Math.max(current_sum, max_sum); \n\n} \n\n\n\n\n\nreturn\nmax_sum == \n0\n? -\n1\n: max_sum; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"11000010001\"\n; \n\nint\nn = str.length(); \n\n\nSystem.out.println(findLength(str, n)); \n\n} \n}", "index": 168, "complexity": "1"}
{"back-translation": "public class GFG {\n    static int minTimeForWritingChars(int N, int insert, int remove, int copy) {\n        if (N == 0) return 0;\n        if (N == 1) return insert;\n        int dp[] = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            if (i % 2 == 0) dp[i] = Math.min(dp[i - 1] + insert, dp[i / 2] + copy);\n            else dp[i] = Math.min(dp[i - 1] + insert, dp[(i + 1) / 2] + copy + remove);\n        }\n        return dp[N];\n    }\n    public static void main(String[] args) {\n        int N = 9;\n        int insert = 1, remove = 2, copy = 1;\n        System.out.println(minTimeForWritingChars(N, insert, remove, copy));\n    }\n}", "src": "public\nclass\nGFG{ \n\n\n\n\n\n\nstatic\nint\nminTimeForWritingChars(\nint\nN, \nint\ninsert, \n\nint\nremove, \nint\ncopy) \n\n{ \n\nif\n(N == \n0\n) \n\nreturn\n0\n; \n\nif\n(N == \n1\n) \n\nreturn\ninsert; \n\n\n\n\nint\ndp[] = \nnew\nint\n[N + \n1\n]; \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= N; i++) \n\n{ \n\n\n\nif\n(i % \n2\n== \n0\n) \n\ndp[i] = Math.min(dp[i-\n1\n] + insert, dp[i/\n2\n] + copy); \n\n\n\n\nelse\n\ndp[i] = Math.min(dp[i-\n1\n] + insert, \n\ndp[(i+\n1\n)/\n2\n] + copy + remove); \n\n} \n\nreturn\ndp[N]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String []args) \n\n{ \n\nint\nN = \n9\n; \n\nint\ninsert = \n1\n, remove = \n2\n, copy = \n1\n; \n\nSystem.out.println(minTimeForWritingChars(N, insert,remove, copy)); \n\n} \n\n\n}", "index": 169, "complexity": "1"}
{"back-translation": "class GFG {\n    public static int sumOfSubstrings(String num) {\n        int n = num.length();\n        int[] sumofdigit = new int[n];\n        sumofdigit[0] = num.charAt(0) - '0';\n        int res = sumofdigit[0];\n        for (int i = 1; i < n; i++) {\n            int numi = num.charAt(i) - '0';\n            sumofdigit[i] = (i + 1) * numi + 10 * sumofdigit[i - 1];\n            res += sumofdigit[i];\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        String num = \"1234\";\n        System.out.println(sumOfSubstrings(num));\n    }\n}", "src": "class\nGFG{ \n\n\n\n\npublic\nstatic\nint\nsumOfSubstrings(String num) \n\n{ \n\nint\nn = num.length(); \n\n\n\n\nint\nsumofdigit[] = \nnew\nint\n[n]; \n\n\n\n\nsumofdigit[\n0\n] = num.charAt(\n0\n)-\n'0'\n; \n\nint\nres = sumofdigit[\n0\n]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nint\nnumi = num.charAt(i)-\n'0'\n; \n\n\n\n\nsumofdigit[i] = (i+\n1\n) * numi + \n\n10\n* sumofdigit[i-\n1\n]; \n\n\n\n\nres += sumofdigit[i]; \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString num = \n\"1234\"\n; \n\n\nSystem.out.println(sumOfSubstrings(num)); \n\n\n} \n}", "index": 170, "complexity": "1"}
{"back-translation": "class GFG { static int maxLoot(int[] hval, int n) { if (n == 0) return 0; if (n == 1) return hval[0]; if (n == 2) return Math.max(hval[0], hval[1]); int[] dp = new int[n]; dp[0] = hval[0]; dp[1] = Math.max(hval[0], hval[1]); for (int i = 2; i < n; i++) dp[i] = Math.max(hval[i] + dp[i-2], dp[i-1]); return dp[n-1]; } public static void main(String[] args) { int hval[] = { 6, 7, 1, 3, 8, 2, 4 }; int n = hval.length; System.out.println(\"Maximum loot value : \" + maxLoot(hval, n)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\nif\n(n == \n1\n) \n\nreturn\nhval[\n0\n]; \n\nif\n(n == \n2\n) \n\nreturn\nMath.max(hval[\n0\n], hval[\n1\n]); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n]; \n\n\n\n\ndp[\n0\n] = hval[\n0\n]; \n\ndp[\n1\n] = Math.max(hval[\n0\n], hval[\n1\n]); \n\n\n\n\nfor\n(\nint\ni = \n2\n; i<n; i++) \n\ndp[i] = Math.max(hval[i]+dp[i-\n2\n], dp[i-\n1\n]); \n\n\nreturn\ndp[n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n}", "index": 171, "complexity": "1"}
{"back-translation": "class GFG { static int maxLoot(int hval[], int n) { if (n == 0) return 0; int value1 = hval[0]; if (n == 1) return value1; int value2 = Math.max(hval[0], hval[1]); if (n == 2) return value2; int max_val = 0; for (int i = 2; i < n; i++) { max_val = Math.max(hval[i] + value1, value2); value1 = value2; value2 = max_val; } return max_val; } public static void main(String[] args) { int hval[] = { 6, 7, 1, 3, 8, 2, 4 }; int n = hval.length; System.out.println(\"Maximum loot value : \" + maxLoot(hval, n)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\n\nint\nvalue1 = hval[\n0\n]; \n\nif\n(n == \n1\n) \n\nreturn\nvalue1; \n\n\nint\nvalue2 = Math.max(hval[\n0\n], hval[\n1\n]); \n\nif\n(n == \n2\n) \n\nreturn\nvalue2; \n\n\n\n\nint\nmax_val = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n2\n; i<n; i++) \n\n{ \n\nmax_val = Math.max(hval[i]+value1, value2); \n\nvalue1 = value2; \n\nvalue2 = max_val; \n\n} \n\n\nreturn\nmax_val; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n}", "index": 172, "complexity": "1"}
{"back-translation": "class GFG {\n    static int countWays(int n) {\n        int DP[] = new int[n + 1];\n        DP[0] = DP[1] = DP[2] = 1;\n        DP[3] = 2;\n        for (int i = 4; i <= n; i++)\n            DP[i] = DP[i - 1] + DP[i - 3] + DP[i - 4];\n        return DP[n];\n    }\n\n    public static void main(String[] args) {\n        int n = 10;\n        System.out.println(countWays(n));\n    }\n}", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ncountWays(\nint\nn) \n\n{ \n\nint\nDP[] = \nnew\nint\n[n + \n1\n]; \n\n\n\n\nDP[\n0\n] = DP[\n1\n] = DP[\n2\n] = \n1\n; \n\nDP[\n3\n] = \n2\n; \n\n\n\n\nfor\n(\nint\ni = \n4\n; i <= n; i++) \n\nDP[i] = DP[i - \n1\n] + DP[i - \n3\n] \n\n+ DP[i - \n4\n]; \n\n\nreturn\nDP[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(countWays(n)); \n\n} \n}", "index": 173, "complexity": "1"}
{"back-translation": "public class GFG { static long countWays(int n) { long[][] dp = new long[2][n + 1]; dp[0][1] = 1; dp[1][1] = 2; for (int i = 2; i <= n; i++) { dp[0][i] = dp[0][i - 1] + dp[1][i - 1]; dp[1][i] = dp[0][i - 1] * 2 + dp[1][i - 1]; } return dp[0][n] + dp[1][n]; } public static void main(String[] args) { int n = 5; System.out.print(\"Total no of ways with n = \" + n + \" are: \" + countWays(n)); } }", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nlong\ncountWays(\nint\nn) { \n\nlong\ndp[][] = \nnew\nlong\n[\n2\n][n + \n1\n]; \n\n\n\n\ndp[\n0\n][\n1\n] = \n1\n; \n\ndp[\n1\n][\n1\n] = \n2\n; \n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\n\n\n\n\n\ndp[\n0\n][i] = dp[\n0\n][i - \n1\n] + dp[\n1\n][i - \n1\n]; \n\n\n\n\n\n\ndp[\n1\n][i] = dp[\n0\n][i - \n1\n] * \n2\n+ dp[\n1\n][i - \n1\n]; \n\n} \n\n\n\n\nreturn\ndp[\n0\n][n] + dp[\n1\n][n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nint\nn = \n5\n; \n\nSystem.out.print(\n\"Total no of ways with n = \"\n+ n \n\n+ \n\" are: \"\n+ countWays(n)); \n\n} \n\n}", "index": 174, "complexity": "1"}
{"back-translation": "class GFG { static int countWays(int n, int m) { int count[] = new int[n + 1]; count[0] = 0; int i; for (i = 1; i <= n; i++) { if (i > m) count[i] = count[i - 1] + count[i - m]; else if (i < m) count[i] = 1; else count[i] = 2; } return count[n]; } public static void main(String[] args) { int n = 7; int m = 4; System.out.println(\"Number of ways = \" + countWays(n, m)); } }", "src": "class\nGFG { \n\n\n\nstatic\nint\ncountWays(\nint\nn, \nint\nm) \n\n{ \n\n\n\n\n\nint\ncount[] = \nnew\nint\n[n + \n1\n]; \n\ncount[\n0\n] = \n0\n; \n\n\n\n\nint\ni; \n\nfor\n(i = \n1\n; i <= n; i++) { \n\n\n\nif\n(i > m) \n\ncount[i] = count[i - \n1\n] + count[i - m]; \n\n\n\n\nelse\nif\n(i < m) \n\ncount[i] = \n1\n; \n\n\n\n\nelse\n\ncount[i] = \n2\n; \n\n} \n\n\n\n\nreturn\ncount[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n7\n; \n\nint\nm = \n4\n; \n\nSystem.out.println(\n\"Number of ways = \"\n\n+ countWays(n, m)); \n\n} \n}", "index": 175, "complexity": "1"}
{"back-translation": "class Grid { static int count(int n) { int[] dp = new int[n + 1]; dp[0] = 0; for (int i = 1; i <= n; i++) { if (i >= 1 && i <= 3) dp[i] = 1; else if (i == 4) dp[i] = 2; else { dp[i] = dp[i - 1] + dp[i - 4]; } } return dp[n]; } public static void main(String[] args) { int n = 5; System.out.println(\"Count of ways is: \" + count(n)); } }", "src": "class\nGrid \n{ \n\n\n\n\n\nstatic\nint\ncount(\nint\nn) \n\n{ \n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\ndp[\n0\n] = \n0\n; \n\n\n\nfor\n(\nint\ni=\n1\n;i<=n;i++) \n\n{ \n\n\n\nif\n(i >= \n1\n&& i <= \n3\n) \n\ndp[i] = \n1\n; \n\nelse\nif\n(i==\n4\n) \n\ndp[i] = \n2\n; \n\n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\ndp[i] = dp[i-\n1\n] + dp[i-\n4\n]; \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nSystem.out.println(\n\"Count of ways is: \"\n+ count(n)); \n\n} \n}", "index": 176, "complexity": "1"}
{"back-translation": "class GFG { static int nonDecNums(int n) { int[][] a = new int[n + 1][10]; for (int i = 0; i <= 9; i++) a[0][i] = 1; for (int i = 1; i <= n; i++) a[i][9] = 1; for (int i = 1; i <= n; i++) for (int j = 8; j >= 0; j--) a[i][j] = a[i - 1][j] + a[i][j + 1]; return a[n][0]; } public static void main(String[] args) { int n = 2; System.out.println(\"Non-decreasing digits = \" + nonDecNums(n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nnonDecNums(\nint\nn) \n\n{ \n\n\n\n\n\nint\n[][] a = \nnew\nint\n[n + \n1\n][\n10\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= \n9\n; i++) \n\na[\n0\n][i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\na[i][\n9\n] = \n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfor\n(\nint\nj = \n8\n; j >= \n0\n; j--) \n\na[i][j] = a[i - \n1\n][j] + a[i][j + \n1\n]; \n\n\nreturn\na[n][\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Non-decreasing digits = \"\n+ nonDecNums(n)); \n\n} \n}", "index": 177, "complexity": "1"}
{"back-translation": "class GFG { static int maxRevenue(int m, int[] x, int[] revenue, int n, int t) { int[] maxRev = new int[m + 1]; for (int i = 0; i < m + 1; i++) maxRev[i] = 0; int nxtbb = 0; for (int i = 1; i <= m; i++) { if (nxtbb < n) { if (x[nxtbb] != i) maxRev[i] = maxRev[i - 1]; else { if (i <= t) maxRev[i] = Math.max(maxRev[i - 1], revenue[nxtbb]); else maxRev[i] = Math.max(maxRev[i - t - 1] + revenue[nxtbb], maxRev[i - 1]); nxtbb++; } } else maxRev[i] = maxRev[i - 1]; } return maxRev[m]; } public static void main(String[] args) { int m = 20; int[] x = new int[]{6, 7, 12, 13, 14}; int[] revenue = new int[]{5, 6, 5, 3, 1}; int n = x.length; int t = 5; System.out.println(maxRevenue(m, x, revenue, n, t)); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nmaxRevenue(\nint\nm, \nint\n[] x, \n\nint\n[] revenue, \n\nint\nn, \nint\nt) \n{ \n\n\n\n\n\n\nint\n[] maxRev = \nnew\nint\n[m + \n1\n]; \n\nfor\n(\nint\ni = \n0\n; i < m + \n1\n; i++) \n\nmaxRev[i] = \n0\n; \n\n\n\n\n\n\nint\nnxtbb = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\n{ \n\n\n\n\n\nif\n(nxtbb < n) \n\n{ \n\n\n\n\n\n\n\nif\n(x[nxtbb] != i) \n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n\n\n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\nif\n(i <= t) \n\nmaxRev[i] = Math.max(maxRev[i - \n1\n], \n\nrevenue[nxtbb]); \n\n\n\n\n\n\nelse\n\nmaxRev[i] = Math.max(maxRev[i - t - \n1\n] + \n\nrevenue[nxtbb], \n\nmaxRev[i - \n1\n]); \n\n\nnxtbb++; \n\n} \n\n} \n\nelse\n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n} \n\n\nreturn\nmaxRev[m]; \n} \n\n\npublic\nstatic\nvoid\nmain(String []args) \n{ \n\nint\nm = \n20\n; \n\nint\n[] x = \nnew\nint\n[]{\n6\n, \n7\n, \n12\n, \n13\n, \n14\n}; \n\nint\n[] revenue = \nnew\nint\n[]{\n5\n, \n6\n, \n5\n, \n3\n, \n1\n}; \n\nint\nn = x.length; \n\nint\nt = \n5\n; \n\nSystem.out.println(maxRevenue(m, x, revenue, n, t)); \n} \n}", "index": 178, "complexity": "1"}
{"back-translation": "public class Main {\n    public static void rearrange(int arr[], int n) {\n        int max_ele = arr[n - 1];\n        int min_ele = arr[0];\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                arr[i] = max_ele;\n                max_ele -= 1;\n            } else {\n                arr[i] = min_ele;\n                min_ele += 1;\n            }\n        }\n    }\n    public static void main(String args[]) {\n        int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        int n = arr.length;\n        System.out.println(\"Original Array\");\n        for (int i = 0; i < n; i++)\n            System.out.print(arr[i] + \" \");\n        rearrange(arr, n);\n        System.out.print(\"\\nModified Array\\n\");\n        for (int i = 0; i < n; i++)\n            System.out.print(arr[i] + \" \");\n    }\n}", "src": "public\nclass\nMain { \n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\nmax_ele = arr[n - \n1\n]; \n\nint\nmin_ele = arr[\n0\n]; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\nif\n(i % \n2\n== \n0\n) { \n\narr[i] = max_ele; \n\nmax_ele -= \n1\n; \n\n} \n\n\n\n\nelse\n{ \n\narr[i] = min_ele; \n\nmin_ele += \n1\n; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Original Array\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"\\nModified Array\\n\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 179, "complexity": "1"}
{"back-translation": "public class LisTree { static class node { int data, liss; node left, right; public node(int data) { this.data = data; this.liss = 0; } } static int liss(node root) { if (root == null) return 0; if (root.liss != 0) return root.liss; if (root.left == null && root.right == null) return root.liss = 1; int liss_excl = liss(root.left) + liss(root.right); int liss_incl = 1; if (root.left != null) { liss_incl += (liss(root.left.left) + liss(root.left.right)); } if (root.right != null) { liss_incl += (liss(root.right.left) + liss(root.right.right)); } return root.liss = Math.max(liss_excl, liss_incl); } public static void main(String[] args) { node root = new node(20); root.left = new node(8); root.left.left = new node(4); root.left.right = new node(12); root.left.right.left = new node(10); root.left.right.right = new node(14); root.right = new node(22); root.right.right = new node(25); System.out.println('Size of the Largest Independent Set is ' + liss(root)); } }", "src": "public\nclass\nLisTree \n{ \n\n\n\nstatic\nclass\nnode \n\n{ \n\nint\ndata, liss; \n\nnode left, right; \n\n\npublic\nnode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.liss = \n0\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nliss(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root.liss != \n0\n) \n\nreturn\nroot.liss; \n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\nroot.liss = \n1\n; \n\n\n\n\n\n\nint\nliss_excl = liss(root.left) + liss(root.right); \n\n\n\n\n\n\nint\nliss_incl = \n1\n; \n\nif\n(root.left != \nnull\n) \n\n{ \n\nliss_incl += (liss(root.left.left) + liss(root.left.right)); \n\n} \n\nif\n(root.right != \nnull\n) \n\n{ \n\nliss_incl += (liss(root.right.left) + liss(root.right.right)); \n\n} \n\n\n\n\n\n\nreturn\nroot.liss = Math.max(liss_excl, liss_incl); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\n\n\nnode root = \nnew\nnode(\n20\n); \n\nroot.left = \nnew\nnode(\n8\n); \n\nroot.left.left = \nnew\nnode(\n4\n); \n\nroot.left.right = \nnew\nnode(\n12\n); \n\nroot.left.right.left = \nnew\nnode(\n10\n); \n\nroot.left.right.right = \nnew\nnode(\n14\n); \n\nroot.right = \nnew\nnode(\n22\n); \n\nroot.right.right = \nnew\nnode(\n25\n); \n\nSystem.out.println(\n\"Size of the Largest Independent Set is \"\n+ liss(root)); \n\n} \n}", "index": 180, "complexity": "1"}
{"back-translation": "class GFG { static int max(int x, int y) { return (x > y ? x : y); } static int maxTasks(int[] high, int[] low, int n) { int[] task_dp = new int[n + 1]; task_dp[0] = 0; task_dp[1] = high[0]; for (int i = 2; i <= n; i++) task_dp[i] = Math.max(high[i - 1] + task_dp[i - 2], low[i - 1] + task_dp[i - 1]); return task_dp[n]; } public static void main(String[] args) { int n = 5; int[] high = {3, 6, 8, 7, 6}; int[] low = {1, 5, 4, 5, 3}; System.out.println(maxTasks(high, low, n)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmax(\nint\nx, \nint\ny) \n{ \n\nreturn\n(x > y ? x : y); \n} \n\n\n\nstatic\nint\nmaxTasks(\nint\n[]high, \nint\n[]low, \nint\nn) \n{ \n\n\n\n\n\nint\n[] task_dp = \nnew\nint\n[n + \n1\n]; \n\n\n\n\ntask_dp[\n0\n] = \n0\n; \n\n\n\n\n\n\ntask_dp[\n1\n] = high[\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) \n\ntask_dp[i] = Math.max(high[i - \n1\n] + task_dp[i - \n2\n], \n\nlow[i - \n1\n] + task_dp[i - \n1\n]); \n\nreturn\ntask_dp[n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n5\n; \n\nint\n[]high = {\n3\n, \n6\n, \n8\n, \n7\n, \n6\n}; \n\nint\n[]low = {\n1\n, \n5\n, \n4\n, \n5\n, \n3\n}; \n\nSystem.out.println(maxTasks(high, low, n)); \n} \n}", "index": 181, "complexity": "1"}
{"back-translation": "class GFG { static void segregateElements(int arr[], int n) { int temp[] = new int[n]; int j = 0; for (int i = 0; i < n; i++) if (arr[i] >= 0) temp[j++] = arr[i]; if (j == n || j == 0) return; for (int i = 0; i < n; i++) if (arr[i] < 0) temp[j++] = arr[i]; for (int i = 0; i < n; i++) arr[i] = temp[i]; } public static void main(String arg[]) { int arr[] = { 1, -1, -3, -2, 7, 5, 11, 6 }; int n = arr.length; segregateElements(arr, n); for (int i = 0; i < n; i++) System.out.print(arr[i] + \" \"); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\nsegregateElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\nint\ntemp[] = \nnew\nint\n[n]; \n\n\n\n\n\n\nint\nj = \n0\n; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] >= \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n\n\n\n\nif\n(j == n || j == \n0\n) \n\nreturn\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = { \n1\n, -\n1\n, -\n3\n, -\n2\n, \n7\n, \n5\n, \n11\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nsegregateElements(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 182, "complexity": "1"}
{"back-translation": "class Node { int key; Node left, right; public Node(int item) { key = item; left = right = null; } } class BinaryTree { Node root; BinaryTree() { root = null; } void printPostorder(Node node) { if (node == null) return; printPostorder(node.left); printPostorder(node.right); System.out.print(node.key + \" \"); } void printInorder(Node node) { if (node == null) return; printInorder(node.left); System.out.print(node.key + \" \"); printInorder(node.right); } void printPreorder(Node node) { if (node == null) return; System.out.print(node.key + \" \"); printPreorder(node.left); printPreorder(node.right); } void printPostorder() { printPostorder(root); } void printInorder() { printInorder(root); } void printPreorder() { printPreorder(root); } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(4); tree.root.left.right = new Node(5); System.out.println(\"Preorder traversal of binary tree is \"); tree.printPreorder(); System.out.println(\"\\nInorder traversal of binary tree is \"); tree.printInorder(); System.out.println(\"\\nPostorder traversal of binary tree is \"); tree.printPostorder(); } }", "src": "class\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\nkey = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\n\n\nNode root; \n\n\nBinaryTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n\n\nvoid\nprintPostorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintPostorder(node.left); \n\n\n\n\nprintPostorder(node.right); \n\n\n\n\nSystem.out.print(node.key + \n\" \"\n); \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.key + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\n\n\nvoid\nprintPreorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nSystem.out.print(node.key + \n\" \"\n); \n\n\n\n\nprintPreorder(node.left); \n\n\n\n\nprintPreorder(node.right); \n\n} \n\n\n\n\nvoid\nprintPostorder() { printPostorder(root); } \n\nvoid\nprintInorder() { printInorder(root); } \n\nvoid\nprintPreorder() { printPreorder(root); } \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\n\nSystem.out.println(\n\"Preorder traversal of binary tree is \"\n); \n\ntree.printPreorder(); \n\n\nSystem.out.println(\n\"\\nInorder traversal of binary tree is \"\n); \n\ntree.printInorder(); \n\n\nSystem.out.println(\n\"\\nPostorder traversal of binary tree is \"\n); \n\ntree.printPostorder(); \n\n} \n}", "index": 183, "complexity": "1"}
{"back-translation": "class Solution { static class INT { int data; INT(int d) { data = d; } } static void findPostOrderUtil(int[] pre, int n, int minval, int maxval, INT preIndex) { if (preIndex.data == n) return; if (pre[preIndex.data] < minval || pre[preIndex.data] > maxval) { return; } int val = pre[preIndex.data]; preIndex.data++; findPostOrderUtil(pre, n, minval, val, preIndex); findPostOrderUtil(pre, n, val, maxval, preIndex); System.out.print(val + \" \"); } static void findPostOrder(int[] pre, int n) { INT preIndex = new INT(0); findPostOrderUtil(pre, n, Integer.MIN_VALUE, Integer.MAX_VALUE, preIndex); } public static void main(String args[]) { int pre[] = { 40, 30, 35, 80, 100 }; int n = pre.length; findPostOrder(pre, n); } }", "src": "class\nSolution \n{ \nstatic\nclass\nINT \n{ \n\nint\ndata; \n\nINT(\nint\nd) \n\n{ \n\ndata=d; \n\n} \n} \n\n\n\nstatic\nvoid\nfindPostOrderUtil(\nint\npre[], \nint\nn, \nint\nminval, \n\nint\nmaxval, INT preIndex) \n{ \n\n\n\n\n\n\n\n\nif\n(preIndex.data == n) \n\nreturn\n; \n\n\n\n\n\n\nif\n(pre[preIndex.data] < minval || pre[preIndex.data] > maxval) { \n\nreturn\n; \n\n} \n\n\n\n\n\n\n\n\n\n\nint\nval = pre[preIndex.data]; \n\npreIndex.data++; \n\n\n\n\n\n\nfindPostOrderUtil(pre, n, minval, val, preIndex); \n\n\n\n\n\n\nfindPostOrderUtil(pre, n, val, maxval, preIndex); \n\n\nSystem.out.print( val + \n\" \"\n); \n} \n\n\nstatic\nvoid\nfindPostOrder(\nint\npre[], \nint\nn) \n{ \n\n\n\n\n\n\n\n\n\n\nINT preIndex = \nnew\nINT(\n0\n); \n\n\nfindPostOrderUtil(pre, n, Integer.MIN_VALUE, \n\nInteger.MAX_VALUE, preIndex); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\npre[] = { \n40\n, \n30\n, \n35\n, \n80\n, \n100\n}; \n\n\nint\nn = pre.length; \n\n\n\n\nfindPostOrder(pre, n); \n} \n}", "index": 184, "complexity": "1"}
{"back-translation": "class Solution { static class Node { int data; Node left, right; } static class INT { int data; } static Node getNode(int data) { Node new_node = new Node(); new_node.data = data; new_node.left = new_node.right = null; return new_node; } static void storeInorderTraversal(Node root, java.util.Vector<Integer> arr) { if (root == null) return; storeInorderTraversal(root.left, arr); arr.add(root.data); storeInorderTraversal(root.right, arr); } static void replaceNodeWithSum(Node root, java.util.Vector<Integer> arr, INT i) { if (root == null) return; replaceNodeWithSum(root.left, arr, i); root.data = arr.get(i.data - 1) + arr.get(i.data + 1); i.data++; replaceNodeWithSum(root.right, arr, i); } static void replaceNodeWithSumUtil(Node root) { if (root == null) return; java.util.Vector<Integer> arr = new java.util.Vector<Integer>(); arr.add(0); storeInorderTraversal(root, arr); arr.add(0); INT i = new INT(); i.data = 1; replaceNodeWithSum(root, arr, i); } static void preorderTraversal(Node root) { if (root == null) return; System.out.print(root.data + \" \"); preorderTraversal(root.left); preorderTraversal(root.right); } public static void main(String args[]) { Node root = getNode(1); root.left = getNode(2); root.right = getNode(3); root.left.left = getNode(4); root.left.right = getNode(5); root.right.left = getNode(6); root.right.right = getNode(7); System.out.println(\"Preorder Traversal before tree modification:\"); preorderTraversal(root); replaceNodeWithSumUtil(root); System.out.println(\"\\nPreorder Traversal after tree modification:\"); preorderTraversal(root); } }", "src": "class\nSolution \n{ \n\n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nclass\nINT \n{ \n\nint\ndata; \n} \n\n\nstatic\nNode getNode(\nint\ndata) \n{ \n\n\n\nNode new_node =\nnew\nNode(); \n\n\n\n\nnew_node.data = data; \n\nnew_node.left = new_node.right = \nnull\n; \n\n\nreturn\nnew_node; \n} \n\n\n\nstatic\nvoid\nstoreInorderTraversal( Node root, \n\nVector<Integer> arr) \n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nstoreInorderTraversal(root.left, arr); \n\n\n\n\narr.add(root.data); \n\n\n\n\nstoreInorderTraversal(root.right, arr); \n} \n\n\n\nstatic\nvoid\nreplaceNodeWithSum( Node root, \n\nVector<Integer> arr, INT i) \n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nreplaceNodeWithSum(root.left, arr, i); \n\n\n\n\n\n\nroot.data = arr.get(i.data - \n1\n) + arr.get(i.data + \n1\n); \n\n\n\n\ni.data++; \n\n\n\n\nreplaceNodeWithSum(root.right, arr, i); \n} \n\n\n\n\nstatic\nvoid\nreplaceNodeWithSumUtil( Node root) \n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\nVector<Integer> arr= \nnew\nVector<Integer>(); \n\n\n\n\n\n\narr.add(\n0\n); \n\n\n\n\nstoreInorderTraversal(root, arr); \n\n\n\n\n\n\narr.add(\n0\n); \n\n\n\n\nINT i = \nnew\nINT(); \n\n\ni.data=\n1\n; \n\n\nreplaceNodeWithSum(root, arr, i); \n} \n\n\n\nstatic\nvoid\npreorderTraversal( Node root) \n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nSystem.out.print( root.data + \n\" \"\n); \n\n\n\n\npreorderTraversal(root.left); \n\n\n\n\npreorderTraversal(root.right); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nNode root = getNode(\n1\n); \n\n\nroot.left = getNode(\n2\n); \n\n\nroot.right = getNode(\n3\n); \n\n\nroot.left.left = getNode(\n4\n); \n\n\nroot.left.right = getNode(\n5\n); \n\n\nroot.right.left = getNode(\n6\n); \n\nroot.right.right = getNode(\n7\n); \n\n\nSystem.out.println( \n\"Preorder Traversal before tree modification:\"\n); \n\npreorderTraversal(root); \n\n\nreplaceNodeWithSumUtil(root); \n\n\nSystem.out.println(\n\"\\nPreorder Traversal after tree modification:\"\n); \n\npreorderTraversal(root); \n\n} \n}", "index": 185, "complexity": "1"}
{"back-translation": "class GFG { static void rearrange(int[] arr, int n) { int temp; for (int i = 0; i < n - 1; i++) { if (i % 2 == 0 && arr[i] > arr[i + 1]) { temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } if (i % 2 != 0 && arr[i] < arr[i + 1]) { temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } } static void printArray(int[] arr, int size) { for (int i = 0; i < size; i++) System.out.print(arr[i] + ", "src": "class\nGFG { \n\n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\nint\ntemp; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) { \n\nif\n(i % \n2\n== \n0\n&& arr[i] > arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\nif\n(i % \n2\n!= \n0\n&& arr[i] < arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n6\n, \n4\n, \n2\n, \n1\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.print(\n\"Before rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"After rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n} \n}", "index": 186, "complexity": "1"}
{"back-translation": "class Solution { static class Node { int data; Node left, right; } static Node temp = new Node(); static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.left = temp.right = null; return temp; } static Node leftMostNode(Node node) { while (node != null && node.left != null) node = node.left; return node; } static Node rightMostNode(Node node) { while (node != null && node.right != null) node = node.right; return node; } static Node findInorderRecursive(Node root, Node x ) { if (root==null) return null; if (root==x || (temp = findInorderRecursive(root.left,x))!=null || (temp = findInorderRecursive(root.right,x))!=null) { if (temp!=null) { if (root.left == temp) { System.out.print( \"Inorder Successor of \"+x.data); System.out.print( \" is \"+ root.data + \"\\n\"); return null; } } return root; } return null; } static void inorderSuccesor(Node root, Node x) { if (x.right != null) { Node inorderSucc = leftMostNode(x.right); System.out.print(\"Inorder Successor of \"+x.data+\" is \"); System.out.print(inorderSucc.data+\"\\n\"); } if (x.right == null) { int f = 0 ; Node rightMost = rightMostNode(root); if (rightMost == x) System.out.print(\"No inorder successor! Right most node.\\n\"); else findInorderRecursive(root, x); } } public static void main(String args[]) { Node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); root.right.right = newNode(6); inorderSuccesor(root, root.right); inorderSuccesor(root, root.left.left); inorderSuccesor(root, root.right.right); } }", "src": "class\nSolution \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode temp = \nnew\nNode(); \n\n\nstatic\nNode newNode(\nint\ndata) \n\n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode leftMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.left != \nnull\n) \n\nnode = node.left; \n\nreturn\nnode; \n} \n\n\nstatic\nNode rightMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.right != \nnull\n) \n\nnode = node.right; \n\nreturn\nnode; \n} \n\n\n\nstatic\nNode findInorderRecursive(Node root, Node x ) \n\n{ \n\nif\n(root==\nnull\n) \n\nreturn\nnull\n; \n\n\nif\n(root==x || (temp = findInorderRecursive(root.left,x))!=\nnull\n|| \n\n(temp = findInorderRecursive(root.right,x))!=\nnull\n) \n\n{ \n\nif\n(temp!=\nnull\n) \n\n{ \n\nif\n(root.left == temp) \n\n{ \n\nSystem.out.print( \n\"Inorder Successor of \"\n+x.data); \n\nSystem.out.print( \n\" is \"\n+ root.data + \n\"\\n\"\n); \n\nreturn\nnull\n; \n\n} \n\n} \n\n\nreturn\nroot; \n\n} \n\n\nreturn\nnull\n; \n} \n\n\n\nstatic\nvoid\ninorderSuccesor(Node root, Node x) \n\n{ \n\n\n\nif\n(x.right != \nnull\n) \n\n{ \n\nNode inorderSucc = leftMostNode(x.right); \n\nSystem.out.print(\n\"Inorder Successor of \"\n+x.data+\n\" is \"\n); \n\nSystem.out.print(inorderSucc.data+\n\"\\n\"\n); \n\n} \n\n\n\n\nif\n(x.right == \nnull\n) \n\n{ \n\nint\nf = \n0\n; \n\n\nNode rightMost = rightMostNode(root); \n\n\n\n\nif\n(rightMost == x) \n\nSystem.out.print(\n\"No inorder successor! Right most node.\\n\"\n); \n\nelse\n\nfindInorderRecursive(root, x); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\n\n\n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.right.right = newNode(\n6\n); \n\n\n\n\ninorderSuccesor(root, root.right); \n\n\n\n\ninorderSuccesor(root, root.left.left); \n\n\n\n\ninorderSuccesor(root, root.right.right); \n\n} \n}", "index": 187, "complexity": "1"}
{"back-translation": "class Solution { static int count = 0; static class Node { int data; Node left; Node right; } static Node newNode(int data) { Node node = new Node(); node.data = data; node.left = null; node.right = null; return (node); } static void NthInorder(Node node, int n) { if (node == null) return; if (count <= n) { NthInorder(node.left, n); count++; if (count == n) System.out.printf(\"%d \", node.data); NthInorder(node.right, n); } } public static void main(String args[]) { Node root = newNode(10); root.left = newNode(20); root.right = newNode(30); root.left.left = newNode(40); root.left.right = newNode(50); int n = 4; NthInorder(root, n); } }", "src": "class\nSolution \n{ \nstatic\nint\ncount =\n0\n; \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left; \n\nNode right; \n} \n\n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\n\nreturn\n(node); \n} \n\n\n\nstatic\nvoid\nNthInorder( Node node, \nint\nn) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\nif\n(count <= n) { \n\n\n\nNthInorder(node.left, n); \n\ncount++; \n\n\n\n\nif\n(count == n) \n\nSystem.out.printf(\n\"%d \"\n, node.data); \n\n\n\n\nNthInorder(node.right, n); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n10\n); \n\nroot.left = newNode(\n20\n); \n\nroot.right = newNode(\n30\n); \n\nroot.left.left = newNode(\n40\n); \n\nroot.left.right = newNode(\n50\n); \n\n\nint\nn = \n4\n; \n\n\nNthInorder(root, n); \n} \n}", "index": 188, "complexity": "1"}
{"back-translation": "public class NthNodePostOrder {\n    static int flag = 0;\n\n    public static void NthPostordernode(Node root, int N) {\n        if (root == null) return;\n\n        if (flag <= N) {\n            NthPostordernode(root.left, N);\n            NthPostordernode(root.right, N);\n            flag++;\n\n            if (flag == N) System.out.print(root.data);\n        }\n    }\n\n    public static void main(String args[]) {\n        Node root = new Node(25);\n        root.left = new Node(20);\n        root.right = new Node(30);\n        root.left.left = new Node(18);\n        root.left.right = new Node(22);\n        root.right.left = new Node(24);\n        root.right.right = new Node(32);\n\n        int N = 6;\n\n        NthPostordernode(root, N);\n    }\n}\n\nclass Node {\n    int data;\n    Node left, right;\n\n    Node(int data) {\n        this.data = data;\n    }\n};", "src": "public\nclass\nNthNodePostOrder { \n\n\nstatic\nint\nflag = \n0\n; \n\n\n\n\n\n\npublic\nstatic\nvoid\nNthPostordernode(Node root, \nint\nN) \n\n{ \n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nif\n(flag <= N) \n\n{ \n\n\n\nNthPostordernode(root.left, N); \n\n\n\nNthPostordernode(root.right, N); \n\nflag++; \n\n\n\nif\n(flag == N) \n\nSystem.out.print(root.data); \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root = \nnew\nNode(\n25\n); \n\nroot.left = \nnew\nNode(\n20\n); \n\nroot.right = \nnew\nNode(\n30\n); \n\nroot.left.left = \nnew\nNode(\n18\n); \n\nroot.left.right = \nnew\nNode(\n22\n); \n\nroot.right.left = \nnew\nNode(\n24\n); \n\nroot.right.right = \nnew\nNode(\n32\n); \n\n\nint\nN = \n6\n; \n\n\n\n\nNthPostordernode(root, N); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\n} \n};", "index": 189, "complexity": "1"}
{"back-translation": "class Node {\n\n    int data;\n    Node left, right;\n\n    public Node(int item) {\n        data = item;\n        left = right = null;\n    }\n}\n\nclass BinaryTree {\n\n    static Node root;\n\n    void printSpiral(Node node) {\n        if (node == null)\n            return;\n\n        Stack<Node> s1 = new Stack<Node>();\n        Stack<Node> s2 = new Stack<Node>();\n\n        s1.push(node);\n\n        while (!s1.empty() || !s2.empty()) {\n\n            while (!s1.empty()) {\n                Node temp = s1.peek();\n                s1.pop();\n                System.out.print(temp.data + \" \");\n\n                if (temp.right != null)\n                    s2.push(temp.right);\n                if (temp.left != null)\n                    s2.push(temp.left);\n            }\n\n            while (!s2.empty()) {\n                Node temp = s2.peek();\n                s2.pop();\n                System.out.print(temp.data + \" \");\n\n                if (temp.left != null)\n                    s1.push(temp.left);\n                if (temp.right != null)\n                    s1.push(temp.right);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node(1);\n        tree.root.left = new Node(2);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(7);\n        tree.root.left.right = new Node(6);\n        tree.root.right.left = new Node(5);\n        tree.root.right.right = new Node(4);\n\n        System.out.println(\"Spiral Order traversal of Binary Tree is \");\n        tree.printSpiral(root);\n    }\n}", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\n\n\n\nStack<Node> s1 = \nnew\nStack<Node>(); \n\n\n\nStack<Node> s2 = \nnew\nStack<Node>(); \n\n\n\n\ns1.push(node); \n\n\n\n\nwhile\n(!s1.empty() || !s2.empty()) { \n\n\n\n\n\nwhile\n(!s1.empty()) { \n\nNode temp = s1.peek(); \n\ns1.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n\n\nif\n(temp.right != \nnull\n) \n\ns2.push(temp.right); \n\n\nif\n(temp.left != \nnull\n) \n\ns2.push(temp.left); \n\n} \n\n\n\n\n\n\nwhile\n(!s2.empty()) { \n\nNode temp = s2.peek(); \n\ns2.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n\n\nif\n(temp.left != \nnull\n) \n\ns1.push(temp.left); \n\nif\n(temp.right != \nnull\n) \n\ns1.push(temp.right); \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral Order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(root); \n\n} \n}", "index": 190, "complexity": "1"}
{"back-translation": "public class GFG { static class Node { int data; Node left; Node right; Node(int data) { this.data = data; left = null; right = null; } } static void levelOrder(Node root) { if (root == null) return; Queue<Node> q = new LinkedList<>(); q.add(root); q.add(null); while (!q.isEmpty()) { Node curr = q.poll(); if (curr == null) { if (!q.isEmpty()) { q.add(null); System.out.println(); } } else { if (curr.left != null) q.add(curr.left); if (curr.right != null) q.add(curr.right); System.out.print(curr.data + \" \"); } } } public static void main(String[] args) { Node root = new Node(1); root.left = new Node(2); root.right = new Node(3); root.left.left = new Node(4); root.left.right = new Node(5); root.right.right = new Node(6); levelOrder(root); } }", "src": "public\nclass\nGFG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n\n\n\n\nstatic\nvoid\nlevelOrder(Node root) { \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\n\n\n\nq.add(root); \n\n\n\n\nq.add(\nnull\n); \n\n\n\n\n\n\nwhile\n(!q.isEmpty()) { \n\n\nNode curr = q.poll(); \n\n\n\n\n\n\nif\n(curr == \nnull\n) { \n\nif\n(!q.isEmpty()) { \n\nq.add(\nnull\n); \n\nSystem.out.println(); \n\n} \n\n} \nelse\n{ \n\n\n\nif\n(curr.left != \nnull\n) \n\nq.add(curr.left); \n\n\n\n\nif\n(curr.right != \nnull\n) \n\nq.add(curr.right); \n\n\nSystem.out.print(curr.data + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nlevelOrder(root); \n\n} \n}", "index": 191, "complexity": "1"}
{"back-translation": "class Node {\n\n    int data;\n    Node left, right;\n\n    Node(int item) {\n        data = item;\n        left = right;\n    }\n}\n\nclass BinaryTree {\n\n    Node root;\n\n    void reverseLevelOrder(Node node) {\n        Stack<Node> stack = new Stack<>();\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(node);\n        while (!queue.isEmpty()) {\n            node = queue.peek();\n            queue.remove();\n            stack.push(node);\n            if (node.right != null) {\n                queue.add(node.right);\n            }\n            if (node.left != null) {\n                queue.add(node.left);\n            }\n        }\n        while (!stack.isEmpty()) {\n            node = stack.peek();\n            System.out.print(node.data + \" \");\n            stack.pop();\n        }\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node(1);\n        tree.root.left = new Node(2);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(4);\n        tree.root.left.right = new Node(5);\n        tree.root.right.left = new Node(6);\n        tree.root.right.right = new Node(7);\n        System.out.println(\"Level Order traversal of binary tree is :\");\n        tree.reverseLevelOrder(tree.root);\n    }\n}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack(); \n\nQueue<Node> Q = \nnew\nLinkedList(); \n\nQ.add(node); \n\n\n\n\n\n\n\n\n\n\nwhile\n(Q.isEmpty() == \nfalse\n) \n\n{ \n\n\n\nnode = Q.peek(); \n\nQ.remove(); \n\nS.push(node); \n\n\n\n\nif\n(node.right != \nnull\n) \n\n\n\nQ.add(node.right); \n\n\n\n\nif\n(node.left != \nnull\n) \n\nQ.add(node.left); \n\n} \n\n\n\n\nwhile\n(S.empty() == \nfalse\n) \n\n{ \n\nnode = S.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nS.pop(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is :\"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n\n} \n}", "index": 192, "complexity": "1"}
{"back-translation": "class Node { int data; Node left, right; public Node(int item) { data = item; left = right = null; } } class BinaryTree { Node root; void printSpecificLevelOrder(Node node) { if (node == null) return; System.out.print(node.data); if (node.left != null) System.out.print(\" \" + node.left.data + \" \" + node.right.data); if (node.left.left == null) return; Queue<Node> q = new LinkedList<Node>(); q.add(node.left); q.add(node.right); Node first = null, second = null; while (!q.isEmpty()) { first = q.peek(); q.remove(); second = q.peek(); q.remove(); System.out.print(\" \" + first.left.data + \" \" + second.right.data); System.out.print(\" \" + first.right.data + \" \" + second.left.data); if (first.left.left != null) { q.add(first.left); q.add(second.right); q.add(first.right); q.add(second.left); } } } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(4); tree.root.left.right = new Node(5); tree.root.right.left = new Node(6); tree.root.right.right = new Node(7); tree.root.left.left.left = new Node(8); tree.root.left.left.right = new Node(9); tree.root.left.right.left = new Node(10); tree.root.left.right.right = new Node(11); tree.root.right.left.left = new Node(12); tree.root.right.left.right = new Node(13); tree.root.right.right.left = new Node(14); tree.root.right.right.right = new Node(15); tree.root.left.left.left.left = new Node(16); tree.root.left.left.left.right = new Node(17); tree.root.left.left.right.left = new Node(18); tree.root.left.left.right.right = new Node(19); tree.root.left.right.left.left = new Node(20); tree.root.left.right.left.right = new Node(21); tree.root.left.right.right.left = new Node(22); tree.root.left.right.right.right = new Node(23); tree.root.right.left.left.left = new Node(24); tree.root.right.left.left.right = new Node(25); tree.root.right.left.right.left = new Node(26); tree.root.right.left.right.right = new Node(27); tree.root.right.right.left.left = new Node(28); tree.root.right.right.left.right = new Node(29); tree.root.right.right.right.left = new Node(30); tree.root.right.right.right.right = new Node(31); System.out.println(\"Specific Level Order traversal of binary tree is \"); tree.printSpecificLevelOrder(tree.root); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nprintSpecificLevelOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nSystem.out.print(node.data); \n\n\n\n\nif\n(node.left != \nnull\n) \n\nSystem.out.print(\n\" \"\n+ node.left.data + \n\" \"\n+ node.right.data); \n\n\n\n\n\n\nif\n(node.left.left == \nnull\n) \n\nreturn\n; \n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\nq.add(node.left); \n\nq.add(node.right); \n\n\n\n\n\n\nNode first = \nnull\n, second = \nnull\n; \n\n\n\n\nwhile\n(!q.isEmpty()) \n\n{ \n\n\n\nfirst = q.peek(); \n\nq.remove(); \n\nsecond = q.peek(); \n\nq.remove(); \n\n\n\n\nSystem.out.print(\n\" \"\n+ first.left.data + \n\" \"\n+second.right.data); \n\nSystem.out.print(\n\" \"\n+ first.right.data + \n\" \"\n+second.left.data); \n\n\n\n\n\n\nif\n(first.left.left != \nnull\n) \n\n{ \n\nq.add(first.left); \n\nq.add(second.right); \n\nq.add(first.right); \n\nq.add(second.left); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\ntree.root.left.left.left = \nnew\nNode(\n8\n); \n\ntree.root.left.left.right = \nnew\nNode(\n9\n); \n\ntree.root.left.right.left = \nnew\nNode(\n10\n); \n\ntree.root.left.right.right = \nnew\nNode(\n11\n); \n\ntree.root.right.left.left = \nnew\nNode(\n12\n); \n\ntree.root.right.left.right = \nnew\nNode(\n13\n); \n\ntree.root.right.right.left = \nnew\nNode(\n14\n); \n\ntree.root.right.right.right = \nnew\nNode(\n15\n); \n\n\ntree.root.left.left.left.left = \nnew\nNode(\n16\n); \n\ntree.root.left.left.left.right = \nnew\nNode(\n17\n); \n\ntree.root.left.left.right.left = \nnew\nNode(\n18\n); \n\ntree.root.left.left.right.right = \nnew\nNode(\n19\n); \n\ntree.root.left.right.left.left = \nnew\nNode(\n20\n); \n\ntree.root.left.right.left.right = \nnew\nNode(\n21\n); \n\ntree.root.left.right.right.left = \nnew\nNode(\n22\n); \n\ntree.root.left.right.right.right = \nnew\nNode(\n23\n); \n\ntree.root.right.left.left.left = \nnew\nNode(\n24\n); \n\ntree.root.right.left.left.right = \nnew\nNode(\n25\n); \n\ntree.root.right.left.right.left = \nnew\nNode(\n26\n); \n\ntree.root.right.left.right.right = \nnew\nNode(\n27\n); \n\ntree.root.right.right.left.left = \nnew\nNode(\n28\n); \n\ntree.root.right.right.left.right = \nnew\nNode(\n29\n); \n\ntree.root.right.right.right.left = \nnew\nNode(\n30\n); \n\ntree.root.right.right.right.right = \nnew\nNode(\n31\n); \n\n\nSystem.out.println(\n\"Specific Level Order traversal of binary\"\n\n+\n\"tree is \"\n); \n\ntree.printSpecificLevelOrder(tree.root); \n\n} \n}", "index": 193, "complexity": "1"}
{"back-translation": "class Multiply {\n\n    static void modify(int[] arr, int n) {\n        if (n <= 1) {\n            return;\n        }\n\n        int prev = arr[0];\n        arr[0] = arr[0] * arr[1];\n\n        for (int i = 1; i < n - 1; i++) {\n            int curr = arr[i];\n            arr[i] = prev * arr[i + 1];\n            prev = curr;\n        }\n\n        arr[n - 1] = prev * arr[n - 1];\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {2, 3, 4, 5, 6};\n        int n = arr.length;\n        modify(arr, n);\n\n        for (int i = 0; i < n; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n}", "src": "class\nMultipy \n{ \n\nstatic\nvoid\nmodify(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nif\n(n <= \n1\n) \n\nreturn\n; \n\n\n\n\nint\nprev = arr[\n0\n]; \n\narr[\n0\n] = arr[\n0\n] * arr[\n1\n]; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<n-\n1\n; i++) \n\n{ \n\n\n\nint\ncurr = arr[i]; \n\n\n\n\narr[i] = prev * arr[i+\n1\n]; \n\n\n\n\nprev = curr; \n\n} \n\n\n\n\narr[n-\n1\n] = prev * arr[n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nmodify(arr, n); \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 194, "complexity": "1"}
{"back-translation": "class Node {\n    char data;\n    Node left, right;\n\n    Node(char item) {\n        data = item;\n        left = right = null;\n    }\n}\n\nclass Index {\n    int index;\n}\n\nclass BinaryTree {\n    Node root;\n    Index index_obj = new Index();\n\n    void storeAlternate(Node node, char arr[], Index index, int l) {\n        if (node == null) {\n            return;\n        }\n\n        storeAlternate(node.left, arr, index, l + 1);\n\n        if (l % 2 != 0) {\n            arr[index.index] = node.data;\n            index.index++;\n        }\n\n        storeAlternate(node.right, arr, index, l + 1);\n    }\n\n    void modifyTree(Node node, char arr[], Index index, int l) {\n        if (node == null) {\n            return;\n        }\n\n        modifyTree(node.left, arr, index, l + 1);\n\n        if (l % 2 != 0) {\n            node.data = arr[index.index];\n            index.index++;\n        }\n\n        modifyTree(node.right, arr, index, l + 1);\n    }\n\n    void reverse(char arr[], int n) {\n        int l = 0, r = n - 1;\n\n        while (l < r) {\n            char temp = arr[l];\n            arr[l] = arr[r];\n            arr[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    void reverseAlternate() {\n        reverseAlternate(root);\n    }\n\n    void reverseAlternate(Node node) {\n        char[] arr = new char[100];\n\n        storeAlternate(node, arr, index_obj, 0);\n\n        reverse(arr, index_obj.index);\n\n        index_obj.index = 0;\n\n        modifyTree(node, arr, index_obj, 0);\n    }\n\n    void printInorder() {\n        printInorder(root);\n    }\n\n    void printInorder(Node node) {\n        if (node == null) {\n            return;\n        }\n\n        printInorder(node.left);\n        System.out.print(node.data + \" \");\n        printInorder(node.right);\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n\n        tree.root = new Node('a');\n        tree.root.left = new Node('b');\n        tree.root.right = new Node('c');\n        tree.root.left.left = new Node('d');\n        tree.root.left.right = new Node('e');\n        tree.root.right.left = new Node('f');\n        tree.root.right.right = new Node('g');\n        tree.root.left.left.left = new Node('h');\n        tree.root.left.left.right = new Node('i');\n        tree.root.left.right.left = new Node('j');\n        tree.root.left.right.right = new Node('k');\n        tree.root.right.left.left = new Node('l');\n        tree.root.right.left.right = new Node('m');\n        tree.root.right.right.left = new Node('n');\n        tree.root.right.right.right = new Node('o');\n\n        System.out.println(\"Inorder Traversal of given tree\");\n        tree.printInorder();\n\n        tree.reverseAlternate();\n\n        System.out.println(\"\");\n        System.out.println(\"\");\n        System.out.println(\"Inorder Traversal of modified tree\");\n        tree.printInorder();\n    }\n}", "src": "class\nNode { \n\n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) { \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\n\nclass\nIndex { \n\n\nint\nindex; \n} \n\nclass\nBinaryTree { \n\n\nNode root; \n\nIndex index_obj = \nnew\nIndex(); \n\n\n\n\nvoid\nstoreAlternate(Node node, \nchar\narr[], Index index, \nint\nl) { \n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\nstoreAlternate(node.left, arr, index, l + \n1\n); \n\n\n\n\nif\n(l % \n2\n!= \n0\n) { \n\narr[index.index] = node.data; \n\nindex.index++; \n\n} \n\n\nstoreAlternate(node.right, arr, index, l + \n1\n); \n\n} \n\n\n\n\n\n\nvoid\nmodifyTree(Node node, \nchar\narr[], Index index, \nint\nl) { \n\n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\n\nmodifyTree(node.left, arr, index, l + \n1\n); \n\n\n\n\nif\n(l % \n2\n!= \n0\n) { \n\nnode.data = arr[index.index]; \n\n(index.index)++; \n\n} \n\n\n\n\nmodifyTree(node.right, arr, index, l + \n1\n); \n\n} \n\n\n\n\n\n\nvoid\nreverse(\nchar\narr[], \nint\nn) { \n\nint\nl = \n0\n, r = n - \n1\n; \n\nwhile\n(l < r) { \n\nchar\ntemp = arr[l]; \n\narr[l] = arr[r]; \n\narr[r] = temp; \n\nl++; \n\nr--; \n\n} \n\n} \n\n\nvoid\nreverseAlternate() { \n\nreverseAlternate(root); \n\n} \n\n\n\n\nvoid\nreverseAlternate(Node node) { \n\n\n\n\nchar\n[] arr = \nnew\nchar\n[\n100\n]; \n\n\n\n\nstoreAlternate(node, arr, index_obj, \n0\n); \n\n\n\n\n\n\n\nreverse(arr, index_obj.index); \n\n\n\n\nindex_obj.index = \n0\n; \n\nmodifyTree(node, arr, index_obj, \n0\n); \n\n} \n\n\nvoid\nprintInorder() { \n\nprintInorder(root); \n\n} \n\n\n\n\n\n\nvoid\nprintInorder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n'a'\n); \n\ntree.root.left = \nnew\nNode(\n'b'\n); \n\ntree.root.right = \nnew\nNode(\n'c'\n); \n\ntree.root.left.left = \nnew\nNode(\n'd'\n); \n\ntree.root.left.right = \nnew\nNode(\n'e'\n); \n\ntree.root.right.left = \nnew\nNode(\n'f'\n); \n\ntree.root.right.right = \nnew\nNode(\n'g'\n); \n\ntree.root.left.left.left = \nnew\nNode(\n'h'\n); \n\ntree.root.left.left.right = \nnew\nNode(\n'i'\n); \n\ntree.root.left.right.left = \nnew\nNode(\n'j'\n); \n\ntree.root.left.right.right = \nnew\nNode(\n'k'\n); \n\ntree.root.right.left.left = \nnew\nNode(\n'l'\n); \n\ntree.root.right.left.right = \nnew\nNode(\n'm'\n); \n\ntree.root.right.right.left = \nnew\nNode(\n'n'\n); \n\ntree.root.right.right.right = \nnew\nNode(\n'o'\n); \n\nSystem.out.println(\n\"Inorder Traversal of given tree\"\n); \n\ntree.printInorder(); \n\n\ntree.reverseAlternate(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Inorder Traversal of modified tree\"\n); \n\ntree.printInorder(); \n\n} \n}", "index": 195, "complexity": "1"}
{"back-translation": "class Sol { static class Node { char key; Node left, right; }; static void preorder(Node root1, Node root2, int lvl) { if(root1 == null || root2==null) return; if(lvl % 2 == 0) { char t = root1.key; root1.key = root2.key; root2.key = t; } preorder(root1.left, root2.right, lvl+1); preorder(root1.right, root2.left, lvl+1); } static void reverseAlternate(Node root) { preorder(root.left, root.right, 0); } static void printInorder(Node root) { if(root == null) return; printInorder(root.left); System.out.print( root.key + \" \"); printInorder(root.right); } static Node newNode(int key) { Node temp = new Node(); temp.left = temp.right = null; temp.key = (char)key; return temp; } public static void main(String args[]) { Node root = newNode('a'); root.left = newNode('b'); root.right = newNode('c'); root.left.left = newNode('d'); root.left.right = newNode('e'); root.right.left = newNode('f'); root.right.right = newNode('g'); root.left.left.left = newNode('h'); root.left.left.right = newNode('i'); root.left.right.left = newNode('j'); root.left.right.right = newNode('k'); root.right.left.left = newNode('l'); root.right.left.right = newNode('m'); root.right.right.left = newNode('n'); root.right.right.right = newNode('o'); System.out.print(\"Inorder Traversal of given tree\\n\"); printInorder(root); reverseAlternate(root); System.out.print(\"\\n\\nInorder Traversal of modified tree\\n\"); printInorder(root); } }", "src": "class\nSol \n{ \n\nstatic\nclass\nNode \n{ \n\nchar\nkey; \n\nNode left, right; \n}; \n\nstatic\nvoid\npreorder( Node root1, Node root2, \nint\nlvl) \n{ \n\n\n\nif\n(root1 == \nnull\n|| root2==\nnull\n) \n\nreturn\n; \n\n\n\n\nif\n(lvl % \n2\n== \n0\n) \n\n{ \n\nchar\nt = root1.key; \n\nroot1.key = root2.key; \n\nroot2.key = t; \n\n} \n\n\n\n\n\n\n\n\npreorder(root1.left, root2.right, lvl+\n1\n); \n\npreorder(root1.right, root2.left, lvl+\n1\n); \n} \n\n\n\nstatic\nvoid\nreverseAlternate( Node root) \n{ \n\npreorder(root.left, root.right, \n0\n); \n} \n\n\n\nstatic\nvoid\nprintInorder( Node root) \n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\nprintInorder(root.left); \n\nSystem.out.print( root.key + \n\" \"\n); \n\nprintInorder(root.right); \n} \n\n\nstatic\nNode newNode(\nint\nkey) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.left = temp.right = \nnull\n; \n\ntemp.key = (\nchar\n)key; \n\nreturn\ntemp; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n'a'\n); \n\nroot.left = newNode(\n'b'\n); \n\nroot.right = newNode(\n'c'\n); \n\nroot.left.left = newNode(\n'd'\n); \n\nroot.left.right = newNode(\n'e'\n); \n\nroot.right.left = newNode(\n'f'\n); \n\nroot.right.right = newNode(\n'g'\n); \n\nroot.left.left.left = newNode(\n'h'\n); \n\nroot.left.left.right = newNode(\n'i'\n); \n\nroot.left.right.left = newNode(\n'j'\n); \n\nroot.left.right.right = newNode(\n'k'\n); \n\nroot.right.left.left = newNode(\n'l'\n); \n\nroot.right.left.right = newNode(\n'm'\n); \n\nroot.right.right.left = newNode(\n'n'\n); \n\nroot.right.right.right = newNode(\n'o'\n); \n\n\nSystem.out.print(\n\"Inorder Traversal of given tree\\n\"\n); \n\nprintInorder(root); \n\n\nreverseAlternate(root); \n\n\nSystem.out.print(\n\"\\n\\nInorder Traversal of modified tree\\n\"\n); \n\nprintInorder(root); \n\n} \n}", "index": 196, "complexity": "1"}
{"back-translation": "class Node {\n\n    int data;\n    Node left, right;\n\n    Node(int item) {\n        data = item;\n        left = right;\n    }\n}\n\nclass BinaryTree {\n\n    Node root;\n    ArrayList<Integer> list = new ArrayList<Integer>();\n\n    ArrayList<Integer> postOrderIterative(Node node) {\n        Stack<Node> S = new Stack<Node>();\n\n        if (node == null)\n            return list;\n\n        S.push(node);\n        Node prev = null;\n\n        while (!S.isEmpty()) {\n            Node current = S.peek();\n\n            if (prev == null || prev.left == current || prev.right == current) {\n                if (current.left != null)\n                    S.push(current.left);\n                else if (current.right != null)\n                    S.push(current.right);\n                else {\n                    S.pop();\n                    list.add(current.data);\n                }\n            } else if (current.left == prev) {\n                if (current.right != null)\n                    S.push(current.right);\n                else {\n                    S.pop();\n                    list.add(current.data);\n                }\n            } else if (current.right == prev) {\n                S.pop();\n                list.add(current.data);\n            }\n            prev = current;\n        }\n\n        return list;\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n\n        tree.root = new Node(1);\n        tree.root.left = new Node(2);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(4);\n        tree.root.left.right = new Node(5);\n        tree.root.right.left = new Node(6);\n        tree.root.right.right = new Node(7);\n\n        ArrayList<Integer> mylist = tree.postOrderIterative(tree.root);\n\n        System.out.println(\"Post order traversal of binary tree is :\");\n        System.out.println(mylist);\n    }\n}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nArrayList<Integer> list = \nnew\nArrayList<Integer>(); \n\n\n\n\n\n\nArrayList<Integer> postOrderIterative(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack<Node>(); \n\n\n\n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\nS.push(node); \n\nNode prev = \nnull\n; \n\nwhile\n(!S.isEmpty()) \n\n{ \n\nNode current = S.peek(); \n\n\n\n\nif\n(prev == \nnull\n|| prev.left == current || \n\nprev.right == current) \n\n{ \n\nif\n(current.left != \nnull\n) \n\nS.push(current.left); \n\nelse\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n\n\n} \n\nelse\nif\n(current.left == prev) \n\n{ \n\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n\n\n} \n\nelse\nif\n(current.right == prev) \n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\nprev = current; \n\n} \n\n\nreturn\nlist; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nArrayList<Integer> mylist = tree.postOrderIterative(tree.root); \n\n\nSystem.out.println(\n\"Post order traversal of binary tree is :\"\n); \n\nSystem.out.println(mylist); \n\n} \n}", "index": 197, "complexity": "1"}
{"back-translation": "class Node {\n\nint data;\nNode left, right;\n\nNode(int item) {\n    data = item;\n    left = right = null;\n}\n}\n\nclass BinaryTree {\n\nNode root;\n\nvoid printLeaves(Node node) {\n    if (node != null) {\n        printLeaves(node.left);\n\n        if (node.left == null && node.right == null)\n            System.out.print(node.data + \" \");\n\n        printLeaves(node.right);\n    }\n}\n\nvoid printBoundaryLeft(Node node) {\n    if (node != null) {\n        if (node.left != null) {\n            System.out.print(node.data + \" \");\n            printBoundaryLeft(node.left);\n        } else if (node.right != null) {\n            System.out.print(node.data + \" \");\n            printBoundaryLeft(node.right);\n        }\n    }\n}\n\nvoid printBoundaryRight(Node node) {\n    if (node != null) {\n        if (node.right != null) {\n            printBoundaryRight(node.right);\n            System.out.print(node.data + \" \");\n        } else if (node.left != null) {\n            printBoundaryRight(node.left);\n            System.out.print(node.data + \" \");\n        }\n    }\n}\n\nvoid printBoundary(Node node) {\n    if (node != null) {\n        System.out.print(node.data + \" \");\n\n        printBoundaryLeft(node.left);\n\n        printLeaves(node.left);\n        printLeaves(node.right);\n\n        printBoundaryRight(node.right);\n    }\n}\n\npublic static void main(String args[]) {\n    BinaryTree tree = new BinaryTree();\n    tree.root = new Node(20);\n    tree.root.left = new Node(8);\n    tree.root.left.left = new Node(4);\n    tree.root.left.right = new Node(12);\n    tree.root.left.right.left = new Node(10);\n    tree.root.left.right.right = new Node(14);\n    tree.root.right = new Node(22);\n    tree.root.right.right = new Node(25);\n    tree.printBoundary(tree.root);\n}", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n\n\nvoid\nprintLeaves(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nprintLeaves(node.left); \n\n\n\n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintLeaves(node.right); \n\n} \n\n} \n\n\n\n\n\n\nvoid\nprintBoundaryLeft(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nif\n(node.left != \nnull\n) { \n\n\n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintBoundaryLeft(node.left); \n\n} \n\nelse\nif\n(node.right != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintBoundaryLeft(node.right); \n\n} \n\n\n\n\n\n\n} \n\n} \n\n\n\n\n\n\nvoid\nprintBoundaryRight(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nif\n(node.right != \nnull\n) { \n\n\n\n\n\nprintBoundaryRight(node.right); \n\nSystem.out.print(node.data + \n\" \"\n); \n\n} \n\nelse\nif\n(node.left != \nnull\n) { \n\nprintBoundaryRight(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\n} \n\n\n\n\n\n} \n\n} \n\n\n\n\nvoid\nprintBoundary(Node node) \n\n{ \n\nif\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintBoundaryLeft(node.left); \n\n\n\n\nprintLeaves(node.left); \n\nprintLeaves(node.right); \n\n\n\n\nprintBoundaryRight(node.right); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n20\n); \n\ntree.root.left = \nnew\nNode(\n8\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n12\n); \n\ntree.root.left.right.left = \nnew\nNode(\n10\n); \n\ntree.root.left.right.right = \nnew\nNode(\n14\n); \n\ntree.root.right = \nnew\nNode(\n22\n); \n\ntree.root.right.right = \nnew\nNode(\n25\n); \n\ntree.printBoundary(tree.root); \n\n} \n}", "index": 198, "complexity": "1"}
{"back-translation": "class ListNode { int data; ListNode next; ListNode(int d) { data = d; next = null; } } class BinaryTreeNode { int data; BinaryTreeNode left, right = null; BinaryTreeNode(int data) { this.data = data; left = right = null; } } class BinaryTree { ListNode head; BinaryTreeNode root; void push(int new_data) { ListNode new_node = new ListNode(new_data); new_node.next = head; head = new_node; } BinaryTreeNode convertList2Binary(BinaryTreeNode node) { Queue<BinaryTreeNode> q = new LinkedList<BinaryTreeNode>(); if (head == null) { node = null; return null; } node = new BinaryTreeNode(head.data); q.add(node); head = head.next; while (head != null) { BinaryTreeNode parent = q.peek(); BinaryTreeNode pp = q.poll(); BinaryTreeNode leftChild = null, rightChild = null; leftChild = new BinaryTreeNode(head.data); q.add(leftChild); head = head.next; if (head != null) { rightChild = new BinaryTreeNode(head.data); q.add(rightChild); head = head.next; } parent.left = leftChild; parent.right = rightChild; } return node; } void inorderTraversal(BinaryTreeNode node) { if (node != null) { inorderTraversal(node.left); System.out.print(node.data + ", "src": "class\nListNode \n{ \n\nint\ndata; \n\nListNode next; \n\nListNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n} \n\n\nclass\nBinaryTreeNode \n{ \n\nint\ndata; \n\nBinaryTreeNode left, right = \nnull\n; \n\nBinaryTreeNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nListNode head; \n\nBinaryTreeNode root; \n\n\n\n\n\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\nListNode new_node = \nnew\nListNode(new_data); \n\n\n\n\nnew_node.next = head; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\n\n\n\n\nBinaryTreeNode convertList2Binary(BinaryTreeNode node) \n\n{ \n\n\n\nQueue<BinaryTreeNode> q = \n\nnew\nLinkedList<BinaryTreeNode>(); \n\n\n\n\nif\n(head == \nnull\n) \n\n{ \n\nnode = \nnull\n; \n\nreturn\nnull\n; \n\n} \n\n\n\n\n\n\nnode = \nnew\nBinaryTreeNode(head.data); \n\nq.add(node); \n\n\n\n\nhead = head.next; \n\n\n\n\n\n\nwhile\n(head != \nnull\n) \n\n{ \n\n\n\n\n\nBinaryTreeNode parent = q.peek(); \n\nBinaryTreeNode pp = q.poll(); \n\n\n\n\n\n\n\n\n\n\n\n\nBinaryTreeNode leftChild = \nnull\n, rightChild = \nnull\n; \n\nleftChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(leftChild); \n\nhead = head.next; \n\nif\n(head != \nnull\n) \n\n{ \n\nrightChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(rightChild); \n\nhead = head.next; \n\n} \n\n\n\n\n\n\nparent.left = leftChild; \n\nparent.right = rightChild; \n\n} \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\nvoid\ninorderTraversal(BinaryTreeNode node) \n\n{ \n\nif\n(node != \nnull\n) \n\n{ \n\ninorderTraversal(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderTraversal(node.right); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.push(\n36\n); \n\n\ntree.push(\n30\n); \n\ntree.push(\n25\n); \n\ntree.push(\n15\n); \n\ntree.push(\n12\n); \n\ntree.push(\n10\n); \n\n\nBinaryTreeNode node = tree.convertList2Binary(tree.root); \n\n\nSystem.out.println(\n\"Inorder Traversal of the\"\n+ \n\n\" constructed Binary Tree is:\"\n); \n\ntree.inorderTraversal(node); \n\n} \n}", "index": 199, "complexity": "1"}
{"back-translation": "public class Tree { Node root; static class Node { int data; Node left, right; Node(int data) { this.data = data; this.left = null; this.right = null; } } public Node insertLevelOrder(int[] arr, Node root, int i) { if (i < arr.length) { Node temp = new Node(arr[i]); root = temp; root.left = insertLevelOrder(arr, root.left, 2 * i + 1); root.right = insertLevelOrder(arr, root.right, 2 * i + 2); } return root; } public void inOrder(Node root) { if (root != null) { inOrder(root.left); System.out.print(root.data + \" \"); inOrder(root.right); } } public static void main(String args[]) { Tree t2 = new Tree(); int arr[] = { 1, 2, 3, 4, 5, 6, 6, 6, 6 }; t2.root = t2.insertLevelOrder(arr, t2.root, 0); t2.inOrder(t2.root); } }", "src": "public\nclass\nTree { \n\nNode root; \n\n\n\n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.left = \nnull\n; \n\nthis\n.right = \nnull\n; \n\n} \n\n} \n\n\n\n\npublic\nNode insertLevelOrder(\nint\n[] arr, Node root, \n\nint\ni) \n\n{ \n\n\n\nif\n(i < arr.length) { \n\nNode temp = \nnew\nNode(arr[i]); \n\nroot = temp; \n\n\n\n\nroot.left = insertLevelOrder(arr, root.left, \n\n2\n* i + \n1\n); \n\n\n\n\nroot.right = insertLevelOrder(arr, root.right, \n\n2\n* i + \n2\n); \n\n} \n\nreturn\nroot; \n\n} \n\n\n\n\npublic\nvoid\ninOrder(Node root) \n\n{ \n\nif\n(root != \nnull\n) { \n\ninOrder(root.left); \n\nSystem.out.print(root.data + \n\" \"\n); \n\ninOrder(root.right); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nTree t2 = \nnew\nTree(); \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n6\n, \n6\n, \n6\n}; \n\nt2.root = t2.insertLevelOrder(arr, t2.root, \n0\n); \n\nt2.inOrder(t2.root); \n\n} \n}", "index": 200, "complexity": "1"}
{"back-translation": "class PairInSortedRotated {\n    static boolean pairInSortedRotated(int arr[], int n, int x) {\n        int i;\n        for (i = 0; i < n - 1; i++) {\n            if (arr[i] > arr[i+1]) {\n                break;\n            }\n        }\n        int l = (i + 1) % n;\n        int r = i;\n        while (l != r) {\n            if (arr[l] + arr[r] == x) {\n                return true;\n            }\n            if (arr[l] + arr[r] < x) {\n                l = (l + 1) % n;\n            } else {\n                r = (n + r - 1) % n;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {11, 15, 6, 8, 9, 10};\n        int sum = 16;\n        int n = arr.length;\n        if (pairInSortedRotated(arr, n, sum)) {\n            System.out.print(\"Array has two elements\" + \" with sum 16\");\n        } else {\n            System.out.print(\"Array doesn't have two\" + \" elements with sum 16 \");\n        }\n    }\n}", "src": "class\nPairInSortedRotated \n{ \n\n\n\n\n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n\n\n\n\n\nint\nr = i; \n\n\n\n\n\n\n\nwhile\n(l != r) \n\n{ \n\n\n\n\n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n\n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n}", "index": 201, "complexity": "1"}
{"back-translation": "class Node { int data; Node left, right; Node(int item) { data = item; left = right = null; } } class Index { int index = 0; } class BinaryTree { Node root; Index myindex = new Index(); Node constructTreeUtil(int pre[], char preLN[], Index index_ptr, int n, Node temp) { int index = index_ptr.index; if (index == n) return null; temp = new Node(pre[index]); (index_ptr.index)++; if (preLN[index] == 'N') { temp.left = constructTreeUtil(pre, preLN, index_ptr, n, temp.left); temp.right = constructTreeUtil(pre, preLN, index_ptr, n, temp.right); } return temp; } Node constructTree(int pre[], char preLN[], int n, Node node) { int index = 0; return constructTreeUtil(pre, preLN, myindex, n, node); } void printInorder(Node node) { if (node == null) return; printInorder(node.getLeft()); System.out.print(node.getData() + ' '); printInorder(node.getRight()); } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); int pre[] = new int[]{ 10, 30, 20, 5, 15 }; char preLN[] = new char[]{ 'N', 'N', 'L', 'L', 'L' }; int n = pre.length; Node mynode = tree.constructTree(pre, preLN, n, tree.root); System.out.println(\"Following is Inorder Traversal of the\" + \"Constructed Binary Tree: \"); tree.printInorder(mynode); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nIndex \n{ \n\nint\nindex = \n0\n; \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nIndex myindex = \nnew\nIndex(); \n\n\n\n\nNode constructTreeUtil(\nint\npre[], \nchar\npreLN[], Index index_ptr, \n\nint\nn, Node temp) \n\n{ \n\n\n\nint\nindex = index_ptr.index; \n\n\n\n\nif\n(index == n) \n\nreturn\nnull\n; \n\n\n\n\n\n\ntemp = \nnew\nNode(pre[index]); \n\n(index_ptr.index)++; \n\n\n\n\n\n\nif\n(preLN[index] == \n'N'\n) \n\n{ \n\ntemp.left = constructTreeUtil(pre, preLN, index_ptr, n, \n\ntemp.left); \n\ntemp.right = constructTreeUtil(pre, preLN, index_ptr, n, \n\ntemp.right); \n\n} \n\n\nreturn\ntemp; \n\n} \n\n\n\n\nNode constructTree(\nint\npre[], \nchar\npreLN[], \nint\nn, Node node) \n\n{ \n\n\n\n\n\nint\nindex = \n0\n; \n\n\nreturn\nconstructTreeUtil(pre, preLN, myindex, n, node); \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\npre[] = \nnew\nint\n[]{\n10\n, \n30\n, \n20\n, \n5\n, \n15\n}; \n\nchar\npreLN[] = \nnew\nchar\n[]{\n'N'\n, \n'N'\n, \n'L'\n, \n'L'\n, \n'L'\n}; \n\nint\nn = pre.length; \n\n\n\n\nNode mynode = tree.constructTree(pre, preLN, n, tree.root); \n\n\n\n\nSystem.out.println(\n\"Following is Inorder Traversal of the\"\n\n+ \n\"Constructed Binary Tree: \"\n); \n\ntree.printInorder(mynode); \n\n} \n}", "index": 202, "complexity": "1"}
{"back-translation": "public class BinaryTreeToDLL {\n\n    static class node {\n\n        int data;\n        node left, right;\n\n        public node(int data) {\n            this.data = data;\n        }\n    }\n\n    static node prev;\n\n    static void fixPrevptr(node root) {\n        if (root == null) return;\n\n        fixPrevptr(root.left);\n        root.left = prev;\n        prev = root;\n        fixPrevptr(root.right);\n    }\n\n    static node fixNextptr(node root) {\n        while (root.right != null) root = root.right;\n\n        while (root != null && root.left != null) {\n            node left = root.left;\n            left.right = root;\n            root = root.left;\n        }\n\n        return root;\n    }\n\n    static node BTTtoDLL(node root) {\n        prev = null;\n\n        fixPrevptr(root);\n\n        return fixNextptr(root);\n    }\n\n    static void printlist(node root) {\n        while (root != null) {\n            System.out.print(root.data + \" \");\n            root = root.right;\n        }\n    }\n\n    static void inorder(node root) {\n        if (root == null) return;\n\n        inorder(root.left);\n        System.out.print(root.data + \" \");\n        inorder(root.right);\n    }\n\n    public static void main(String[] args) {\n        node root = new node(10);\n        root.left = new node(12);\n        root.right = new node(15);\n        root.left.left = new node(25);\n        root.left.right = new node(30);\n        root.right.left = new node(36);\n\n        System.out.println(\"Inorder Tree Traversal\");\n        inorder(root);\n\n        node head = BTTtoDLL(root);\n\n        System.out.println(\"\\nDLL Traversal\");\n        printlist(head);\n    }", "src": "public\nclass\nBinaryTreeToDLL \n{ \n\nstatic\nclass\nnode \n\n{ \n\nint\ndata; \n\nnode left, right; \n\n\npublic\nnode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\n} \n\n} \n\n\nstatic\nnode prev; \n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nfixPrevptr(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nfixPrevptr(root.left); \n\nroot.left = prev; \n\nprev = root; \n\nfixPrevptr(root.right); \n\n\n} \n\n\n\n\n\n\nstatic\nnode fixNextptr(node root) \n\n{ \n\n\n\n\n\nwhile\n(root.right != \nnull\n) \n\nroot = root.right; \n\n\n\n\n\n\n\n\nwhile\n(root != \nnull\n&& root.left != \nnull\n) \n\n{ \n\nnode left = root.left; \n\nleft.right = root; \n\nroot = root.left; \n\n} \n\n\n\n\nreturn\nroot; \n\n} \n\n\nstatic\nnode BTTtoDLL(node root) \n\n{ \n\nprev = \nnull\n; \n\n\n\n\nfixPrevptr(root); \n\n\n\n\nreturn\nfixNextptr(root); \n\n} \n\n\n\n\nstatic\nvoid\nprintlist(node root) \n\n{ \n\nwhile\n(root != \nnull\n) \n\n{ \n\nSystem.out.print(root.data + \n\" \"\n); \n\nroot = root.right; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\ninorder(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\ninorder(root.left); \n\nSystem.out.print(root.data + \n\" \"\n); \n\ninorder(root.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nnode root = \nnew\nnode(\n10\n); \n\nroot.left = \nnew\nnode(\n12\n); \n\nroot.right = \nnew\nnode(\n15\n); \n\nroot.left.left = \nnew\nnode(\n25\n); \n\nroot.left.right = \nnew\nnode(\n30\n); \n\nroot.right.left = \nnew\nnode(\n36\n); \n\n\nSystem.out.println(\n\"Inorder Tree Traversal\"\n); \n\ninorder(root); \n\n\nnode head = BTTtoDLL(root); \n\n\nSystem.out.println(\n\"\\nDLL Traversal\"\n); \n\nprintlist(head); \n\n} \n}", "index": 203, "complexity": "1"}
{"back-translation": "class Node {\n\n    int data;\n    Node left, right;\n\n    public Node(int data) {\n        this.data = data;\n        left = right = null;\n    }\n}\n\nclass BinaryTree {\n\n    Node root;\n    Node head;\n    static Node prev = null;\n\n    void BinaryTree2DoubleLinkedList(Node root) {\n        if (root == null)\n            return;\n\n        BinaryTree2DoubleLinkedList(root.left);\n\n        if (prev == null)\n            head = root;\n        else {\n            root.left = prev;\n            prev.right = root;\n        }\n        prev = root;\n\n        BinaryTree2DoubleLinkedList(root.right);\n    }\n\n    void printList(Node node) {\n        while (node != null) {\n            System.out.print(node.data + \" \");\n            node = node.right;\n        }\n    }\n\n    public static void main(String[] args) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node(10);\n        tree.root.left = new Node(12);\n        tree.root.right = new Node(15);\n        tree.root.left.left = new Node(25);\n        tree.root.left.right = new Node(30);\n        tree.root.right.left = new Node(36);\n\n        tree.BinaryTree2DoubleLinkedList(tree.root);\n\n        tree.printList(tree.head);\n    }\n}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nNode head; \n\n\n\n\n\n\n\n\nstatic\nNode prev = \nnull\n; \n\n\n\n\n\n\n\n\nvoid\nBinaryTree2DoubleLinkedList(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\nBinaryTree2DoubleLinkedList(root.left); \n\n\n\n\nif\n(prev == \nnull\n) \n\nhead = root; \n\nelse\n\n{ \n\nroot.left = prev; \n\nprev.right = root; \n\n} \n\nprev = root; \n\n\n\n\nBinaryTree2DoubleLinkedList(root.right); \n\n} \n\n\n\n\nvoid\nprintList(Node node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.right; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n12\n); \n\ntree.root.right = \nnew\nNode(\n15\n); \n\ntree.root.left.left = \nnew\nNode(\n25\n); \n\ntree.root.left.right = \nnew\nNode(\n30\n); \n\ntree.root.right.left = \nnew\nNode(\n36\n); \n\n\n\n\ntree.BinaryTree2DoubleLinkedList(tree.root); \n\n\n\n\ntree.printList(tree.head); \n\n\n} \n}", "index": 204, "complexity": "1"}
{"back-translation": "class Node { int data; Node left, right; public Node(int data) { this.data = data; left = right = null; } } class BinaryTree { Node root; Node head; void BToDLL(Node root) { if (root == null) return; BToDLL(root.right); root.right = head; if (head != null) (head).left = root; head = root; BToDLL(root.left); } void printList(Node head) { System.out.println(\"Extracted Double Linked List is : \"); while (head != null) { System.out.print(head.data + \" \"); head = head.right; } } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(5); tree.root.left = new Node(3); tree.root.right = new Node(6); tree.root.left.right = new Node(4); tree.root.left.left = new Node(1); tree.root.right.right = new Node(8); tree.root.left.left.right = new Node(2); tree.root.left.left.left = new Node(0); tree.root.right.right.left = new Node(7); tree.root.right.right.right = new Node(9); tree.BToDLL(tree.root); tree.printList(tree.head); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\n\n\nNode root; \n\n\n\n\n\n\nNode head; \n\n\n\n\n\n\nvoid\nBToDLL(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\nBToDLL(root.right); \n\n\n\n\nroot.right = head; \n\n\n\n\nif\n(head != \nnull\n) \n\n(head).left = root; \n\n\n\n\nhead = root; \n\n\n\n\nBToDLL(root.left); \n\n} \n\n\n\n\nvoid\nprintList(Node head) \n\n{ \n\nSystem.out.println(\n\"Extracted Double Linked List is : \"\n); \n\nwhile\n(head != \nnull\n) \n\n{ \n\nSystem.out.print(head.data + \n\" \"\n); \n\nhead = head.right; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n3\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.right = \nnew\nNode(\n4\n); \n\ntree.root.left.left = \nnew\nNode(\n1\n); \n\ntree.root.right.right = \nnew\nNode(\n8\n); \n\ntree.root.left.left.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left.left = \nnew\nNode(\n0\n); \n\ntree.root.right.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right.right = \nnew\nNode(\n9\n); \n\n\ntree.BToDLL(tree.root); \n\ntree.printList(tree.head); \n\n} \n}", "index": 205, "complexity": "1"}
{"back-translation": "class GFG { static class node { int key; node left, right; node(int key) { this.key = key; this.left = null; this.right = null; } } static void convert(node root) { if (root == null) return; convert(root.left); convert(root.right); if (root.left == null) root.left = root.right; else root.left.right = root.right; root.right = null; } static void downRightTraversal(node root) { if (root != null) { System.out.print(root.key + \" \"); downRightTraversal(root.right); downRightTraversal(root.left); } } static node newNode(int key) { node temp = new node(0); temp.key = key; temp.left = null; temp.right = null; return temp; } public static void main(String[] args) { node root = new node(1); root.left = newNode(2); root.right = newNode(3); root.right.left = newNode(4); root.right.right = newNode(5); root.right.left.left = newNode(6); root.right.right.left = newNode(7); root.right.right.right = newNode(8); convert(root); System.out.println(\"Traversal of the tree \" + \"converted to down-right form\"); downRightTraversal(root); } }", "src": "class\nGFG \n{ \n\n\nstatic\nclass\nnode \n{ \n\nint\nkey; \n\nnode left, right; \n\nnode(\nint\nkey) \n\n{ \n\nthis\n.key = key; \n\nthis\n.left = \nnull\n; \n\nthis\n.right = \nnull\n; \n\n} \n} \n\n\n\n\nstatic\nvoid\nconvert(node root) \n{ \n\n\n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n\n\n\n\nconvert(root.left); \n\nconvert(root.right); \n\n\n\n\n\n\nif\n(root.left == \nnull\n) \n\nroot.left = root.right; \n\n\n\n\n\n\nelse\n\nroot.left.right = root.right; \n\n\n\n\nroot.right = \nnull\n; \n} \n\n\n\nstatic\nvoid\ndownRightTraversal(node root) \n{ \n\nif\n(root != \nnull\n) \n\n{ \n\nSystem.out.print(root.key + \n\" \"\n); \n\ndownRightTraversal(root.right); \n\ndownRightTraversal(root.left); \n\n} \n} \n\n\n\nstatic\nnode newNode(\nint\nkey) \n{ \n\nnode temp = \nnew\nnode(\n0\n); \n\ntemp.key = key; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\n\n\n\n\nnode root = \nnew\nnode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n4\n); \n\nroot.right.right = newNode(\n5\n); \n\nroot.right.left.left = newNode(\n6\n); \n\nroot.right.right.left = newNode(\n7\n); \n\nroot.right.right.right = newNode(\n8\n); \n\n\nconvert(root); \n\n\nSystem.out.println(\n\"Traversal of the tree \"\n+ \n\n\"converted to down-right form\"\n); \n\ndownRightTraversal(root); \n} \n}", "index": 206, "complexity": "1"}
{"back-translation": "class Node {\n\n    int data;\n    Node left, right;\n\n    Node(int item) {\n        data = item;\n        left = right = null;\n    }\n}\n\nclass BinaryTree {\n\n    Node root;\n\n    int toSumTree(Node node) {\n\n        if (node == null)\n            return 0;\n\n        int old_val = node.data;\n\n        node.data = toSumTree(node.left) + toSumTree(node.right);\n\n        return node.data + old_val;\n    }\n\n    void printInorder(Node node) {\n\n        if (node == null)\n            return;\n\n        printInorder(node.left);\n        System.out.print(node.data + \" \");\n        printInorder(node.right);\n    }\n\n    public static void main(String args[]) {\n\n        BinaryTree tree = new BinaryTree();\n\n        tree.root = new Node(10);\n        tree.root.left = new Node(-2);\n        tree.root.right = new Node(6);\n        tree.root.left.left = new Node(8);\n        tree.root.left.right = new Node(-4);\n        tree.root.right.left = new Node(7);\n        tree.root.right.right = new Node(5);\n\n        tree.toSumTree(tree.root);\n\n        System.out.println(\"Inorder Traversal of the resultant tree is:\");\n        tree.printInorder(tree.root);\n    }\n}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\n\n\nint\ntoSumTree(Node node) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\n\n\nint\nold_val = node.data; \n\n\n\n\n\n\nnode.data = toSumTree(node.left) + toSumTree(node.right); \n\n\n\n\n\n\nreturn\nnode.data + old_val; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(-\n2\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.left = \nnew\nNode(\n8\n); \n\ntree.root.left.right = \nnew\nNode(-\n4\n); \n\ntree.root.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right = \nnew\nNode(\n5\n); \n\n\ntree.toSumTree(tree.root); \n\n\n\n\n\n\nSystem.out.println(\n\"Inorder Traversal of the resultant tree is:\"\n); \n\ntree.printInorder(tree.root); \n\n} \n}", "index": 207, "complexity": "1"}
{"back-translation": "class GfG {static class node {int data;node left, right;}    static int updatetree(node root) {if (root == null) return 0;if (root.left == null && root.right == null) return root.data;int leftsum = updatetree(root.left);int rightsum = updatetree(root.right);root.data += leftsum;return root.data + rightsum;}static void inorder(node node) {if (node == null) return;inorder(node.left);System.out.print(node.data + \" \");inorder(node.right);}static node newNode(int data) {node node = new node();node.data = data;node.left = null;node.right = null;return (node);}public static void main(String[] args) {node root = newNode(1);root.left = newNode(2);root.right = newNode(3);root.left.left = newNode(4);root.left.right = newNode(5);root.right.right = newNode(6);updatetree(root);System.out.println(\"Inorder traversal of the modified tree is\");inorder(root);}}", "src": "class\nGfG { \n\n\nstatic\nclass\nnode \n{ \n\nint\ndata; \n\nnode left, right; \n} \n\n\n\n\nstatic\nint\nupdatetree(node root) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\nroot.data; \n\n\n\n\nint\nleftsum = updatetree(root.left); \n\nint\nrightsum = updatetree(root.right); \n\n\n\n\nroot.data += leftsum; \n\n\n\n\nreturn\nroot.data + rightsum; \n} \n\n\nstatic\nvoid\ninorder(node node) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\ninorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorder(node.right); \n} \n\n\nstatic\nnode newNode(\nint\ndata) \n{ \n\nnode node = \nnew\nnode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\nnode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.right.right = newNode(\n6\n); \n\n\nupdatetree(root); \n\n\n\nSystem.out.println(\n\"Inorder traversal of the modified tree is\"\n); \n\ninorder(root); \n} \n}", "index": 208, "complexity": "1"}
{"back-translation": "class GFG {static int N = 12,ans;static Vector<Vector<Integer>> tree=new Vector<Vector<Integer>>();static int dfs(int visit[], int node){int num = 0, temp = 0;visit[node] = 1;for(int i = 0; i < tree.get(node).size(); i++){if(visit[tree.get(node).get(i)] == 0){temp = dfs( visit, tree.get(node).get(i));if(temp%2!=0) num += temp;else ans++;}}return num+1;}static int minEdge(int n){int visit[] = new int[n+2];ans = 0;dfs( visit, 1);return ans;}public static void main(String args[]){int n = 10;for(int i = 0; i < n + 2;i++) tree.add(new Vector<Integer>());tree.get(1).add(3);tree.get(3).add(1);tree.get(1).add(6);tree.get(6).add(1);tree.get(1).add(2);tree.get(2).add(1);tree.get(3).add(4);tree.get(4).add(3);tree.get(6).add(8);tree.get(8).add(6);tree.get(2).add(7);tree.get(7).add(2);tree.get(2).add(5);tree.get(5).add(2);tree.get(4).add(9);tree.get(9).add(4);tree.get(4).add(10);tree.get(10).add(4);System.out.println( minEdge( n));}}", "src": "class\nGFG \n{ \n\nstatic\nint\nN = \n12\n,ans; \n\n\nstatic\nVector<Vector<Integer>> tree=\nnew\nVector<Vector<Integer>>(); \n\n\n\n\n\n\nstatic\nint\ndfs( \nint\nvisit[], \nint\nnode) \n\n{ \n\nint\nnum = \n0\n, temp = \n0\n; \n\n\n\n\nvisit[node] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < tree.get(node).size(); i++) \n\n{ \n\nif\n(visit[tree.get(node).get(i)] == \n0\n) \n\n{ \n\n\n\n\n\ntemp = dfs( visit, tree.get(node).get(i)); \n\n\n\n\n\n\n\n\nif\n(temp%\n2\n!=\n0\n) \n\nnum += temp; \n\nelse\n\nans++; \n\n} \n\n} \n\n\nreturn\nnum+\n1\n; \n\n} \n\n\n\n\n\n\nstatic\nint\nminEdge( \nint\nn) \n\n{ \n\nint\nvisit[] = \nnew\nint\n[n+\n2\n]; \n\nans = \n0\n; \n\n\ndfs( visit, \n1\n); \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n + \n2\n;i++) \n\ntree.add(\nnew\nVector<Integer>()); \n\n\ntree.get(\n1\n).add(\n3\n); \n\ntree.get(\n3\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n6\n); \n\ntree.get(\n6\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n2\n); \n\ntree.get(\n2\n).add(\n1\n); \n\n\ntree.get(\n3\n).add(\n4\n); \n\ntree.get(\n4\n).add(\n3\n); \n\n\ntree.get(\n6\n).add(\n8\n); \n\ntree.get(\n8\n).add(\n6\n); \n\n\ntree.get(\n2\n).add(\n7\n); \n\ntree.get(\n7\n).add(\n2\n); \n\n\ntree.get(\n2\n).add(\n5\n); \n\ntree.get(\n5\n).add(\n2\n); \n\n\ntree.get(\n4\n).add(\n9\n); \n\ntree.get(\n9\n).add(\n4\n); \n\n\ntree.get(\n4\n).add(\n10\n); \n\ntree.get(\n10\n).add(\n4\n); \n\n\nSystem.out.println( minEdge( n)); \n\n} \n}", "index": 209, "complexity": "1"}
{"back-translation": "class Node { char data; Node left, right; public Node(char item) { data = item; left = null; right = null; } } class BinaryTree { Node convertExpression(char[] expression, int i) { if (i >= expression.length) return null; Node root = new Node(expression[i]); ++i; if (i < expression.length && expression[i]=='?') root.left = convertExpression(expression, i+1); else if (i < expression.length) root.right = convertExpression(expression, i+1); return root; } public void printTree(Node root) { if (root == null) return; System.out.print(root.data + \" \"); printTree(root.left); printTree(root.right); } public static void main(String args[]) { String exp = \"a?b?c:d:e\"; BinaryTree tree = new BinaryTree(); char[] expression=exp.toCharArray(); Node root = tree.convertExpression(expression, 0); tree.printTree(root); } }", "src": "class\nNode \n{ \n\nchar\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n} \n\n\nclass\nBinaryTree \n{ \n\n\n\n\n\nNode convertExpression(\nchar\n[] expression, \nint\ni) \n\n{ \n\n\n\nif\n(i >= expression.length) \n\nreturn\nnull\n; \n\n\n\n\n\n\nNode root = \nnew\nNode(expression[i]); \n\n\n\n\n++i; \n\n\n\n\n\n\n\n\nif\n(i < expression.length && expression[i]==\n'?'\n) \n\nroot.left = convertExpression(expression, i+\n1\n); \n\n\n\n\n\n\nelse\nif\n(i < expression.length) \n\nroot.right = convertExpression(expression, i+\n1\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\npublic\nvoid\nprintTree( Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nSystem.out.print(root.data +\n\" \"\n); \n\nprintTree(root.left); \n\nprintTree(root.right); \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString exp = \n\"a?b?c:d:e\"\n; \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nchar\n[] expression=exp.toCharArray(); \n\nNode root = tree.convertExpression(expression, \n0\n); \n\ntree.printTree(root) ; \n\n} \n}", "index": 210, "complexity": "1"}
{"back-translation": "public class FlipTree {\n\n\npublic static Node flipBinaryTree(Node root) {\nif (root == null)\nreturn root;\nif (root.left == null && root.right == null)\nreturn root;\nNode flippedRoot = flipBinaryTree(root.left);\nroot.left.left = root.right;\nroot.left.right = root;\nroot.left = root.right = null;\nreturn flippedRoot;\n}\n\npublic static void printLevelOrder(Node root) {\nif (root == null)\nreturn;\nQueue<Node> q = new LinkedList<>();\nq.add(root);\nwhile (true) {\nint nodeCount = q.size();\nif (nodeCount == 0)\nbreak;\nwhile (nodeCount > 0) {\nNode node = q.remove();\nSystem.out.print(node.data + \" \");\nif (node.left != null)\nq.add(node.left);\nif (node.right != null)\nq.add(node.right);\nnodeCount--;\n}\nSystem.out.println();\n}\n}\n\npublic static void main(String args[]) {\nNode root = new Node(1);\nroot.left = new Node(2);\nroot.right = new Node(1);\nroot.right.left = new Node(4);\nroot.right.right = new Node(5);\nSystem.out.println(\"Level order traversal of given tree\");\nprintLevelOrder(root);\nroot = flipBinaryTree(root);\nSystem.out.println(\"Level order traversal of flipped tree\");\nprintLevelOrder(root);\n}\n}\n\nclass Node {\nint data;\nNode left, right;\nNode(int data) {\nthis.data = data;\n}\n};", "src": "public\nclass\nFlipTree { \n\n\n\n\npublic\nstatic\nNode flipBinaryTree(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\nroot; \n\nif\n(root.left == \nnull\n&& root.right ==\nnull\n) \n\nreturn\nroot; \n\n\n\n\nNode flippedRoot=flipBinaryTree(root.left); \n\n\n\n\n\n\nroot.left.left=root.right; \n\nroot.left.right=root; \n\nroot.left=root.right=\nnull\n; \n\nreturn\nflippedRoot; \n\n} \n\n\n\n\n\n\npublic\nstatic\nvoid\nprintLevelOrder(Node root) \n\n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nQueue<Node> q=\nnew\nLinkedList<>(); \n\n\n\nq.add(root); \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.remove(); \n\nSystem.out.print(node.data+\n\" \"\n); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left=\nnew\nNode(\n2\n); \n\nroot.right=\nnew\nNode(\n1\n); \n\nroot.right.left = \nnew\nNode(\n4\n); \n\nroot.right.right = \nnew\nNode(\n5\n); \n\nSystem.out.println(\n\"Level order traversal of given tree\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\nSystem.out.println(\n\"Level order traversal of flipped tree\"\n); \n\nprintLevelOrder(root); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\n} \n};", "index": 211, "complexity": "1"}
{"back-translation": "class GFG { static class Node { int data; Node left, right; }; static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.left = temp.right = null; return temp; } static Node flipBinaryTree(Node root) { Node curr = root; Node next = null; Node temp = null; Node prev = null; while (curr != null) { next = curr.left; curr.left = temp; temp = curr.right; curr.right = prev; prev = curr; curr = next; } return prev; } static void printLevelOrder(Node root) { if (root == null) return; Queue<Node> q = new LinkedList<Node>(); q.add(root); while (true) { int nodeCount = q.size(); if (nodeCount == 0) break; while (nodeCount > 0) { Node node = q.peek(); System.out.print(node.data + \" \"); q.remove(); if (node.left != null) q.add(node.left); if (node.right != null) q.add(node.right); nodeCount--; } System.out.println(); } } public static void main(String args[]) { Node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.right.left = newNode(4); root.right.right = newNode(5); System.out.print(\"Level order traversal \" + \"of given tree\\n\"); printLevelOrder(root); root = flipBinaryTree(root); System.out.print(\"\\nLevel order traversal \" + \"of the flipped tree\\n\"); printLevelOrder(root); } }", "src": "class\nGFG \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n\n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode flipBinaryTree(Node root) \n{ \n\n\n\nNode curr = root; \n\nNode next = \nnull\n; \n\nNode temp = \nnull\n; \n\nNode prev = \nnull\n; \n\n\n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\nnext = curr.left; \n\n\n\n\n\n\n\n\n\n\n\n\n\ncurr.left = temp; \n\n\n\n\ntemp = curr.right; \n\n\n\n\n\n\ncurr.right = prev; \n\n\nprev = curr; \n\ncurr = next; \n\n} \n\nreturn\nprev; \n} \n\n\n\n\nstatic\nvoid\nprintLevelOrder(Node root) \n{ \n\n\n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\n\n\n\n\n\nq.add(root); \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n4\n); \n\nroot.right.right = newNode(\n5\n); \n\n\nSystem.out.print(\n\"Level order traversal \"\n+ \n\n\"of given tree\\n\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\n\nSystem.out.print(\n\"\\nLevel order traversal \"\n+ \n\n\"of the flipped tree\\n\"\n); \n\nprintLevelOrder(root); \n} \n}", "index": 212, "complexity": "1"}
{"back-translation": "class Node { \n\n    int data; \n    Node left, right; \n\n\n    public Node(int d) { \n        data = d; \n        left = right = null; \n    } \n} \n\nclass BinaryTree { \n\n    Node root; \n\n    int isSumProperty(Node node) { \n        int left_data = 0, right_data = 0; \n\n        if (node == null || (node.left == null && node.right == null)) \n            return 1; \n        else { \n            if (node.left != null) \n                left_data = node.left.data; \n            if (node.right != null) \n                right_data = node.right.data; \n            if ((node.data == left_data + right_data) && (isSumProperty(node.left) != 0) && isSumProperty(node.right) != 0) \n                return 1; \n            else \n                return 0; \n        } \n    } \n\n    public static void main(String[] args) { \n        BinaryTree tree = new BinaryTree(); \n        tree.root = new Node(10); \n        tree.root.left = new Node(8); \n        tree.root.right = new Node(2); \n        tree.root.left.left = new Node(3); \n        tree.root.left.right = new Node(5); \n        tree.root.right.right = new Node(2); \n        if (tree.isSumProperty(tree.root) != 0) \n            System.out.println(\"The given tree satisfies children\" + \" sum property\"); \n        else \n            System.out.println(\"The given tree does not satisfy children\" + \" sum property\"); \n    } \n}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nint\nisSumProperty(Node node) \n\n{ \n\n\n\n\nint\nleft_data = \n0\n, right_data = \n0\n; \n\n\n\n\nif\n(node == \nnull\n\n|| (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n1\n; \n\nelse\n\n{ \n\n\n\n\nif\n(node.left != \nnull\n) \n\nleft_data = node.left.data; \n\n\n\n\nif\n(node.right != \nnull\n) \n\nright_data = node.right.data; \n\n\n\n\nif\n((node.data == left_data + right_data) \n\n&& (isSumProperty(node.left)!=\n0\n) \n\n&& isSumProperty(node.right)!=\n0\n) \n\nreturn\n1\n; \n\nelse\n\nreturn\n0\n; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n8\n); \n\ntree.root.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n2\n); \n\nif\n(tree.isSumProperty(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree satisfies children\"\n\n+ \n\" sum property\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree does not satisfy children\"\n\n+ \n\" sum property\"\n); \n\n} \n}", "index": 213, "complexity": "1"}
{"back-translation": "class Node {\n\n    int data;\n\n    Node left, right, nextRight;\n\n    Node(int item) {\n        data = item;\n        left = right = nextRight = null;\n    }\n}\n\nclass BinaryTree {\n\n    Node root;\n\n    int isLeaf(Node node) {\n        if (node == null)\n            return 0;\n        if (node.left == null && node.right == null)\n            return 1;\n        return 0;\n    }\n\n    int isSumTree(Node node) {\n        int ls;\n        int rs;\n\n        if (node == null || isLeaf(node) == 1)\n            return 1;\n\n        if (isSumTree(node.left) != 0 && isSumTree(node.right) != 0) {\n            if (node.left == null)\n                ls = 0;\n            else if (isLeaf(node.left) != 0)\n                ls = node.left.data;\n            else\n                ls = 2 * (node.left.data);\n\n            if (node.right == null)\n                rs = 0;\n            else if (isLeaf(node.right) != 0)\n                rs = node.right.data;\n            else\n                rs = 2 * (node.right.data);\n\n            if ((node.data == rs + ls))\n                return 1;\n            else\n                return 0;\n        }\n\n        return 0;\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node(26);\n        tree.root.left = new Node(10);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(4);\n        tree.root.left.right = new Node(6);\n        tree.root.right.right = new Node(3);\n\n        if (tree.isSumTree(tree.root) != 0)\n            System.out.println(\"The given tree is a sum tree\");\n        else\n            System.out.println(\"The given tree is not a sum tree\");\n    }\n}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right, nextRight; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = nextRight = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nint\nisLeaf(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nreturn\n1\n; \n\nreturn\n0\n; \n\n} \n\n\n\n\nint\nisSumTree(Node node) \n\n{ \n\nint\nls; \n\n\nint\nrs; \n\n\n\n\n\nif\n(node == \nnull\n|| isLeaf(node) == \n1\n) \n\nreturn\n1\n; \n\n\nif\n(isSumTree(node.left) != \n0\n&& isSumTree(node.right) != \n0\n) \n\n{ \n\n\n\nif\n(node.left == \nnull\n) \n\nls = \n0\n; \n\nelse\nif\n(isLeaf(node.left) != \n0\n) \n\nls = node.left.data; \n\nelse\n\nls = \n2\n* (node.left.data); \n\n\n\n\nif\n(node.right == \nnull\n) \n\nrs = \n0\n; \n\nelse\nif\n(isLeaf(node.right) != \n0\n) \n\nrs = node.right.data; \n\nelse\n\nrs = \n2\n* (node.right.data); \n\n\n\n\nif\n((node.data == rs + ls)) \n\nreturn\n1\n; \n\nelse\n\nreturn\n0\n; \n\n} \n\n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n26\n); \n\ntree.root.left = \nnew\nNode(\n10\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n3\n); \n\n\nif\n(tree.isSumTree(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree is a sum tree\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree is not a sum tree\"\n); \n\n} \n}", "index": 214, "complexity": "1"}
{"back-translation": "class Node  { int data; Node left, right; Node(int item) { data = item; left = right = null; } } class BinaryTree { Node root; boolean isSibling(Node node, Node a, Node b) { if (node == null) return false; return ((node.left == a && node.right == b) || (node.left == b && node.right == a) || isSibling(node.left, a, b) || isSibling(node.right, a, b)); } int level(Node node, Node ptr, int lev) { if (node == null) return 0; if (node == ptr) return lev; int l = level(node.left, ptr, lev + 1); if (l != 0) return l; return level(node.right, ptr, lev + 1); } boolean isCousin(Node node, Node a, Node b) { return ((level(node, a, 1) == level(node, b, 1)) && (!isSibling(node, a, b))); } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(4); tree.root.left.right = new Node(5); tree.root.left.right.right = new Node(15); tree.root.right.left = new Node(6); tree.root.right.right = new Node(7); tree.root.right.left.right = new Node(8); Node Node1, Node2; Node1 = tree.root.left.left; Node2 = tree.root.right.right; if (tree.isCousin(tree.root, Node1, Node2)) System.out.println(\"Yes\"); else System.out.println(\"No\"); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\n\n\nboolean\nisSibling(Node node, Node a, Node b) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\nfalse\n; \n\n\nreturn\n((node.left == a && node.right == b) || \n\n(node.left == b && node.right == a) || \n\nisSibling(node.left, a, b) || \n\nisSibling(node.right, a, b)); \n\n} \n\n\n\n\n\n\nint\nlevel(Node node, Node ptr, \nint\nlev) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\nif\n(node == ptr) \n\nreturn\nlev; \n\n\n\n\nint\nl = level(node.left, ptr, lev + \n1\n); \n\nif\n(l != \n0\n) \n\nreturn\nl; \n\n\n\n\nreturn\nlevel(node.right, ptr, lev + \n1\n); \n\n} \n\n\n\n\nboolean\nisCousin(Node node, Node a, Node b) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\nreturn\n((level(node, a, \n1\n) == level(node, b, \n1\n)) && \n\n(!isSibling(node, a, b))); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.left.right.right = \nnew\nNode(\n15\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\ntree.root.right.left.right = \nnew\nNode(\n8\n); \n\n\nNode Node1, Node2; \n\nNode1 = tree.root.left.left; \n\nNode2 = tree.root.right.right; \n\nif\n(tree.isCousin(tree.root, Node1, Node2)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 215, "complexity": "1"}
{"back-translation": "class Node { int data; Node left, right; Node(int item) { data = item; left = right = null; } } class Leaf { int leaflevel=0; } class BinaryTree { Node root; Leaf mylevel = new Leaf(); boolean checkUtil(Node node, int level, Leaf leafLevel) { if(node == null) return true; if(node.left == null && node.right == null) { if(leafLevel.leaflevel == 0) { leafLevel.leaflevel = level; return true; } return (level == leafLevel.leaflevel); } return checkUtil(node.left, level + 1, leafLevel) && checkUtil(node.right, level + 1, leafLevel); } boolean check(Node node) { int level = 0; return checkUtil(node, level, mylevel); } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); tree.root = new Node(12); tree.root.left = new Node(5); tree.root.left.left = new Node(3); tree.root.left.right = new Node(9); tree.root.left.left.left = new Node(1); tree.root.left.right.left = new Node(1); if(tree.check(tree.root)) System.out.println(\"Leaves are at same level\"); else System.out.println(\"Leaves are not at same level\"); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nLeaf \n{ \n\nint\nleaflevel=\n0\n; \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nLeaf mylevel = \nnew\nLeaf(); \n\n\n\n\nboolean\ncheckUtil(Node node, \nint\nlevel, Leaf leafLevel) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\n{ \n\n\n\nif\n(leafLevel.leaflevel == \n0\n) \n\n{ \n\n\n\nleafLevel.leaflevel = level; \n\nreturn\ntrue\n; \n\n} \n\n\n\n\n\n\nreturn\n(level == leafLevel.leaflevel); \n\n} \n\n\n\n\n\n\nreturn\ncheckUtil(node.left, level + \n1\n, leafLevel) \n\n&& checkUtil(node.right, level + \n1\n, leafLevel); \n\n} \n\n\n\n\nboolean\ncheck(Node node) \n\n{ \n\nint\nlevel = \n0\n; \n\nreturn\ncheckUtil(node, level, mylevel); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n12\n); \n\ntree.root.left = \nnew\nNode(\n5\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.left.right = \nnew\nNode(\n9\n); \n\ntree.root.left.left.left = \nnew\nNode(\n1\n); \n\ntree.root.left.right.left = \nnew\nNode(\n1\n); \n\nif\n(tree.check(tree.root)) \n\nSystem.out.println(\n\"Leaves are at same level\"\n); \n\nelse\n\nSystem.out.println(\n\"Leaves are not at same level\"\n); \n\n} \n}", "index": 216, "complexity": "1"}
{"back-translation": "class Node { int data; Node left, right; Node(int key) { int data = key; left = right = null; } } class GFG { static boolean checkLevelLeafNode(Node root) { if (root == null) return true; Queue<Node> q = new LinkedList<>(); q.add(root); int result = Integer.MAX_VALUE; int level = 0; while (q.size() != 0) { int size = q.size(); level++; while (size > 0) { Node temp = q.remove(); if (temp.left != null) { q.add(temp.left); if (temp.left.left == null && temp.left.right == null) { if (result == Integer.MAX_VALUE) result = level; else if (result != level) return false; } } if (temp.right != null) { q.add(temp.right); if (temp.right.left == null && temp.right.right == null) { if (result == Integer.MAX_VALUE) result = level; else if (result != level) return false; } } size--; } } return true; } public static void main(String args[]) { Node root = new Node(1); root.left = new Node(2); root.right = new Node(3); root.left.right = new Node(4); root.right.left = new Node(5); root.right.right = new Node(6); boolean result = checkLevelLeafNode(root); if (result == true) System.out.println(\"All leaf nodes are at same level\"); else System.out.println(\"Leaf nodes not at same level\"); } }", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n\n\nNode(\nint\nkey) { \n\nint\ndata = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nGFG { \n\n\n\n\n\n\nstatic\nboolean\ncheckLevelLeafNode(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\nq.add(root); \n\n\nint\nresult = Integer.MAX_VALUE; \n\nint\nlevel = \n0\n; \n\n\n\n\nwhile\n(q.size() != \n0\n) { \n\nint\nsize = q.size(); \n\nlevel++; \n\n\n\n\nwhile\n(size > \n0\n) { \n\nNode temp = q.remove(); \n\n\n\n\nif\n(temp.left != \nnull\n) { \n\nq.add(temp.left); \n\n\n\n\nif\n(temp.left.left == \nnull\n&& temp.left.right == \nnull\n) { \n\n\n\n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n\n\n\n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n\n\nif\n(temp.right != \nnull\n) { \n\nq.add(temp.right); \n\n\n\n\nif\n(temp.right.left == \nnull\n&& temp.right.right == \nnull\n) { \n\n\n\n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n\n\n\n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\nsize--; \n\n} \n\n\n} \n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.right = \nnew\nNode(\n4\n); \n\nroot.right.left = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nboolean\nresult = checkLevelLeafNode(root); \n\nif\n(result == \ntrue\n) \n\nSystem.out.println(\n\"All leaf nodes are at same level\"\n); \n\nelse\n\nSystem.out.println(\n\"Leaf nodes not at same level\"\n); \n\n} \n}", "index": 217, "complexity": "1"}
{"back-translation": "class Node { int key; Node left, right; public Node(int key) { this.key = key; left = right = null; } } class Res { boolean res = false; } class BinaryTree { Node root; int count(Node node) { if (node == null) return 0; return count(node.left) + count(node.right) + 1; } int checkRec(Node root, int n, Res res) { if (root == null) return 0; int c = checkRec(root.left, n, res) + 1 + checkRec(root.right, n, res); if (c == n - c) res.res = true; return c; } boolean check(Node root) { int n = count(root); Res res = new Res(); checkRec(root, n, res); return res.res; } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(5); tree.root.left = new Node(1); tree.root.right = new Node(6); tree.root.left.left = new Node(3); tree.root.right.left = new Node(7); tree.root.right.right = new Node(4); if (tree.check(tree.root) == true) System.out.println(\"YES\"); else System.out.println(\"NO\"); } }", "src": "class\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n\n\npublic\nNode(\nint\nkey) \n\n{ \n\nthis\n.key = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nRes \n{ \n\nboolean\nres = \nfalse\n; \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nint\ncount(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\nreturn\ncount(node.left) + count(node.right) + \n1\n; \n\n} \n\n\n\n\n\n\n\n\n\n\nint\ncheckRec(Node root, \nint\nn, Res res) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\n\n\n\nint\nc = checkRec(root.left, n, res) + \n1\n\n+ checkRec(root.right, n, res); \n\n\n\n\n\n\nif\n(c == n - c) \n\nres.res = \ntrue\n; \n\n\n\n\nreturn\nc; \n\n} \n\n\n\n\nboolean\ncheck(Node root) \n\n{ \n\n\n\nint\nn = count(root); \n\n\n\n\nRes res = \nnew\nRes(); \n\ncheckRec(root, n, res); \n\n\nreturn\nres.res; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n1\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nif\n(tree.check(tree.root) == \ntrue\n) \n\nSystem.out.println(\n\"YES\"\n); \n\nelse\n\nSystem.out.println(\n\"NO\"\n); \n\n} \n}", "index": 218, "complexity": "1"}
{"back-translation": "class GfG { static class Node { int key; Node left, right; } static int findADepth(Node node) { int d = 0; while (node != null) { d++; node = node.left; } return d; } static boolean isPerfectRec(Node root, int d, int level) { if (root == null) return true; if (root.left == null && root.right == null) return (d == level + 1); if (root.left == null || root.right == null) return false; return isPerfectRec(root.left, d, level + 1) && isPerfectRec(root.right, d, level + 1); } static boolean isPerfect(Node root) { int d = findADepth(root); return isPerfectRec(root, d, 0); } static Node newNode(int k) { Node node = new Node(); node.key = k; node.right = null; node.left = null; return node; } public static void main(String args[]) { Node root = null; root = newNode(10); root.left = newNode(20); root.right = newNode(30); root.left.left = newNode(40); root.left.right = newNode(50); root.right.left = newNode(60); root.right.right = newNode(70); if (isPerfect(root) == true) System.out.println(\"Yes\"); else System.out.println(\"No\"); } }", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n} \n\n\nstatic\nint\nfindADepth(Node node) \n{ \nint\nd = \n0\n; \nwhile\n(node != \nnull\n) \n{ \n\nd++; \n\nnode = node.left; \n} \nreturn\nd; \n} \n\n\nstatic\nboolean\nisPerfectRec(Node root, \nint\nd, \nint\nlevel) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\n(d == level+\n1\n); \n\n\n\n\nif\n(root.left == \nnull\n|| root.right == \nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\nreturn\nisPerfectRec(root.left, d, level+\n1\n) && isPerfectRec(root.right, d, level+\n1\n); \n} \n\n\nstatic\nboolean\nisPerfect(Node root) \n{ \nint\nd = findADepth(root); \nreturn\nisPerfectRec(root, d, \n0\n); \n} \n\n\nstatic\nNode newNode(\nint\nk) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.key = k; \n\nnode.right = \nnull\n; \n\nnode.left = \nnull\n; \n\nreturn\nnode; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = \nnull\n; \n\nroot = newNode(\n10\n); \n\nroot.left = newNode(\n20\n); \n\nroot.right = newNode(\n30\n); \n\n\nroot.left.left = newNode(\n40\n); \n\nroot.left.right = newNode(\n50\n); \n\nroot.right.left = newNode(\n60\n); \n\nroot.right.right = newNode(\n70\n); \n\n\nif\n(isPerfect(root) == \ntrue\n) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n} \n}", "index": 219, "complexity": "1"}
{"back-translation": "class Node {\n    int data;\n    Node left, right;\n\n    Node(int item) {\n        data = item;\n        left = right = null;\n    }\n}\n\nclass BinaryTree {\n    Node root;\n\n    boolean isFullTree(Node node) {\n        if (node == null) return true;\n\n        if (node.left == null && node.right == null) return true;\n\n        if ((node.left != null) && (node.right != null))\n            return (isFullTree(node.left) && isFullTree(node.right));\n\n        return false;\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node(10);\n        tree.root.left = new Node(20);\n        tree.root.right = new Node(30);\n        tree.root.left.right = new Node(40);\n        tree.root.left.left = new Node(50);\n        tree.root.right.left = new Node(60);\n        tree.root.left.left.left = new Node(80);\n        tree.root.right.right = new Node(70);\n        tree.root.left.left.right = new Node(90);\n        tree.root.left.right.left = new Node(80);\n        tree.root.left.right.right = new Node(90);\n        tree.root.right.left.left = new Node(80);\n        tree.root.right.left.right = new Node(90);\n        tree.root.right.right.left = new Node(80);\n        tree.root.right.right.right = new Node(90);\n\n        if (tree.isFullTree(tree.root))\n            System.out.print(\"The binary tree is full\");\n        else\n            System.out.print(\"The binary tree is not full\");\n    }\n}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nboolean\nisFullTree(Node node) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nif\n(node.left == \nnull\n&& node.right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n((node.left!=\nnull\n) && (node.right!=\nnull\n)) \n\nreturn\n(isFullTree(node.left) && isFullTree(node.right)); \n\n\n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n20\n); \n\ntree.root.right = \nnew\nNode(\n30\n); \n\ntree.root.left.right = \nnew\nNode(\n40\n); \n\ntree.root.left.left = \nnew\nNode(\n50\n); \n\ntree.root.right.left = \nnew\nNode(\n60\n); \n\ntree.root.left.left.left = \nnew\nNode(\n80\n); \n\ntree.root.right.right = \nnew\nNode(\n70\n); \n\ntree.root.left.left.right = \nnew\nNode(\n90\n); \n\ntree.root.left.right.left = \nnew\nNode(\n80\n); \n\ntree.root.left.right.right = \nnew\nNode(\n90\n); \n\ntree.root.right.left.left = \nnew\nNode(\n80\n); \n\ntree.root.right.left.right = \nnew\nNode(\n90\n); \n\ntree.root.right.right.left = \nnew\nNode(\n80\n); \n\ntree.root.right.right.right = \nnew\nNode(\n90\n); \n\n\nif\n(tree.isFullTree(tree.root)) \n\nSystem.out.print(\n\"The binary tree is full\"\n); \n\nelse\n\nSystem.out.print(\n\"The binary tree is not full\"\n); \n\n} \n}", "index": 220, "complexity": "1"}
{"back-translation": "public\nclass\nCompleteBTree \n{ \n\nstatic\nclass\nNode \n{ \n\nint\ndata; \nNode left; \nNode right; \nNode(\nint\nd) \n{ \ndata = d; \nleft = \nnull\n; \nright = \nnull\n; \n} \n} \nstatic\nboolean\nisCompleteBT(Node root) \n{ \nif\n(root == \nnull\n) \nreturn\ntrue\n; \nQueue<Node> queue =\nnew\nLinkedList<>(); \nboolean flag = \nfalse\n; \nqueue.add(root); \nwhile\n(!queue.isEmpty()) \n{ \nNode temp_node = queue.remove(); \nif\n(temp_node.left != \nnull\n) \n{ \nif\n(flag == \ntrue\n) \nreturn\nfalse\n; \nqueue.add(temp_node.left); \n} \nelse\nflag = \ntrue\n; \nif\n(temp_node.right != \nnull\n) \n{ \nif\n(flag == \ntrue\n) \nreturn\nfalse\n; \nqueue.add(temp_node.right); \n} \nelse\nflag = \ntrue\n; \n} \nreturn\ntrue\n; \n} \npublic\nstatic\nvoid\nmain(String[] args) \n{ \nNode root = \nnew\nNode(\n1\n); \nroot.left = \nnew\nNode(\n2\n); \nroot.right = \nnew\nNode(\n3\n); \nroot.left.left = \nnew\nNode(\n4\n); \nroot.left.right = \nnew\nNode(\n5\n); \nroot.right.right = \nnew\nNode(\n6\n); \nif\n(isCompleteBT(root) == \ntrue\n) \nSystem.out.println(\n\"Complete Binary Tree\"\n); \nelse\nSystem.out.println(\n\"NOT Complete Binary Tree\"\n); \n} \n}", "src": "public\nclass\nCompleteBTree \n{ \n\n\n\nstatic\nclass\nNode \n\n{ \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n\n\nstatic\nboolean\nisCompleteBT(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<Node> queue =\nnew\nLinkedList<>(); \n\n\n\n\n\n\nboolean\nflag = \nfalse\n; \n\n\n\n\nqueue.add(root); \n\nwhile\n(!queue.isEmpty()) \n\n{ \n\nNode temp_node = queue.remove(); \n\n\n\n\nif\n(temp_node.left != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n\n\nqueue.add(temp_node.left); \n\n} \n\n\n\nelse\n\nflag = \ntrue\n; \n\n\n\n\nif\n(temp_node.right != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n\n\nqueue.add(temp_node.right); \n\n\n} \n\n\n\nelse\n\nflag = \ntrue\n; \n\n} \n\n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nif\n(isCompleteBT(root) == \ntrue\n) \n\nSystem.out.println(\n\"Complete Binary Tree\"\n); \n\nelse\n\nSystem.out.println(\n\"NOT Complete Binary Tree\"\n); \n\n} \n\n}", "index": 221, "complexity": "1"}
{"back-translation": "class Node {\n\n    char data;\n    Node left, right;\n\n    Node(char item) {\n        data = item;\n        left = right = null;\n    }\n}\n\nclass Passing {\n\n    int i;\n    int m = 0;\n    int n = 0;\n}\n\nclass BinaryTree {\n\n    static Node root;\n    Passing p = new Passing();\n\n    String strstr(String haystack, String needle) {\n        if (haystack == null || needle == null) {\n            return null;\n        }\n        int hLength = haystack.length();\n        int nLength = needle.length();\n        if (hLength < nLength) {\n            return null;\n        }\n        if (nLength == 0) {\n            return haystack;\n        }\n        for (int i = 0; i <= hLength - nLength; i++) {\n            if (haystack.charAt(i) == needle.charAt(0)) {\n                int j = 0;\n                for (; j < nLength; j++) {\n                    if (haystack.charAt(i + j) != needle.charAt(j)) {\n                        break;\n                    }\n                }\n                if (j == nLength) {\n                    return haystack.substring(i);\n                }\n            }\n        }\n        return null;\n    }\n\n    void storeInorder(Node node, char arr[], Passing i) {\n        if (node == null) {\n            arr[i.i++] = '$';\n            return;\n        }\n        storeInorder(node.left, arr, i);\n        arr[i.i++] = node.data;\n        storeInorder(node.right, arr, i);\n    }\n\n    void storePreOrder(Node node, char arr[], Passing i) {\n        if (node == null) {\n            arr[i.i++] = '$';\n            return;\n        }\n        arr[i.i++] = node.data;\n        storePreOrder(node.left, arr, i);\n        storePreOrder(node.right, arr, i);\n    }\n\n    boolean isSubtree(Node T, Node S) {\n        if (S == null) {\n            return true;\n        }\n        if (T == null) {\n            return false;\n        }\n        char inT[] = new char[100];\n        String op1 = String.valueOf(inT);\n        char inS[] = new char[100];\n        String op2 = String.valueOf(inS);\n        storeInorder(T, inT, p);\n        storeInorder(S, inS, p);\n        inT[p.m] = '\\0';\n        inS[p.m] = '\\0';\n        if (strstr(op1, op2) != null) {\n            return false;\n        }\n        p.m = 0;\n        p.n = 0;\n        char preT[] = new char[100];\n        char preS[] = new char[100];\n        String op3 = String.valueOf(preT);\n        String op4 = String.valueOf(preS);\n        storePreOrder(T, preT, p);\n        storePreOrder(S, preS, p);\n        preT[p.m] = '\\0';\n        preS[p.n] = '\\0';\n        return (strstr(op3, op4) != null);\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n\n        Node T = new Node('a');\n        T.left = new Node('b');\n        T.right = new Node('d');\n        T.left.left = new Node('c');\n        T.right.right = new Node('e');\n\n        Node S = new Node('a');\n        S.left = new Node('b');\n        S.right = new Node('d');\n        S.left.left = new Node('c');\n\n        if (tree.isSubtree(T, S)) {\n            System.out.println(\"Yes, S is a subtree of T\");\n        } else {\n            System.out.println(\"No, S is not a subtree of T\");\n        }\n    }\n}", "src": "class\nNode { \n\n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nPassing { \n\n\nint\ni; \n\nint\nm = \n0\n; \n\nint\nn = \n0\n; \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\nPassing p = \nnew\nPassing(); \n\n\nString strstr(String haystack, String needle) \n\n{ \n\nif\n(haystack == \nnull\n|| needle == \nnull\n) { \n\nreturn\nnull\n; \n\n} \n\nint\nhLength = haystack.length(); \n\nint\nnLength = needle.length(); \n\nif\n(hLength < nLength) { \n\nreturn\nnull\n; \n\n} \n\nif\n(nLength == \n0\n) { \n\nreturn\nhaystack; \n\n} \n\nfor\n(\nint\ni = \n0\n; i <= hLength - nLength; i++) { \n\nif\n(haystack.charAt(i) == needle.charAt(\n0\n)) { \n\nint\nj = \n0\n; \n\nfor\n(; j < nLength; j++) { \n\nif\n(haystack.charAt(i + j) != needle.charAt(j)) { \n\nbreak\n; \n\n} \n\n} \n\nif\n(j == nLength) { \n\nreturn\nhaystack.substring(i); \n\n} \n\n} \n\n} \n\nreturn\nnull\n; \n\n} \n\n\n\n\n\n\nvoid\nstoreInorder(Node node, \nchar\narr[], Passing i) \n\n{ \n\nif\n(node == \nnull\n) { \n\narr[i.i++] = \n'$'\n; \n\nreturn\n; \n\n} \n\nstoreInorder(node.left, arr, i); \n\narr[i.i++] = node.data; \n\nstoreInorder(node.right, arr, i); \n\n} \n\n\n\n\n\n\nvoid\nstorePreOrder(Node node, \nchar\narr[], Passing i) \n\n{ \n\nif\n(node == \nnull\n) { \n\narr[i.i++] = \n'$'\n; \n\nreturn\n; \n\n} \n\narr[i.i++] = node.data; \n\nstorePreOrder(node.left, arr, i); \n\nstorePreOrder(node.right, arr, i); \n\n} \n\n\n\n\nboolean\nisSubtree(Node T, Node S) \n\n{ \n\n\n\nif\n(S == \nnull\n) { \n\nreturn\ntrue\n; \n\n} \n\nif\n(T == \nnull\n) { \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\nchar\ninT[] = \nnew\nchar\n[\n100\n]; \n\nString op1 = String.valueOf(inT); \n\nchar\ninS[] = \nnew\nchar\n[\n100\n]; \n\nString op2 = String.valueOf(inS); \n\nstoreInorder(T, inT, p); \n\nstoreInorder(S, inS, p); \n\ninT[p.m] = \n'\\0'\n; \n\ninS[p.m] = \n'\\0'\n; \n\n\n\n\nif\n(strstr(op1, op2) != \nnull\n) { \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\np.m = \n0\n; \n\np.n = \n0\n; \n\nchar\npreT[] = \nnew\nchar\n[\n100\n]; \n\nchar\npreS[] = \nnew\nchar\n[\n100\n]; \n\nString op3 = String.valueOf(preT); \n\nString op4 = String.valueOf(preS); \n\nstorePreOrder(T, preT, p); \n\nstorePreOrder(S, preS, p); \n\npreT[p.m] = \n'\\0'\n; \n\npreS[p.n] = \n'\\0'\n; \n\n\n\n\n\n\nreturn\n(strstr(op3, op4) != \nnull\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode T = \nnew\nNode(\n'a'\n); \n\nT.left = \nnew\nNode(\n'b'\n); \n\nT.right = \nnew\nNode(\n'd'\n); \n\nT.left.left = \nnew\nNode(\n'c'\n); \n\nT.right.right = \nnew\nNode(\n'e'\n); \n\n\nNode S = \nnew\nNode(\n'a'\n); \n\nS.left = \nnew\nNode(\n'b'\n); \n\nS.right = \nnew\nNode(\n'd'\n); \n\nS.left.left = \nnew\nNode(\n'c'\n); \n\n\nif\n(tree.isSubtree(T, S)) { \n\nSystem.out.println(\n\"Yes, S is a subtree of T\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"No, S is not a subtree of T\"\n); \n\n} \n\n} \n}", "index": 222, "complexity": "1"}
{"back-translation": "class Node {\n\n    int data;\n    Node left, right;\n\n    public Node(int data) {\n        this.data = data;\n        left = right = null;\n    }\n}\n\nclass BinaryTree {\n\n    Node a, b;\n\n    public boolean areMirror(Node a, Node b) {\n\n        if (a == null && b == null)\n            return true;\n\n        if (a == null || b == null)\n            return false;\n\n        return a.data == b.data && areMirror(a.left, b.right) && areMirror(a.right, b.left);\n    }\n\n    public static void main(String[] args) {\n        BinaryTree tree = new BinaryTree();\n        Node a = new Node(1);\n        Node b = new Node(1);\n        a.left = new Node(2);\n        a.right = new Node(3);\n        a.left.left = new Node(4);\n        a.left.right = new Node(5);\n        b.left = new Node(3);\n        b.right = new Node(2);\n        b.right.left = new Node(5);\n        b.right.right = new Node(4);\n\n        if (tree.areMirror(a, b) == true)\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n    }\n}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode a, b; \n\n\n\n\nboolean\nareMirror(Node a, Node b) \n\n{ \n\n\n\nif\n(a == \nnull\n&& b == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nif\n(a == \nnull\n|| b == \nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\nreturn\na.data == b.data \n\n&& areMirror(a.left, b.right) \n\n&& areMirror(a.right, b.left); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode a = \nnew\nNode(\n1\n); \n\nNode b = \nnew\nNode(\n1\n); \n\na.left = \nnew\nNode(\n2\n); \n\na.right = \nnew\nNode(\n3\n); \n\na.left.left = \nnew\nNode(\n4\n); \n\na.left.right = \nnew\nNode(\n5\n); \n\n\nb.left = \nnew\nNode(\n3\n); \n\nb.right = \nnew\nNode(\n2\n); \n\nb.right.left = \nnew\nNode(\n5\n); \n\nb.right.right = \nnew\nNode(\n4\n); \n\n\nif\n(tree.areMirror(a, b) == \ntrue\n) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n\n} \n}", "index": 223, "complexity": "1"}
{"back-translation": "class GFG { static int findMedian(int[] arr, int i, int n) { if (i <= n) Arrays.sort(arr, i, n); else Arrays.sort(arr, n, i); return arr[n / 2]; } static int kthSmallest(int[] arr, int l, int r, int k) { if (k > 0 && k <= r - l + 1) { int n = r - l + 1; int i; int[] median = new int[(n + 4) / 5]; for (i = 0; i < n / 5; i++) median[i] = findMedian(arr, l + i * 5, 5); if (i * 5 < n) { median[i] = findMedian(arr, l + i * 5, n % 5); i++; } int medOfMed = (i == 1) ? median[i - 1] : kthSmallest(median, 0, i - 1, i / 2); int pos = partition(arr, l, r, medOfMed); if (pos - l == k - 1) return arr[pos]; if (pos - l > k - 1) return kthSmallest(arr, l, pos - 1, k); return kthSmallest(arr, pos + 1, r, k - pos + l - 1); } return Integer.MAX_VALUE; } static int[] swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } static int partition(int[] arr, int l, int r, int x) { int i; for (i = l; i < r; i++) if (arr[i] == x) break; swap(arr, i, r); i = l; for (int j = l; j <= r - 1; j++) { if (arr[j] <= x) { swap(arr, i, j); i++; } } swap(arr, i, r); return i; } public static void main(String[] args) { int arr[] = { 12, 3, 5, 7, 4, 19, 26 }; int n = arr.length, k = 3; System.out.println(\"K'th smallest element is \" + kthSmallest(arr, 0, n - 1, k)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nfindMedian(\nint\narr[], \nint\ni,\nint\nn) \n{ \n\nif\n(i <= n) \n\nArrays.sort(arr, i, n); \n\n\nelse\n\nArrays.sort(arr, n, i); \n\nreturn\narr[n/\n2\n]; \n\n} \n\n\n\n\n\nstatic\nint\nkthSmallest(\nint\narr[], \nint\nl, \nint\nr, \nint\nk) \n{ \n\n\n\n\n\nif\n(k > \n0\n&& k <= r - l + \n1\n) \n\n{ \n\nint\nn = r - l + \n1\n; \n\n\n\n\n\n\n\n\n\nint\ni; \n\n\n\n\nint\n[]median = \nnew\nint\n[(n + \n4\n) / \n5\n]; \n\nfor\n(i = \n0\n; i < n/\n5\n; i++) \n\nmedian[i] = findMedian(arr,l + i * \n5\n, \n5\n); \n\n\n\n\nif\n(i*\n5\n< n) \n\n{ \n\nmedian[i] = findMedian(arr,l + i * \n5\n, n % \n5\n); \n\ni++; \n\n} \n\n\n\n\n\n\n\n\nint\nmedOfMed = (i == \n1\n)? median[i - \n1\n]: \n\nkthSmallest(median, \n0\n, i - \n1\n, i / \n2\n); \n\n\n\n\n\n\nint\npos = partition(arr, l, r, medOfMed); \n\n\n\n\nif\n(pos-l == k - \n1\n) \n\nreturn\narr[pos]; \n\nif\n(pos-l > k - \n1\n) \n\n\nreturn\nkthSmallest(arr, l, pos - \n1\n, k); \n\n\n\n\nreturn\nkthSmallest(arr, pos + \n1\n, r, k - pos + l - \n1\n); \n\n} \n\n\n\n\nreturn\nInteger.MAX_VALUE; \n} \n\nstatic\nint\n[] swap(\nint\n[]arr, \nint\ni, \nint\nj) \n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n} \n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n{ \n\n\n\nint\ni; \n\nfor\n(i = l; i < r; i++) \n\nif\n(arr[i] == x) \n\nbreak\n; \n\nswap(arr, i, r); \n\n\n\n\ni = l; \n\nfor\n(\nint\nj = l; j <= r - \n1\n; j++) \n\n{ \n\nif\n(arr[j] <= x) \n\n{ \n\nswap(arr, i, j); \n\ni++; \n\n} \n\n} \n\nswap(arr, i, r); \n\nreturn\ni; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n12\n, \n3\n, \n5\n, \n7\n, \n4\n, \n19\n, \n26\n}; \n\nint\nn = arr.length, k = \n3\n; \n\nSystem.out.println(\n\"K'th smallest element is \"\n\n+ kthSmallest(arr, \n0\n, n - \n1\n, k)); \n} \n}", "index": 224, "complexity": "1"}
{"back-translation": "class GfG { static class Node { int data; Node left, right; } static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.left = null; temp.right = null; return temp; } static String areMirrors(Node root1, Node root2) { Stack<Node> st1 = new Stack<Node> (); Stack<Node> st2 = new Stack<Node> (); while(true) { while(root1 != null && root2 != null) { if(root1.data != root2.data) return \"No\"; st1.push(root1); st2.push(root2); root1 = root1.left; root2 = root2.right; } if(!(root1 == null && root2 == null)) return \"No\"; if(!st1.isEmpty() && !st2.isEmpty()) { root1 = st1.peek(); root2 = st2.peek(); st1.pop(); st2.pop(); root1 = root1.right; root2 = root2.left; } else break; } return \"Yes\"; } public static void main(String[] args) { Node root1 = newNode(1); root1.left = newNode(3); root1.right = newNode(2); root1.right.left = newNode(5); root1.right.right = newNode(4); Node root2 = newNode(1); root2.left = newNode(2); root2.right = newNode(3); root2.left.left = newNode(4); root2.left.right = newNode(5); System.out.println(areMirrors(root1, root2)); } }", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\n\nstatic\nString areMirrors(Node root1, Node root2) \n{ \n\nStack<Node> st1 = \nnew\nStack<Node> (); \n\nStack<Node> st2 = \nnew\nStack<Node> (); \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nwhile\n(root1 != \nnull\n&& root2 != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(root1.data != root2.data) \n\nreturn\n\"No\"\n; \n\n\nst1.push(root1); \n\nst2.push(root2); \n\nroot1 = root1.left; \n\nroot2 = root2.right; \n\n} \n\n\n\n\n\n\n\n\n\n\nif\n(!(root1 == \nnull\n&& root2 == \nnull\n)) \n\nreturn\n\"No\"\n; \n\n\nif\n(!st1.isEmpty() && !st2.isEmpty()) \n\n{ \n\nroot1 = st1.peek(); \n\nroot2 = st2.peek(); \n\nst1.pop(); \n\nst2.pop(); \n\n\n\n\nroot1 = root1.right; \n\n\n\n\nroot2 = root2.left; \n\n} \n\n\n\n\nelse\n\nbreak\n; \n\n} \n\n\n\n\nreturn\n\"Yes\"\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\nNode root1 = newNode(\n1\n); \n\n\nroot1.left = newNode(\n3\n); \n\n\nroot1.right = newNode(\n2\n); \n\n\nroot1.right.left = newNode(\n5\n); \n\n\nroot1.right.right = newNode(\n4\n); \n\n\n\n\n\nNode root2 = newNode(\n1\n); \n\n\nroot2.left = newNode(\n2\n); \n\n\nroot2.right = newNode(\n3\n); \n\n\nroot2.left.left = newNode(\n4\n); \n\n\nroot2.left.right = newNode(\n5\n); \n\n\n\nSystem.out.println(areMirrors(root1, root2)); \n} \n}", "index": 225, "complexity": "1"}
{"back-translation": "class Node { int data; Node left, right; Node(int item) { data = item; left = right = null; } }\n\nclass BinaryTree { Node root1, root2; boolean identicalTrees(Node a, Node b) { if (a == null && b == null) return true; if (a != null && b != null) return (a.data == b.data && identicalTrees(a.left, b.left) && identicalTrees(a.right, b.right)); return false; } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root1 = new Node(1); tree.root1.left = new Node(2); tree.root1.right = new Node(3); tree.root1.left.left = new Node(4); tree.root1.left.right = new Node(5); tree.root2 = new Node(1); tree.root2.left = new Node(2); tree.root2.right = new Node(3); tree.root2.left.left = new Node(4); tree.root2.left.right = new Node(5); if (tree.identicalTrees(tree.root1, tree.root2)) System.out.println(\"Both trees are identical\"); else System.out.println(\"Trees are not identical\"); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root1, root2; \n\n\n\n\nboolean\nidenticalTrees(Node a, Node b) \n\n{ \n\n\n\nif\n(a == \nnull\n&& b == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nif\n(a != \nnull\n&& b != \nnull\n) \n\nreturn\n(a.data == b.data \n\n&& identicalTrees(a.left, b.left) \n\n&& identicalTrees(a.right, b.right)); \n\n\n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\ntree.root1 = \nnew\nNode(\n1\n); \n\ntree.root1.left = \nnew\nNode(\n2\n); \n\ntree.root1.right = \nnew\nNode(\n3\n); \n\ntree.root1.left.left = \nnew\nNode(\n4\n); \n\ntree.root1.left.right = \nnew\nNode(\n5\n); \n\n\ntree.root2 = \nnew\nNode(\n1\n); \n\ntree.root2.left = \nnew\nNode(\n2\n); \n\ntree.root2.right = \nnew\nNode(\n3\n); \n\ntree.root2.left.left = \nnew\nNode(\n4\n); \n\ntree.root2.left.right = \nnew\nNode(\n5\n); \n\n\nif\n(tree.identicalTrees(tree.root1, tree.root2)) \n\nSystem.out.println(\n\"Both trees are identical\"\n); \n\nelse\n\nSystem.out.println(\n\"Trees are not identical\"\n); \n\n\n} \n}", "index": 226, "complexity": "1"}
{"back-translation": "public class CheckForPath {\n    public static boolean existPath(Node root, int[] arr, int index) {\n        if (root == null) {\n            return arr.length == 0;\n        }\n        if ((root.left == null && root.right == null) && (root.data == arr[index] && root.data == arr[arr.length - 1])) {\n            return true;\n        }\n        return (index < arr.length && (root.data == arr[index] && (existPath(root.left, arr, index + 1) || existPath(root.right, arr, index + 1))));\n    }\n    public static void main(String args[]) {\n        int arr[] = {5, 8, 6, 7};\n        Node root = new Node(5);\n        root.left = new Node(3);\n        root.right = new Node(8);\n        root.left.left = new Node(2);\n        root.left.right = new Node(4);\n        root.left.left.left = new Node(1);\n        root.right.left = new Node(6);\n        root.right.left.right = new Node(7);\n        if (existPath(root, arr, 0)) {\n            System.out.print(\"Path Exists\");\n        } else {\n            System.out.print(\"Path does not Exist\");\n        }\n    }\n}\nclass Node {\n    int data;\n    Node left, right;\n    Node(int data) {\n        this.data = data;\n        left = right = null;\n    }\n};", "src": "public\nclass\nCheckForPath { \n\n\n\n\n\n\n\n\n\n\npublic\nstatic\nboolean\nexistPath(Node root, \nint\narr[], \nint\nindex) \n\n{ \n\n\n\n\n\nif\n(root==\nnull\n) \n\n{ \n\nreturn\narr.length==\n0\n; \n\n} \n\n\n\n\n\n\nif\n((root.left==\nnull\n&& root.right==\nnull\n) && (root.data==arr[index] \n\n&& root.data==arr[arr.length-\n1\n])) \n\n{ \n\nreturn\ntrue\n; \n\n} \n\n\n\n\n\n\n\n\n\n\nreturn\n(index<arr.length && (root.data==arr[index] && \n\n(existPath(root.left,arr,index+\n1\n) || \n\nexistPath(root.right, arr, index+\n1\n)))); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\n\n\nint\narr[] = {\n5\n, \n8\n, \n6\n, \n7\n}; \n\nNode root=\nnew\nNode(\n5\n); \n\nroot.left=\nnew\nNode(\n3\n); \n\nroot.right=\nnew\nNode(\n8\n); \n\nroot.left.left = \nnew\nNode(\n2\n); \n\nroot.left.right = \nnew\nNode(\n4\n); \n\nroot.left.left.left = \nnew\nNode(\n1\n); \n\nroot.right.left = \nnew\nNode(\n6\n); \n\nroot.right.left.right = \nnew\nNode(\n7\n); \n\n\nif\n(existPath(root, arr, \n0\n)) \n\n{ \n\nSystem.out.print(\n\"Path Exists\"\n); \n\n} \n\nelse\n\n{ \n\nSystem.out.print(\n\"Path does not Exist\"\n); \n\n} \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\nleft=right=\nnull\n; \n\n} \n};", "index": 227, "complexity": "1"}
{"back-translation": "class GfG { static class Node { int data; Node left, right; } static Node newNode(int item) { Node temp = new Node(); temp.data = item; temp.left = null; temp.right = null; return temp; } static int getLevel(Node root, Node node, int level) { if (root == null) return 0; if (root == node) return level; int downlevel = getLevel(root.left, node, level+1); if (downlevel != 0) return downlevel; return getLevel(root.right, node, level+1); } static void printGivenLevel(Node root, Node node, int level) { if (root == null || level < 2) return; if (level == 2) { if (root.left == node || root.right == node) return; if (root.left != null) System.out.print(root.left.data + ", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\n\nstatic\nNode newNode(\nint\nitem) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = item; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nint\ngetLevel(Node root, Node node, \nint\nlevel) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n0\n; \n\nif\n(root == node) \n\nreturn\nlevel; \n\n\n\n\nint\ndownlevel = getLevel(root.left, node, level+\n1\n); \n\nif\n(downlevel != \n0\n) \n\nreturn\ndownlevel; \n\n\n\n\nreturn\ngetLevel(root.right, node, level+\n1\n); \n} \n\n\nstatic\nvoid\nprintGivenLevel(Node root, Node node, \nint\nlevel) \n{ \n\n\n\nif\n(root == \nnull\n|| level < \n2\n) \n\nreturn\n; \n\n\n\n\n\n\nif\n(level == \n2\n) \n\n{ \n\nif\n(root.left == node || root.right == node) \n\nreturn\n; \n\nif\n(root.left != \nnull\n) \n\nSystem.out.print(root.left.data + \n\" \"\n); \n\nif\n(root.right != \nnull\n) \n\nSystem.out.print(root.right.data + \n\" \"\n); \n\n} \n\n\n\n\nelse\nif\n(level > \n2\n) \n\n{ \n\nprintGivenLevel(root.left, node, level-\n1\n); \n\nprintGivenLevel(root.right, node, level-\n1\n); \n\n} \n} \n\n\nstatic\nvoid\nprintCousins(Node root, Node node) \n{ \n\n\n\nint\nlevel = getLevel(root, node, \n1\n); \n\n\n\n\nprintGivenLevel(root, node, level); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.left.right.right = newNode(\n15\n); \n\nroot.right.left = newNode(\n6\n); \n\nroot.right.right = newNode(\n7\n); \n\nroot.right.left.right = newNode(\n8\n); \n\n\nprintCousins(root, root.left.right); \n} \n}", "index": 228, "complexity": "1"}
{"back-translation": "public class PrintPath { public static boolean hasPath(Node root, ArrayList<Integer> arr, int x) { if (root == null) return false; arr.add(root.data); if (root.data == x) return true; if (hasPath(root.left, arr, x) || hasPath(root.right, arr, x)) return true; arr.remove(arr.size() - 1); return false; } public static void printPath(Node root, int x) { ArrayList<Integer> arr = new ArrayList<>(); if (hasPath(root, arr, x)) { for (int i = 0; i < arr.size() - 1; i++) System.out.print(arr.get(i) + \"->\"); System.out.print(arr.get(arr.size() - 1)); } else System.out.print(\"No Path\"); } public static void main(String args[]) { Node root = new Node(1); root.left = new Node(2); root.right = new Node(3); root.left.left = new Node(4); root.left.right = new Node(5); root.right.left = new Node(6); root.right.right = new Node(7); int x = 5; printPath(root, x); } } class Node { int data; Node left, right; Node(int data) { this.data = data; left = right = null; } };", "src": "public\nclass\nPrintPath { \n\n\n\n\n\n\n\n\npublic\nstatic\nboolean\nhasPath(Node root, ArrayList<Integer> arr, \nint\nx) \n\n{ \n\n\n\n\n\nif\n(root==\nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\narr.add(root.data); \n\n\n\n\n\n\nif\n(root.data == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\nif\n(hasPath(root.left, arr, x) || \n\nhasPath(root.right, arr, x)) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\narr.remove(arr.size()-\n1\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\npublic\nstatic\nvoid\nprintPath(Node root, \nint\nx) \n\n{ \n\n\n\nArrayList<Integer> arr=\nnew\nArrayList<>(); \n\n\n\n\n\n\nif\n(hasPath(root, arr, x)) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i<arr.size()-\n1\n; i++) \n\nSystem.out.print(arr.get(i)+\n\"->\"\n); \n\nSystem.out.print(arr.get(arr.size() - \n1\n)); \n\n} \n\n\n\n\nelse\n\nSystem.out.print(\n\"No Path\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.left = \nnew\nNode(\n6\n); \n\nroot.right.right = \nnew\nNode(\n7\n); \n\nint\nx=\n5\n; \n\nprintPath(root, x); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\nleft=right=\nnull\n; \n\n} \n};", "index": 229, "complexity": "1"}
{"back-translation": "class GfG { static class Node { int data; Node left, right; } static void printOddNodes(Node root, boolean isOdd) { if (root == null) return; if (isOdd == true) System.out.print(root.data + \" \"); printOddNodes(root.left, !isOdd); printOddNodes(root.right, !isOdd); } static Node newNode(int data) { Node node = new Node(); node.data = data; node.left = null; node.right = null; return (node); } public static void main(String[] args) { Node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); printOddNodes(root, true); } }", "src": "class\nGfG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\nstatic\nvoid\nprintOddNodes(Node root, \nboolean\nisOdd) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\nif\n(isOdd == \ntrue\n) \n\nSystem.out.print(root.data + \n\" \"\n); \n\n\n\n\n\n\nprintOddNodes(root.left, !isOdd); \n\nprintOddNodes(root.right, !isOdd); \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nprintOddNodes(root, \ntrue\n); \n\n} \n}", "index": 230, "complexity": "1"}
{"back-translation": "class GfG { static class Node { int data; Node left, right; } static void printOddNodes(Node root) { if (root == null) return; Queue<Node> q = new LinkedList<Node> (); q.add(root); boolean isOdd = true; while (true) { int nodeCount = q.size(); if (nodeCount == 0) break; while (nodeCount > 0) { Node node = q.peek(); if (isOdd == true) System.out.print(node.data + \" \"); q.remove(); if (node.left != null) q.add(node.left); if (node.right != null) q.add(node.right); nodeCount--; } isOdd = !isOdd; } } static Node newNode(int data) { Node node = new Node(); node.data = data; node.left = null; node.right = null; return(node); } public static void main(String[] args) { Node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); printOddNodes(root); } }", "src": "class\nGfG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nvoid\nprintOddNodes(Node root) \n{ \n\n\n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node> (); \n\n\n\n\nq.add(root); \n\nboolean\nisOdd = \ntrue\n; \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nif\n(isOdd == \ntrue\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\n\nisOdd = !isOdd; \n\n} \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nprintOddNodes(root); \n} \n}", "index": 231, "complexity": "1"}
{"back-translation": "public class FullNodes {\n\n    public static void findFullNode(Node root) {\n        if (root != null) {\n            findFullNode(root.left);\n            if (root.left != null && root.right != null)\n                System.out.print(root.data + \" \");\n            findFullNode(root.right);\n        }\n    }\n\n    public static void main(String args[]) {\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.right = new Node(3);\n        root.left.left = new Node(4);\n        root.right.left = new Node(5);\n        root.right.right = new Node(6);\n        root.right.left.right = new Node(7);\n        root.right.right.right = new Node(8);\n        root.right.left.right.left = new Node(9);\n        findFullNode(root);\n    }\n}\n\n\nclass Node {\n    int data;\n    Node left, right;\n\n    Node(int data) {\n        left = right = null;\n        this.data = data;\n    }\n};", "src": "public\nclass\nFullNodes { \n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nfindFullNode(Node root) \n\n{ \n\nif\n(root != \nnull\n) \n\n{ \n\nfindFullNode(root.left); \n\nif\n(root.left != \nnull\n&& root.right != \nnull\n) \n\nSystem.out.print(root.data+\n\" \"\n); \n\nfindFullNode(root.right); \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.right.left = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\nroot.right.left.right = \nnew\nNode(\n7\n); \n\nroot.right.right.right = \nnew\nNode(\n8\n); \n\nroot.right.left.right.left = \nnew\nNode(\n9\n); \n\nfindFullNode(root); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nleft=right=\nnull\n; \n\nthis\n.data=data; \n\n} \n};", "index": 232, "complexity": "1"}
{"back-translation": "class GFG { static int sum = 0; static class Node { int data; Node left, right; }; static Node getNode(int data) { Node newNode = new Node(); newNode.data = data; newNode.left = newNode.right = null; return newNode; } static void sumOfParentOfX(Node root, int x) { if (root == null) return; if ((root.left != null && root.left.data == x) || (root.right != null && root.right.data == x)) sum += root.data; sumOfParentOfX(root.left, x); sumOfParentOfX(root.right, x); } static int sumOfParentOfXUtil(Node root, int x) { sum = 0; sumOfParentOfX(root, x); return sum; } public static void main(String args[]) { Node root = getNode(4); root.left = getNode(2); root.right = getNode(5); root.left.left = getNode(7); root.left.right = getNode(2); root.right.left = getNode(2); root.right.right = getNode(3); int x = 2; System.out.println( \"Sum = \"+ sumOfParentOfXUtil(root, x)); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nsum = \n0\n; \n\n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n\nstatic\nNode getNode(\nint\ndata) \n{ \n\n\n\nNode newNode = \nnew\nNode(); \n\n\n\n\nnewNode.data = data; \n\nnewNode.left = newNode.right = \nnull\n; \n\nreturn\nnewNode; \n} \n\n\n\nstatic\nvoid\nsumOfParentOfX(Node root, \nint\nx) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\n\n\n\n\nif\n((root.left != \nnull\n&& root.left.data == x) || \n\n(root.right != \nnull\n&& root.right.data == x)) \n\nsum += root.data; \n\n\n\n\n\n\n\n\nsumOfParentOfX(root.left, x); \n\nsumOfParentOfX(root.right, x); \n\n} \n\n\n\n\nstatic\nint\nsumOfParentOfXUtil(Node root, \n\nint\nx) \n{ \n\nsum = \n0\n; \n\nsumOfParentOfX(root, x); \n\n\n\n\nreturn\nsum; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nNode root = getNode(\n4\n); \n\n\nroot.left = getNode(\n2\n); \n\n\nroot.right = getNode(\n5\n); \n\n\nroot.left.left = getNode(\n7\n); \n\n\nroot.left.right = getNode(\n2\n); \n\n\nroot.right.left = getNode(\n2\n); \n\nroot.right.right = getNode(\n3\n); \n\n\nint\nx = \n2\n; \n\n\nSystem.out.println( \n\"Sum = \"\n+ \n\nsumOfParentOfXUtil(root, x)); \n} \n}", "index": 233, "complexity": "1"}
{"back-translation": "class LinkedList { static LNode head; class LNode { int data; LNode next, prev; LNode(int d) { data = d; next = prev = null; } } class TNode { int data; TNode left, right; TNode(int d) { data = d; left = right = null; } } TNode sortedListToBST() { int n = countNodes(head); return sortedListToBSTRecur(n); } TNode sortedListToBSTRecur(int n) { if (n <= 0) return null; TNode left = sortedListToBSTRecur(n / 2); TNode root = new TNode(head.data); root.left = left; head = head.next; root.right = sortedListToBSTRecur(n - n / 2 - 1); return root; } int countNodes(LNode head) { int count = 0; LNode temp = head; while (temp != null) { temp = temp.next; count++; } return count; } void push(int new_data) { LNode new_node = new LNode(new_data); new_node.prev = null; new_node.next = head; if (head != null) head.prev = new_node; head = new_node; } void printList(LNode node) { while (node != null) { System.out.print(node.data + \" \"); node = node.next; } } void preOrder(TNode node) { if (node == null) return; System.out.print(node.data + \" \"); preOrder(node.left); preOrder(node.right); } public static void main(String[] args) { LinkedList llist = new LinkedList(); llist.push(7); llist.push(6); llist.push(5); llist.push(4); llist.push(3); llist.push(2); llist.push(1); System.out.println(\"Given Linked List \"); llist.printList(head); TNode root = llist.sortedListToBST(); System.out.println(\"\"); System.out.println(\"Pre-Order Traversal of constructed BST \"); llist.preOrder(root); } }", "src": "class\nLinkedList { \n\n\n\n\nstatic\nLNode head; \n\n\n\n\nclass\nLNode \n\n{ \n\nint\ndata; \n\nLNode next, prev; \n\n\nLNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\n\n\nclass\nTNode \n\n{ \n\nint\ndata; \n\nTNode left, right; \n\n\nTNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n\n} \n\n\n\n\nTNode sortedListToBST() \n\n{ \n\n\n\nint\nn = countNodes(head); \n\n\n\n\nreturn\nsortedListToBSTRecur(n); \n\n} \n\n\n\n\nTNode sortedListToBSTRecur(\nint\nn) \n\n{ \n\n\n\nif\n(n <= \n0\n) \n\nreturn\nnull\n; \n\n\n\n\nTNode left = sortedListToBSTRecur(n / \n2\n); \n\n\n\n\nTNode root = \nnew\nTNode(head.data); \n\n\n\n\nroot.left = left; \n\n\n\n\nhead = head.next; \n\n\n\n\nroot.right = sortedListToBSTRecur(n - n / \n2\n- \n1\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\n\n\nint\ncountNodes(LNode head) \n\n{ \n\nint\ncount = \n0\n; \n\nLNode temp = head; \n\nwhile\n(temp != \nnull\n) \n\n{ \n\ntemp = temp.next; \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\nLNode new_node = \nnew\nLNode(new_data); \n\n\n\n\nnew_node.prev = \nnull\n; \n\n\n\n\nnew_node.next = head; \n\n\n\n\nif\n(head != \nnull\n) \n\nhead.prev = new_node; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\nvoid\nprintList(LNode node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.next; \n\n} \n\n} \n\n\n\n\nvoid\npreOrder(TNode node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList llist = \nnew\nLinkedList(); \n\n\n\n\nllist.push(\n7\n); \n\nllist.push(\n6\n); \n\nllist.push(\n5\n); \n\nllist.push(\n4\n); \n\nllist.push(\n3\n); \n\nllist.push(\n2\n); \n\nllist.push(\n1\n); \n\n\nSystem.out.println(\n\"Given Linked List \"\n); \n\nllist.printList(head); \n\n\n\n\nTNode root = llist.sortedListToBST(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Pre-Order Traversal of constructed BST \"\n); \n\nllist.preOrder(root); \n\n} \n}", "index": 234, "complexity": "1"}
{"back-translation": "class Test { static int arr[] = {10, 324, 45, 90, 9808}; static int largest() { int i; int max = arr[0]; for (i = 1; i < arr.length; i++) if (arr[i] > max) max = arr[i]; return max; } public static void main(String[] args) { System.out.println(\"Largest in given array is \" + largest()); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = {\n10\n, \n324\n, \n45\n, \n90\n, \n9808\n}; \n\n\n\n\nstatic\nint\nlargest() \n\n{ \n\nint\ni; \n\n\n\n\nint\nmax = arr[\n0\n]; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < arr.length; i++) \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Largest in given array is \"\n+ largest()); \n\n} \n\n}", "index": 235, "complexity": "1"}
{"back-translation": "ERROR", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\n\n\n\nNode sortedArrayToBST(\nint\narr[], \nint\nstart, \nint\nend) { \n\n\n\n\nif\n(start > end) { \n\nreturn\nnull\n; \n\n} \n\n\n\n\nint\nmid = (start + end) / \n2\n; \n\nNode node = \nnew\nNode(arr[mid]); \n\n\n\n\nnode.left = sortedArrayToBST(arr, start, mid - \n1\n); \n\n\n\n\nnode.right = sortedArrayToBST(arr, mid + \n1\n, end); \n\n\nreturn\nnode; \n\n} \n\n\n\n\nvoid\npreOrder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nint\nn = arr.length; \n\nroot = tree.sortedArrayToBST(arr, \n0\n, n - \n1\n); \n\nSystem.out.println(\n\"Preorder traversal of constructed BST\"\n); \n\ntree.preOrder(root); \n\n} \n}", "index": 236, "complexity": "1"}
{"back-translation": "class Node { int data; Node left, right; Node(int d) { data = d; left = right = null; } } class Sum { int sum = 0; } class BinaryTree { static Node root; Sum summ = new Sum(); void addGreaterUtil(Node node, Sum sum_ptr) { if (node == null) { return; } addGreaterUtil(node.right, sum_ptr); sum_ptr.sum = sum_ptr.sum + node.data; node.data = sum_ptr.sum; addGreaterUtil(node.left, sum_ptr); } Node addGreater(Node node) { addGreaterUtil(node, summ); return node; } void printInorder(Node node) { if (node == null) { return; } printInorder(node.left); System.out.print(node.data + \" \"); printInorder(node.right); } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(5); tree.root.left = new Node(2); tree.root.right = new Node(13); System.out.println(\"Inorder traversal of given tree \"); tree.printInorder(root); Node node = tree.addGreater(root); System.out.println(\"\"); System.out.println(\"Inorder traversal of modified tree \"); tree.printInorder(node); } }", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nSum { \n\n\nint\nsum = \n0\n; \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\nSum summ = \nnew\nSum(); \n\n\n\n\n\n\nvoid\naddGreaterUtil(Node node, Sum sum_ptr) { \n\n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\n\n\n\naddGreaterUtil(node.right, sum_ptr); \n\n\n\n\nsum_ptr.sum = sum_ptr.sum + node.data; \n\n\n\n\nnode.data = sum_ptr.sum; \n\n\n\n\n\n\naddGreaterUtil(node.left, sum_ptr); \n\n} \n\n\n\n\n\n\nNode addGreater(Node node) { \n\naddGreaterUtil(node, summ); \n\nreturn\nnode; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n13\n); \n\n\nSystem.out.println(\n\"Inorder traversal of given tree \"\n); \n\ntree.printInorder(root); \n\nNode node = tree.addGreater(root); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Inorder traversal of modified tree \"\n); \n\ntree.printInorder(node); \n\n} \n}", "index": 237, "complexity": "1"}
{"back-translation": "class Node { int data; Node left, right; Node(int d) { data = d; left = right = null; } } class BinaryTree { static Node head; Node insert(Node node, int data) { if (node == null) { return (new Node(data)); } else { if (data <= node.data) { node.left = insert(node.left, data); } else { node.right = insert(node.right, data); } return node; } } int minvalue(Node node) { Node current = node; while (current.left != null) { current = current.left; } return (current.data); } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); Node root = null; root = tree.insert(root, 4); tree.insert(root, 2); tree.insert(root, 1); tree.insert(root, 3); tree.insert(root, 6); tree.insert(root, 5); System.out.println(\"Minimum value of BST is \" + tree.minvalue(root)); } }", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode head; \n\n\n\n\nNode insert(Node node, \nint\ndata) { \n\n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n(\nnew\nNode(data)); \n\n} \nelse\n{ \n\n\n\n\nif\n(data <= node.data) { \n\nnode.left = insert(node.left, data); \n\n} \nelse\n{ \n\nnode.right = insert(node.right, data); \n\n} \n\n\n\n\nreturn\nnode; \n\n} \n\n} \n\n\n\n\nint\nminvalue(Node node) { \n\nNode current = node; \n\n\n\n\nwhile\n(current.left != \nnull\n) { \n\ncurrent = current.left; \n\n} \n\nreturn\n(current.data); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode root = \nnull\n; \n\nroot = tree.insert(root, \n4\n); \n\ntree.insert(root, \n2\n); \n\ntree.insert(root, \n1\n); \n\ntree.insert(root, \n3\n); \n\ntree.insert(root, \n6\n); \n\ntree.insert(root, \n5\n); \n\n\nSystem.out.println(\n\"Minimum value of BST is \"\n+ tree.minvalue(root)); \n\n} \n}", "index": 238, "complexity": "1"}
{"back-translation": "class Solution { static class NodeDetails { int data; int min, max; } static boolean levelOrderIsOfBST(int arr[], int n) { if (n == 0) return true; Queue<NodeDetails> q = new LinkedList<NodeDetails>(); int i = 0; NodeDetails newNode = new NodeDetails(); newNode.data = arr[i++]; newNode.min = Integer.MIN_VALUE; newNode.max = Integer.MAX_VALUE; q.add(newNode); while (i != n && q.size() > 0) { NodeDetails temp = q.peek(); q.remove(); newNode = new NodeDetails(); if ( i < n && (arr[i] < (int)temp.data && arr[i] > (int)temp.min)) { newNode.data = arr[i++]; newNode.min = temp.min; newNode.max = temp.data; q.add(newNode); } newNode = new NodeDetails(); if ( i < n && (arr[i] > (int)temp.data && arr[i] < (int)temp.max)) { newNode.data = arr[i++]; newNode.min = temp.data; newNode.max = temp.max; q.add(newNode); } } if (i == n) return true; return false; } public static void main(String args[]) { int arr[] = { 7, 4, 12, 3, 6, 8, 1, 5, 10 }; int n = arr.length; if (levelOrderIsOfBST(arr, n)) System.out.print( ", "src": "class\nSolution \n{ \n\n\n\n\n\nstatic\nclass\nNodeDetails \n{ \n\nint\ndata; \n\nint\nmin, max; \n}; \n\n\n\n\nstatic\nboolean\nlevelOrderIsOfBST(\nint\narr[], \nint\nn) \n{ \n\n\n\nif\n(n == \n0\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<NodeDetails> q = \nnew\nLinkedList<NodeDetails>(); \n\n\n\n\nint\ni = \n0\n; \n\n\n\n\n\n\nNodeDetails newNode=\nnew\nNodeDetails(); \n\nnewNode.data = arr[i++]; \n\nnewNode.min = Integer.MIN_VALUE; \n\nnewNode.max = Integer.MAX_VALUE; \n\nq.add(newNode); \n\n\n\n\n\n\nwhile\n(i != n && q.size() > \n0\n) \n\n{ \n\n\n\n\n\nNodeDetails temp = q.peek(); \n\nq.remove(); \n\nnewNode = \nnew\nNodeDetails(); \n\n\n\n\n\n\n\n\nif\n(i < n && (arr[i] < (\nint\n)temp.data && \n\narr[i] > (\nint\n)temp.min)) \n\n{ \n\n\n\n\n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.min; \n\nnewNode.max = temp.data; \n\nq.add(newNode); \n\n} \n\n\nnewNode=\nnew\nNodeDetails(); \n\n\n\n\n\n\n\n\nif\n(i < n && (arr[i] > (\nint\n)temp.data && \n\narr[i] < (\nint\n)temp.max)) \n\n{ \n\n\n\n\n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.data; \n\nnewNode.max = temp.max; \n\nq.add(newNode); \n\n} \n\n} \n\n\n\n\n\n\nif\n(i == n) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nreturn\nfalse\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n7\n, \n4\n, \n12\n, \n3\n, \n6\n, \n8\n, \n1\n, \n5\n, \n10\n}; \n\nint\nn = arr.length; \n\nif\n(levelOrderIsOfBST(arr, n)) \n\nSystem.out.print( \n\"Yes\"\n); \n\nelse\n\nSystem.out.print( \n\"No\"\n); \n\n} \n}", "index": 239, "complexity": "1"}
{"back-translation": "class GfG { static class Node { int data; Node left, right; } static Node createNewNode(int data) { Node temp = new Node(); temp.data = data; temp.right = null; temp.left = null; return temp; } static Node findKthLargestUsingMorrisTraversal(Node root, int k) { Node current = root; Node kLargest = null; int count = 0; while (current != null) { if (current.right == null) { if (++count == k) kLargest = current; current = current.left; } else { Node successor = current.right; while (successor.left != null && successor.left != current) successor = successor.left; if (successor.left == null) { successor.left = current; current = current.right; } else { successor.left = null; if (++count == k) kLargest = current; current = current.left; } } } return kLargest; } public static void main(String[] args) { Node root = createNewNode(4); root.left = createNewNode(2); root.right = createNewNode(7); root.left.left = createNewNode(1); root.left.right = createNewNode(3); root.right.left = createNewNode(6); root.right.right = createNewNode(10); System.out.println(\"Finding K-th largest Node in BST : \" + findKthLargestUsingMorrisTraversal(root, 2).data); } }", "src": "class\nGfG \n{ \n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.right = \nnull\n; \n\ntemp.left = \nnull\n; \n\nreturn\ntemp; \n} \n\nstatic\nNode KthLargestUsingMorrisTraversal(Node root, \nint\nk) \n{ \n\nNode curr = root; \n\nNode Klargest = \nnull\n; \n\n\n\n\nint\ncount = \n0\n; \n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\n\n\nif\n(curr.right == \nnull\n) \n\n{ \n\n\n\n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n\n\ncurr = curr.left; \n\n} \n\n\nelse\n\n{ \n\n\n\n\nNode succ = curr.right; \n\n\nwhile\n(succ.left != \nnull\n&& succ.left != curr) \n\nsucc = succ.left; \n\n\nif\n(succ.left == \nnull\n) \n\n{ \n\n\n\n\n\n\nsucc.left = curr; \n\n\n\n\ncurr = curr.right; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\n\nsucc.left = \nnull\n; \n\n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n\n\ncurr = curr.left; \n\n} \n\n} \n\n} \n\nreturn\nKlargest; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\n\n\n\nNode root = newNode(\n4\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n7\n); \n\nroot.left.left = newNode(\n1\n); \n\nroot.left.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n6\n); \n\nroot.right.right = newNode(\n10\n); \n\n\nSystem.out.println(\n\"Finding K-th largest Node in BST : \"\n+ \n\nKthLargestUsingMorrisTraversal(root, \n2\n).data); \n} \n}", "index": 240, "complexity": "1"}
{"back-translation": "class Node {\n\n    int data;\n    Node left, right;\n\n    Node(int d) {\n        data = d;\n        left = right = null;\n    }\n}\n\nclass BinarySearchTree {\n\n    Node root;\n\n    BinarySearchTree() {\n        root = null;\n    }\n\n    public void insert(int data) {\n        this.root = this.insertRec(this.root, data);\n    }\n\n    Node insertRec(Node node, int data) {\n        if (node == null) {\n            this.root = new Node(data);\n            return this.root;\n        }\n        if (data < node.data) {\n            node.left = this.insertRec(node.left, data);\n        } else {\n            node.right = this.insertRec(node.right, data);\n        }\n        return node;\n    }\n\n    public class count {\n\n        int c = 0;\n    }\n\n    void secondLargestUtil(Node node, count C) {\n        if (node == null || C.c >= 2)\n            return;\n        this.secondLargestUtil(node.right, C);\n        C.c++;\n        if (C.c == 2) {\n            System.out.print(\"2nd largest element is \" + node.data);\n            return;\n        }\n        this.secondLargestUtil(node.left, C);\n    }\n\n    void secondLargest(Node node) {\n        count C = new count();\n        this.secondLargestUtil(this.root, C);\n    }\n\n    public static void main(String[] args) {\n        BinarySearchTree tree = new BinarySearchTree();\n\n        tree.insert(50);\n        tree.insert(30);\n        tree.insert(20);\n        tree.insert(40);\n        tree.insert(70);\n        tree.insert(60);\n        tree.insert(80);\n\n        tree.secondLargest(tree.root);\n    }\n}", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n\n\nNode root; \n\n\n\n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n\n\npublic\nvoid\ninsert(\nint\ndata) \n\n{ \n\nthis\n.root = \nthis\n.insertRec(\nthis\n.root, data); \n\n} \n\n\n\n\nNode insertRec(Node node, \nint\ndata) \n\n{ \n\n\n\nif\n(node == \nnull\n) { \n\nthis\n.root = \nnew\nNode(data); \n\nreturn\nthis\n.root; \n\n} \n\n\n\n\nif\n(data < node.data) { \n\nnode.left = \nthis\n.insertRec(node.left, data); \n\n} \nelse\n{ \n\nnode.right = \nthis\n.insertRec(node.right, data); \n\n} \n\nreturn\nnode; \n\n} \n\n\n\n\npublic\nclass\ncount { \n\nint\nc = \n0\n; \n\n} \n\n\n\n\nvoid\nsecondLargestUtil(Node node, count C) \n\n{ \n\n\n\n\n\nif\n(node == \nnull\n|| C.c >= \n2\n) \n\nreturn\n; \n\n\n\n\n\n\nthis\n.secondLargestUtil(node.right, C); \n\n\n\n\nC.c++; \n\n\n\n\nif\n(C.c == \n2\n) { \n\nSystem.out.print(\n\"2nd largest element is \"\n+ \n\nnode.data); \n\nreturn\n; \n\n} \n\n\n\n\nthis\n.secondLargestUtil(node.left, C); \n\n} \n\n\n\n\nvoid\nsecondLargest(Node node) \n\n{ \n\n\n\ncount C = \nnew\ncount(); \n\nthis\n.secondLargestUtil(\nthis\n.root, C); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n\n\n\ntree.insert(\n50\n); \n\ntree.insert(\n30\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n40\n); \n\ntree.insert(\n70\n); \n\ntree.insert(\n60\n); \n\ntree.insert(\n80\n); \n\n\ntree.secondLargest(tree.root); \n\n} \n}", "index": 241, "complexity": "1"}
{"back-translation": "class GfG { static class Node { int key; Node left, right; } static int KSmallestUsingMorris(Node root, int k) { int count = 0; int ksmall = Integer.MIN_VALUE; Node curr = root; while (curr != null) { if (curr.left == null) { count++; if (count==k) ksmall = curr.key; curr = curr.right; } else { Node pre = curr.left; while (pre.right != null && pre.right != curr) pre = pre.right; if (pre.right== null) { pre.right = curr; curr = curr.left; } else { pre.right = null; count++; if (count==k) ksmall = curr.key; curr = curr.right; } } } return ksmall; } static Node newNode(int item) { Node temp = new Node(); temp.key = item; temp.left = null; temp.right = null; return temp; } static Node insert(Node node, int key) { if (node == null) return newNode(key); if (key < node.key) node.left = insert(node.left, key); else if (key > node.key) node.right = insert(node.right, key); return node; } public static void main(String[] args) { Node root = null; root = insert(root, 50); insert(root, 30); insert(root, 20); insert(root, 40); insert(root, 70); insert(root, 60); insert(root, 80); for (int k=1; k<=7; k++) System.out.print(KSmallestUsingMorris(root, k) + \" \"); } }", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n} \n\n\nstatic\nint\nKSmallestUsingMorris(Node root, \nint\nk) \n{ \n\n\n\n\n\nint\ncount = \n0\n; \n\n\nint\nksmall = Integer.MIN_VALUE; \n\n\nNode curr = root; \n\n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\nif\n(curr.left == \nnull\n) \n\n{ \n\ncount++; \n\n\n\n\n\n\nif\n(count==k) \n\nksmall = curr.key; \n\n\n\n\ncurr = curr.right; \n\n} \n\nelse\n\n{ \n\n\n\n\n\nNode pre = curr.left; \n\nwhile\n(pre.right != \nnull\n&& pre.right != curr) \n\npre = pre.right; \n\n\n\n\nif\n(pre.right== \nnull\n) \n\n{ \n\n\n\npre.right = curr; \n\ncurr = curr.left; \n\n} \n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\n\n\npre.right = \nnull\n; \n\n\ncount++; \n\n\n\n\n\n\nif\n(count==k) \n\nksmall = curr.key; \n\n\ncurr = curr.right; \n\n} \n\n} \n\n} \n\nreturn\nksmall; \n\n} \n\n\nstatic\nNode newNode(\nint\nitem) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.key = item; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode insert(Node node, \nint\nkey) \n{ \n\n\n\nif\n(node == \nnull\n) \nreturn\nnewNode(key); \n\n\n\n\nif\n(key < node.key) \n\nnode.left = insert(node.left, key); \n\nelse\nif\n(key > node.key) \n\nnode.right = insert(node.right, key); \n\n\n\n\nreturn\nnode; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\nNode root = \nnull\n; \n\nroot = insert(root, \n50\n); \n\ninsert(root, \n30\n); \n\ninsert(root, \n20\n); \n\ninsert(root, \n40\n); \n\ninsert(root, \n70\n); \n\ninsert(root, \n60\n); \n\ninsert(root, \n80\n); \n\n\nfor\n(\nint\nk=\n1\n; k<=\n7\n; k++) \n\nSystem.out.print(KSmallestUsingMorris(root, k) + \n\" \"\n); \n\n} \n}", "index": 242, "complexity": "1"}
{"back-translation": "class GFG { static boolean isInorder(int[] arr, int n) { if (n == 0 || n == 1) { return true; } for (int i = 1; i < n; i++) { if (arr[i - 1] > arr[i]) { return false; } } return true; } public static void main(String[] args) { int arr[] = {19, 23, 25, 30, 45}; int n = arr.length; if (isInorder(arr, n)) { System.out.println(\"Yes\"); } else { System.out.println(\"Non\"); } } }", "src": "class\nGFG { \n\n\n\n\nstatic\nboolean\nisInorder(\nint\n[] arr, \nint\nn) { \n\n\n\nif\n(n == \n0\n|| n == \n1\n) { \n\nreturn\ntrue\n; \n\n} \n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n\n{ \n\nif\n(arr[i - \n1\n] > arr[i]) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n\n\nreturn\ntrue\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n19\n, \n23\n, \n25\n, \n30\n, \n45\n}; \n\nint\nn = arr.length; \n\nif\n(isInorder(arr, n)) { \n\nSystem.out.println(\n\"Yes\"\n); \n\n} \nelse\n{ \n\nSystem.out.println(\n\"Non\"\n); \n\n} \n\n} \n}", "index": 243, "complexity": "1"}
{"back-translation": "class PrintLargest { static void print3largest(int[] arr, int arr_size) { int i, first, second, third; if (arr_size < 3) { System.out.print(\" Invalid Input \"); return; } third = first = second = Integer.MIN_VALUE; for (i = 0; i < arr_size; i++) { if (arr[i] > first) { third = second; second = first; first = arr[i]; } else if (arr[i] > second) { third = second; second = arr[i]; } else if (arr[i] > third) third = arr[i]; } System.out.println(\"Three largest elements are \" + first + \" \" + second + \" \" + third); } public static void main(String[] args) { int arr[] = { 12, 13, 1, 10, 34, 1 }; int n = arr.length; print3largest(arr, n); } }", "src": "class\nPrintLargest \n{ \n\n\n\nstatic\nvoid\nprint3largest(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ni, first, second, third; \n\n\n\n\nif\n(arr_size < \n3\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nthird = first = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nthird = second; \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second) \n\n{ \n\nthird = second; \n\nsecond = arr[i]; \n\n} \n\n\nelse\nif\n(arr[i] > third) \n\nthird = arr[i]; \n\n} \n\n\nSystem.out.println(\n\"Three largest elements are \"\n+ \n\nfirst + \n\" \"\n+ second + \n\" \"\n+ third); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint3largest(arr, n); \n\n} \n}", "index": 244, "complexity": "1"}
{"back-translation": "public class GFG { static class Node { int data; Node left, right; public Node(int data) { this.data = data; left = null; right = null; } } static Node root1; static Node root2; static int countPairs(Node root1, Node root2, int x) { if (root1 == null || root2 == null) return 0; Stack<Node> st1 = new Stack<>(); Stack<Node> st2 = new Stack<>(); Node top1, top2; int count = 0; while (true) { while (root1 != null) { st1.push(root1); root1 = root1.left; } while (root2 != null) { st2.push(root2); root2 = root2.right; } if (st1.empty() || st2.empty()) break; top1 = st1.peek(); top2 = st2.peek(); if ((top1.data + top2.data) == x) { count++; st1.pop(); st2.pop(); root1 = top1.right; root2 = top2.left; } else if ((top1.data + top2.data) < x) { st1.pop(); root1 = top1.right; } else { st2.pop(); root2 = top2.left; } } return count; } public static void main(String args[]) { root1 = new Node(5); root1.left = new Node(3); root1.right = new Node(7); root1.left.left = new Node(2); root1.left.right = new Node(4); root1.right.left = new Node(6); root1.right.right = new Node(8); root2 = new Node(10); root2.left = new Node(6); root2.right = new Node(15); root2.left.left = new Node(3); root2.left.right = new Node(8); root2.right.left = new Node(11); root2.right.right = new Node(18); int x = 16; System.out.println(\"Pairs = \" + countPairs(root1, root2, x)); } }", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n\n\npublic\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\nstatic\nNode root1; \n\nstatic\nNode root2; \n\n\n\n\n\nstatic\nint\ncountPairs(Node root1, Node root2, \n\nint\nx) \n\n{ \n\n\n\nif\n(root1 == \nnull\n|| root2 == \nnull\n) \n\nreturn\n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\nStack<Node> st1 = \nnew\nStack<>(); \n\nStack<Node> st2 = \nnew\nStack<>(); \n\nNode top1, top2; \n\n\nint\ncount = \n0\n; \n\n\n\n\n\n\nwhile\n(\ntrue\n) { \n\n\n\n\n\n\nwhile\n(root1 != \nnull\n) { \n\nst1.push(root1); \n\nroot1 = root1.left; \n\n} \n\n\n\n\n\n\nwhile\n(root2 != \nnull\n) { \n\nst2.push(root2); \n\nroot2 = root2.right; \n\n} \n\n\n\n\n\n\nif\n(st1.empty() || st2.empty()) \n\nbreak\n; \n\n\ntop1 = st1.peek(); \n\ntop2 = st2.peek(); \n\n\n\n\nif\n((top1.data + top2.data) == x) { \n\n\n\ncount++; \n\n\n\n\nst1.pop(); \n\nst2.pop(); \n\n\n\n\n\n\nroot1 = top1.right; \n\nroot2 = top2.left; \n\n} \n\n\n\n\n\n\nelse\nif\n((top1.data + top2.data) < x) { \n\nst1.pop(); \n\nroot1 = top1.right; \n\n} \n\n\n\n\n\n\nelse\n{ \n\nst2.pop(); \n\nroot2 = top2.left; \n\n} \n\n} \n\n\n\n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nroot1 = \nnew\nNode(\n5\n); \n\n\nroot1.left = \nnew\nNode(\n3\n); \n\n\nroot1.right = \nnew\nNode(\n7\n); \n\n\nroot1.left.left = \nnew\nNode(\n2\n); \n\n\nroot1.left.right = \nnew\nNode(\n4\n); \n\n\nroot1.right.left = \nnew\nNode(\n6\n); \n\nroot1.right.right = \nnew\nNode(\n8\n); \n\n\n\n\nroot2 = \nnew\nNode(\n10\n); \n\n\nroot2.left = \nnew\nNode(\n6\n); \n\n\nroot2.right = \nnew\nNode(\n15\n); \n\n\nroot2.left.left = \nnew\nNode(\n3\n); \n\n\nroot2.left.right = \nnew\nNode(\n8\n); \n\n\nroot2.right.left = \nnew\nNode(\n11\n); \n\nroot2.right.right = \nnew\nNode(\n18\n); \n\n\nint\nx = \n16\n; \n\nSystem.out.println(\n\"Pairs = \"\n\n+ countPairs(root1, root2, x)); \n\n} \n}", "index": 245, "complexity": "1"}
{"back-translation": "class Node {\n\n    int key;\n\n    Node left;\n\n    Node right;\n}\n\nclass GFG {\n\n    private static Node removeOutsideRange(Node root, int min, int max) {\n\n        if (root == null) {\n\n            return null;\n        }\n\n        root.left = removeOutsideRange(root.left, min, max); \n\n        root.right = removeOutsideRange(root.right, min, max);\n\n        if (root.key < min) {\n\n            Node rchild = root.right;\n\n            root = null;\n            return rchild;\n        }\n\n        if (root.key > max) {\n\n            Node lchild = root.left;\n\n            root = null;\n            return lchild;\n        }\n\n        return root;\n    }\n\n    public static Node newNode(int num) {\n\n        Node temp = new Node();\n        temp.key = num;\n        temp.left = null;\n        temp.right = null;\n\n        return temp;\n    }\n\n    public static Node insert(Node root, int key) {\n\n        if (root == null) {\n\n            return newNode(key);\n        }\n\n        if (root.key > key) {\n\n            root.left = insert(root.left, key);\n        } else {\n\n            root.right = insert(root.right, key);\n        }\n\n        return root;\n    }\n\n    private static void inorderTraversal(Node root) {\n\n        if (root != null) {\n\n            inorderTraversal(root.left);\n            System.out.print(root.key + \" \");\n            inorderTraversal(root.right);\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Node root = null;\n        root = insert(root, 6);\n        root = insert(root, -13);\n        root = insert(root, 14);\n        root = insert(root, -8);\n        root = insert(root, 15);\n        root = insert(root, 13);\n        root = insert(root, 7);\n\n        System.out.print(\"Inorder Traversal of the given tree is: \");\n        inorderTraversal(root);\n\n        root = removeOutsideRange(root, -10, 13);\n\n        System.out.print(\"\\nInorder traversal of the modified tree: \");\n        inorderTraversal(root);\n    }\n}", "src": "class\nNode \n{ \n\nint\nkey; \n\nNode left; \n\nNode right; \n} \n\nclass\nGFG \n{ \n\n\n\n\n\n\n\nprivate\nstatic\nNode removeOutsideRange(Node root, \n\nint\nmin, \nint\nmax) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\n{ \n\nreturn\nnull\n; \n\n} \n\n\n\n\n\n\nroot.left = removeOutsideRange(root.left, \n\nmin, max); \n\nroot.right = removeOutsideRange(root.right, \n\nmin, max); \n\n\n\n\n\n\n\n\n\n\nif\n(root.key < min) \n\n{ \n\nNode rchild = root.right; \n\nroot = \nnull\n; \n\nreturn\nrchild; \n\n} \n\n\n\n\n\n\nif\n(root.key > max) \n\n{ \n\nNode lchild = root.left; \n\nroot = \nnull\n; \n\nreturn\nlchild; \n\n} \n\n\n\n\nreturn\nroot; \n\n} \n\n\npublic\nstatic\nNode newNode(\nint\nnum) \n\n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.key = num; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n\n} \n\n\npublic\nstatic\nNode insert(Node root, \n\nint\nkey) \n\n{ \n\nif\n(root == \nnull\n) \n\n{ \n\nreturn\nnewNode(key); \n\n} \n\nif\n(root.key > key) \n\n{ \n\nroot.left = insert(root.left, key); \n\n} \n\nelse\n\n{ \n\nroot.right = insert(root.right, key); \n\n} \n\nreturn\nroot; \n\n} \n\n\nprivate\nstatic\nvoid\ninorderTraversal(Node root) \n\n{ \n\nif\n(root != \nnull\n) \n\n{ \n\ninorderTraversal(root.left); \n\nSystem.out.print(root.key + \n\" \"\n); \n\ninorderTraversal(root.right); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nNode root = \nnull\n; \n\nroot = insert(root, \n6\n); \n\nroot = insert(root, -\n13\n); \n\nroot = insert(root, \n14\n); \n\nroot = insert(root, -\n8\n); \n\nroot = insert(root, \n15\n); \n\nroot = insert(root, \n13\n); \n\nroot = insert(root, \n7\n); \n\n\nSystem.out.print(\n\"Inorder Traversal of \"\n+ \n\n\"the given tree is: \"\n); \n\ninorderTraversal(root); \n\n\nroot = removeOutsideRange(root, -\n10\n, \n13\n); \n\n\nSystem.out.print(\n\"\\nInorder traversal of \"\n+ \n\n\"the modified tree: \"\n); \n\ninorderTraversal(root); \n\n} \n}", "index": 246, "complexity": "1"}
{"back-translation": "class Node { int data; Node left, right; Node(int d) { data = d; left = right = null; } } class BinarySearchTree { Node root; BinarySearchTree() { root = null; } void inorder() { inorderUtil(this.root); } void inorderUtil(Node node) { if (node == null) return; inorderUtil(node.left); System.out.print(node.data + \" \"); inorderUtil(node.right); } void insert(int key) { root = insertRec(root, key); } Node insertRec(Node root, int data) { if (root == null) { root = new Node(data); return root; } if (data < root.data) root.left = insertRec(root.left, data); else if (data > root.data) root.right = insertRec(root.right, data); return root; } ArrayList<Integer> treeToList(Node node, ArrayList<Integer> list) { if (node == null) return list; treeToList(node.left, list); list.add(node.data); treeToList(node.right, list); return list; } boolean isPairPresent(Node node, int target) { ArrayList<Integer> a1 = new ArrayList<>(); ArrayList<Integer> a2 = treeToList(node, a1); int start = 0; int end = a2.size() - 1; while (start < end) { if (a2.get(start) + a2.get(end) == target) { System.out.println(\"Pair Found: \" + a2.get(start) + \" + \" + a2.get(end) + \" = \" + target); return true; } if (a2.get(start) + a2.get(end) > target) { end--; } if (a2.get(start) + a2.get(end) < target) { start++; } } System.out.println(\"No such values are found!\"); return false; } public static void main(String[] args) { BinarySearchTree tree = new BinarySearchTree(); tree.insert(15); tree.insert(10); tree.insert(20); tree.insert(8); tree.insert(12); tree.insert(16); tree.insert(25); tree.isPairPresent(tree.root, 33); } }", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n\n\nNode root; \n\n\n\n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n\n\nvoid\ninorder() \n\n{ \n\ninorderUtil(\nthis\n.root); \n\n} \n\n\n\n\nvoid\ninorderUtil(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\ninorderUtil(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderUtil(node.right); \n\n} \n\n\n\n\nvoid\ninsert(\nint\nkey) \n\n{ \n\nroot = insertRec(root, key); \n\n} \n\n\n\n\nNode insertRec(Node root, \nint\ndata) \n\n{ \n\n\n\n\nif\n(root == \nnull\n) { \n\nroot = \nnew\nNode(data); \n\nreturn\nroot; \n\n} \n\n\n\n\nif\n(data < root.data) \n\nroot.left = insertRec(root.left, data); \n\nelse\nif\n(data > root.data) \n\nroot.right = insertRec(root.right, data); \n\n\nreturn\nroot; \n\n} \n\n\n\n\n\n\nArrayList<Integer> treeToList(Node node, ArrayList<Integer> \n\nlist) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\n\ntreeToList(node.left, list); \n\nlist.add(node.data); \n\ntreeToList(node.right, list); \n\n\nreturn\nlist; \n\n} \n\n\n\n\nboolean\nisPairPresent(Node node, \nint\ntarget) \n\n{ \n\n\n\n\n\n\n\nArrayList<Integer> a1 = \nnew\nArrayList<>(); \n\n\n\n\n\n\nArrayList<Integer> a2 = treeToList(node, a1); \n\n\nint\nstart = \n0\n; \n\n\n\nint\nend = a2.size() - \n1\n; \n\n\n\nwhile\n(start < end) { \n\n\nif\n(a2.get(start) + a2.get(end) == target) \n\n\n{ \n\nSystem.out.println(\n\"Pair Found: \"\n+ a2.get(start) + \n\" + \"\n+ a2.get(end) + \n\" \"\n\n+ \n\"= \"\n+ target); \n\nreturn\ntrue\n; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) > target) \n\n\n{ \n\nend--; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) < target) \n\n\n{ \n\nstart++; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No such values are found!\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n\ntree.insert(\n15\n); \n\ntree.insert(\n10\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n8\n); \n\ntree.insert(\n12\n); \n\ntree.insert(\n16\n); \n\ntree.insert(\n25\n); \n\n\ntree.isPairPresent(tree.root, \n33\n); \n\n} \n}", "index": 247, "complexity": "1"}
{"back-translation": "class Solution { static class Node { Node left, right; int data; } static Node createNode(int x) { Node p = new Node(); p.data = x; p.left = p.right = null; return p; } static void insertNode(Node root, int x) { Node p = root, q = null; while (p != null) { q = p; if (p.data < x) p = p.right; else p = p.left; } if (q == null) p = createNode(x); else { if (q.data < x) q.right = createNode(x); else q.left = createNode(x); } } static int maxelpath(Node q, int x) { Node p = q; int mx = -1; while (p.data != x) { if (p.data > x) { mx = Math.max(mx, p.data); p = p.left; } else { mx = Math.max(mx, p.data); p = p.right; } } return Math.max(mx, x); } static int maximumElement(Node root, int x, int y) { Node p = root; while ((x < p.data && y < p.data) || (x > p.data && y > p.data)) { if (x < p.data && y < p.data) p = p.left; else if (x > p.data && y > p.data) p = p.right; } return Math.max(maxelpath(p, x), maxelpath(p, y)); } public static void main(String args[]) { int arr[] = { 18, 36, 9, 6, 12, 10, 1, 8 }; int a = 1, b = 10; int n = arr.length; Node root = createNode(arr[0]); for (int i = 1; i < n; i++) insertNode(root, arr[i]); System.out.println(maximumElement(root, a, b)); } }", "src": "class\nSolution \n{ \n\nstatic\nclass\nNode \n{ \n\nNode left, right; \n\nint\ndata; \n} \n\n\nstatic\nNode createNode(\nint\nx) \n{ \n\nNode p = \nnew\nNode(); \n\np . data = x; \n\np . left = p . right = \nnull\n; \n\nreturn\np; \n} \n\n\nstatic\nvoid\ninsertNode( Node root, \nint\nx) \n{ \n\nNode p = root, q = \nnull\n; \n\n\nwhile\n(p != \nnull\n) \n\n{ \n\nq = p; \n\nif\n(p . data < x) \n\np = p . right; \n\nelse\n\np = p . left; \n\n} \n\n\nif\n(q == \nnull\n) \n\np = createNode(x); \n\nelse\n\n{ \n\nif\n(q . data < x) \n\nq . right = createNode(x); \n\nelse\n\nq . left = createNode(x); \n\n} \n} \n\n\n\nstatic\nint\nmaxelpath(Node q, \nint\nx) \n{ \n\nNode p = q; \n\n\nint\nmx = -\n1\n; \n\n\n\n\n\n\nwhile\n(p . data != x) \n\n{ \n\nif\n(p . data > x) \n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . left; \n\n} \n\nelse\n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . right; \n\n} \n\n} \n\n\nreturn\nMath.max(mx, x); \n} \n\n\n\nstatic\nint\nmaximumElement( Node root, \nint\nx, \nint\ny) \n{ \n\nNode p = root; \n\n\n\n\nwhile\n((x < p . data && y < p . data) || \n\n(x > p . data && y > p . data)) \n\n{ \n\n\n\n\n\nif\n(x < p . data && y < p . data) \n\np = p . left; \n\n\n\n\n\n\nelse\nif\n(x > p . data && y > p . data) \n\np = p . right; \n\n} \n\n\n\n\n\n\nreturn\nMath.max(maxelpath(p, x), maxelpath(p, y)); \n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n18\n, \n36\n, \n9\n, \n6\n, \n12\n, \n10\n, \n1\n, \n8\n}; \n\nint\na = \n1\n, b = \n10\n; \n\nint\nn =arr.length; \n\n\n\n\nNode root = createNode(arr[\n0\n]); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\ninsertNode(root, arr[i]); \n\n\nSystem.out.println( maximumElement(root, a, b) ); \n\n} \n}", "index": 248, "complexity": "1"}
{"back-translation": "class Solution { static class Node { int data; Node left, right; }; static Node newNode(int num) { Node temp = new Node(); temp.data = num; temp.left = temp.right = null; return temp; } static Node insert(Node root, int key) { if (root == null) return newNode(key); if (root.data > key) root.left = insert(root.left, key); else root.right = insert(root.right, key); return root; } static void storeInorder(Node ptr, Vector<Integer> vect) { if (ptr==null) return; storeInorder(ptr.left, vect); vect.add(ptr.data); storeInorder(ptr.right, vect); } static void pairSumUtil(Vector<Integer> vect1, Vector<Integer> vect2, int sum) { int left = 0; int right = vect2.size() - 1; while (left < vect1.size() && right >= 0) { if (vect1.get(left) + vect2.get(right) == sum) { System.out.print(\"(\" + vect1.get(left) + \", \" + vect2.get(right) + \"), \"); left++; right--; } else if (vect1.get(left) + vect2.get(right) < sum) left++; else right--; } } static void pairSum(Node root1, Node root2, int sum) { Vector<Integer> vect1= new Vector<Integer>(), vect2= new Vector<Integer>(); storeInorder(root1, vect1); storeInorder(root2, vect2); pairSumUtil(vect1, vect2, sum); } public static void main(String args[]) { Node root1 = null; root1 = insert(root1, 8); root1 = insert(root1, 10); root1 = insert(root1, 3); root1 = insert(root1, 6); root1 = insert(root1, 1); root1 = insert(root1, 5); root1 = insert(root1, 7); root1 = insert(root1, 14); root1 = insert(root1, 13); Node root2 = null; root2 = insert(root2, 5); root2 = insert(root2, 18); root2 = insert(root2, 2); root2 = insert(root2, 1); root2 = insert(root2, 3); root2 = insert(root2, 4); int sum = 10; pairSum(root1, root2, sum); } }", "src": "class\nsolution \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n\n\nstatic\nNode newNode(\nint\nnum) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = num; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode insert(Node root, \nint\nkey) \n{ \n\nif\n(root == \nnull\n) \n\nreturn\nnewNode(key); \n\nif\n(root.data > key) \n\nroot.left = insert(root.left, key); \n\nelse\n\nroot.right = insert(root.right, key); \n\nreturn\nroot; \n} \n\n\nstatic\nvoid\nstoreInorder(Node ptr, Vector<Integer> vect) \n{ \n\nif\n(ptr==\nnull\n) \n\nreturn\n; \n\nstoreInorder(ptr.left, vect); \n\nvect.add(ptr.data); \n\nstoreInorder(ptr.right, vect); \n} \n\n\n\n\nstatic\nvoid\npairSumUtil(Vector<Integer> vect1, Vector<Integer> vect2, \n\nint\nsum) \n{ \n\n\n\n\n\nint\nleft = \n0\n; \n\nint\nright = vect2.size() - \n1\n; \n\n\n\n\nwhile\n(left < vect1.size() && right >= \n0\n) \n\n{ \n\n\n\nif\n(vect1.get(left) + vect2.get(right) == sum) \n\n{ \n\nSystem.out.print( \n\"(\"\n+vect1.get(left) + \n\", \"\n+ vect2.get(right) + \n\"), \"\n); \n\nleft++; \n\nright--; \n\n} \n\n\n\n\n\n\nelse\nif\n(vect1.get(left) + vect2.get(right) < sum) \n\nleft++; \n\n\n\n\n\n\nelse\n\nright--; \n\n} \n} \n\n\n\n\nstatic\nvoid\npairSum(Node root1, Node root2, \nint\nsum) \n{ \n\n\n\n\n\nVector<Integer> vect1= \nnew\nVector<Integer>(), vect2= \nnew\nVector<Integer>(); \n\nstoreInorder(root1, vect1); \n\nstoreInorder(root2, vect2); \n\n\n\n\n\n\n\n\npairSumUtil(vect1, vect2, sum); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nNode root1 = \nnull\n; \n\nroot1 = insert(root1, \n8\n); \n\nroot1 = insert(root1, \n10\n); \n\nroot1 = insert(root1, \n3\n); \n\nroot1 = insert(root1, \n6\n); \n\nroot1 = insert(root1, \n1\n); \n\nroot1 = insert(root1, \n5\n); \n\nroot1 = insert(root1, \n7\n); \n\nroot1 = insert(root1, \n14\n); \n\nroot1 = insert(root1, \n13\n); \n\n\n\n\nNode root2 = \nnull\n; \n\nroot2 = insert(root2, \n5\n); \n\nroot2 = insert(root2, \n18\n); \n\nroot2 = insert(root2, \n2\n); \n\nroot2 = insert(root2, \n1\n); \n\nroot2 = insert(root2, \n3\n); \n\nroot2 = insert(root2, \n4\n); \n\n\nint\nsum = \n10\n; \n\npairSum(root1, root2, sum); \n} \n}", "index": 249, "complexity": "1"}
{"back-translation": "class Node {\n    int data;\n    Node left, right;\n\n    Node(int d) {\n        data = d;\n        left = right = null;\n    }\n}\n\nclass BinarySearchTree {\n    Node root;\n\n    BinarySearchTree() {\n        root = null;\n    }\n\n    void inorder() {\n        inorderUtil(this.root);\n    }\n\n    void inorderUtil(Node node) {\n        if (node == null)\n            return;\n\n        inorderUtil(node.left);\n        System.out.print(node.data + \" \");\n        inorderUtil(node.right);\n    }\n\n    public void insert(int data) {\n        this.root = this.insertRec(this.root, data);\n    }\n\n    Node insertRec(Node node, int data) {\n        if (node == null) {\n            this.root = new Node(data);\n            return this.root;\n        }\n\n        if (data <= node.data) {\n            node.left = this.insertRec(node.left, data);\n        } else {\n            node.right = this.insertRec(node.right, data);\n        }\n\n        return node;\n    }\n\n    public class Sum {\n        int sum = 0;\n    }\n\n    void modifyBSTUtil(Node node, Sum S) {\n        if (node == null)\n            return;\n\n        this.modifyBSTUtil(node.right, S);\n\n        S.sum = S.sum + node.data;\n        node.data = S.sum;\n\n        this.modifyBSTUtil(node.left, S);\n    }\n\n    void modifyBST(Node node) {\n        Sum S = new Sum();\n        this.modifyBSTUtil(node, S);\n    }\n\n    public static void main(String[] args) {\n        BinarySearchTree tree = new BinarySearchTree();\n\n        tree.insert(50);\n        tree.insert(30);\n        tree.insert(20);\n        tree.insert(40);\n        tree.insert(70);\n        tree.insert(60);\n        tree.insert(80);\n\n        tree.modifyBST(tree.root);\n\n        tree.inorder();\n    }\n}", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n\n\nNode root; \n\n\n\n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n\n\nvoid\ninorder() \n\n{ \n\ninorderUtil(\nthis\n.root); \n\n} \n\n\n\n\n\n\nvoid\ninorderUtil(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\ninorderUtil(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderUtil(node.right); \n\n} \n\n\n\n\npublic\nvoid\ninsert(\nint\ndata) \n\n{ \n\nthis\n.root = \nthis\n.insertRec(\nthis\n.root, data); \n\n} \n\n\n\n\nNode insertRec(Node node, \nint\ndata) \n\n{ \n\n\n\nif\n(node == \nnull\n) { \n\nthis\n.root = \nnew\nNode(data); \n\nreturn\nthis\n.root; \n\n} \n\n\n\n\nif\n(data <= node.data) { \n\nnode.left = \nthis\n.insertRec(node.left, data); \n\n} \nelse\n{ \n\nnode.right = \nthis\n.insertRec(node.right, data); \n\n} \n\nreturn\nnode; \n\n} \n\n\n\n\npublic\nclass\nSum { \n\nint\nsum = \n0\n; \n\n} \n\n\n\n\n\n\nvoid\nmodifyBSTUtil(Node node, Sum S) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nthis\n.modifyBSTUtil(node.right, S); \n\n\n\n\n\n\nS.sum = S.sum + node.data; \n\nnode.data = S.sum; \n\n\n\n\nthis\n.modifyBSTUtil(node.left, S); \n\n} \n\n\n\n\nvoid\nmodifyBST(Node node) \n\n{ \n\nSum S = \nnew\nSum(); \n\nthis\n.modifyBSTUtil(node, S); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n\n\n\ntree.insert(\n50\n); \n\ntree.insert(\n30\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n40\n); \n\ntree.insert(\n70\n); \n\ntree.insert(\n60\n); \n\ntree.insert(\n80\n); \n\n\ntree.modifyBST(tree.root); \n\n\n\n\ntree.inorder(); \n\n} \n}", "index": 250, "complexity": "1"}
{"back-translation": "class GFG { static int n, p; static int rd[] = new int[1100]; static int wt[] = new int[1100]; static int cd[] = new int[1100]; static List<Integer> a = new ArrayList<Integer>(); static List<Integer> b = new ArrayList<Integer>(); static List<Integer> c = new ArrayList<Integer>(); static int ans; static int dfs(int w) { if (cd[w] == 0) return w; if (wt[w] < ans) ans = wt[w]; return dfs(cd[w]); } static void solve(int arr[][]) { int i = 0; while (i < p) { int q = arr[i][0]; int h = arr[i][1]; int t = arr[i][2]; cd[q] = h; wt[q] = t; rd[h] = q; i++; } a = new ArrayList<Integer>(); b = new ArrayList<Integer>(); c = new ArrayList<Integer>(); for (int j = 1; j <= n; ++j) if (rd[j] == 0 && cd[j] > 0) { ans = 1000000000; int w = dfs(j); a.add(j); b.add(w); c.add(ans); } System.out.println(a.size()); for (int j = 0; j < a.size(); ++j) System.out.println(a.get(j) + \" \" + b.get(j) + \" \" + c.get(j)); } public static void main(String args[]) { n = 9; p = 6; for (int i = 0; i < 1100; i++) rd[i] = cd[i] = wt[i] = 0; int arr[][] = { { 7, 4, 98 }, { 5, 9, 72 }, { 4, 6, 10 }, { 2, 8, 22 }, { 9, 7, 17 }, { 3, 1, 66 } }; solve(arr); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nn, p; \n\n\n\n\n\n\nstatic\nint\nrd[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nint\nwt[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nint\ncd[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nList <Integer> a = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nList <Integer> b = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nList <Integer> c = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nint\nans; \n\n\nstatic\nint\ndfs(\nint\nw) \n\n{ \n\nif\n(cd[w] == \n0\n) \n\nreturn\nw; \n\nif\n(wt[w] < ans) \n\nans = wt[w]; \n\n\nreturn\ndfs(cd[w]); \n\n} \n\n\n\n\nstatic\nvoid\nsolve(\nint\narr[][]) \n\n{ \n\nint\ni = \n0\n; \n\n\nwhile\n(i < p) \n\n{ \n\n\nint\nq = arr[i][\n0\n]; \n\nint\nh = arr[i][\n1\n]; \n\nint\nt = arr[i][\n2\n]; \n\n\ncd[q] = h; \n\nwt[q] = t; \n\nrd[h] = q; \n\ni++; \n\n} \n\n\na=\nnew\nArrayList<Integer>(); \n\nb=\nnew\nArrayList<Integer>(); \n\nc=\nnew\nArrayList<Integer>(); \n\n\nfor\n(\nint\nj = \n1\n; j <= n; ++j) \n\n\n\n\nif\n(rd[j] == \n0\n&& cd[j]>\n0\n) { \n\nans = \n1000000000\n; \n\nint\nw = dfs(j); \n\n\n\n\n\n\n\n\na.add(j); \n\nb.add(w); \n\nc.add(ans); \n\n} \n\n\nSystem.out.println(a.size()); \n\n\nfor\n(\nint\nj = \n0\n; j < a.size(); ++j) \n\nSystem.out.println(a.get(j) + \n\" \"\n\n+ b.get(j) + \n\" \"\n+ c.get(j)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nn = \n9\n; \n\np = \n6\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < \n1100\n; i++) \n\nrd[i] = cd[i] = wt[i] = \n0\n; \n\n\nint\narr[][] = { { \n7\n, \n4\n, \n98\n}, \n\n{ \n5\n, \n9\n, \n72\n}, \n\n{ \n4\n, \n6\n, \n10\n}, \n\n{ \n2\n, \n8\n, \n22\n}, \n\n{ \n9\n, \n7\n, \n17\n}, \n\n{ \n3\n, \n1\n, \n66\n} }; \n\nsolve(arr); \n\n} \n}", "index": 251, "complexity": "1"}
{"back-translation": "class GFG { static int policeThief(char arr[], int n, int k) { int res = 0; ArrayList<Integer> thi = new ArrayList<Integer>(); ArrayList<Integer> pol = new ArrayList<Integer>(); for (int i = 0; i < n; i++) { if (arr[i] == 'P') pol.add(i); else if (arr[i] == 'T') thi.add(i); } int l = 0, r = 0; while (l < thi.size() && r < pol.size()) { if (Math.abs(thi.get(l) - pol.get(r)) <= k) { res++; l++; r++; } else if (thi.get(l) < pol.get(r)) l++; else r++; } return res; } public static void main(String args[]) { int k, n; char arr1[] = new char[] { 'P', 'T', 'T', 'P', 'T' }; k = 2; n = arr1.length; System.out.println(\"Maximum thieves caught: \"+policeThief(arr1, n, k)); char arr2[] = new char[] { 'T', 'T', 'P', 'P', 'T', 'P' }; k = 2; n = arr2.length; System.out.println(\"Maximum thieves caught: \"+policeThief(arr2, n, k)); char arr3[] = new char[]{ 'P', 'T', 'P', 'T', 'T', 'P' }; k = 3; n = arr3.length; System.out.println(\"Maximum thieves caught: \"+policeThief(arr3, n, k)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\npoliceThief(\nchar\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nArrayList<Integer> thi = \nnew\nArrayList<Integer>(); \n\nArrayList<Integer> pol = \nnew\nArrayList<Integer>(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(arr[i] == \n'P'\n) \n\npol.add(i); \n\nelse\nif\n(arr[i] == \n'T'\n) \n\nthi.add(i); \n\n} \n\n\n\n\n\n\nint\nl = \n0\n, r = \n0\n; \n\nwhile\n(l < thi.size() && r < pol.size()) { \n\n\n\n\nif\n(Math.abs(thi.get(l) - pol.get(r)) <= k) { \n\nres++; \n\nl++; \n\nr++; \n\n} \n\n\n\n\nelse\nif\n(thi.get(l) < pol.get(r)) \n\nl++; \n\nelse\n\nr++; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nk, n; \n\nchar\narr1[] =\nnew\nchar\n[] { \n'P'\n, \n'T'\n, \n'T'\n, \n\n'P'\n, \n'T'\n}; \n\nk = \n2\n; \n\nn = arr1.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr1, n, k)); \n\n\nchar\narr2[] =\nnew\nchar\n[] { \n'T'\n, \n'T'\n, \n'P'\n, \n'P'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n2\n; \n\nn = arr2.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr2, n, k)); \n\n\nchar\narr3[] = \nnew\nchar\n[]{ \n'P'\n, \n'T'\n, \n'P'\n, \n'T'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n3\n; \n\nn = arr3.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr3, n, k)); \n\n} \n}", "index": 252, "complexity": "1"}
{"back-translation": "class GFG { static int minProductSubset(int[] a, int n) { if (n == 1) return a[0]; int negmax = Integer.MIN_VALUE; int posmin = Integer.MAX_VALUE; int count_neg = 0, count_zero = 0; int product = 1; for (int i = 0; i < n; i++) { if (a[i] == 0) { count_zero++; continue; } if (a[i] < 0) { count_neg++; negmax = Math.max(negmax, a[i]); } if (a[i] > 0 && a[i] < posmin) posmin = a[i]; product *= a[i]; } if (count_zero == n || (count_neg == 0 && count_zero > 0)) return 0; if (count_neg == 0) return posmin; if (count_neg % 2 == 0 && count_neg != 0) { product = product / negmax; } return product; } public static void main(String[] args) { int a[] = { -1, -1, -2, 4, 3 }; int n = 5; System.out.println(minProductSubset(a, n)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nminProductSubset(\nint\na[], \nint\nn) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\na[\n0\n]; \n\n\n\n\n\n\n\n\n\n\n\n\nint\nnegmax = Integer.MIN_VALUE; \n\nint\nposmin = Integer.MAX_VALUE; \n\nint\ncount_neg = \n0\n, count_zero = \n0\n; \n\nint\nproduct = \n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\nif\n(a[i] == \n0\n){ \n\ncount_zero++; \n\ncontinue\n; \n\n} \n\n\n\n\n\n\nif\n(a[i] < \n0\n) \n\n{ \n\ncount_neg++; \n\nnegmax = Math.max(negmax, a[i]); \n\n} \n\n\n\n\nif\n(a[i] > \n0\n&& a[i] < posmin) \n\nposmin = a[i]; \n\n\nproduct *= a[i]; \n\n} \n\n\n\n\n\n\n\n\nif\n(count_zero == n || \n\n(count_neg == \n0\n&& count_zero > \n0\n)) \n\nreturn\n0\n; \n\n\n\n\nif\n(count_neg == \n0\n) \n\nreturn\nposmin; \n\n\n\n\n\n\nif\n(count_neg % \n2\n== \n0\n&& count_neg != \n0\n) \n\n{ \n\n\n\n\n\n\n\n\nproduct = product / negmax; \n\n} \n\n\nreturn\nproduct; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\na[] = { -\n1\n, -\n1\n, -\n2\n, \n4\n, \n3\n}; \n\nint\nn = \n5\n; \n\n\nSystem.out.println(minProductSubset(a, n)); \n\n} \n}", "index": 253, "complexity": "1"}
{"back-translation": "public class GFG {\n    static int maxProductSubset(int[] a, int n) {\n        if (n == 1) {\n            return a[0];\n        }\n        int max_neg = Integer.MIN_VALUE;\n        int count_neg = 0, count_zero = 0;\n        int prod = 1;\n        for (int i = 0; i < n; i++) {\n            if (a[i] == 0) {\n                count_zero++;\n                continue;\n            }\n            if (a[i] < 0) {\n                count_neg++;\n                max_neg = Math.max(max_neg, a[i]);\n            }\n            prod = prod * a[i];\n        }\n        if (count_zero == n) {\n            return 0;\n        }\n        if (count_neg % 2 == 1) {\n            if (count_neg == 1 && count_zero > 0 && count_zero + count_neg == n) {\n                return 0;\n            }\n            prod = prod / max_neg;\n        }\n        return prod;\n    }\n\n    public static void main(String[] args) {\n        int a[] = {-1, -1, -2, 4, 3};\n        int n = a.length;\n        System.out.println(maxProductSubset(a, n));\n    }\n}", "src": "class\nGFG { \n\n\nstatic\nint\nmaxProductSubset(\nint\na[], \nint\nn) { \n\nif\n(n == \n1\n) { \n\nreturn\na[\n0\n]; \n\n} \n\n\n\n\n\n\n\n\nint\nmax_neg = Integer.MIN_VALUE; \n\nint\ncount_neg = \n0\n, count_zero = \n0\n; \n\nint\nprod = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n(a[i] == \n0\n) { \n\ncount_zero++; \n\ncontinue\n; \n\n} \n\n\n\n\n\n\nif\n(a[i] < \n0\n) { \n\ncount_neg++; \n\nmax_neg = Math.max(max_neg, a[i]); \n\n} \n\n\nprod = prod * a[i]; \n\n} \n\n\n\n\nif\n(count_zero == n) { \n\nreturn\n0\n; \n\n} \n\n\n\n\n\n\nif\n(count_neg % \n2\n== \n1\n) { \n\n\n\n\n\n\nif\n(count_neg == \n1\n\n&& count_zero > \n0\n\n&& count_zero + count_neg == n) { \n\nreturn\n0\n; \n\n} \n\n\n\n\n\n\n\n\nprod = prod / max_neg; \n\n} \n\n\nreturn\nprod; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\na[] = {-\n1\n, -\n1\n, -\n2\n, \n4\n, \n3\n}; \n\nint\nn = a.length; \n\nSystem.out.println(maxProductSubset(a, n)); \n\n\n} \n}", "index": 254, "complexity": "1"}
{"back-translation": "public class GFG {\n\n    static int minSum(int[] A, int n) {\n        int min_val = Arrays.stream(A).min().getAsInt();\n        return (min_val * (n - 1));\n    }\n\n    public static void main(String[] args) {\n        int[] A = {3, 6, 2, 8, 7, 5};\n        int n = A.length;\n        System.out.println((minSum(A, n)));\n    }\n}", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nint\nminSum(\nint\n[] A, \nint\nn) { \n\nint\nmin_val = Arrays.stream(A).min().getAsInt(); \n\nreturn\n(min_val * (n - \n1\n)); \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain(String[] args) { \n\nint\n[] A = {\n3\n, \n6\n, \n2\n, \n8\n, \n7\n, \n5\n}; \n\nint\nn = A.length; \n\nSystem.out.println((minSum(A, n))); \n\n\n} \n}", "index": 255, "complexity": "1"}
{"back-translation": "class GFG { static int MinOperation(int a[], int n, int k) { int result = 0; for (int i = 0; i < n; ++i) { if (a[i] != 1 && a[i] > k) { result = result + Math.min(a[i] % k, k - a[i] % k); } else { result = result + k - a[i]; } } return result; } public static void main (String[] args) { int arr[] = {4, 5, 6}; int n = arr.length; int k = 5; System.out.println(MinOperation(arr, n, k)); } }", "src": "class\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nn, \nint\nk) \n{ \n\n\nint\nresult = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(a[i] != \n1\n&& a[i] > k) \n\n{ \n\nresult = result + \n\nMath.min(a[i] % k, \n\nk - a[i] % k); \n\n} \n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\n\nresult = result + k - a[i]; \n\n} \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\narr[] = {\n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n5\n; \n\nSystem.out.println(MinOperation(arr, n, k)); \n} \n}", "index": 256, "complexity": "1"}
{"back-translation": "public class GFG { public static int maxSum(int[] stack1, int[] stack2, int[] stack3, int n1, int n2, int n3) { int sum1 = 0, sum2 = 0, sum3 = 0; for (int i = 0; i < n1; i++) sum1 += stack1[i]; for (int i = 0; i < n2; i++) sum2 += stack2[i]; for (int i = 0; i < n3; i++) sum3 += stack3[i]; int top1 = 0, top2 = 0, top3 = 0; int ans = 0; while (true) { if (top1 == n1 || top2 == n2 || top3 == n3) return 0; if (sum1 == sum2 && sum2 == sum3) return sum1; if (sum1 >= sum2 && sum1 >= sum3) sum1 -= stack1[top1++]; else if (sum2 >= sum3 && sum2 >= sum1) sum2 -= stack2[top2++]; else if (sum3 >= sum2 && sum3 >= sum1) sum3 -= stack3[top3++]; } } public static void main(String[] args) { int[] stack1 = { 3, 2, 1, 1, 1 }; int[] stack2 = { 4, 3, 2 }; int[] stack3 = { 1, 1, 4, 1 }; int n1 = stack1.length; int n2 = stack2.length; int n3 = stack3.length; System.out.println(maxSum(stack1, stack2, stack3, n1, n2, n3)); } }", "src": "class\nGFG { \n\n\n\n\n\n\npublic\nstatic\nint\nmaxSum(\nint\nstack1[], \nint\nstack2[], \n\nint\nstack3[], \nint\nn1, \nint\nn2, \n\nint\nn3) \n\n{ \n\nint\nsum1 = \n0\n, sum2 = \n0\n, sum3 = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n1; i++) \n\nsum1 += stack1[i]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n2; i++) \n\nsum2 += stack2[i]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n3; i++) \n\nsum3 += stack3[i]; \n\n\n\n\n\n\nint\ntop1 =\n0\n, top2 = \n0\n, top3 = \n0\n; \n\nint\nans = \n0\n; \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\nif\n(top1 == n1 || top2 == n2 || top3 == n3) \n\nreturn\n0\n; \n\n\n\n\nif\n(sum1 == sum2 && sum2 == sum3) \n\nreturn\nsum1; \n\n\n\n\n\n\nif\n(sum1 >= sum2 && sum1 >= sum3) \n\nsum1 -= stack1[top1++]; \n\nelse\nif\n(sum2 >= sum3 && sum2 >= sum3) \n\nsum2 -= stack2[top2++]; \n\nelse\nif\n(sum3 >= sum2 && sum3 >= sum1) \n\nsum3 -= stack3[top3++]; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nstack1[] = { \n3\n, \n2\n, \n1\n, \n1\n, \n1\n}; \n\nint\nstack2[] = { \n4\n, \n3\n, \n2\n}; \n\nint\nstack3[] = { \n1\n, \n1\n, \n4\n, \n1\n}; \n\n\nint\nn1 = stack1.length; \n\nint\nn2 = stack2.length; \n\nint\nn3 = stack3.length; \n\n\nSystem.out.println(maxSum(stack1, stack2, \n\nstack3, n1, n2, n3)); \n\n} \n\n}", "index": 257, "complexity": "1"}
{"back-translation": "class GFG {\n\n    static void printVector(Vector<Integer> v) {\n        System.out.println(v.size());\n        for (int i = 0; i < v.size(); i++)\n            System.out.print(v.get(i) + \" \");\n        System.out.println();\n    }\n\n    static void findTwoGroup(int n) {\n        int sum = n * (n + 1) / 2;\n        int group1Sum = sum / 2;\n        Vector<Integer> group1 = new Vector<Integer>();\n        Vector<Integer> group2 = new Vector<Integer>();\n        for (int i = n; i > 0; i--) {\n            if (group1Sum - i >= 0) {\n                group1.add(i);\n                group1Sum -= i;\n            } else {\n                group2.add(i);\n            }\n        }\n        printVector(group1);\n        printVector(group2);\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        findTwoGroup(n);\n    }\n}", "src": "class\nGFG \n{ \n\n\n\nstatic\nvoid\nprintVector(Vector<Integer> v) \n\n{ \n\n\n\nSystem.out.println(v.size()); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < v.size(); i++) \n\nSystem.out.print(v.get(i) + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nfindTwoGroup(\nint\nn) \n\n{ \n\n\n\nint\nsum = n * (n + \n1\n) / \n2\n; \n\n\n\n\nint\ngroup1Sum = sum / \n2\n; \n\n\nVector<Integer> group1 = \nnew\nVector<Integer>(); \n\nVector<Integer> group2 = \nnew\nVector<Integer>(); \n\n\nfor\n(\nint\ni = n; i > \n0\n; i--) { \n\n\n\n\n\n\n\n\nif\n(group1Sum - i >= \n0\n) { \n\n\ngroup1.add(i); \n\n\n\n\ngroup1Sum -= i; \n\n} \n\nelse\n{ \n\ngroup2.add(i); \n\n} \n\n} \n\n\n\n\nprintVector(group1); \n\nprintVector(group2); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nfindTwoGroup(n); \n\n} \n}", "index": 258, "complexity": "1"}
{"back-translation": "public class GFG { static int cost(int[] a, int n) { int min = a[0]; for (int i = 1; i < a.length; i++) { if (a[i] < min) min = a[i]; } return (n - 1) * min; } public static void main(String[] args) { int[] a = { 4, 3, 2 }; int n = a.length; System.out.println(cost(a, n)); } }", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\ncost(\nint\n[]a, \nint\nn) \n\n{ \n\nint\nmin = a[\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i< a.length; i++) \n\n{ \n\nif\n(a[i] < min) \n\nmin = a[i]; \n\n} \n\n\n\n\n\n\nreturn\n(n - \n1\n) * min; \n\n} \n\n\n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\n\nint\n[]a = { \n4\n, \n3\n, \n2\n}; \n\nint\nn = a.length; \n\n\nSystem.out.println(cost(a, n)); \n\n} \n}", "index": 259, "complexity": "1"}
{"back-translation": "class GFG { static void digitsNum(int N) { if (N == 0) System.out.println(\"0\"); if (N % 9 != 0) System.out.print((N % 9)); for (int i = 1; i <= (N / 9); ++i) System.out.print(\"9\"); for (int i = 1; i <= N; ++i) System.out.print(\"0\"); System.out.print(\"\"); } public static void main(String[] args) { int N = 5; System.out.print(\"The number is : \"); digitsNum(N); } }", "src": "class\nGFG \n{ \n\nstatic\nvoid\ndigitsNum(\nint\nN) \n{ \n\n\n\nif\n(N == \n0\n) \n\nSystem.out.println(\n\"0\"\n); \n\n\n\n\n\n\n\nif\n(N % \n9\n!= \n0\n) \n\nSystem.out.print((N % \n9\n)); \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= (N / \n9\n); ++i) \n\nSystem.out.print(\n\"9\"\n); \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= N; ++i) \n\nSystem.out.print(\n\"0\"\n); \n\nSystem.out.print(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nN = \n5\n; \n\nSystem.out.print(\n\"The number is : \"\n); \n\ndigitsNum(N); \n\n} \n}", "index": 260, "complexity": "1"}
{"back-translation": "class GFG { static void findSmallest(int m, int s) { if (s == 0) { System.out.print(m == 1 ? \"Smallest number is 0\" : \"Not possible\"); return; } if (s > 9 * m) { System.out.println(\"Not possible\"); return; } int[] res = new int[m]; s -= 1; for (int i = m - 1; i > 0; i--) { if (s > 9) { res[i] = 9; s -= 9; } else { res[i] = s; s = 0; } } res[0] = s + 1; System.out.print(\"Smallest number is \"); for (int i = 0; i < m; i++) System.out.print(res[i]); } public static void main (String[] args) { int s = 9, m = 2; findSmallest(m, s); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nvoid\nfindSmallest(\nint\nm, \nint\ns) \n\n{ \n\n\n\n\n\nif\n(s == \n0\n) \n\n{ \n\nSystem.out.print(m == \n1\n? \n\"Smallest number is 0\"\n: \n\"Not possible\"\n); \n\n\nreturn\n; \n\n} \n\n\n\n\nif\n(s > \n9\n*m) \n\n{ \n\nSystem.out.println(\n\"Not possible\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nint\n[] res = \nnew\nint\n[m]; \n\n\n\n\n\n\n\n\ns -= \n1\n; \n\n\n\n\nfor\n(\nint\ni=m-\n1\n; i>\n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(s > \n9\n) \n\n{ \n\nres[i] = \n9\n; \n\ns -= \n9\n; \n\n} \n\nelse\n\n{ \n\nres[i] = s; \n\ns = \n0\n; \n\n} \n\n} \n\n\n\n\n\n\nres[\n0\n] = s + \n1\n; \n\n\n\n\n\nSystem.out.print(\n\"Smallest number is \"\n); \n\nfor\n(\nint\ni=\n0\n; i<m; i++) \n\nSystem.out.print(res[i]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\ns = \n9\n, m = \n2\n; \n\nfindSmallest(m, s); \n\n} \n}", "index": 261, "complexity": "1"}
{"back-translation": "class KeyComparator implements Comparator<Key> { public int compare(Key k1, Key k2) { if (k1.freq < k2.freq) return 1; else if (k1.freq > k2.freq) return -1; return 0; } } class Key { int freq; char ch; Key(int val, char c) { freq = val; ch = c; } } class GFG { static int MAX_CHAR = 26; static void rearrangeString(String str) { int n = str.length(); int[] count = new int[MAX_CHAR]; for (int i = 0; i < n; i++) count[str.charAt(i) - 'a']++; PriorityQueue<Key> pq = new PriorityQueue<>(new KeyComparator()); for (char c = 'a'; c <= 'z'; c++) { int val = c - 'a'; if (count[val] > 0) pq.add(new Key(count[val], c)); } str = \"\"; Key prev = new Key(-1, '#'); while (!pq.isEmpty()) { Key k = pq.peek(); pq.poll(); str = str + k.ch; if (prev.freq > 0) pq.add(prev); k.freq--; prev = k; } if (n != str.length()) System.out.println(\" Not valid String \"); else System.out.println(str); } public static void main(String args[]) { String str = \"bbbaa\"; rearrangeString(str); } }", "src": "class\nKeyComparator \nimplements\nComparator<Key> { \n\n\n\n\npublic\nint\ncompare(Key k1, Key k2) \n\n{ \n\nif\n(k1.freq < k2.freq) \n\nreturn\n1\n; \n\nelse\nif\n(k1.freq > k2.freq) \n\nreturn\n-\n1\n; \n\nreturn\n0\n; \n\n} \n} \n\nclass\nKey { \n\nint\nfreq; \n\n\nchar\nch; \n\nKey(\nint\nval, \nchar\nc) \n\n{ \n\nfreq = val; \n\nch = c; \n\n} \n} \n\nclass\nGFG { \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nvoid\nrearrangeString(String str) \n\n{ \n\nint\nn = str.length(); \n\n\n\n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[str.charAt(i) - \n'a'\n]++; \n\n\n\n\n\n\nPriorityQueue<Key> pq = \nnew\nPriorityQueue<>(\nnew\n\nKeyComparator()); \n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\nval = c - \n'a'\n; \n\nif\n(count[val] > \n0\n) \n\npq.add(\nnew\nKey(count[val], c)); \n\n} \n\n\n\n\nstr = \n\"\"\n; \n\n\n\n\n\n\n\n\nKey prev = \nnew\nKey(-\n1\n, \n'#'\n); \n\n\n\n\nwhile\n(pq.size() != \n0\n) { \n\n\n\n\n\n\nKey k = pq.peek(); \n\npq.poll(); \n\nstr = str + k.ch; \n\n\n\n\n\n\n\n\nif\n(prev.freq > \n0\n) \n\npq.add(prev); \n\n\n\n\n\n\n(k.freq)--; \n\nprev = k; \n\n} \n\n\n\n\n\n\nif\n(n != str.length()) \n\nSystem.out.println(\n\" Not valid String \"\n); \n\nelse\n\nSystem.out.println(str); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"bbbaa\"\n; \n\nrearrangeString(str); \n\n} \n}", "index": 262, "complexity": "1"}
{"back-translation": "public class GfG { public static String noAdjacentDup(String s1) { int n = s1.length(); char[] s = s1.toCharArray(); for (int i = 1; i < n; i++) { if (s[i] == s[i - 1]) { s[i] = 'a'; while (s[i] == s[i - 1] || (i + 1 < n && s[i] == s[i + 1])) s[i]++; i++; } } return (new String(s)); } public static void main(String argc[]) { String s = \"geeksforgeeks\"; System.out.println(noAdjacentDup(s)); } }", "src": "public\nclass\nGfG{ \n\n\n\n\npublic\nstatic\nString noAdjacentDup(String s1) \n\n{ \n\nint\nn = s1.length(); \n\nchar\n[] s = s1.toCharArray(); \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nif\n(s[i] == s[i - \n1\n]) \n\n{ \n\n\n\ns[i] = \n'a'\n; \n\n\n\n\n\n\n\n\nwhile\n(s[i] == s[i - \n1\n] || \n\n(i + \n1\n< n && s[i] == s[i + \n1\n])) \n\ns[i]++; \n\n\ni++; \n\n} \n\n} \n\nreturn\n(\nnew\nString(s)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\n\nString s = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(noAdjacentDup(s)); \n\n\n} \n\n}", "index": 263, "complexity": "1"}
{"back-translation": "class Test { static int arr[] = {12, 34, 54, 2, 3}; static int recSearch(int arr[], int l, int r, int x) { if (r < l) return -1; if (arr[l] == x) return l; if (arr[r] == x) return r; return recSearch(arr, l+1, r-1, x); } public static void main(String[] args) { int x = 3; int index = recSearch(arr, 0, arr.length-1, x); if (index != -1) System.out.println(\"Element \" + x + \" is present at index \" + index); else System.out.println(\"Element \" + x + \" is not present\"); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = {\n12\n, \n34\n, \n54\n, \n2\n, \n3\n}; \n\n\n\n\nstatic\nint\nrecSearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r < l) \n\nreturn\n-\n1\n; \n\nif\n(arr[l] == x) \n\nreturn\nl; \n\nif\n(arr[r] == x) \n\nreturn\nr; \n\nreturn\nrecSearch(arr, l+\n1\n, r-\n1\n, x); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nx = \n3\n; \n\n\n\n\nint\nindex = recSearch(arr, \n0\n, arr.length-\n1\n, x); \n\nif\n(index != -\n1\n) \n\nSystem.out.println(\n\"Element \"\n+ x + \n\" is present at index \"\n+ \n\nindex); \n\nelse\n\nSystem.out.println(\n\"Element \"\n+ x + \n\" is not present\"\n); \n\n} \n\n}", "index": 264, "complexity": "1"}
{"back-translation": "class Main {\n\n    static int getMissingNo(int a[], int n) {\n\n        int i, total;\n\n        total = (n + 1) * (n + 2) / 2;\n\n        for (i = 0; i < n; i++)\n\n            total -= a[i];\n\n        return total;\n    }\n\n    public static void main(String args[]) {\n\n        int a[] = {1, 2, 4, 5, 6};\n\n        int miss = getMissingNo(a, 5);\n\n        System.out.println(miss);\n    }\n}", "src": "class\nMain { \n\n\n\nstatic\nint\ngetMissingNo(\nint\na[], \nint\nn) \n\n{ \n\nint\ni, total; \n\ntotal = (n + \n1\n) * (n + \n2\n) / \n2\n; \n\nfor\n(i = \n0\n; i < n; i++) \n\ntotal -= a[i]; \n\nreturn\ntotal; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\na[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\nmiss = getMissingNo(a, \n5\n); \n\nSystem.out.println(miss); \n\n} \n}", "index": 265, "complexity": "1"}
{"back-translation": "class SecondSmallest {\n    static void print2Smallest(int[] arr) {\n        int first, second, arr_size = arr.length;\n        if (arr_size < 2) {\n            System.out.println(\" Invalid Input \");\n            return;\n        }\n        first = second = Integer.MAX_VALUE;\n        for (int i = 0; i < arr_size; i++) {\n            if (arr[i] < first) {\n                second = first;\n                first = arr[i];\n            } else if (arr[i] < second && arr[i] != first) {\n                second = arr[i];\n            }\n        }\n        if (second == Integer.MAX_VALUE)\n            System.out.println(\"There is no second\" + \"smallest element\");\n        else\n            System.out.println(\"The smallest element is \" + first + \" and second Smallest\" + \" element is \" + second);\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {12, 13, 1, 10, 34, 1};\n        print2Smallest(arr);\n    }\n}", "src": "class\nSecondSmallest \n{ \n\n\n\nstatic\nvoid\nprint2Smallest(\nint\narr[]) \n\n{ \n\nint\nfirst, second, arr_size = arr.length; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MAX_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] < first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] < second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nif\n(second == Integer.MAX_VALUE) \n\nSystem.out.println(\n\"There is no second\"\n+ \n\n\"smallest element\"\n); \n\nelse\n\nSystem.out.println(\n\"The smallest element is \"\n+ \n\nfirst + \n\" and second Smallest\"\n+ \n\n\" element is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nprint2Smallest(arr); \n\n} \n}", "index": 266, "complexity": "1"}
{"back-translation": "class Main {\n\n    static int ceilSearch(int arr[], int low, int high, int x) {\n        int i;\n\n        if (x <= arr[low])\n            return low;\n\n        for (i = low; i < high; i++) {\n\n            if (arr[i] == x)\n                return i;\n\n            if (arr[i] < x && arr[i + 1] >= x)\n                return i + 1;\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = { 1, 2, 8, 10, 10, 12, 19 };\n        int n = arr.length;\n        int x = 3;\n        int index = ceilSearch(arr, 0, n - 1, x);\n\n        if (index == -1)\n            System.out.println(\"Ceiling of \" + x + \" doesn't exist in array\");\n        else\n            System.out.println(\"ceiling of \" + x + \" is \" + arr[index]);\n    }\n}", "src": "class\nMain \n{ \n\n\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\ni; \n\n\n\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n\n\nfor\n(i = low; i < high; i++) \n\n{ \n\nif\n(arr[i] == x) \n\nreturn\ni; \n\n\n\n\nif\n(arr[i] < x && arr[i+\n1\n] >= x) \n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n}", "index": 267, "complexity": "1"}
{"back-translation": "class Main { static int countOccurrences(int arr[], int n, int x) { int res = 0; for (int i = 0; i < n; i++) { if (x == arr[i]) res++; } return res; } public static void main(String args[]) { int arr[] = {1, 2, 2, 2, 2, 3, 4, 7, 8, 8}; int n = arr.length; int x = 2; System.out.println(countOccurrences(arr, n, x)); } }", "src": "class\nMain \n{ \n\n\n\nstatic\nint\ncountOccurrences(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nif\n(x == arr[i]) \n\nres++; \n\nreturn\nres; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n3\n, \n4\n, \n7\n,\n8\n,\n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.println(countOccurrences(arr, n, x)); \n\n} \n}", "index": 268, "complexity": "1"}
{"back-translation": "class GFG { static void printTwoElements(int arr[], int size) { int i; System.out.print(\"The repeating element is \"); for (i = 0; i < size; i++) { int abs_val = Math.abs(arr[i]); if (arr[abs_val - 1] > 0) arr[abs_val - 1] = -arr[abs_val - 1]; else System.out.println(abs_val); } System.out.print(\"And the missing element is \"); for (i = 0; i < size; i++) { if (arr[i] > 0) System.out.println(i + 1); } } public static void main(String[] args) { int arr[] = { 7, 3, 4, 5, 5, 6, 2 }; int n = arr.length; printTwoElements(arr, n); } }", "src": "class\nGFG { \n\n\nstatic\nvoid\nprintTwoElements(\nint\narr[], \nint\nsize) \n\n{ \n\nint\ni; \n\nSystem.out.print(\n\"The repeating element is \"\n); \n\n\nfor\n(i = \n0\n; i < size; i++) { \n\nint\nabs_val = Math.abs(arr[i]); \n\nif\n(arr[abs_val - \n1\n] > \n0\n) \n\narr[abs_val - \n1\n] = -arr[abs_val - \n1\n]; \n\nelse\n\nSystem.out.println(abs_val); \n\n} \n\n\nSystem.out.print(\n\"And the missing element is \"\n); \n\nfor\n(i = \n0\n; i < size; i++) { \n\nif\n(arr[i] > \n0\n) \n\nSystem.out.println(i + \n1\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n7\n, \n3\n, \n4\n, \n5\n, \n5\n, \n6\n, \n2\n}; \n\nint\nn = arr.length; \n\nprintTwoElements(arr, n); \n\n} \n}", "index": 269, "complexity": "1"}
{"back-translation": "class GFG { static int x, y; static void getTwoElements(int arr[], int n) { int xor1; int set_bit_no; int i; x = 0; y = 0; xor1 = arr[0]; for(i = 1; i < n; i++) xor1 = xor1 ^ arr[i]; for(i = 1; i <= n; i++) xor1 = xor1 ^ i; set_bit_no = xor1 & ~(xor1 - 1); for(i = 0; i < n; i++) { if((arr[i] & set_bit_no) != 0) x = x ^ arr[i]; else y = y ^ arr[i]; } for(i = 1; i <= n; i++) { if((i & set_bit_no) != 0) x = x ^ i; else y = y ^ i; } } public static void main(String[] args) { int arr[] = { 1, 3, 4, 5, 1, 6, 2}; int n = arr.length; getTwoElements(arr, n); System.out.println(\" The missing element is \" + x + \"and the \" + \"repeating number is \" + y); } }", "src": "class\nGFG { \n\nstatic\nint\nx, y; \n\n\nstatic\nvoid\ngetTwoElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nxor1; \n\n\n\n\nint\nset_bit_no; \n\n\nint\ni; \n\nx = \n0\n; \n\ny = \n0\n; \n\n\nxor1 = arr[\n0\n]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nxor1 = xor1 ^ arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i <= n; i++) \n\nxor1 = xor1 ^ i; \n\n\n\n\nset_bit_no = xor1 & ~(xor1 - \n1\n); \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n((arr[i] & set_bit_no) != \n0\n) \n\n\n\nx = x ^ arr[i]; \n\n\nelse\n\n\n\ny = y ^ arr[i]; \n\n} \n\nfor\n(i = \n1\n; i <= n; i++) { \n\nif\n((i & set_bit_no) != \n0\n) \n\n\n\nx = x ^ i; \n\n\nelse\n\n\n\ny = y ^ i; \n\n} \n\n\n\n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n4\n, \n5\n, \n1\n, \n6\n, \n2\n}; \n\n\nint\nn = arr.length; \n\ngetTwoElements(arr, n); \n\nSystem.out.println(\n\" The missing element is \"\n\n+ x + \n\"and the \"\n\n+ \n\"repeating number is \"\n\n+ y); \n\n} \n}", "index": 270, "complexity": "1"}
{"back-translation": "class Main { static int linearSearch(int arr[], int n) { int i = 0; while (i < n) { if (arr[i] == i) return i; i++; } return -1; } public static void main(String args[]) { int arr[] = {-10, -1, 0, 3, 10, 11, 30, 50, 100}; int n = arr.length; System.out.println(\"Fixed Point is \" + linearSearch(arr, n)); } }", "src": "class\nMain \n{ \n\nstatic\nint\nlinearSearch(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] == i) \n\nreturn\ni; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {-\n10\n, -\n1\n, \n0\n, \n3\n, \n10\n, \n11\n, \n30\n, \n50\n, \n100\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Fixed Point is \"\n\n+ linearSearch(arr, n)); \n\n} \n}", "index": 271, "complexity": "1"}
{"back-translation": "class Main { static int findMaximum(int arr[], int low, int high) { int max = arr[low]; int i; for (i = low; i <= high; i++) { if (arr[i] > max) max = arr[i]; } return max; } public static void main (String[] args) { int arr[] = {1, 30, 40, 50, 60, 70, 23, 20}; int n = arr.length; System.out.print(\"The maximum element is \" + findMaximum(arr, 0, n-1)); } }", "src": "class\nMain \n{ \n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\nmax = arr[low]; \n\nint\ni; \n\nfor\n(i = low; i <= high; i++) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\n} \n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n30\n, \n40\n, \n50\n, \n60\n, \n70\n, \n23\n, \n20\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"The maximum element is \"\n+ \n\nfindMaximum(arr, \n0\n, n-\n1\n)); \n\n} \n}", "index": 272, "complexity": "1"}
{"back-translation": "class PairDifference { static boolean findPair(int arr[], int n) { int size = arr.length; int i = 0, j = 1; while (i < size && j < size) { if (i != j && arr[j] - arr[i] == n) { System.out.print(\"Pair Found: \" + \"( \" + arr[i] + \", \" + arr[j] + \" )\"); return true; } else if (arr[j] - arr[i] < n) j++; else i++; } System.out.print(\"No such pair\"); return false; } public static void main (String[] args) { int arr[] = { 1, 8, 30, 40, 100 }; int n = 60; findPair(arr,n); } }", "src": "class\nPairDifference \n{ \n\n\n\nstatic\nboolean\nfindPair(\nint\narr[],\nint\nn) \n\n{ \n\nint\nsize = arr.length; \n\n\n\n\nint\ni = \n0\n, j = \n1\n; \n\n\n\n\nwhile\n(i < size && j < size) \n\n{ \n\nif\n(i != j && arr[j]-arr[i] == n) \n\n{ \n\nSystem.out.print(\n\"Pair Found: \"\n+ \n\n\"( \"\n+arr[i]+\n\", \"\n+ arr[j]+\n\" )\"\n); \n\nreturn\ntrue\n; \n\n} \n\nelse\nif\n(arr[j] - arr[i] < n) \n\nj++; \n\nelse\n\ni++; \n\n} \n\n\nSystem.out.print(\n\"No such pair\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n8\n, \n30\n, \n40\n, \n100\n}; \n\nint\nn = \n60\n; \n\nfindPair(arr,n); \n\n} \n}", "index": 273, "complexity": "1"}
{"back-translation": "class GFG {\n    public static void print2largest(int[] arr, int arr_size) {\n        int i, first, second;\n        if (arr_size < 2) {\n            System.out.print(\" Invalid Input \");\n            return;\n        }\n        first = second = Integer.MIN_VALUE;\n        for (i = 0; i < arr_size ; i++) {\n            if (arr[i] > first) {\n                second = first;\n                first = arr[i];\n            }\n            else if (arr[i] > second && arr[i] != first) {\n                second = arr[i];\n            }\n        }\n        if (second == Integer.MIN_VALUE) {\n            System.out.print(\"There is no second largest element\\n\");\n        }\n        else {\n            System.out.print(\"The second largest element is \" + second);\n        }\n    }\n    public static void main(String[] args) {\n        int arr[] = {12, 35, 1, 10, 34, 1};\n        int n = arr.length;\n        print2largest(arr, n);\n    }\n}", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nvoid\nprint2largest(\nint\narr[], \n\nint\narr_size) \n\n{ \n\nint\ni, first, second; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\n\nif\n(second == Integer.MIN_VALUE) \n\nSystem.out.print(\n\"There is no second largest\"\n+ \n\n\" element\\n\"\n); \n\nelse\n\nSystem.out.print(\n\"The second largest element\"\n+ \n\n\" is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n35\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint2largest(arr, n); \n\n} \n}", "index": 274, "complexity": "1"}
{"back-translation": "class Main { static void printFirstRepeating(int[] arr) { int min = -1; HashSet<Integer> set = new HashSet<>(); for (int i = arr.length - 1; i >= 0; i--) { if (set.contains(arr[i])) min = i; else set.add(arr[i]); } if (min != -1) System.out.println(\"The first repeating element is \" + arr[min]); else System.out.println(\"There are no repeating elements\"); } public static void main(String[] args) throws java.lang.Exception { int[] arr = {10, 5, 3, 4, 3, 5, 6}; printFirstRepeating(arr); } }", "src": "class\nMain \n{ \n\n\n\nstatic\nvoid\nprintFirstRepeating(\nint\narr[]) \n\n{ \n\n\n\nint\nmin = -\n1\n; \n\n\n\n\nHashSet<Integer> set = \nnew\nHashSet<>(); \n\n\n\n\nfor\n(\nint\ni=arr.length-\n1\n; i>=\n0\n; i--) \n\n{ \n\n\n\nif\n(set.contains(arr[i])) \n\nmin = i; \n\n\nelse\n\n\nset.add(arr[i]); \n\n} \n\n\n\n\nif\n(min != -\n1\n) \n\nSystem.out.println(\n\"The first repeating element is \"\n+ arr[min]); \n\nelse\n\nSystem.out.println(\n\"There are no repeating elements\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \nthrows\njava.lang.Exception \n\n{ \n\nint\narr[] = {\n10\n, \n5\n, \n3\n, \n4\n, \n3\n, \n5\n, \n6\n}; \n\nprintFirstRepeating(arr); \n\n} \n}", "index": 275, "complexity": "1"}
{"back-translation": "class FindCommon { void findCommon(int ar1[], int ar2[], int ar3[]) { int i = 0, j = 0, k = 0; while (i < ar1.length && j < ar2.length && k < ar3.length) { if (ar1[i] == ar2[j] && ar2[j] == ar3[k]) { System.out.print(ar1[i]+\" \"); i++; j++; k++; } else if (ar1[i] < ar2[j]) i++; else if (ar2[j] < ar3[k]) j++; else k++; } } public static void main(String args[]) { FindCommon ob = new FindCommon(); int ar1[] = { 1, 5, 10, 20, 40, 80 }; int ar2[] = { 6, 7, 20, 80, 100 }; int ar3[] = { 3, 4, 15, 20, 30, 70, 80, 120 }; System.out.print(\"Common elements are \"); ob.findCommon(ar1, ar2, ar3); } }", "src": "class\nFindCommon \n{ \n\n\n\nvoid\nfindCommon(\nint\nar1[], \nint\nar2[], \nint\nar3[]) \n\n{ \n\n\n\nint\ni = \n0\n, j = \n0\n, k = \n0\n; \n\n\n\n\nwhile\n(i < ar1.length && j < ar2.length && k < ar3.length) \n\n{ \n\n\n\n\n\nif\n(ar1[i] == ar2[j] && ar2[j] == ar3[k]) \n\n{ System.out.print(ar1[i]+\n\" \"\n); i++; j++; k++; } \n\n\n\n\nelse\nif\n(ar1[i] < ar2[j]) \n\ni++; \n\n\n\n\nelse\nif\n(ar2[j] < ar3[k]) \n\nj++; \n\n\n\n\nelse\n\nk++; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nFindCommon ob = \nnew\nFindCommon(); \n\n\nint\nar1[] = {\n1\n, \n5\n, \n10\n, \n20\n, \n40\n, \n80\n}; \n\nint\nar2[] = {\n6\n, \n7\n, \n20\n, \n80\n, \n100\n}; \n\nint\nar3[] = {\n3\n, \n4\n, \n15\n, \n20\n, \n30\n, \n70\n, \n80\n, \n120\n}; \n\n\nSystem.out.print(\n\"Common elements are \"\n); \n\nob.findCommon(ar1, ar2, ar3); \n\n} \n}", "index": 276, "complexity": "1"}
{"back-translation": "class CloseSum { static void printClosest(int[] arr, int n, int x) { int res_l = 0, res_r = 0; int l = 0, r = n-1, diff = Integer.MAX_VALUE; while (r > l) { if (Math.abs(arr[l] + arr[r] - x) < diff) { res_l = l; res_r = r; diff = Math.abs(arr[l] + arr[r] - x); } if (arr[l] + arr[r] > x) r--; else l++; } System.out.println(\" The closest pair is \"+arr[res_l]+\" and \"+ arr[res_r]); } public static void main(String[] args) { int arr[] = {10, 22, 28, 29, 30, 40}, x = 54; int n = arr.length; printClosest(arr, n, x); } }", "src": "class\nCloseSum { \n\n\n\n\nstatic\nvoid\nprintClosest(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres_l=\n0\n, res_r=\n0\n; \n\n\n\n\n\n\n\nint\nl = \n0\n, r = n-\n1\n, diff = Integer.MAX_VALUE; \n\n\n\n\nwhile\n(r > l) \n\n{ \n\n\n\nif\n(Math.abs(arr[l] + arr[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(arr[l] + arr[r] - x); \n\n} \n\n\n\n\nif\n(arr[l] + arr[r] > x) \n\nr--; \n\nelse\n\n\nl++; \n\n} \n\n\nSystem.out.println(\n\" The closest pair is \"\n+arr[res_l]+\n\" and \"\n+ arr[res_r]); \n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n22\n, \n28\n, \n29\n, \n30\n, \n40\n}, x = \n54\n; \n\nint\nn = arr.length; \n\nprintClosest(arr, n, x); \n\n} \n}", "index": 277, "complexity": "1"}
{"back-translation": "class ClosestPair { void printClosest(int ar1[], int ar2[], int m, int n, int x) { int diff = Integer.MAX_VALUE; int res_l = 0, res_r = 0; int l = 0, r = n-1; while (l<m && r>=0) { if (Math.abs(ar1[l] + ar2[r] - x) < diff) { res_l = l; res_r = r; diff = Math.abs(ar1[l] + ar2[r] - x); } if (ar1[l] + ar2[r] > x) r--; else l++; } System.out.print(\"The closest pair is [\"+ ar1[res_l] + \", \"+ ar2[res_r] + \"]\"); } public static void main(String args[]) { ClosestPair ob = new ClosestPair(); int ar1[] = {1, 4, 5, 7}; int ar2[] = {10, 20, 30, 40}; int m = ar1.length; int n = ar2.length; int x = 38; ob.printClosest(ar1, ar2, m, n, x); } }", "src": "class\nClosestPair \n{ \n\n\n\n\n\n\n\n\n\nvoid\nprintClosest(\nint\nar1[], \nint\nar2[], \nint\nm, \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nint\nres_l = \n0\n, res_r = \n0\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\nwhile\n(l<m && r>=\n0\n) \n\n{ \n\n\n\n\n\nif\n(Math.abs(ar1[l] + ar2[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(ar1[l] + ar2[r] - x); \n\n} \n\n\n\n\n\n\nif\n(ar1[l] + ar2[r] > x) \n\nr--; \n\nelse\n\n\nl++; \n\n} \n\n\n\n\nSystem.out.print(\n\"The closest pair is [\"\n+ ar1[res_l] + \n\n\", \"\n+ ar2[res_r] + \n\"]\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nClosestPair ob = \nnew\nClosestPair(); \n\nint\nar1[] = {\n1\n, \n4\n, \n5\n, \n7\n}; \n\nint\nar2[] = {\n10\n, \n20\n, \n30\n, \n40\n}; \n\nint\nm = ar1.length; \n\nint\nn = ar2.length; \n\nint\nx = \n38\n; \n\nob.printClosest(ar1, ar2, m, n, x); \n\n} \n}", "index": 278, "complexity": "1"}
{"back-translation": "class PairInSortedRotated { static boolean pairInSortedRotated(int arr[], int n, int x) { int i; for (i = 0; i < n - 1; i++) if (arr[i] > arr[i+1]) break; int l = (i + 1) % n; int r = i; while (l != r) { if (arr[l] + arr[r] == x) return true; if (arr[l] + arr[r] < x) l = (l + 1) % n; else r = (n + r - 1) % n; } return false; } public static void main(String[] args) { int arr[] = { 11, 15, 6, 8, 9, 10 }; int sum = 16; int n = arr.length; if (pairInSortedRotated(arr, n, sum)) System.out.print(\"Array has two elements\"+ \" with sum 16\"); else System.out.print(\"Array doesn't have two\"+ \" elements with sum 16 \"); } }", "src": "class\nPairInSortedRotated \n{ \n\n\n\n\n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n\n\n\n\n\nint\nr = i; \n\n\n\n\n\n\n\nwhile\n(l != r) \n\n{ \n\n\n\n\n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n\n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n}", "index": 279, "complexity": "1"}
{"back-translation": "class Test {\n    static int arr[] = new int[]{12, 34, 10, 6, 40};\n\n    static int findLargestSumPair() {\n        int first, second;\n\n        if (arr[0] > arr[1]) {\n            first = arr[0];\n            second = arr[1];\n        } else {\n            first = arr[1];\n            second = arr[0];\n        }\n\n        for (int i = 2; i < arr.length; i++) {\n            if (arr[i] > first) {\n                second = first;\n                first = arr[i];\n            } else if (arr[i] > second && arr[i] != first) {\n                second = arr[i];\n            }\n        }\n\n        return (first + second);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Max Pair Sum is \" + findLargestSumPair());\n    }\n}", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n12\n, \n34\n, \n10\n, \n6\n, \n40\n}; \n\n\n\n\nstatic\nint\nfindLargestSumPair() \n\n{ \n\n\n\nint\nfirst, second; \n\nif\n(arr[\n0\n] > arr[\n1\n]) \n\n{ \n\nfirst = arr[\n0\n]; \n\nsecond = arr[\n1\n]; \n\n} \n\nelse\n\n{ \n\nfirst = arr[\n1\n]; \n\nsecond = arr[\n0\n]; \n\n} \n\n\n\n\n\n\nfor\n(\nint\ni = \n2\n; i<arr.length; i ++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nreturn\n(first + second); \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nSystem.out.println(\n\"Max Pair Sum is \"\n+ findLargestSumPair()); \n\n\n} \n}", "index": 280, "complexity": "1"}
{"back-translation": "ERROR", "src": "class\nSecondSmallest \n{ \n\n\n\nstatic\nvoid\nprint2Smallest(\nint\narr[]) \n\n{ \n\nint\nfirst, second, arr_size = arr.length; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MAX_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] < first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] < second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nif\n(second == Integer.MAX_VALUE) \n\nSystem.out.println(\n\"There is no second\"\n+ \n\n\"smallest element\"\n); \n\nelse\n\nSystem.out.println(\n\"The smallest element is \"\n+ \n\nfirst + \n\" and second Smallest\"\n+ \n\n\" element is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nprint2Smallest(arr); \n\n} \n}", "index": 281, "complexity": "1"}
{"back-translation": "public class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = 0;\n\t\tString inp = s.nextLine();\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tchar k = inp.charAt(i);\n\t\t\tif (k == '+')\n\t\t\t\tans++;\n\t\t\tif (k == '-') {\n\t\t\t\tif (ans>0)\n\t\t\t\t\tans--;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = 0;\n\t\tString inp = s.nextLine();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchar k = inp.charAt(i);\n\t\t\tif (k == '+')\n\t\t\t\tans++;\n\t\t\tif (k == '-') {\n\t\t\t\tif (ans>0)\n\t\t\t\t\tans--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 282, "complexity": "1"}
{"back-translation": "public class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tans = Math.min(ans, Math.min(arr[i], arr[0]) / i);\n\t\t}\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tans = Math.min(ans, Math.min(arr[n - 1], arr[i]) / (n - i - 1));\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint arr[] = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tans = Math.min(ans, Math.min(arr[i],arr[0])/i);\n\t\t}\n\t\tfor (int i=n-2;i>=0;i--){\n\t\t\tans = Math.min(ans, Math.min(arr[n-1],arr[i])/(n-i-1));\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 283, "complexity": "1"}
{"back-translation": "public class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint tmp;\n\t\tint min=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ttmp=sc.nextInt();\n\t\t\tif(2*i>n-1) {\n\t\t\t\ttmp=tmp/i;\n\t\t\t}else {\n\t\t\t\ttmp=tmp/(n-1-i);\n\t\t\t}\n\t\t\tif(tmp<min) {\n\t\t\t\tmin=tmp;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint tmp;\n\t\tint min=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ttmp=sc.nextInt();\n\t\t\tif(i>n-1-i) {\n\t\t\t\ttmp=tmp/i;\n\t\t\t}else {\n\t\t\t\ttmp=tmp/(n-1-i);\n\t\t\t}\n\t\t\tif(tmp<min) {\n\t\t\t\tmin=tmp;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "index": 284, "complexity": "1"}
{"back-translation": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            while(s.length()<n){\n                s=s+s;\n            }\n            String s1=new String();\n            for(int i=0;i<n;i++){\n                s1=s1+Character.toString(s.charAt(i));\n            }\n            System.out.println(s1);\n        }\n\t}\n}", "src": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            while(s.length()<n){\n                s=s+s;\n            }\n            String s1=new String();\n            for(int i=0;i<n;i++){\n                s1=s1+Character.toString(s.charAt(i));\n            }\n            System.out.println(s1);\n        }\n\t}\n}", "index": 285, "complexity": "1"}
{"back-translation": "class MaximumSum { int FindMaxSum(int[] arr, int n) { int incl = arr[0]; int excl = 0; int excl_new; int i; for (i = 1; i < n; i++) { excl_new = (incl > excl) ? incl : excl; incl = excl + arr[i]; excl = excl_new; } return ((incl > excl) ? incl : excl); } public static void main(String[] args) { MaximumSum sum = new MaximumSum(); int arr[] = new int[]{5, 5, 10, 100, 10, 5}; System.out.println(sum.FindMaxSum(arr, arr.length)); } }", "src": "class\nMaximumSum \n{ \n\n\n\nint\nFindMaxSum(\nint\narr[], \nint\nn) \n\n{ \n\nint\nincl = arr[\n0\n]; \n\nint\nexcl = \n0\n; \n\nint\nexcl_new; \n\nint\ni; \n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\n\n\nexcl_new = (incl > excl) ? incl : excl; \n\n\n\n\nincl = excl + arr[i]; \n\nexcl = excl_new; \n\n} \n\n\n\n\nreturn\n((incl > excl) ? incl : excl); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMaximumSum sum = \nnew\nMaximumSum(); \n\nint\narr[] = \nnew\nint\n[]{\n5\n, \n5\n, \n10\n, \n100\n, \n10\n, \n5\n}; \n\nSystem.out.println(sum.FindMaxSum(arr, arr.length)); \n\n} \n}", "index": 286, "complexity": "1"}
{"back-translation": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            StringBuilder sb=new StringBuilder();\n            for(int i=0;i<k;i++){\n                sb.append(\"1\");\n            }\n            System.out.println(sb.toString());\n        }\n        else{\n            int a=(n-k)/2;\n            StringBuilder sb=new StringBuilder();\n            while(sb.length()<n){\n                for(int i=0;i<a && sb.length()<n;i++){\n                    sb.append(\"1\");\n                }\n                if(sb.length()<n){\n                    sb.append(\"0\");\n                }\n            }\n            System.out.println(sb.toString());\n        }\n\t}\n}", "src": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n            while(s.length()<n){\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            }\n            System.out.println(s);\n        }\n\t}\n}", "index": 287, "complexity": "1"}
{"back-translation": "public class helloWorld {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint[][] dn = new int[200][m+1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\tfor (int k = 2; k <= m; k++)\n\t\t\tfor (int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif (exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor (int j = i + 2; j <= 'z'; j++)\n\t\t\t\t\t\tif (dn[j][k - 1] > 0 && (a == 0 || (a > dn[j][k - 1])))\n\t\t\t\t\t\t\ta = dn[j][k - 1];\n\t\t\t\t\tif (a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1;\n\t\t\t\t}\n\t\tint ans = -1;\n\t\tfor (int i = 'a'; i <= 'z'; i++)\n\t\t\tif (dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]))\n\t\t\t\tans = dn[i][m];\n\t\tSystem.out.println(ans);\n\t\tin.close();\n\t}\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 288, "complexity": "1"}
{"back-translation": "public class RevisedHelloWorld {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt += in.nextInt();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt -= in.nextInt();\n\t\t}\n\t\t\n\t\tif (cnt < 0) {\n\t\t\tans = \"No\";\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\tin.close();\n\t}\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}", "index": 289, "complexity": "1"}
{"back-translation": "public class Piles {\n    static int summation(int[] arr) {\n        int sum = 0;\n        for (int k = 0; k < arr.length; k++) {\n            sum += arr[k];\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        if (n >= 1 && n <= 50) {\n            int[] x = new int[n];\n            int[] y = new int[n];\n\n            for (int i = 0; i < n; i++) {\n                x[i] = sc.nextInt();\n            }\n\n            for (int j = 0; j < n; j++) {\n                y[j] = sc.nextInt();\n            }\n\n            int xsum = summation(x);\n            int ysum = summation(y);\n\n            if (xsum >= ysum) {\n                System.out.println(\"Yes\");\n            } else {\n                System.out.println(\"No\");\n            }\n        }\n    }\n}", "src": "public class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tfor(k=0;k<arr.length;k++) {\n\t\t\tsum = sum + arr[k];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n}", "index": 290, "complexity": "1"}
{"back-translation": "class GFG { public static int findFrequency(int arr[], int n, int left, int right, int element) { int count = 0; for (int i = left - 1; i < right; ++i) if (arr[i] == element) ++count; return count; } public static void main(String[] args) { int arr[] = { 2, 8, 6, 9, 8, 6, 8, 2, 11 }; int n = arr.length; System.out.println(\"Frequency of 2 from 1 to 6 = \" + findFrequency(arr, n, 1, 6, 2)); System.out.println(\"Frequency of 8 from 4 to 9 = \" + findFrequency(arr, n, 4, 9, 8)); } }", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nfindFrequency(\nint\narr[], \nint\nn, \n\nint\nleft, \nint\nright, \n\nint\nelement) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = left - \n1\n; i < right; ++i) \n\nif\n(arr[i] == element) \n\n++count; \n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n8\n, \n6\n, \n9\n, \n8\n, \n6\n, \n8\n, \n2\n, \n11\n}; \n\nint\nn = arr.length; \n\n\n\n\nSystem.out.println(\n\"Frequency of 2 from 1 to 6 = \"\n+ \n\nfindFrequency(arr, n, \n1\n, \n6\n, \n2\n)); \n\n\n\n\nSystem.out.println(\n\"Frequency of 8 from 4 to 9 = \"\n+ \n\nfindFrequency(arr, n, \n4\n, \n9\n, \n8\n)); \n\n\n} \n\n}", "index": 291, "complexity": "1"}
{"back-translation": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tint i=0;\n\t\twhile (i<n)\n\t\t{\n\t\t\ts1+=input.nextInt();\n\t\t\ti++;\n\t\t}\n\t\ti=0;\n\t\twhile (i<n)\n\t\t{\n\t\t\ts2+=input.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "src": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts1+=input.nextInt();\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts2+=input.nextInt();\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "index": 292, "complexity": "1"}
{"back-translation": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2];\n\t\tint x = scan.nextInt();\n\t\tfor (int i = 0; i < 2; i++)\n\t\t\tfor (int j = 0; j < x; j++)\n\t\t\t\ta[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\t}\n\n}", "src": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}", "index": 293, "complexity": "1"}
{"back-translation": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(set1.contains(a[i])){\n                            System.out.println(0);\n                            return;\n                     }\n                     set1.add(a[i]);\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     \n                            \n                     \n                       \n                         \n                     \n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "index": 294, "complexity": "1"}
{"back-translation": "public class B {\n    public static void main(String[] args) throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5 + 50];\n        int g[] = new int[(int) 2e5 + 50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n + 1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if (f[a] > 0) {\n                ans = 0;\n                break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if ((a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)) {\n                ans = 1;\n                break;\n            }\n\n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if (g[a] > 1) {\n                ans = 2;\n                break;\n            }\n\n        }\n\n        pw.println(ans); pw.close();\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is) {\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (ptrbuf >= lenbuf) {\n                ptrbuf = 0;\n                try {\n                    lenbuf = is.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        public int skip() {\n            int b; while ((b = readByte()) != -1 && isSpaceChar(b)); return b;\n        }\n\n        public String next() {\n            int b = skip(); StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))) {\n                sb.appendCodePoint(b); b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int num = 0, b; boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-') { minus = true; b = readByte(); }\n            while(true) {\n                if(b >= '0' && b <= '9') {\n                    num = (num<<3) + (num<<1) + ints[b];\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0; int b; boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-') { minus = true; b = readByte(); }\n            while(true) {\n                if(b >= '0' && b <= '9') {\n                    num = (num<<3) + (num<<1) + ints[b];\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public char[] next(int n) {\n            char[] buf = new char[n]; int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))) {\n                buf[p++] = (char) b; b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        \n    }\n}", "src": "public class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            \n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ \n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       \n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        \n    }\n}", "index": 295, "complexity": "1"}
{"back-translation": "class Test {\n\n    static int arr[] = new int[]{ 10 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9};\n\n    static int maxSum() {\n\n        int arrSum = 0;\n\n        int currVal = 0;\n\n        for (int i=0; i<arr.length; i++) {\n\n            arrSum = arrSum + arr[i];\n\n            currVal = currVal + (i * arr[i]);\n\n        }\n\n        int maxVal = currVal;\n\n        for (int j=1; j<arr.length; j++) {\n\n            currVal = currVal + arrSum - arr.length * arr[arr.length - j];\n\n            if (currVal > maxVal)\n\n                maxVal = currVal;\n\n        }\n\n        return maxVal;\n\n    }\n\n    public static void main(String[] args) {\n\n        System.out.println(\"Max sum is \" + maxSum());\n\n    }\n\n}", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n10\n, \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\n\n\n\nstatic\nint\nmaxSum() \n\n{ \n\n\n\nint\narrSum = \n0\n; \n\n\nint\ncurrVal = \n0\n; \n\n\nfor\n(\nint\ni=\n0\n; i<arr.length; i++) \n\n{ \n\narrSum = arrSum + arr[i]; \n\ncurrVal = currVal+(i*arr[i]); \n\n} \n\n\n\n\nint\nmaxVal = currVal; \n\n\n\n\n\n\nfor\n(\nint\nj=\n1\n; j<arr.length; j++) \n\n{ \n\ncurrVal = currVal + arrSum-arr.length*arr[arr.length-j]; \n\nif\n(currVal > maxVal) \n\nmaxVal = currVal; \n\n} \n\n\n\n\nreturn\nmaxVal; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Max sum is \"\n+ maxSum()); \n\n} \n}", "index": 296, "complexity": "1"}
{"back-translation": "public class NewTaskA {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tlong i = sc.nextInt();\n\t\tlong goal = sc.nextLong();\n\nif(i>goal) {\n\ti=goal;\n}\n\t\tint count = 0;\n\t\twhile (goal >= 0) {\n\t\t\tif (goal - i >= 0) {\n\t\t\t\tgoal = goal - i;\n\t\t\t\tcount++;\n\t\t\t} else\n\t\t\t\ti--;\n\t\t\tif (goal == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tout.print(count);\n\n\t\tout.flush();\n\n\t}\n\n\tstatic class NewScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic NewScanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic NewScanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "src": "public class TaskA {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tlong i = sc.nextInt();\n\t\tlong goal = sc.nextLong();\n\nif(i>goal) {\n\ti=goal;\n}\n\t\tint count = 0;\n\t\twhile (goal >= 0) {\n\t\t\tif (goal - i >= 0) {\n\t\t\t\tgoal = goal - i;\n\t\t\t\tcount++;\n\t\t\t} else\n\t\t\t\ti--;\n\t\t\tif (goal == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tout.print(count);\n\n\t\tout.flush();\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "index": 297, "complexity": "1"}
{"back-translation": "public class CoinsTask {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint S = in.nextInt();\n\t\tint mCoins = 0;\n\t\twhile(S / n != 0) {\n\t\t\tmCoins += 1;\n\t\t\tS -= n;\n\t\t}\n\t\tmCoins = S == 0 ? mCoins : mCoins + 1;\n\t\tSystem.out.print(mCoins);\n\t}\n\n}", "src": "public class CoinsTask {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint S = in.nextInt();\n\t\tint mCoins = 0;\n\t\twhile(S/n != 0) {\n\t\t\tmCoins+=1;\n\t\t\tS-=n;\n\t\t}\n\t\tmCoins = S == 0? mCoins : mCoins+1;\n\t\tSystem.out.print(mCoins);\n\t}\n\n}", "index": 298, "complexity": "1"}
{"back-translation": "public class P1075A {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong n, x, y;\n\t\tn = scan.nextLong();\n\t\tx = scan.nextLong();\n\t\ty = scan.nextLong();\n\t\tboolean flag = true, flag1 = false, flag2 = false;\n\t\tlong w1, w2, b1, b2;\n\t\tlong W = 0l, B = 0l;\n\t\tw1 = w2 = 1;\n\t\tb1 = b2 = n;\n\t\twhile (w1 < n) {\n\t\t\tif (w1 == x) {\n\t\t\t\tflag1 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (w2 == y)\n\t\t\t\tbreak;\n\t\t\t++w1;\n\t\t\t++w2;\n\t\t\t++W;\n\t\t}\n\t\tif (flag1)\n\t\t\tW += (y - w2);\n\t\telse\n\t\t\tW += (x - w1);\n\t\twhile (b1 > 1) {\n\t\t\tif (b1 == x) {\n\t\t\t\tflag2 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (b2 == y)\n\t\t\t\tbreak;\n\t\t\t--b1;\n\t\t\t--b2;\n\t\t\t++B;\n\t\t}\n\t\tif (flag2)\n\t\t\tB += (b2 - y);\n\t\telse\n\t\t\tB += (b1 - x);\n\t\tif (B < W)\n\t\t\tSystem.out.println(\"Black\");\n\t\telse\n\t\t\tSystem.out.println(\"White\");\n\t}\n}", "src": "public class P1075A\n{\n\tpublic static void main(String[] args)\n\t{\n\t Scanner scan=new Scanner(System.in);\n\t long n,x,y;\n\t n=scan.nextLong();\n\t x=scan.nextLong();\n\t y=scan.nextLong();\n\t boolean flag=true,flag1=false,flag2=false;\n\t long w1,w2,b1,b2;\n\t long W=0l,B=0l;\n\t w1=w2=1;\t\tb1=b2=n;\n\t while(w1<n)\n\t\t{\n\t\t if(w1==x)\n\t\t\t{flag1=true;\tbreak;}\n\t\t if(w2==y)\n\t\t\tbreak;\n\t\t ++w1;\t++w2;\t++W;\n\t\t}\n\t if(flag1)\n\t\tW+=(y-w2);\n\t else\n\t\tW+=(x-w1);\n\t while(b1>1)\n\t\t{\n\t\t if(b1==x)\n\t\t\t{flag2=true;\tbreak;}\n\t\t if(b2==y)\n\t\t\tbreak;\n\t\t --b1;\t--b2;\t++B;\n\t\t}\n\t if(flag2)\n\t\tB+=(b2-y);\n\t else\n\t\tB+=(b1-x);\n\t if(B<W)\n\t\tSystem.out.println(\"Black\");\n\t else\n\t\tSystem.out.println(\"White\");\n\t}\n}", "index": 299, "complexity": "1"}
{"back-translation": "public class kingrace {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        long a = input.nextLong();\n        input.nextLine();\n        String[] coo = input.nextLine().split(\" \");\n        long xcoin = Long.parseLong(coo[0]);\n        long ycoin = Long.parseLong(coo[1]);\n        coordinates first = new coordinates(1, 1, a);\n        coordinates second = new coordinates(a, a, a);\n        double x = (double) Math.sqrt(Math.abs((xcoin - 1) * (xcoin - 1) + (ycoin - 1) * (ycoin - 1)));\n        double y = (double) Math.sqrt(Math.abs((xcoin - a) * (xcoin - a) + (ycoin - a) * (ycoin - a));\n        long c = 0;\n        long d = 0;\n        if (x > y) {\n            System.out.println(\"Black\");\n        } else if (x < y) {\n            System.out.println(\"White\");\n        } else {\n            c = first.Distance(new coordinates(xcoin, ycoin, a));\n            d = second.Distance(new coordinates(xcoin, ycoin, a));\n        }\n        if (d != 0 && c != 0)\n            if (d < c) {\n                System.out.println(\"Black\");\n            } else {\n                System.out.println(\"White\");\n            }\n        input.close();\n    }\n}\n\nclass coordinates {\n    private long xcoord;\n    private long ycoord;\n    private long dim;\n\n    public coordinates(long x, long y, long dimensions) {\n        xcoord = x;\n        ycoord = y;\n        dim = dimensions;\n\n    }\n\n    public void setCoordinates(long x, long y) {\n        xcoord = x;\n        ycoord = y;\n\n    }\n\n    public long Distance(coordinates num) {\n        long distance = 0;\n\n        while (this.xcoord != num.xcoord || this.ycoord != num.ycoord) {\n\n            if (num.xcoord - this.xcoord == 1 && num.ycoord == this.ycoord) {\n\n                distance++;\n                this.setCoordinates(this.xcoord + 1, this.ycoord);\n            } else if (num.xcoord - this.xcoord == -1 && num.ycoord == this.ycoord) {\n\n                distance++;\n                this.setCoordinates(this.xcoord - 1, this.ycoord);\n            } else if (num.xcoord - this.xcoord == 0 && num.ycoord - this.ycoord == 1) {\n                distance++;\n                this.setCoordinates(this.xcoord, this.ycoord + 1);\n            } else if (num.xcoord - this.xcoord == 0 && num.ycoord - this.ycoord == -1) {\n                distance++;\n                this.setCoordinates(this.xcoord, this.ycoord - 1);\n            } else if (num.xcoord - this.xcoord >= 0 && num.ycoord - this.ycoord <= 0) {\n\n                distance++;\n                this.setCoordinates(this.xcoord + 1, this.ycoord - 1);\n            } else if (num.xcoord - this.xcoord >= 0 && num.ycoord - this.ycoord >= 0) {\n\n                distance++;\n                this.setCoordinates(this.xcoord + 1, this.ycoord + 1);\n            } else if (num.xcoord - this.xcoord <= 0 && num.ycoord - this.ycoord <= 0)\n\n            {\n                distance++;\n                this.setCoordinates(this.xcoord - 1, this.ycoord - 1);\n            } else if (num.xcoord - this.xcoord <= 0 && num.ycoord - this.ycoord >= 0)\n            {distance++;\n                this.setCoordinates(this.xcoord - 1, this.ycoord + 1);\n            }\n\n        }\n\n        return distance;\n    }\n\n} ", "src": "public class kingrace {public static void main(String[] args) \n{ \n    Scanner input=new Scanner(System.in);\n    long a = input.nextLong();\n   input.nextLine();\n    String [] coo = input.nextLine().split(\" \");\n    long xcoin = Long.parseLong(coo[0]);\n    long ycoin = Long.parseLong(coo[1]);\n    coordinates first = new coordinates(1,1,a);\n    coordinates second = new coordinates(a,a,a);\n    double x = (double)Math.sqrt(Math.abs((xcoin-1)*(xcoin-1)+(ycoin-1)*(ycoin-1)));\n    double y = (double)Math.sqrt(Math.abs((xcoin-a)*(xcoin-a)+(ycoin-a)*(ycoin-a)));\n   long c = 0;\n   long d = 0;\n    if (x>y)\n    {\n    \tSystem.out.println(\"Black\");\n    }\n    else if(x<y)\n    {\n    \tSystem.out.println(\"White\");\n    }\n    else {\n    c = first.Distance(new coordinates(xcoin,ycoin,a));\n    d = second.Distance(new coordinates(xcoin,ycoin,a));\n    }\n    if(d!=0&&c!=0)\n    if (d<c)\n    {\n    \tSystem.out.println(\"Black\");\n    \t\n    }\n    else \n    {\n    \tSystem.out.println(\"White\");\n    }\n  \n  input.close();\n} \n\n}\nclass coordinates{\n\tprivate long xcoord;\n\tprivate long ycoord;\n\tprivate long dim; \n\tpublic coordinates(long x, long y, long dimensions)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\tdim = dimensions;\n\t\t\n\t}\n\tpublic void setCoordinates(long x, long y)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\t\n\t}\n\tpublic long Distance(coordinates num)\n\t{\n\t\tlong distance = 0; \n\t\t\n\t\t\n\t\twhile ((this.xcoord!=num.xcoord||this.ycoord!=num.ycoord))\n\t\t{\n\t\t\n\t\t\tif (num.xcoord-this.xcoord==1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\n\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==-1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==1)\n\t\t\t{distance ++; this.setCoordinates(this.xcoord, this.ycoord+1);}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==-1) {\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord, this.ycoord-1);\n\t\t\t}\n\t\t\t\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord-1); \n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord+1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord-1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t\t\t{distance ++; this.setCoordinates(this.xcoord-1, this.ycoord+1);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\treturn distance;\n\t}\n\t\n\t\n}", "index": 300, "complexity": "1"}
{"back-translation": "class GFG { static int answer_query(int[] a, int n, int l, int r) { int count = 0; for (int i = l; i < r; i++) if (a[i] == a[i + 1]) count += 1; return count; } public static void main(String[] args) { int a[] = {1, 2, 2, 2, 3, 3, 4, 4, 4}; int n = a.length; int L, R; L = 1; R = 8; System.out.println(answer_query(a, n, L, R)); L = 0; R = 4; System.out.println(answer_query(a, n, L, R)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nanswer_query(\nint\na[], \nint\nn, \n\nint\nl, \nint\nr) \n\n{ \n\n\n\n\n\n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = l; i < r; i++) \n\nif\n(a[i] == a[i + \n1\n]) \n\ncount += \n1\n; \n\n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = a.length; \n\n\n\n\nint\nL, R; \n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n\n\n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n} \n}", "index": 301, "complexity": "1"}
{"back-translation": "public class Solution {     public static void main(String[] args) {         Scanner sc = new Scanner(System.in);         int n = sc.nextInt(), m = sc.nextInt();         int[] loca = new int[n + m];         int[] res = new int[m];         for (int i = 0; i < n + m; i++)             loca[i] = sc.nextInt();         int y = 0;         int[] driver = new int[m];         for (int i = 0; i < n + m; i++) {             int x = sc.nextInt();             if (x == 1)                 driver[y++] = i;         }         int i = 0, j = 0, p = 0, q = 0;         for (i = 0; i < m + n; i++) {             if (i == driver[0]) {                 i++;                 break;             }             if (loca[i] < loca[driver[0]])                 res[0]++;             else                 break;         }         for (; i < n + m; i++) {             int coor = loca[i];             if (j == m - 1)                 break;             p = driver[j];             q = driver[j + 1];             if (i == j)                 continue;             int d1 = coor - loca[p], d2 = loca[q] - coor;             if (d2 == 0) {j++;continue;}             if (d1 <= d2)                 res[j]++;             else                 res[j + 1]++;         }         for (; i < m + n; i++) {             if (i == driver[j]) {                 i++;                 break;             }             if (loca[i] > loca[driver[j]])                 res[j]++;             else                 break;         }         for (i = 0; i < m; i++)             System.out.print(res[i] + \" \");     } }", "src": "public class Solution {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc= new Scanner(System.in);\n\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\tint loca[]=new int[n+m];\n\t\tint res[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++)\n\t\t\tloca[i]=sc.nextInt();\n\t\t\n\t\tint y=0;\n\t\tint driver[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++){\n\t\t\tint x=sc.nextInt();\n\t\t\tif(x==1)\n\t\t\t\tdriver[y++]=i;\n\t\t}\n\t\t\n\t\tint i=0,j=0,p=0,q=0;\n\t\tfor(i=0;i<m+n;i++) {\n\t\t\tif(i==driver[0])\n\t\t\t\t{i++;break;}\n\t\t\tif(loca[i]<loca[driver[0]])\n\t\t\t\tres[0]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(;i<n+m;i++){\n\t\t\t\n\t\t\tint coor=loca[i];\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif(j==m-1)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tp=driver[j];q=driver[j+1];\t\t\n\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint d1=coor-loca[p],d2=loca[q]-coor;\n\t\t\t\n\t\t\tif(d2==0)\n\t\t\t\t{j++;continue;}\n\t\t\tif(d1<=d2)\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tres[j+1]++;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(;i<m+n;i++) {\n\t\t\t\n\t\t\tif(i==driver[j])\n\t\t\t{i++;break;}\n\t\t\t\n\t\t\tif(loca[i]>loca[driver[j]])\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(i=0;i<m;i++)\n\t\t\tSystem.out.print(res[i]+\" \");\n\t}\n}", "index": 302, "complexity": "1"}
{"back-translation": "class GFG { static int repeated_digit(int n) { LinkedHashSet<Integer> s = new LinkedHashSet<>(); while (n != 0) { int d = n % 10; if (s.contains(d)) { return 0; } s.add(d); n = n / 10; } return 1; } static int calculate(int L, int R) { int answer = 0; for (int i = L; i < R + 1; ++i) { answer = answer + repeated_digit(i); } return answer; } public static void main(String[] args) { int L = 1, R = 100; System.out.println(calculate(L, R)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nrepeated_digit(\nint\nn) \n{ \n\nLinkedHashSet<Integer> s = \nnew\nLinkedHashSet<>(); \n\n\n\n\nwhile\n(n != \n0\n) \n\n{ \n\nint\nd = n % \n10\n; \n\n\n\n\n\n\n\n\nif\n(s.contains(d)) \n\n{ \n\n\n\n\n\nreturn\n0\n; \n\n} \n\ns.add(d); \n\nn = n / \n10\n; \n\n} \n\n\n\n\n\n\nreturn\n1\n; \n} \n\n\n\n\nstatic\nint\ncalculate(\nint\nL, \nint\nR) \n{ \n\nint\nanswer = \n0\n; \n\n\n\n\nfor\n(\nint\ni = L; i < R + \n1\n; ++i) \n\n{ \n\n\n\n\n\n\nanswer = answer + repeated_digit(i); \n\n} \n\n\nreturn\nanswer; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nL = \n1\n, R = \n100\n; \n\n\n\n\nSystem.out.println(calculate(L, R)); \n} \n}", "index": 303, "complexity": "1"}
{"back-translation": "class GFG {\n    static void initializeDiffArray(int[] A, int[] D) {\n        int n = A.length;\n        D[0] = A[0];\n        D[n] = 0;\n        for (int i = 1; i < n; i++) {\n            D[i] = A[i] - A[i - 1];\n        }\n    }\n\n    static void update(int[] D, int l, int r, int x) {\n        D[l] += x;\n        D[r + 1] -= x;\n    }\n\n    static int printArray(int[] A, int[] D) {\n        for (int i = 0; i < A.length; i++) {\n            if (i == 0) {\n                A[i] = D[i];\n            } else {\n                A[i] = D[i] + A[i - 1];\n            }\n            System.out.print(A[i] + \" \");\n        }\n        System.out.println();\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        int A[] = {10, 5, 20, 40};\n        int n = A.length;\n        int D[] = new int[n + 1];\n        initializeDiffArray(A, D);\n        update(D, 0, 1, 10);\n        printArray(A, D);\n        update(D, 1, 3, 20);\n        update(D, 2, 2, 30);\n        printArray(A, D);\n    }\n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\ninitializeDiffArray(\nint\nA[], \nint\nD[]) \n\n{ \n\n\nint\nn = A.length; \n\n\nD[\n0\n] = A[\n0\n]; \n\nD[n] = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nD[i] = A[i] - A[i - \n1\n]; \n\n} \n\n\n\n\nstatic\nvoid\nupdate(\nint\nD[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nD[l] += x; \n\nD[r + \n1\n] -= x; \n\n} \n\n\n\n\nstatic\nint\nprintArray(\nint\nA[], \nint\nD[]) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < A.length; i++) { \n\n\nif\n(i == \n0\n) \n\nA[i] = D[i]; \n\n\n\n\n\n\nelse\n\nA[i] = D[i] + A[i - \n1\n]; \n\n\nSystem.out.print(A[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nint\nA[] = { \n10\n, \n5\n, \n20\n, \n40\n}; \n\nint\nn = A.length; \n\n\n\n\n\n\n\nint\nD[] = \nnew\nint\n[n + \n1\n]; \n\ninitializeDiffArray(A, D); \n\n\n\n\n\n\nupdate(D, \n0\n, \n1\n, \n10\n); \n\nprintArray(A, D); \n\n\n\n\n\n\nupdate(D, \n1\n, \n3\n, \n20\n); \n\nupdate(D, \n2\n, \n2\n, \n30\n); \n\n\nprintArray(A, D); \n\n} \n}", "index": 304, "complexity": "1"}
{"back-translation": "public class Cf1003A { \n    public static void main(String[] args) throws IOException { \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n        int n = Integer.parseInt(br.readLine()); \n        StringTokenizer stk = new StringTokenizer(br.readLine()); \n        int[] arr = new int[100]; \n        int max = 0; \n        int tmp; \n        for (int i = 0; i < n; i++) { \n            tmp = Integer.parseInt(stk.nextToken()) - 1; \n            max = max < ++arr[tmp] ? arr[tmp] : max; \n        } \n        System.out.println(max); \n    } \n}", "src": "public class Cf1003A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int[] arr = new int[100];\n        int max = 0;\n        int tmp;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken()) - 1;\n           max = max < ++arr[tmp] ? arr[tmp] : max;\n        }\n        System.out.println(max);\n    }\n}", "index": 305, "complexity": "1"}
{"back-translation": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        contest1 solver = new contest1();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class contest1 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int x = in.nextInt();\n            String s = \"\";\n            int count = 0;\n\n            int copya = a;\n            int copyb = b;\n            int change = 0;\n\n             \n            if (x == 1) {\n                while (a > 0) {\n                    s += '0';\n                    a--;\n                }\n                while (b > 0) {\n                    s += '1';\n                    b--;\n                }\n            } else {\n                if (copya > copyb) {\n                    while (change <= x - 1) {\n                        if (change % 2 == 0) {\n                            s += '0';\n                            change++;\n                            a--;\n                        } else {\n                            s += '1';\n                            change++;\n                            b--;\n                        }\n                    }\n                } else if (copyb >= copya) {\n                    while (change <= x - 1) {\n                        if (change % 2 == 0) {\n                            s += '1';\n                            change++;\n                            b--;\n                        } else {\n                            s += '0';\n                            change++;\n                            a--;\n                        }\n                    }\n                }\n\n                char z = s.charAt(s.length() - 1);\n                if (z == '0') {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                }\n            }\n            out.println(s);\n        }\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        contest1 solver = new contest1();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class contest1 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int x = in.nextInt();\n            String s = \"\";\n            int count = 0;\n\n            int copya = a;\n            int copyb = b;\n            int change = 0;\n\n            if (x == 1) {\n                if (copya > copyb) {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n\n                }\n\n            } else {\n                \n                if (copya > copyb) {\n                    while (change <= x - 1) {\n                        if (change % 2 == 0) {\n                            s += '0';\n                            change++;\n                            a--;\n                        } else {\n                            s += '1';\n                            change++;\n                            b--;\n                        }\n                    }\n\n                } else if (copyb >= copya) {\n                    \n                    while (change <= x - 1) {\n                        \n                        if (change % 2 == 0) {\n                            s += '1';\n                            change++;\n                            b--;\n                        } else {\n                            s += '0';\n                            change++;\n                            a--;\n                        }\n                    }\n                }\n\n                char z = s.charAt(s.length() - 1);\n                \n                if (z == '0') {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                }\n            }\n            out.println(s);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 306, "complexity": "1"}
{"back-translation": "public class programA {\n   \tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint d = Integer.parseInt(st.nextToken());\n\t\tint arr[] = new int[n];\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tarr[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tint s= 2;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tlong dis = (long) (2 * d);\n\t\t\tlong dis2 = Math.abs(arr[i] - arr[i + 1]);\n\t\t\tif (dis2 == dis) s++;\n\t\t\telse if (dis2 > dis) s += 2;\n\t\t}\n\t\tSystem.out.println(s);\n   \t\t}\n}", "src": "public class programA {\n   \tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint d = Integer.parseInt(st.nextToken());\n\t\tint arr[] = new int[n];\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tarr[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tint s= 2;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tlong dis = (long)2*d;\n\t\t\tlong dis2 = Math.abs(arr[i]-arr[i+1]);\n\t\t\tif(dis2 == dis)s++;\n\t\t\telse if (dis2 > dis)s+=2;\n\t\t}\n\t\tSystem.out.println(s);\n   \t\t}\n}", "index": 307, "complexity": "1"}
{"back-translation": "public class Cf1005A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int numberOfStairs = 0;\n        StringBuilder result = new StringBuilder();\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int previousNum = 0;\n        int tmp = 0;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken());\n            if (tmp == 1) {\n                ++numberOfStairs;\n                if (previousNum != 0)\n                    result.append(previousNum + \" \");\n            }\n            previousNum = tmp;\n        }\n        result.append(previousNum);\n        System.out.println(numberOfStairs);\n        System.out.println(result);\n    }\n}", "src": "public class Cf1005A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int numberOfStairs = 0;\n        StringBuilder result = new StringBuilder(\"\");\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int previousNum = 0;\n        int tmp = 0;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken());\n            if (tmp == 1){\n                ++numberOfStairs;\n                if (previousNum != 0)\n                    result.append(previousNum + \" \");\n            }\n            previousNum = tmp;\n        }\n        result.append(previousNum);\n        System.out.println(numberOfStairs);\n        System.out.println(result);\n    }\n}", "index": 308, "complexity": "1"}
{"back-translation": "class Profit { static int maxProfit(int price[], int n) { int profit[] = new int[n]; for (int i=0; i<n; i++) profit[i] = 0; int max_price = price[n-1]; for (int i=n-2; i>=0; i--) { if (price[i] > max_price) max_price = price[i]; profit[i] = Math.max(profit[i+1], max_price-price[i]); } int min_price = price[0]; for (int i=1; i<n; i++) { if (price[i] < min_price) min_price = price[i]; profit[i] = Math.max(profit[i-1], profit[i] + (price[i]-min_price) ); } int result = profit[n-1]; return result; } public static void main(String args[]) { int price[] = {2, 30, 15, 10, 8, 25, 80}; int n = price.length; System.out.println(", "src": "class\nProfit \n{ \n\n\n\n\n\nstatic\nint\nmaxProfit(\nint\nprice[], \nint\nn) \n\n{ \n\n\n\nint\nprofit[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nprofit[i] = \n0\n; \n\n\n\n\nint\nmax_price = price[n-\n1\n]; \n\nfor\n(\nint\ni=n-\n2\n;i>=\n0\n;i--) \n\n{ \n\n\n\nif\n(price[i] > max_price) \n\nmax_price = price[i]; \n\n\n\n\n\n\n\n\n\n\nprofit[i] = Math.max(profit[i+\n1\n], max_price-price[i]); \n\n} \n\n\n\n\nint\nmin_price = price[\n0\n]; \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\n\n\nif\n(price[i] < min_price) \n\nmin_price = price[i]; \n\n\n\n\n\n\n\n\n\n\nprofit[i] = Math.max(profit[i-\n1\n], profit[i] + \n\n(price[i]-min_price) ); \n\n} \n\nint\nresult = profit[n-\n1\n]; \n\nreturn\nresult; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nprice[] = {\n2\n, \n30\n, \n15\n, \n10\n, \n8\n, \n25\n, \n80\n}; \n\nint\nn = price.length; \n\nSystem.out.println(\n\"Maximum Profit = \"\n+ maxProfit(price, n)); \n\n} \n\n}", "index": 309, "complexity": "1"}
{"back-translation": "public class CodeForce {\n    \n    \n        public static void main(String[] args) {\n            Scanner sc=new Scanner(System.in);\n            String s=sc.next();\n            String t=sc.next();\n            int count=s.length()+t.length();\n            for(int i=0;i<Math.min(s.length(), t.length());i++){\n                if(s.charAt(s.length()-1-i)==t.charAt(t.length()-1-i))count=count-2;\n                else break;\n            }\n            System.out.println(count);\n            \n            \n            \n            \n           \n            \n                \n        }    \n    }", "src": "public class CodeForce {\n    \n    \n        public static void main(String[] args) {\n            Scanner sc=new Scanner(System.in);\n            String s=sc.next();\n            String t=sc.next();\n            int count=s.length()+t.length();\n            for(int i=0;i<Math.min(s.length(), t.length());i++){\n                if(s.charAt(s.length()-1-i)==t.charAt(t.length()-1-i))count=count-2;\n                else break;\n            }\n            System.out.println(count);\n            \n            \n            \n            \n           \n            \n                \n        }    \n    }", "index": 310, "complexity": "1"}
{"back-translation": "public class Codeforces {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = new int[n];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            arr[i] = Integer.parseInt(st.nextToken());\n        }\n        for (int i = 0; i < n; i++) {\n            if (arr[i] % 2 == 0) {\n                arr[i]--;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            pw.print(arr[i] + \" \");\n        }\n        pw.flush();\n        pw.close();\n    }\n}", "src": "public class Codeforces {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = new int[n];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for(int i = 0; i < n; i++){\n            arr[i] = Integer.parseInt(st.nextToken());\n        }\n        for(int i = 0; i < n; i++){\n            if(arr[i] % 2 == 0){\n                arr[i]--;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            pw.print(arr[i] + \" \");\n        }\n        pw.flush();\n        pw.close();\n    }\n}", "index": 311, "complexity": "1"}
{"back-translation": "public class Main { public static void main(String[] args) { InputStream inputStream = System.in; OutputStream outputStream = System.out; FastScanner in = new FastScanner(inputStream); FastPrinter out = new FastPrinter(outputStream); TaskC solver = new TaskC(); solver.solve(1, in, out); out.close(); } static class TaskC { public void solve(int testNumber, FastScanner in, FastPrinter out) { int n = in.nextInt(); long[] a = new long[n]; long[] b = new long[n]; for (int i = 0; i < n; i++) { b[i] = a[i] = in.nextInt(); if (i > 0) { a[i] += a[i - 1]; } } for (int i = n - 2; i >= 0; i--) { b[i] += b[i + 1]; } long sum1 = 0; long sum3 = 0; long result = 0; for (int i = 0, j = n - 1; i < j; ) { sum1 = a[i]; sum3 = b[j]; if (sum1 == sum3) { result = Math.max(result, sum1); i++; j--; } else if (sum1 < sum3) { i++; } else { j--; } } out.println(result); } } static class FastScanner { public BufferedReader br; public StringTokenizer st; public FastScanner(InputStream is) { br = new BufferedReader(new InputStreamReader(is)); } public FastScanner(File f) { try { br = new BufferedReader(new FileReader(f)); } catch (FileNotFoundException e) { e.printStackTrace(); } } public String next() { while (st == null || !st.hasMoreElements()) { String s = null; try { s = br.readLine(); } catch (IOException e) { e.printStackTrace(); } if (s == null) { return null; } st = new StringTokenizer(s); } return st.nextToken(); } public int nextInt() { return Integer.parseInt(next()); } } static class FastPrinter extends PrintWriter { public FastPrinter(OutputStream out) { super(out); } public FastPrinter(Writer out) { super(out); } } }", "src": "public class Main\n{\n    public static void main(String[] args)\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskC\n    {\n        public void solve(int testNumber, FastScanner in, FastPrinter out)\n        {\n            int n = in.nextInt();\n            long[] a = new long[n];\n            long[] b = new long[n];\n            for (int i = 0; i < n; i++)\n            {\n                b[i] = a[i] = in.nextInt();\n                if (i > 0)\n                {\n                    a[i] += a[i - 1];\n                }\n            }\n            for (int i = n - 2; i >= 0; i--)\n            {\n                b[i] += b[i + 1];\n            }\n            \n            long sum1 = 0;\n            long sum3 = 0;\n            long result = 0;\n            for (int i = 0, j = n - 1; i < j; )\n            {\n                sum1 = a[i];\n                sum3 = b[j];\n                if (sum1 == sum3)\n                {\n                    result = Math.max(result, sum1);\n                    i++;\n                    j--;\n                }\n                else if (sum1 < sum3)\n                {\n                    i++;\n                }\n                else\n                {\n                    j--;\n                }\n            }\n            out.println(result);\n            \n            \n        }\n        \n    }\n    \n    static class FastScanner\n    {\n        public BufferedReader br;\n        public StringTokenizer st;\n        \n        public FastScanner(InputStream is)\n        {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n        \n        public FastScanner(File f)\n        {\n            try\n            {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        \n        public String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                String s = null;\n                try\n                {\n                    s = br.readLine();\n                } catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                {\n                    return null;\n                }\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        \n    }\n    \n    static class FastPrinter extends PrintWriter\n    {\n        public FastPrinter(OutputStream out)\n        {\n            super(out);\n        }\n        \n        public FastPrinter(Writer out)\n        {\n            super(out);\n        }\n        \n    }\n}", "index": 312, "complexity": "1"}
{"back-translation": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,ans=0;\n\t\tString sa,sb;\n\t\tchar[] a,b;\n\t\tn=sc.nextInt();\n\t\tsa=sc.next();\n\t\tsb=sc.next();\n\t\ta=sa.toCharArray();\n\t\tb=sb.toCharArray();\n\t\tans=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint[] vis=new int[28];\n\t\t\tvis[a[i]-'a']++;\n\t\t\tvis[b[i]-'a']++;\n\t\t\tvis[a[n-1-i]-'a']++;\n\t\t\tvis[b[n-1-i]-'a']++;\n\t\t\tint num=0,ans1=0,ans2=0;\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\tif(vis[j]!=0) {\n\t\t\t\t\tnum++;\n\t\t\t\t\tif(num==1)\n\t\t\t\t\t\tans1=vis[j];\n\t\t\t\t\telse\n\t\t\t\t\t\tans2=vis[j];\n\t\t\t\t}\n\t\t\tif(num==2) {\n\t\t\t\tif(ans1==1||ans2==1)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==3) {\n\t\t\t\tif(a[i]==a[n-i-1])\n\t\t\t\t\tans+=2;\n\t\t\t\telse\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==4)\n\t\t\t\tans+=2;\n\t\t\ta[i]=b[i];\n\t\t\ta[n-1-i]=b[n-1-i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,ans=0;\n\t\tString sa,sb;\n\t\tchar[] a,b;\n\t\tn=sc.nextInt();\n\t\tsa=sc.next();\n\t\tsb=sc.next();\n\t\ta=sa.toCharArray();\n\t\tb=sb.toCharArray();\n\t\tans=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i==n/2)\n\t\t\t{\n\t\t\t\tif(a[i]!=b[i])\n\t\t\t\t\tans++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] vis=new int[28];\n\t\t\tvis[a[i]-'a']++;\n\t\t\tvis[b[i]-'a']++;\n\t\t\tvis[a[n-1-i]-'a']++;\n\t\t\tvis[b[n-1-i]-'a']++;\n\t\t\tint num=0,ans1=0,ans2=0;\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\tif(vis[j]!=0)\n\t\t\t\t{\n\t\t\t\t\tnum++;\n\t\t\t\t\tif(num==1)\n\t\t\t\t\t\tans1=vis[j];\n\t\t\t\t\telse\n\t\t\t\t\t\tans2=vis[j];\n\t\t\t\t}\n\t\t\tif(num==2)\n\t\t\t{\n\t\t\t\tif(ans1==1||ans2==1)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==3)\n\t\t\t{\n\t\t\t\tif(a[i]==a[n-i-1])\n\t\t\t\t\tans+=2;\n\t\t\t\telse\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==4)\n\t\t\t\tans+=2;\n\t\t\ta[i]=b[i];\n\t\t\ta[n-1-i]=b[n-1-i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 313, "complexity": "1"}
{"back-translation": "class Main{public static void main(String[] args){InputStream inputStream=System.in;OutputStream outputStream=System.out;FastScanner in=new FastScanner(inputStream);PrintWriter out=new PrintWriter(outputStream);EMilitaryProblem solver=new EMilitaryProblem();solver.solve(1,in,out);out.close();}static class EMilitaryProblem{ArrayList<Integer>[] adj;int[] sz;int[] preorder;int curPos;int[] pos;public void solve(int testNumber,FastScanner br,PrintWriter pw){int n=br.nextInt();int q=br.nextInt();preorder=new int[n];sz=new int[n];pos=new int[n];curPos=0;adj=new ArrayList[n];for(int i=0;i<n;i++)adj[i]=new ArrayList<Integer>();for(int i=1;i<n;i++){int u=br.nextInt();u--;adj[u].add(i);}dfs(0);for(int i=0;i<n;i++){pos[preorder[i]]=i;}for(int i=0;i<q;i++){int u=br.nextInt();int k=br.nextInt();u--;if(sz[u]<k){pw.println(\"-1\");}else{pw.println(preorder[pos[u]+k-1]+1);}}pw.close();}public int dfs(int u){preorder[curPos]=u;curPos++;sz[u]++;for(int e : adj[u]){sz[u]+=dfs(e);}return sz[u];}}static class FastScanner{private InputStream stream;private byte[] buf=new byte[1024];private int curChar;private int numChars;private FastScanner.SpaceCharFilter filter;public FastScanner(InputStream stream){this.stream=stream;}public int read(){if(numChars==-1){throw new InputMismatchException();}if(curChar>=numChars){curChar=0;try{numChars=stream.read(buf);}catch(IOException e){throw new InputMismatchException();}if(numChars<=0){return -1;}}return buf[curChar++];}public int nextInt(){int c=read();while(isSpaceChar(c)){c=read();}int sgn=1;if(c=='-'){sgn=-1;c=read();}int res=0;do{if(c<'0'||c>'9'){throw new InputMismatchException();}res*=10;res+=c-'0';c=read();}while(!isSpaceChar(c));return res*sgn;}public boolean isSpaceChar(int c){if(filter!=null){return filter.isSpaceChar(c);}return isWhitespace(c);}public static boolean isWhitespace(int c){return c==' '||c=='\\n'||c=='\\r'||c=='\\t'||c==-1;}public interface SpaceCharFilter{public boolean isSpaceChar(int ch);}}}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EMilitaryProblem solver = new EMilitaryProblem();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EMilitaryProblem {\n        ArrayList<Integer>[] adj;\n        int[] sz;\n        int[] preorder;\n        int curPos;\n        int[] pos;\n\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            int q = br.nextInt();\n            preorder = new int[n];\n            sz = new int[n];\n            pos = new int[n];\n            curPos = 0;\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) adj[i] = new ArrayList<Integer>();\n            for (int i = 1; i < n; i++) {\n                int u = br.nextInt();\n                u--;\n                adj[u].add(i);\n            }\n            dfs(0);\n            for (int i = 0; i < n; i++) {\n                pos[preorder[i]] = i;\n            }\n            for (int i = 0; i < q; i++) {\n                int u = br.nextInt();\n                int k = br.nextInt();\n                u--;\n                if (sz[u] < k) {\n                    pw.println(\"-1\");\n                } else {\n                    pw.println(preorder[pos[u] + k - 1] + 1);\n                }\n            }\n            pw.close();\n        }\n\n        public int dfs(int u) {\n            preorder[curPos] = u;\n            curPos++;\n            sz[u]++;\n            for (int e : adj[u]) {\n                sz[u] += dfs(e);\n            }\n            return sz[u];\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 314, "complexity": "1"}
{"back-translation": "class Test { static int[] arr = new int[] { 3, 7, 90, 20, 10, 50, 40}; static void findMinAvgSubarray(int n, int k) { if (n < k) return; int res_index = 0; int curr_sum = 0; for (int i = 0; i < k; i++) curr_sum += arr[i]; int min_sum = curr_sum; for (int i = k; i < n; i++) { curr_sum += arr[i] - arr[i - k]; if (curr_sum < min_sum) { min_sum = curr_sum; res_index = (i - k + 1); } } System.out.println(\"Subarray between [\" + res_index + \", \" + (res_index + k - 1) + \"] has minimum average\"); } public static void main(String[] args) { int k = 3; findMinAvgSubarray(arr.length, k); } }", "src": "class\nTest { \n\n\nstatic\nint\narr[] = \nnew\nint\n[] { \n3\n, \n7\n, \n90\n, \n20\n, \n10\n, \n50\n, \n40\n}; \n\n\n\n\n\n\nstatic\nvoid\nfindMinAvgSubarray(\nint\nn, \nint\nk) \n\n{ \n\n\n\nif\n(n < k) \n\nreturn\n; \n\n\n\n\nint\nres_index = \n0\n; \n\n\n\n\nint\ncurr_sum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\ncurr_sum += arr[i]; \n\n\n\n\nint\nmin_sum = curr_sum; \n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\n\n\n\n\ncurr_sum += arr[i] - arr[i - k]; \n\n\n\n\nif\n(curr_sum < min_sum) { \n\nmin_sum = curr_sum; \n\nres_index = (i - k + \n1\n); \n\n} \n\n} \n\n\nSystem.out.println(\n\"Subarray between [\"\n+ \n\nres_index + \n\", \"\n+ (res_index + k - \n1\n) + \n\n\"] has minimum average\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nk = \n3\n; \n\n\nfindMinAvgSubarray(arr.length, k); \n\n} \n}", "index": 315, "complexity": "1"}
{"back-translation": "public class helloWorld {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        String str = in.next();\n        boolean[] exist = new boolean[200];\n        int[][] dn = new int[200][m + 1];\n\n        for (int i = 0; i < n; i++) {\n            int a = str.charAt(i);\n            exist[a] = true;\n            dn[a][1] = a - 'a' + 1;\n        }\n\n        for (int k = 2; k <= m; k++)\n            for (int i = 'a'; i <= 'z'; i++)\n                if (exist[i]) {\n                    int a = 0;\n                    for (int j = i + 2; j <= 'z'; j++)\n                        if (dn[j][k - 1] > 0 && (a == 0 || (a > dn[j][k - 1])))\n                            a = dn[j][k - 1];\n                    if (a > 0)\n                        dn[i][k] = a + i - 'a' + 1;\n                }\n\n        int ans = -1;\n        for (int i = 'a'; i <= 'z'; i++)\n            if (dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]))\n                ans = dn[i][m];\n\n        System.out.println(ans);\n\n        in.close();\n    }\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 316, "complexity": "1"}
{"back-translation": "class MinimumDistance {\n\n    int minDist(int arr[], int n, int x, int y) {\n\n        int i = 0;\n        int min_dist = Integer.MAX_VALUE;\n        int prev=0;\n\n        for(i = 0; i < n; i++) {\n            if(arr[i] == x || arr[i] == y) {\n                prev = i;\n                break;\n            }\n        }\n\n        for(; i < n; i++) {\n            if(arr[i] == x || arr[i] == y) {\n                if(arr[prev] != arr[i] && (i - prev) < min_dist) {\n                    min_dist = i - prev;\n                    prev = i;\n                }\n                else\n                    prev = i;\n            }\n        }\n\n        return min_dist;\n    }\n\n    public static void main(String[] args) {\n        MinimumDistance min = new MinimumDistance();\n        int arr[] = {3, 5, 4, 2, 6, 3, 0, 0, 5, 4, 8, 3};\n        int n = arr.length;\n        int x = 3;\n        int y = 6;\n\n        System.out.println(\"Minimum distance between \" + x + \" and \" + y + \" is \" + min.minDist(arr, n, x, y));\n    }\n}", "src": "class\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni = \n0\n; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nint\nprev=\n0\n; \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\nprev = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nfor\n(; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\n\n\n\n\n\n\n\n\nif\n(arr[prev] != arr[i] && (i - prev) < min_dist) \n\n{ \n\nmin_dist = i - prev; \n\nprev = i; \n\n} \n\nelse\n\nprev = i; \n\n} \n\n} \n\n\nreturn\nmin_dist; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n3\n, \n0\n, \n0\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n}", "index": 317, "complexity": "1"}
{"back-translation": "public class Solution {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt += in.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt -= in.nextInt();\n\t\t}\n\t\tif (cnt < 0) {\n\t\t\tans = \"No\";\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tin.close();\n\t}\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}", "index": 318, "complexity": "1"}
{"back-translation": "public class Piles {\n    static int summation(int arr[]) {\n        int k, sum=0;\n        for(k=0;k<arr.length;k++) {\n            sum = sum + arr[k];\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        if(n>=1 && n<=50) {\n            int x[] = new int[n];\n            int y[] = new int[n];\n\n            for(int i=0;i<n;i++) {\n                x[i] = sc.nextInt();\n            }\n            for(int j=0;j<n;j++) {\n                y[j] = sc.nextInt();\n            }\n            int xsum = summation(x);\n            int ysum = summation(y);\n            if(xsum>=ysum) {\n                System.out.println(\"Yes\");\n            }\n            else {\n                System.out.println(\"No\");\n            }\n        }\n    }\n}", "src": "public class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tfor(k=0;k<arr.length;k++) {\n\t\t\tsum = sum + arr[k];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n}", "index": 319, "complexity": "1"}
{"back-translation": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tint i=0;\n\t\twhile(i<n)\n\t\t{\n\t\t\ts1+=input.nextInt();\n\t\t\ti++;\n\t\t}\n\t\ti=0;\n\t\twhile(i<n)\n\t\t{\n\t\t\ts2+=input.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "src": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts1+=input.nextInt();\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts2+=input.nextInt();\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "index": 320, "complexity": "1"}
{"back-translation": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2];\n\t\tint x = scan.nextInt();\n\t\tint i = 0;\n\t\twhile (i < 2) {\n\t\t\tint j = 0;\n\t\t\tint sum = 0;\n\t\t\twhile (j < x) {\n\t\t\t\tsum += scan.nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ta[i] = sum;\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\t}\n\n}", "src": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}", "index": 321, "complexity": "1"}
{"back-translation": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(set1.contains(a[i])){\n                            System.out.println(0);\n                            return;\n                     }else{\n                            set1.add(a[i]);\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && !set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     \n                            \n                     \n                       \n                         \n                     \n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     \n                            \n                     \n                       \n                         \n                     \n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "index": 322, "complexity": "1"}
{"back-translation": "public class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n || ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n || ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n || ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            \n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ \n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       \n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        \n    }\n}", "src": "public class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            \n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ \n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       \n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        \n    }\n}", "index": 323, "complexity": "1"}
{"back-translation": "public class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader in = new FastReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong n = in.nextLong();\n\t\tlong k = in.nextLong();\n\t\tlong s = in.nextLong();\n\t\tif (k > s || k * (n - 1) < s) {\n\t\t\tout.println(\"NO\");\n\t\t} else {\n\t\t\tout.println(\"YES\");\n\t\t\tlong cur = 1;\n\t\t\twhile (k > 0) {\n\t\t\t\tlong x = Math.min(n - 1, s - k + 1);\n\t\t\t\tif (cur - x > 0) {\n\t\t\t\t\tcur = cur - x;\n\t\t\t\t} else {\n\t\t\t\t\tcur = cur + x;\n\t\t\t\t}\n\t\t\t\tout.print(cur + \" \");\n\t\t\t\ts -= x;\n\t\t\t\tk--;\n\t\t\t}\n\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class FastReader {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic FastReader(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic FastReader(FileReader fileReader) {\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader in = new FastReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong n = in.nextLong();\n\t\tlong k = in.nextLong();\n\t\tlong s = in.nextLong();\n\t\tif (k > s || k * (n - 1) < s) {\n\t\t\tout.println(\"NO\");\n\t\t} else {\n\t\t\tout.println(\"YES\");\n\t\t\tlong cur = 1;\n\t\t\twhile (k > 0) {\n\t\t\t\tlong x = Math.min(n - 1, s - k + 1);\n\t\t\t\tcur = ( cur - x > 0 ? cur  - x : cur + x);\n\t\t\t\tout.print(cur + \" \");\n\t\t\t\ts -= x;\n\t\t\t\tk--;\n\t\t\t}\n\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class FastReader {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic FastReader(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic FastReader(FileReader fileReader) {\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n}", "index": 324, "complexity": "1"}
{"back-translation": "public class DeathNote {\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n    public static StringTokenizer st;\n    \n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        int[] a = intArray(n);\n        \n        StringBuilder sb = new StringBuilder();\n        int x = 0;\n        for (int i = 0; i < n; i++) {\n            x += a[i];\n            sb.append(\" \" + (x/m));\n            x %= m;\n        }\n        \n        System.out.println(sb.toString().substring(1));\n    }\n    \n    public static String nextLine() throws IOException {\n        return in.readLine();\n    }\n\n    public static String nextString() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(in.readLine());\n        return st.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(nextString());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(nextString());\n    }\n\n    public static int[] intArray(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextInt();\n        return a;\n    }\n\n    public static int[][] intArray(int n, int m) throws IOException {\n        int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                a[i][j] = nextInt();\n        return a;\n    }\n\n    public static long[] longArray(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextLong();\n        return a;\n    }\n}", "src": "public class DeathNote {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\tint x = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx += a[i];\n\t\t\tsb.append(\" \" + (x/m));\n\t\t\tx %= m;\n\t\t}\n\t\t\n\t\tSystem.out.println(sb.toString().substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 325, "complexity": "1"}
{"back-translation": "public class Main {\n\n    static String S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        S = sc.next();\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        int ans = -1;\n        int time = 1;\n        int n = S.length();\n        for (int i = 1; i < n * 2; i++) {\n            if (S.charAt((i - 1) % n) != S.charAt(i % n)) {\n                time++;\n            } else {\n                ans = Math.max(time, ans);\n                time = 1;\n            }\n        }\n        ans = Math.max(time, ans);\n\n        if (ans == n * 2) {\n            return n;\n        } else {\n            return ans;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}", "src": "public class Main {\n\n    static String S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        S = sc.next();\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        int ans = -1;\n        int time = 1;\n        int n = S.length();\n        for (int i = 1; i < n*2; i++) {\n            if( S.charAt((i-1)%n) != S.charAt(i%n) ) {\n                time++;\n            } else {\n                ans = Math.max(time, ans);\n                time = 1;\n            }\n        }\n        ans = Math.max(time, ans);\n\n        if( ans == n*2 ) {\n            return n;\n        } else {\n            return ans;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}", "index": 326, "complexity": "1"}
{"back-translation": "public class Cheast {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] l = new int[n];\n        l[0] = sc.nextInt();\n        int x = 1;\n        int c = 1;\n        for (int i = 1; i < n; i++) {\n            l[i] = sc.nextInt();\n            if (l[i] <= l[i - 1] * 2) {\n                c++;\n                x = Math.max(x, c);\n            } else {\n                c = 1;\n            }\n        }\n        System.out.println(x);\n    }\n}", "src": "public class Cheast {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] l = new int[n];\n        l[0] = sc.nextInt();\n        int x=1;\n        int c=1;\n        for (int i=1;i<n;i++) {\n            l[i] = sc.nextInt();\n            if (l[i] <= l[i-1]*2) {\n                c++;\n                x = Math.max(x,c);\n            }\n            else\n                c = 1;\n        }\n        System.out.println(x);\n\n\n\n    }\n}", "index": 327, "complexity": "1"}
{"back-translation": "class vasyaarray {\npublic static void main(String[] args) throws IOException {\nFastReader in = new FastReader(System.in);\nint n = in.nextInt();\nlong[] arr1 = new long[n];\nlong[] pre1 = new long[n];\nint i, j;\narr1[0] = in.nextLong();\npre1[0] = arr1[0];\nfor (i = 1; i < n; i++) {\narr1[i] = in.nextLong();\npre1[i] = pre1[i - 1] + arr1[i];\n}\nint m = in.nextInt();\nlong[] arr2 = new long[m];\nlong[] pre2 = new long[m];\narr2[0] = in.nextInt();\npre2[0] = arr2[0];\nfor (i = 1; i < m; i++) {\narr2[i] = in.nextInt();\npre2[i] = pre2[i - 1] + arr2[i];\n}\nif (pre1[n - 1] != pre2[m - 1])\nSystem.out.println(\"-1\");\nelse {\nlong s1 = 0, s2 = 0;\ni = j = 0;\nint k = 0;\nwhile (true) {\nif (s1 == s2) {\nif (s1 == 0) {\ns1 = arr1[i++];\ns2 = arr2[j++];\n}\nelse {\nk++;\ns1 = s2 = 0;\nif (i == n && j == m)\nbreak;\n}\n}\nelse if (s1 > s2) {\ns2 += arr2[j++];\n}\nelse {\ns1 += arr1[i++];\n}\n}\nSystem.out.println(k);\n}\n}\n}\nclass FastReader {\nbyte[] buf = new byte[2048];\nint index, total;\nInputStream in;\n\nFastReader(InputStream is) {\nin = is;\n}\n\nint scan() throws IOException {\nif (index >= total) {\nindex = 0;\ntotal = in.read(buf);\nif (total <= 0) {\nreturn -1;\n}\n}\nreturn buf[index++];\n}\n\nString next() throws IOException {\nint c;\nfor (c = scan(); c <= 32; c = scan()) ;\nStringBuilder sb = new StringBuilder();\nfor (; c > 32; c = scan()) {\nsb.append((char) c);\n}\nreturn sb.toString();\n}\n\nString nextLine() throws IOException {\nint c;\nfor (c = scan(); c <= 32; c = scan()) ;\nStringBuilder sb = new StringBuilder();\nfor (; c != 10; c = scan()) {\nsb.append((char) c);\n}\nreturn sb.toString();\n}\n\nchar nextChar() throws IOException {\nint c;\nfor (c = scan(); c <= 32; c = scan()) ;\nreturn (char) c;\n}\n\nint nextInt() throws IOException {\nint c, val = 0;\nfor (c = scan(); c <= 32; c = scan()) ;\nboolean neg = c == '-';\nif (c == '-' || c == '+') {\nc = scan();\n}\nfor (; c >= '0' && c <= '9'; c = scan()) {\nval = (val << 3) + (val << 1) + (c & 15);\n}\nreturn neg ? -val : val;\n}\n\nlong nextLong() throws IOException {\nint c;\nlong val = 0;\nfor (c = scan(); c <= 32; c = scan()) ;\nboolean neg = c == '-';\nif (c == '-' || c == '+') {\nc = scan();\n}\nfor (; c >= '0' && c <= '9'; c = scan()) {\nval = (val << 3) + (val << 1) + (c & 15);\n}\nreturn neg ? -val : val;\n}\n}", "src": "public class vasyaarray{\npublic static void main(String[] args)throws IOException {\n    FastReader in=new FastReader(System.in);\n        int n=in.nextInt();\n        long arr1[]=new long[n];\n        long pre1[]=new long[n];\n        int i,j;\n        arr1[0]=in.nextLong();\n        pre1[0]=arr1[0];\n        for(i=1;i<n;i++)\n        {\n            arr1[i]=in.nextLong();\n            pre1[i]=pre1[i-1]+arr1[i];\n        }\n        int m=in.nextInt();\n        long arr2[]=new long[m];\n        long pre2[]=new long[m];\n        arr2[0]=in.nextInt();\n        pre2[0]=arr2[0];\n        for(i=1;i<m;i++)\n        {\n            arr2[i]=in.nextInt();\n            pre2[i]=pre2[i-1]+arr2[i];\n        }\n        \n         \n        if(pre1[n-1]!=pre2[m-1])\n        System.out.println(\"-1\");\n        else\n        {\n            long s1=0,s2=0;\n            i=j=0;\n            int k=0;\n            while(true)\n            {\n                if(s1==s2)\n                {\n                    if(s1==0)\n                    {\n                        s1=arr1[i++];\n                        s2=arr2[j++];\n                        \n                    }\n                    else\n                    {\n                        k++;\n                        s1=s2=0;\n                        \n                        if(i==n && j==m)\n                        break;\n                    }\n                }\n                else if(s1>s2)\n                {\n                    s2+=arr2[j++];\n                    \n                }\n                else\n                {\n                    s1+=arr1[i++];\n                    \n                }\n            }\n            System.out.println(k);\n        }\n    }\n}\nclass FastReader {\n \n    byte[] buf = new byte[2048];\n    int index, total;\n    InputStream in;\n \n    FastReader(InputStream is) {\n        in = is;\n    }\n \n    int scan() throws IOException {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) {\n                return -1;\n            }\n        }\n        return buf[index++];\n    }\n \n    String next() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    String nextLine() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c !=10; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    char nextChar() throws IOException{\n        int c;\n         for (c = scan(); c <= 32; c = scan());\n         return (char)c;\n        }\n \n    int nextInt() throws IOException {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n \n    long nextLong() throws IOException {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n}", "index": 328, "complexity": "1"}
{"back-translation": "public class HelloWorldBackTranslation {\n    static ArrayList<Integer> ar;\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        StringBuilder ans = new StringBuilder();\n        if (n <= 2)\n            ans.append(\"No\");\n        else if (n == 4) { \n            ans.append(\"Yes\\n\"); \n            ans.append(\"1 2\\n\"); \n            ans.append(\"3 1 3 4\\n\");\n        } else {\n            ans.append(\"Yes\\n\");\n            if (n % 2 == 1) {\n                int a = (n + 1) / 2;\n                ans.append(\"1 \");\n                ans.append(a); \n                ans.append(\"\\n\");\n                ans.append(n - 1); \n                for (int i = 1; i < a; i++)\n                    ans.append(\" \" + i); \n                for (int i = a + 1; i <= n; i++)\n                    ans.append(\" \" + i); \n            } else {\n                int a = n / 2;\n                ans.append(\"2 \");\n                ans.append(a + \" \");\n                ans.append(a + 1 + \" \\n\");\n                ans.append(n - 2);\n                for (int i = 1; i < a; i++)\n                    ans.append(\" \" + i); \n                for (int i = a + 2; i <= n; i++)\n                    ans.append(\" \" + i); \n            }\n        } \n        System.out.println(ans); \n        in.close(); \n    } \n}", "src": "public class helloWorld \n{\n\tstatic ArrayList<Integer> ar;\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tStringBuilder ans = new StringBuilder();\n\t\tif(n <= 2)\n\t\t\tans.append(\"No\");\n\t\telse if(n == 4) {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tans.append(\"1 2\\n\");\n\t\t\tans.append(\"3 1 3 4\\n\");\n\t\t}\n\t\telse  {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tif(n % 2 == 1) {\n\t\t\t\tint a = (n+1)/2;\n\t\t\t\tans.append(\"1 \");\n\t\t\t\tans.append(a);\n\t\t\t\tans.append(\"\\n\");\n\t\t\t\tans.append(n-1);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+1; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a = n/2;\n\t\t\t\tans.append(\"2 \");\n\t\t\t\tans.append(a + \" \");\n\t\t\t\tans.append(a+1 + \" \\n\");\n\t\t\t\tans.append(n-2);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+2; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 329, "complexity": "1"}
{"back-translation": "class SmallestSubArraySum { static int smallestSubWithSum(int arr[], int n, int x) { int curr_sum = 0, min_len = n + 1; int start = 0, end = 0; while (end < n) { while (curr_sum <= x && end < n) curr_sum += arr[end++]; while (curr_sum > x && start < n) { if (end - start < min_len) min_len = end - start; curr_sum -= arr[start++]; } } return min_len; } public static void main(String[] args) { int arr1[] = { 1, 4, 45, 6, 10, 19 }; int x = 51; int n1 = arr1.length; int res1 = smallestSubWithSum(arr1, n1, x); if (res1 == n1 + 1) System.out.println(\"Not Possible\"); else System.out.println(res1); int arr2[] = { 1, 10, 5, 2, 7 }; int n2 = arr2.length; x = 9; int res2 = smallestSubWithSum(arr2, n2, x); if (res2 == n2 + 1) System.out.println(\"Not Possible\"); else System.out.println(res2); int arr3[] = { 1, 11, 100, 1, 0, 200, 3, 2, 1, 250 }; int n3 = arr3.length; x = 280; int res3 = smallestSubWithSum(arr3, n3, x); if (res3 == n3 + 1) System.out.println(\"Not Possible\"); else System.out.println(res3); } }", "src": "class\nSmallestSubArraySum \n{ \n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n\n\nint\nstart = \n0\n, end = \n0\n; \n\nwhile\n(end < n) \n\n{ \n\n\n\n\n\nwhile\n(curr_sum <= x && end < n) \n\ncurr_sum += arr[end++]; \n\n\n\n\nwhile\n(curr_sum > x && start < n) \n\n{ \n\n\n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n\n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n}", "index": 330, "complexity": "1"}
{"back-translation": "public class A {\n   public static void main(String args[]) throws Exception {\n      BufferedReader infile = new BufferedReader(new InputStreamReader(System.in)); \n      StringTokenizer st = new StringTokenizer(infile.readLine());\n      int N = Integer.parseInt(st.nextToken());\n      int L = Integer.parseInt(st.nextToken());\n      int A = Integer.parseInt(st.nextToken());\n      int[] arr1 = new int[N];\n      int[] arr2 = new int[N];\n      for (int i = 0; i < N; i++) {\n         st = new StringTokenizer(infile.readLine());\n         int x = Integer.parseInt(st.nextToken());\n         int y = Integer.parseInt(st.nextToken()) + x;\n         arr1[i] = x;\n         arr2[i] = y;\n      }\n      int res = 0;\n      for (int i = 1; i < N; i++)\n         res += (arr1[i] - arr2[i - 1]) / A;\n      if (N > 0)\n         res += (L - arr2[N - 1]) / A + arr1[0] / A;\n      else\n         res += L / A;\n      System.out.println(res);\n   }\n}", "src": "public class A\n   {\n      public static void main(String args[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in)); \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int L = Integer.parseInt(st.nextToken());\n         int A = Integer.parseInt(st.nextToken());\n         int[] arr1 = new int[N];\n         int[] arr2 = new int[N];\n         for(int i=0; i < N; i++)\n         {\n            st = new StringTokenizer(infile.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken())+x;\n            arr1[i] = x;\n            arr2[i] = y;\n         }\n         int res = 0;\n         for(int i=1; i < N; i++)\n            res += (arr1[i]-arr2[i-1])/A;\n         if(N > 0)\n            res += (L-arr2[N-1])/A+arr1[0]/A;\n         else\n            res += L/A;\n         System.out.println(res);\n      }\n   }", "index": 331, "complexity": "1"}
{"back-translation": "public class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tint n = input.nextInt();\n\t\tString s = input.next();\n\t\tboolean done = false;\n\t\tfor (int i = 0; i < s.length() - 1; i++)\n\t\t{\n\t\t\tif (s.charAt(i) != s.charAt(i + 1))\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tSystem.out.println(s.charAt(i) + \"\" + s.charAt(i + 1));\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!done)\n\t\t{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}", "src": "public class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tint n = input.nextInt();\n\t\tString s = input.next();\n\t\tboolean done = false;\n\t\tfor (int i = 0; i < s.length() - 1; i++)\n\t\t{\n\t\t\tif (s.charAt(i) != s.charAt(i + 1))\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tSystem.out.println(s.charAt(i) + \"\" + s.charAt(i + 1));\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!done)\n\t\t{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}", "index": 332, "complexity": "1"}
{"back-translation": "class GFG { static int findMaxAverage(int[] arr, int n, int k) { if(k > n) return -1; int[] csum = new int[n]; csum[0] = arr[0]; for(int i = 1; i < n; i++) csum[i] = csum[i - 1] + arr[i]; int max_sum = csum[k - 1], max_end = k - 1; for(int i = k; i < n; i++) { int curr_sum = csum[i] - csum[i - k]; if(curr_sum > max_sum) { max_sum = curr_sum; max_end = i; } } return max_end - k + 1; } static public void main(String[] args) { int[] arr = {1, 12, -5, -6, 50, 3}; int k = 4; int n = arr.length; System.out.println(\"The maximum \"+ \"average subarray of length \"+ k + \" begins at index \"+ findMaxAverage(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxAverage(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\n\n\n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n\n\n\n\n\n\n\n\nint\n[]csum = \nnew\nint\n[n]; \n\n\ncsum[\n0\n] = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\ncsum[i] = csum[i - \n1\n] + arr[i]; \n\n\n\n\n\n\nint\nmax_sum = csum[k - \n1\n], \n\nmax_end = k - \n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nint\ncurr_sum = csum[i] - \n\ncsum[i - k]; \n\nif\n(curr_sum > max_sum) \n\n{ \n\nmax_sum = curr_sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]arr = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"The maximum \"\n\n+ \n\"average subarray of length \"\n\n+ k + \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n}", "index": 333, "complexity": "1"}
{"back-translation": "class GFG { static int findMaxAverage(int arr[], int n, int k) { if (k > n) return -1; int sum = arr[0]; for (int i = 1; i < k; i++) sum += arr[i]; int max_sum = sum, max_end = k-1; for (int i = k; i < n; i++) { sum = sum + arr[i] - arr[i-k]; if (sum > max_sum) { max_sum = sum; max_end = i; } } return max_end - k + 1; } public static void main (String[] args) { int arr[] = {1, 12, -5, -6, 50, 3}; int k = 4; int n = arr.length; System.out.println(\"The maximum average\" + \" subarray of length \"+ k + \" begins at index \"+ findMaxAverage(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMaxAverage(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n\n\nint\nsum = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < k; i++) \n\nsum += arr[i]; \n\n\nint\nmax_sum = sum, max_end = k-\n1\n; \n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nsum = sum + arr[i] - arr[i-k]; \n\nif\n(sum > max_sum) \n\n{ \n\nmax_sum = sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n\n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.println( \n\"The maximum average\"\n\n+ \n\" subarray of length \"\n+ k \n\n+ \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n}", "index": 334, "complexity": "1"}
{"back-translation": "public class Ehab3 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        System.out.println((n + 1));\n        int c = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            int cd = n + i - ((a[i] + c) % n);\n            System.out.println(\"1 \" + (i + 1) + \" \" + cd);\n            c += cd;\n        }\n        System.out.println(\"2 \" + n + \" \" + n);\n    }\n}", "src": "public class ehab3 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint n = in.nextInt();\n\tint[] a = new int[n];\n\tfor ( int i = 0; i < n; i++ )\n\t    a[i] = in.nextInt();\n\tSystem.out.println( ( n + 1 ) );\n\tint c = 0;\n\tfor ( int i = n - 1; i >= 0; i-- ) {\n\t    int cd = n + i - ( ( a[i] + c ) % n );\n\t    System.out.println( \"1 \" + ( i + 1 ) + \" \" + cd );\n\t    c += cd;\n\t}\n\tSystem.out.println( \"2 \" + n + \" \" + n );\n    }\n}", "index": 335, "complexity": "1"}
{"back-translation": "public class Main {public static void main(String[] args) {Scanner sc=new Scanner(System.in);int num=sc.nextInt();long sum1=0;long sum2=0;for(int i=0;i<num*2;i++){sum1+=sc.nextInt();sum2+=sc.nextInt();}System.out.println(sum1/num+\" \"+sum2/num);}}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint num=sc.nextInt();\n\t\tlong sum1=0,sum2=0;\n\t\tfor(int i=0;i<num*2;i++){\n\t\t\tsum1+=sc.nextInt();\n\t\t\tsum2+=sc.nextInt();\n\t\t}\n\t\tSystem.out.println(sum1/num+\" \"+sum2/num);\n\t}\n}", "index": 336, "complexity": "1"}
{"back-translation": "public class UniformString {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = nextInt();\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint n = nextInt();\n\t\t\tint k = nextInt();\n\t\t\tString s = \"\";\n\t\t\tfor (int j = 0; j < n; j++) \n\t\t\t\ts += (char)('a' + (j%k)); \n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}\n", "src": "public class UniformString {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = nextInt();\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint n = nextInt();\n\t\t\tint k = nextInt();\n\t\t\tString s = \"\";\n\t\t\tfor (int j = 0; j < n; j++) \n\t\t\t\ts += (char)('a' + (j%k)); \n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 337, "complexity": "1"}
{"back-translation": "class arr_rot {\n\n    static void leftRotate(int arr[], int n, int k) {\n        int mod = k % n;\n\n        for (int i = 0; i < n; ++i) {\n            System.out.print(arr[(i + mod) % n] + \" \");\n        }\n\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {1, 3, 5, 7, 9};\n        int n = arr.length;\n\n        int k = 2;\n        leftRotate(arr, n, k);\n\n        k = 3;\n        leftRotate(arr, n, k);\n\n        k = 4;\n        leftRotate(arr, n, k);\n    }\n}", "src": "class\narr_rot \n{ \n\n\n\n\n\nstatic\nvoid\nleftRotate(\nint\narr[], \nint\nn, \n\nint\nk) \n\n{ \n\n\n\nint\nmod = k % n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[(i + mod) % n] \n\n+ \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n5\n, \n7\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nint\nk = \n2\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n3\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n4\n; \n\nleftRotate(arr, n, k); \n\n} \n}", "index": 338, "complexity": "1"}
{"back-translation": "class GFG {\n\nstatic int findMinOps(int[] arr, int n) {\nint ans = 0;\nfor (int i = 0, j = n - 1; i <= j;) {\nif (arr[i] == arr[j]) {\ni++;\nj--;\n} else if (arr[i] > arr[j]) {\nj--;\narr[j] += arr[j+1];\nans++;\n} else {\ni++;\narr[i] += arr[i-1];\nans++;\n}\n}\nreturn ans;\n}\n\npublic static void main(String[] args) {\nint arr[] = new int[]{1, 4, 5, 9, 1};\nSystem.out.println(\"Count of minimum operations is \" + findMinOps(arr, arr.length));\n}\n}", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nfindMinOps(\nint\n[] arr, \nint\nn) \n\n{ \n\nint\nans = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni=\n0\n,j=n-\n1\n; i<=j;) \n\n{ \n\n\n\n\n\nif\n(arr[i] == arr[j]) \n\n{ \n\ni++; \n\nj--; \n\n} \n\n\n\n\n\n\nelse\nif\n(arr[i] > arr[j]) \n\n{ \n\n\n\nj--; \n\narr[j] += arr[j+\n1\n] ; \n\nans++; \n\n} \n\n\n\n\nelse\n\n{ \n\ni++; \n\narr[i] += arr[i-\n1\n]; \n\nans++; \n\n} \n\n} \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n4\n, \n5\n, \n9\n, \n1\n} ; \n\nSystem.out.println(\n\"Count of minimum operations is \"\n+ \n\nfindMinOps(arr, arr.length)); \n\n\n} \n}", "index": 339, "complexity": "1"}
{"back-translation": "public class GennadyAndACardGame {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tString line =null;\n\t\tString[] n={};\n\t\tString s=\"NO\";\n\t\tString input = null;\n\t\twhile((line=bufr.readLine())!=null)    {\n\t\t\tif(\"over\".equals(line))\n\t\t\t\tbreak;\n\t\t\tinput = bufr.readLine();\n\t\t\tn=input.split(\" \");\n\t\t\tfor(int i=0;i<n.length;i++){\n\t\t\t\tif(n[i].contains(line.substring(0,1)) || n[i].contains(line.substring(1))){\n\t\t\t\t\ts=\"YES\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(s);\n\t\t\ts=\"NO\";\n\t\t\tbufw.flush();\n\t\t}\n\t\tbufw.close();\n\t}\n}", "src": "public class GennadyAndACardGame {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tString line =null;\n\t\tString[] n={};\n\t\tString s=\"NO\";\n\t\twhile((line=bufr.readLine())!=null)    {\n\t\t\tif(\"over\".equals(line))\n\t\t\t\tbreak;\n\t\t\tn=bufr.readLine().split(\" \");\n\t\t\tfor(int i=0;i<n.length;i++){\n\t\t\t\tif(n[i].contains(line.substring(0,1)) || n[i].contains(line.substring(1))){\n\t\t\t\t\ts=\"YES\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(s);\n\t\t\ts=\"NO\";\n\t\t\tbufw.flush();\n\t\t}\n\t\tbufw.close();                          \n\t}\n}", "index": 340, "complexity": "1"}
{"back-translation": "class FindSmallestInteger {\n    int findSmallest(int[] arr, int n) {\n        int res = 1;\n        for (int i = 0; i < n && arr[i] <= res; i++)\n            res = res + arr[i];\n        return res;\n    }\n\n    public static void main(String[] args) {\n        FindSmallestInteger small = new FindSmallestInteger();\n        int[] arr1 = {1, 3, 4, 5};\n        int n1 = arr1.length;\n        System.out.println(small.findSmallest(arr1, n1));\n\n        int[] arr2 = {1, 2, 6, 10, 11, 15};\n        int n2 = arr2.length;\n        System.out.println(small.findSmallest(arr2, n2));\n\n        int[] arr3 = {1, 1, 1, 1};\n        int n3 = arr3.length;\n        System.out.println(small.findSmallest(arr3, n3));\n\n        int[] arr4 = {1, 1, 3, 4};\n        int n4 = arr4.length;\n        System.out.println(small.findSmallest(arr4, n4));\n    }\n}", "src": "class\nFindSmallestInteger \n{ \n\n\n\n\n\nint\nfindSmallest(\nint\narr[], \nint\nn) \n\n{ \n\nint\nres = \n1\n; \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n && arr[i] <= res; i++) \n\nres = res + arr[i]; \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nFindSmallestInteger small = \nnew\nFindSmallestInteger(); \n\nint\narr1[] = {\n1\n, \n3\n, \n4\n, \n5\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(small.findSmallest(arr1, n1)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n6\n, \n10\n, \n11\n, \n15\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(small.findSmallest(arr2, n2)); \n\n\nint\narr3[] = {\n1\n, \n1\n, \n1\n, \n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(small.findSmallest(arr3, n3)); \n\n\nint\narr4[] = {\n1\n, \n1\n, \n3\n, \n4\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(small.findSmallest(arr4, n4)); \n\n\n} \n}", "index": 341, "complexity": "1"}
{"back-translation": "public class CodeForces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint d = in.nextInt(), sum = in.nextInt();\n\t\tList<Data> data = new ArrayList<>();\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\tint min = in.nextInt(), max = in.nextInt();\n\t\t\tint centre = (min + max) / 2;\n\t\t\tdata.add(new Data(centre - min, max - centre, centre));\n\t\t\tsum -= centre;\n\t\t}\n\t\tIterator<Data> it = data.iterator();\n\t\twhile (sum != 0) {\n\t\t\tif(!it.hasNext()) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tData da = it.next();\n\t\t\tif (sum > 0) {\n\t\t\t\tda.centre += da.above;\n\t\t\t\tsum -= da.above;\n\t\t\t} else {\n\t\t\t\tda.centre -= da.below;\n\t\t\t\tsum += da.below;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t\tfor (Data da : data) {\n\t\t\tSystem.out.print(da.centre + \" \");\n\t\t}\n\t}\n}\nclass Data {\n\tint below, above, centre;\n\t\n\tData(int below, int above, int centre) {\n\t\tthis.below = below;\n\t\tthis.above = above;\n\t\tthis.centre = centre;\n\t}\n}", "src": "public class CodeForces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint d = in.nextInt(), sum = in.nextInt();\n\t\tList<Data> data = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < d; ++i) {\n\t\t\tint min = in.nextInt(), max = in.nextInt();\n\t\t\tint centre = (min + max) / 2;\n\t\t\tdata.add(new Data(centre - min, max - centre, centre));\n\t\t\tsum -= centre;\n\t\t}\n\t\t\n\t\tIterator<Data> it = data.iterator();\n\t\t\n\t\twhile (sum != 0) {\n\t\t\tif (!it.hasNext()) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tData da = it.next();\n\n\t\t\tif (sum > 0) {\n\t\t\t\tda.centre += da.above;\n\t\t\t\tsum -= da.above;\n\t\t\t} else {\n\t\t\t\tda.centre -= da.below;\n\t\t\t\tsum += da.below;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n\t\t\n\t\tfor (Data da : data) {\n\t\t\tSystem.out.print(da.centre + \" \");\n\t\t}\n\t}\n}\n\nclass Data {\n\tint below, above, centre;\n\t\n\tData(int below, int above, int centre) {\n\t\tthis.below = below;\n\t\tthis.above = above;\n\t\tthis.centre = centre;\n\t}\n}", "index": 342, "complexity": "1"}
{"back-translation": "public class Main {\n    \n    static Scanner in = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int n = in.nextInt(), l[] = new int[n], p = -1000000, d_min = 1000000, min = 1000000000;\n        for (int i = 0; i < n; i++) {\n            l[i] = in.nextInt();\n            min = Math.min(min, l[i]);\n        }\n        int p = -1;\n        int d_min = 1000000;\n        int min = 1000000000;\n        for (int i = 0; i < n; i++) {\n            if (l[i] == min) {\n                d_min = Math.min(d_min, i - p);\n                p = i;\n            }\n        }\n        out.println(d_min);\n        out.close();\n    }\n    \n    static class Scanner {\n        Scanner() {\n        }\n        int nextInt() {\n            return in.nextInt();\n        }\n    }\n    \n    static class PrintWriter {\n        PrintWriter() {\n        }\n        void println(int num) {\n            System.out.println(num);\n        }\n        void close() {\n        }\n    }\n}", "src": "public class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int n = in.nextInt(), l[] = new int[n],\n            p = -1000000, d_min = 1000000, min = 1000000000;\n        for(int i = 0; i < n; i++) {\n            l[i] = in.nextInt();\n            min = Math.min(min, l[i]);\n        }\n        for(int i = 0; i < n; i++)\n            if(l[i] == min) {\n                d_min = Math.min(d_min, i - p);\n                p = i;\n            }\n        out.print(d_min);\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public String nextLine() throws IOException {\n            while(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            String r = st.nextToken(\"\\n\");\n            st = new StringTokenizer(br.readLine(), \" \");\n            return r;\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 343, "complexity": "1"}
{"back-translation": "public class Codechef {\n     \n\n  public static void main(String[] args) throws IOException {\n    Scanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a=sc.nextInt();\n    int b=sc.nextInt();\n      int res=0;\n     int i=1;\n     while(i<n) {\n         res=Math.max(res, Math.min(a/i, b/(n-i)));\n         i++;\n     }\n     System.out.println(res);\n  }\n\n   }", "src": "public class Codechef {\n     \n\n  public static void main(String[] args) throws IOException {\n\tScanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a=sc.nextInt();\n    int b=sc.nextInt();\n      int res=0;\n     for(int i=1;i<n;i++)\n     res=Math.max(res, Math.min(a/i, b/(n-i) ) );\n     System.out.println(res);\n  }\n\n   }", "index": 344, "complexity": "1"}
{"back-translation": "public class Solution {\n    static final int N = 31;\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out,true);\n    static long c[] = new long[N];\n    static int w[] = new int[N];\n    public static void main(String[] args) {\n        w[0] = 1;\n        for(int i = 1; i < N; i++) {\n            w[i] = w[i - 1] * 2;\n        }\n        int n = sc.nextInt();\n        int l = sc.nextInt();\n        for(int i = 0; i < N; i++) {\n            c[i] = Long.MAX_VALUE;\n        }\n        for(int i = 0; i < n; i++) {\n            c[i] = sc.nextInt();\n        }\n        for(int i = 1; i < N; i++) {\n            c[i] = min(c[i - 1] * 2, c[i]);\n        }\n        long ans = 0;\n        for(int i = 0; i < N; i++) {\n            if ((l & w[i]) != 0) {\n                ans += c[i];\n            }\n        }\n        long m = 0;\n        for(int i = N - 1; i >= 0; i--) {\n            if ((l & w[i]) != 0) {\n                m += c[i];\n            } else {\n                ans = min(ans, m + c[i]);\n            }\n        }\n        out.println(ans);\n    }\n\n    static long min(long a, long b) {\n        return a < b ? a : b;\n    }\n}", "src": "public class practise {\n    static final int N = 31;\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out,true);\n    static long c[] = new long[N];\n    static int w[] = new int[N];\n    public static void main(String[] args) {\n        w[0] = 1;\n        for(int i=1;i<N;i++) w[i] = w[i-1]*2;\n        int n = sc.nextInt(); int l = sc.nextInt();\n        for(int i=0;i<N;i++) c[i] = Long.MAX_VALUE;\n        for(int i=0;i<n;i++) c[i] = sc.nextInt();\n        for(int i=1;i<N;i++) {\n            c[i] = min(c[i-1]*2,c[i]);\n        }\n        long ans = 0;\n        for(int i=0;i<N;i++) {\n            if( (l&w[i])!=0) {\n                ans += c[i];\n            }\n        }\n        long m = 0;\n        for(int i=N - 1;i>=0;i--) {\n            if((l&w[i])!=0) {\n                m += c[i];\n            } else {\n                ans = min(ans,m+c[i]);\n            }\n        }\n        out.println(ans);\n    }\n\n    static long min(long a,long b) {\n        return a<b?a:b;\n    }\n}", "index": 345, "complexity": "1"}
{"back-translation": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        char c[]=new char[n];\n        Arrays.fill(c,'o');\n        int x=1,y=1,z;\n        int count = 1;\n        while(count <= n)\n        {\n            c[count-1]='O';\n            z=x+count;\n            x=count;\n            count=z;\n        }\n        String ans=new String(c);\n        System.out.println(ans);\n    }\n}", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        char c[]=new char[n];\n        Arrays.fill(c,'o');\n        int x=1,y=1,z;\n        while(y<=n)\n        {\n            c[y-1]='O';\n            z=x+y;\n            x=y;\n            y=z;\n        }\n        String ans=new String(c);\n        System.out.println(ans);\n    }\n}", "index": 346, "complexity": "1"}
{"back-translation": "public class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int x = sc.nextInt();\n        String s = sc.next();\n        boolean f = true;\n        boolean f2 = true;\n        boolean f3 = true;\n        boolean f4 = true;\n        int v = 0;\n        for (int i = 0; i < s.length() - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1) && (s.charAt(i) != '?' || s.charAt(i + 1) != '?')) {\n                f = false;\n                break;\n            } else {\n                f = true;\n            }\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '?') {\n                if (i == 0 || i == s.length() - 1) {\n                    f2 = true;\n                    v++;\n                } else if (s.charAt(i) == s.charAt(i + 1)) {\n                    f2 = true;\n                    v++;\n                } else if (s.charAt(i - 1) == s.charAt(i + 1) && i != 0 && i != s.length() - 1) {\n                    f2 = true;\n                    v++;\n                }\n            } else {\n                if (v > 0) f2 = true;\n                else f2 = false;\n            }\n        }\n        if (f && f2) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n}", "src": "public class java{\n          public static void main(String[]arg) {\n        \t Scanner sc=new Scanner(System.in); \n        \t int x=sc.nextInt();\n        \t String s=sc.next();\n        \t boolean f=true;\n        \t boolean f2=true;\n        \t boolean f3=true;\n        \t boolean f4=true;\n        \t int v=0;\n        \t for(int i=0;i<s.length()-1;i++) {\n        \t\t if(s.charAt(i)==s.charAt(i+1)&&(s.charAt(i)!='?'||s.charAt(i+1)!='?')) {\n        \t\t\t f=false;\n        \t\t\t break;\n        \t\t }else {\n        \t\t\t f=true;\n        \t\t }\n        \t }\n        \t\n        \t \n        \t for(int i=0;i<s.length();i++) {\n        \t\t if(s.charAt(i)=='?') {\n        \t\t\t \n        \t\t\t if(i==0||i==s.length()-1) {\n        \t\t\t\t f2=true; \n        \t\t\t\t v++;\n        \t\t\t }else if(s.charAt(i)==s.charAt(i+1)) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t          }\n        \t\t\t else if(s.charAt(i-1)==s.charAt(i+1)&&i!=0&&i!=s.length()-1) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t         }\n        \t\t\t }else {\n        \t\t\t\t if(v>0) f2=true;\n        \t\t\t\t else f2=false;\n        \t\t\t }\n        \t\t }\n        \t \n        \tif(f&&f2) {\n        \t\tSystem.out.println(\"YES\");\n        \t}else {\n        \t\tSystem.out.println(\"NO\");\n        \t}\n          }\n          \n}", "index": 347, "complexity": "1"}
{"back-translation": "class Test { static int arr1[] = new int[]{ 0, 1, 0, 1, 1, 1, 1}; static int arr2[] = new int[]{ 1, 1, 1, 1, 1, 0, 1}; static int longestCommonSum(int n) { int maxLen = 0; int preSum1 = 0, preSum2 = 0; int diff[] = new int[2 * n + 1]; for (int i = 0; i < diff.length; i++) { diff[i] = -1; } for (int i = 0; i < n; i++) { preSum1 += arr1[i]; preSum2 += arr2[i]; int curr_diff = preSum1 - preSum2; int diffIndex = n + curr_diff; if (curr_diff == 0) maxLen = i + 1; else if ( diff[diffIndex] == -1) diff[diffIndex] = i; else { int len = i - diff[diffIndex]; if (len > maxLen) maxLen = len; } } return maxLen; } public static void main(String[] args) { System.out.print(\"Length of the longest common span with same sum is \"); System.out.println(longestCommonSum(arr1.length)); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n0\n, \n1\n, \n0\n, \n1\n, \n1\n, \n1\n, \n1\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n1\n}; \n\n\n\n\n\n\nstatic\nint\nlongestCommonSum(\nint\nn) \n\n{ \n\n\n\nint\nmaxLen = \n0\n; \n\n\n\n\nint\npreSum1 = \n0\n, preSum2 = \n0\n; \n\n\n\n\n\n\n\n\n\n\nint\ndiff[] = \nnew\nint\n[\n2\n*n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < diff.length; i++) { \n\ndiff[i] = -\n1\n; \n\n} \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\npreSum1 += arr1[i]; \n\npreSum2 += arr2[i]; \n\n\n\n\n\n\n\n\nint\ncurr_diff = preSum1 - preSum2; \n\nint\ndiffIndex = n + curr_diff; \n\n\n\n\n\n\n\n\nif\n(curr_diff == \n0\n) \n\nmaxLen = i+\n1\n; \n\n\n\n\n\n\nelse\nif\n( diff[diffIndex] == -\n1\n) \n\ndiff[diffIndex] = i; \n\n\n\n\nelse\n\n{ \n\n\n\nint\nlen = i - diff[diffIndex]; \n\n\n\n\nif\n(len > maxLen) \n\nmaxLen = len; \n\n} \n\n} \n\nreturn\nmaxLen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print(\n\"Length of the longest common span with same sum is \"\n); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n}", "index": 348, "complexity": "1"}
{"back-translation": "public class Codeforces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, f[], c=0;\n\t\tn = in.nextInt();\n\t\tf = new int[n];\n\t\twhile (--n>0){\n\t\t\tint index1 = in.nextInt()-1;\n\t\t\tf[index1] ++;\n\t\t\tint index2 = in.nextInt()-1;\n\t\t\tf[index2]++;\n\t\t\tin.nextLine();\n\t\t}\n\t\tint c=0;\n\t\tfor(int i=0; i<f.length; i++) \n\t\t\tif (f[i] == 1) \n\t\t\t\tc++;\n\t\tSystem.out.println(c);\n\t}\n\n}", "src": "public class Codeforces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, f[], c=0;\n\t\tn = in.nextInt();\n\t\tf = new int[n];\n\t\twhile (--n>0){\n\t\t\tf[in.nextInt()-1] ++;\n\t\t\tf[in.nextInt()-1]++;\n\t\t\tin.nextLine();\n\t\t}\n\t\tfor(int i=0; i<f.length; i++) if (f[i] == 1) c++;\n\t\tSystem.out.println(c);\n\t}\n\n}", "index": 349, "complexity": "1"}
{"back-translation": "class loser { static class InputReader { public BufferedReader br; public StringTokenizer token; public InputReader(InputStream stream) { br=new BufferedReader(new InputStreamReader(stream),32768); token=null; } public String next() { while(token==null || !token.hasMoreTokens()) { try { token=new StringTokenizer(br.readLine()); } catch(IOException e) { throw new RuntimeException(e); } } return token.nextToken(); } public int nextInt() { return Integer.parseInt(next()); } public long nextLong() { return Long.parseLong(next()); } } static class card{ long a; int i; public card(long a,int i) { this.a=a; this.i=i; } } static class sort implements Comparator<pair> { public int compare(pair o1,pair o2) { if(o1.a!=o2.a) return (int)(o1.a-o2.a); else return (int)(o1.b-o2.b); } } static void shuffle(long a[]) { List<Long> l=new ArrayList<>(); for(int i=0;i<a.length;i++) l.add(a[i]); Collections.shuffle(l); for(int i=0;i<a.length;i++) a[i]=l.get(i); } static class pair{ int a,b; public pair(int a,int b) { this.a=a; this.b=b; } } public static void main(String[] args) { InputReader sc=new InputReader(System.in); char c[]=sc.next().toCharArray(); int l=c.length; int a[]=new int[3]; for(int i=0;i<l;i++) { a[c[i]-'a']++; if(i>0 && c[i]<c[i-1]) { System.out.println(\"NO\"); System.exit(0); } } if(a[0]>0 && a[1]>0 && (a[2]==a[1]...NO\"); } else System.out.println(\"NO\"); } }", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        long a;\n        int i;\n        public card(long a,int i)\n        {\n            this.a=a;\n            this.i=i;\n        }\n    }\n    static class sort implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.a!=o2.a)\n                return (int)(o1.a-o2.a);\n            else\n                return (int)(o1.b-o2.b);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    \n    static class pair{\n        int a,b;\n        public pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        char c[]=sc.next().toCharArray();\n        int l=c.length;\n        int a[]=new int[3];\n        for(int i=0;i<l;i++)\n        {\n            a[c[i]-'a']++;\n           if(i>0 && c[i]<c[i-1])\n           {\n               System.out.println(\"NO\");\n               System.exit(0);\n           }\n        }\n        if(a[0]>0 && a[1]>0 && (a[2]==a[1] || a[2]==a[0]))\n        System.out.println(\"YES\");\n        else\n        System.out.println(\"NO\");\n    }\n}", "index": 350, "complexity": "1"}
{"back-translation": "public class GFG {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint ans = 0;\n\t\tint t = sc.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint nn = sc.nextInt();\n\t\t\tans += a;\n\t\t\tif (b < c) {\n\t\t\t\tans += (t - nn) * (c - b);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class GFG {\n\tpublic static void main (String[] args) {\n\t    Scanner sc = new Scanner (System.in);\n\t    int n = sc.nextInt();\n\t    int a = sc.nextInt();\n\t    int b = sc.nextInt();\n\t    int c = sc.nextInt();\n\t    int ans = 0;\n\t    int t= sc.nextInt();\n\t    int arr[] = new int[n];\n\t    for(int i=0;i<n;i++){\n\t        int nn = sc.nextInt();\n\t        ans+=a;\n\t        if(b<c){\n\t            ans += (t-nn) * (c - b);\n\t        }\n\t    }\n\t    System.out.println(ans);\n\t}\n}", "index": 351, "complexity": "1"}
{"back-translation": "class C {\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint n = sc.nextInt();\n\t\tint[] counts = new int[60];\n\t\tArrayList<ArrayDeque<Long>> nums = new ArrayList<>();\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tnums.add(new ArrayDeque<>());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong num = sc.nextLong();\n\t\t\tfor (int j = 1; j <= 60; ++j) {\n\t\t\t\tif (num < (1L << j)) {\n\t\t\t\t\tnums.get(j - 1).add(num);\n\t\t\t\t\t++counts[j - 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong curr = 0;\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= 60; ++j) {\n\t\t\t\tif (j == 60) {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (counts[j] == 0 || (curr & (1L << j)) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tlong num = nums.get(j).removeFirst();\n\t\t\t\t--counts[j];\n\t\t\t\tcurr ^= num;\n\t\t\t\tif (i > 0)\n\t\t\t\t\tans.append(\" \");\n\t\t\t\tans.append(num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class C {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\t\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] counts = new int[60];\n\t\tArrayList<ArrayDeque<Long>> nums = new ArrayList<>();\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tnums.add(new ArrayDeque<>());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong num = sc.nextLong();\n\t\t\tfor (int j = 1; j <= 60; ++j) {\n\t\t\t\tif (num < (1L<<j)) {\n\t\t\t\t\tnums.get(j-1).add(num);\n\t\t\t\t\t++counts[j-1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong curr = 0;\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= 60; ++j) {\n\t\t\t\tif (j==60) {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (counts[j]==0||(curr&(1L<<j))!=0)\n\t\t\t\t\tcontinue;\n\t\t\t\tlong num = nums.get(j).removeFirst();\n\t\t\t\t--counts[j];\n\t\t\t\tcurr ^= num;\n\t\t\t\tif (i>0)\n\t\t\t\t\tans.append(\" \");\n\t\t\t\tans.append(num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 352, "complexity": "1"}
{"back-translation": "public class TwoGramTranslator {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        String s = sc.next();\n\n        Map<String, Integer> hm = new HashMap<>();\n        for (int i = 0; i < n - 1; i++) {\n            String curr = s.substring(i, i + 2);\n\n            if (hm.containsKey(curr)) {\n                hm.put(curr, hm.get(curr) + 1);\n            } else {\n                hm.put(curr, 1);\n            }\n        }\n\n        String ans = \"\";\n        int currMax = 0;\n        for (String twoGram : hm.keySet()) {\n            if (hm.get(twoGram) > currMax) {\n                ans = twoGram;\n                currMax = hm.get(twoGram);\n            }\n        }\n\n        System.out.println(ans);\n\n        sc.close();\n    }\n}", "src": "public class TwoGram {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        String s = sc.next();\n\n        HashMap <String, Integer> hm = new HashMap<>();\n        for (int i = 0; i < n - 1; i++) {\n            String curr = s.substring(i, i + 2);\n\n            if (hm.containsKey(curr)) {\n                hm.put(curr, hm.get(curr) + 1);\n            } else {\n                hm.put(curr, 1);\n            }\n        }\n\n        String ans = \"\";\n        int currMax = 0;\n        for (String twoGram : hm.keySet()) {\n            if (hm.get(twoGram) > currMax) {\n                ans = twoGram;\n                currMax = hm.get(twoGram);\n            }\n        }\n\n        System.out.println(ans);\n\n        sc.close();\n    }\n}", "index": 353, "complexity": "1"}
{"back-translation": "public class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(bf.readLine());\n        int[]f=new int[1001];\n        int[]a=new int[n];\n        StringTokenizer tk=new StringTokenizer(bf.readLine());\n        for (int i = 0; i < n; i++) {\n            int element=Integer.parseInt(tk.nextToken());\n            a[i]=element;\n            f[element]++;\n        }\n        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        ArrayList<Integer> h=new ArrayList<>();\n        int counter=0;\n        for (int i = 0; i < n; i++) {\n            if(f[a[i]]==1){counter++; h.add(a[i]);}\n            else{f[a[i]]-=1;}\n        }\n        pw.write(counter+\"\\\\n\");\n        for (int i = 0; i < h.size(); i++) {\n            pw.write(h.get(i)+\" \");\n        }\n        pw.flush();\n    }\n}", "src": "public class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(bf.readLine());\n        int[]f=new int[1001];\n        int[]a=new int[n];\n        StringTokenizer tk=new StringTokenizer(bf.readLine());\n        for (int i = 0; i < n; i++) {\n            int element=Integer.parseInt(tk.nextToken());\n            a[i]=element;\n            f[element]++;\n        }\n        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        ArrayList<Integer> h=new ArrayList<>();\n        int counter=0;\n        for (int i = 0; i < n; i++) {\n            if(f[a[i]]==1){counter++; h.add(a[i]);}\n            else{f[a[i]]-=1;}\n        }\n        pw.write(counter+\"\\n\");\n        for (int i = 0; i < h.size(); i++) {\n            pw.write(h.get(i)+\" \");\n        }\n        pw.flush();\n    }\n}", "index": 354, "complexity": "1"}
{"back-translation": "class MergeArrays { void moveToEnd(int mPlusN[], int size) { int i, j = size - 1; for (i = size - 1; i >= 0; i--) { if (mPlusN[i] != -1) { mPlusN[j] = mPlusN[i]; j--; } } } void merge(int mPlusN[], int N[], int m, int n) { int i = n; int j = 0; int k = 0; while (k < (m + n)) { if ((i < (m + n) && mPlusN[i] <= N[j]) || (j == n)) { mPlusN[k] = mPlusN[i]; k++; i++; } else { mPlusN[k] = N[j]; k++; j++; } } } void printArray(int arr[], int size) { int i; for (i = 0; i < size; i++) System.out.print(arr[i] + \" \"); System.out.println(\"\"); } public static void main(String[] args) { MergeArrays mergearray = new MergeArrays(); int mPlusN[] = { 2, 8, -1, -1, -1, 13, -1, 15, 20 }; int N[] = { 5, 7, 9, 25 }; int n = N.length; int m = mPlusN.length - n; mergearray.moveToEnd(mPlusN, m + n); mergearray.merge(mPlusN, N, m, n); mergearray.printArray(mPlusN, m + n); } }", "src": "class\nMergeArrays \n{ \n\n\n\nvoid\nmoveToEnd(\nint\nmPlusN[], \nint\nsize) \n\n{ \n\nint\ni, j = size - \n1\n; \n\nfor\n(i = size - \n1\n; i >= \n0\n; i--) \n\n{ \n\nif\n(mPlusN[i] != -\n1\n) \n\n{ \n\nmPlusN[j] = mPlusN[i]; \n\nj--; \n\n} \n\n} \n\n} \n\n\n\n\nvoid\nmerge(\nint\nmPlusN[], \nint\nN[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = n; \n\n\n\n\nint\nj = \n0\n; \n\n\n\n\nint\nk = \n0\n; \n\n\n\n\nwhile\n(k < (m + n)) \n\n{ \n\n\n\nif\n((i < (m + n) && mPlusN[i] <= N[j]) || (j == n)) \n\n{ \n\nmPlusN[k] = mPlusN[i]; \n\nk++; \n\ni++; \n\n} \n\nelse\n\n\n{ \n\nmPlusN[k] = N[j]; \n\nk++; \n\nj++; \n\n} \n\n} \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMergeArrays mergearray = \nnew\nMergeArrays(); \n\n\n\n\nint\nmPlusN[] = {\n2\n, \n8\n, -\n1\n, -\n1\n, -\n1\n, \n13\n, -\n1\n, \n15\n, \n20\n}; \n\nint\nN[] = {\n5\n, \n7\n, \n9\n, \n25\n}; \n\nint\nn = N.length; \n\nint\nm = mPlusN.length - n; \n\n\n\n\nmergearray.moveToEnd(mPlusN, m + n); \n\n\n\n\nmergearray.merge(mPlusN, N, m, n); \n\n\n\n\nmergearray.printArray(mPlusN, m + n); \n\n} \n}", "index": 355, "complexity": "1"}
{"back-translation": "public class Practice {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tString s = sc.nextLine();\n\t\tint n = 0;\n\t\tint m = 0;\n\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '-') {\n\t\t\t\tn++;\n\t\t\t} else {\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\n\t\tif (m == 0) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t} else {\n\t\t\tif (n % m == 0) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\n}", "src": "public class Practice {\n\t\n\t   \n\n\t\tpublic static void main(String []args)\n\t\t{\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\t\n\t\t\t\n\t\t\tString s=sc.nextLine();\n\t\t\tint n=0;\n\t\t\tint m=0;\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)=='-')\n\t\t\t\t{\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif(n%m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t}\n\n}", "index": 356, "complexity": "1"}
{"back-translation": "class Geeks { static void rvereseArray(int arr[], int start, int end) { while (start < end) { int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; start++; end--; } } static void printArray(int arr[], int size) { for (int i = 0; i < size; i++) System.out.print(arr[i] + \" \"); } static void splitArr(int arr[], int k, int n) { rvereseArray(arr, 0, n - 1); rvereseArray(arr, 0, n - k - 1); rvereseArray(arr, n - k, n - 1); } public static void main(String args[]) { int arr[] = {12, 10, 5, 6, 52, 36}; int n = arr.length; int k = 2; splitArr(arr, k, n); printArray(arr, n); } }", "src": "class\nGeeks \n{ \n\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n{ \n\nwhile\n(start < end) { \n\nint\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nstart++; \n\nend--; \n\n} \n} \n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n} \n\n\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nk, \nint\nn) \n{ \n\nrvereseArray(arr, \n0\n, n - \n1\n); \n\nrvereseArray(arr, \n0\n, n - k - \n1\n); \n\nrvereseArray(arr, n - k, n - \n1\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\n\n\n\nsplitArr(arr, k, n); \n\nprintArray(arr, n); \n\n} \n\n}", "index": 357, "complexity": "1"}
{"back-translation": "public\n\nclass\nGFG\n{\n\npublic\n\n\nstatic\n\nvoid\n\nsortit\n(\nint\n[]arr, \nint\nn)\n\n\n{\n\nfor\n(\nint\ni = 0; i < n; i++)\n\n{\n\narr[i] = i + 1;\n\n}\n\n}\n\npublic\n\nstatic\n\nvoid\n\nmain(String args[])\n\n{\n\nint\n[]arr = {10, 7, 9, 2, 8, 3, 5, 4, 6, 1};\n\nint\nn = arr.length;\n\nsortit(arr, n);\n\nfor\n(\nint\ni = 0; i < n; i++)\n\nSystem.out.print(arr[i] + \" \");\n\n}\n\n}", "src": "public\nclass\nGFG { \n\n\n\n\n\nstatic\nvoid\nsortit(\nint\n[]arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i]=i+\n1\n; \n\n\n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n7\n, \n9\n, \n2\n, \n8\n, \n\n3\n, \n5\n, \n4\n, \n6\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n\n\nsortit(arr, n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 358, "complexity": "1"}
{"back-translation": "public class mohamedy23 {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tString s = sc.next();\n\t\tint i = s.length() - 1;\n\t\tif (n == 1) {\n\t\t\tif (s.charAt(0) == '1') {\n\t\t\t\tSystem.out.print(\"YES\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (n == 2) {\n\t\t\tif (s.contains(\"00\") || s.contains(\"11\")) {\n\t\t\t\tSystem.out.print(\"NO\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\"Yes\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (s.contains(\"000\") || s.contains(\"11\")) {\n\t\t\tSystem.out.print(\"NO\");\n\t\t\treturn;\n\t\t} else if (s.charAt(0) == '0' && s.charAt(1) == '0' && s.charAt(2) == '1') {\n\t\t\tSystem.out.print(\"NO\");\n\t\t\treturn;\n\t\t} else if (s.charAt(i) == '0' && s.charAt(i - 1) == '0') {\n\t\t\tSystem.out.print(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(\"YES\");\n\t}\n}", "src": "public class mohamedy23\n\t\t{\n\t      public static void main (String args[])\n\t\t    {\n\t\t    \tScanner sc=new Scanner(System.in);\n\t\t    \tint n=sc.nextInt();String s=sc.next();int i=s.length()-1;\n\t\t    \t\n\t\t    \tif(n==1) {\n\t\t    \t\tif(s.charAt(0)=='1') {\n\t\t    \t\t\tSystem.out.print(\"YES\");return;\n\t\t    \t\t}else {\n\t\t    \t\t\tSystem.out.print(\"NO\");return;\n\t\t    \t\t}\n\t\t    \t}else if(n==2) {\n\t\t    \t\tif(s.contains(\"00\")||s.contains(\"11\")) {\n\t\t    \t\t\tSystem.out.print(\"NO\");return;\n\t\t    \t\t}else {\n\t\t    \t\t\tSystem.out.print(\"Yes\");return;\n\t\t    \t\t}\n\t\t    \t}\n\t\t    \telse if(s.contains(\"000\")||s.contains(\"11\")) {\n\t\t    \t\tSystem.out.print(\"NO\");return;\n\t\t    \t}\n\t\t    \telse\tif(s.charAt(0)=='0'&&s.charAt(1)=='0'&&s.charAt(2)=='1') {\n\t\t    \t\tSystem.out.print(\"NO\");return;\n\t\t    \t}\n\t\t    \telse\tif(s.charAt(i)=='0'&&s.charAt(i-1)=='0') {\n\t\t    \t\tSystem.out.print(\"NO\");\n\t\t    \t\treturn;\n\t\t    \t\t}\n\t\t    \t System.out.print(\"YES\");\n\t\t    }\n\t\t}", "index": 359, "complexity": "1"}
{"back-translation": "class Main {static class D2C982_cut_them_all {int n;ArrayList<Integer>[] adj;int[] sizes = new int[n];boolean[] visited = new boolean[n];public void solve(int testNumber, InputReader in, OutputWriter out) {n = in.nextInt();if ((n & 1) == 1) {out.println(-1);return;}sizes = new int[n];visited = new boolean[n];adj = new ArrayList[n];for (int i = 0; i < n; i++) {adj[i] = new ArrayList<>();}for (int i = 1; i < n; i++) {int u = in.nextInt() - 1;int v = in.nextInt() - 1;adj[u].add(v);adj[v].add(u);}int root = 0;for (int i = 1; i < n; i++) {if (adj[i].size() > adj[root].size()) {root = i;}}dfs(root);int cnt = 0;for (int i = 0; i < n; i++) {if ((sizes[i] & 1) == 0) cnt++;}out.println(cnt - 1);}int dfs(int u) {visited[u] = true;int cnt = 1;for (int w : adj[u]) if (!visited[w]) cnt += dfs(w);sizes[u] = cnt;return cnt;}}public static void main(String[] args) {InputStream inputStream = System.in;OutputStream outputStream = System.out;InputReader in = new InputReader(inputStream);OutputWriter out = new OutputWriter(outputStream);D2C982_cut_them_all solver = new D2C982_cut_them_all();solver.solve(1, in, out);out.close();}}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D2C982_cut_them_all solver = new D2C982_cut_them_all();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D2C982_cut_them_all {\n        int n;\n        ArrayList<Integer>[] adj;\n        int[] sizes = new int[n];\n        boolean[] visited = new boolean[n];\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            n = in.nextInt();\n            if ((n & 1) == 1) {\n                out.println(-1);\n                return;\n            }\n            sizes = new int[n];\n            visited = new boolean[n];\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            for (int i = 1; i < n; i++) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n\n            int root = 0;\n            for (int i = 1; i < n; i++) {\n                if (adj[i].size() > adj[root].size()) {\n                    root = i;\n                }\n            }\n\n            dfs(root);\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if ((sizes[i] & 1) == 0) cnt++;\n            }\n            out.println(cnt - 1);\n\n        }\n\n        int dfs(int u) {\n\n            visited[u] = true;\n            int cnt = 1;\n\n            for (int w : adj[u])\n                if (!visited[w])\n                    cnt += dfs(w);\n\n            sizes[u] = cnt;\n            return cnt;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}", "index": 360, "complexity": "1"}
{"back-translation": "class GFG {\n\n    static boolean sortedAfterSwap(int[] A, boolean[] B, int n) {\n        int i, j;\n        for (i = 0; i < n - 1; i++) {\n            if (B[i]) {\n                j = i;\n                while (B[j]) {\n                    j++;\n                }\n                Arrays.sort(A, i, 1 + j);\n                i = j;\n            }\n        }\n        for (i = 0; i < n; i++) {\n            if (A[i] != i + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] A = {1, 2, 5, 3, 4, 6};\n        boolean[] B = {false, true, true, true, false};\n        int n = A.length;\n        if (sortedAfterSwap(A, B, n)) {\n            System.out.println(\"A can be sorted\");\n        } else {\n            System.out.println(\"A can not be sorted\");\n        }\n    }\n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nsortedAfterSwap(\nint\nA[], \n\nboolean\nB[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n - \n1\n; i++) { \n\nif\n(B[i]) { \n\nj = i; \n\nwhile\n(B[j]) { \n\nj++; \n\n} \n\n\n\nArrays.sort(A, i, \n1\n+ j); \n\ni = j; \n\n} \n\n} \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n(A[i] != i + \n1\n) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n1\n, \n2\n, \n5\n, \n3\n, \n4\n, \n6\n}; \n\nboolean\nB[] = { \nfalse\n, \ntrue\n, \ntrue\n, \ntrue\n, \nfalse\n}; \n\nint\nn = A.length; \n\n\nif\n(sortedAfterSwap(A, B, n)) { \n\nSystem.out.println(\n\"A can be sorted\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"A can not be sorted\"\n); \n\n} \n\n} \n}", "index": 361, "complexity": "1"}
{"back-translation": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt(), t;\n        int[] a = new int[101];\n        int answ = 0;\n        for (long i = 0; i < n; i++) {\n            t = in.nextInt();\n            a[t]++;\n            if (a[t] < 2) {\n                if (answ < k) {\n                    data.append(i + 1).append(\" \");\n                    answ++;\n                }\n            }\n\n        }\n        if (answ == k) {\n            System.out.println(\"YES\");\n            System.out.println(data);\n        } else {\n            System.out.println(\"NO\");\n        }\n\n\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "src": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt(), t;\n        int[] a = new int[101];\n        int answ = 0;\n        for (long i = 0; i < n; i++) {\n            t = in.nextInt();\n            a[t]++;\n            if (a[t] < 2) {\n                if (answ < k) {\n                    data.append(i + 1).append(\" \");\n                    answ++;\n                }\n            }\n\n        }\n        if (answ == k) {\n            System.out.println(\"YES\");\n            System.out.println(data);\n        } else {\n            System.out.println(\"NO\");\n        }\n\n\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 362, "complexity": "1"}
{"back-translation": "public class Main {\n    public static void main(String[] args) {\n        IO io = new IO();\n        String s = io.nextLine();\n        if (s.length() < 3) io.println(\"No\");\n        else {\n            int[] b = new int[200];\n            for (int i = 2; i < s.length(); i++) {\n                b['.'] = b['A'] = b['B'] = b['C'] = 0;\n                b[s.charAt(i - 2)] = 1;\n                b[s.charAt(i - 1)] = 1;\n                b[s.charAt(i)] = 1;\n                if (b['A'] + b['B'] + b['C'] == 3) {\n                    io.println(\"Yes\");\n                    return;\n                }\n            }\n            io.println(\"No\");\n        }\n    }\n\n    static class IO {\n        BufferedInputStream din;\n        final int BUFFER_SIZE = 1 << 16;\n        byte[] buffer;\n        int byteRead, bufferPoint;\n\n        StringBuilder builder;\n        PrintWriter pw;\n\n        public IO() {\n            din = new BufferedInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPoint = byteRead = 0;\n\n            builder = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), true);\n        }\n\n        int read() {\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (byteRead == -1) buffer[0] = -1;\n            }\n            return buffer[bufferPoint++];\n        }\n\n        int peek() {\n            if (byteRead == -1) return -1;\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (byteRead <= 0) return -1;\n            }\n            return buffer[bufferPoint];\n        }\n\n        boolean hasNext() {\n            int c = peek();\n            while (c != -1 && c <= ' ') {\n                read();\n                c = peek();\n            }\n            return c != -1;\n        }\n\n        char nextChar() {\n            int c = read();\n            while (c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        double nextDouble() {\n            double ret = 0, div = 1;\n            int c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        String nextLine() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n        String next() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (Character.isWhitespace(c)) {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n        int nextInt() {\n            int ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        long nextLong() {\n            long ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        void println(Object o) {\n            pw.println(o);\n        }\n\n        void print(Object o) {\n            pw.print(o);\n        }\n\n        void printf(String format, Object... objects) {\n            pw.printf(format, objects);\n        }\n\n        void close() {\n            pw.close();\n        }\n\n        void done(Object o) {\n            print(o);\n            close();\n        }\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        IO io = new IO();\n        String s=io.nextLine();\n        if (s.length()<3)io.println(\"No\");\n        else {\n            int[]b=new int[200];\n            for (int i=2;i<s.length();i++){\n                b['.']=b['A']=b['B']=b['C']=0;\n                b[s.charAt(i-2)]=1;\n                b[s.charAt(i-1)]=1;\n                b[s.charAt(i)]=1;\n                if (b['A']+b['B']+b['C']==3){io.println(\"Yes\");return;}\n            }\n            io.println(\"No\");\n        }\n    }\n\n\n    static class IO {\n\n        BufferedInputStream din;\n        final int BUFFER_SIZE = 1 << 16;\n        byte[] buffer;\n        int byteRead, bufferPoint;\n\n        StringBuilder builder;\n        PrintWriter pw;\n\n        public IO() {\n            din = new BufferedInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPoint = byteRead = 0;\n\n            builder = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                    System.out\n            )), true);\n        }\n\n        int read() {\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (byteRead == -1) buffer[0] = -1;\n            }\n            return buffer[bufferPoint++];\n        }\n\n        int peek() {\n            if (byteRead == -1) return -1;\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (byteRead <= 0) return -1;\n            }\n            return buffer[bufferPoint];\n        }\n\n        boolean hasNext() {\n            int c = peek();\n            while (c != -1 && c <= ' ') {\n                read();\n                c = peek();\n            }\n            return c != -1;\n        }\n\n        char nextChar() {\n            int c = read();\n            while (c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        double nextDouble() {\n            double ret = 0, div = 1;\n            int c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        String nextLine() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n\n        String next() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (Character.isWhitespace(c)) {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n        int nextInt() {\n            int ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        long nextLong() {\n            long ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        void println(Object o) {\n            pw.println(o);\n        }\n\n        void print(Object o) {\n            pw.print(o);\n        }\n\n        void printf(String format, Object... objects) {\n            pw.printf(format, objects);\n        }\n\n        void close() {\n            pw.close();\n        }\n\n        void done(Object o) {\n            print(o);\n            close();\n        }\n\n    }\n}", "index": 363, "complexity": "1"}
{"back-translation": "class icpc {\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n        String s1[] = in.readLine().split(\" \");\n        int n = Integer.parseInt(s1[0]);\n        int p = Integer.parseInt(s1[1]);\n        String s = in.readLine();\n        StringBuilder stringBuilder = new StringBuilder(s);\n        boolean flag = false;\n        for (int i = 0; i < n; i++) {\n            if (i + p < n) {\n                if (s.charAt(i) != '.' && s.charAt(i + p) != '.' && s.charAt(i) != s.charAt(i + p)) {\n                    flag = true;\n                    break;\n                } else if (s.charAt(i) == '.' && s.charAt(i + p) != '.') {\n                    int x = s.charAt(i + p) - '0';\n                    char ch = (char) ((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i, ch);\n                    flag = true;\n                    break;\n                } else if (s.charAt(i) != '.' && s.charAt(i + p) == '.') {\n                    int x = s.charAt(i) - '0';\n                    char ch = (char) ((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i + p, ch);\n                    flag = true;\n                    break;\n                } else if (s.charAt(i) == '.' && s.charAt(i + p) == '.') {\n                    stringBuilder.setCharAt(i, '1');\n                    stringBuilder.setCharAt(i + p, '0');\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        if (flag) {\n            for (int i = 0; i < stringBuilder.length(); i++) {\n                if (stringBuilder.charAt(i) == '.') {\n                    stringBuilder.setCharAt(i, '0');\n                }\n            }\n            System.out.println(stringBuilder);\n        } else\n            System.out.println(\"No\");\n\n\n    }\n}\n}\n\n\nclass StringAlgorithms {\n    public int[] calculateZ(char input[]) {\n        int Z[] = new int[input.length];\n        int left = 0;\n        int right = 0;\n        for (int k = 1; k < input.length; k++) {\n            if (k > right) {\n                left = right = k;\n                while (right < input.length && input[right] == input[right - left]) {\n                    right++;\n                }\n                Z[k] = right - left;\n                right--;\n            } else {\n\n                int k1 = k - left;\n\n                if (Z[k1] < right - k + 1) {\n                    Z[k] = Z[k1];\n                } else {\n                    left = k;\n                    while (right < input.length && input[right] == input[right - left]) {\n                        right++;\n                    }\n                    Z[k] = right - left;\n                    right--;\n                }\n            }\n        }\n        return Z;\n    }\n\n    public ArrayList<Integer> matchPattern(char text[], char pattern[]) {\n        char newString[] = new char[text.length + pattern.length + 1];\n        int i = 0;\n        for (char ch : pattern) {\n            newString[i] = ch;\n            i++;\n        }\n        newString[i] = '$';\n        i++;\n        for (char ch : text) {\n            newString[i] = ch;\n            i++;\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        int Z[] = calculateZ(newString);\n\n        for (i = 0; i < Z.length; i++) {\n            if (Z[i] == pattern.length) {\n                result.add(i - pattern.length - 1);\n            }\n        }\n        return result;\n    }\n}\n\n\nclass BasicFunctions {\n    public long min(long[] A) {\n        long min = Long.MAX_VALUE;\n        for (int i = 0; i < A.length; i++) {\n            min = Math.min(min, A[i]);\n        }\n        return min;\n    }\n\n    public long max(long[] A) {\n        long max = Long.MAX_VALUE;\n        for (int i = 0; i < A.length; i++) {\n            max = Math.max(max, A[i]);\n        }\n        return max;\n    }\n}\n\n\nclass Name implements Comparable<Name> {\n    int x;\n    int y;\n\n    public Name(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public int compareTo(Name ob) {\n        if (this.x < ob.x)\n            return -1;\n        else if (this.x > ob.x)\n            return 1;\n        return 0;\n    }\n}\n\nclass Matrix {\n    long a;\n    long b;\n    long c;\n    long d;\n\n    public Matrix(long a, long b, long c, long d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n}\n\n\nclass Game implements Comparable<Game> {\n    long x;\n    long y;\n\n    public Game(long x, long y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public int compareTo(Game ob) {\n        if (this.x < ob.x)\n            return -1;\n        else if (this.x > ob.x)\n            return 1;\n        else {\n            if (this.y < ob.y)\n                return -1;\n            else if (this.y > ob.y)\n                return 1;\n            else\n                return 0;\n        }\n    }\n}\n\nclass MergeSortInt {\n    void merge(int arr[], int l, int m, int r) {\n\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n        int i = 0, j = 0;\n\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n\n            int m = (l + r) / 2;\n\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            merge(arr, l, m, r);\n        }\n    }\n}\n\nclass MergeSortLong {\n    void merge(long arr[], int l, int m, int r) {\n\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        long L[] = new long[n1];\n        long R[] = new long[n2];\n\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n        int i = 0, j = 0;\n\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    void sort(long arr[], int l, int r) {\n        if (l < r) {\n\n            int m = (l + r) / 2;\n\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            merge(arr, l, m, r);\n        }\n    }\n}\n\nclass Node {\n    String a;\n    String b;\n\n    Node(String s1, String s2) {\n        this.a = s1;\n        this.b = s2;\n    }\n\n    @Override\n    public boolean equals(Object ob) {\n        if (ob == null)\n            return false;\n        if (!(ob instanceof Node))\n            return false;\n        if (ob == this)\n            return true;\n        Node obj = (Node) ob;\n        if (this.a.equals(obj.a) && this.b.equals(obj.b))\n            return true;\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return (int) this.a.length();\n    }\n}\n\nclass Reader {\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader() {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException {\n        byte[] buf = new byte[64];\n        int cnt = 0, c;\n        while ((c = read()) != -1) {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.') {\n            while ((c = read()) >= '0' && c <= '9') {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\n\nclass FenwickTree {\n    public void update(long[] fenwickTree, long delta, int index) {\n        index += 1;\n        while (index < fenwickTree.length) {\n            fenwickTree[index] += delta;\n            index = index + (index & (-index));\n        }\n    }\n\n    public long prefixSum(long[] fenwickTree, int index) {\n        long sum = 0L;\n        index += 1;\n        while (index > 0) {\n            sum += fenwickTree[index];\n            index -= (index & (-index));\n        }\n        return sum;\n    }\n}\n\nclass SegmentTree {\n    public int nextPowerOfTwo(int num) {\n        if (num == 0)\n            return 1;\n        if (num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while ((num & (num - 1)) > 0) {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n\n    public int[] createSegmentTree(int[] input) {\n        int np2 = nextPowerOfTwo(input.length);\n        int[] segmentTree = new int[np2 * 2 - 1];\n\n        for (int i = 0; i < segmentTree.length; i++)\n            segmentTree[i] = Integer.MIN_VALUE;\n\n        constructSegmentTree(segmentTree, input, 0, input.length - 1, 0);\n        return segmentTree;\n\n    }\n\n    private void constructSegmentTree(int[] segmentTree, int[] input, int low, int high, int pos) {\n        if (low == high) {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high) / 2;\n        constructSegmentTree(segmentTree, input, low, mid, 2 * pos + 1);\n        constructSegmentTree(segmentTree, input, mid + 1, high, 2 * pos + 2);\n        segmentTree[pos] = Math.max(segmentTree[2 * pos + 1], segmentTree[2 * pos + 2]);\n    }\n\n    public int rangeMinimumQuery(int[] segmentTree, int qlow, int qhigh, int len) {\n        return rangeMinimumQuery(segmentTree, 0, len - 1, qlow, qhigh, 0);\n    }\n\n    private int rangeMinimumQuery(int segmentTree[], int low, int high, int qlow, int qhigh, int pos) {\n        if (qlow <= low && qhigh >= high) {\n            return segmentTree[pos];\n        }\n        if (qlow > high || qhigh < low) {\n            return Integer.MIN_VALUE;\n        }\n        int mid = (low + high) / 2;\n        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),\n                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));\n    }\n}", "src": "public class icpc\n{\n    public static void main(String[] args)throws IOException\n    {\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n        String s1[] = in.readLine().split(\" \");\n        int  n = Integer.parseInt(s1[0]);\n        int p = Integer.parseInt(s1[1]);\n        String s = in.readLine();\n        StringBuilder stringBuilder = new StringBuilder(s);\n        boolean flag = false;\n        for(int i=0;i<n;i++)\n        {\n            if(i + p < n)\n            {\n                if(s.charAt(i) != '.' && s.charAt(i + p) != '.' && s.charAt(i) != s.charAt(i + p))\n                {\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) != '.')\n                {\n                    int x = s.charAt(i + p) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) != '.' && s.charAt(i + p) == '.')\n                {\n                    int x = s.charAt(i) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i + p, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) == '.')\n                {\n                    stringBuilder.setCharAt(i, '1');\n                    stringBuilder.setCharAt(i + p, '0');\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        if(flag)\n        {\n            for(int i=0;i<stringBuilder.length();i++)\n            {\n                if(stringBuilder.charAt(i) == '.')\n                {\n                    stringBuilder.setCharAt(i, '0');\n                }\n            }\n            System.out.println(stringBuilder);\n        }\n        else\n            System.out.println(\"No\");\n\n\n    }\n}\nclass StringAlgorithms\n{\n    public int[] calculateZ(char input[]) {\n        int Z[] = new int[input.length];\n        int left = 0;\n        int right = 0;\n        for(int k = 1; k < input.length; k++) {\n            if(k > right) {\n                left = right = k;\n                while(right < input.length && input[right] == input[right - left]) {\n                    right++;\n                }\n                Z[k] = right - left;\n                right--;\n            } else {\n                \n                int k1 = k - left;\n                \n                if(Z[k1] < right - k + 1) {\n                    Z[k] = Z[k1];\n                } else { \n                    left = k;\n                    while(right < input.length && input[right] == input[right - left]) {\n                        right++;\n                    }\n                    Z[k] = right - left;\n                    right--;\n                }\n            }\n        }\n        return Z;\n    }\n    public ArrayList<Integer> matchPattern(char text[], char pattern[]) {\n        char newString[] = new char[text.length + pattern.length + 1];\n        int i = 0;\n        for(char ch : pattern) {\n            newString[i] = ch;\n            i++;\n        }\n        newString[i] = '$';\n        i++;\n        for(char ch : text) {\n            newString[i] = ch;\n            i++;\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        int Z[] = calculateZ(newString);\n\n        for(i = 0; i < Z.length ; i++) {\n            if(Z[i] == pattern.length) {\n                result.add(i - pattern.length - 1);\n            }\n        }\n        return result;\n    }\n}\nclass BasicFunctions\n{\n    public long min(long[] A)\n    {\n        long min = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            min = Math.min(min, A[i]);\n        }\n        return min;\n    }\n    public long max(long[] A)\n    {\n        long max = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            max = Math.max(max, A[i]);\n        }\n        return max;\n    }\n}\nclass Name implements Comparable<Name>\n{\n    int x;\n    int y;\n\n    public Name(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public int compareTo(Name ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        return 0;\n    }\n}\nclass Matrix\n{\n    long a;\n    long b;\n    long c;\n    long d;\n\n    public Matrix(long a, long b, long c, long d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n}\nclass Game implements Comparable<Game>\n{\n    long x;\n    long y;\n\n    public Game(long x, long y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public int compareTo(Game ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        else\n        {\n            if(this.y < ob.y)\n                return -1;\n            else if(this.y > ob.y)\n                return 1;\n            else\n                return 0;\n        }\n    }\n}\nclass MergeSortInt\n{\n    \n    \n    \n    void merge(int arr[], int l, int m, int r) {\n        \n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        \n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        \n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        \n\n        \n        int i = 0, j = 0;\n\n        \n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        \n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        \n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    \n    \n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n            \n            int m = (l + r) / 2;\n\n            \n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            \n            merge(arr, l, m, r);\n        }\n    }\n\n}\nclass MergeSortLong\n{\n    \n    \n    \n    void merge(long arr[], int l, int m, int r) {\n        \n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        \n        long L[] = new long[n1];\n        long R[] = new long[n2];\n\n        \n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        \n\n        \n        int i = 0, j = 0;\n\n        \n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        \n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        \n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    \n    \n    void sort(long arr[], int l, int r) {\n        if (l < r) {\n            \n            int m = (l + r) / 2;\n\n            \n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            \n            merge(arr, l, m, r);\n        }\n    }\n}\nclass Node\n{\n    String a;\n    String b;\n    Node(String s1,String s2)\n    {\n        this.a = s1;\n        this.b = s2;\n    }\n    @Override\n    public boolean equals(Object ob)\n    {\n        if(ob == null)\n            return false;\n        if(!(ob instanceof Node))\n            return false;\n        if(ob == this)\n            return true;\n        Node obj = (Node)ob;\n        if(this.a.equals(obj.a) && this.b.equals(obj.b))\n            return true;\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int)this.a.length();\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64]; \n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\nclass FenwickTree\n{\n    public void update(long[] fenwickTree,long delta,int index)\n    {\n        index += 1;\n        while(index < fenwickTree.length)\n        {\n            fenwickTree[index] += delta;\n            index = index + (index & (-index));\n        }\n    }\n    public long prefixSum(long[] fenwickTree,int index)\n    {\n        long sum = 0L;\n        index += 1;\n        while(index > 0)\n        {\n            sum += fenwickTree[index];\n            index -= (index & (-index));\n        }\n        return sum;\n    }\n}\nclass SegmentTree\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n    public int[] createSegmentTree(int[] input)\n    {\n        int np2 = nextPowerOfTwo(input.length);\n        int[] segmentTree = new int[np2 * 2 - 1];\n\n        for(int i=0;i<segmentTree.length;i++)\n            segmentTree[i] = Integer.MIN_VALUE;\n\n        constructSegmentTree(segmentTree,input,0,input.length-1,0);\n        return segmentTree;\n\n    }\n    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/ 2;\n        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);\n        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);\n        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);\n    }\n    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)\n    {\n        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);\n    }\n    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)\n    {\n        if(qlow <= low && qhigh >= high){\n            return segmentTree[pos];\n        }\n        if(qlow > high || qhigh < low){\n            return Integer.MIN_VALUE;\n        }\n        int mid = (low+high)/2;\n        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),\n                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));\n    }\n}", "index": 364, "complexity": "1"}
{"back-translation": "public class Fingerprints {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tset.add(nextInt());\n\t\t}\n\t\t\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (set.contains(a[i])) {\n\t\t\t\ts += \" \" + a[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(s.length() == 0 ? s : s.substring(1));\n\t}\n\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class Fingerprints {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tset.add(nextInt());\n\t\t\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (set.contains(a[i]))\n\t\t\t\ts += \" \" + a[i];\n\t\t\n\t\tSystem.out.println(s.length() == 0 ? s : s.substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 365, "complexity": "1"}
{"back-translation": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(a));\n\n\t\tsc.close();\n\t}\n\n\tstatic String solve(int[] a) {\n\t\tif (a.length == 1 || (a.length == 2 && a[0] == a[1])) {\n\t\t\treturn \"-1\";\n\t\t}\n\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tsum += a[i];\n\t\t}\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (a[i] * 2 != sum) {\n\t\t\t\treturn String.format(\"1\\n%d\", i + 1);\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(a));\n\n\t\tsc.close();\n\t}\n\n\tstatic String solve(int[] a) {\n\t\tif (a.length == 1 || (a.length == 2 && a[0] == a[1])) {\n\t\t\treturn \"-1\";\n\t\t}\n\n\t\tint sum = Arrays.stream(a).sum();\n\t\tfor (int i = 0;; i++) {\n\t\t\tif (a[i] * 2 != sum) {\n\t\t\t\treturn String.format(\"1\\n%d\", i + 1);\n\t\t\t}\n\t\t}\n\t}\n}", "index": 366, "complexity": "1"}
{"back-translation": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), m = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        int h=0,t=n-1,answ=0;\n        while (h<n&&t>=0){\n            if(a[h]<=m){\n                answ++;\n                h++;\n            }else if(a[t]<=m){\n                t--;\n                answ++;\n            }else{\n                break;\n            }\n        }\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "src": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), m = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        int h=0,t=n-1,answ=0;\n        while (h<n&&t>=0){\n            if(a[h]<=m){\n                answ++;\n                h++;\n            }else if(a[t]<=m){\n                t--;\n                answ++;\n            }else{\n                break;\n            }\n        }\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 367, "complexity": "1"}
{"back-translation": "public class Solution{\n\tpublic static void main(String sp[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString st = sc.next();\n\t\t\n\t\tchar arr[] = st.toCharArray();\n\t\t\n\t\tboolean b=false;\n\t\tfor(char j='a';j<='z';j++){\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]==j){\n\t\t\t\tarr[i]='*';\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tif(k==0){\n\t\t\t\tb=true;\n\t\t\t\tprin(arr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}}\n\n\t}\n\t\n\tpublic static void prin(char arr[]){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]!='*')\n\t\t\t\tsb.append(arr[i]);\n\t\t}\n\t\tif(sb.length()!=0)\n\t\t\tSystem.out.println(sb.toString());\n\t}\n}", "src": "public class Solution{\n\tpublic static void main(String sp[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString st = sc.next();\n\t\t\n\t\tchar arr[] = st.toCharArray();\n\t\t\n\t\tboolean b=false;\n\t\tfor(char j='a';j<='z';j++){\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]==j){\n\t\t\t\tarr[i]='*';\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tif(k==0){\n\t\t\t\tb=true;\n\t\t\t\tprin(arr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}}\n\n\t}\n\t\n\tpublic static void prin(char arr[]){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]!='*')\n\t\t\t\tsb.append(arr[i]);\n\t\t}\n\t\tif(sb.length()!=0)\n\t\t\tSystem.out.println(sb.toString());\n\t}\n}", "index": 368, "complexity": "1"}
{"back-translation": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "index": 369, "complexity": "1"}
{"back-translation": "public class Transform {\n    static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        out.println(solve(n, m));\n        out.flush();\n        out.close();\n    }\n\n    private static String solve(int n, int m) {\n        int[] grid = new int[m+1];\n        for (int i = 0; i < n; i++) {\n            int start = in.nextInt();\n            int end = in.nextInt();\n\n            grid[start]++;\n            grid[end]--;\n\n        }\n        int sum = 0;\n        for(int i = 0; i < m; i++){\n            sum += grid[i];\n            if(sum == 0) return \"NO\";\n        }\n\n        return \"YES\";\n    }\n}", "src": "public class pr902A {\n    static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        out.println(solve(n, m));\n        out.flush();\n        out.close();\n    }\n\n    private static String solve(int n, int m) {\n        int[] grid = new int[m+1];\n        for (int i = 0; i < n; i++) {\n            int start = in.nextInt();\n            int end = in.nextInt();\n\n            grid[start]++;\n            grid[end]--;\n\n        }\n        int sum = 0;\n        for(int i = 0; i < m; i++){\n            sum += grid[i];\n            if(sum == 0) return \"NO\";\n        }\n\n        return \"YES\";\n    }\n}", "index": 370, "complexity": "1"}
{"back-translation": "public class TransposedErrorCorrectSystem {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        String a = scan.next();\n        String b = scan.next();\n\n        int[][] mismatch = new int[26][26];\n        for (int i = 0; i < 26; i++) Arrays.fill(mismatch[i], -1);\n        int[][] pair = new int[2][26];\n        for (int i = 0; i < 2; i++) Arrays.fill(pair[i], -1);\n        int hd = 0;\n        for (int i = 0; i < n; i++) {\n            if (a.charAt(i) != b.charAt(i)) {\n                hd++;\n                mismatch[a.charAt(i) - 'a'][b.charAt(i) - 'a'] = i;\n                pair[0][a.charAt(i) - 'a'] = i;\n                pair[1][b.charAt(i) - 'a'] = i;\n            }\n        }\n        for (int i = 0; i < 26; i++) {\n            for (int j = i + 1; j < 26; j++) {\n                if (mismatch[i][j] > -1 && mismatch[j][i] > -1) {\n                    System.out.println(hd - 2);\n                    System.out.println((mismatch[i][j] + 1) + \" \" + (mismatch[j][i] + 1));\n                    return;\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (a.charAt(i) != b.charAt(i)) {\n                if (pair[0][b.charAt(i) - 'a'] > -1) {\n                    System.out.println(hd - 1);\n                    System.out.println((i + 1) + \" \" + (pair[0][b.charAt(i) - 'a'] + 1));\n                    return;\n                }\n            }\n        }\n\n        System.out.println(hd);\n        System.out.println(\"-1 -1\");\n    }\n}", "src": "public class ErrorCorrectSystem\n{\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tString a = scan.next();\n\t\tString b = scan.next();\n\t\t\n\t\tint[][] mismatch = new int[26][26];\n\t\tfor(int i = 0; i < 26; i++) Arrays.fill(mismatch[i], -1);\n\t\tint[][] pair = new int[2][26];\n\t\tfor(int i = 0; i < 2; i++) Arrays.fill(pair[i], -1);\n\t\tint hd = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\thd++;\n\t\t\t\tmismatch[a.charAt(i)-'a'][b.charAt(i)-'a'] = i;\n\t\t\t\tpair[0][a.charAt(i)-'a'] = i;\n\t\t\t\tpair[1][b.charAt(i)-'a'] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tfor(int j = i+1; j < 26; j++) {\n\t\t\t\tif(mismatch[i][j] > -1 && mismatch[j][i] > -1) {\n\t\t\t\t\tSystem.out.println(hd-2);\n\t\t\t\t\tSystem.out.println((mismatch[i][j]+1)+\" \"+(mismatch[j][i]+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\t\n\t\t\t\tif(pair[0][b.charAt(i)-'a'] > -1) {\n\t\t\t\t\tSystem.out.println(hd-1);\n\t\t\t\t\tSystem.out.println((i+1)+\" \"+(pair[0][b.charAt(i)-'a']+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(hd);\n\t\tSystem.out.println(\"-1 -1\");\n\t}\n\n}", "index": 371, "complexity": "1"}
{"back-translation": "public class Solution1 implements Runnable {\n    static final long MAX = 1000000007L;\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n        public String next() {\n            return readString();\n        }\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Solution1(), \"Solution1\", 1 << 26).start();\n    }\n    long gcd(long a, long b) {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n    long lcm(long a, long b) {\n        return (a * b) / gcd(a, b);\n    }\n    int root(int a) {\n        while (arr[a] != a) {\n            arr[a] = arr[arr[a]];\n            a = arr[a];\n        }\n        return a;\n    }\n    void union(int a, int b) {\n        int xroot = root(a);\n        int yroot = root(b);\n        if (arr[xroot] < arr[yroot]) {\n            arr[xroot] = yroot;\n        } else {\n            arr[yroot] = xroot;\n        }\n    }\n    boolean find(int a, int b) {\n        int roota = root(a);\n        int rootb = root(b);\n        if (roota == rootb) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    int[] arr;\n    final int level = 20;\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        char[] ch = new char[n];\n        char[] ch2 = new char[n];\n        ch = sc.next().toCharArray();\n        ch2 = sc.next().toCharArray();\n        HashSet<Integer>[] hset = new HashSet[26];\n        for (int i = 0; i < 26; i++) {\n            hset[i] = new HashSet();\n        }\n        int count = 0;\n        for (int i = 0; i < ch.length; i++) {\n            if (ch[i] != ch2[i]) {\n                hset[ch[i] - 97].add(ch2[i] - 97);\n                count++;\n            }\n        }\n        boolean flag = false;\n        int swap1 = -1;\n        int swap2 = -1;\n        int rem = -1;\n        for (int i = 0; i < ch.length; i++) {\n            if (ch[i] != ch2[i]) {\n                if (hset[ch2[i] - 97].size() != 0) {\n                    swap1 = i;\n                    flag = true;\n                    if (hset[ch2[i] - 97].contains(ch[i] - 97)) {\n                        rem = i;\n                        count -= 2;\n                        flag = false;\n                        break;\n                    }\n                }\n            }\n        }\n        if (flag) {\n            count--;\n            w.println(count);\n            for (int i = 0; i < n; i++) {\n                if (i != swap1 && ch[i] == ch2[swap1] && ch[i] != ch2[i]) {\n                    w.println((swap1 + 1) + \" \" + (i + 1);\n                    w.close();\n                    System.exit(0);\n                }\n            }\n        } else {\n            if (rem == -1) {\n                w.println(count);\n                w.println(\"-1 -1\");\n            } else {\n                w.println(count);\n                for (int i = 0; i < n; i++) {\n                    if (i != rem && ch[i] == ch2[rem] && ch[rem] == ch2[i] && ch[i] != ch2[i]) {\n                        w.println((rem + 1) + \" \" + (i + 1));\n                        w.close();\n                        System.exit(0);\n                    }\n                }\n            }\n        w.close();\n    }\n    boolean fun(long[] prefix, long mid, long temp, long[] arr) {\n        if (temp >= prefix[(int) mid]) {\n            return true;\n        }\n        return false;\n    }\n    static class Pair implements Comparable<Pair> {\n        int x;\n        int y;\n        Pair() {}\n        Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        public int compareTo(Pair p) {\n            return Long.compare(this.x, p.x);\n        }\n    }\n}", "src": "public class Solution1 implements Runnable\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstatic final long MAX = 1000000007L;\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class InputReader\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate InputStream stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate byte[] buf = new byte[1024];\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int curChar;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int numChars;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate SpaceCharFilter filter;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic InputReader(InputStream stream)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.stream = stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int read()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (numChars==-1) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (curChar >= numChars)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String nextLine()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString str = \"\";\n\t\t\t\t\t\t\t\t\t\t\t            try\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                str = br.readLine();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            catch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                e.printStackTrace();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            return str;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int nextInt()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic long nextLong() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlong res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic double nextDouble() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble m = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm /= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String readString() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res.toString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int c) \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String next() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn readString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic interface SpaceCharFilter \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t \t\n\t\t\t\t\t\t\t\t\t\t\t\tpublic static void main(String args[]) throws Exception\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Thread(null, new Solution1(),\"Solution1\",1<<26).start();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tlong gcd(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t        if (a == 0)\n\t\t\t\t\t\t\t\t\t\t\t            return b;\n\t\t\t\t\t\t\t\t\t\t\t         \n\t\t\t\t\t\t\t\t\t\t\t        return gcd(b%a, a);\n\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t    \n\t\t\t\t\t\t\t\t\t\t\t\t long lcm(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t\t        return (a*b)/gcd(a, b);\n\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t int root(int a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t while(arr[a] != a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[a] = arr[arr[a]];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t a = arr[a];\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t\t return a;\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t void union(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int xroot = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int yroot = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(arr[xroot] < arr[yroot]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[xroot] = yroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[yroot] = xroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t boolean find(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int roota = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int rootb = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(roota == rootb){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t int[] arr;\n\t\t\t\t\t\t\t\t\t\t\t\t final int level = 20;\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\tpublic void run()\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tInputReader sc= new InputReader(System.in);\n\t\t\t\t\t\t\t\t\t\t\t\t\tPrintWriter w= new PrintWriter(System.out);\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n = sc.nextInt();\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch2 = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tch = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tch2 = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tHashSet<Integer> hset[] = new HashSet[26];\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < 26;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[i]  =new HashSet();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[ch[i]-97].add(ch2[i]-97);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tboolean flag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap1 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap2 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint rem = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].size() != 0){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswap1 = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].contains(ch[i]-97)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trem = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount-=2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(flag){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != swap1 && ch[i] == ch2[swap1] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((swap1+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(rem == -1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(\"-1 -1\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != rem && ch[i] == ch2[rem] && ch[rem] == ch2[i] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((rem+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tboolean fun(long[] prefix,long mid,long temp,long[] arr){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(temp >= prefix[(int)mid]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class Pair implements Comparable<Pair>{\n\t\t\t\t\t\t\t\t\t\t\t\t\tint x;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(){}\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(int x,int y){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int compareTo(Pair p){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn Long.compare(this.x,p.x);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}", "index": 372, "complexity": "1"}
{"back-translation": "class Main{static class Reader{private InputStream mIs;private byte[] buf=new byte[1024];private int curChar,numChars;public Reader(){this(System.in);}public Reader(InputStream is){mIs=is;}public int read(){if(numChars==-1)throw new InputMismatchException();if(curChar>=numChars){curChar=0;try{numChars=mIs.read(buf);}catch(IOException e){throw new InputMismatchException();}if(numChars<=0)return -1;}return buf[curChar++];}public String nextLine(){int c=read();while(isSpaceChar(c))c=read();StringBuilder res=new StringBuilder();do{res.appendCodePoint(c);c=read();}while(!isEndOfLine(c));return res.toString();}public String s(){int c=read();while(isSpaceChar(c))c=read();StringBuilder res=new StringBuilder();do{res.appendCodePoint(c);c=read();}while(!isSpaceChar(c));return res.toString();}public long l(){int c=read();while(isSpaceChar(c))c=read();int sgn=1;if(c=='-'){sgn=-1;c=read();}long res=0;do{if(c<'0'||c>'9')throw new InputMismatchException();res*=10;res+=c-'0';c=read();}while(!isSpaceChar(c));return res*sgn;}public int i(){int c=read();while(isSpaceChar(c))c=read();int sgn=1;if(c=='-'){sgn=-1;c=read();}int res=0;do{if(c<'0'||c>'9')throw new InputMismatchException();res*=10;res+=c-'0';c=read();}while(!isSpaceChar(c));return res*sgn;}public double d() throws IOException{return Double.parseDouble(s());}public boolean isSpaceChar(int c){return c==' '||c=='\\n'||c=='\\r'||c=='\\t'||c==-1;}public boolean isEndOfLine(int c){return c=='\\n'||c=='\\r'||c==-1;}}public static void main(String args[]){Reader sc=new Reader();PrintWriter out=new PrintWriter(System.out);int n=sc.i();String s1=sc.s();String s2=sc.s();int pos1=-1;int pos2=-1;int [][][]arr=new int[100][100][2];for(int i=0;i<n;i++){if(s1.charAt(i)!=s2.charAt(i)){if(arr[s2.charAt(i)-97][s1.charAt(i)-97][0]==1){pos2=i;pos1=arr[s2.charAt(i)-97][s1.charAt(i)-97][1];break;}arr[s1.charAt(i)-97][s2.charAt(i)-97][0]=1;arr[s1.charAt(i)-97][s2.charAt(i)-97][1]=i;}}int ham=0;for(int i=0;i<n;i++){if(s1.charAt(i)!=s2.charAt(i))ham++;}if(pos1!=-1&&pos2!=-1){System.out.println(ham-2);System.out.println(pos1+1+\" \"+(pos2+1));System.exit(0);}int [][]arr1=new int[100][2];int [][]arr2=new int[100][2];for(int i=0;i<n;i++){if(s1.charAt(i)!=s2.charAt(i)){if(arr1[s1.charAt(i)-97][0]==1){pos2=i;pos1=arr1[s1.charAt(i)-97][1];break;}if(arr2[s2.charAt(i)-97][0]==1){pos2=i;pos1=arr2[s2.charAt(i)-97][1];break;}arr1[s2.charAt(i)-97][0]=1;arr1[s2.charAt(i)-97][1]=i;arr2[s1.charAt(i)-97][0]=1;arr2[s1.charAt(i)-97][1]=i;}}if(pos1!=-1&&pos2!=-1){System.out.println(ham-1);System.out.println(pos1+1+\" \"+(pos2+1));System.exit(0);}System.out.println(ham);System.out.println(pos1+\" \"+pos2);}}", "src": "public class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n    } \n    \n    \n    \n    \n    public static void main(String args[])\n    {\n        Reader sc=new Reader();\n        PrintWriter out=new PrintWriter(System.out);\n        int n=sc.i();\n        String s1=sc.s();\n        String s2=sc.s();\n        int pos1=-1;\n        int pos2=-1;\n        int arr[][][]=new int[100][100][2];\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            {\n                if(arr[s2.charAt(i)-97][s1.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr[s2.charAt(i)-97][s1.charAt(i)-97][1];\n                    break;\n                }\n                arr[s1.charAt(i)-97][s2.charAt(i)-97][0]=1;\n                arr[s1.charAt(i)-97][s2.charAt(i)-97][1]=i;\n            }\n        }\n        int ham=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            ham++;\n        }\n        if(pos1!=-1&&pos2!=-1)\n        {\n            System.out.println(ham-2);\n            System.out.println(pos1+1+\" \"+(pos2+1));\n            System.exit(0);\n        }\n        \n        int arr1[][]=new int[100][2];\n        int arr2[][]=new int[100][2];\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            {\n                if(arr1[s1.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr1[s1.charAt(i)-97][1];\n                    break;\n                }\n                if(arr2[s2.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr2[s2.charAt(i)-97][1];\n                    break;\n                }\n                arr1[s2.charAt(i)-97][0]=1;\n                arr1[s2.charAt(i)-97][1]=i;\n                arr2[s1.charAt(i)-97][0]=1;\n                arr2[s1.charAt(i)-97][1]=i;\n            }\n        }\n        if(pos1!=-1&&pos2!=-1)\n        {\n            System.out.println(ham-1);\n            System.out.println(pos1+1+\" \"+(pos2+1));\n            System.exit(0);\n        }\n        System.out.println(ham);\n        System.out.println(pos1+\" \"+pos2);\n    }\n}", "index": 373, "complexity": "1"}
{"back-translation": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tint[] f = new int[n];\n\t\tint[] t = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = sc.nextInt();\n\t\t\tt[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(f, t, s));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] f, int[] t, int s) {\n\t\tint[] maxTimes = new int[s + 1];\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tmaxTimes[f[i]] = Math.max(maxTimes[f[i]], t[i]);\n\t\t}\n\n\t\tint time = 0;\n\t\tfor (int i = s; i > 0; i--) {\n\t\t\ttime = Math.max(time, maxTimes[i]);\n\n\t\t\ttime++;\n\t\t}\n\t\treturn time;\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tint[] f = new int[n];\n\t\tint[] t = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = sc.nextInt();\n\t\t\tt[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(f, t, s));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] f, int[] t, int s) {\n\t\tint[] maxTimes = new int[s + 1];\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tmaxTimes[f[i]] = Math.max(maxTimes[f[i]], t[i]);\n\t\t}\n\n\t\tint time = 0;\n\t\tfor (int i = s; i > 0; i--) {\n\t\t\ttime = Math.max(time, maxTimes[i]);\n\n\t\t\ttime++;\n\t\t}\n\t\treturn time;\n\t}\n}", "index": 374, "complexity": "1"}
{"back-translation": "public class Code {\n\n   static int [] reverse(int a[]) \n    { \n        int[] b = new int[a.length]; \n       int j = 0  ;\n        for (int i = a.length-1; i >= 0; i--) {\n            b[i] = a[j] ; \n            j++;\n        }\n        return b ;\n    }\n    public static void main(String[] args) {\n        int pas ; \n        int top ; \n        Scanner in = new Scanner(System.in) ; \n        pas= in.nextInt(); \n        top=in.nextInt() ; \n        int a [] = new int[pas] ; \n        int b [] = new int[pas] ; \n        \n        for (int i = 0; i < pas; i++) {\n            a[i] = in.nextInt() ; \n            b[i] = in.nextInt() ; \n           \n         }\n       a =  reverse(a) ;\n        b = reverse(b) ;\n        int ftime =0 ; \n        int t;\n        int po = top ; \n        for (int i = 0; i < pas; i++) {\n             ftime+=(po-a[i]) ; \n            t = Math.max(b[i]-ftime, 0) ; \n            ftime+=t ; \n            po = a[i] ; \n           \n        }\n        if(po!=0) ftime+=po ;\n        System.out.println(ftime);\n        \n    }\n    \n}", "src": "public class Code {\n\n   static int [] reverse(int a[]) \n    { \n        int[] b = new int[a.length]; \n       int j = 0  ;\n        for (int i = a.length-1; i >= 0; i--) {\n            b[i] = a[j] ; \n            j++;\n        }\n        return b ;\n    }\n    public static void main(String[] args) {\n        int pas ; \n        int top ; \n        Scanner in = new Scanner(System.in) ; \n        pas= in.nextInt(); \n        top=in.nextInt() ; \n        int a [] = new int[pas] ; \n        int b [] = new int[pas] ; \n        \n        for (int i = 0; i < pas; i++) {\n            a[i] = in.nextInt() ; \n            b[i] = in.nextInt() ; \n           \n         }\n       a =  reverse(a) ;\n        b = reverse(b) ;\n        int ftime =0 ; \n        int t;\n        int po = top ; \n        for (int i = 0; i < pas; i++) {\n             ftime+=(po-a[i]) ; \n            t = Math.max(b[i]-ftime, 0) ; \n            ftime+=t ; \n            po = a[i] ; \n           \n        }\n        if(po!=0) ftime+=po ;\n        System.out.println(ftime);\n        \n    }\n    \n}", "index": 375, "complexity": "1"}
{"back-translation": "class FindUnion {\n\n    static int printUnion(int arr1[], int arr2[], int m, int n) {\n\n        int i = 0, j = 0;\n\n        while(i < m && j < n) {\n\n            if(arr1[i] < arr2[j]) System.out.print(arr1[i++] + \" \");\n\n            else if(arr2[j] < arr1[i]) System.out.print(arr2[j++] + \" \");\n\n            else {\n\n                System.out.print(arr2[j++] + \" \");\n\n                i++;\n\n            }\n\n        }\n\n        while(i < m) System.out.print(arr1[i++] + \" \");\n\n        while(j < n) System.out.print(arr2[j++] + \" \");\n\n        return 0;\n\n    }\n\n    public static void main(String args[]) {\n\n        int arr1[] = { 1, 2, 4, 5, 6 };\n\n        int arr2[] = { 2, 3, 5, 7 };\n\n        int m = arr1.length;\n\n        int n = arr2.length;\n\n        printUnion(arr1, arr2, m, n);\n\n    }\n\n}", "src": "class\nFindUnion \n{ \n\n\n\nstatic\nint\nprintUnion(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nwhile\n(i < m && j < n) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n\n\n\nwhile\n(i < m) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nwhile\n(j < n) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintUnion(arr1, arr2, m, n); \n\n} \n}", "index": 376, "complexity": "1"}
{"back-translation": "public class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n\n        String a = scanner.nextLine(), b = scanner.nextLine();\n\n        int n = b.length(), m = a.length();\n\n        int p[] = new int[n];\n\n        p[0] = b.charAt(0) - '0';\n\n        for (int i = 1; i < n; i++) {\n            p[i] = p[i - 1] + (b.charAt(i) - '0');\n        }\n\n        long ans = 0;\n        for (int i = 0; i < m; i++) {\n            int cur = a.charAt(i) - '0';\n\n            int cnt = p[n - m + i] - (i > 0 ? p[i - 1] : 0);\n\n            if (cur == 0) {\n                ans += cnt;\n            } else {\n                ans += n - m + 1 - cnt;\n            }\n        }\n\n        System.out.println(ans);\n    }\n\n    class Pair {\n        int c, f;\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            return reader.readLine();\n        }\n    }\n}", "src": "public class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n\n        String a = scanner.nextLine(), b = scanner.nextLine();\n\n        int n = b.length(), m = a.length();\n\n        int p[] = new int[n];\n\n        p[0] = b.charAt(0) - '0';\n\n        for (int i = 1; i < n; i++) {\n            p[i] = p[i - 1] + (b.charAt(i) - '0');\n        }\n\n        long ans = 0;\n        for (int i = 0; i < m; i++) {\n            int cur = a.charAt(i) - '0';\n\n            int cnt = p[n - m + i] - (i > 0 ? p[i - 1] : 0);\n\n            if (cur == 0) {\n                ans += cnt;\n            } else {\n                ans += n - m + 1  - cnt;\n            }\n        }\n\n        System.out.println(ans);\n\n    }\n\n\n    class Pair {\n        int c, f;\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "index": 377, "complexity": "1"}
{"back-translation": "public class TransformedCodef8 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int num = sc.nextInt();\n        int[] beacon = new int[1000001];\n        for (int i = 0; i < num; i++) {\n            beacon[sc.nextInt()] = sc.nextInt();\n        }\n        int[] dp = new int[1000001];\n        int max = 1;\n        if (beacon[0] > 0) {\n            dp[0] = 1;\n        }\n\n        for (int i = 1; i <= 1000000; i++) {\n            if (beacon[i] == 0) {\n                dp[i] = dp[i - 1];\n            } else {\n                int b = beacon[i];\n                if (i <= b) {\n                    dp[i] = 1;\n                } else {\n                    dp[i] = dp[i - b - 1] + 1;\n                }\n            }\n            max = Math.max(max, dp[i]);\n        }\n        System.out.println(num - max);\n        sc.close();\n    }\n}", "src": "public class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint beacon[] = new int[1000001];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tbeacon[sc.nextInt()] = sc.nextInt();\n\t\t}\n\t\tint dp[] = new int[1000001];\n\t\tint max = 1;\n\t\tif (beacon[0] > 0) {\n\t\t\tdp[0] = 1;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} \n\t\t\telse {\n\t\t\t\tint b = beacon[i];\n\t\t\t\tif (i <= b) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = dp[i-b-1] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\t\t\n\t\tSystem.out.println(num-max);\n\t\tsc.close();\n\t}\n\n}", "index": 378, "complexity": "1"}
{"back-translation": "class FindUnion {\n\n    static void UnionArray(int[] arr1, int[] arr2) {\n\n        int m = arr1[arr1.length - 1];\n        int n = arr2[arr2.length - 1];\n        int ans = 0;\n\n        if (m > n) {\n            ans = m;\n        } else\n            ans = n;\n\n        int[] newtable = new int[ans + 1];\n\n        System.out.print(arr1[0] + \" \");\n        ++newtable[arr1[0]];\n\n        for (int i = 1; i < arr1.length; i++) {\n\n            if (arr1[i] != arr1[i - 1]) {\n                System.out.print(arr1[i] + \" \");\n                ++newtable[arr1[i]];\n            }\n        }\n\n        for (int j = 0; j < arr2.length; j++) {\n\n            if (newtable[arr2[j]] == 0) {\n                System.out.print(arr2[j] + \" \");\n                ++newtable[arr2[j]];\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n\n        int arr1[] = {1, 2, 2, 2, 3};\n        int arr2[] = {2, 3, 4, 5};\n\n        UnionArray(arr1, arr2);\n    }\n}", "src": "class\nFindUnion \n{ \n\n\nstatic\nvoid\nUnionArray(\nint\narr1[], \n\nint\narr2[]) \n\n{ \n\n\n\nint\nm = arr1[arr1.length - \n1\n]; \n\nint\nn = arr2[arr2.length - \n1\n]; \n\n\nint\nans = \n0\n; \n\n\nif\n(m > n) \n\n{ \n\nans = m; \n\n} \n\nelse\n\nans = n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nnewtable[] = \nnew\nint\n[ans + \n1\n]; \n\n\n\n\n\n\nSystem.out.print(arr1[\n0\n] + \n\" \"\n); \n\n\n\n\n\n\n++newtable[arr1[\n0\n]]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < arr1.length; i++) \n\n{ \n\n\n\n\n\nif\n(arr1[i] != arr1[i - \n1\n]) \n\n{ \n\nSystem.out.print(arr1[i] + \n\" \"\n); \n\n++newtable[arr1[i]]; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < arr2.length; j++) \n\n{ \n\n\n\n\n\nif\n(newtable[arr2[j]] == \n0\n) \n\n{ \n\nSystem.out.print(arr2[j] + \n\" \"\n); \n\n++newtable[arr2[j]]; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n4\n, \n5\n}; \n\n\nUnionArray(arr1, arr2); \n\n} \n}", "index": 379, "complexity": "1"}
{"back-translation": "ERROR", "src": "public class round569d2a {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint sum = 1;\n\t\tint tracker = 4;\n\t\twhile (n > 1) {\n\t\t\tsum += tracker;\n\t\t\ttracker += 4;\n\t\t\tn--;\n\t\t}\n\t\tSystem.out.println(sum);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 380, "complexity": "1"}
{"back-translation": "class Main { static InputReader in = new InputReader(System.in); static PrintWriter out = new PrintWriter(System.out); static long oo = 1000000000000L; static int[][] memo; public static void main(String[] args) throws IOException { int[] cnt = new int[101]; cnt[1] = 1; for(int i = 2; i <= 100; ++i) { cnt[i] = cnt[i - 1] + 4 * (i - 1); } int n = in.nextInt(); System.out.println(cnt[n]); out.close(); } static int maxHit(ArrayList<Integer> a, int p, int i) { if (i == a.size()) return 0; if (memo[p][i] != -1) return memo[p][i]; int ret = maxHit(a, p, i + 1); if (p == -1 || a.get(p) < a.get(i)) { ret = Math.max(ret, maxHit(a, i, i + 1)); } return memo[p][i] = ret; } static long lcm(long a, long b) { return a * b / gcd(a, b); } static boolean nextPermutation(int[] a) { for (int i = a.length - 2; i >= 0; --i) { if (a[i] < a[i + 1]) { for (int j = a.length - 1;; --j) { if (a[i] < a[j]) { int t = a[i]; a[i] = a[j]; a[j] = t; for (i++, j = a.length - 1; i < j; ++i, --j) { t = a[i]; a[i] = a[j]; a[j] = t; } return true; } } } } return false; } static void shuffle(int[] a) { Random r = new Random(); for (int i = a.length - 1; i > 0; --i) { int si = r.nextInt(i); int t = a[si]; a[si] = a[i]; a[i] = t; } } static void shuffle(long[] a) { Random r = new Random(); for (int i = a.length - 1; i > 0; --i) { int si = r.nextInt(i); long t = a[si]; a[si] = a[i]; a[i] = t; } } static int lower_bound(int[] a, int n, int k) { int s = 0; int e = n; int m; while (e - s > 0) { m = (s + e) / 2; if (a[m] < k) s = m + 1; else e = m; } return e; } static int lower_bound(long[] a, int n, long k) { int s = 0; int e = n; int m; while (e - s > 0) { m = (s + e) / 2; if (a[m] < k) s = m + 1; else e = m; } return e; } static int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } static long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); } static class Pair implements Comparable<Pair> { int first, second; public Pair(int first, int second) { super(); this.first = first; this.second = second; } @Override public int compareTo(Pair o) { return this.first != o.first ? this.first - o.first : this.second - o.second; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + first; result = prime * result + second; return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Pair other = (Pair) obj; if (first != other.first) return false; if (second != other.second) return false; return true; } } } class InputReader { private final InputStream stream; private final byte[] buf = new byte[8192]; private int curChar, snumChars; public InputReader(InputStream st) { this.stream = st; } public int read() { if (snumChars == -1) throw new InputMismatchException(); if (curChar >= snumChars) { curChar = 0; try { snumChars = stream.read(buf); } catch (IOException e) { throw new InputMismatchException(); } if (snumChars <= 0) return -1; } return buf[curChar++]; } public int nextInt() { int c = read(); while (isSpaceChar(c)) { c = read(); } int sgn = 1; if (c == '-') { sgn = -1; c = read(); } int res = 0; do { res *= 10; res += c - '0'; c = read(); } while (!isSpaceChar(c)); return res * sgn; } public long nextLong() { int c = read(); while (isSpaceChar(c)) { c = read(); } int sgn = 1; if (c == '-') { sgn = -1; c = read(); } long res = 0; do { res *= 10; res += c - '0'; c = read(); } while (!isSpaceChar(c)); return res * sgn; } public int[] nextIntArray(int n) { int a[] = new int[n]; for (int i = 0; i < n; i++) { a[i] = nextInt(); } return a; } public String readString() { int c = read(); while (isSpaceChar(c)) { c = read(); } StringBuilder res = new StringBuilder(); do { res.appendCodePoint(c); c = read(); } while (!isSpaceChar(c)); return res.toString(); } public String nextLine() { int c = read(); while (isSpaceChar(c)) c = read(); StringBuilder res = new StringBuilder(); do { res.appendCodePoint(c); c = read(); } while (!isEndOfLine(c)); return res.toString(); } public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } private boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } }", "src": "public class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint[] cnt = new int[101];\n\t\tcnt[1] = 1;\n\t\tfor(int i = 2; i <= 100; ++i) {\n\t\t\tcnt[i] = cnt[i-1] + 4 * (i - 1);\n\t\t}\n\t\tint n = in.nextInt();\n\t\tSystem.out.println( cnt[n] );\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic int maxHit(ArrayList<Integer> a, int p, int i) {\n\t\tif(i == a.size())\n\t\t\treturn 0;\n\t\tif(memo[p][i] != -1)\n\t\t\treturn memo[p][i];\n\t\tint ret = maxHit(a, p, i + 1);\n\t\tif(p == -1 || a.get(p) < a.get(i)) {\n\t\t\tret = Math.max(ret, maxHit(a, i, i + 1) );\n\t\t}\n\t\treturn memo[p][i] = ret;\n\t}\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "index": 381, "complexity": "1"}
{"back-translation": "public class Test{\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint num=1;\n\t\tint add=0;\n\t\tint i=1;\n\t\twhile(i<n){\n\t\t\tadd=4*i;\n\t\t\tnum+=add;\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(num);\n\t}\n}", "src": "public class Test{\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint num=1;\n\t\tint add;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tadd=4*i;\n\t\t\tnum+=add;\n\t\t}\n\t\tSystem.out.println(num);\n\t}\n}", "index": 382, "complexity": "1"}
{"back-translation": "class GFG { static int findRepeating(int[] arr, int n) { int res = 0; for (int i = 0; i < n - 1; i++) res = res ^ (i + 1) ^ arr[i]; res = res ^ arr[n - 1]; return res; } public static void main(String[] args) { int arr[] = { 9, 8, 2, 6, 1, 8, 5, 3, 4, 7 }; int n = arr.length; System.out.println(findRepeating(arr, n)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nfindRepeating(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nres = res ^ (i + \n1\n) ^ arr[i]; \n\nres = res ^ arr[n - \n1\n]; \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n9\n, \n8\n, \n2\n, \n6\n, \n1\n, \n8\n, \n5\n, \n3\n, \n4\n, \n7\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findRepeating(arr, n)); \n\n} \n}", "index": 383, "complexity": "1"}
{"back-translation": "class MajorityElement {\n\n    private static void findMajority(int[] arr) {\n\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\n        for (int i = 0; i < arr.length; i++) {\n\n            if (map.containsKey(arr[i])) {\n\n                int count = map.get(arr[i]) + 1;\n\n                if (count > arr.length / 2) {\n\n                    System.out.println(\"Majority found :- \" + arr[i]);\n                    return;\n                }\n                else\n                    map.put(arr[i], count);\n            }\n            else\n                map.put(arr[i], 1);\n        }\n\n        System.out.println(\" No Majority element\");\n    }\n\n    public static void main(String[] args) {\n\n        int a[] = new int[]{2, 2, 2, 2, 5, 5, 2, 3, 3};\n\n        findMajority(a);\n    }\n}", "src": "class\nMajorityElement \n{ \n\nprivate\nstatic\nvoid\nfindMajority(\nint\n[] arr) \n\n{ \n\nHashMap<Integer,Integer> map = \nnew\nHashMap<Integer, Integer>(); \n\n\nfor\n(\nint\ni = \n0\n; i < arr.length; i++) { \n\nif\n(map.containsKey(arr[i])) { \n\nint\ncount = map.get(arr[i]) +\n1\n; \n\nif\n(count > arr.length /\n2\n) { \n\nSystem.out.println(\n\"Majority found :- \"\n+ arr[i]); \n\nreturn\n; \n\n} \nelse\n\nmap.put(arr[i], count); \n\n\n} \n\nelse\n\nmap.put(arr[i],\n1\n); \n\n} \n\nSystem.out.println(\n\" No Majority element\"\n); \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = \nnew\nint\n[]{\n2\n,\n2\n,\n2\n,\n2\n,\n5\n,\n5\n,\n2\n,\n3\n,\n3\n}; \n\n\nfindMajority(a); \n\n} \n}", "index": 384, "complexity": "1"}
{"back-translation": "class GFG { static int maxTripletSum(int arr[], int n) { int maxA = -100000000, maxB = -100000000; int maxC = -100000000; for (int i = 0; i < n; i++) { if (arr[i] > maxA) { maxC = maxB; maxB = maxA; maxA = arr[i]; } else if (arr[i] > maxB) { maxC = maxB; maxB = arr[i]; } else if (arr[i] > maxC) maxC = arr[i]; } return (maxA + maxB + maxC); } public static void main(String args[]) { int arr[] = { 1, 0, 8, 6, 4, 2 }; int n = arr.length; System.out.println(maxTripletSum(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxTripletSum(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\nmaxA = -\n100000000\n, maxB = -\n100000000\n; \n\nint\nmaxC = -\n100000000\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n(arr[i] > maxA) \n\n{ \n\nmaxC = maxB; \n\nmaxB = maxA; \n\nmaxA = arr[i]; \n\n} \n\n\n\n\n\n\nelse\nif\n(arr[i] > maxB) \n\n{ \n\nmaxC = maxB; \n\nmaxB = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > maxC) \n\nmaxC = arr[i]; \n\n} \n\n\nreturn\n(maxA + maxB + maxC); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n0\n, \n8\n, \n6\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxTripletSum(arr, n)); \n\n} \n}", "index": 385, "complexity": "1"}
{"back-translation": "class LinkedList {\n\nNode head;\n\n\nNode left;\n\n\n\n\nclass Node {\n\nchar data;\n\nNode next;\n\n\nNode(char d) {\n\ndata = d;\n\nnext = null;\n\n}\n\n}\n\n\n\n\nboolean isPalindromeUtil(Node right) {\n\nleft = head;\n\n\n\n\nif(right == null)\n\nreturn true;\n\n\n\nboolean isp = isPalindromeUtil(right.next);\n\nif(isp == false)\n\nreturn false;\n\n\n\nboolean isp1 = (right.data == (left).data);\n\n\n\nleft = left.next;\n\nreturn isp1;\n\n}\n\n\n\n\nboolean isPalindrome(Node head) {\n\nboolean result = isPalindromeUtil(head);\n\nreturn result;\n\n}\n\n\n\n\npublic void push(char new_data) {\n\n\n\nNode new_node = new Node(new_data);\n\n\n\n\nnew_node.next = head;\n\n\n\n\nhead = new_node;\n\n}\n\n\n\n\nvoid printList(Node ptr) {\n\nwhile(ptr != null) {\n\nSystem.out.print(ptr.data + \"->\");\n\nptr = ptr.next;\n\n}\n\nSystem.out.println(\"NULL\");\n\n}\n\n\n\n\npublic static void main(String[] args) {\n\n\n\nLinkedList llist = new LinkedList();\n\n\nchar str[] = { 'a', 'b', 'a', 'c', 'a', 'b', 'a' };\n\nString string = new String(str);\n\nfor(int i = 0; i < 7; i++) {\n\nllist.push(str[i]);\n\nllist.printList(llist.head);\n\nif(llist.isPalindrome(llist.head) != false) {\n\nSystem.out.println(\"Is Palindrome\");\n\nSystem.out.println(\"\");\n\n}\n\nelse {\n\nSystem.out.println(\"Not Palindrome\");\n\nSystem.out.println(\"\");\n\n}\n\n}\n\n}\n}", "src": "class\nLinkedList { \n\nNode head; \n\n\nNode left; \n\n\n\n\nclass\nNode { \n\nchar\ndata; \n\nNode next; \n\n\nNode(\nchar\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n\n\nboolean\nisPalindromeUtil(Node right) \n\n{ \n\nleft = head; \n\n\n\n\nif\n(right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nboolean\nisp = isPalindromeUtil(right.next); \n\nif\n(isp == \nfalse\n) \n\nreturn\nfalse\n; \n\n\n\n\nboolean\nisp1 = (right.data == (left).data); \n\n\n\n\nleft = left.next; \n\n\nreturn\nisp1; \n\n} \n\n\n\n\nboolean\nisPalindrome(Node head) \n\n{ \n\nboolean\nresult = isPalindromeUtil(head); \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nvoid\npush(\nchar\nnew_data) \n\n{ \n\n\n\nNode new_node = \nnew\nNode(new_data); \n\n\n\n\nnew_node.next = head; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\nvoid\nprintList(Node ptr) \n\n{ \n\nwhile\n(ptr != \nnull\n) { \n\nSystem.out.print(ptr.data + \n\"->\"\n); \n\nptr = ptr.next; \n\n} \n\nSystem.out.println(\n\"NULL\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nLinkedList llist = \nnew\nLinkedList(); \n\n\nchar\nstr[] = { \n'a'\n, \n'b'\n, \n'a'\n, \n'c'\n, \n'a'\n, \n'b'\n, \n'a'\n}; \n\nString string = \nnew\nString(str); \n\nfor\n(\nint\ni = \n0\n; i < \n7\n; i++) { \n\nllist.push(str[i]); \n\nllist.printList(llist.head); \n\nif\n(llist.isPalindrome(llist.head) != \nfalse\n) { \n\nSystem.out.println(\n\"Is Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"Not Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n} \n\n} \n}", "index": 386, "complexity": "1"}
{"back-translation": "public class GFG { static int maxSum(int[] arr, int n) { int sum = 0; int i; int pivot = findPivot(arr, n); int diff = n - 1 - pivot; for (i = 0; i < n; i++) sum = sum + ((i + diff) % n) * arr[i]; return sum; } static int findPivot(int[] arr, int n) { int i; for (i = 0; i < n; i++) { if (arr[i] > arr[(i + 1) % n]) return i; } return 0; } public static void main(String args[]) { int arr[] = { 8, 3, 1, 2 }; int n = arr.length; int max = maxSum(arr, n); System.out.println(max); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nsum = \n0\n; \n\nint\ni; \n\nint\npivot = findPivot(arr, n); \n\n\n\n\n\n\nint\ndiff = n - \n1\n- pivot; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nsum= sum + ((i + diff) % n) * arr[i]; \n\n} \n\nreturn\nsum; \n} \n\n\nstatic\nint\nfindPivot(\nint\narr[], \nint\nn) \n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] > arr[(i + \n1\n) % n]) \n\nreturn\ni; \n\n} \n\nreturn\n0\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nmax = maxSum(arr,n); \n\nSystem.out.println(max); \n\n} \n}", "index": 387, "complexity": "1"}
{"back-translation": "public class GFG { static final int MAX_CHAR = 26; static int countSubstringWithEqualEnds(String s) { int result = 0; int n = s.length(); int[] count = new int[MAX_CHAR]; for (int i = 0; i < n; i++) count[s.charAt(i)-'a']++; for (int i = 0; i < MAX_CHAR; i++) result += (count[i] * (count[i] + 1) / 2); return result; } public static void main(String args[]) { String s = \"abcab\"; System.out.println(countSubstringWithEqualEnds(s)); } }", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\n\n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[s.charAt(i)-\n'a'\n]++; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nresult += (count[i] * (count[i] + \n1\n) / \n2\n); \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 388, "complexity": "1"}
{"back-translation": "class GFG { static long binomialCoeff(int n, int k) { long res = 1; if (k > n - k) { k = n - k; } for (int i = 0; i < k; ++i) { res *= (n - i); res /= (i + 1); } return res; } static long catalan(int n) { long c = binomialCoeff(2 * n, n); return c / (n + 1); } public static void main(String[] args) { for (int i = 0; i < 10; i++) { System.out.print(catalan(i) + \" \"); } } }", "src": "class\nGFG { \n\n\n\nstatic\nlong\nbinomialCoeff(\nint\nn, \nint\nk) { \n\nlong\nres = \n1\n; \n\n\n\n\nif\n(k > n - k) { \n\nk = n - k; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < k; ++i) { \n\nres *= (n - i); \n\nres /= (i + \n1\n); \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\nstatic\nlong\ncatalan(\nint\nn) { \n\n\n\nlong\nc = binomialCoeff(\n2\n* n, n); \n\n\n\n\nreturn\nc / (n + \n1\n); \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalan(i) + \n\" \"\n); \n\n} \n\n\n} \n}", "index": 389, "complexity": "1"}
{"back-translation": "class GFG { static int PermutationCoeff(int n, int k) { int Fn = 1, Fk = 1; for (int i = 1; i <= n; i++) { Fn *= i; if (i == n - k) Fk = Fn; } int coeff = Fn / Fk; return coeff; } public static void main(String args[]) { int n = 10, k = 2; System.out.println(\"Value of P( \" + n + \",\" + k + \") is \" + PermutationCoeff(n, k)); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nPermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nFn = \n1\n, Fk = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\nFn *= i; \n\nif\n(i == n - k) \n\nFk = Fn; \n\n} \n\nint\ncoeff = Fn / Fk; \n\nreturn\ncoeff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ \n\nk +\n\") is \"\n+ \n\nPermutationCoeff(n, k) ); \n\n} \n}", "index": 390, "complexity": "1"}
{"back-translation": "class GFG { static int countFriendsPairings(int n) { int a = 1, b = 2, c = 0; if (n <= 2) { return n; } for (int i = 3; i <= n; i++) { c = b + (i - 1) * a; a = b; b = c; } return c; } public static void main(String[] args) { int n = 4; System.out.println(countFriendsPairings(n)); } }", "src": "class\nGFG { \n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\na = \n1\n, b = \n2\n, c = \n0\n; \n\nif\n(n <= \n2\n) { \n\nreturn\nn; \n\n} \n\nfor\n(\nint\ni = \n3\n; i <= n; i++) { \n\nc = b + (i - \n1\n) * a; \n\na = b; \n\nb = c; \n\n} \n\nreturn\nc; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}", "index": 391, "complexity": "1"}
{"back-translation": "class GFG { static int countSeq(int n) { int nCr = 1, res = 1; for (int r = 1; r <= n; r++) { nCr = (nCr * (n + 1 - r)) / r; res += nCr * nCr; } return res; } public static void main(String args[]) { int n = 2; System.out.print(\"Count of sequences is \"); System.out.println(countSeq(n)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\nstatic\nint\ncountSeq(\nint\nn) \n{ \n\nint\nnCr = \n1\n, res = \n1\n; \n\n\n\n\nfor\n(\nint\nr = \n1\n; r <= n ; r++) \n\n{ \n\n\n\n\n\nnCr = (nCr * (n + \n1\n- r)) / r; \n\n\nres += nCr * nCr; \n\n} \n\n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.print(\n\"Count of sequences is \"\n); \n\nSystem.out.println(countSeq(n)); \n} \n}", "index": 392, "complexity": "1"}
{"back-translation": "class GFG { static void rearrange(int arr[], int n) { for (int i = 0; i < n; i++) { arr[arr[i] % n] += i * n; } for (int i = 0; i < n; i++) { arr[i] /= n; } } static void printArray(int arr[], int n) { for (int i = 0; i < n; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); } public static void main(String[] args) { int arr[] = { 2, 0, 1, 4, 5, 3 }; int n = arr.length; System.out.println(\"Given array is : \"); printArray(arr, n); rearrange(arr, n); System.out.println(\"Modified array is :\"); printArray(arr, n); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\narr[arr[i] % n] += i * n; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\narr[i] /= n; \n\n} \n\n} \n\n\n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is : \"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is :\"\n); \n\nprintArray(arr, n); \n\n} \n}", "index": 393, "complexity": "1"}
{"back-translation": "class GFG { static void findElements(int[] arr, int n) { int first = Integer.MIN_VALUE; int second = Integer.MAX_VALUE; for (int i = 0; i < n; i++) { if (arr[i] > first) { second = first; first = arr[i]; } else if (arr[i] > second) second = arr[i]; } for (int i = 0; i < n; i++) if (arr[i] < second) System.out.print(arr[i] + \" \") ; } public static void main(String args[]) { int arr[] = { 2, -6, 3, 5, 1 }; int n = arr.length; findElements(arr, n); } }", "src": "class\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nint\nfirst = Integer.MIN_VALUE; \n\nint\nsecond = Integer.MAX_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second) \n\nsecond = arr[i]; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < second) \n\nSystem.out.print(arr[i] + \n\" \"\n) ; \n} \n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n} \n}", "index": 394, "complexity": "1"}
{"back-translation": "class GFG {\n\n public static int smallestSubWithSum(int arr[], int n, int x) {\n\n int curr_sum = 0, min_len = n + 1;\n\n int start = 0, end = 0;\n\n while (end < n) {\n\n while (curr_sum <= x && end < n) {\n\n if (curr_sum <= 0 && x > 0) {\n\n start = end;\n\n curr_sum = 0;\n\n }\n\n curr_sum += arr[end++];\n\n }\n\n while (curr_sum > x && start < n) {\n\n if (end - start < min_len) {\n\n min_len = end - start;\n\n }\n\n curr_sum -= arr[start++];\n\n }\n\n }\n\n return min_len;\n }\n\n public static void main(String[] args) {\n\n int arr1[] = {- 8, 1, 4, 2, -6};\n\n int x = 6;\n\n int n1 = arr1.length;\n\n int res1 = smallestSubWithSum(arr1, n1, x);\n\n if (res1 == n1 + 1) {\n\n System.out.println(\"Not possible\");\n\n } else {\n\n System.out.println(res1);\n\n }\n }\n\n}", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \n\nint\nn, \nint\nx) \n{ \n\n\n\n\n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n\n\n\n\nint\nstart = \n0\n, end = \n0\n; \n\nwhile\n(end < n) \n\n{ \n\n\n\n\n\n\n\nwhile\n(curr_sum <= x && end < n) \n\n{ \n\n\n\n\n\n\n\nif\n(curr_sum <= \n0\n&& x > \n0\n) \n\n{ \n\nstart = end; \n\ncurr_sum = \n0\n; \n\n} \n\n\ncurr_sum += arr[end++]; \n\n} \n\n\n\n\n\n\nwhile\n(curr_sum > x && start < n) \n\n{ \n\n\n\n\n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n\n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\narr1[] = {- \n8\n, \n1\n, \n4\n, \n2\n, -\n6\n}; \n\nint\nx = \n6\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, \n\nn1, x); \n\nif\n(res1 == n1 + \n1\n) \n\nSystem.out.println(\n\"Not possible\"\n); \n\nelse\n\nSystem.out.println (res1); \n} \n}", "index": 395, "complexity": "1"}
{"back-translation": "class FindIntersection { static void printIntersection(int arr1[], int arr2[], int m, int n) { int i = 0, j = 0; while (i < m && j < n) { if (arr1[i] < arr2[j]) i++; else if (arr2[j] < arr1[i]) j++; else { System.out.print(arr2[j++] + \" \"); i++; } } } public static void main(String args[]) { int arr1[] = {1, 2, 4, 5, 6}; int arr2[] = {2, 3, 5, 7}; int m = arr1.length; int n = arr2.length; printIntersection(arr1, arr2, m, n); } }", "src": "class\nFindIntersection \n{ \n\n\n\nstatic\nvoid\nprintIntersection(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nwhile\n(i < m && j < n) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\ni++; \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nj++; \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintIntersection(arr1, arr2, m, n); \n\n} \n}", "index": 396, "complexity": "1"}
{"back-translation": "class RotateArray {\n\n    void leftRotate(int arr[], int d, int n) {\n        for (int i = 0; i < d; i++) {\n            leftRotatebyOne(arr, n);\n        }\n    }\n\n    void leftRotatebyOne(int arr[], int n) {\n        int i, temp;\n        temp = arr[0];\n        for (i = 0; i < n - 1; i++) {\n            arr[i] = arr[i + 1];\n        }\n        arr[i] = temp;\n    }\n\n    void printArray(int arr[], int n) {\n        for (int i = 0; i < n; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n\n    public static void main(String[] args) {\n        RotateArray rotate = new RotateArray();\n        int arr[] = {1, 2, 3, 4, 5, 6, 7};\n        rotate.leftRotate(arr, 2, 7);\n        rotate.printArray(arr, 7);\n    }\n}", "src": "class\nRotateArray { \n\n\n\nvoid\nleftRotate(\nint\narr[], \nint\nd, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < d; i++) \n\nleftRotatebyOne(arr, n); \n\n} \n\n\nvoid\nleftRotatebyOne(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, temp; \n\ntemp = arr[\n0\n]; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\narr[i] = arr[i + \n1\n]; \n\narr[i] = temp; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRotateArray rotate = \nnew\nRotateArray(); \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nrotate.leftRotate(arr, \n2\n, \n7\n); \n\nrotate.printArray(arr, \n7\n); \n\n} \n}", "index": 397, "complexity": "3"}
{"back-translation": "class CountTriangles { static int findNumberOfTriangles(int arr[]) { int n = arr.length; Arrays.sort(arr); int count = 0; for (int i = 0; i < n-2; ++i) { int k = i + 2; for (int j = i+1; j < n; ++j) { while (k < n && arr[i] + arr[j] > arr[k]) ++k; if (k>j) count += k - j - 1; } } return count; } public static void main (String[] args) { int arr[] = {10, 21, 22, 100, 101, 200, 300}; System.out.println(\"Total number of triangles is \"+ findNumberOfTriangles(arr)); } }", "src": "class\nCountTriangles \n{ \n\n\n\n\n\nstatic\nint\nfindNumberOfTriangles(\nint\narr[]) \n\n{ \n\nint\nn = arr.length; \n\n\n\nArrays.sort(arr); \n\n\n\n\nint\ncount = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n-\n2\n; ++i) \n\n{ \n\n\n\nint\nk = i + \n2\n; \n\n\n\n\nfor\n(\nint\nj = i+\n1\n; j < n; ++j) \n\n{ \n\n\n\nwhile\n(k < n && arr[i] + arr[j] > arr[k]) \n\n++k; \n\n\n\n\nif\n(k>j) \n\ncount += k - j - \n1\n; \n\n} \n\n} \n\nreturn\ncount; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n21\n, \n22\n, \n100\n, \n101\n, \n200\n, \n300\n}; \n\nSystem.out.println(\n\"Total number of triangles is \"\n+ \n\nfindNumberOfTriangles(arr)); \n\n} \n}", "index": 398, "complexity": "3"}
{"back-translation": "class GFG { static int countPairsWithDiffK(int arr[], int n, int k) { int count = 0; for (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) if (arr[i] - arr[j] == k || arr[j] - arr[i] == k) count++; } return count; } public static void main(String args[]) { int arr[] = { 1, 5, 3, 4, 2 }; int n = arr.length; int k = 3; System.out.println(\"Count of pairs with given diff is \" + countPairsWithDiffK(arr, n, k)); } }", "src": "class\nGFG { \n\n\nstatic\nint\ncountPairsWithDiffK(\nint\narr[], \n\nint\nn, \nint\nk) \n\n{ \n\nint\ncount = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\nif\n(arr[i] - arr[j] == k || \n\narr[j] - arr[i] == k) \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n5\n, \n3\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Count of pairs with given diff is \"\n\n+ countPairsWithDiffK(arr, n, k)); \n\n} \n}", "index": 399, "complexity": "3"}
{"back-translation": "class Test { static int arr1[] = new int[]{1, 5, 9, 10, 15, 20}; static int arr2[] = new int[]{2, 3, 8, 13}; static void merge(int m, int n) { for (int i = n - 1; i >= 0; i--) { int j, last = arr1[m - 1]; for (j = m - 2; j >= 0 && arr1[j] > arr2[i]; j--) arr1[j + 1] = arr1[j]; if (j != m - 2 || last > arr2[i]) { arr1[j + 1] = arr2[i]; arr2[i] = last; } } } public static void main(String[] args) { merge(arr1.length, arr2.length); System.out.print(\"After Merging First Array: \"); System.out.println(Arrays.toString(arr1)); System.out.print(\"Second Array: \"); System.out.println(Arrays.toString(arr2)); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n1\n, \n5\n, \n9\n, \n10\n, \n15\n, \n20\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n2\n, \n3\n, \n8\n, \n13\n}; \n\n\nstatic\nvoid\nmerge(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\nfor\n(\nint\ni=n-\n1\n; i>=\n0\n; i--) \n\n{ \n\n\n\nint\nj, last = arr1[m-\n1\n]; \n\nfor\n(j=m-\n2\n; j >= \n0\n&& arr1[j] > arr2[i]; j--) \n\narr1[j+\n1\n] = arr1[j]; \n\n\n\n\nif\n(j != m-\n2\n|| last > arr2[i]) \n\n{ \n\narr1[j+\n1\n] = arr2[i]; \n\narr2[i] = last; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nmerge(arr1.length,arr2.length); \n\nSystem.out.print(\n\"After Merging nFirst Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr1)); \n\nSystem.out.print(\n\"Second Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr2)); \n\n} \n}", "index": 400, "complexity": "3"}
{"back-translation": "public class GFG { static boolean isPresent(int B[], int m, int x) { for (int i = 0; i < m; i++) if (B[i] == x) return true; return false; } static int findMaxSubarraySumUtil(int A[], int B[], int n, int m) { int max_so_far = -2147483648, curr_max = 0; for (int i = 0; i < n; i++) { if (isPresent(B, m, A[i])) { curr_max = 0; continue; } curr_max = Math.max(A[i], curr_max + A[i]); max_so_far = Math.max(max_so_far, curr_max); } return max_so_far; } static void findMaxSubarraySum(int A[], int B[], int n, int m) { int maxSubarraySum = findMaxSubarraySumUtil(A, B, n, m); if (maxSubarraySum == -2147483648) { System.out.println(\"Maximum Subarray Sum\" + \" \" + \"can't be found\"); } else { System.out.println(\"The Maximum Subarray Sum = \" + maxSubarraySum); } } public static void main(String[] args) { int A[] = { 3, 4, 5, -4, 6 }; int B[] = { 1, 8, 5 }; int n = A.length; int m = B.length; findMaxSubarraySum(A, B, n, m); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nisPresent(\nint\nB[], \n\nint\nm, \n\nint\nx) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(B[i] == x) \n\nreturn\ntrue\n; \n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxSubarraySumUtil(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\n\nint\nmax_so_far = -\n2147483648\n, curr_max = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\nif\n(isPresent(B, m, A[i])) { \n\ncurr_max = \n0\n; \n\ncontinue\n; \n\n} \n\n\n\n\ncurr_max = Math.max(A[i], curr_max + A[i]); \n\nmax_so_far = Math.max(max_so_far, curr_max); \n\n} \n\nreturn\nmax_so_far; \n\n} \n\n\n\n\nstatic\nvoid\nfindMaxSubarraySum(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\nint\nmaxSubarraySum = findMaxSubarraySumUtil(A, B, \n\nn, m); \n\n\n\n\n\n\n\n\nif\n(maxSubarraySum == -\n2147483648\n) { \n\nSystem.out.println(\n\"Maximum Subarray Sum\"\n\n+ \n\" \"\n+ \n\"can't be found\"\n); \n\n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"The Maximum Subarray Sum = \"\n\n+ maxSubarraySum); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\nA[] = { \n3\n, \n4\n, \n5\n, -\n4\n, \n6\n}; \n\nint\nB[] = { \n1\n, \n8\n, \n5\n}; \n\n\nint\nn = A.length; \n\nint\nm = B.length; \n\n\n\n\nfindMaxSubarraySum(A, B, n, m); \n\n} \n}", "index": 401, "complexity": "3"}
{"back-translation": "class GFG {static int findMaxSum(int[] arr, int n) {int res = Integer.MIN_VALUE;for (int i = 0; i < n; i++) {int prefix_sum = arr[i];for (int j = 0; j < i; j++) prefix_sum += arr[j];int suffix_sum = arr[i];for (int j = n - 1; j > i; j--) suffix_sum += arr[j];if (prefix_sum == suffix_sum) res = Math.max(res, prefix_sum);}return res;}public static void main(String[] args) {int arr[] = {-2, 5, 3, 1, 2, 6, -4, 2};int n = arr.length;System.out.println(findMaxSum(arr, n));}}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMaxSum(\nint\n[]arr, \nint\nn) \n\n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\nprefix_sum = arr[i]; \n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nprefix_sum += arr[j]; \n\n\nint\nsuffix_sum = arr[i]; \n\n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nsuffix_sum += arr[j]; \n\n\nif\n(prefix_sum == suffix_sum) \n\nres = Math.max(res, prefix_sum); \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {-\n2\n, \n5\n, \n3\n, \n1\n, \n2\n, \n6\n, -\n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findMaxSum(arr, n)); \n\n} \n}", "index": 402, "complexity": "3"}
{"back-translation": "class EquilibriumIndex {\n\n    int equilibrium(int arr[], int n) {\n        int i, j;\n        int leftsum, rightsum;\n\n        for (i = 0; i < n; ++i) {\n            leftsum = 0;\n            for (j = 0; j < i; j++)\n                leftsum += arr[j];\n\n            rightsum = 0;\n            for (j = i + 1; j < n; j++)\n                rightsum += arr[j];\n\n            if (leftsum == rightsum)\n                return i;\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        EquilibriumIndex equi = new EquilibriumIndex();\n        int arr[] = { -7, 1, 5, 2, -4, 3, 0 };\n        int arr_size = arr.length;\n        System.out.println(equi.equilibrium(arr, arr_size));\n    }\n}", "src": "class\nEquilibriumIndex { \n\nint\nequilibrium(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\nleftsum, rightsum; \n\n\n\n\nfor\n(i = \n0\n; i < n; ++i) { \n\n\n\n\nleftsum = \n0\n; \n\nfor\n(j = \n0\n; j < i; j++) \n\nleftsum += arr[j]; \n\n\n\n\nrightsum = \n0\n; \n\nfor\n(j = i + \n1\n; j < n; j++) \n\nrightsum += arr[j]; \n\n\n\n\nif\n(leftsum == rightsum) \n\nreturn\ni; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nEquilibriumIndex equi = \nnew\nEquilibriumIndex(); \n\nint\narr[] = { -\n7\n, \n1\n, \n5\n, \n2\n, -\n4\n, \n3\n, \n0\n}; \n\nint\narr_size = arr.length; \n\nSystem.out.println(equi.equilibrium(arr, arr_size)); \n\n} \n}", "index": 403, "complexity": "3"}
{"back-translation": "class LeadersInArray {\n\nvoid printLeaders(int arr[], int size) {\nfor (int i = 0; i < size; i++) {\nint j;\nfor (j = i + 1; j < size; j++) {\nif (arr[i] <= arr[j])\nbreak;\n}\nif (j == size)\nSystem.out.print(arr[i] + \" \");\n}\n}\n\npublic static void main(String[] args) {\nLeadersInArray lead = new LeadersInArray();\nint arr[] = new int[]{16, 17, 4, 3, 5, 2};\nint n = arr.length;\nlead.printLeaders(arr, n);\n}\n}", "src": "class\nLeadersInArray \n{ \n\n\n\nvoid\nprintLeaders(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nint\nj; \n\nfor\n(j = i + \n1\n; j < size; j++) \n\n{ \n\nif\n(arr[i] <= arr[j]) \n\nbreak\n; \n\n} \n\nif\n(j == size) \n\n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nLeadersInArray lead = \nnew\nLeadersInArray(); \n\nint\narr[] = \nnew\nint\n[]{\n16\n, \n17\n, \n4\n, \n3\n, \n5\n, \n2\n}; \n\nint\nn = arr.length; \n\nlead.printLeaders(arr, n); \n\n} \n}", "index": 404, "complexity": "3"}
{"back-translation": "class GFG { static void findMajority(int arr[], int n) { int maxCount = 0; int index = -1; for (int i = 0; i < n; i++) { int count = 0; for (int j = 0; j < n; j++) { if (arr[i] == arr[j]) count++; } if (count > maxCount) { maxCount = count; index = i; } } if (maxCount > n/2) System.out.println (arr[index]); else System.out.println (\"No Majority Element\"); } public static void main(String[] args) { int arr[] = {1, 1, 2, 1, 3, 5, 1}; int n = arr.length; findMajority(arr, n); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nfindMajority(\nint\narr[], \nint\nn) \n{ \n\nint\nmaxCount = \n0\n; \n\nint\nindex = -\n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nif\n(arr[i] == arr[j]) \n\ncount++; \n\n} \n\n\n\n\n\n\nif\n(count > maxCount) \n\n{ \n\nmaxCount = count; \n\nindex = i; \n\n} \n\n} \n\n\n\n\n\n\nif\n(maxCount > n/\n2\n) \n\nSystem.out.println (arr[index]); \n\n\nelse\n\nSystem.out.println (\n\"No Majority Element\"\n); \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n1\n, \n1\n, \n2\n, \n1\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n\n\nfindMajority(arr, n); \n\n} \n\n}", "index": 405, "complexity": "3"}
{"back-translation": "class SubarraySum {\n\n    int subArraySum(int arr[], int n, int sum) {\n        int curr_sum, i, j;\n\n        for (i = 0; i < n; i++) {\n            curr_sum = arr[i];\n\n            for (j = i + 1; j < n; j++) {\n                if (curr_sum == sum) {\n                    int p = j - 1;\n                    System.out.println(\"Sum found between indexes \" + i + \" and \" + p);\n                    return 1;\n                }\n\n                if (curr_sum > sum || j == n) break;\n\n                curr_sum = curr_sum + arr[j];\n            }\n        }\n\n        System.out.println(\"No subarray found\");\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        SubarraySum arraysum = new SubarraySum();\n        int arr[] = {15, 2, 4, 8, 9, 5, 10, 23};\n        int n = arr.length;\n        int sum = 23;\n        arraysum.subArraySum(arr, n, sum);\n    }\n}", "src": "class\nSubarraySum \n{ \n\n\n\nint\nsubArraySum(\nint\narr[], \nint\nn, \nint\nsum) \n\n{ \n\nint\ncurr_sum, i, j; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\ncurr_sum = arr[i]; \n\n\n\n\nfor\n(j = i + \n1\n; j <= n; j++) \n\n{ \n\nif\n(curr_sum == sum) \n\n{ \n\nint\np = j - \n1\n; \n\nSystem.out.println(\n\"Sum found between indexes \"\n+ i \n\n+ \n\" and \"\n+ p); \n\nreturn\n1\n; \n\n} \n\nif\n(curr_sum > sum || j == n) \n\nbreak\n; \n\ncurr_sum = curr_sum + arr[j]; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No subarray found\"\n); \n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSubarraySum arraysum = \nnew\nSubarraySum(); \n\nint\narr[] = {\n15\n, \n2\n, \n4\n, \n8\n, \n9\n, \n5\n, \n10\n, \n23\n}; \n\nint\nn = arr.length; \n\nint\nsum = \n23\n; \n\narraysum.subArraySum(arr, n, sum); \n\n} \n}", "index": 406, "complexity": "3"}
{"back-translation": "class FindTriplet { boolean find3Numbers(int A[], int arr_size, int sum) { int l, r; quickSort(A, 0, arr_size - 1); for (int i = 0; i < arr_size - 2; i++) { l = i + 1; r = arr_size - 1; while (l < r) { if (A[i] + A[l] + A[r] == sum) { System.out.print(\"Triplet is \" + A[i] + \", \" + A[l] + \", \" + A[r]); return true; } else if (A[i] + A[l] + A[r] < sum) l++; else r--; } } return false; } int partition(int A[], int si, int ei) { int x = A[ei]; int i = (si - 1); int j; for (j = si; j <= ei - 1; j++) { if (A[j] <= x) { i++; int temp = A[i]; A[i] = A[j]; A[j] = temp; } } int temp = A[i + 1]; A[i + 1] = A[ei]; A[ei] = temp; return (i + 1); } void quickSort(int A[], int si, int ei) { int pi; if (si < ei) { pi = partition(A, si, ei); quickSort(A, si, pi - 1); quickSort(A, pi + 1, ei); } } public static void main(String[] args) { FindTriplet triplet = new FindTriplet(); int A[] = { 1, 4, 45, 6, 10, 8 }; int sum = 22; int arr_size = A.length; triplet.find3Numbers(A, arr_size, sum); } }", "src": "class\nFindTriplet { \n\n\n\n\n\n\nboolean\nfind3Numbers(\nint\nA[], \nint\narr_size, \nint\nsum) \n\n{ \n\nint\nl, r; \n\n\n\n\nquickSort(A, \n0\n, arr_size - \n1\n); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < arr_size - \n2\n; i++) { \n\n\n\n\n\n\n\n\nl = i + \n1\n; \n\n\nr = arr_size - \n1\n; \n\n\nwhile\n(l < r) { \n\nif\n(A[i] + A[l] + A[r] == sum) { \n\nSystem.out.print(\n\"Triplet is \"\n+ A[i] + \n\", \"\n+ A[l] + \n\", \"\n+ A[r]); \n\nreturn\ntrue\n; \n\n} \n\nelse\nif\n(A[i] + A[l] + A[r] < sum) \n\nl++; \n\n\nelse\n\n\nr--; \n\n} \n\n} \n\n\n\n\nreturn\nfalse\n; \n\n} \n\n\nint\npartition(\nint\nA[], \nint\nsi, \nint\nei) \n\n{ \n\nint\nx = A[ei]; \n\nint\ni = (si - \n1\n); \n\nint\nj; \n\n\nfor\n(j = si; j <= ei - \n1\n; j++) { \n\nif\n(A[j] <= x) { \n\ni++; \n\nint\ntemp = A[i]; \n\nA[i] = A[j]; \n\nA[j] = temp; \n\n} \n\n} \n\nint\ntemp = A[i + \n1\n]; \n\nA[i + \n1\n] = A[ei]; \n\nA[ei] = temp; \n\nreturn\n(i + \n1\n); \n\n} \n\n\n\n\nvoid\nquickSort(\nint\nA[], \nint\nsi, \nint\nei) \n\n{ \n\nint\npi; \n\n\n\n\nif\n(si < ei) { \n\npi = partition(A, si, ei); \n\nquickSort(A, si, pi - \n1\n); \n\nquickSort(A, pi + \n1\n, ei); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nFindTriplet triplet = \nnew\nFindTriplet(); \n\nint\nA[] = { \n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n8\n}; \n\nint\nsum = \n22\n; \n\nint\narr_size = A.length; \n\n\ntriplet.find3Numbers(A, arr_size, sum); \n\n} \n}", "index": 407, "complexity": "3"}
{"back-translation": "class GFG { static void findTriplets(int[] arr, int n) { boolean found = false; for (int i = 0; i < n; i++) { HashSet<Integer> s = new HashSet<Integer>(); for (int j = i; j < n; j++) { int x = -(arr[i] + arr[j]); if (s.contains(x)) { System.out.printf(\"%d %d %d\\n\", x, arr[i], arr[j]); found = true; } else { s.add(arr[j]); } } } if (found == false) { System.out.printf(\" No Triplet Found\\n\"); } } public static void main(String[] args) { int[] arr = {0, -1, 2, -3, 1}; int n = arr.length; findTriplets(arr, n); } }", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n\n{ \n\nboolean\nfound = \nfalse\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\n{ \n\n\n\n\n\nHashSet<Integer> s = \nnew\nHashSet<Integer>(); \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n{ \n\nint\nx = -(arr[i] + arr[j]); \n\nif\n(s.contains(x)) \n\n{ \n\nSystem.out.printf(\n\"%d %d %d\\n\"\n, x, arr[i], arr[j]); \n\nfound = \ntrue\n; \n\n} \n\nelse\n\n{ \n\ns.add(arr[j]); \n\n} \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\n{ \n\nSystem.out.printf(\n\" No Triplet Found\\n\"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindTriplets(arr, n); \n\n} \n}", "index": 408, "complexity": "3"}
{"back-translation": "class GFG { static void spiralPrint(int m, int n, int[][] a) { int i, k = 0, l = 0; while (k < m && l < n) { for (i = l; i < n; ++i) { System.out.print(a[k][i] + \" \"); } k++; for (i = k; i < m; ++i) { System.out.print(a[i][n - 1] + \" \"); } n--; if (k < m) { for (i = n - 1; i >= l; --i) { System.out.print(a[m - 1][i] + \" \"); } m--; } if (l < n) { for (i = m - 1; i >= k; --i) { System.out.print(a[i][l] + \" \"); } l++; } } } public static void main(String[] args) { int R = 3; int C = 6; int a[][] = { { 1, 2, 3, 4, 5, 6}, { 7, 8, 9, 10, 11, 12}, { 13, 14, 15, 16, 17, 18} }; spiralPrint(R, C, a); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nspiralPrint(\nint\nm, \nint\nn, \nint\na[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n\n\n\nwhile\n(k < m && l < n) { \n\n\n\nfor\n(i = l; i < n; ++i) { \n\nSystem.out.print(a[k][i] + \n\" \"\n); \n\n} \n\nk++; \n\n\n\n\nfor\n(i = k; i < m; ++i) { \n\nSystem.out.print(a[i][n - \n1\n] + \n\" \"\n); \n\n} \n\nn--; \n\n\n\n\nif\n(k < m) { \n\nfor\n(i = n - \n1\n; i >= l; --i) { \n\nSystem.out.print(a[m - \n1\n][i] + \n\" \"\n); \n\n} \n\nm--; \n\n} \n\n\n\n\nif\n(l < n) { \n\nfor\n(i = m - \n1\n; i >= k; --i) { \n\nSystem.out.print(a[i][l] + \n\" \"\n); \n\n} \n\nl++; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nR = \n3\n; \n\nint\nC = \n6\n; \n\nint\na[][] = { { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}, \n\n{ \n7\n, \n8\n, \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n, \n17\n, \n18\n} }; \n\nspiralPrint(R, C, a); \n\n} \n}", "index": 409, "complexity": "3"}
{"back-translation": "class GFG { static int R = 4; static int C = 4; static void counterClockspiralPrint(int m, int n, int arr[][]) { int i, k = 0, l = 0; int cnt = 0; int total = m * n; while(k < m && l < n) { if(cnt == total) break; for(i = k; i < m; ++i) { System.out.print(arr[i][l] + \" \"); cnt++; } l++; if(cnt == total) break; for(i = l; i < n; ++i) { System.out.print(arr[m - 1][i] + \" \"); cnt++; } m--; if(cnt == total) break; if(k < m) { for(i = m - 1; i >= k; --i) { System.out.print(arr[i][n - 1] + \" \"); cnt++; } n--; } if(cnt == total) break; if(l < n) { for(i = n - 1; i >= l; --i) { System.out.print(arr[k][i] + \" \"); cnt++; } k++; } } } public static void main(String[] args) { int arr[][] = { { 1, 2, 3, 4}, { 5, 6, 7, 8}, { 9, 10, 11, 12}, { 13, 14, 15, 16} }; counterClockspiralPrint(R, C, arr); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nR = \n4\n; \n\nstatic\nint\nC = \n4\n; \n\n\n\n\n\n\nstatic\nvoid\ncounterClockspiralPrint(\nint\nm, \n\nint\nn, \n\nint\narr[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n\n\n\n\n\n\nint\ncnt = \n0\n; \n\n\n\n\n\n\nint\ntotal = m * n; \n\n\nwhile\n(k < m && l < n) \n\n{ \n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nfor\n(i = k; i < m; ++i) \n\n{ \n\nSystem.out.print(arr[i][l] + \n\" \"\n); \n\ncnt++; \n\n} \n\nl++; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nfor\n(i = l; i < n; ++i) \n\n{ \n\nSystem.out.print(arr[m - \n1\n][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nm--; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nif\n(k < m) \n\n{ \n\nfor\n(i = m - \n1\n; i >= k; --i) \n\n{ \n\nSystem.out.print(arr[i][n - \n1\n] + \n\" \"\n); \n\ncnt++; \n\n} \n\nn--; \n\n} \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nif\n(l < n) \n\n{ \n\nfor\n(i = n - \n1\n; i >= l; --i) \n\n{ \n\nSystem.out.print(arr[k][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nk++; \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[][] = { { \n1\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n5\n, \n6\n, \n7\n, \n8\n}, \n\n{ \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n} }; \n\n\n\n\ncounterClockspiralPrint(R, C, arr); \n} \n}", "index": 410, "complexity": "3"}
{"back-translation": "class GFG { public static int N = 4, M = 6; static int findMaxPath(int[][] mat) { int res = -1; for (int i = 0; i < M; i++) res = Math.max(res, mat[0][i]); for (int i = 1; i < N; i++) { res = -1; for (int j = 0; j < M; j++) { if (j > 0 && j < M - 1) mat[i][j] += Math.max(mat[i - 1][j], Math.max(mat[i - 1][j - 1], mat[i - 1][j + 1])); else if (j > 0) mat[i][j] += Math.max(mat[i - 1][j], mat[i - 1][j - 1]); else if (j < M - 1) mat[i][j] += Math.max(mat[i - 1][j], mat[i - 1][j + 1]); res = Math.max(mat[i][j], res); } } return res; } public static void main(String[] args) { int mat[][] = { { 10, 10, 2, 0, 20, 4}, { 1, 0, 0, 30, 2, 5}, { 0, 10, 4, 0, 2, 0}, { 1, 0, 2, 20, 0, 4} }; System.out.println(findMaxPath(mat)); } }", "src": "class\nGFG \n{ \n\npublic\nstatic\nint\nN = \n4\n, M = \n6\n; \n\n\n\n\nstatic\nint\nfindMaxPath(\nint\nmat[][]) \n\n{ \n\n\n\nint\nres = -\n1\n; \n\nfor\n(\nint\ni = \n0\n; i < M; i++) \n\nres = max(res, mat[\n0\n][i]); \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\nres = -\n1\n; \n\nfor\n(\nint\nj = \n0\n; j < M; j++) \n\n{ \n\n\n\nif\n(j > \n0\n&& j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmax(mat[i - \n1\n][j - \n1\n], \n\nmat[i - \n1\n][j + \n1\n])); \n\n\n\n\nelse\nif\n(j > \n0\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j - \n1\n]); \n\n\n\n\nelse\nif\n(j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j + \n1\n]); \n\n\n\n\nres = max(mat[i][j], res); \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nmat[][] = { { \n10\n, \n10\n, \n2\n, \n0\n, \n20\n, \n4\n}, \n\n{ \n1\n, \n0\n, \n0\n, \n30\n, \n2\n, \n5\n}, \n\n{ \n0\n, \n10\n, \n4\n, \n0\n, \n2\n, \n0\n}, \n\n{ \n1\n, \n0\n, \n2\n, \n20\n, \n0\n, \n4\n} \n\n}; \n\n\nSystem.out.println(findMaxPath(mat)); \n\n} \n}", "index": 411, "complexity": "3"}
{"back-translation": "class\nLinkedList {\n\n    static\n    Node head;\n\n    static\nclass\nNode {\n\n        int\ndata;\n        Node next;\n\n        Node(\nint\nd) {\n            data = d;\n            next = \nnull\n;\n        }\n    }\n\n    void\n    remove_duplicates() {\n        Node ptr1 = \nnull\n, ptr2 = \nnull\n, dup = \nnull\n;\n        ptr1 = head;\n\n        while\n        (ptr1 != \nnull\n&& ptr1.next != \nnull\n) {\n            ptr2 = ptr1;\n\n            while\n            (ptr2.next != \nnull\n) {\n\n                if\n                (ptr1.data == ptr2.next.data) {\n\n                    dup = ptr2.next;\n                    ptr2.next = ptr2.next.next;\n                    System.gc();\n\n                } else\n\n                {\n                    ptr2 = ptr2.next;\n                }\n            }\n            ptr1 = ptr1.next;\n        }\n    }\n\n    void\n    printList(Node node) {\n        while\n        (node != \nnull\n) {\n            System.out.print(node.data + \n\" \"\n);\n            node = node.next;\n        }\n    }\n\n    public\n    static\n    void\n    main(String[] args) {\n        LinkedList list = \nnew\nLinkedList();\n        list.head = \nnew\nNode(\n10\n);\n        list.head.next = \nnew\nNode(\n12\n);\n        list.head.next.next = \nnew\nNode(\n11\n);\n        list.head.next.next.next = \nnew\nNode(\n11\n);\n        list.head.next.next.next.next = \nnew\nNode(\n12\n);\n        list.head.next.next.next.next.next = \nnew\nNode(\n11\n);\n        list.head.next.next.next.next.next.next = \nnew\nNode(\n10\n);\n\n        System.out.println(\n\"Linked List before removing duplicates : \\n \"\n);\n        list.printList(head);\n\n        list.remove_duplicates();\n\n        System.out.println(\n\"\"\n);\n        System.out.println(\n\"Linked List after removing duplicates : \\n \"\n);\n        list.printList(head);\n    }\n}", "src": "class\nLinkedList { \n\n\nstatic\nNode head; \n\n\nstatic\nclass\nNode { \n\n\nint\ndata; \n\nNode next; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n\n\nvoid\nremove_duplicates() { \n\nNode ptr1 = \nnull\n, ptr2 = \nnull\n, dup = \nnull\n; \n\nptr1 = head; \n\n\n\n\nwhile\n(ptr1 != \nnull\n&& ptr1.next != \nnull\n) { \n\nptr2 = ptr1; \n\n\n\n\nwhile\n(ptr2.next != \nnull\n) { \n\n\n\n\nif\n(ptr1.data == ptr2.next.data) { \n\n\n\n\ndup = ptr2.next; \n\nptr2.next = ptr2.next.next; \n\nSystem.gc(); \n\n} \nelse\n\n{ \n\nptr2 = ptr2.next; \n\n} \n\n} \n\nptr1 = ptr1.next; \n\n} \n\n} \n\n\nvoid\nprintList(Node node) { \n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.next; \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList list = \nnew\nLinkedList(); \n\nlist.head = \nnew\nNode(\n10\n); \n\nlist.head.next = \nnew\nNode(\n12\n); \n\nlist.head.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next.next = \nnew\nNode(\n12\n); \n\nlist.head.next.next.next.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next.next.next.next = \nnew\nNode(\n10\n); \n\n\nSystem.out.println(\n\"Linked List before removing duplicates : \\n \"\n); \n\nlist.printList(head); \n\n\nlist.remove_duplicates(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Linked List after removing duplicates : \\n \"\n); \n\nlist.printList(head); \n\n} \n}", "index": 412, "complexity": "3"}
{"back-translation": "public class GFG { static class Node { public int data; public Node next; public Node(int data) { this.data = data; } } static void getJosephusPosition(int m, int n) { Node head = new Node(1); Node prev = head; for (int i = 2; i <= n; i++) { prev.next = new Node(i); prev = prev.next; } prev.next = head; Node ptr1 = head, ptr2 = head; while (ptr1.next != ptr1) { int count = 1; while (count != m) { ptr2 = ptr1; ptr1 = ptr1.next; count++; } ptr2.next = ptr1.next; ptr1 = ptr2.next; } System.out.println(\"Last person left standing \" + \"(Josephus Position) is \" + ptr1.data); } public static void main(String args[]) { int n = 14, m = 2; getJosephusPosition(m, n); } }", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nclass\nNode \n\n{ \n\npublic\nint\ndata ; \n\npublic\nNode next; \n\npublic\nNode( \nint\ndata ) \n\n{ \n\nthis\n.data = data; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\ngetJosephusPosition(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\nNode head = \nnew\nNode(\n1\n); \n\nNode prev = head; \n\nfor\n(\nint\ni = \n2\n; i <= n; i++) \n\n{ \n\nprev.next = \nnew\nNode(i); \n\nprev = prev.next; \n\n} \n\n\n\n\nprev.next = head; \n\n\n\n\nNode ptr1 = head, ptr2 = head; \n\n\nwhile\n(ptr1.next != ptr1) \n\n{ \n\n\n\n\nint\ncount = \n1\n; \n\nwhile\n(count != m) \n\n{ \n\nptr2 = ptr1; \n\nptr1 = ptr1.next; \n\ncount++; \n\n} \n\n\n\n\nptr2.next = ptr1.next; \n\nptr1 = ptr2.next; \n\n} \n\nSystem.out.println (\n\"Last person left standing \"\n+ \n\n\"(Josephus Position) is \"\n+ ptr1.data); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n14\n, m = \n2\n; \n\ngetJosephusPosition(m, n); \n\n} \n}", "index": 413, "complexity": "3"}
{"back-translation": "class GFG { static int maxSum(int[] arr, int n) { int res = Integer.MIN_VALUE; for (int i = 0; i < n; i++) { int curr_sum = 0; for (int j = n - i; j < n * 2 - i; j++) { int index = j % n; curr_sum += (j - i) * arr[index]; } res = Math.max(res, curr_sum); } return res; } public static void main(String args[]) { int arr[] = { 8, 3, 1, 2 }; int n = arr.length; System.out.println(maxSum(arr, n)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n{ \n\n\n\n\nint\ncurr_sum = \n0\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nint\nindex = (i + j) % n; \n\ncurr_sum += j * arr[index]; \n\n} \n\n\n\n\nres = Math.max(res, curr_sum); \n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n} \n\n\n}", "index": 414, "complexity": "3"}
{"back-translation": "class GFG { static void calculateSpan(int price[], int n, int S[]) { S[0] = 1; for (int i = 1; i < n; i++) { S[i] = 1; for (int j = i - 1; (j >= 0) && (price[i] >= price[j]); j--) S[i]++; } } static void printArray(int arr[]) { System.out.print(Arrays.toString(arr)); } public static void main(String[] args) { int price[] = { 10, 4, 5, 90, 120, 80 }; int n = price.length; int S[] = new int[n]; calculateSpan(price, n, S); printArray(S); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\ncalculateSpan(\nint\nprice[], \nint\nn, \nint\nS[]) \n\n{ \n\n\n\nS[\n0\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) { \n\nS[i] = \n1\n; \n\n\n\n\n\n\n\nfor\n(\nint\nj = i - \n1\n; (j >= \n0\n) && (price[i] >= price[j]); j--) \n\nS[i]++; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[]) \n\n{ \n\nSystem.out.print(Arrays.toString(arr)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nprice[] = { \n10\n, \n4\n, \n5\n, \n90\n, \n120\n, \n80\n}; \n\nint\nn = price.length; \n\nint\nS[] = \nnew\nint\n[n]; \n\n\n\n\ncalculateSpan(price, n, S); \n\n\n\n\nprintArray(S); \n\n} \n}", "index": 415, "complexity": "3"}
{"back-translation": "class GFG { static Stack<Integer> sortStack(Stack<Integer> input) { Stack<Integer> tmpStack = new Stack<Integer>(); while (!input.empty()) { int tmp = input.peek(); input.pop(); while (!tmpStack.empty() && tmpStack.peek() < tmp) { input.push(tmpStack.peek()); tmpStack.pop(); } tmpStack.push(tmp); } return tmpStack; } static void sortArrayUsingStacks(int[] arr, int n) { Stack<Integer> input = new Stack<Integer>(); for (int i = 0; i < n; i++) input.push(arr[i]); Stack<Integer> tmpStack = sortStack(input); for (int i = 0; i < n; i++) { arr[i] = tmpStack.peek(); tmpStack.pop(); } } public static void main(String args[]) { int[] arr = { 10, 5, 15, 45 }; int n = arr.length; sortArrayUsingStacks(arr, n); for (int i = 0; i < n; i++) System.out.print(arr[i] + \" \"); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nStack<Integer> sortStack(Stack<Integer> input) \n\n{ \n\nStack<Integer> tmpStack = \n\nnew\nStack<Integer>(); \n\n\nwhile\n(!input.empty()) \n\n{ \n\n\n\n\n\nint\ntmp = input.peek(); \n\ninput.pop(); \n\n\n\n\n\n\n\n\nwhile\n(!tmpStack.empty() && \n\ntmpStack.peek() < tmp) \n\n{ \n\n\n\n\n\n\n\ninput.push(tmpStack.peek()); \n\ntmpStack.pop(); \n\n} \n\n\n\n\n\n\ntmpStack.push(tmp); \n\n} \n\n\nreturn\ntmpStack; \n\n} \n\n\nstatic\nvoid\nsortArrayUsingStacks(\nint\n[]arr, \n\nint\nn) \n\n{ \n\n\n\n\n\nStack<Integer> input = \n\nnew\nStack<Integer>(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ninput.push(arr[i]); \n\n\n\n\nStack<Integer> tmpStack = \n\nsortStack(input); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i] = tmpStack.peek(); \n\ntmpStack.pop(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n5\n, \n15\n, \n45\n}; \n\nint\nn = arr.length; \n\n\nsortArrayUsingStacks(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 416, "complexity": "3"}
{"back-translation": "class GFG { public static int minIndex(Queue<Integer> list, int sortIndex) { int min_index = -1; int min_value = Integer.MAX_VALUE; int s = list.size(); for (int i = 0; i < s; i++) { int current = list.peek(); list.poll(); if (current <= min_value && i <= sortIndex) { min_index = i; min_value = current; } list.add(current); } return min_index; } public static void insertMinToRear(Queue<Integer> list, int min_index) { int min_value = 0; int s = list.size(); for (int i = 0; i < s; i++) { int current = list.peek(); list.poll(); if (i != min_index) list.add(current); else min_value = current; } list.add(min_value); } public static void sortQueue(Queue<Integer> list) { for (int i = 1; i <= list.size(); i++) { int min_index = minIndex(list,list.size() - i); insertMinToRear(list, min_index); } } public static void main (String[] args) { Queue<Integer> list = new LinkedList<Integer>(); list.add(30); list.add(11); list.add(15); list.add(4); sortQueue(list); while(list.isEmpty()== false) { System.out.print(list.peek() + \" \"); list.poll(); } } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\npublic\nstatic\nint\nminIndex(Queue<Integer> list, \n\nint\nsortIndex) \n\n{ \n\nint\nmin_index = -\n1\n; \n\nint\nmin_value = Integer.MAX_VALUE; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\n\n\n\nlist.poll(); \n\n\n\n\n\n\n\n\n\n\nif\n(current <= min_value && i <= sortIndex) \n\n{ \n\nmin_index = i; \n\nmin_value = current; \n\n} \n\nlist.add(current); \n\n} \n\nreturn\nmin_index; \n} \n\n\n\n\n\n\npublic\nstatic\nvoid\ninsertMinToRear(Queue<Integer> list, \n\nint\nmin_index) \n\n{ \n\nint\nmin_value = \n0\n; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\nlist.poll(); \n\nif\n(i != min_index) \n\nlist.add(current); \n\nelse\n\nmin_value = current; \n\n} \n\nlist.add(min_value); \n\n} \n\n\npublic\nstatic\nvoid\nsortQueue(Queue<Integer> list) \n\n{ \n\nfor\n(\nint\ni = \n1\n; i <= list.size(); i++) \n\n{ \n\nint\nmin_index = minIndex(list,list.size() - i); \n\ninsertMinToRear(list, min_index); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nQueue<Integer> list = \nnew\nLinkedList<Integer>(); \n\nlist.add(\n30\n); \n\nlist.add(\n11\n); \n\nlist.add(\n15\n); \n\nlist.add(\n4\n); \n\n\n\n\nsortQueue(list); \n\n\n\n\nwhile\n(list.isEmpty()== \nfalse\n) \n\n{ \n\nSystem.out.print(list.peek() + \n\" \"\n); \n\nlist.poll(); \n\n} \n\n} \n}", "index": 417, "complexity": "3"}
{"back-translation": "class Node { int data; Node left, right; public Node(int d) { data = d; left = right = null; } } class BinaryTree { Node root; void printSpiral(Node node) { int h = height(node); int i; boolean ltr = false; for (i = 1; i <= h; i++) { printGivenLevel(node, i, ltr); ltr = !ltr; } } int height(Node node) { if (node == null) return 0; else { int lheight = height(node.left); int rheight = height(node.right); if (lheight > rheight) return (lheight + 1); else return (rheight + 1); } } void printGivenLevel(Node node, int level, boolean ltr) { if (node == null) return; if (level == 1) System.out.print(node.data + \" \"); else if (level > 1) { if (ltr != false) { printGivenLevel(node.left, level - 1, ltr); printGivenLevel(node.right, level - 1, ltr); } else { printGivenLevel(node.right, level - 1, ltr); printGivenLevel(node.left, level - 1, ltr); } } } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(7); tree.root.left.right = new Node(6); tree.root.right.left = new Node(5); tree.root.right.right = new Node(4); System.out.println(\"Spiral order traversal of Binary Tree is \"); tree.printSpiral(tree.root); } }", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\n\n\n\nboolean\nltr = \nfalse\n; \n\nfor\n(i = \n1\n; i <= h; i++) { \n\nprintGivenLevel(node, i, ltr); \n\n\n\n\nltr = !ltr; \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n{ \n\n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel, \nboolean\nltr) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) { \n\nif\n(ltr != \nfalse\n) { \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\n} \n\nelse\n{ \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\n} \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(tree.root); \n\n} \n}", "index": 418, "complexity": "3"}
{"back-translation": "public class GFG {\n\n    static void printKMax(int arr[], int n, int k) {\n\n        int j, max;\n\n        for (int i = 0; i <= n - k; i++) {\n\n            max = arr[i];\n\n            for (j = 1; j < k; j++) {\n\n                if (arr[i + j] > max)\n                    max = arr[i + j];\n            }\n\n            System.out.print(max + \" \");\n        }\n    }\n\n    public static void main(String args[]) {\n\n        int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        int k = 3;\n\n        printKMax(arr, arr.length, k);\n    }\n}", "src": "public\nclass\nGFG { \n\n\n\nstatic\nvoid\nprintKMax(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nj, max; \n\n\nfor\n(\nint\ni = \n0\n; i <= n - k; i++) { \n\n\nmax = arr[i]; \n\n\nfor\n(j = \n1\n; j < k; j++) { \n\nif\n(arr[i + j] > max) \n\nmax = arr[i + j]; \n\n} \n\nSystem.out.print(max + \n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}; \n\nint\nk = \n3\n; \n\nprintKMax(arr, arr.length, k); \n\n} \n}", "index": 419, "complexity": "3"}
{"back-translation": "class Solution {\n\n    static void printFirstNegativeInteger(int arr[], int n, int k) {\n\n        boolean flag;\n\n        for (int i = 0; i < (n - k + 1); i++) {\n            flag = false;\n\n            for (int j = 0; j < k; j++) {\n\n                if (arr[i + j] < 0) {\n                    System.out.print((arr[i + j]) + \" \");\n                    flag = true;\n                    break;\n                }\n            }\n\n            if (!flag) {\n                System.out.print(\"0\" + \" \");\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {12, -1, -7, 8, -15, 30, 16, 28};\n        int n = arr.length;\n        int k = 3;\n        printFirstNegativeInteger(arr, n, k);\n    }\n}", "src": "class\nsolution \n{ \n\n\n\nstatic\nvoid\nprintFirstNegativeInteger(\nint\narr[], \nint\nn, \nint\nk) \n{ \n\n\n\n\n\nboolean\nflag; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i<(n-k+\n1\n); i++) \n\n{ \n\nflag = \nfalse\n; \n\n\n\n\nfor\n(\nint\nj = \n0\n; j<k; j++) \n\n{ \n\n\n\n\n\n\n\n\n\nif\n(arr[i+j] < \n0\n) \n\n{ \n\nSystem.out.print((arr[i+j])+\n\" \"\n); \n\nflag = \ntrue\n; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nif\n(!flag) \n\nSystem.out.print(\n\"0\"\n+\n\" \"\n); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n12\n, -\n1\n, -\n7\n, \n8\n, -\n15\n, \n30\n, \n16\n, \n28\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nprintFirstNegativeInteger(arr, n, k); \n\n} \n}", "index": 420, "complexity": "3"}
{"back-translation": "class GFG { static int maxSubarrayXOR(int arr[], int n) { int ans = Integer.MIN_VALUE; for (int i = 0; i < n; i++) { int curr_xor = 0; for (int j = i; j < n; j++) { curr_xor = curr_xor ^ arr[j]; ans = Math.max(ans, curr_xor); } } return ans; } public static void main(String args[]) { int arr[] = { 8 , 1 , 2 , 12 }; int n = arr.length; System.out.println(\"Max subarray XOR is \"+ maxSubarrayXOR(arr, n)); } }", "src": "class\nGFG { \n\nstatic\nint\nmaxSubarrayXOR(\nint\narr[], \nint\nn) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\nint\ncurr_xor = \n0\n; \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\ncurr_xor = curr_xor ^ arr[j]; \n\nans = Math.max(ans, curr_xor); \n\n} \n\n} \n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n8\n, \n1\n, \n2\n, \n12\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Max subarray XOR is \"\n+ \n\nmaxSubarrayXOR(arr, n)); \n\n} \n}", "index": 421, "complexity": "3"}
{"back-translation": "class GFG { public static void splitArr(int arr[], int n, int k) { for (int i = 0; i < k; i++) { int x = arr[0]; for (int j = 0; j < n - 1; ++j) arr[j] = arr[j + 1]; arr[n - 1] = x; } } public static void main(String[] args) { int arr[] = { 12, 10, 5, 6, 52, 36 }; int n = arr.length; int position = 2; splitArr(arr, 6, position); for (int i = 0; i < n; ++i) System.out.print(arr[i] + \" \"); } }", "src": "class\nGFG { \n\npublic\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < k; i++) { \n\n\n\n\nint\nx = arr[\n0\n]; \n\nfor\n(\nint\nj = \n0\n; j < n - \n1\n; ++j) \n\narr[j] = arr[j + \n1\n]; \n\narr[n - \n1\n] = x; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nsplitArr(arr, \n6\n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 422, "complexity": "3"}
{"back-translation": "public class CountKSubStr { \n\n\n\n\nint countkDist(String str, int k) { \n\nint res = 0; \nint n = str.length(); \nint cnt[] = new int[26]; \n\nfor (int i = 0; i < n; i++) { \n\nint dist_count = 0; \n\nArrays.fill(cnt, 0); \n\nfor (int j=i; j<n; j++) { \n\nif (cnt[str.charAt(j) - 'a'] == 0) dist_count++; \n\ncnt[str.charAt(j) - 'a']++; \n\nif (dist_count == k) res++; \n\n} \n\n} \n\nreturn res; \n\n} \n\npublic static void main(String[] args) { \n\nCountKSubStr ob = new CountKSubStr(); \nString ch = \"abcbaa\"; \nint k = 3; \nSystem.out.println(\"Total substrings with exactly \"+ k + \" distinct characters : \"+ ob.countkDist(ch, k)); \n\n} \n}", "src": "public\nclass\nCountKSubStr \n{ \n\n\n\n\n\nint\ncountkDist(String str, \nint\nk) \n\n{ \n\n\n\nint\nres = \n0\n; \n\n\nint\nn = str.length(); \n\n\n\n\nint\ncnt[] = \nnew\nint\n[\n26\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndist_count = \n0\n; \n\n\n\n\nArrays.fill(cnt, \n0\n); \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\n\n\n\n\nif\n(cnt[str.charAt(j) - \n'a'\n] == \n0\n) \n\ndist_count++; \n\n\n\n\ncnt[str.charAt(j) - \n'a'\n]++; \n\n\n\n\n\n\nif\n(dist_count == k) \n\nres++; \n\n} \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountKSubStr ob = \nnew\nCountKSubStr(); \n\nString ch = \n\"abcbaa\"\n; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Total substrings with exactly \"\n+ \n\nk + \n\" distinct characters : \"\n\n+ ob.countkDist(ch, k)); \n\n} \n}", "index": 423, "complexity": "3"}
{"back-translation": "class GFG { static final int MAX_CHAR = 26; static boolean check(int[] freq, int k) { for (int i = 0; i < MAX_CHAR; i++) { if (freq[i] != 0 && freq[i] != k) return false; } return true; } static int substrings(String s, int k) { int res = 0; for (int i = 0; i < s.length(); i++) { int[] freq = new int[MAX_CHAR]; for (int j = i; j < s.length(); j++) { int index = s.charAt(j) - 'a'; freq[index]++; if (freq[index] > k) break; else if (freq[index] == k && check(freq, k)) { res++; } } } return res; } public static void main(String[] args) { String s = \"aabbcc\"; int k = 2; System.out.println(substrings(s, k)); s = \"aabbc\"; k = 2; System.out.println(substrings(s, k)); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\nstatic\nboolean\ncheck(\nint\nfreq[], \nint\nk) \n{ \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nif\n(freq[i] !=\n0\n&& freq[i] != k) \n\nreturn\nfalse\n; \n\nreturn\ntrue\n; \n} \n\n\n\nstatic\nint\nsubstrings(String s, \nint\nk) \n{ \n\nint\nres = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i< s.length(); i++) \n\n{ \n\n\n\n\n\n\nint\nfreq[] = \nnew\nint\n[MAX_CHAR]; \n\n\n\n\nfor\n(\nint\nj = i; j<s.length(); j++) \n\n{ \n\n\n\n\nint\nindex = s.charAt(j) - \n'a'\n; \n\nfreq[index]++; \n\n\n\n\n\n\n\n\nif\n(freq[index] > k) \n\nbreak\n; \n\n\n\n\n\n\nelse\nif\n(freq[index] == k && \n\ncheck(freq, k) == \ntrue\n) \n\nres++; \n\n} \n\n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nString s = \n\"aabbcc\"\n; \n\nint\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n\n\ns = \n\"aabbc\"\n; \n\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n} \n}", "index": 424, "complexity": "3"}
{"back-translation": "public class GFG {\n\n    static int countNonEmptySubstr(String str) {\n        int n = str.length();\n        return n * (n + 1) / 2;\n    }\n\n    public static void main(String args[]) {\n        String s = \"abcde\";\n        System.out.println(countNonEmptySubstr(s));\n    }\n}", "src": "public\nclass\nGFG { \n\n\nstatic\nint\ncountNonEmptySubstr(String str) \n\n{ \n\nint\nn = str.length(); \n\nreturn\nn * (n + \n1\n) / \n2\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcde\"\n; \n\nSystem.out.println( \n\ncountNonEmptySubstr(s)); \n\n} \n}", "index": 425, "complexity": "3"}
{"back-translation": "public static class GFG { static boolean checkEquality(String s) { return (s.charAt(0) == s.charAt(s.length() - 1)); } static int countSubstringWithEqualEnds(String s) { int result = 0; int n = s.length(); for (int i = 0; i < n; i++) for (int len = 1; len <= n-i; len++) if (checkEquality(s.substring(i, i + len))) result++; return result; } public static void main(String args[]) { String s = \"abcab\"; System.out.println(countSubstringWithEqualEnds(s)); } }", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nboolean\ncheckEquality(String s) \n\n{ \n\nreturn\n(s.charAt(\n0\n) == s.charAt(s.length() - \n1\n)); \n\n} \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\nfor\n(\nint\nlen = \n1\n; len <= n-i; len++) \n\n\n\n\n\n\nif\n(checkEquality(s.substring(i, i + len))) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 426, "complexity": "3"}
{"back-translation": "public class GFG { static int countSubstringWithEqualEnds(String s) { int result = 0; int n = s.length(); for (int i = 0; i < n; i++) for (int j = i; j < n; j++) if (s.charAt(i) == s.charAt(j)) result++; return result; } public static void main(String args[]) { String s = \"abcab\"; System.out.println(countSubstringWithEqualEnds(s)); } }", "src": "public\nclass\nGFG { \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nfor\n(\nint\nj = i; j < n; j++) \n\nif\n(s.charAt(i) == s.charAt(j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 427, "complexity": "3"}
{"back-translation": "class GFG { \n\n\n\n\n\n\npublic static void SplitAndAdd(int[] A, int length, int rotation) { \n\n\n\nint[] tmp = new int[length*2]; \n\nSystem.arraycopy(A, 0, tmp, 0, length); \n\nSystem.arraycopy(A, 0, tmp, length, length); \n\nfor (int i=rotation; i<rotation+length; i++) \n\nA[i-rotation]=tmp[i]; \n\n} \n\n\n\npublic static void main(String[] args) { \n\nint arr[] = { 12, 10, 5, 6, 52, 36}; \n\nint n = arr.length; \n\nint position = 2; \n\n\nSplitAndAdd(arr, n, position); \n\n\nfor (int i = 0; i < n; ++i) \n\nSystem.out.print(arr[i] + \" \"); \n\n} \n}", "src": "class\nGFG { \n\n\n\n\n\n\npublic\nstatic\nvoid\nSplitAndAdd(\nint\n[] A,\nint\nlength,\nint\nrotation){ \n\n\n\n\nint\n[] tmp = \nnew\nint\n[length*\n2\n]; \n\n\n\n\nSystem.arraycopy(A, \n0\n, tmp, \n0\n, length); \n\nSystem.arraycopy(A, \n0\n, tmp, length, length); \n\nfor\n(\nint\ni=rotation;i<rotation+length;i++) \n\nA[i-rotation]=tmp[i]; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nSplitAndAdd(arr, n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 428, "complexity": "3"}
{"back-translation": "public class GFG { static final int MAX_CHAR = 26; static String getKey(String str) { boolean[] visited = new boolean[MAX_CHAR]; Arrays.fill(visited, false); for (int j = 0; j < str.length(); j++) visited[str.charAt(j) - 'a'] = true; String key = \"\"; for (int j = 0; j < MAX_CHAR; j++) if (visited[j]) key = key + (char)('a' + j); return key; } static void wordsWithSameCharSet(String words[], int n) { HashMap<String, ArrayList<Integer>> Hash = new HashMap<>(); for (int i = 0; i < n; i++) { String key = getKey(words[i]); if (Hash.containsKey(key)) { ArrayList<Integer> get_al = Hash.get(key); get_al.add(i); Hash.put(key, get_al); } else { ArrayList<Integer> new_al = new ArrayList<>(); new_al.add(i); Hash.put(key, new_al); } } for (Entry<String, ArrayList<Integer>> it : Hash.entrySet()) { ArrayList<Integer> get = it.getValue(); for (Integer v : get) System.out.print(words[v] + \", \"); System.out.println(); } } public static void main(String args[]) { String words[] = { \"may\", \"student\", \"students\", \"dog\", \"studentssess\", \"god\", \"cat\", \"act\", \"tab\", \"bat\", \"flow\", \"wolf\", \"lambs\", \"amy\", \"yam\", \"balms\", \"looped\", \"poodle\" }; int n = words.length; wordsWithSameCharSet(words, n); } }", "src": "public\nclass\nGFG { \n\n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\n\n\nstatic\nString getKey(String str) \n\n{ \n\nboolean\n[] visited = \nnew\nboolean\n[MAX_CHAR]; \n\nArrays.fill(visited, \nfalse\n); \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < str.length(); j++) \n\nvisited[str.charAt(j) - \n'a'\n] = \ntrue\n; \n\nString key = \n\"\"\n; \n\nfor\n(\nint\nj=\n0\n; j < MAX_CHAR; j++) \n\nif\n(visited[j]) \n\nkey = key + (\nchar\n)(\n'a'\n+j); \n\nreturn\nkey; \n\n} \n\n\n\n\nstatic\nvoid\nwordsWithSameCharSet(String words[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nHashMap<String, ArrayList<Integer>> Hash = \nnew\nHashMap<>(); \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\nString key = getKey(words[i]); \n\n\n\n\n\n\n\n\nif\n(Hash.containsKey(key)) \n\n{ \n\nArrayList<Integer> get_al = Hash.get(key); \n\nget_al.add(i); \n\nHash.put(key, get_al); \n\n} \n\n\n\n\n\n\n\n\nelse\n\n{ \n\nArrayList<Integer> new_al = \nnew\nArrayList<>(); \n\nnew_al.add(i); \n\nHash.put(key, new_al); \n\n} \n\n} \n\n\n\n\nfor\n(Entry<String, ArrayList<Integer>> it : Hash.entrySet()) \n\n{ \n\nArrayList<Integer> get =it.getValue(); \n\nfor\n(Integer v:get) \n\nSystem.out.print( words[v] + \n\", \"\n); \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString words[] = { \n\"may\"\n, \n\"student\"\n, \n\"students\"\n, \n\"dog\"\n, \n\n\"studentssess\"\n, \n\"god\"\n, \n\"cat\"\n, \n\"act\"\n, \n\"tab\"\n, \n\n\"bat\"\n, \n\"flow\"\n, \n\"wolf\"\n, \n\"lambs\"\n, \n\"amy\"\n, \n\"yam\"\n, \n\n\"balms\"\n, \n\"looped\"\n, \n\"poodle\"\n}; \n\nint\nn = words.length; \n\nwordsWithSameCharSet(words, n); \n\n} \n}", "index": 429, "complexity": "3"}
{"back-translation": "class CountSubString { int countSubStr(char str[], int n) { int res = 0; for (int i = 0; i < n; i++) { if (str[i] == '1') { for (int j = i + 1; j < n; j++) { if (str[j] == '1') res++; } } } return res; } public static void main(String[] args) { CountSubString count = new CountSubString(); String string = \"00100101\"; char str[] = string.toCharArray(); int n = str.length; System.out.println(count.countSubStr(str, n)); } }", "src": "class\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[],\nint\nn) \n\n{ \n\nint\nres = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i<n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\n{ \n\n\n\nfor\n(\nint\nj = i + \n1\n; j< n; j++) \n\n{ \n\nif\n(str[j] == \n'1'\n) \n\nres++; \n\n} \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str,n)); \n\n} \n}", "index": 430, "complexity": "3"}
{"back-translation": "class GFG { static void printMinIndexChar(String str, String patt) { int minIndex = Integer.MAX_VALUE; int m = str.length(); int n = patt.length(); for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { if (patt.charAt(i) == str.charAt(j) && j < minIndex) { minIndex = j; break; } } } if (minIndex != Integer.MAX_VALUE) System.out.println(\"Minimum Index Character = \" + str.charAt(minIndex)); else System.out.println(\"No character present\"); } public static void main(String[] args) { String str = \"geeksforgeeks\"; String patt = \"set\"; printMinIndexChar(str, patt); } }", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n\n\n\n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n\n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) { \n\n\n\n\n\n\n\n\nif\n(patt.charAt(i)== str.charAt(j) && j < minIndex) { \n\nminIndex = j; \n\nbreak\n; \n\n} \n\n} \n\n} \n\n\n\n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n\n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n}", "index": 431, "complexity": "3"}
{"back-translation": "class Test { static int countPairs(String str) { int result = 0; int n = str.length(); for (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) if (Math.abs(str.charAt(i) - str.charAt(j)) == Math.abs(i - j)) result++; return result; } public static void main(String args[]) { String str = \"geeksforgeeks\"; System.out.println(countPairs(str)); } }", "src": "class\nTest { \n\n\n\n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n\n\n\n\n\nif\n(Math.abs(str.charAt(i) - str.charAt(j)) == \n\nMath.abs(i - j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n}", "index": 432, "complexity": "3"}
{"back-translation": "class GFG {\n\nstatic int findSubsequenceCount(String S, String T) {\n\nint m = T.length();\n\nint n = S.length();\n\nif (m > n)\nreturn 0;\nint mat[][] = new int[m + 1][n + 1];\nfor (int i = 1; i <= m; i++)\nmat[i][0] = 0;\nfor (int j = 0; j <= n; j++)\nmat[0][j] = 1;\nfor (int i = 1; i <= m; i++) {\nfor (int j = 1; j <= n; j++) {\nif (T.charAt(i - 1) != S.charAt(j - 1))\nmat[i][j] = mat[i][j - 1];\nelse\nmat[i][j] = mat[i][j - 1] + mat[i - 1][j - 1];\n}\n}\nreturn mat[m][n];\n}\npublic static void main(String[] args) {\nString T = \"ge\";\nString S = \"geeksforgeeks\";\nSystem.out.println(findSubsequenceCount(S, T));\n}\n}", "src": "class\nGFG { \n\nstatic\nint\nfindSubsequenceCount(String S, String T) \n\n{ \n\nint\nm = T.length(); \n\nint\nn = S.length(); \n\n\n\n\nif\n(m > n) \n\nreturn\n0\n; \n\n\n\n\n\n\nint\nmat[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\nmat[i][\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\nmat[\n0\n][j] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= m; i++) { \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) { \n\n\n\n\n\n\n\nif\n(T.charAt(i - \n1\n) != S.charAt(j - \n1\n)) \n\nmat[i][j] = mat[i][j - \n1\n]; \n\n\n\n\n\n\n\n\n\n\nelse\n\nmat[i][j] = mat[i][j - \n1\n] + mat[i - \n1\n][j - \n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\nmat[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString T = \n\"ge\"\n; \n\nString S = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(findSubsequenceCount(S, T)); \n\n} \n}", "index": 433, "complexity": "3"}
{"back-translation": "class GFG { static int bellNumber(int n) { int[][] bell = new int[n+1][n+1]; bell[0][0] = 1; for (int i=1; i<=n; i++) { bell[i][0] = bell[i-1][i-1]; for (int j=1; j<=i; j++) bell[i][j] = bell[i-1][j-1] + bell[i][j-1]; } return bell[n][0]; } public static void main(String[] args) { for (int n=0; n<=5; n++) System.out.println(\"Bell Number \" + n + \" is \" + bellNumber(n)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nbellNumber(\nint\nn) \n\n{ \n\nint\n[][] bell = \nnew\nint\n[n+\n1\n][n+\n1\n]; \n\nbell[\n0\n][\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n\n\nbell[i][\n0\n] = bell[i-\n1\n][i-\n1\n]; \n\n\n\n\nfor\n(\nint\nj=\n1\n; j<=i; j++) \n\nbell[i][j] = bell[i-\n1\n][j-\n1\n] + bell[i][j-\n1\n]; \n\n} \n\n\nreturn\nbell[n][\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nfor\n(\nint\nn=\n0\n; n<=\n5\n; n++) \n\nSystem.out.println(\n\"Bell Number \"\n+ n + \n\n\" is \"\n+bellNumber(n)); \n\n} \n}", "index": 434, "complexity": "3"}
{"back-translation": "class GFG { static int catalanDP(int n) { int catalan[] = new int[n + 2]; catalan[0] = 1; catalan[1] = 1; for (int i = 2; i <= n; i++) { catalan[i] = 0; for (int j = 0; j < i; j++) { catalan[i] += catalan[j] * catalan[i - j - 1]; } } return catalan[n]; } public static void main(String[] args) { for (int i = 0; i < 10; i++) { System.out.print(catalanDP(i) + \" \"); } } }", "src": "class\nGFG{ \n\n\n\n\nstatic\nint\ncatalanDP(\nint\nn) { \n\n\n\nint\ncatalan[] = \nnew\nint\n[n + \n2\n]; \n\n\n\n\ncatalan[\n0\n] = \n1\n; \n\ncatalan[\n1\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\ncatalan[i] = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < i; j++) { \n\ncatalan[i] += catalan[j] * catalan[i - j - \n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\ncatalan[n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalanDP(i) + \n\" \"\n); \n\n} \n\n} \n}", "index": 435, "complexity": "3"}
{"back-translation": "class BinomialCoefficient { static int binomialCoeff(int n, int k) { int C[][] = new int[n+1][k+1]; int i, j; for (i = 0; i <= n; i++) { for (j = 0; j <= Math.min(i, k); j++) { if (j == 0 || j == i) C[i][j] = 1; else C[i][j] = C[i-1][j-1] + C[i-1][j]; } } return C[n][k]; } static int min(int a, int b) { return (a<b)? a: b; } public static void main(String args[]) { int n = 5, k = 2; System.out.println(\"Value of C(\" + n + \",\" + k + \") is \" + binomialCoeff(n, k)); } }", "src": "class\nBinomialCoefficient \n{ \n\n\n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[][] = \nnew\nint\n[n+\n1\n][k+\n1\n]; \n\nint\ni, j; \n\n\n\n\nfor\n(i = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(j = \n0\n; j <= min(i, k); j++) \n\n{ \n\n\n\nif\n(j == \n0\n|| j == i) \n\nC[i][j] = \n1\n; \n\n\n\n\nelse\n\nC[i][j] = C[i-\n1\n][j-\n1\n] + C[i-\n1\n][j]; \n\n} \n\n} \n\n\nreturn\nC[n][k]; \n\n} \n\n\n\n\nstatic\nint\nmin(\nint\na, \nint\nb) \n\n{ \n\nreturn\n(a<b)? a: b; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of C(\"\n+n+\n\",\"\n+k+\n\") is \"\n+binomialCoeff(n, k)); \n\n} \n}", "index": 436, "complexity": "3"}
{"back-translation": "class GFG { static int permutationCoeff(int n, int k) { int P[][] = new int[n + 2][k + 2]; for (int i = 0; i <= n; i++) { for (int j = 0; j <= Math.min(i, k); j++) { if (j == 0) P[i][j] = 1; else P[i][j] = P[i - 1][j] + (j * P[i - 1][j - 1]); P[i][j + 1] = 0; } } return P[n][k]; } public static void main(String args[]) { int n = 10, k = 2; System.out.println(\"Value of P( \"+ n + \",\" + k +\")\"+ \" is \"+ permutationCoeff(n, k) ); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nP[][] = \nnew\nint\n[n + \n2\n][k + \n2\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; \n\nj <= Math.min(i, k); \n\nj++) \n\n{ \n\n\n\nif\n(j == \n0\n) \n\nP[i][j] = \n1\n; \n\n\n\n\n\n\nelse\n\nP[i][j] = P[i - \n1\n][j] + \n\n(j * P[i - \n1\n][j - \n1\n]); \n\n\n\n\n\n\nP[i][j + \n1\n] = \n0\n; \n\n} \n\n} \n\nreturn\nP[n][k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ k +\n\")\"\n+ \n\n\" is \"\n+ permutationCoeff(n, k) ); \n\n} \n}", "index": 437, "complexity": "3"}
{"back-translation": "class GFG { static final int MAX = 100; static int getMaxGold(int gold[][], int m, int n) { int goldTable[][] = new int[m][n]; for (int[] rows : goldTable) Arrays.fill(rows, 0); for (int col = n - 1; col >= 0; col--) { for (int row = 0; row < m; row++) { int right = (col == n - 1) ? 0 : goldTable[row][col + 1]; int right_up = (row == 0 || col == n - 1) ? 0 : goldTable[row - 1][col + 1]; int right_down = (row == m - 1 || col == n - 1) ? 0 : goldTable[row + 1][col + 1]; goldTable[row][col] = gold[row][col] + Math.max(right, Math.max(right_up, right_down)); } } int res = goldTable[0][0]; for (int i = 1; i < m; i++) res = Math.max(res, goldTable[i][0]); return res; } public static void main(String arg[]) { int gold[][] = {{1, 3, 1, 5}, {2, 2, 4, 1}, {5, 0, 2, 3}, {0, 6, 1, 2}}; int m = 4, n = 4; System.out.print(getMaxGold(gold, m, n)); } }", "src": "class\nGFG { \n\n\nstatic\nfinal\nint\nMAX = \n100\n; \n\n\n\n\n\n\n\n\n\n\nstatic\nint\ngetMaxGold(\nint\ngold[][], \n\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\ngoldTable[][] = \nnew\nint\n[m][n]; \n\n\nfor\n(\nint\n[] rows:goldTable) \n\nArrays.fill(rows, \n0\n); \n\n\nfor\n(\nint\ncol = n-\n1\n; col >= \n0\n; col--) \n\n{ \n\nfor\n(\nint\nrow = \n0\n; row < m; row++) \n\n{ \n\n\n\n\n\n\nint\nright = (col == n-\n1\n) ? \n0\n\n: goldTable[row][col+\n1\n]; \n\n\n\n\n\n\nint\nright_up = (row == \n0\n|| \n\ncol == n-\n1\n) ? \n0\n: \n\ngoldTable[row-\n1\n][col+\n1\n]; \n\n\n\n\n\n\nint\nright_down = (row == m-\n1\n\n|| col == n-\n1\n) ? \n0\n: \n\ngoldTable[row+\n1\n][col+\n1\n]; \n\n\n\n\n\n\ngoldTable[row][col] = gold[row][col] \n\n+ Math.max(right, Math.max(right_up, \n\nright_down)); \n\n; \n\n} \n\n} \n\n\n\n\n\n\nint\nres = goldTable[\n0\n][\n0\n]; \n\n\nfor\n(\nint\ni = \n1\n; i < m; i++) \n\nres = Math.max(res, goldTable[i][\n0\n]); \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ngold[][]= { {\n1\n, \n3\n, \n1\n, \n5\n}, \n\n{\n2\n, \n2\n, \n4\n, \n1\n}, \n\n{\n5\n, \n0\n, \n2\n, \n3\n}, \n\n{\n0\n, \n6\n, \n1\n, \n2\n} }; \n\n\nint\nm = \n4\n, n = \n4\n; \n\n\nSystem.out.print(getMaxGold(gold, m, n)); \n\n} \n}", "index": 438, "complexity": "3"}
{"back-translation": "class GFG {\n    static void printArray(int A[], int size) {\n        for (int i = 0; i < size; i++)\n            System.out.print(A[i] + \" \");\n        System.out.println();\n    }\n    static void merge(int arr[], int l, int m, int r) {\n        int i, j, k;\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n        for (i = 0; i < n1; i++)\n            L[i] = arr[l + i];\n        for (j = 0; j < n2; j++)\n            R[j] = arr[m + 1 + j];\n        i = 0;\n        j = 0;\n        k = l;\n        while (i < n1 && L[i] < 0)\n            arr[k++] = L[i++];\n        while (j < n2 && R[j] < 0)\n            arr[k++] = R[j++];\n        while (i < n1)\n            arr[k++] = L[i++];\n        while (j < n2)\n            arr[k++] = R[j++];\n    }\n    static void RearrangePosNeg(int arr[], int l, int r) {\n        if (l < r) {\n            int m = l + (r - l) / 2;\n            RearrangePosNeg(arr, l, m);\n            RearrangePosNeg(arr, m + 1, r);\n            merge(arr, l, m, r);\n        }\n    }\n    public static void main(String[] args) {\n        int arr[] = { -12, 11, -13, -5, 6, -7, 5, -3, -6 };\n        int arr_size = arr.length;\n        RearrangePosNeg(arr, 0, arr_size - 1);\n        printArray(arr, arr_size);\n    }\n}", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nprintArray(\nint\nA[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(A[i] + \n\" \"\n); \n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nmerge(\nint\narr[], \nint\nl, \nint\nm, \nint\nr) \n\n{ \n\nint\ni, j, k; \n\nint\nn1 = m - l + \n1\n; \n\nint\nn2 = r - m; \n\n\n\n\nint\nL[] = \nnew\nint\n[n1]; \n\nint\nR[] = \nnew\nint\n[n2]; \n\n\n\n\nfor\n(i = \n0\n; i < n1; i++) \n\nL[i] = arr[l + i]; \n\nfor\n(j = \n0\n; j < n2; j++) \n\nR[j] = arr[m + \n1\n+ j]; \n\n\n\n\n\n\ni = \n0\n; \n\n\n\n\nj = \n0\n; \n\n\n\n\nk = l; \n\n\n\n\n\n\n\n\n\n\n\nwhile\n(i < n1 && L[i] < \n0\n) \n\narr[k++] = L[i++]; \n\n\n\n\nwhile\n(j < n2 && R[j] < \n0\n) \n\narr[k++] = R[j++]; \n\n\n\n\nwhile\n(i < n1) \n\narr[k++] = L[i++]; \n\n\n\n\nwhile\n(j < n2) \n\narr[k++] = R[j++]; \n\n} \n\n\n\n\n\n\nstatic\nvoid\nRearrangePosNeg(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\n\n\n\n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nRearrangePosNeg(arr, l, m); \n\nRearrangePosNeg(arr, m + \n1\n, r); \n\n\nmerge(arr, l, m, r); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { -\n12\n, \n11\n, -\n13\n, -\n5\n, \n6\n, -\n7\n, \n5\n, -\n3\n, -\n6\n}; \n\nint\narr_size = arr.length; \n\nRearrangePosNeg(arr, \n0\n, arr_size - \n1\n); \n\nprintArray(arr, arr_size); \n\n} \n}", "index": 439, "complexity": "3"}
{"back-translation": "class GFG { static boolean isSubsetSum(int set[], int n, int sum) { boolean subset[][] = new boolean[sum+1][n+1]; for (int i = 0; i <= n; i++) subset[0][i] = true; for (int i = 1; i <= sum; i++) subset[i][0] = false; for (int i = 1; i <= sum; i++) { for (int j = 1; j <= n; j++) { subset[i][j] = subset[i][j-1]; if (i >= set[j-1]) subset[i][j] = subset[i][j] || subset[i - set[j-1]][j-1]; } } return subset[sum][n]; } public static void main(String args[]) { int set[] = { 3, 34, 4, 12, 5, 2 }; int sum = 9; int n = set.length; if (isSubsetSum(set, n, sum) == true) System.out.println(\"Found a subset\" + \" with given sum\"); else System.out.println(\"No subset with\" + \" given sum\"); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nisSubsetSum(\nint\nset[], \n\nint\nn, \nint\nsum) \n\n{ \n\n\n\n\n\n\n\nboolean\nsubset[][] = \n\nnew\nboolean\n[sum+\n1\n][n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nsubset[\n0\n][i] = \ntrue\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\nsubset[i][\n0\n] = \nfalse\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\n{ \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) \n\n{ \n\nsubset[i][j] = subset[i][j-\n1\n]; \n\nif\n(i >= set[j-\n1\n]) \n\nsubset[i][j] = subset[i][j] || \n\nsubset[i - set[j-\n1\n]][j-\n1\n]; \n\n} \n\n} \n\n\n\n\n\nreturn\nsubset[sum][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\nset[] = {\n3\n, \n34\n, \n4\n, \n12\n, \n5\n, \n2\n}; \n\nint\nsum = \n9\n; \n\nint\nn = set.length; \n\nif\n(isSubsetSum(set, n, sum) == \ntrue\n) \n\nSystem.out.println(\n\"Found a subset\"\n\n+ \n\" with given sum\"\n); \n\nelse\n\nSystem.out.println(\n\"No subset with\"\n\n+ \n\" given sum\"\n); \n\n} \n}", "index": 440, "complexity": "3"}
{"back-translation": "class GFG { static boolean modularSum(int arr[], int n, int m) { if (n > m) return true; boolean DP[] = new boolean[m]; Arrays.fill(DP, false); for (int i = 0; i < n; i++) { if (DP[0]) return true; boolean temp[] = new boolean[m]; Arrays.fill(temp, false); for (int j = 0; j < m; j++) { if (DP[j] == true) { if (DP[(j + arr[i]) % m] == false) temp[(j + arr[i]) % m] = true; } } for (int j = 0; j < m; j++) if (temp[j]) DP[j] = true; DP[arr[i] % m] = true; } return DP[0]; } public static void main(String arg[]) { int arr[] = {1, 7}; int n = arr.length; int m = 5; if (modularSum(arr, n, m)) System.out.print(\"YES\\n\"); else System.out.print(\"NO\\n\"); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nmodularSum(\nint\narr[], \n\nint\nn, \nint\nm) \n\n{ \n\nif\n(n > m) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\nboolean\nDP[]=\nnew\nboolean\n[m]; \n\n\nArrays.fill(DP, \nfalse\n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\nif\n(DP[\n0\n]) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\n\n\nboolean\ntemp[] = \nnew\nboolean\n[m]; \n\nArrays.fill(temp, \nfalse\n); \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) \n\n{ \n\n\n\n\n\n\nif\n(DP[j] == \ntrue\n) \n\n{ \n\nif\n(DP[(j + arr[i]) % m] == \nfalse\n) \n\n\n\n\n\n\ntemp[(j + arr[i]) % m] = \ntrue\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) \n\nif\n(temp[j]) \n\nDP[j] = \ntrue\n; \n\n\n\n\n\n\n\n\n\nDP[arr[i] % m] = \ntrue\n; \n\n} \n\n\nreturn\nDP[\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = {\n1\n, \n7\n}; \n\nint\nn = arr.length; \n\nint\nm = \n5\n; \n\n\nif\n(modularSum(arr, n, m)) \n\nSystem.out.print(\n\"YES\\n\"\n); \n\nelse\n\nSystem.out.print(\n\"NO\\n\"\n); \n\n} \n}", "index": 441, "complexity": "3"}
{"back-translation": "class GFG {\n    static int largestSubset(int[] a, int n) {\n        Arrays.sort(a);\n        int[] dp = new int[n];\n        dp[n - 1] = 1;\n        for (int i = n - 2; i >= 0; i--) {\n            int mxm = 0;\n            for (int j = i + 1; j < n; j++) {\n                if (a[j] % a[i] == 0) {\n                    mxm = Math.max(mxm, dp[j]);\n                }\n            }\n            dp[i] = 1 + mxm;\n        }\n        return Arrays.stream(dp).max().getAsInt();\n    }\n    public static void main(String[] args) {\n        int[] a = {1, 3, 6, 13, 17, 18};\n        int n = a.length;\n        System.out.println(largestSubset(a, n));\n    }\n}", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nlargestSubset(\nint\n[] a, \nint\nn) \n\n{ \n\n\n\nArrays.sort(a); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n]; \n\n\n\n\ndp[n - \n1\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) { \n\n\n\n\n\n\n\n\nint\nmxm = \n0\n; \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) { \n\nif\n(a[j] % a[i] == \n0\n) { \n\nmxm = Math.max(mxm, dp[j]); \n\n} \n\n} \n\n\ndp[i] = \n1\n+ mxm; \n\n} \n\n\n\n\nreturn\nArrays.stream(dp).max().getAsInt(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\n[] a = { \n1\n, \n3\n, \n6\n, \n13\n, \n17\n, \n18\n}; \n\nint\nn = a.length; \n\nSystem.out.println(largestSubset(a, n)); \n\n} \n}", "index": 442, "complexity": "3"}
{"back-translation": "class RodCutting {\n    static int cutRod(int price[], int n) {\n        int val[] = new int[n+1];\n        val[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int max_val = Integer.MIN_VALUE;\n            for (int j = 0; j < i; j++)\n                max_val = Math.max(max_val, price[j] + val[i-j-1]);\n            val[i] = max_val;\n        }\n        return val[n];\n    }\n\n    public static void main(String args[]) {\n        int arr[] = new int[] {1, 5, 8, 9, 10, 17, 17, 20};\n        int size = arr.length;\n        System.out.println(\"Maximum Obtainable Value is \" + cutRod(arr, size));\n    }\n}", "src": "class\nRodCutting \n{ \n\n\n\nstatic\nint\ncutRod(\nint\nprice[],\nint\nn) \n\n{ \n\nint\nval[] = \nnew\nint\n[n+\n1\n]; \n\nval[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i<=n; i++) \n\n{ \n\nint\nmax_val = Integer.MIN_VALUE; \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nmax_val = Math.max(max_val, \n\nprice[j] + val[i-j-\n1\n]); \n\nval[i] = max_val; \n\n} \n\n\nreturn\nval[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[] {\n1\n, \n5\n, \n8\n, \n9\n, \n10\n, \n17\n, \n17\n, \n20\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Maximum Obtainable Value is \"\n+ \n\ncutRod(arr, size)); \n\n} \n}", "index": 443, "complexity": "3"}
{"back-translation": "class GFG { static int[][] lookup = new int[1000][1000]; static int countSeqUtil(int n, int dif) { if (Math.abs(dif) > n) return 0; if (n == 1 && dif == 0) return 2; if (n == 1 && Math.abs(dif) == 1) return 1; if (lookup[n][n+dif] != -1) return lookup[n][n+dif]; int res = countSeqUtil(n-1, dif+1) + 2*countSeqUtil(n-1, dif) + countSeqUtil(n-1, dif-1); return lookup[n][n+dif] = res; } static int countSeq(int n) { for (int k = 0; k < lookup.length; k++) { for (int j = 0; j < lookup.length; j++) { lookup[k][j] = -1; } } return countSeqUtil(n, 0); } public static void main(String[] args) { int n = 2; System.out.println(\"Count of sequences is \" + countSeq(2)); } }", "src": "class\nGFG { \n\n\n\nstatic\nint\nlookup[][] = \nnew\nint\n[\n1000\n][\n1000\n]; \n\n\n\n\nstatic\nint\ncountSeqUtil(\nint\nn, \nint\ndif) \n{ \n\n\n\n\n\nif\n(Math.abs(dif) > n) \n\nreturn\n0\n; \n\n\n\n\nif\n(n == \n1\n&& dif == \n0\n) \n\nreturn\n2\n; \n\nif\n(n == \n1\n&& Math.abs(dif) == \n1\n) \n\nreturn\n1\n; \n\n\n\n\n\n\n\n\nif\n(lookup[n][n+dif] != -\n1\n) \n\nreturn\nlookup[n][n+dif]; \n\n\nint\nres = \n\n\ncountSeqUtil(n-\n1\n, dif+\n1\n) + \n\n\n\n\n2\n*countSeqUtil(n-\n1\n, dif) + \n\n\n\n\ncountSeqUtil(n-\n1\n, dif-\n1\n); \n\n\n\n\n\n\nreturn\nlookup[n][n+dif] = res; \n} \n\n\n\n\nstatic\nint\ncountSeq(\nint\nn) \n{ \n\n\n\n\n\n\n\nfor\n(\nint\nk = \n0\n; k < lookup.length; k++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < lookup.length; j++) \n\n{ \n\nlookup[k][j] = -\n1\n; \n\n} \n\n} \n\n\n\n\nreturn\ncountSeqUtil(n, \n0\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Count of sequences is \"\n\n+ countSeq(\n2\n)); \n} \n}", "index": 444, "complexity": "3"}
{"back-translation": "class Sequences {\n\n    static int getTotalNumberOfSequences(int m, int n) {\n        int T[][] = new int[m + 1][n + 1];\n        for (int i = 0; i < m + 1; i++) {\n            for (int j = 0; j < n + 1; j++) {\n                if (i == 0 || j == 0) {\n                    T[i][j] = 0;\n                } else if (i < j) {\n                    T[i][j] = 0;\n                } else if (j == 1) {\n                    T[i][j] = i;\n                } else {\n                    T[i][j] = T[i - 1][j] + T[i / 2][j - 1];\n                }\n            }\n        }\n        return T[m][n];\n    }\n\n    public static void main(String[] args) {\n        int m = 10;\n        int n = 4;\n        System.out.println(\"Total number of possible sequences \" + getTotalNumberOfSequences(m, n));\n    }\n}", "src": "class\nSequences \n{ \n\n\n\n\n\nstatic\nint\ngetTotalNumberOfSequences(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\nT[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\nfor\n(\nint\ni=\n0\n; i<m+\n1\n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<n+\n1\n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(i == \n0\n|| j == \n0\n) \n\nT[i][j] = \n0\n; \n\n\n\n\n\n\n\n\nelse\nif\n(i < j) \n\nT[i][j] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\nif\n(j == \n1\n) \n\nT[i][j] = i; \n\n\n\n\nelse\n\nT[i][j] = T[i-\n1\n][j] + T[i/\n2\n][j-\n1\n]; \n\n} \n\n} \n\nreturn\nT[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nm = \n10\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(\n\"Total number of possible sequences \"\n+ \n\ngetTotalNumberOfSequences(m, n)); \n\n} \n}", "index": 445, "complexity": "3"}
{"back-translation": "class GFG { static int MaxSumBS(int arr[], int n) { int max_sum = Integer.MIN_VALUE; int MSIBS[] = new int[n]; int MSDBS[] = new int[n]; for (int i = 0; i < n; i++) { MSDBS[i] = arr[i]; MSIBS[i] = arr[i]; } for (int i = 1; i < n; i++) for (int j = 0; j < i; j++) if (arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) MSIBS[i] = MSIBS[j] + arr[i]; for (int i = n - 2; i >= 0; i--) for (int j = n - 1; j > i; j--) if (arr[i] > arr[j] && MSDBS[i] < MSDBS[j] + arr[i]) MSDBS[i] = MSDBS[j] + arr[i]; for (int i = 0; i < n; i++) max_sum = Math.max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i])); return max_sum; } public static void main(String[] args) { int arr[] = { 1, 15, 51, 45, 33, 100, 12, 18, 9 }; int n = arr.length; System.out.println(\"Maximum Sum : \" + MaxSumBS(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nMaxSumBS(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmax_sum = Integer.MIN_VALUE; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nMSIBS[] = \nnew\nint\n[n]; \n\nint\nMSDBS[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nMSDBS[i] = arr[i]; \n\nMSIBS[i] = arr[i]; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) \n\nMSIBS[i] = MSIBS[j] + arr[i]; \n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && MSDBS[i] < MSDBS[j] + arr[i]) \n\nMSDBS[i] = MSDBS[j] + arr[i]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmax_sum = Math.max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i])); \n\n\n\n\n\n\nreturn\nmax_sum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n15\n, \n51\n, \n45\n, \n33\n, \n100\n, \n12\n, \n18\n, \n9\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum Sum : \"\n+ MaxSumBS(arr, n)); \n\n} \n}", "index": 446, "complexity": "3"}
{"back-translation": "class GFG { static int maxSumIS(int arr[], int n) { int i, j, max = 0; int msis[] = new int[n]; for(i = 0; i < n; i++) msis[i] = arr[i]; for(i = 1; i < n; i++) for(j = 0; j < i; j++) if(arr[i] > arr[j] && msis[i] < msis[j] + arr[i]) msis[i] = msis[j] + arr[i]; for(i = 0; i < n; i++) if(max < msis[i]) max = msis[i]; return max; } public static void main(String args[]) { int arr[] = new int[]{1, 101, 2, 3, 100, 4, 5}; int n = arr.length; System.out.println(\"Sum of maximum sum \" + \"increasing subsequence is \" + maxSumIS(arr, n)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n}", "index": 447, "complexity": "3"}
{"back-translation": "class GFG {\n\n    static int lis(int[] arr, int n) {\n        int[] mpis = new int[n];\n        int max = Integer.MIN_VALUE;\n\n        for (int i = 0; i < n; i++)\n            mpis[i] = arr[i];\n\n        for (int i = 1; i < n; i++)\n            for (int j = 0; j < i; j++)\n                if (arr[i] > arr[j] && mpis[i] < (mpis[j] * arr[i]))\n                    mpis[i] = mpis[j] * arr[i];\n\n        for (int k = 0; k < mpis.length; k++) {\n            if (mpis[k] > max) {\n                max = mpis[k];\n            }\n        }\n\n        return max;\n    }\n\n    static public void main(String[] args) {\n        int[] arr = {3, 100, 4, 5, 150, 6};\n        int n = arr.length;\n\n        System.out.println(lis(arr, n));\n    }\n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlis(\nint\n[] arr, \nint\nn) \n\n{ \n\nint\n[] mpis = \nnew\nint\n[n]; \n\nint\nmax = Integer.MIN_VALUE; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmpis[i] = arr[i]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && mpis[i] \n\n< (mpis[j] * arr[i])) \n\nmpis[i] = mpis[j] * arr[i]; \n\n\n\n\nfor\n(\nint\nk = \n0\n; k < mpis.length; k++) \n\n{ \n\nif\n(mpis[k] > max) { \n\nmax = mpis[k]; \n\n} \n\n} \n\n\nreturn\nmax; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] arr = { \n3\n, \n100\n, \n4\n, \n5\n, \n150\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(lis(arr, n)); \n\n} \n}", "index": 448, "complexity": "3"}
{"back-translation": "class GFG { static int longestSubseqWithDiffOne(int arr[], int n) { int dp[] = new int[n]; for (int i = 0; i < n; i++) dp[i] = 1; for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { if ((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) dp[i] = Math.max(dp[i], dp[j]+1); } } int result = 1; for (int i = 0; i < n ; i++) if (result < dp[i]) result = dp[i]; return result; } public static void main(String[] args) { int arr[] = {1, 2, 3, 4, 5, 3, 2}; int n = arr.length; System.out.println(longestSubseqWithDiffOne(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlongestSubseqWithDiffOne(\nint\narr[], \n\nint\nn) \n\n{ \n\n\n\n\n\nint\ndp[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i< n; i++) \n\ndp[i] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n\n\n\n\n\n\nif\n((arr[i] == arr[j] + \n1\n) || \n\n(arr[i] == arr[j] - \n1\n)) \n\n\ndp[i] = Math.max(dp[i], dp[j]+\n1\n); \n\n} \n\n} \n\n\n\n\n\n\nint\nresult = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n ; i++) \n\nif\n(result < dp[i]) \n\nresult = dp[i]; \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\n\n\n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n3\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(longestSubseqWithDiffOne( \n\narr, n)); \n\n} \n}", "index": 449, "complexity": "3"}
{"back-translation": "class GFG { public static int maxLenSub(int arr[], int n) { int mls[] = new int[n], max = 0; for (int i = 0; i < n; i++) mls[i] = 1; for (int i = 1; i < n; i++) for (int j = 0; j < i; j++) if (Math.abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) mls[i] = mls[j] + 1; for (int i = 0; i < n; i++) if (max < mls[i]) max = mls[i]; return max; } public static void main(String[] args) { int arr[] = { 2, 5, 6, 3, 7, 6, 5, 8 }; int n = arr.length; System.out.println(\"Maximum length subsequence = \" + maxLenSub(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nmaxLenSub(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmls[] = \nnew\nint\n[n], max = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmls[i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(Math.abs(arr[i] - arr[j]) <= \n1\n\n&& mls[i] < mls[j] + \n1\n) \n\nmls[i] = mls[j] + \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(max < mls[i]) \n\nmax = mls[i]; \n\n\n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n5\n, \n6\n, \n3\n, \n7\n, \n6\n, \n5\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum length subsequence = \"\n+ \n\nmaxLenSub(arr, n)); \n\n\n} \n}", "index": 450, "complexity": "3"}
{"back-translation": "class GFG {\n\nstatic int pre_compute(int a[], int n, int index, int k) {\nint[][] dp = new int[n][n];\nfor (int i = 0; i < n; i++) {\nif (a[i] > a[0])\ndp[0][i] = a[i] + a[0];\nelse\ndp[0][i] = a[i];\n}\nfor (int i = 1; i < n; i++) {\nfor (int j = 0; j < n; j++) {\nif (a[j] > a[i] && j > i) {\nif (dp[i - 1][i] + a[j] > dp[i - 1][j])\ndp[i][j] = dp[i - 1][i] + a[j];\nelse\ndp[i][j] = dp[i - 1][j];\n}\nelse\ndp[i][j] = dp[i - 1][j];\n}\n}\nreturn dp[index][k];\n}\n\npublic static void main(String[] args) {\nint a[] = {1, 101, 2, 3, 100, 4, 5};\nint n = a.length;\nint index = 4, k = 6;\nSystem.out.println(pre_compute(a, n, index, k));\n}\n}", "src": "class\nGFG { \n\n\nstatic\nint\npre_compute(\nint\na[], \nint\nn, \n\nint\nindex, \nint\nk) \n\n{ \n\nint\ndp[][] = \nnew\nint\n[n][n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(a[i] > a[\n0\n]) \n\ndp[\n0\n][i] = a[i] + a[\n0\n]; \n\nelse\n\ndp[\n0\n][i] = a[i]; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nif\n(a[j] > a[i] && j > i) \n\n{ \n\nif\n(dp[i - \n1\n][i] + a[j] > \n\ndp[i - \n1\n][j]) \n\ndp[i][j] = dp[i - \n1\n][i] \n\n+ a[j]; \n\nelse\n\ndp[i][j] = dp[i - \n1\n][j]; \n\n} \n\nelse\n\ndp[i][j] = dp[i - \n1\n][j]; \n\n} \n\n} \n\n\n\n\nreturn\ndp[index][k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = { \n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = a.length; \n\nint\nindex = \n4\n, k = \n6\n; \n\nSystem.out.println( \n\npre_compute(a, n, index, k)); \n\n} \n}", "index": 451, "complexity": "3"}
{"back-translation": "class Pair {\n    int a;\n    int b;\n\n    public Pair(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n\n    static int maxChainLength(Pair arr[], int n) {\n        int i, j, max = 0;\n        int mcl[] = new int[n];\n\n        for (i = 0; i < n; i++)\n            mcl[i] = 1;\n\n        for (i = 1; i < n; i++)\n            for (j = 0; j < i; j++)\n                if (arr[i].a > arr[j].b && mcl[i] < mcl[j] + 1)\n                    mcl[i] = mcl[j] + 1;\n\n        for (i = 0; i < n; i++)\n            if (max < mcl[i])\n                max = mcl[i];\n\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Pair arr[] = new Pair[] {\n            new Pair(5, 24),\n            new Pair(15, 25),\n            new Pair(27, 40),\n            new Pair(50, 60)\n        };\n\n        System.out.println(\"Length of maximum size chain is \" + maxChainLength(arr, arr.length));\n    }\n}", "src": "class\nPair{ \n\nint\na; \n\nint\nb; \n\n\npublic\nPair(\nint\na, \nint\nb) { \n\nthis\n.a = a; \n\nthis\n.b = b; \n\n} \n\n\n\n\n\n\nstatic\nint\nmaxChainLength(Pair arr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmcl[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nmcl[i] = \n1\n; \n\n\n\n\nfor\n( i = \n1\n; i < n; i++ ) \n\nfor\n( j = \n0\n; j < i; j++ ) \n\nif\n( arr[i].a > arr[j].b && mcl[i] < mcl[j] + \n1\n) \n\nmcl[i] = mcl[j] + \n1\n; \n\n\n\n\n\n\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nif\n( max < mcl[i] ) \n\nmax = mcl[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nPair arr[] = \nnew\nPair[] {\nnew\nPair(\n5\n,\n24\n), \nnew\nPair(\n15\n, \n25\n), \n\nnew\nPair (\n27\n, \n40\n), \nnew\nPair(\n50\n, \n60\n)}; \n\nSystem.out.println(\n\"Length of maximum size chain is \"\n+ \n\nmaxChainLength(arr, arr.length)); \n\n} \n}", "index": 452, "complexity": "3"}
{"back-translation": "ERROR", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMaxSubSquare(\nint\nM[][]) \n\n{ \n\nint\ni,j; \n\nint\nR = M.length; \n\n\nint\nC = M[\n0\n].length; \n\n\nint\nS[][] = \nnew\nint\n[R][C]; \n\n\nint\nmax_of_s, max_i, max_j; \n\n\n\n\nfor\n(i = \n0\n; i < R; i++) \n\nS[i][\n0\n] = M[i][\n0\n]; \n\n\n\n\nfor\n(j = \n0\n; j < C; j++) \n\nS[\n0\n][j] = M[\n0\n][j]; \n\n\n\n\nfor\n(i = \n1\n; i < R; i++) \n\n{ \n\nfor\n(j = \n1\n; j < C; j++) \n\n{ \n\nif\n(M[i][j] == \n1\n) \n\nS[i][j] = Math.min(S[i][j-\n1\n], \n\nMath.min(S[i-\n1\n][j], S[i-\n1\n][j-\n1\n])) + \n1\n; \n\nelse\n\nS[i][j] = \n0\n; \n\n} \n\n} \n\n\n\n\nmax_of_s = S[\n0\n][\n0\n]; max_i = \n0\n; max_j = \n0\n; \n\nfor\n(i = \n0\n; i < R; i++) \n\n{ \n\nfor\n(j = \n0\n; j < C; j++) \n\n{ \n\nif\n(max_of_s < S[i][j]) \n\n{ \n\nmax_of_s = S[i][j]; \n\nmax_i = i; \n\nmax_j = j; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\"Maximum size sub-matrix is: \"\n); \n\nfor\n(i = max_i; i > max_i - max_of_s; i--) \n\n{ \n\nfor\n(j = max_j; j > max_j - max_of_s; j--) \n\n{ \n\nSystem.out.print(M[i][j] + \n\" \"\n); \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nM[][] = {{\n0\n, \n1\n, \n1\n, \n0\n, \n1\n}, \n\n{\n1\n, \n1\n, \n0\n, \n1\n, \n0\n}, \n\n{\n0\n, \n1\n, \n1\n, \n1\n, \n0\n}, \n\n{\n1\n, \n1\n, \n1\n, \n1\n, \n0\n}, \n\n{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n}, \n\n{\n0\n, \n0\n, \n0\n, \n0\n, \n0\n}}; \n\n\nprintMaxSubSquare(M); \n\n} \n\n}", "index": 453, "complexity": "3"}
{"back-translation": "class GFG {\n\npublic static int maxCost(int[][] mat, int N) {\n\nint[][] dp = new int[N][N];\n\ndp[0][0] = mat[0][0];\n\nfor (int i = 1; i < N; i++)\ndp[i][0] = mat[i][0] + dp[i - 1][0];\n\nfor (int i = 1; i < N; i++)\nfor (int j = 1; j < i + 1 && j < N; j++)\ndp[i][j] = mat[i][j] + Math.max(dp[i - 1][j - 1], dp[i - 1][j]);\n\nint result = 0;\n\nfor (int i = 0; i < N; i++)\nif (result < dp[N - 1][i])\nresult = dp[N - 1][i];\n\nreturn result;\n\n}\n\npublic static void main(String[] args) {\n\nint mat[][] = { { 4, 1, 5, 6, 1 }, { 2, 9, 2, 11, 10 }, { 15, 1, 3, 15, 2 }, { 16, 92, 41, 4, 3 }, { 8, 142, 6, 4, 8 } };\n\nint N = 5;\n\nSystem.out.println(\"Maximum Path Sum : \" + maxCost(mat, N));\n\n}\n}", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nmaxCost(\nint\nmat[][], \nint\nN) \n\n{ \n\n\n\n\n\nint\ndp[][]=\nnew\nint\n[N][N]; \n\n\ndp[\n0\n][\n0\n] = mat[\n0\n][\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\ndp[i][\n0\n] = mat[i][\n0\n] + dp[i-\n1\n][\n0\n]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j < i + \n1\n&& j < N; j++) \n\ndp[i][j] = mat[i][j] + \n\nMath.max(dp[i-\n1\n][j-\n1\n], \n\ndp[i-\n1\n][j]); \n\n\n\n\n\n\nint\nresult = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\nif\n(result < dp[N-\n1\n][i]) \n\nresult = dp[N-\n1\n][i]; \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n4\n, \n1\n,\n5\n,\n6\n, \n1\n}, \n\n{ \n2\n,\n9\n,\n2\n,\n11\n,\n10\n}, \n\n{ \n15\n,\n1\n,\n3\n,\n15\n, \n2\n}, \n\n{ \n16\n, \n92\n, \n41\n,\n4\n,\n3\n}, \n\n{ \n8\n, \n142\n, \n6\n, \n4\n, \n8\n} \n\n}; \n\nint\nN = \n5\n; \n\nSystem.out.println(\n\"Maximum Path Sum : \"\n+ \n\nmaxCost(mat, N)); \n\n} \n}", "index": 454, "complexity": "3"}
{"back-translation": "class GFG {\n\n    static int N = 4;\n\n    static int MaximumPath(int Mat[][]) {\n        int result = 0;\n        int dp[][] = new int[N][N + 2];\n\n        for (int[] rows : dp)\n            Arrays.fill(rows, 0);\n\n        for (int i = 0; i < N; i++)\n            dp[0][i + 1] = Mat[0][i];\n\n        for (int i = 1; i < N; i++)\n            for (int j = 1; j <= N; j++)\n                dp[i][j] = Math.max(dp[i - 1][j - 1], Math.max(dp[i - 1][j], dp[i - 1][j + 1])) + Mat[i][j - 1];\n\n        for (int i = 0; i <= N; i++)\n            result = Math.max(result, dp[N - 1][i]);\n\n        return result;\n    }\n\n    public static void main(String arg[]) {\n\n        int Mat[][] = { { 4, 2, 3, 4 }, { 2, 9, 1, 10 }, { 15, 1, 3, 0 }, { 16, 92, 41, 44 } };\n\n        System.out.println(MaximumPath(Mat));\n    }\n}", "src": "class\nGFG { \n\n\nstatic\nint\nN = \n4\n; \n\n\n\n\nstatic\nint\nMaximumPath(\nint\nMat[][]) \n\n{ \n\nint\nresult = \n0\n; \n\n\n\n\n\n\nint\ndp[][] = \nnew\nint\n[N][N + \n2\n]; \n\n\n\n\nfor\n(\nint\n[] rows : dp) \n\nArrays.fill(rows, \n0\n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ndp[\n0\n][i + \n1\n] = Mat[\n0\n][i]; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j <= N; j++) \n\ndp[i][j] = Math.max(dp[i - \n1\n][j - \n1\n], \n\nMath.max(dp[i - \n1\n][j], \n\ndp[i - \n1\n][j + \n1\n])) + \n\nMat[i][j - \n1\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= N; i++) \n\nresult = Math.max(result, dp[N - \n1\n][i]); \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nMat[][] = { { \n4\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n2\n, \n9\n, \n1\n, \n10\n}, \n\n{ \n15\n, \n1\n, \n3\n, \n0\n}, \n\n{ \n16\n, \n92\n, \n41\n, \n44\n} }; \n\n\nSystem.out.println(MaximumPath(Mat)); \n\n} \n}", "index": 455, "complexity": "3"}
{"back-translation": "class MinimumCostPath { private static int min(int x, int y, int z) { return Math.min(Math.min(x, y), z); } private static int minCost(int[][] cost, int m, int n) { int[][] tc = new int[m + 1][n + 1]; tc[0][0] = cost[0][0]; for (int i = 1; i <= m; i++) tc[i][0] = tc[i - 1][0] + cost[i][0]; for (int j = 1; j <= n; j++) tc[0][j] = tc[0][j - 1] + cost[0][j]; for (int i = 1; i <= m; i++) for (int j = 1; j <= n; j++) tc[i][j] = min(tc[i - 1][j - 1], tc[i - 1][j], tc[i][j - 1]) + cost[i][j]; return tc[m][n]; } public static void main(String args[]) { int cost[][] = {{1, 2, 3}, {4, 8, 2}, {1, 5, 3}}; System.out.println(minCost(cost, 2, 2)); } }", "src": "class\nMinimumCostPath \n{ \n\n\n\nprivate\nstatic\nint\nmin(\nint\nx, \nint\ny, \nint\nz) \n\n{ \n\nif\n(x < y) \n\nreturn\n(x < z)? x : z; \n\nelse\n\nreturn\n(y < z)? y : z; \n\n} \n\n\nprivate\nstatic\nint\nminCost(\nint\ncost[][], \nint\nm, \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\ntc[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\ntc[\n0\n][\n0\n] = cost[\n0\n][\n0\n]; \n\n\n\n\nfor\n(i = \n1\n; i <= m; i++) \n\ntc[i][\n0\n] = tc[i-\n1\n][\n0\n] + cost[i][\n0\n]; \n\n\n\n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[\n0\n][j] = tc[\n0\n][j-\n1\n] + cost[\n0\n][j]; \n\n\n\n\nfor\n(i = \n1\n; i <= m; i++) \n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[i][j] = min(tc[i-\n1\n][j-\n1\n], \n\ntc[i-\n1\n][j], \n\ntc[i][j-\n1\n]) + cost[i][j]; \n\n\nreturn\ntc[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\ncost[][]= {{\n1\n, \n2\n, \n3\n}, \n\n{\n4\n, \n8\n, \n2\n}, \n\n{\n1\n, \n5\n, \n3\n}}; \n\nSystem.out.println(minCost(cost,\n2\n,\n2\n)); \n\n} \n}", "index": 456, "complexity": "3"}
{"back-translation": "class GFG { private static int minJumps(int[] arr, int n) { int jumps[] = new int[n]; int i, j; if (n == 0 || arr[0] == 0) return Integer.MAX_VALUE; jumps[0] = 0; for (i = 1; i < n; i++) { jumps[i] = Integer.MAX_VALUE; for (j = 0; j < i; j++) { if (i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) { jumps[i] = Math.min(jumps[i], jumps[j] + 1); break; } } } return jumps[n - 1]; } public static void main(String[] args) { int arr[] = { 1, 3, 6, 1, 0, 9 }; System.out.println(\"Minimum number of jumps to reach end is : \" + minJumps(arr, arr.length)); } }", "src": "class\nGFG{ \n\nprivate\nstatic\nint\nminJumps(\nint\n[] arr, \nint\nn) { \n\nint\njumps[] = \nnew\nint\n[n]; \n\n\n\n\nint\ni, j; \n\n\nif\n(n == \n0\n|| arr[\n0\n] == \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\n\n\n\n\njumps[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\njumps[i] = Integer.MAX_VALUE; \n\nfor\n(j = \n0\n; j < i; j++) \n\n{ \n\nif\n(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) \n\n{ \n\njumps[i] = Math.min(jumps[i], jumps[j] + \n1\n); \n\nbreak\n; \n\n} \n\n} \n\n} \n\nreturn\njumps[n-\n1\n]; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\n\nSystem.out.println(\n\"Minimum number of jumps to reach end is : \"\n+ \n\nminJumps(arr,arr.length)); \n\n} \n}", "index": 457, "complexity": "3"}
{"back-translation": "class GFG { static int MAX = 100; static int[][] dp = new int[MAX][MAX]; static int countRemovals(int[] a, int i, int j, int k) { if (i >= j) return 0; else if ((a[j] - a[i]) <= k) return 0; else if (dp[i][j] != -1) return dp[i][j]; else if ((a[j] - a[i]) > k) { dp[i][j] = 1 + Math.min(countRemovals(a, i + 1, j, k), countRemovals(a, i, j - 1, k)); } return dp[i][j]; } static int removals(int[] a, int n, int k) { Arrays.sort(a); for (int[] rows : dp) Arrays.fill(rows,-1); if (n == 1) return 0; else return countRemovals(a, 0, n - 1, k); } public static void main (String[] args) { int a[] = { 1, 3, 4, 9, 10, 11, 12, 17, 20 }; int n = a.length; int k = 4; System.out.print(removals(a, n, k)); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nMAX=\n100\n; \n\nstatic\nint\ndp[][]=\nnew\nint\n[MAX][MAX]; \n\n\n\n\n\n\nstatic\nint\ncountRemovals(\nint\na[], \nint\ni, \nint\nj, \nint\nk) \n\n{ \n\n\n\nif\n(i >= j) \n\nreturn\n0\n; \n\n\n\n\n\n\nelse\nif\n((a[j] - a[i]) <= k) \n\nreturn\n0\n; \n\n\n\n\nelse\nif\n(dp[i][j] != -\n1\n) \n\nreturn\ndp[i][j]; \n\n\n\n\nelse\nif\n((a[j] - a[i]) > k) { \n\n\n\n\n\n\n\n\ndp[i][j] = \n1\n+ Math.min(countRemovals(a, i + \n1\n, j, k), \n\ncountRemovals(a, i, j - \n1\n, k)); \n\n} \n\nreturn\ndp[i][j]; \n\n} \n\n\n\n\nstatic\nint\nremovals(\nint\na[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nArrays.sort(a); \n\n\n\n\n\n\nfor\n(\nint\n[] rows:dp) \n\nArrays.fill(rows,-\n1\n); \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\nelse\n\nreturn\ncountRemovals(a, \n0\n, n - \n1\n, k); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\na[] = { \n1\n, \n3\n, \n4\n, \n9\n, \n10\n, \n11\n, \n12\n, \n17\n, \n20\n}; \n\nint\nn = a.length; \n\nint\nk = \n4\n; \n\nSystem.out.print(removals(a, n, k)); \n\n} \n}", "index": 458, "complexity": "3"}
{"back-translation": "class EDIST { public static int min(int x, int y, int z) { if (x <= y && x <= z) return x; if (y <= x && y <= z) return y; else return z; } public static int editDistDP(String str1, String str2, int m, int n) { int dp[][] = new int[m + 1][n + 1]; for (int i = 0; i <= m; i++) { for (int j = 0; j <= n; j++) { if (i == 0) dp[i][j] = j; else if (j == 0) dp[i][j] = i; else if (str1.charAt(i - 1) == str2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]); } } return dp[m][n]; } public static void main(String args[]) { String str1 = \"sunday\"; String str2 = \"saturday\"; System.out.println(editDistDP(str1, str2, str1.length(), str2.length())); } }", "src": "class\nEDIST \n{ \n\nstatic\nint\nmin(\nint\nx,\nint\ny,\nint\nz) \n\n{ \n\nif\n(x <= y && x <= z) \nreturn\nx; \n\nif\n(y <= x && y <= z) \nreturn\ny; \n\nelse\nreturn\nz; \n\n} \n\n\nstatic\nint\neditDistDP(String str1, String str2, \nint\nm, \nint\nn) \n\n{ \n\n\n\nint\ndp[][] = \nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<=m; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<=n; j++) \n\n{ \n\n\n\n\n\nif\n(i==\n0\n) \n\ndp[i][j] = j; \n\n\n\n\n\n\n\nelse\nif\n(j==\n0\n) \n\ndp[i][j] = i; \n\n\n\n\n\n\n\nelse\nif\n(str1.charAt(i-\n1\n) == str2.charAt(j-\n1\n)) \n\ndp[i][j] = dp[i-\n1\n][j-\n1\n]; \n\n\n\n\n\n\nelse\n\ndp[i][j] = \n1\n+ min(dp[i][j-\n1\n], \n\n\ndp[i-\n1\n][j], \n\n\ndp[i-\n1\n][j-\n1\n]); \n\n\n} \n\n} \n\n\nreturn\ndp[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str1 = \n\"sunday\"\n; \n\nString str2 = \n\"saturday\"\n; \n\nSystem.out.println( editDistDP( str1 , str2 , str1.length(), str2.length()) ); \n\n} \n}", "index": 459, "complexity": "3"}
{"back-translation": "public class LongestCommonSubSequence { static int LCSubStr(char X[], char Y[], int m, int n) { int LCStuff[][] = new int[m + 1][n + 1]; int result = 0; for (int i = 0; i <= m; i++) { for (int j = 0; j <= n; j++) { if (i == 0 || j == 0) LCStuff[i][j] = 0; else if (X[i - 1] == Y[j - 1]) { LCStuff[i][j] = LCStuff[i - 1][j - 1] + 1; result = Math.max(result, LCStuff[i][j]); } else LCStuff[i][j] = 0; } } return result; } public static void main(String[] args) { String X = \"OldSite:GeeksforGeeks.org\"; String Y = \"NewSite:GeeksQuiz.com\"; int m = X.length(); int n = Y.length(); System.out.println(\"Length of Longest Common Substring is \" + LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); } }", "src": "public\nclass\nLongestCommonSubSequence \n{ \n\n\n\nstatic\nint\nLCSubStr(\nchar\nX[], \nchar\nY[], \nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\nint\nLCStuff[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\nint\nresult = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= m; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\n{ \n\nif\n(i == \n0\n|| j == \n0\n) \n\nLCStuff[i][j] = \n0\n; \n\nelse\nif\n(X[i - \n1\n] == Y[j - \n1\n]) \n\n{ \n\nLCStuff[i][j] = LCStuff[i - \n1\n][j - \n1\n] + \n1\n; \n\nresult = Integer.max(result, LCStuff[i][j]); \n\n} \n\nelse\n\nLCStuff[i][j] = \n0\n; \n\n} \n\n} \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString X = \n\"OldSite:GeeksforGeeks.org\"\n; \n\nString Y = \n\"NewSite:GeeksQuiz.com\"\n; \n\n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\nSystem.out.println(\n\"Length of Longest Common Substring is \"\n\n+ LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); \n\n} \n}", "index": 460, "complexity": "3"}
{"back-translation": "public class GFG { static int LCSubStr(String X, String Y) { int m = X.length(); int n = Y.length(); int result = 0; int[][] len = new int[2][n]; int currRow = 0; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (i == 0 || j == 0) { len[currRow][j] = 0; } else if (X.charAt(i - 1) == Y.charAt(j - 1)) { len[currRow][j] = len[(1 - currRow)][(j - 1)] + 1; result = Math.max(result, len[currRow][j]); } else { len[currRow][j] = 0; } } currRow = 1 - currRow; } return result; } public static void main(String args[]) { String X = \"GeeksforGeeks\"; String Y = \"GeeksQuiz\"; System.out.print(LCSubStr(X, Y)); } }", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\nLCSubStr(String X, String Y) \n\n{ \n\n\n\n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\n\n\n\n\nint\nresult = \n0\n; \n\n\n\n\n\n\nint\n[][]len = \nnew\nint\n[\n2\n][n]; \n\n\n\n\n\n\nint\ncurrRow = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < m; i++) { \n\nfor\n(\nint\nj = \n0\n; j < n; j++) { \n\nif\n(i == \n0\n|| j == \n0\n) { \n\nlen[currRow][j] = \n0\n; \n\n} \n\nelse\nif\n(X.charAt(i - \n1\n) == \n\nY.charAt(j - \n1\n)) \n\n{ \n\nlen[currRow][j] = \n\nlen[(\n1\n- currRow)][(j - \n1\n)] \n\n+ \n1\n; \n\nresult = Math.max(result, \n\nlen[currRow][j]); \n\n} \n\nelse\n\n{ \n\nlen[currRow][j] = \n0\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\ncurrRow = \n1\n- currRow; \n\n} \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString X = \n\"GeeksforGeeks\"\n; \n\nString Y = \n\"GeeksQuiz\"\n; \n\n\nSystem.out.print(LCSubStr(X, Y)); \n\n} \n}", "index": 461, "complexity": "3"}
{"back-translation": "class GFG { static int offeringNumber(int n, int[] templeHeight) { int sum = 0; for (int i = 0; i < n; ++i) { int left = 0, right = 0; for (int j = i - 1; j >= 0; --j) { if (templeHeight[j] < templeHeight[j + 1]) ++left; else break; } for (int j = i + 1; j < n; ++j) { if (templeHeight[j] < templeHeight[j - 1]) ++right; else break; } sum += Math.max(right, left) + 1; } return sum; } public static void main(String[] args) { int arr1[] = { 1, 2, 2 }; System.out.println(offeringNumber(3, arr1)); int arr2[] = { 1, 4, 3, 6, 2, 1 }; System.out.println(offeringNumber(6, arr2)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nofferingNumber(\nint\nn, \n\nint\ntempleHeight[]) \n{ \n\nint\nsum = \n0\n; \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\n\n\n\n\nint\nleft = \n0\n, right = \n0\n; \n\nfor\n(\nint\nj = i - \n1\n; j >= \n0\n; --j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j + \n1\n]) \n\n++left; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j - \n1\n]) \n\n++right; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\n\n\n\n\nsum += Math.max(right, left) + \n1\n; \n\n} \n\n\nreturn\nsum; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \nint\narr1[] = {\n1\n, \n2\n, \n2\n}; \nSystem.out.println(offeringNumber(\n3\n, arr1)); \nint\narr2[] = {\n1\n, \n4\n, \n3\n, \n\n6\n, \n2\n, \n1\n}; \nSystem.out.println(offeringNumber(\n6\n, arr2)); \n} \n}", "index": 462, "complexity": "3"}
{"back-translation": "class GFG { static void printEqualSumSets(int[] arr, int n) { int i, currSum, sum = 0; for (i = 0; i < arr.length; i++) sum += arr[i]; if ((sum & 1) == 1) { System.out.print(\"-1\"); return; } int k = sum >> 1; boolean[][] dp = new boolean[n + 1][k + 1]; for (i = 1; i <= k; i++) dp[0][i] = false; for (i = 0; i <= n; i++) dp[i][0] = true; for (i = 1; i <= n; i++) { for (currSum = 1; currSum <= k; currSum++) { dp[i][currSum] = dp[i - 1][currSum]; if (arr[i - 1] <= currSum) dp[i][currSum] = dp[i][currSum] | dp[i - 1][currSum - arr[i - 1]]; } } List<Integer> set1 = new ArrayList<Integer>(); List<Integer> set2 = new ArrayList<Integer>(); if (!dp[n][k]) { System.out.print(\"-1\\n\"); return; } i = n; currSum = k; while (i > 0 && currSum >= 0) { if (dp[i - 1][currSum]) { i--; set2.add(arr[i]); } else if (dp[i - 1][currSum - arr[i - 1]]) { i--; currSum -= arr[i]; set1.add(arr[i]); } } System.out.print(\"Set 1 elements: \"); for (i = 0; i < set1.size(); i++) System.out.print(set1.get(i) + \" \"); System.out.print(\"\\nSet 2 elements: \"); for (i = 0; i < set2.size(); i++) System.out.print(set2.get(i) + \" \"); } public static void main(String args[]) { int[] arr = new int[]{5, 5, 1, 11}; int n = arr.length; printEqualSumSets(arr, n); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nvoid\nprintEqualSumSets(\nint\n[]arr, \n\nint\nn) \n\n{ \n\nint\ni, currSum, sum = \n0\n; \n\n\n\n\nfor\n(i = \n0\n; i < arr.length; i++) \n\nsum += arr[i]; \n\n\n\n\n\n\n\n\n\n\nif\n((sum & \n1\n) == \n1\n) \n\n{ \n\nSystem.out.print(\n\"-1\"\n); \n\nreturn\n; \n\n} \n\n\n\n\n\n\nint\nk = sum >> \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nboolean\n[][]dp = \nnew\nboolean\n[n + \n1\n][k + \n1\n]; \n\n\n\n\n\n\nfor\n(i = \n1\n; i <= k; i++) \n\ndp[\n0\n][i] = \nfalse\n; \n\n\n\n\n\n\nfor\n(i = \n0\n; i <= n; i++) \n\ndp[i][\n0\n] = \ntrue\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i <= n; i++) \n\n{ \n\nfor\n(currSum = \n1\n; \n\ncurrSum <= k; \n\ncurrSum++) \n\n{ \n\n\n\n\ndp[i][currSum] = dp[i - \n1\n][currSum]; \n\n\n\n\nif\n(arr[i - \n1\n] <= currSum) \n\ndp[i][currSum] = dp[i][currSum] | \n\ndp[i - \n1\n][currSum - arr[i - \n1\n]]; \n\n} \n\n} \n\n\n\n\nList<Integer> set1 = \nnew\nArrayList<Integer>(); \n\nList<Integer> set2 = \nnew\nArrayList<Integer>(); \n\n\n\n\n\n\nif\n(!dp[n][k]) \n\n{ \n\nSystem.out.print(\n\"-1\\n\"\n); \n\nreturn\n; \n\n} \n\n\n\n\n\n\ni = n; \n\ncurrSum = k; \n\n\nwhile\n(i > \n0\n&& currSum >= \n0\n) \n\n{ \n\n\n\n\n\n\n\n\nif\n(dp[i - \n1\n][currSum]) \n\n{ \n\ni--; \n\nset2.add(arr[i]); \n\n} \n\n\n\n\n\n\nelse\nif\n(dp[i - \n1\n][currSum - arr[i - \n1\n]]) \n\n{ \n\ni--; \n\ncurrSum -= arr[i]; \n\nset1.add(arr[i]); \n\n} \n\n} \n\n\n\n\nSystem.out.print(\n\"Set 1 elements: \"\n); \n\nfor\n(i = \n0\n; i < set1.size(); i++) \n\nSystem.out.print(set1.get(i) + \n\" \"\n); \n\n\nSystem.out.print(\n\"\\nSet 2 elements: \"\n); \n\n\nfor\n(i = \n0\n; i < set2.size(); i++) \n\nSystem.out.print(set2.get(i) + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = \nnew\nint\n[]{ \n5\n, \n5\n, \n1\n, \n11\n}; \n\nint\nn = arr.length; \n\nprintEqualSumSets(arr, n); \n\n} \n}", "index": 463, "complexity": "3"}
{"back-translation": "public class LBS { static int lbs(int[] arr, int n) { int i, j; int[] lis = new int[n]; for (i = 0; i < n; i++) lis[i] = 1; for (i = 1; i < n; i++) for (j = 0; j < i; j++) if (arr[i] > arr[j] && lis[i] < lis[j] + 1) lis[i] = lis[j] + 1; int[] lds = new int[n]; for (i = 0; i < n; i++) lds[i] = 1; for (i = n - 2; i >= 0; i--) for (j = n - 1; j > i; j--) if (arr[i] > arr[j] && lds[i] < lds[j] + 1) lds[i] = lds[j] + 1; int max = lis[0] + lds[0] - 1; for (i = 1; i < n; i++) if (lis[i] + lds[i] - 1 > max) max = lis[i] + lds[i] - 1; return max; } public static void main(String[] args) { int arr[] = { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 }; int n = arr.length; System.out.println(\"Length of LBS is \" + lbs(arr, n)); } }", "src": "class\nLBS \n{ \n\n\n\nstatic\nint\nlbs( \nint\narr[], \nint\nn ) \n\n{ \n\nint\ni, j; \n\n\n\n\nint\n[] lis = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlis[i] = \n1\n; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && lis[i] < lis[j] + \n1\n) \n\nlis[i] = lis[j] + \n1\n; \n\n\n\n\nint\n[] lds = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlds[i] = \n1\n; \n\n\n\n\nfor\n(i = n-\n2\n; i >= \n0\n; i--) \n\nfor\n(j = n-\n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && lds[i] < lds[j] + \n1\n) \n\nlds[i] = lds[j] + \n1\n; \n\n\n\n\n\nint\nmax = lis[\n0\n] + lds[\n0\n] - \n1\n; \n\nfor\n(i = \n1\n; i < n; i++) \n\nif\n(lis[i] + lds[i] - \n1\n> max) \n\nmax = lis[i] + lds[i] - \n1\n; \n\n\nreturn\nmax; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n0\n, \n8\n, \n4\n, \n12\n, \n2\n, \n10\n, \n6\n, \n14\n, \n1\n, \n9\n, \n5\n, \n\n13\n, \n3\n, \n11\n, \n7\n, \n15\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of LBS is \"\n+ lbs( arr, n )); \n\n} \n}", "index": 464, "complexity": "3"}
{"back-translation": "class GFG { static int lps(String s) { int n = s.length(); int a[] = new int[n]; for (int i = n - 1; i >= 0; i--) { int back_up = 0; for (int j = i; j < n; j++) { if (j == i) a[j] = 1; else if (s.charAt(i) == s.charAt(j)) { int temp = a[j]; a[j] = back_up + 2; back_up = temp; } else { back_up = a[j]; a[j] = Math.max(a[j - 1], a[j]); } } } return a[n - 1]; } public static void main(String[] args) { String str = \"GEEKSFORGEEKS\"; System.out.println(lps(str)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlps(String s) \n\n{ \n\nint\nn = s.length(); \n\n\n\n\n\n\n\n\nint\na[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(\nint\ni = n - \n1\n; i >= \n0\n; i--) \n\n{ \n\nint\nback_up = \n0\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i; j < n; j++) { \n\n\n\n\n\n\n\n\nif\n(j == i) \n\na[j] = \n1\n; \n\n\n\n\n\n\n\n\nelse\nif\n(s.charAt(i) == s.charAt(j)) \n\n{ \n\nint\ntemp = a[j]; \n\na[j] = back_up + \n2\n; \n\nback_up = temp; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\nback_up = a[j]; \n\na[j] = Math.max(a[j - \n1\n], a[j]); \n\n} \n\n} \n\n} \n\nreturn\na[n - \n1\n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"GEEKSFORGEEKS\"\n; \n\nSystem.out.println(lps(str)); \n\n} \n}", "index": 465, "complexity": "3"}
{"back-translation": "public class GFG { static int countPS(String str) { int N = str.length(); int[][] cps = new int[N+1][N+1]; for (int i = 0; i < N; i++) cps[i][i] = 1; for (int L = 2; L <= N; L++) { for (int i = 0; i < N; i++) { int k = L + i - 1; if (k < N) { if (str.charAt(i) == str.charAt(k)) cps[i][k] = cps[i][k-1] + cps[i+1][k] + 1; else cps[i][k] = cps[i][k-1] + cps[i+1][k] - cps[i+1][k-1]; } } } return cps[0][N-1]; } public static void main(String args[]) { String str = \"abcb\"; System.out.println(\"Total palindromic \" + \"subsequence are : \" + countPS(str)); } }", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\nstatic\nint\ncountPS(String str) \n\n{ \n\nint\nN = str.length(); \n\n\n\n\n\n\nint\n[][] cps = \nnew\nint\n[N+\n1\n][N+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ncps[i][i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\nL=\n2\n; L<=N; L++) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\n{ \n\nint\nk = L + i - \n1\n; \n\nif\n(k < N){ \n\nif\n(str.charAt(i) == str.charAt(k)) \n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] + \n1\n; \n\nelse\n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] - \n\ncps[i+\n1\n][k-\n1\n]; \n\n} \n\n} \n\n} \n\n\n\n\nreturn\ncps[\n0\n][N-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"abcb\"\n; \n\nSystem.out.println(\n\"Total palindromic \"\n+ \n\n\"subsequence are : \"\n\n+ countPS(str)); \n\n} \n}", "index": 466, "complexity": "3"}
{"back-translation": "public class LongestPalinSubstring { static void printSubStr(String str, int low, int high) { System.out.println(str.substring(low, high + 1)); } static int longestPalSubstr(String str) { int n = str.length(); boolean table[][] = new boolean[n][n]; int maxLength = 1; for (int i = 0; i < n; ++i) table[i][i] = true; int start = 0; for (int i = 0; i < n - 1; ++i) { if (str.charAt(i) == str.charAt(i + 1)) { table[i][i + 1] = true; start = i; maxLength = 2; } } for (int k = 3; k <= n; ++k) { for (int i = 0; i < n - k + 1; ++i) { int j = i + k - 1; if (table[i + 1][j - 1] && str.charAt(i) == str.charAt(j)) { table[i][j] = true; if (k > maxLength) { start = i; maxLength = k; } } } } System.out.print(\"Longest palindrome substring is; \"); printSubStr(str, start, start + maxLength - 1); return maxLength; } public static void main(String[] args) { String str = \"forgeeksskeegfor\"; System.out.println(\"Length is: \" + longestPalSubstr(str)); } }", "src": "public\nclass\nLongestPalinSubstring \n{ \n\n\n\nstatic\nvoid\nprintSubStr(String str, \nint\nlow, \nint\nhigh) { \n\nSystem.out.println(str.substring(low, high + \n1\n)); \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nlongestPalSubstr(String str) { \n\nint\nn = str.length(); \n\n\n\n\n\n\n\n\n\nboolean\ntable[][] = \nnew\nboolean\n[n][n]; \n\n\n\n\nint\nmaxLength = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\ntable[i][i] = \ntrue\n; \n\n\n\n\nint\nstart = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nif\n(str.charAt(i) == str.charAt(i + \n1\n)) { \n\ntable[i][i + \n1\n] = \ntrue\n; \n\nstart = i; \n\nmaxLength = \n2\n; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nk = \n3\n; k <= n; ++k) { \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n - k + \n1\n; ++i) \n\n{ \n\n\n\n\n\nint\nj = i + k - \n1\n; \n\n\n\n\n\n\n\n\nif\n(table[i + \n1\n][j - \n1\n] && str.charAt(i) == \n\nstr.charAt(j)) { \n\ntable[i][j] = \ntrue\n; \n\n\nif\n(k > maxLength) { \n\nstart = i; \n\nmaxLength = k; \n\n} \n\n} \n\n} \n\n} \n\nSystem.out.print(\n\"Longest palindrome substring is; \"\n); \n\nprintSubStr(str, start, start + maxLength - \n1\n); \n\n\nreturn\nmaxLength; \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nString str = \n\"forgeeksskeegfor\"\n; \n\nSystem.out.println(\n\"Length is: \"\n+ \n\nlongestPalSubstr(str)); \n\n} \n}", "index": 467, "complexity": "3"}
{"back-translation": "public class GFG { static int CountPS(char str[], int n) { int dp[][] = new int[n][n]; boolean P[][] = new boolean[n][n]; for (int i = 0; i < n; i++) P[i][i] = true; for (int i = 0; i < n - 1; i++) { if (str[i] == str[i + 1]) { P[i][i + 1] = true; dp[i][i + 1] = 1; } } for (int gap = 2; gap < n; gap++) { for (int i = 0; i < n - gap; i++) { int j = gap + i; if (str[i] == str[j] && P[i + 1][j - 1]) P[i][j] = true; if (P[i][j] == true) dp[i][j] = dp[i][j - 1] + dp[i + 1][j] + 1 - dp[i + 1][j - 1]; else dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]; } } return dp[0][n - 1]; } public static void main(String[] args) { String str = \"abaab\"; System.out.println(CountPS(str.toCharArray(), str.length())); } }", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\nstatic\nint\nCountPS(\nchar\nstr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\ndp[][] = \nnew\nint\n[n][n]; \n\n\n\n\n\n\nboolean\nP[][] = \nnew\nboolean\n[n][n]; \n\n\n\n\nfor\n(\nint\ni= \n0\n; i< n; i++) \n\nP[i][i] = \ntrue\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\nif\n(str[i] == str[i+\n1\n]) \n\n{ \n\nP[i][i+\n1\n] = \ntrue\n; \n\ndp[i][i+\n1\n] = \n1\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ngap=\n2\n; gap<n; gap++) \n\n{ \n\n\n\nfor\n(\nint\ni=\n0\n; i<n-gap; i++) \n\n{ \n\n\n\nint\nj = gap + i; \n\n\n\n\nif\n(str[i] == str[j] && P[i+\n1\n][j-\n1\n] ) \n\nP[i][j] = \ntrue\n; \n\n\n\n\n\n\n\n\nif\n(P[i][j] == \ntrue\n) \n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] + \n1\n- dp[i+\n1\n][j-\n1\n]; \n\nelse\n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] - dp[i+\n1\n][j-\n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\ndp[\n0\n][n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"abaab\"\n; \n\nSystem.out.println(CountPS(str.toCharArray(), str.length())); \n\n} \n}", "index": 468, "complexity": "3"}
{"back-translation": "class GFG { static void constructDp(int[][] dp, String str) { int l = str.length(); int[][] isPalin = new int[l + 1][l + 1]; for (int i = 0; i <= l; i++) { for (int j = 0; j <= l; j++) { isPalin[i][j] = dp[i][j] = 0; } } for (int i = l - 1; i >= 0; i--) { isPalin[i][i] = 1; dp[i][i] = 1; for (int j = i + 1; j < l; j++) { isPalin[i][j] = (str.charAt(i) == str.charAt(j) && (i + 1 > j - 1 || (isPalin[i + 1][j - 1]) != 0)) ? 1 : 0; dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1] + isPalin[i][j]; } } } static int countOfPalindromeInRange(int[][] dp, int l, int r) { return dp[l][r]; } public static void main(String args[]) { int MAX = 50; String str = \"xyaabax\"; int[][] dp = new int[MAX][MAX]; constructDp(dp, str); int l = 3; int r = 5; System.out.println(countOfPalindromeInRange(dp, l, r)); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nconstructDp(\nint\ndp[][], String str) \n\n{ \n\nint\nl = str.length(); \n\n\n\n\n\n\nint\n[][] isPalin = \nnew\nint\n[l + \n1\n][l + \n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= l; i++) { \n\nfor\n(\nint\nj = \n0\n; j <= l; j++) { \n\nisPalin[i][j] = dp[i][j] = \n0\n; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = l - \n1\n; i >= \n0\n; i--) { \n\n\n\nisPalin[i][i] = \n1\n; \n\ndp[i][i] = \n1\n; \n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < l; j++) { \n\n\n\nisPalin[i][j] = (str.charAt(i) == str.charAt(j) && (i + \n1\n> j - \n1\n|| (isPalin[i + \n1\n][j - \n1\n]) != \n0\n)) ? \n1\n: \n0\n; \n\n\n\n\ndp[i][j] = dp[i][j - \n1\n] + dp[i + \n1\n][j] - dp[i + \n1\n][j - \n1\n] + isPalin[i][j]; \n\n} \n\n} \n\n} \n\n\n\n\nstatic\nint\ncountOfPalindromeInRange(\nint\ndp[][], \nint\nl, \nint\nr) \n\n{ \n\nreturn\ndp[l][r]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nMAX = \n50\n; \n\nString str = \n\"xyaabax\"\n; \n\nint\n[][] dp = \nnew\nint\n[MAX][MAX]; \n\nconstructDp(dp, str); \n\n\nint\nl = \n3\n; \n\nint\nr = \n5\n; \n\nSystem.out.println(countOfPalindromeInRange(dp, l, r)); \n\n} \n}", "index": 469, "complexity": "3"}
{"back-translation": "public class GFG { static int maxAlternateSum(int[] arr, int n) { if (n == 1) return arr[0]; int[] dec = new int[n]; int[] inc = new int[n]; dec[0] = inc[0] = arr[0]; int flag = 0; for (int i=1; i<n; i++) { for (int j=0; j<i; j++) { if (arr[j] > arr[i]) { dec[i] = Math.max(dec[i], inc[j]+arr[i]); flag = 1; } else if (arr[j] < arr[i] && flag == 1) inc[i] = Math.max(inc[i], dec[j]+arr[i]); } } int result = Integer.MIN_VALUE; for (int i = 0; i < n; i++) { if (result < inc[i]) result = inc[i]; if (result < dec[i]) result = dec[i]; } return result; } public static void main(String[] args) { int arr[]= { 8 , 2 , 3 , 5 , 7 , 9 , 10 }; System.out.println( ", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\n\n\nstatic\nint\nmaxAlternateSum(\nint\narr[], \nint\nn) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\narr[\n0\n]; \n\n\n\n\n\n\n\n\n\n\n\nint\ndec[] = \nnew\nint\n[n]; \n\n\n\n\n\nint\ninc[] = \nnew\nint\n[n]; \n\n\n\n\n\n\ndec[\n0\n] = inc[\n0\n] = arr[\n0\n]; \n\n\nint\nflag = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<i; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(arr[j] > arr[i]) \n\n{ \n\ndec[i] = Math.max(dec[i], inc[j]+arr[i]); \n\n\n\n\n\n\nflag = \n1\n; \n\n} \n\n\n\n\n\n\n\n\nelse\nif\n(arr[j] < arr[i] && flag == \n1\n) \n\n\n\n\n\n\ninc[i] = Math.max(inc[i], dec[j]+arr[i]); \n\n} \n\n} \n\n\n\n\nint\nresult = Integer.MIN_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(result < inc[i]) \n\nresult = inc[i]; \n\nif\n(result < dec[i]) \n\nresult = dec[i]; \n\n} \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[]= {\n8\n, \n2\n, \n3\n, \n5\n, \n7\n, \n9\n, \n10\n}; \n\nSystem.out.println(\n\"Maximum sum = \"\n+ \n\nmaxAlternateSum(arr , arr.length)); \n\n} \n}", "index": 470, "complexity": "3"}
{"back-translation": "class GFG {\n\n    static int zzis(int arr[], int n) {\n\n        int las[][] = new int[n][2];\n\n        for (int i = 0; i < n; i++)\n            las[i][0] = las[i][1] = 1;\n\n        int res = 1;\n\n        for (int i = 1; i < n; i++) {\n\n            for (int j = 0; j < i; j++) {\n\n                if (arr[j] < arr[i] && las[i][0] < las[j][1] + 1)\n                    las[i][0] = las[j][1] + 1;\n\n                if (arr[j] > arr[i] && las[i][1] < las[j][0] + 1)\n                    las[i][1] = las[j][0] + 1;\n\n            }\n\n            if (res < Math.max(las[i][0], las[i][1]))\n                res = Math.max(las[i][0], las[i][1]);\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        int arr[] = {10, 22, 9, 33, 49, 50, 31, 60};\n        int n = arr.length;\n\n        System.out.println(\"Length of Longest \" +\n                \"alternating subsequence is \" +\n                zzis(arr, n));\n    }\n}", "src": "class\nGFG { \n\n\n\nstatic\nint\nzzis(\nint\narr[], \nint\nn) \n{ \n\n\n\nint\nlas[][] = \nnew\nint\n[n][\n2\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nlas[i][\n0\n] = las[i][\n1\n] = \n1\n; \n\n\nint\nres = \n1\n; \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] < arr[i] && \n\nlas[i][\n0\n] < las[j][\n1\n] + \n1\n) \n\nlas[i][\n0\n] = las[j][\n1\n] + \n1\n; \n\n\n\n\n\n\nif\n( arr[j] > arr[i] && \n\nlas[i][\n1\n] < las[j][\n0\n] + \n1\n) \n\nlas[i][\n1\n] = las[j][\n0\n] + \n1\n; \n\n} \n\n\n\n\nif\n(res < Math.max(las[i][\n0\n], las[i][\n1\n])) \n\nres = Math.max(las[i][\n0\n], las[i][\n1\n]); \n\n} \n\n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = { \n10\n, \n22\n, \n9\n, \n33\n, \n49\n, \n\n50\n, \n31\n, \n60\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of Longest \"\n+ \n\n\"alternating subsequence is \"\n+ \n\nzzis(arr, n)); \n} \n}", "index": 471, "complexity": "3"}
{"back-translation": "class GFG { static int search(int[] arr, int x, int n) { for (int i = 0; i < n; i++) if (arr[i] == x) return i; return -1; } static void printPostOrder(int[] in1, int[] pre, int n) { int root = search(in1, pre[0], n); if (root != 0) printPostOrder(in1, Arrays.copyOfRange(pre, 1, n), root); if (root != n - 1) printPostOrder(Arrays.copyOfRange(in1, root+1, n), Arrays.copyOfRange(pre, 1+root, n), n - root - 1); System.out.print(pre[0] + \" \"); } public static void main(String args[]) { int in1[] = { 4, 2, 5, 1, 3, 6 }; int pre[] = { 1, 2, 4, 5, 3, 6 }; int n = in1.length; System.out.println(\"Postorder traversal \"); printPostOrder(in1, pre, n); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nsearch(\nint\narr[], \nint\nx, \nint\nn) \n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] == x) \n\nreturn\ni; \n\nreturn\n-\n1\n; \n} \n\n\n\nstatic\nvoid\nprintPostOrder(\nint\nin1[], \n\nint\npre[], \nint\nn) \n{ \n\n\n\n\n\n\n\nint\nroot = search(in1, pre[\n0\n], n); \n\n\n\n\n\n\nif\n(root != \n0\n) \n\nprintPostOrder(in1, Arrays.copyOfRange(pre, \n1\n, n), root); \n\n\n\n\n\n\nif\n(root != n - \n1\n) \n\nprintPostOrder(Arrays.copyOfRange(in1, root+\n1\n, n), \n\nArrays.copyOfRange(pre, \n1\n+root, n), n - root - \n1\n); \n\n\n\n\nSystem.out.print( pre[\n0\n] + \n\" \"\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\nin1[] = { \n4\n, \n2\n, \n5\n, \n1\n, \n3\n, \n6\n}; \n\nint\npre[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n3\n, \n6\n}; \n\nint\nn = in1.length; \n\nSystem.out.println(\n\"Postorder traversal \"\n); \n\nprintPostOrder(in1, pre, n); \n} \n}", "index": 472, "complexity": "3"}
{"back-translation": "public class PostPrinter {\n\n    static int preIndex = 0;\n\n    void printPost(int[] in, int[] pre, int inStrt, int inEnd) {\n        if (inStrt > inEnd)\n            return;\n\n        int inIndex = search(in, inStrt, inEnd, pre[preIndex++]);\n\n        printPost(in, pre, inStrt, inIndex - 1);\n\n        printPost(in, pre, inIndex + 1, inEnd);\n\n        System.out.print(in[inIndex] + \" \");\n    }\n\n    int search(int[] in, int startIn, int endIn, int data) {\n        int i = 0;\n        for (i = startIn; i < endIn; i++) {\n            if (in[i] == data)\n                return i;\n        }\n        return i;\n    }\n\n    public static void main(String ars[]) {\n        int in[] = {4, 2, 5, 1, 3, 6};\n        int pre[] = {1, 2, 4, 5, 3, 6};\n        int len = in.length;\n        PostPrinter tree = new PostPrinter();\n        tree.printPost(in, pre, 0, len - 1);\n    }\n}", "src": "public\nclass\nPrintPost { \n\nstatic\nint\npreIndex = \n0\n; \n\nvoid\nprintPost(\nint\n[] in, \nint\n[] pre, \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\n; \n\n\n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, pre[preIndex++]); \n\n\n\n\nprintPost(in, pre, inStrt, inIndex - \n1\n); \n\n\n\n\nprintPost(in, pre, inIndex + \n1\n, inEnd); \n\n\n\n\nSystem.out.print(in[inIndex] + \n\" \"\n); \n\n} \n\n\nint\nsearch(\nint\n[] in, \nint\nstartIn, \nint\nendIn, \nint\ndata) \n\n{ \n\nint\ni = \n0\n; \n\nfor\n(i = startIn; i < endIn; i++) \n\nif\n(in[i] == data) \n\nreturn\ni; \n\nreturn\ni; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String ars[]) \n\n{ \n\nint\nin[] = { \n4\n, \n2\n, \n5\n, \n1\n, \n3\n, \n6\n}; \n\nint\npre[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n3\n, \n6\n}; \n\nint\nlen = in.length; \n\nPrintPost tree = \nnew\nPrintPost(); \n\ntree.printPost(in, pre, \n0\n, len - \n1\n); \n\n} \n}", "index": 473, "complexity": "3"}
{"back-translation": "class Node {\n    int data;\n    Node left, right;\n\n    public Node(int d) {\n        data = d;\n        left = right = null;\n    }\n}\n\nclass BinaryTree {\n    Node root;\n\n    void printSpiral(Node node) {\n        int h = height(node);\n        int i;\n        boolean ltr = false;\n        for (i = 1; i <= h; i++) {\n            printGivenLevel(node, i, ltr);\n            ltr = !ltr;\n        }\n    }\n\n    int height(Node node) {\n        if (node == null)\n            return 0;\n        else {\n            int lheight = height(node.left);\n            int rheight = height(node.right);\n            if (lheight > rheight)\n                return (lheight + 1);\n            else\n                return (rheight + 1);\n        }\n    }\n\n    void printGivenLevel(Node node, int level, boolean ltr) {\n        if (node == null)\n            return;\n        if (level == 1)\n            System.out.print(node.data + \" \");\n        else if (level > 1) {\n            if (ltr != false) {\n                printGivenLevel(node.left, level - 1, ltr);\n                printGivenLevel(node.right, level - 1, ltr);\n            } else {\n                printGivenLevel(node.right, level - 1, ltr);\n                printGivenLevel(node.left, level - 1, ltr);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node(1);\n        tree.root.left = new Node(2);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(7);\n        tree.root.left.right = new Node(6);\n        tree.root.right.left = new Node(5);\n        tree.root.right.right = new Node(4);\n        System.out.println(\"Spiral order traversal of Binary Tree is \");\n        tree.printSpiral(tree.root);\n    }\n}", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\n\n\n\nboolean\nltr = \nfalse\n; \n\nfor\n(i = \n1\n; i <= h; i++) { \n\nprintGivenLevel(node, i, ltr); \n\n\n\n\nltr = !ltr; \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n{ \n\n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel, \nboolean\nltr) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) { \n\nif\n(ltr != \nfalse\n) { \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\n} \n\nelse\n{ \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\n} \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(tree.root); \n\n} \n}", "index": 474, "complexity": "3"}
{"back-translation": "class Node {\n\n    int data;\n    Node left, right;\n\n    Node(int item) {\n        data = item;\n        left = right;\n    }\n}\n\nclass BinaryTree {\n\n    Node root;\n\n    void reverseLevelOrder(Node node) {\n        int h = height(node);\n        int i;\n        for (i = h; i >= 1; i--) {\n            printGivenLevel(node, i);\n        }\n    }\n\n    void printGivenLevel(Node node, int level) {\n        if (node == null) return;\n        if (level == 1) System.out.print(node.data + \" \");\n        else if (level > 1) {\n            printGivenLevel(node.left, level - 1);\n            printGivenLevel(node.right, level - 1);\n        }\n    }\n\n    int height(Node node) {\n        if (node == null) return 0;\n        else {\n            int lheight = height(node.left);\n            int rheight = height(node.right);\n            if (lheight > rheight) return (lheight + 1);\n            else return (rheight + 1);\n        }\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node(1);\n        tree.root.left = new Node(2);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(4);\n        tree.root.left.right = new Node(5);\n        System.out.println(\"Level Order traversal of binary tree is : \");\n        tree.reverseLevelOrder(tree.root);\n    }\n}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\nfor\n(i = h; i >= \n1\n; i--) \n\n\n\n{ \n\nprintGivenLevel(node, i); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) \n\n{ \n\nprintGivenLevel(node.left, level - \n1\n); \n\nprintGivenLevel(node.right, level - \n1\n); \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n\n{ \n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is : \"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n} \n}", "index": 475, "complexity": "3"}
{"back-translation": "class Node { char data; Node left, right; Node(char item) { data = item; left = right = null; } } class BinaryTree { Node root; static int preIndex = 0; Node buildTree(char in[], char pre[], int inStrt, int inEnd) { if (inStrt > inEnd) return null; Node tNode = new Node(pre[preIndex++]); if (inStrt == inEnd) return tNode; int inIndex = search(in, inStrt, inEnd, tNode.data); tNode.left = buildTree(in, pre, inStrt, inIndex - 1); tNode.right = buildTree(in, pre, inIndex + 1, inEnd); return tNode; } int search(char arr[], int strt, int end, char value) { int i; for (i = strt; i <= end; i++) { if (arr[i] == value) return i; } return i; } void printInorder(Node node) { if (node == null) return; printInorder(node.left); System.out.print(node.data + \" \"); printInorder(node.right); } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); char in[] = new char[] { 'D', 'B', 'E', 'A', 'F', 'C'}; char pre[] = new char[] { 'A', 'B', 'D', 'E', 'C', 'F'}; int len = in.length; Node root = tree.buildTree(in, pre, 0, len - 1); System.out.println(\"Inorder traversal of constructed tree is : \"); tree.printInorder(root); } }", "src": "class\nNode { \n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\nstatic\nint\npreIndex = \n0\n; \n\n\n\n\nNode buildTree(\nchar\nin[], \nchar\npre[], \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode tNode = \nnew\nNode(pre[preIndex++]); \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n\n\ntNode.left = buildTree(in, pre, inStrt, inIndex - \n1\n); \n\ntNode.right = buildTree(in, pre, inIndex + \n1\n, inEnd); \n\n\nreturn\ntNode; \n\n} \n\n\n\n\n\n\n\nint\nsearch(\nchar\narr[], \nint\nstrt, \nint\nend, \nchar\nvalue) \n\n{ \n\nint\ni; \n\nfor\n(i = strt; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\ni; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nchar\nin[] = \nnew\nchar\n[] { \n'D'\n, \n'B'\n, \n'E'\n, \n'A'\n, \n'F'\n, \n'C'\n}; \n\nchar\npre[] = \nnew\nchar\n[] { \n'A'\n, \n'B'\n, \n'D'\n, \n'E'\n, \n'C'\n, \n'F'\n}; \n\nint\nlen = in.length; \n\nNode root = tree.buildTree(in, pre, \n0\n, len - \n1\n); \n\n\n\n\nSystem.out.println(\n\"Inorder traversal of constructed tree is : \"\n); \n\ntree.printInorder(root); \n\n} \n}", "index": 476, "complexity": "3"}
{"back-translation": "class GFG { public static void ancestorMatrix(Node root , int matrix[][], int size) { if (root== null) return; ancestorMatrix(root.left, matrix, size); ancestorMatrix(root.right, matrix, size); if (root.left != null) { matrix[root.data][root.left.data] = 1; for (int i = 0; i < size; i++) { if (matrix[root.left.data][i] == 1) matrix[root.data][i] = 1; } } if (root.right != null) { matrix[root.data][root.right.data] = 1; for (int i = 0; i < size; i++) { if (matrix[root.right.data][i]== 1) matrix[root.data][i] = 1; } } } public static void main(String[] args) { Node tree_root = new Node(5); tree_root.left = new Node (1); tree_root.right = new Node(2); tree_root.left.left = new Node(0); tree_root.left.right = new Node(4); tree_root.right.left = new Node(3); int size = 6; int matrix [][] = new int[size][size]; ancestorMatrix(tree_root, matrix, size); for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { System.out.print(matrix[i][j]+ ", "src": "class\nGFG \n{ \n\n\n\npublic\nstatic\nvoid\nancestorMatrix(Node root , \n\nint\nmatrix[][],\nint\nsize) \n\n{ \n\n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nancestorMatrix(root.left, matrix, size); \n\n\n\n\nancestorMatrix(root.right, matrix, size); \n\n\n\n\n\n\n\nif\n(root.left != \nnull\n) \n\n{ \n\n\n\nmatrix[root.data][root.left.data] = \n1\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\n\n\n\n\n\n\nif\n(matrix[root.left.data][i] == \n1\n) \n\nmatrix[root.data][i] = \n1\n; \n\n} \n\n} \n\n\n\n\nif\n(root.right != \nnull\n) \n\n{ \n\nmatrix[root.data][root.right.data] = \n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nif\n(matrix[root.right.data][i]==\n1\n) \n\nmatrix[root.data][i] = \n1\n; \n\n} \n\n} \n\n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\nNode tree_root = \nnew\nNode(\n5\n); \n\ntree_root.left = \nnew\nNode (\n1\n); \n\ntree_root.right = \nnew\nNode(\n2\n); \n\ntree_root.left.left = \nnew\nNode(\n0\n); \n\ntree_root.left.right = \nnew\nNode(\n4\n); \n\ntree_root.right.left = \nnew\nNode(\n3\n); \n\n\n\n\nint\nsize = \n6\n; \n\nint\nmatrix [][] = \nnew\nint\n[size][size]; \n\n\nancestorMatrix(tree_root, matrix, size); \n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < size; j++) \n\n{ \n\nSystem.out.print(matrix[i][j]+\n\" \"\n); \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\nstatic\nclass\nNode \n\n{ \n\npublic\nint\ndata ; \n\npublic\nNode left ,right; \n\npublic\nNode (\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.left = \nthis\n.right = \nnull\n; \n\n} \n\n} \n}", "index": 477, "complexity": "3"}
{"back-translation": "class Node { int data; Node left, right; Node(int item) { data = item; left = right = null; } } class BinaryTree { Node root; Node buildTree(int inorder[], int start, int end, Node node) { if (start > end) return null; int i = max(inorder, start, end); node = new Node(inorder[i]); if (start == end) return node; node.left = buildTree(inorder, start, i - 1, node.left); node.right = buildTree(inorder, i + 1, end, node.right); return node; } int max(int arr[], int strt, int end) { int i, max = arr[strt], maxind = strt; for (i = strt + 1; i <= end; i++) { if (arr[i] > max) { max = arr[i]; maxind = i; } } return maxind; } void printInorder(Node node) { if (node == null) return; printInorder(node.left); System.out.print(node.data + ", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nNode buildTree(\nint\ninorder[], \nint\nstart, \nint\nend, Node node) \n\n{ \n\nif\n(start > end) \n\nreturn\nnull\n; \n\n\n\n\nint\ni = max(inorder, start, end); \n\n\n\n\nnode = \nnew\nNode(inorder[i]); \n\n\n\n\nif\n(start == end) \n\nreturn\nnode; \n\n\n\n\nnode.left = buildTree(inorder, start, i - \n1\n, node.left); \n\nnode.right = buildTree(inorder, i + \n1\n, end, node.right); \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\n\nint\nmax(\nint\narr[], \nint\nstrt, \nint\nend) \n\n{ \n\nint\ni, max = arr[strt], maxind = strt; \n\nfor\n(i = strt + \n1\n; i <= end; i++) \n\n{ \n\nif\n(arr[i] > max) \n\n{ \n\nmax = arr[i]; \n\nmaxind = i; \n\n} \n\n} \n\nreturn\nmaxind; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\nint\ninorder[] = \nnew\nint\n[]{\n5\n, \n10\n, \n40\n, \n30\n, \n28\n}; \n\nint\nlen = inorder.length; \n\nNode mynode = tree.buildTree(inorder, \n0\n, len - \n1\n, tree.root); \n\n\n\n\nSystem.out.println(\n\"Inorder traversal of the constructed tree is \"\n); \n\ntree.printInorder(mynode); \n\n} \n}", "index": 478, "complexity": "3"}
{"back-translation": "class Node { int data; Node left, right; public Node(int data) { this.data = data; left = right = null; } } class Index { int index; } class BinaryTree { Node buildUtil(int[] in, int[] post, int inStrt, int inEnd, Index pIndex) { if (inStrt > inEnd) return null; Node node = new Node(post[pIndex.index]); (pIndex.index)--; if (inStrt == inEnd) return node; int iIndex = search(in, inStrt, inEnd, node.data); node.right = buildUtil(in, post, iIndex + 1, inEnd, pIndex); node.left = buildUtil(in, post, inStrt, iIndex - 1, pIndex); return node; } Node buildTree(int[] in, int[] post, int n) { Index pIndex = new Index(); pIndex.index = n - 1; return buildUtil(in, post, 0, n - 1, pIndex); } int search(int[] arr, int strt, int end, int value) { int i; for (i = strt; i <= end; i++) { if (arr[i] == value) break; } return i; } void preOrder(Node node) { if (node == null) return; System.out.print(node.data + \" \"); preOrder(node.left); preOrder(node.right); } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); int in[] = new int[] { 4, 8, 2, 5, 1, 6, 3, 7 }; int post[] = new int[] { 8, 4, 5, 2, 6, 7, 3, 1 }; int n = in.length; Node root = tree.buildTree(in, post, n); System.out.println(\"Preorder of the constructed tree : \"); tree.preOrder(root); } }", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\n\nclass\nIndex { \n\nint\nindex; \n} \n\nclass\nBinaryTree { \n\n\n\nNode buildUtil(\nint\nin[], \nint\npost[], \nint\ninStrt, \n\nint\ninEnd, Index pIndex) \n\n{ \n\n\n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode node = \nnew\nNode(post[pIndex.index]); \n\n(pIndex.index)--; \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\nnode; \n\n\n\n\nint\niIndex = search(in, inStrt, inEnd, node.data); \n\n\n\n\nnode.right = buildUtil(in, post, iIndex + \n1\n, inEnd, pIndex); \n\nnode.left = buildUtil(in, post, inStrt, iIndex - \n1\n, pIndex); \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\nNode buildTree(\nint\nin[], \nint\npost[], \nint\nn) \n\n{ \n\nIndex pIndex = \nnew\nIndex(); \n\npIndex.index = n - \n1\n; \n\nreturn\nbuildUtil(in, post, \n0\n, n - \n1\n, pIndex); \n\n} \n\n\n\n\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n\n{ \n\nint\ni; \n\nfor\n(i = strt; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nbreak\n; \n\n} \n\nreturn\ni; \n\n} \n\n\n\n\nvoid\npreOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\nin[] = \nnew\nint\n[] { \n4\n, \n8\n, \n2\n, \n5\n, \n1\n, \n6\n, \n3\n, \n7\n}; \n\nint\npost[] = \nnew\nint\n[] { \n8\n, \n4\n, \n5\n, \n2\n, \n6\n, \n7\n, \n3\n, \n1\n}; \n\nint\nn = in.length; \n\nNode root = tree.buildTree(in, post, n); \n\nSystem.out.println(\n\"Preorder of the constructed tree : \"\n); \n\ntree.preOrder(root); \n\n} \n}", "index": 479, "complexity": "3"}
{"back-translation": "class Node { int data; Node left, right; Node(int item) { data = item; left = right = null; } } class BinaryTree { Node root; void convertTree(Node node) { int left_data = 0, right_data = 0, diff; if (node == null || (node.left == null && node.right == null)) return; else { convertTree(node.left); convertTree(node.right); if (node.left != null) left_data = node.left.data; if (node.right != null) right_data = node.right.data; diff = left_data + right_data - node.data; if (diff > 0) node.data = node.data + diff; if (diff < 0) increment(node, -diff); } } void increment(Node node, int diff) { if (node.left != null) { node.left.data = node.left.data + diff; increment(node.left, diff); } else if (node.right != null) { node.right.data = node.right.data + diff; increment(node.right, diff); } } void printInorder(Node node) { if (node == null) return; printInorder(node.left); System.out.print(node.data + \" \"); printInorder(node.right); } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); tree.root = new Node(50); tree.root.left = new Node(7); tree.root.right = new Node(2); tree.root.left.left = new Node(3); tree.root.left.right = new Node(5); tree.root.right.left = new Node(1); tree.root.right.right = new Node(30); System.out.println(\"Inorder traversal before conversion is :\"); tree.printInorder(tree.root); tree.convertTree(tree.root); System.out.println(\"\"); System.out.println(\"Inorder traversal after conversion is :\"); tree.printInorder(tree.root); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nconvertTree(Node node) \n\n{ \n\nint\nleft_data = \n0\n, right_data = \n0\n, diff; \n\n\n\n\nif\n(node == \nnull\n\n|| (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n; \n\nelse\n\n{ \n\n\n\nconvertTree(node.left); \n\nconvertTree(node.right); \n\n\n\n\nif\n(node.left != \nnull\n) \n\nleft_data = node.left.data; \n\n\n\n\nif\n(node.right != \nnull\n) \n\nright_data = node.right.data; \n\n\n\n\ndiff = left_data + right_data - node.data; \n\n\n\n\nif\n(diff > \n0\n) \n\nnode.data = node.data + diff; \n\n\n\n\nif\n(diff < \n0\n) \n\n\n\n\nincrement(node, -diff); \n\n} \n\n} \n\n\n\n\nvoid\nincrement(Node node, \nint\ndiff) \n\n{ \n\n\n\nif\n(node.left != \nnull\n) \n\n{ \n\nnode.left.data = node.left.data + diff; \n\n\n\n\nincrement(node.left, diff); \n\n} \n\nelse\nif\n(node.right != \nnull\n) \n\n\n{ \n\nnode.right.data = node.right.data + diff; \n\n\n\n\nincrement(node.right, diff); \n\n} \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n50\n); \n\ntree.root.left = \nnew\nNode(\n7\n); \n\ntree.root.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n1\n); \n\ntree.root.right.right = \nnew\nNode(\n30\n); \n\n\nSystem.out.println(\n\"Inorder traversal before conversion is :\"\n); \n\ntree.printInorder(tree.root); \n\n\ntree.convertTree(tree.root); \n\nSystem.out.println(\n\"\"\n); \n\n\nSystem.out.println(\n\"Inorder traversal after conversion is :\"\n); \n\ntree.printInorder(tree.root); \n\n\n} \n}", "index": 480, "complexity": "3"}
{"back-translation": "class Node {\n\n    int data;\n    Node left, right, nextRight;\n\n    Node(int item) {\n        data = item;\n        left = right = nextRight = null;\n    }\n}\n\nclass BinaryTree {\n\n    Node root;\n\n    int sum(Node node) {\n        if (node == null)\n            return 0;\n        return sum(node.left) + node.data + sum(node.right);\n    }\n\n    int isSumTree(Node node) {\n        int ls, rs;\n        if ((node == null) || (node.left == null && node.right == null))\n            return 1;\n        ls = sum(node.left);\n        rs = sum(node.right);\n        if ((node.data == ls + rs) && (isSumTree(node.left) != 0) && (isSumTree(node.right) != 0))\n            return 1;\n        return 0;\n    }\n\n    public static void main(String args[]) {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new Node(26);\n        tree.root.left = new Node(10);\n        tree.root.right = new Node(3);\n        tree.root.left.left = new Node(4);\n        tree.root.left.right = new Node(6);\n        tree.root.right.right = new Node(3);\n        if (tree.isSumTree(tree.root) != 0)\n            System.out.println(\"The given tree is a sum tree\");\n        else\n            System.out.println(\"The given tree is not a sum tree\");\n    }\n}", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right, nextRight; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = nextRight = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nint\nsum(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nreturn\nsum(node.left) + node.data + sum(node.right); \n\n} \n\n\n\n\nint\nisSumTree(Node node) \n\n{ \n\nint\nls, rs; \n\n\n\n\nif\n((node == \nnull\n) || (node.left == \nnull\n&& node.right == \nnull\n)) \n\nreturn\n1\n; \n\n\n\n\nls = sum(node.left); \n\nrs = sum(node.right); \n\n\n\n\nif\n((node.data == ls + rs) && (isSumTree(node.left) != \n0\n) \n\n&& (isSumTree(node.right)) != \n0\n) \n\nreturn\n1\n; \n\n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n26\n); \n\ntree.root.left = \nnew\nNode(\n10\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n3\n); \n\n\nif\n(tree.isSumTree(tree.root) != \n0\n) \n\nSystem.out.println(\n\"The given tree is a sum tree\"\n); \n\nelse\n\nSystem.out.println(\n\"The given tree is not a sum tree\"\n); \n\n} \n}", "index": 481, "complexity": "3"}
{"back-translation": "class Node { int key; Node left, right; public Node(int key) { this.key = key; left = right = null; } } class BinaryTree { Node root; int count(Node node) { if (node == null) return 0; return count(node.left) + count(node.right) + 1; } boolean checkRec(Node node, int n) { if (node == null) return false; if (count(node) == n - count(node)) return true; return checkRec(node.left, n) || checkRec(node.right, n); } boolean check(Node node) { int n = count(node); return checkRec(node, n); } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(5); tree.root.left = new Node(1); tree.root.right = new Node(6); tree.root.left.left = new Node(3); tree.root.right.left = new Node(7); tree.root.right.right = new Node(4); if (tree.check(tree.root) == true) System.out.println(\"YES\"); else System.out.println(\"NO\"); } }", "src": "class\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n\n\npublic\nNode(\nint\nkey) \n\n{ \n\nthis\n.key = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nint\ncount(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\n\nreturn\ncount(node.left) + count(node.right) + \n1\n; \n\n} \n\n\n\n\n\n\n\n\nboolean\ncheckRec(Node node, \nint\nn) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\nif\n(count(node) == n - count(node)) \n\nreturn\ntrue\n; \n\n\n\n\nreturn\ncheckRec(node.left, n) \n\n|| checkRec(node.right, n); \n\n} \n\n\n\n\nboolean\ncheck(Node node) \n\n{ \n\n\n\nint\nn = count(node); \n\n\n\n\nreturn\ncheckRec(node, n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n1\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.left = \nnew\nNode(\n3\n); \n\ntree.root.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nif\n(tree.check(tree.root)==\ntrue\n) \n\nSystem.out.println(\n\"YES\"\n); \n\nelse\n\nSystem.out.println(\n\"NO\"\n); \n\n} \n}", "index": 482, "complexity": "3"}
{"back-translation": "class GfG {\n\nstatic int preIndex = 0;\n\n\nstatic class Node {\n\nint data;\n\nNode left, right;\n}\n\n\nstatic Node newNode(int data) {\n\nNode temp = new Node();\n\ntemp.data = data;\n\ntemp.left = null;\n\ntemp.right = null;\n\nreturn temp;\n}\n\n\nstatic int search(int arr[], int strt, int end, int value) {\n\nfor(int i = strt; i <= end; i++) {\n\nif(arr[i] == value)\n\nreturn i;\n\n}\n\nreturn -1;\n}\n\n\nstatic Node buildTree(int in[], int pre[], int inStrt, int inEnd) {\n\nif (inStrt > inEnd)\n\nreturn null;\n\n\n\nNode tNode = newNode(pre[preIndex++]);\n\n\n\nif (inStrt == inEnd)\n\nreturn tNode;\n\n\n\nint inIndex = search(in, inStrt, inEnd, tNode.data);\n\n\ntNode.left = buildTree(in, pre, inStrt, inIndex-1);\n\ntNode.right = buildTree(in, pre, inIndex+1, inEnd);\n\n\nreturn tNode;\n}\n\n\nstatic int checkPostorder(Node node, int postOrder[], int index) {\n\nif (node == null)\n\nreturn index;\n\n\n\nindex = checkPostorder(node.left, postOrder, index);\n\nindex = checkPostorder(node.right, postOrder, index);\n\nif (node.data == postOrder[index])\n\nindex++;\n\nelse\n\nreturn -1;\n\n\nreturn index;\n}\n\n\npublic static void main(String[] args) {\n\nint inOrder[] = {4, 2, 5, 1, 3};\n\nint preOrder[] = {1, 2, 4, 5, 3};\n\nint postOrder[] = {4, 5, 2, 3, 1};\n\nint len = inOrder.length;\n\nNode root = buildTree(inOrder, preOrder, 0, len - 1);\n\nint index = checkPostorder(root, postOrder, 0);\n\nif (index == len)\n\nSystem.out.println(\"Yes\");\n\nelse\n\nSystem.out.println(\"No\");\n\n}\n}", "src": "class\nGfG { \n\nstatic\nint\npreIndex = \n0\n; \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n{ \n\nfor\n(\nint\ni = strt; i <= end; i++) \n\n{ \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\n-\n1\n; \n} \n\n\nstatic\nNode buildTree(\nint\nin[], \nint\npre[], \nint\ninStrt, \nint\ninEnd) \n{ \n\n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode tNode = newNode(pre[preIndex++]); \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n\n\ntNode.left = buildTree(in, pre, inStrt, inIndex-\n1\n); \n\ntNode.right = buildTree(in, pre, inIndex+\n1\n, inEnd); \n\n\nreturn\ntNode; \n} \n\n\nstatic\nint\ncheckPostorder(Node node, \nint\npostOrder[], \nint\nindex) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\nindex; \n\n\n\n\nindex = checkPostorder(node.left,postOrder,index); \n\n\n\n\nindex = checkPostorder(node.right,postOrder,index); \n\n\n\n\nif\n(node.data == postOrder[index]) \n\nindex++; \n\nelse\n\nreturn\n-\n1\n; \n\n\nreturn\nindex; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\ninOrder[] = {\n4\n, \n2\n, \n5\n, \n1\n, \n3\n}; \n\nint\npreOrder[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n3\n}; \n\nint\npostOrder[] = {\n4\n, \n5\n, \n2\n, \n3\n, \n1\n}; \n\n\nint\nlen = inOrder.length; \n\n\n\n\n\n\nNode root = buildTree(inOrder, preOrder, \n0\n, len - \n1\n); \n\n\n\n\n\n\nint\nindex = checkPostorder(root,postOrder,\n0\n); \n\n\n\n\nif\n(index == len) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 483, "complexity": "3"}
{"back-translation": "class MST {\n\nprivate static final int V = 5;\n\nint minKey(int key[], Boolean mstSet[]) {\nint min = Integer.MAX_VALUE, min_index = -1;\nfor (int v = 0; v < V; v++)\nif (mstSet[v] == false && key[v] < min) {\nmin = key[v];\nmin_index = v;\n}\nreturn min_index;\n}\n\nvoid printMST(int parent[], int graph[][]) {\nSystem.out.println(\"Edge \\tWeight\");\nfor (int i = 1; i < V; i++)\nSystem.out.println(parent[i] + \" - \" + i + \"\\t\" + graph[i][parent[i]]);\n}\n\nvoid primMST(int graph[][]) {\nint parent[] = new int[V];\nint key[] = new int[V];\nBoolean mstSet[] = new Boolean[V];\nfor (int i = 0; i < V; i++) {\nkey[i] = Integer.MAX_VALUE;\nmstSet[i] = false;\n}\nkey[0] = 0;\nparent[0] = -1;\nfor (int count = 0; count < V - 1; count++) {\nint u = minKey(key, mstSet);\nmstSet[u] = true;\nfor (int v = 0; v < V; v++)\nif (graph[u][v] != 0 && mstSet[v] == false && graph[u][v] < key[v]) {\nparent[v] = u;\nkey[v] = graph[u][v];\n}\n}\nprintMST(parent, graph);\n}\n\npublic static void main(String[] args) {\nMST t = new MST();\nint graph[][] = new int[][] {{0, 2, 0, 6, 0}, {2, 0, 3, 8, 5}, {0, 3, 0, 0, 7}, {6, 8, 0, 0, 9}, {0, 5, 7, 9, 0}};\nt.primMST(graph);\n}\n}", "src": "class\nMST { \n\n\n\nprivate\nstatic\nfinal\nint\nV = \n5\n; \n\n\n\n\n\n\nint\nminKey(\nint\nkey[], Boolean mstSet[]) \n\n{ \n\n\n\nint\nmin = Integer.MAX_VALUE, min_index = -\n1\n; \n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\nif\n(mstSet[v] == \nfalse\n&& key[v] < min) { \n\nmin = key[v]; \n\nmin_index = v; \n\n} \n\n\nreturn\nmin_index; \n\n} \n\n\n\n\n\n\nvoid\nprintMST(\nint\nparent[], \nint\ngraph[][]) \n\n{ \n\nSystem.out.println(\n\"Edge \\tWeight\"\n); \n\nfor\n(\nint\ni = \n1\n; i < V; i++) \n\nSystem.out.println(parent[i] + \n\" - \"\n+ i + \n\"\\t\"\n+ graph[i][parent[i]]); \n\n} \n\n\n\n\n\n\nvoid\nprimMST(\nint\ngraph[][]) \n\n{ \n\n\n\nint\nparent[] = \nnew\nint\n[V]; \n\n\n\n\nint\nkey[] = \nnew\nint\n[V]; \n\n\n\n\nBoolean mstSet[] = \nnew\nBoolean[V]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < V; i++) { \n\nkey[i] = Integer.MAX_VALUE; \n\nmstSet[i] = \nfalse\n; \n\n} \n\n\n\n\nkey[\n0\n] = \n0\n; \n\n\n\n\nparent[\n0\n] = -\n1\n; \n\n\n\n\n\nfor\n(\nint\ncount = \n0\n; count < V - \n1\n; count++) { \n\n\n\n\n\nint\nu = minKey(key, mstSet); \n\n\n\n\nmstSet[u] = \ntrue\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\n\n\n\n\n\n\n\nif\n(graph[u][v] != \n0\n&& mstSet[v] == \nfalse\n&& graph[u][v] < key[v]) { \n\nparent[v] = u; \n\nkey[v] = graph[u][v]; \n\n} \n\n} \n\n\n\n\nprintMST(parent, graph); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nMST t = \nnew\nMST(); \n\nint\ngraph[][] = \nnew\nint\n[][] { { \n0\n, \n2\n, \n0\n, \n6\n, \n0\n}, \n\n{ \n2\n, \n0\n, \n3\n, \n8\n, \n5\n}, \n\n{ \n0\n, \n3\n, \n0\n, \n0\n, \n7\n}, \n\n{ \n6\n, \n8\n, \n0\n, \n0\n, \n9\n}, \n\n{ \n0\n, \n5\n, \n7\n, \n9\n, \n0\n} }; \n\n\n\n\nt.primMST(graph); \n\n} \n}", "index": 484, "complexity": "3"}
{"back-translation": "static final int V=9; int minDistance(int dist[], Boolean sptSet[]) { int min = Integer.MAX_VALUE, min_index=-1; for (int v = 0; v < V; v++) if (sptSet[v] == false && dist[v] <= min) { min = dist[v]; min_index = v; } return min_index; } void printSolution(int dist[], int n) { System.out.println(\"Vertex Distance \"); for (int i = 0; i < V; i++) System.out.println(i+\" tt \"+dist[i]); } void dijkstra(int graph[][], int src) { int dist[] = new int[V]; Boolean sptSet[] = new Boolean[V]; for (int i = 0; i < V; i++) { dist[i] = Integer.MAX_VALUE; sptSet[i] = false; } dist[src] = 0; for (int count = 0; count < V-1; count++) { int u = minDistance(dist, sptSet); sptSet[u] = true; for (int v = 0; v < V; v++) if (!sptSet[v] && graph[u][v]!=0&& dist[u] != Integer.MAX_VALUE && dist[u]+graph[u][v] < dist[v]) dist[v] = dist[u] + graph[u][v]; } printSolution(dist, V); } public static void main (String[] args) { int graph[][] = new int[][]{{0, 4, 0, 0, 0, 0, 0, 8, 0}, {4, 0, 8, 0, 0, 0, 0, 11, 0}, {0, 8, 0, 7, 0, 4, 0, 0, 2}, {0, 0, 7, 0, 9, 14, 0, 0, 0}, {0, 0, 0, 9, 0, 10, 0, 0, 0}, {0, 0, 4, 14, 10, 0, 2, 0, 0}, {0, 0, 0, 0, 0, 2, 0, 1, 6}, {8, 11, 0, 0, 0, 0, 1, 0, 7}, {0, 0, 2, 0, 0, 0, 6, 7, 0} }; ShortestPath t = new ShortestPath(); t.dijkstra(graph, 0); }", "src": "class\nShortestPath \n{ \n\n\n\n\n\nstatic\nfinal\nint\nV=\n9\n; \n\nint\nminDistance(\nint\ndist[], Boolean sptSet[]) \n\n{ \n\n\n\nint\nmin = Integer.MAX_VALUE, min_index=-\n1\n; \n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\nif\n(sptSet[v] == \nfalse\n&& dist[v] <= min) \n\n{ \n\nmin = dist[v]; \n\nmin_index = v; \n\n} \n\n\nreturn\nmin_index; \n\n} \n\n\n\n\nvoid\nprintSolution(\nint\ndist[], \nint\nn) \n\n{ \n\nSystem.out.println(\n\"Vertex Distance \"\n); \n\nfor\n(\nint\ni = \n0\n; i < V; i++) \n\nSystem.out.println(i+\n\" tt \"\n+dist[i]); \n\n} \n\n\n\n\n\n\n\n\nvoid\ndijkstra(\nint\ngraph[][], \nint\nsrc) \n\n{ \n\nint\ndist[] = \nnew\nint\n[V]; \n\n\n\n\n\n\n\n\n\nBoolean sptSet[] = \nnew\nBoolean[V]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < V; i++) \n\n{ \n\ndist[i] = Integer.MAX_VALUE; \n\nsptSet[i] = \nfalse\n; \n\n} \n\n\n\n\ndist[src] = \n0\n; \n\n\n\n\nfor\n(\nint\ncount = \n0\n; count < V-\n1\n; count++) \n\n{ \n\n\n\n\n\n\n\nint\nu = minDistance(dist, sptSet); \n\n\n\n\nsptSet[u] = \ntrue\n; \n\n\n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\n\n\n\n\n\n\n\nif\n(!sptSet[v] && graph[u][v]!=\n0\n&& \n\ndist[u] != Integer.MAX_VALUE && \n\ndist[u]+graph[u][v] < dist[v]) \n\ndist[v] = dist[u] + graph[u][v]; \n\n} \n\n\n\n\nprintSolution(dist, V); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\nint\ngraph[][] = \nnew\nint\n[][]{{\n0\n, \n4\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n8\n, \n0\n}, \n\n{\n4\n, \n0\n, \n8\n, \n0\n, \n0\n, \n0\n, \n0\n, \n11\n, \n0\n}, \n\n{\n0\n, \n8\n, \n0\n, \n7\n, \n0\n, \n4\n, \n0\n, \n0\n, \n2\n}, \n\n{\n0\n, \n0\n, \n7\n, \n0\n, \n9\n, \n14\n, \n0\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n0\n, \n9\n, \n0\n, \n10\n, \n0\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n4\n, \n14\n, \n10\n, \n0\n, \n2\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n2\n, \n0\n, \n1\n, \n6\n}, \n\n{\n8\n, \n11\n, \n0\n, \n0\n, \n0\n, \n0\n, \n1\n, \n0\n, \n7\n}, \n\n{\n0\n, \n0\n, \n2\n, \n0\n, \n0\n, \n0\n, \n6\n, \n7\n, \n0\n} \n\n}; \n\nShortestPath t = \nnew\nShortestPath(); \n\nt.dijkstra(graph, \n0\n); \n\n} \n}", "index": 485, "complexity": "3"}
{"back-translation": "class GFG { static int maximumSum(int[] arr, int n, int k) { for(int i = 1; i <= k; i++) { int min = Integer.MAX_VALUE; int index = -1; for(int j = 0; j < n; j++) { if(arr[j] < min) { min = arr[j]; index = j; } } if(min == 0) break; arr[index] = -arr[index]; } int sum = 0; for(int i = 0; i < n; i++) sum += arr[i]; return sum; } public static void main(String arg[]) { int[] arr = {-2, 0, 5, -1, 2}; int k = 4; int n = arr.length; System.out.print(maximumSum(arr, n, k)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nmaximumSum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nfor\n(\nint\ni = \n1\n; i <= k; i++) \n\n{ \n\nint\nmin = +\n2147483647\n; \n\nint\nindex = -\n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj=\n0\n; j<n; j++) \n\n{ \n\nif\n(arr[j] < min) \n\n{ \n\nmin = arr[j]; \n\nindex = j; \n\n} \n\n} \n\n\n\n\n\n\n\n\nif\n(min == \n0\n) \n\nbreak\n; \n\n\n\n\narr[index] = -arr[index]; \n\n} \n\n\n\n\nint\nsum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nsum += arr[i]; \n\nreturn\nsum; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = {-\n2\n, \n0\n, \n5\n, -\n1\n, \n2\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.print(maximumSum(arr, n, k)); \n\n} \n}", "index": 486, "complexity": "3"}
{"back-translation": "class GFG { static void minimizeWithKSwaps(int arr[], int n, int k) { for (int i = 0; i < n-1 && k > 0; ++i) { int pos = i; for (int j = i+1; j < n ; ++j) { if (j - i > k) break; if (arr[j] < arr[pos]) pos = j; } int temp; for (int j = pos; j>i; --j) { temp=arr[j]; arr[j]=arr[j-1]; arr[j-1]=temp; } k -= pos-i; } } public static void main(String[] args) { int arr[] = {7, 6, 9, 2, 1}; int n = arr.length; int k = 3; minimizeWithKSwaps(arr, n, k); for (int i=0; i<n; ++i) System.out.print(arr[i] + ", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\nminimizeWithKSwaps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n-\n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n\n\n\n\nint\npos = i; \n\nfor\n(\nint\nj = i+\n1\n; j < n ; ++j) \n\n{ \n\n\n\n\n\n\nif\n(j - i > k) \n\nbreak\n; \n\n\n\n\n\n\nif\n(arr[j] < arr[pos]) \n\npos = j; \n\n} \n\n\n\n\n\n\nint\ntemp; \n\n\nfor\n(\nint\nj = pos; j>i; --j) \n\n{ \n\ntemp=arr[j]; \n\narr[j]=arr[j-\n1\n]; \n\narr[j-\n1\n]=temp; \n\n} \n\n\n\n\n\n\nk -= pos-i; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\narr[] = {\n7\n, \n6\n, \n9\n, \n2\n, \n1\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nminimizeWithKSwaps(arr, n, k); \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; ++i) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n\n} \n}", "index": 487, "complexity": "3"}
{"back-translation": "class GFG { static void SwapInts(int array[], int position1, int position2) { int temp = array[position1]; array[position1] = array[position2]; array[position2] = temp; } static void KSwapMaximum(int[] arr, int n, int k) { for (int i = 0; i < n - 1 && k > 0; ++i) { int indexPosition = i; for (int j = i + 1; j < n; ++j) { if (k <= j - i) break; if (arr[j] > arr[indexPosition]) indexPosition = j; } for (int j = indexPosition; j > i; --j) SwapInts(arr, j, j - 1); k -= indexPosition - i; } } public static void main(String args[]) { int[] arr = { 3, 5, 4, 1, 2 }; int n = arr.length; int k = 3; KSwapMaximum(arr, n, k); for (int i = 0; i < n; ++i) System.out.print(arr[i] + ", "src": "class\nGFG \n{ \n\nstatic\nvoid\nSwapInts(\nint\narray[], \n\nint\nposition1, \n\nint\nposition2) \n\n{ \n\n\n\n\n\n\n\n\n\n\nint\ntemp = array[position1]; \n\n\n\n\n\n\narray[position1] = array[position2]; \n\n\n\n\n\n\narray[position2] = temp; \n\n} \n\n\n\n\n\n\nstatic\nvoid\nKSwapMaximum(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; \n\ni < n - \n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n\n\n\n\n\n\n\n\nint\nindexPosition = i; \n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\n\n\n\n\n\n\n\nif\n(k <= j - i) \n\nbreak\n; \n\n\n\n\n\n\n\n\n\n\nif\n(arr[j] > arr[indexPosition]) \n\nindexPosition = j; \n\n} \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = indexPosition; j > i; --j) \n\nSwapInts(arr, j, j - \n1\n); \n\n\n\n\n\n\nk -= indexPosition - i; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = { \n3\n, \n5\n, \n4\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nKSwapMaximum(arr, n, k); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 488, "complexity": "3"}
{"back-translation": "class Graph { private int V; private LinkedList<Integer> adj[]; Graph(int v) { V = v; adj = new LinkedList[v]; for (int i = 0; i < v; ++i) adj[i] = new LinkedList(); } void addEdge(int v, int w) { adj[v].add(w); adj[w].add(v); } void greedyColoring() { int result[] = new int[V]; Arrays.fill(result, -1); result[0] = 0; boolean available[] = new boolean[V]; Arrays.fill(available, true); for (int u = 1; u < V; u++) { Iterator<Integer> it = adj[u].iterator(); while (it.hasNext()) { int i = it.next(); if (result[i] != -1) available[result[i]] = false; } int cr; for (cr = 0; cr < V; cr++) { if (available[cr]) break; } result[u] = cr; Arrays.fill(available, true); } for (int u = 0; u < V; u++) System.out.println(\"Vertex \" + u + \" ---> Color \" + result[u]); } public static void main(String args[]) { Graph g1 = new Graph(5); g1.addEdge(0, 1); g1.addEdge(0, 2); g1.addEdge(1, 2); g1.addEdge(1, 3); g1.addEdge(2, 3); g1.addEdge(3, 4); System.out.println(\"Coloring of graph 1\"); g1.greedyColoring(); System.out.println(); Graph g2 = new Graph(5); g2.addEdge(0, 1); g2.addEdge(0, 2); g2.addEdge(1, 2); g2.addEdge(1, 4); g2.addEdge(2, 4); g2.addEdge(4, 3); System.out.println(\"Coloring of graph 2 \"); g2.greedyColoring(); } }", "src": "class\nGraph \n{ \n\nprivate\nint\nV; \n\n\nprivate\nLinkedList<Integer> adj[]; \n\n\n\n\n\nGraph(\nint\nv) \n\n{ \n\nV = v; \n\nadj = \nnew\nLinkedList[v]; \n\nfor\n(\nint\ni=\n0\n; i<v; ++i) \n\nadj[i] = \nnew\nLinkedList(); \n\n} \n\n\n\n\nvoid\naddEdge(\nint\nv,\nint\nw) \n\n{ \n\nadj[v].add(w); \n\nadj[w].add(v); \n\n\n} \n\n\n\n\n\n\nvoid\ngreedyColoring() \n\n{ \n\nint\nresult[] = \nnew\nint\n[V]; \n\n\n\n\nArrays.fill(result, -\n1\n); \n\n\n\n\nresult[\n0\n] = \n0\n; \n\n\n\n\n\n\n\n\nboolean\navailable[] = \nnew\nboolean\n[V]; \n\n\n\n\nArrays.fill(available, \ntrue\n); \n\n\n\n\nfor\n(\nint\nu = \n1\n; u < V; u++) \n\n{ \n\n\n\n\n\nIterator<Integer> it = adj[u].iterator() ; \n\nwhile\n(it.hasNext()) \n\n{ \n\nint\ni = it.next(); \n\nif\n(result[i] != -\n1\n) \n\navailable[result[i]] = \nfalse\n; \n\n} \n\n\n\n\nint\ncr; \n\nfor\n(cr = \n0\n; cr < V; cr++){ \n\nif\n(available[cr]) \n\nbreak\n; \n\n} \n\n\nresult[u] = cr; \n\n\n\n\n\nArrays.fill(available, \ntrue\n); \n\n} \n\n\n\n\nfor\n(\nint\nu = \n0\n; u < V; u++) \n\nSystem.out.println(\n\"Vertex \"\n+ u + \n\" ---> Color \"\n\n+ result[u]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nGraph g1 = \nnew\nGraph(\n5\n); \n\ng1.addEdge(\n0\n, \n1\n); \n\ng1.addEdge(\n0\n, \n2\n); \n\ng1.addEdge(\n1\n, \n2\n); \n\ng1.addEdge(\n1\n, \n3\n); \n\ng1.addEdge(\n2\n, \n3\n); \n\ng1.addEdge(\n3\n, \n4\n); \n\nSystem.out.println(\n\"Coloring of graph 1\"\n); \n\ng1.greedyColoring(); \n\n\nSystem.out.println(); \n\nGraph g2 = \nnew\nGraph(\n5\n); \n\ng2.addEdge(\n0\n, \n1\n); \n\ng2.addEdge(\n0\n, \n2\n); \n\ng2.addEdge(\n1\n, \n2\n); \n\ng2.addEdge(\n1\n, \n4\n); \n\ng2.addEdge(\n2\n, \n4\n); \n\ng2.addEdge(\n4\n, \n3\n); \n\nSystem.out.println(\n\"Coloring of graph 2 \"\n); \n\ng2.greedyColoring(); \n\n} \n}", "index": 489, "complexity": "3"}
{"back-translation": "class GFG { static final int N = 3; static int getMin(int arr[]) { int minInd = 0; for (int i = 1; i < N; i++) if (arr[i] < arr[minInd]) minInd = i; return minInd; } static int getMax(int arr[]) { int maxInd = 0; for (int i = 1; i < N; i++) if (arr[i] > arr[maxInd]) maxInd = i; return maxInd; } static int minOf2(int x, int y) { return (x < y) ? x: y; } static void minCashFlowRec(int amount[]) { int mxCredit = getMax(amount), mxDebit = getMin(amount); if (amount[mxCredit] == 0 && amount[mxDebit] == 0) return; int min = minOf2(-amount[mxDebit], amount[mxCredit]); amount[mxCredit] -= min; amount[mxDebit] += min; System.out.println(\"Person \" + mxDebit + \" pays \" + min + \" to \" + \"Person \" + mxCredit); minCashFlowRec(amount); } static void minCashFlow(int graph[][]) { int amount[]=new int[N]; for (int p = 0; p < N; p++) for (int i = 0; i < N; i++) amount[p] += (graph[i][p] - graph[p][i]); minCashFlowRec(amount); } public static void main (String[] args) { int graph[][] = { {0, 1000, 2000}, {0, 0, 5000}, {0, 0, 0},}; minCashFlow(graph); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nfinal\nint\nN = \n3\n; \n\n\n\n\n\n\nstatic\nint\ngetMin(\nint\narr[]) \n\n{ \n\nint\nminInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] < arr[minInd]) \n\nminInd = i; \n\nreturn\nminInd; \n\n} \n\n\n\n\n\n\nstatic\nint\ngetMax(\nint\narr[]) \n\n{ \n\nint\nmaxInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] > arr[maxInd]) \n\nmaxInd = i; \n\nreturn\nmaxInd; \n\n} \n\n\n\n\nstatic\nint\nminOf2(\nint\nx, \nint\ny) \n\n{ \n\nreturn\n(x < y) ? x: y; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nminCashFlowRec(\nint\namount[]) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nmxCredit = getMax(amount), mxDebit = getMin(amount); \n\n\n\n\n\n\nif\n(amount[mxCredit] == \n0\n&& amount[mxDebit] == \n0\n) \n\nreturn\n; \n\n\n\n\nint\nmin = minOf2(-amount[mxDebit], amount[mxCredit]); \n\namount[mxCredit] -= min; \n\namount[mxDebit] += min; \n\n\n\n\nSystem.out.println(\n\"Person \"\n+ mxDebit + \n\" pays \"\n+ min \n\n+ \n\" to \"\n+ \n\"Person \"\n+ mxCredit); \n\n\n\n\n\n\n\n\n\n\n\n\nminCashFlowRec(amount); \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nminCashFlow(\nint\ngraph[][]) \n\n{ \n\n\n\n\n\nint\namount[]=\nnew\nint\n[N]; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\np = \n0\n; p < N; p++) \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\namount[p] += (graph[i][p] - graph[p][i]); \n\n\nminCashFlowRec(amount); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\n\n\nint\ngraph[][] = { {\n0\n, \n1000\n, \n2000\n}, \n\n{\n0\n, \n0\n, \n5000\n}, \n\n{\n0\n, \n0\n, \n0\n},}; \n\n\n\n\nminCashFlow(graph); \n\n} \n}", "index": 490, "complexity": "3"}
{"back-translation": "class Main { static void minAbsSumPair( int arr[], int arr_size) { int inv_count = 0; int l, r, min_sum, sum, min_l, min_r; if (arr_size < 2) { System.out.println( \"Invalid Input\"); return; } min_l = 0; min_r = 1; min_sum = arr[0] + arr[1]; for (l = 0; l < arr_size - 1; l++) { for (r = l+1; r < arr_size; r++) { sum = arr[l] + arr[r]; if (Math.abs(min_sum) > Math.abs(sum)) { min_sum = sum; min_l = l; min_r = r; } } } System.out.println( \" The two elements whose \" + \"sum is minimum are \" + arr[min_l]+ \" and \"+arr[min_r]); } public static void main (String[] args) { int arr[] = { 1, 60, -10, 70, -80, 85}; minAbsSumPair(arr, 6); } }", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n}", "index": 491, "complexity": "3"}
{"back-translation": "class GFG { static void printPrevSmaller(int[] arr, int n) { System.out.print(\"_, \"); for (int i = 1; i < n; i++) { int j; for (j = i - 1; j >= 0; j--) { if (arr[j] < arr[i]) { System.out.print(arr[j] + \", \"); break; } } if (j == -1) System.out.print(\"_, \"); } } public static void main(String[] args) { int[] arr = { 1, 3, 0, 2, 5 }; int n = arr.length; printPrevSmaller(arr, n); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nprintPrevSmaller(\nint\n[]arr, \nint\nn) \n{ \n\n\n\n\n\n\nSystem.out.print( \n\"_, \"\n); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nint\nj; \n\nfor\n(j = i - \n1\n; j >= \n0\n; j--) \n\n{ \n\nif\n(arr[j] < arr[i]) \n\n{ \n\nSystem.out.print(arr[j] + \n\", \"\n); \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nif\n(j == -\n1\n) \n\nSystem.out.print( \n\"_, \"\n) ; \n\n} \n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]arr = {\n1\n, \n3\n, \n0\n, \n2\n, \n5\n}; \n\nint\nn = arr.length; \n\nprintPrevSmaller(arr, n); \n\n} \n}", "index": 492, "complexity": "3"}
{"back-translation": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] arr = new int[n];\n\t\tint maxindex = 0;\n\t\tint minindex = 0;\n\t\tint max;\n\t\tint min;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tarr[i] = Integer.parseInt(args[i + 1]);\n\t\t}\n\t\tint k = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tfor (int j = i; j < arr.length; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tint k1 = Math.min(arr[i], arr[j]) / Math.abs(i - j);\n\t\t\t\t\tif (k1 < k) {\n\t\t\t\t\t\tk = k1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(k);\n\t}\n\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint[] arr = new int [n];\n\t\tint maxindex=0;\n\t\tint minindex=0;\n\t\tint max;\n\t\tint min;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tarr[i]=sc.nextInt();\n\t\t}\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tfor(int j=i;j<arr.length;j++) {\n\t\t\t\tif(i!=j) {\n\t\t\t\t\tint k1=Math.min(arr[i], arr[j])/Math.abs(i-j);\n\t\t\t\t\tif(k1<k) {\n\t\t\t\t\t\tk = k1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(k);\n\t}\n\n}", "index": 493, "complexity": "3"}
{"back-translation": "ERROR", "src": "public class hi {\n    public static void main(String[] args) throws IOException{\n        Reader in=new Reader();\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\tint n=in.nextInt();\n\t\tint[] arr=in.nextIntArray(n);\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tint a=(int)Math.floor((Math.min(arr[i],arr[j])/Math.abs(i-j)));\n\t\t\t\tif(a < k)\n\t\t\t\t\tk=a;\n\t\t\t}\n\t\t}\n\t\tw.println(k);\n        w.close();\n        return;\n\t}\n\t\n}\n\n\nclass Reader \n\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\t\tpublic String nextLine() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n        public String next() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\t\tpublic int nextInt() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} while ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n        } \n        public int[] nextIntArray(int n) throws IOException{\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n            }\n\n\t\t\treturn a;\n\t\t}\n\t\tpublic long nextLong() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic double nextDouble() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n\n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n\n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n        } \n        public boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n    }", "index": 494, "complexity": "3"}
{"back-translation": "public class PartySweet {\n    static BufferedReader br;\n    static StringTokenizer tokenizer;\n\n    public static void main(String[] args) throws Exception {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int n = nextInt(), m = nextInt();\n        int[] b = new int[n];\n        int[] g = new int[m];\n        for (int i = 0; i < n; i++)\n            b[i] = nextInt();\n        for (int i = 0; i < m; i++)\n            g[i] = nextInt();\n        int total = 0;\n        int max = 0, max2 = 0;\n        for (int i = 0; i < n; i++) {\n            if (b[i] > b[max]) {\n                max2 = max;\n                max = i;\n            } else if (b[max2] < b[i])\n                max2 = i;\n        }\n        total += b[max] - b[max2];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (b[i] > g[j]) {\n                    System.out.println(-1);\n                    return;\n                }\n                if (i != max)\n                    total += b[i];\n                else\n                    total += g[j];\n            }\n        }\n        System.out.println(total);\n    }\n\n    public static String next() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            String line = br.readLine();\n            if (line == null)\n                throw new IOException();\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n}", "src": "public class PartySweet {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt(), m = nextInt();\n\t\tint[] b = new int[n];\n\t\tint[] g = new int[m];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tb[i] = nextInt();\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tg[i] = nextInt();\n\t\tint total = 0;\n\t\tint max = 0, max2 = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(b[i] > b[max]) {\n\t\t\t\tmax2 = max;\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t\telse if(b[max2] < b[i])\n\t\t\t\tmax2 = i;\n\t\t}\n\t\ttotal += b[max] - b[max2];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(b[i] > g[j]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(i != max)\n\t\t\t\t\ttotal += b[i];\n\t\t\t\telse\n\t\t\t\t\ttotal += g[j];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(total);\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "index": 495, "complexity": "3"}
{"back-translation": "ERROR", "src": "public class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "index": 496, "complexity": "3"}
{"back-translation": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 & i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n}", "src": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "index": 497, "complexity": "3"}
{"back-translation": "public class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "src": "public class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "index": 498, "complexity": "3"}
{"back-translation": "public class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "src": "public class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n\n\n\n\n\n\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "index": 499, "complexity": "3"}
{"back-translation": "public class Solution {  \n    public static void main(String[] args) {  \n        Scanner sc = new Scanner(System.in);  \n        Solution ss = new Solution();  \n        ss.test(sc);  \n    }  \n      \n    void test(Scanner sc){  \n        int LEN = sc.nextInt();  \n        int[] a = new int[LEN];  \n        int[] b = new int[LEN];  \n        for (int i = 0; i < b.length; i++) {  \n            a[i] = sc.nextInt();  \n        }  \n        for (int i = 0; i < b.length; i++) {  \n            b[i] = sc.nextInt();  \n        }  \n        Arrays.sort(a);  \n        Arrays.sort(b);  \n          \n        int ia=0, ib=0;  \n        while(ia<LEN && a[ia]==0) ia++;  \n        while(ib<LEN && b[ib]==0) ib++;  \n        if(ib==LEN){  \n            System.out.println(\"Yes\");  \n            return;  \n        }  \n        if(ia==LEN){  \n            System.out.println(\"No\");  \n            return;  \n        }    \n          \n        boolean out = true;  \n        while(ia<LEN && ib<LEN){  \n            if(a[ia]==b[ib]){  \n                ia++;  \n                ib++;  \n            }else{  \n                if(a[ia]>b[ib]){  \n                    while(ib<LEN && b[ib]!=a[ia]){  \n                        ib++;  \n                    }  \n                    if(ib==LEN){  \n                        out=false;  \n                        break;  \n                    }  \n                }  \n            }  \n        }  \n          \n        if(out){  \n            System.out.println(\"Yes\");  \n        }else{  \n            System.out.println(\"No\");  \n        }  \n    }  \n}", "src": "public class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\twhile(ia<LEN && a[ia]==0) ia++;\n\t\twhile(ib<LEN && b[ib]==0) ib++;\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\twhile(ia<LEN && ib<LEN){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\twhile(ib<LEN && b[ib]!=a[ia]){\n\t\t\t\t\t\tib++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}", "index": 500, "complexity": "3"}
{"back-translation": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet<Integer> newset = new HashSet<Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[]) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tk = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(tk.nextToken());\n        int x = Integer.parseInt(tk.nextToken());\n        \n        int[] a = new int[N];\n        int[] b = new int[N];\n        StringTokenizer tb = new StringTokenizer(br.readLine());\n        for(int i=0; i<N; i++){\n            a[i] = Integer.parseInt(tb.nextToken());\n        }\n        if(set_size(a, N) < N){\n            System.out.print(\"0\");\n            System.exit(0);\n        }\n        int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "src": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "index": 501, "complexity": "3"}
{"back-translation": "public class Cr500 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n        for (int i = 0; i < n; i++) {\n            int v;\n            if (!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n            if (!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n        if (contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for (int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for (int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if (i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "src": "public class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "index": 502, "complexity": "3"}
{"back-translation": "public class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "src": "public class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "index": 503, "complexity": "3"}
{"back-translation": "public class Main {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] v = new int[n];\n        int[] ans = new int[n];\n        long s = 0;\n        int t;\n        for (int i = 0; i < n; i++) {\n            v[i] = in.nextInt();\n            s += v[i];\n        }\n\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (v[j] > v[i]) {\n                    t = v[i];\n                    v[i] = v[j];\n                    v[j] = t;\n                }\n            }\n        }\n\n        for (int i = 0; i < n - 1; i++) {\n            if (v[i] > v[i + 1]) {\n                ans[i] = v[i] - v[i + 1];\n            }\n\n            if (v[i] == v[i + 1] && v[i] != 1) {\n                ans[i] = 1;\n                v[i + 1]--;\n            }\n\n            if (v[i] < v[i + 1]) {\n                ans[i] = 1;\n                v[i + 1] = v[i] - 1;\n                if (v[i + 1] == 0) {\n                    v[i + 1] = 1;\n                }\n            }\n            if (v[i] == 0 || v[i] == 1) {\n                ans[i] = 1;\n                v[i] = 1;\n            }\n        }\n        if (v[n - 1] > 1) {\n            ans[n - 1] = v[n - 1];\n        } else {\n            ans[n - 1] = 1;\n        }\n\n        for (int i = 0; i < n; i++) {\n            s -= ans[i];\n\n        }\n        System.out.print(s);\n\n\n    }\n}", "src": "public class Main {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] v = new int[n];\n        int[] ans = new int[n];\n        long s = 0;\n        int t;\n        for(int i=0; i<n;i++) {\n            v[i] = in.nextInt();\n            s+=v[i];\n        }\n\n        for(int i=0; i<n-1;i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (v[j] > v[i]) {\n                    t = v[i];\n                    v[i] = v[j];\n                    v[j] = t;\n                }\n            }\n        }\n\n        for(int i=0; i<n-1; i++){\n            if(v[i] > v[i+1]){\n                    ans[i] = v[i]-v[i+1];\n            }\n\n            if(v[i] == v[i+1] && v[i]!=1){\n                ans[i]=1;\n                v[i+1]--;\n            }\n\n            if(v[i] < v[i+1]){\n                ans[i]=1;\n                v[i+1] = v[i]-1;\n                if(v[i+1] == 0){\n                    v[i+1] = 1;\n                }\n            }\n            if(v[i] == 0 || v[i] == 1){\n                ans[i] = 1;\n                v[i] = 1;\n            }\n        }\n        if (v[n-1] > 1){\n            ans[n-1] = v[n-1];\n        }\n        else{\n            ans[n-1] = 1;\n        }\n\n        for (int i=0; i<n; i++){\n                s-=ans[i];\n\n        }\n        System.out.print(s);\n\n\n    }\n}", "index": 504, "complexity": "3"}
{"back-translation": "public class Main {\n\n    public static void main(String[] args) {\n       Scanner s = new Scanner(System.in);\n       int n = s.nextInt();\n       int m = s.nextInt();\n       m = 0;\n       long sum = 0;\n       int[] expon = new int[n];\n        for (int i = 0; i < n; i++) {\n            expon[i] = s.nextInt();\n            m = Math.max(expon[i], m);\n            sum += expon[i];\n        }\n        HashSet<Integer> levels = new HashSet<>();\n\n\n        int amount = 0;\n        for (int i = 0; i < n; i++) {\n            int currentHigh = expon[i];\n            for (int j = currentHigh; j >= 1; j--) {\n                if(!levels.contains(j)) {\n                    levels.add(j);\n                    amount++;\n                    break;\n                }\n                if(j == 1){\n                    amount++;\n                }\n            }\n        }\n        System.out.println((sum - amount) - (m - levels.size()));\n    }\n}", "src": "public class Main {\n\n    public static void main(String[] args) {\n       Scanner s = new Scanner(System.in);\n       int n = s.nextInt();\n       int m = s.nextInt();\n       m = 0;\n       long sum = 0;\n       int[] expon = new int[n];\n        for (int i = 0; i < n; i++) {\n            expon[i] = s.nextInt();\n            m = Math.max(expon[i], m);\n            sum += expon[i];\n        }\n        HashSet<Integer> levels = new HashSet<>();\n\n\n        int amount = 0;\n        for (int i = 0; i < n; i++) {\n            int currentHigh = expon[i];\n            for (int j = currentHigh; j >= 1; j--) {\n                if(!levels.contains(j)) {\n                    levels.add(j);\n                    amount++;\n                    break;\n                }\n                if(j == 1){\n                    amount++;\n                }\n            }\n        }\n        System.out.println((sum - amount) - (m - levels.size()));\n    }\n}", "index": 505, "complexity": "3"}
{"back-translation": "class GFG { static int answerQuery(int a[], int n, int l, int r) { int count = 0; l = l - 1; for (int i = l; i < r; i++) { int element = a[i]; int divisors = 0; for (int j = l; j < r; j++) { if (a[j] % a[i] == 0) divisors++; else break; } if (divisors == (r - l)) count++; } return count; } public static void main (String[] args) { int a[] = { 1, 2, 3, 5 }; int n = a.length; int l = 1, r = 4; System.out.println(answerQuery(a, n, l, r)); l = 2; r = 4; System.out.println(answerQuery(a, n, l, r)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nanswerQuery(\nint\na[], \nint\nn, \n\nint\nl, \nint\nr) \n{ \n\n\n\nint\ncount = \n0\n; \n\n\n\n\nl = l - \n1\n; \n\n\n\n\nfor\n(\nint\ni = l; i < r; i++) \n\n{ \n\nint\nelement = a[i]; \n\nint\ndivisors = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\nj = l; j < r; j++) \n\n{ \n\n\n\nif\n(a[j] % a[i] == \n0\n) \n\ndivisors++; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\nif\n(divisors == (r - l)) \n\ncount++; \n\n} \n\n\n\n\nreturn\ncount; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = { \n1\n, \n2\n, \n3\n, \n5\n}; \n\nint\nn = a.length; \n\n\nint\nl = \n1\n, r = \n4\n; \n\nSystem.out.println( answerQuery(a, n, l, r)); \n\n\nl = \n2\n; r = \n4\n; \n\nSystem.out.println( answerQuery(a, n, l, r)); \n} \n}", "index": 506, "complexity": "3"}
{"back-translation": "public class Main {\n    static class Interval {\n        int start;\n        int end;\n\n        public Interval(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static long mod = 1000000007;\n\n    public static void main(String[] args) {\n\n        FastReader in = new FastReader();\n        long intervals = in.nextInt();\n        long x = in.nextInt();\n        long y = in.nextInt();\n        Interval[] ints = new Interval[(int) intervals];\n        for (int i = 0; i < intervals; i++) {\n            ints[i] = new Interval(in.nextInt(), in.nextInt());\n        }\n        Arrays.sort(ints, (a, b) -> a.start - b.start);\n        long count = 0;\n        for (int i = 0; i < ints.length; i++) {\n            if (i >= 0 && ints[i] != null) {\n                Interval cur1 = ints[i];\n                for (int j = i + 1; j < ints.length; j++) {\n                    if (ints[j] != null) {\n                        Interval cur2 = ints[j];\n                        if (y * (cur2.start - cur1.end) < x) {\n                            if (cur1.start != cur2.start && cur1.end < cur2.start) {\n                                cur1.end = cur2.end;\n                                ints[j] = null;\n                            }\n                        } else\n                            break;\n                    }\n\n                }\n                count = (count + x) % mod;\n                count += (y * (cur1.end - cur1.start) % mod);\n                count %= mod;\n            }\n\n        }\n\n        System.out.println(count);\n    }\n}", "src": "public class main {\nstatic\tclass Interval{\n\t\tint start;\n\t\tint end;\n\t\tpublic Interval(int start,int end) {\n\t\t\tthis.start=start;\n\t\t\tthis.end=end;\n\t\t}\n\t}\nstatic class FastReader \n{ \n    BufferedReader br; \n    StringTokenizer st; \n\n    public FastReader() \n    { \n        br = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    } \n\n    String next() \n    { \n        while (st == null || !st.hasMoreElements()) \n        { \n            try\n            { \n                st = new StringTokenizer(br.readLine()); \n            } \n            catch (IOException  e) \n            { \n                e.printStackTrace(); \n            } \n        } \n        return st.nextToken(); \n    } \n\n    int nextInt() \n    { \n        return Integer.parseInt(next()); \n    } \n\n    long nextLong() \n    { \n        return Long.parseLong(next()); \n    } \n\n    double nextDouble() \n    { \n        return Double.parseDouble(next()); \n    } \n\n    String nextLine() \n    { \n        String str = \"\"; \n        try\n        { \n            str = br.readLine(); \n        } \n        catch (IOException e) \n        { \n            e.printStackTrace(); \n        } \n        return str; \n    } \n} \n\tstatic long mod = 1000000007;\n\tpublic static void main(String[] args) {\n\t\t\n\t\tFastReader in = new FastReader();\n\t\tlong intervals = in.nextInt();\n\t\tlong x = in.nextInt();\n\t\t long y = in.nextInt();\n\t\tInterval []ints = new Interval[(int)(int) intervals];\n\t\tfor(int i = 0;i<intervals;i++) {\n\t\t\tints[i] = new Interval(in.nextInt(),in.nextInt());\n\t\t}\n\t\tArrays.sort(ints, (a,b)->a.start-b.start);\n\t\tlong count = 0;\n\t\tfor(int i = 0;i<ints.length;i++) {\n\t\t\tif(i>=0&&ints[i]!=null) {\n\t\t\tInterval cur1 = ints[i];\n\t\t\tfor(int j = i+1;j<ints.length;j++) {\n\t\t\tif(ints[j]!=null) {\n\t\t\tInterval cur2 = ints[j];\n\t\t\tif(y*(cur2.start-cur1.end)<x) {\n\t\t\tif(cur1.start!=cur2.start&&cur1.end<cur2.start) {\n\t\t\t\tcur1.end=cur2.end;\n\t\t\t\t\n\t\t\t\tints[j]=null;\n\t\t\t\n\t\t\t}}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tcount = (count + x) % mod;\n\t\t\tcount += (y*(cur1.end-cur1.start)%mod);\n\t\t\tcount%=mod;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\n\n\n\n\n\n\n\n\t\tSystem.out.println(count);\n\t}\n\n}", "index": 507, "complexity": "3"}
{"back-translation": "public class TaxiDriversAndLyft {\n\n    static class Resident{\n        Integer index;         \n        Integer type;         \n        Integer requests;     \n        \n        public Resident(int index, int type) {\n            this.index = index;\n            this.type = type;\n            this.requests = 0;\n        }\n        \n        @Override\n        public String toString() {\n            if(type == 0) {\n                return \"Rider at index : \" + index;\n            }\n            else {\n                return \"Driver at index : \" + index + \", Requests: \" + requests;\n            }\n        }\n    }\n    \n    static ArrayList<Resident> residents;\n    static ArrayList<Integer> drivers_indexes = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Scanner reader = new Scanner(System.in);\n        int n = reader.nextInt();\n        int m = reader.nextInt();\n        int length = n + m;\n        \n        int [] coordinates = new int[length];\n        int [] types = new int[length];\n        residents = new ArrayList<>();\n        drivers_indexes = new ArrayList<>();\n        \n        for (int i = 0; i < length; i++) {\n            coordinates[i] = reader.nextInt();\n        }\n        \n        for (int i = 0; i < length; i++) {\n            types[i] = reader.nextInt();\n            \n            if(types[i] == 1)\n                drivers_indexes.add(i);\n                \n            residents.add(new Resident(i, types[i]));\n        }\n        reader.close();  \n        \n        for (int i = 0; i < length; i++) {\n            Resident current = residents.get(i);\n            if(current.type == 0) {\n                int left = i-1, right = i+1;\n                                \n                while(left >= 0 || right < length) {\n                    if(left >= 0 && residents.get(left).type == 1) {\n                        residents.get(left).requests++;\n                        break;\n                    }\n                    else if(right < length && residents.get(right).type == 1) {\n                        residents.get(right).requests++;\n                        break;\n                    }\n                    \n                    left--;\n                    right++;\n                }\n            }\n        }\n        \n        for(int index : drivers_indexes) {\n            System.out.print(residents.get(index).requests + \" \");\n        }\n    }\n\n}", "src": "public class TaxiDriversAndLyft {\n\t\n\tstatic class Resident{\n\t\tInteger index;\t\t\t\n\t\tInteger type;\t\t\t\n\t\tInteger requests;\t\t\n\t\t\n\t\tpublic Resident(int index, int type) {\n\t\t\tthis.index = index;\n\t\t\tthis.type = type;\n\t\t\tthis.requests = 0;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif(type == 0) {\n\t\t\t\treturn \"Rider at index : \" + index;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"Driver at index : \" + index + \", Requests: \" + requests;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Resident> residents;\n\tstatic ArrayList<Integer> drivers_indexes = new ArrayList<>();\n\n\tpublic static void main(String[] args) {\n\t\tScanner reader = new Scanner(System.in);\n\t\tint n = reader.nextInt();\n\t\tint m = reader.nextInt();\n\t\tint length = n + m;\n\t\t\n\t\tint [] coordinates = new int[length];\n\t\tint [] types = new int[length];\n\t\tresidents = new ArrayList<>();\n\t\tdrivers_indexes = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tcoordinates[i] = reader.nextInt();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\ttypes[i] = reader.nextInt();\n\t\t\t\n\t\t\tif(types[i] == 1)\n\t\t\t\tdrivers_indexes.add(i);\n\t\t\t\t\n\t\t\tresidents.add(new Resident(i, types[i]));\n\t\t}\n\t\treader.close();\t\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tResident current = residents.get(i);\n\t\t\tif(current.type == 0) {\n\t\t\t\tint left = i-1, right = i+1;\n\t\t\t\t\t\t\t\t\n\t\t\t\twhile(left >= 0 || right < length) {\n\t\t\t\t\tif(left >= 0 && residents.get(left).type == 1) {\n\t\t\t\t\t\tresidents.get(left).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(right < length && residents.get(right).type == 1) {\n\t\t\t\t\t\tresidents.get(right).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tleft--;\n\t\t\t\t\tright++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int index : drivers_indexes) {\n\t\t\tSystem.out.print(residents.get(index).requests + \" \");\n\t\t}\n\t}\n\n}", "index": 508, "complexity": "3"}
{"back-translation": "public class Lyft {\n    private static FastScanner scan = new FastScanner(System.in);\n    private static PrintWriter pr = new PrintWriter(System.out);\n    private static int n, m, taxistNumber, noTaxistNumber = 0;\n    static people peoples[], taxist[], noTaxist[];\n    public static void main(String[] args) throws IOException {\n        n = scan.nextInt();\n        m = scan.nextInt();\n        peoples = new people[n + m];\n        noTaxist = new people[n];\n        taxist = new people[m];\n        for (int i = 0; i < peoples.length; i++) {\n            peoples[i] = new people(scan.nextInt());\n        }\n        for (people i : peoples) {\n            if (scan.nextInt() == 1) {\n                i.taxi = true;\n                i.passangers = 0;\n                taxist[taxistNumber] = i;\n                taxistNumber++;\n            } else {\n                noTaxist[noTaxistNumber] = i;\n                noTaxistNumber++;\n            }\n        }\n        for (people i : noTaxist) {\n            for (people ii : taxist) {\n                if (ii.taxi) {\n                    if (i.nearestTaxist == null) {\n                        i.nearestTaxist = ii;\n                        ii.passangers++;\n                    } else if (i.coord - i.nearestTaxist.coord > ii.coord - i.coord) {\n                        i.nearestTaxist.passangers--;\n                        i.nearestTaxist = ii;\n                        i.nearestTaxist.passangers++;\n                    }\n                }\n            }\n        }\n        for (people i : taxist) {\n            pr.print(i.passangers + \" \");\n        }\n        pr.close();\n    }\n}\n\nclass FastScanner {\n    private static final int bufferSize = 64 * 1024;\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    FastScanner(InputStream inputStream) {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream), bufferSize);\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            String line = reader.readLine();\n            if (line == null) {\n                tokenizer = null;\n                return null;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    int[] readIntArray(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    long[] readLongArray(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextLong();\n        }\n        return a;\n    }\n\n    int nextInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws NumberFormatException, IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextLine() throws IOException {\n        tokenizer = null;\n        return reader.readLine();\n    }\n}\n\nclass people {\n    int coord = 0;\n    boolean taxi = false;\n    people nearestTaxist = null;\n    int passangers = -1;\n\n    people(int coord) {\n        this.coord = coord;\n    }\n}", "src": "public class Lyft {\n    private static FastScanner scan = new FastScanner(System.in);\n    private static PrintWriter pr = new PrintWriter(System.out);\n    private static int n, m, taxistNumber, noTaxistNumber = 0;\n    static people peoples[], taxist[], noTaxist[];\n    public static void main(String[] args) throws IOException {\n        n = scan.nextInt();\n        m = scan.nextInt();\n        peoples = new people[n + m];\n        noTaxist = new people[n];\n        taxist = new people[m];\n        for(int i = 0; i < peoples.length; i++){\n            peoples[i] = new people(scan.nextInt());\n        }\n        for (people i : peoples){\n            if(scan.nextInt() == 1){\n                i.taxi = true;\n                i.passangers = 0;\n                taxist[taxistNumber] = i;\n                taxistNumber++;\n            }else{\n                noTaxist[noTaxistNumber] = i;\n                noTaxistNumber++;\n            }\n        }\n        for (people i : noTaxist){\n                for (people ii: taxist){\n                    if(ii.taxi){\n                       if(i.nearestTaxist == null){\n                           i.nearestTaxist = ii;\n                           ii.passangers++;\n                       }else if(i.coord - i.nearestTaxist.coord > ii.coord - i.coord){\n                           i.nearestTaxist.passangers--;\n                           i.nearestTaxist = ii;\n                           i.nearestTaxist.passangers++;\n                       }\n                    }\n                }\n        }\n        for (people i : taxist){\n                pr.print(i.passangers + \" \");\n        }\n        pr.close();\n    }\n}\nclass FastScanner\n{\n    private static final int bufferSize = 64 * 1024;\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    FastScanner(InputStream inputStream)\n    {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream), bufferSize);\n    }\n\n    String nextToken() throws IOException\n    {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n        {\n            String line = reader.readLine();\n            if (line == null)\n            {\n                tokenizer = null;\n                return null;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    int[] readIntArray(int n) throws IOException\n    {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    long[] readLongArray(int n) throws IOException\n    {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = nextLong();\n        }\n        return a;\n    }\n\n    int nextInt() throws NumberFormatException, IOException\n    {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws NumberFormatException, IOException\n    {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws NumberFormatException, IOException\n    {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextLine() throws IOException\n    {\n        tokenizer = null;\n        return reader.readLine();\n    }\n}\nclass people{\n    int coord = 0;\n    boolean taxi = false;\n    people nearestTaxist = null;\n    int passangers = -1;\n    people(int coord){\n        this.coord = coord;\n    }\n}", "index": 509, "complexity": "3"}
{"back-translation": "public class NeaZipjzI {public static void main(String[] args) {Scanner scan = new Scanner(System.in);int n = scan.nextInt();int m = scan.nextInt();int k = n + m;long[] arr1 = new long[k];for (int i = 0; i < k; i++) {arr1[i] = scan.nextLong();}long[] tax = new long[k];long[] taxcount = new long[k];for (int i = 0; i < k; i++) {tax[i] = scan.nextInt();}int c;int b;for (int i = 0; i < k; i++) {if (tax[i] == 0) {c = i;while (tax[c] != 1) {if (c == 0) {c = -1;break;}c--;}b = i;while (tax[b] != 1) {if (b >= k - 1) {b = -1;break;}b++;}if (c == -1 && b >= 0) {taxcount[b]++;} else if (b == -1 && c >= 0) {taxcount[c]++;} else if (b >= 0 && c >= 0) {if (arr1[i] - arr1[c] > arr1[b] - arr1[i]) {taxcount[b]++;}if (arr1[i] - arr1[c] < arr1[b] - arr1[i]) {taxcount[c]++;}if (arr1[i] - arr1[c] == arr1[b] - arr1[i]) {taxcount[c]++;}}}", "src": "public class TaxistsnLyft {\n\tpublic static void main (String[] args){\n\t\tScanner scan = new Scanner (System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint k = n+m;\n\t\tlong[] arr1 = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tarr1[i]=scan.nextLong();\n\t\t}\n\t\tlong[] tax = new long[k];\n\t\tlong[] taxcount = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\ttax[i]=scan.nextInt();\n\t\t}\n\t\tint c;\n\t\tint b;\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tif(tax[i]==0){\n\t\t\t\tc=i;\n\t\t\t\twhile(tax[c]!=1){\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tc=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tc--;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tb=i;\n\t\t\t\twhile(tax[b]!=1){\n\t\t\t\t\tif(b>=k-1){\n\t\t\t\t\t\tb=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} \n\t\t\t\t\tb++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(c==-1&&b>=0){\n\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t} else if(b==-1&&c>=0) {\n\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t} else if(b>=0&&c>=0) {\n\t\t\t\t\tif(arr1[i]-arr1[c]>arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]<arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]==arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\tfor(int j = 0; j<k; j++){\n\t\t\tif(tax[j]==1){\n\t\t\t\tSystem.out.print(taxcount[j]+\" \");\n\t\t\t}\n\t\tscan.close();\n\t\t}\n\t}\n}", "index": 510, "complexity": "3"}
{"back-translation": "public class RookHome {\n    static long MAX = 1_000_000_000;\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(new BufferedInputStream(System.in));\n        int n = s.nextInt();\n        int m = s.nextInt();\n        long[] vert = new long[n + 2];\n        vert[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            vert[i] = s.nextLong();\n        }\n        vert[n + 1] = MAX;\n        long[][] hor = new long[m][2];\n        for (int i = 0; i < m; i++) {\n            hor[i][0] = s.nextLong();\n            hor[i][1] = s.nextLong();\n            s.nextLong();\n        }\n        long min = Long.MAX_VALUE;\n        int count;\n        for (int i = 0; i < vert.length - 1; i++) {\n            count = 0;\n            for (int j = 0; j < m; j++) {\n                if (hor[j][0] <= vert[i] && hor[j][1] >= vert[i + 1]) {\n                    count++;\n                }\n            }\n            min = Math.min(min, i + count);\n        }\n        System.out.println(min);\n    }\n}", "src": "public class RookHome {\n\tstatic long MAX = 1_000_000_000;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(new BufferedInputStream(System.in));\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tlong[] vert = new long[n + 2];\n\t\tvert[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tvert[i] = s.nextLong();\n\t\t}\n\t\tvert[n + 1] = MAX;\n\t\tlong[][] hor = new long[m][2];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\thor[i][0] = s.nextLong();\n\t\t\thor[i][1] = s.nextLong();\n\t\t\ts.nextLong();\n\t\t}\n\t\tlong min = Long.MAX_VALUE;\n\t\tint count;\n\t\tfor(int i = 0; i < vert.length - 1; i++) {\n\t\t\tcount = 0;\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(hor[j][0] <= vert[i] && hor[j][1] >= vert[i + 1]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = Math.min(min, i + count);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "index": 511, "complexity": "3"}
{"back-translation": "public class Main {\n    public static int n, m;\n    public static int[] vert, group;\n    public static int[][] horiz;\n    public static boolean ok(int a, int b, int g) {\n        int start, end;\n        if (g == 0) {\n            start = 1;\n            end = vert.length > 0 ? vert[0] : (int) Math.pow(10, 9);\n        } else if (g == group.length - 1) {\n             start = vert[g - 1];\n             end = (int) Math.pow(10, 9);\n        } else {\n            start = vert[g - 1];\n            end = vert[g];\n        }\n        return a <= start && b >= end;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        vert = new int[n];\n        for (int i = 0; i < n; i++) {\n            vert[i] = in.nextInt();\n        }\n        horiz = new int[m][3];\n        for (int i = 0; i < m; i++) {\n            horiz[i] = new int[]{in.nextInt(), in.nextInt(), in.nextInt()};\n        }\n        group = new int[n + 1];\n        Arrays.fill(group, 0);\n        for (int i = 0; i < m; i++) {\n            int a = horiz[i][0];\n            int b = horiz[i][1];\n            for (int j = 0; j < group.length; j++) {\n                if (ok(a, b, j)) {\n                    group[j]++;\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < group.length; i++) {\n            min = Math.min(min, group[i] + i);\n        }\n        System.out.println(min);\n    }\n}", "src": "public class Main {\n    public static int n, m;\n    public static int[] vert, group;\n    public static int[][] horiz;\n    public static boolean ok(int a, int b, int g) {\n        int start, end;\n        if (g == 0) {\n            start = 1;\n            end = vert.length > 0 ? vert[0] : (int)Math.pow(10, 9);\n        } else if (g == group.length - 1) {\n            start = vert[g - 1];\n            end = (int)Math.pow(10, 9);\n        } else {\n            start = vert[g - 1];\n            end = vert[g];\n        }\n        return a <= start && b >= end;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        vert = new int[n];\n        for (int i = 0; i < n; i++) {\n            vert[i] = in.nextInt();\n        }\n        horiz = new int[m][3];\n        for (int i = 0; i < m; i++) {\n            horiz[i] = new int[]{in.nextInt(), in.nextInt(), in.nextInt()};\n        }\n        group = new int[n + 1];\n        Arrays.fill(group, 0);\n        for (int i = 0; i < m; i++) {\n            int a = horiz[i][0];\n            int b = horiz[i][1];\n            for (int j = 0; j < group.length; j++) {\n                if (ok(a, b, j)) {\n                    group[j]++;\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < group.length; i++) {\n            min = Math.min(min, group[i] + i);\n        }\n        System.out.println(min);\n    }\n}", "index": 512, "complexity": "3"}
{"back-translation": "public class Tokitsukaze {\n\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        long k =sc.nextLong();\n        double[]p=new double[m];\n        for(int i = 0;i<m;i++){\n            p[i]=sc.nextDouble();\n        }\n        int c=0;\n        int used=0;\n        for(int i = 0;i<m;){\n            long low=(long)((Math.floor((p[i])/k)*k)-i)+1;\n            long high=low+k;\n            for(int j=i;j<m;j++){\n                if(p[j]>=low&&p[i]<=high){\n                    i++;\n                }\n            }\n            c++;\n        }\n        System.out.println(c);\n\n    }\n    \n}", "src": "public class Tokitsukaze {\n\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        long k =sc.nextLong();\n        double[]p=new double[m];\n        for(int i = 0;i<m;i++){\n            p[i]=sc.nextDouble();\n        }\n        int c=0;\n        int used=0;\n        for(int i = 0;i<m;){\n            long low=(long)((Math.floor(p[i]/k)*k)-i)+1;\n            long high=low+k;\n            for(int j=i;j<m;j++){\n                if(p[j]>=low&&p[i]<=high){\n                    i++;\n                }\n            }\n            c++;\n        }\n        System.out.println(c);\n\n    }\n    \n}", "index": 513, "complexity": "3"}
{"back-translation": "final class Solution{static boolean f=true;static void F(Object R){if(f)System.err.println(R);}static void F(Object[] R){if(f){for(Object O:R)System.err.print(O+\" \");System.err.println(\"\");}}static void F(int[] R){if(f){for(int I:R)System.err.print(I+\" \");System.err.println(\"\");}}static void F(int[] R,int I){if(f){for(int J=0;J<I;J++)System.err.print(R[J]+\" \");System.err.println(\"\");}}static void F(long[] R){if(f){for(long L:R)System.err.print(L+\" \");System.err.println(\"\");}}static void E(Object R){if(f)System.err.print(R);}static void C(Object O){System.out.println(O);}static void C(Object O){C(\"\"+O+\"\\n\");}static void C(Object O){try{D.write(\"\"+O);}catch(Exception E){}}static long X=998244353;static int P=64;static BufferedWriter D;static InputReader J;static void S()throws Exception{Locale.setDefault(Locale.US);D=new BufferedWriter(new OutputStreamWriter(System.out));J=new InputReader(System.in);long G=J.readLong();int M=J.readInt();long K=J.readLong();long[] Q=new long[M];for(int Y=0;Y<M;Y++)Q[Y]=J.readLong()-1;int L=-1;int N=M;int I=0;long Z=K-1;int A=0;int B=0;int H=0;while(N>0){while(Q[I]>Z){Z+=K;if(Z>=G-1)Z=G-1;}int O=I;while(O+1<M&&Q[O+1]<=Z)O++;int T=O-I+1;N-=T;Z+=T;I=O+1;H++;}C(H);try{D.close();}catch(Exception e){}}public static void main(String[] args)throws Exception{S();}static final class InputReader{private final InputStream W;private final byte[] Z=new byte[1024];private int U;private int V;public InputReader(InputStream W){this.W=W;}private int A()throws IOException{if(U>=V){U=0;V=W.read(Z);if(V<=0)return -1;}return Z[U++];}public final String readString()throws IOException{int C=A();while(D(C)){C=A();}StringBuilder Y=new StringBuilder();do{Y.append((char)C);C=A();}while(!D(C));return Y.toString();}public final int readInt()throws IOException{int C=A();boolean Q=false;while(D(C)){C=A();}char R=(char)C;if(R==45){Q=true;C=A();}int S=0;do{S*=10;S+=C-48;C=A();}while(!D(C));if(Q)return -S;return S;}public final long readLong()throws IOException{int C=A();boolean Q=false;while(D(C)){C=A();}char R=(char)C;if(R==45){Q=true;C=A();}long S=0;do{S*=10;S+=C-48;C=A();}while(!D(C));if(Q)return -S;return S;}private boolean D(int C){return C==32||C==10||C==13||C==9||C==-1;}}}", "src": "public final class CF_573_D1_A {\n\n\n\tstatic boolean verb=true;\n\tstatic void log(Object X){if (verb) System.err.println(X);}\n\tstatic void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+\" \");System.err.println(\"\");}}\n\tstatic void log(long[] X){if (verb) {for (long U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\n\tstatic void logWln(Object X){if (verb) System.err.print(X);}\n\tstatic void info(Object o){\tSystem.out.println(o);}\n\tstatic void output(Object o){outputWln(\"\"+o+\"\\n\");\t}\n\tstatic void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n\n\t\n\tstatic long mod=998244353 ; \n\tstatic int CX=64;\n\n\n\t\n\tstatic BufferedWriter out;\n\tstatic InputReader reader;\n\n\n\t\n\n\tstatic void process() throws Exception {\n\n\t\tLocale.setDefault(Locale.US);\n\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\treader = new InputReader(System.in);\n\n\t\tlong n=reader.readLong();\n\t\tint m=reader.readInt();\n\t\t\n\t\tlong k=reader.readLong();\n\t\tlong[] p=new long[m];\n\t\tfor (int i=0;i<m;i++)\n\t\t\tp[i]=reader.readLong()-1;\n\t\t\n\t\tint pid=-1;\n\t\tint rem=m;\n\t\tint win=0; \n\t\tlong mx=k-1; \n\t\tint res=0;\n\t\tint idx=0;\n\t\t\n\t\twhile (rem>0) {\n\t\t\t\n\t\t\twhile (p[idx]>mx) {\n\t\t\t\tmx+=k;\n\t\t\t\tif (mx>=n-1)\n\t\t\t\t\tmx=n-1;\n\t\t\t\t\n\t\t\t}\n\t\t\n\t\t\tint nxt=idx;\n\t\t\twhile (nxt+1<m && p[nxt+1]<=mx)\n\t\t\t\tnxt++;\n\t\t\tint nb=nxt-idx+1;\n\t\t\trem-=nb;\n\t\t\tmx+=nb;\n\t\t\tidx=nxt+1;\n\t\t\tres++;\n\t\t}\n\t\toutput(res);\n\n\t\n\t\ttry {\n\t\t\tout.close();\n\t\t} catch (Exception E) {\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tprocess();\n\n\t}\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n}", "index": 514, "complexity": "3"}
{"back-translation": "class MinimumDistance {\n\n    int minDist(int arr[], int n, int x, int y) {\n        int i, j;\n        int min_dist = Integer.MAX_VALUE;\n        for (i = 0; i < n; i++) {\n            for (j = i + 1; j < n; j++) {\n                if ((x == arr[i] && y == arr[j] || y == arr[i] && x == arr[j]) && min_dist > Math.abs(i - j))\n                    min_dist = Math.abs(i - j);\n            }\n        }\n        return min_dist;\n    }\n\n    public static void main(String[] args) {\n        MinimumDistance min = new MinimumDistance();\n        int arr[] = {3, 5, 4, 2, 6, 5, 6, 6, 5, 4, 8, 3};\n        int n = arr.length;\n        int x = 3;\n        int y = 6;\n\n        System.out.println(\"Minimum distance between \" + x + \" and \" + y + \" is \" + min.minDist(arr, n, x, y));\n    }\n}", "src": "class\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni, j; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nfor\n(j = i + \n1\n; j < n; j++) \n\n{ \n\nif\n((x == arr[i] && y == arr[j] \n\n|| y == arr[i] && x == arr[j]) \n\n&& min_dist > Math.abs(i - j)) \n\nmin_dist = Math.abs(i - j); \n\n} \n\n} \n\nreturn\nmin_dist; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n5\n, \n6\n, \n6\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n}", "index": 515, "complexity": "3"}
{"back-translation": "ERROR", "src": "public class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "index": 516, "complexity": "3"}
{"back-translation": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n                \n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n}", "src": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "index": 517, "complexity": "3"}
{"back-translation": "public class Main {\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() { return Integer.parseInt(next()); }\n\n        public long nextLong() { return Long.parseLong(next()); }\n\n        public double nextDouble() { return Double.parseDouble(next()); }\n\n        public String nextLine() {\n            String line = \"\";\n            if (st.hasMoreTokens()) line = st.nextToken();\n            else try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            while (st.hasMoreTokens()) line += \" \" + st.nextToken();\n            return line;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for (int i = 0; i < m; i++) a[sc.nextInt()]++;\n\n        for (int i = 1; i <= 100; i++) {\n            int y = 0;\n            for (int x : a) {\n                y += x / i;\n            }\n            if (y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "src": "public class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "index": 518, "complexity": "3"}
{"back-translation": "public class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n\n        for (int i : a) {\n            map.put(i, map.getOrDefault(i, 0) + 1);\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min = 1;\n        int max = list.get(list.size() - 1).num;\n        int res = 0;\n\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}\n\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "src": "public class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n\n\n\n\n\n\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "index": 519, "complexity": "3"}
{"back-translation": "public class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\twhile(ia<LEN && a[ia]==0) ia++;\n\t\twhile(ib<LEN && b[ib]==0) ib++;\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\twhile(ia<LEN && ib<LEN){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\twhile(ib<LEN && b[ib]!=a[ia]){\n\t\t\t\t\t\tib++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}", "src": "public class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\twhile(ia<LEN && a[ia]==0) ia++;\n\t\twhile(ib<LEN && b[ib]==0) ib++;\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\twhile(ia<LEN && ib<LEN){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\twhile(ib<LEN && b[ib]!=a[ia]){\n\t\t\t\t\t\tib++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}", "index": 520, "complexity": "3"}
{"back-translation": "class GFG { static int maxSum(int[] arr, int n) { int res = Integer.MIN_VALUE; for (int i = 0; i < n; i++) { int curr_sum = 0; for (int j = 0; j < n; j++) { int index = (i + j) % n; curr_sum += j * arr[index]; } res = Math.max(res, curr_sum); } return res; } public static void main(String args[]) { int arr[] = {8, 3, 1, 2}; int n = arr.length; System.out.println(maxSum(arr, n)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n{ \n\n\n\n\nint\ncurr_sum = \n0\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nint\nindex = (i + j) % n; \n\ncurr_sum += j * arr[index]; \n\n} \n\n\n\n\nres = Math.max(res, curr_sum); \n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n} \n\n\n}", "index": 521, "complexity": "3"}
{"back-translation": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "src": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "index": 522, "complexity": "3"}
{"back-translation": "public class Cr500 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n        for (int i = 0; i < n; i++) {\n            int v;\n            if (!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n            if (!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n        if (contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n        System.out.println(status);\n    }\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for (int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for (int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if (i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "src": "public class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "index": 523, "complexity": "3"}
{"back-translation": "public class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "src": "public class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "index": 524, "complexity": "3"}
{"back-translation": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        int a[]=new int[m+1];\n        int i,j;\n        int c=0;\n        for(i=0;i<n;i++)\n        {\n            int l=scan.nextInt();\n            int r=scan.nextInt();\n            for(j=l;j<=r;j++)\n            {\n                if(a[j]!=1)\n                {\n                    a[j]=1;\n                    c++;\n                }\n            }\n        }\n        System.out.println(m-c);\n        for(i=1;i<=m;i++)\n        {\n            if(a[i]==0)\n            {\n                System.out.print(i+\" \");\n            }\n        }\n    }\n}", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        int a[]=new int[m+1];\n        int i,j;\n        int c=0;\n        for(i=0;i<n;i++)\n        {\n            int l=scan.nextInt();\n            int r=scan.nextInt();\n            for(j=l;j<=r;j++)\n            {\n                if(a[j]!=1)\n                {\n                    a[j]=1;\n                    c++;\n                }\n            }\n        }\n        System.out.println(m-c);\n        for(i=1;i<=m;i++)\n        {\n            if(a[i]==0)\n            {\n                System.out.print(i+\" \");\n            }\n        }\n    }\n}", "index": 525, "complexity": "3"}
{"back-translation": "class GFG { private static int minJumps(int[] arr, int n) { int jumps[] = new int[n]; int i, j; if (n == 0 || arr[0] == 0) return Integer.MAX_VALUE; jumps[0] = 0; for (i = 1; i < n; i++) { jumps[i] = Integer.MAX_VALUE; for (j = 0; j < i; j++) { if (i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) { jumps[i] = Math.min(jumps[i], jumps[j] + 1); break; } } } return jumps[n-1]; } public static void main(String[] args) { int arr[] = {1, 3, 6, 1, 0, 9}; System.out.println(\"Minimum number of jumps to reach end is : \" + minJumps(arr, arr.length)); } }", "src": "class\nGFG{ \n\nprivate\nstatic\nint\nminJumps(\nint\n[] arr, \nint\nn) { \n\nint\njumps[] = \nnew\nint\n[n]; \n\n\n\n\nint\ni, j; \n\n\nif\n(n == \n0\n|| arr[\n0\n] == \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\n\n\n\n\njumps[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\njumps[i] = Integer.MAX_VALUE; \n\nfor\n(j = \n0\n; j < i; j++) \n\n{ \n\nif\n(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) \n\n{ \n\njumps[i] = Math.min(jumps[i], jumps[j] + \n1\n); \n\nbreak\n; \n\n} \n\n} \n\n} \n\nreturn\njumps[n-\n1\n]; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\n\nSystem.out.println(\n\"Minimum number of jumps to reach end is : \"\n+ \n\nminJumps(arr,arr.length)); \n\n} \n}", "index": 526, "complexity": "3"}
{"back-translation": "public class DoggoRecoloring {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tString s = nextString();\n\t\tboolean b = false;\n\t\t\n\t\tif (n == 1 || n > 26) {\n\t\t\tb = true;\n\t\t} else {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (s.charAt(i) == s.charAt(j)) {\n\t\t\t\t\t\tb = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(b ? \"Yes\" : \"No\");\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class DoggoRecoloring {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tString s = nextString();\n\t\tboolean b = false;\n\t\t\n\t\tif (n == 1 || n > 26)\n\t\t\tb = true;\n\t\telse \n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = i+1; j < n; j++)\n\t\t\t\t\tif (s.charAt(i) == s.charAt(j))\n\t\t\t\t\t\t b = true;\n\t\t\n\t\tSystem.out.println(b ? \"Yes\" : \"No\");\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 527, "complexity": "3"}
{"back-translation": "class GFG { static int maxSumIS(int arr[], int n) { int i, j, max = 0; int msis[] = new int[n]; for (i = 0; i < n; i++) msis[i] = arr[i]; for (i = 1; i < n; i++) for (j = 0; j < i; j++) if (arr[i] > arr[j] && msis[i] < msis[j] + arr[i]) msis[i] = msis[j] + arr[i]; for (i = 0; i < n; i++) if (max < msis[i]) max = msis[i]; return max; } public static void main(String args[]) { int arr[] = new int[]{1, 101, 2, 3, 100, 4, 5}; int n = arr.length; System.out.println(\"Sum of maximum sum \" + \"increasing subsequence is \" + maxSumIS(arr, n)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n}", "index": 528, "complexity": "3"}
{"back-translation": "public class SmallestSubArraySum {\n\n    static int smallestSubWithSum(int arr[], int n, int x) {\n        int min_len = n + 1;\n\n        for (int start = 0; start < n; start++) {\n            int curr_sum = arr[start];\n\n            if (curr_sum > x)\n                return 1;\n\n            for (int end = start + 1; end < n; end++) {\n                curr_sum += arr[end];\n\n                if (curr_sum > x && (end - start + 1) < min_len)\n                    min_len = (end - start + 1);\n            }\n        }\n\n        return min_len;\n    }\n\n    public static void main(String[] args) {\n        int arr1[] = {1, 4, 45, 6, 10, 19};\n        int x = 51;\n        int n1 = arr1.length;\n        int res1 = smallestSubWithSum(arr1, n1, x);\n\n        if (res1 == n1 + 1)\n            System.out.println(\"Not Possible\");\n        else\n            System.out.println(res1);\n\n        int arr2[] = {1, 10, 5, 2, 7};\n        int n2 = arr2.length;\n        x = 9;\n        int res2 = smallestSubWithSum(arr2, n2, x);\n\n        if (res2 == n2 + 1)\n            System.out.println(\"Not Possible\");\n        else\n            System.out.println(res2);\n\n        int arr3[] = {1, 11, 100, 1, 0, 200, 3, 2, 1, 250};\n        int n3 = arr3.length;\n        x = 280;\n        int res3 = smallestSubWithSum(arr3, n3, x);\n\n        if (res3 == n3 + 1)\n            System.out.println(\"Not Possible\");\n        else\n            System.out.println(res3);\n    }\n}", "src": "class\nSmallestSubArraySum \n{ \n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\nmin_len = n + \n1\n; \n\n\n\n\nfor\n(\nint\nstart = \n0\n; start < n; start++) \n\n{ \n\n\n\nint\ncurr_sum = arr[start]; \n\n\n\n\nif\n(curr_sum > x) \n\nreturn\n1\n; \n\n\n\n\nfor\n(\nint\nend = start + \n1\n; end < n; end++) \n\n{ \n\n\n\ncurr_sum += arr[end]; \n\n\n\n\n\n\n\n\nif\n(curr_sum > x && (end - start + \n1\n) < min_len) \n\nmin_len = (end - start + \n1\n); \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n}", "index": 529, "complexity": "3"}
{"back-translation": "public class DivideCandies {\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tlong n = input.nextLong();\n\t\tint m = input.nextInt();\n\t\tlong[] a = new long[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (i <= (n % m) && i != 0) {\n\t\t\t\ta[i] = n / m + 1;\n\t\t\t} else {\n\t\t\t\ta[i] = n / m;\n\t\t\t}\n\t\t}\n\t\tlong result = 0L;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif ((i * i + j * j) % m == 0) {\n\t\t\t\t\tresult += a[i] * a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}", "src": "public class DivideCandies {\n\tpublic static void main(String[] args){\n\t\tScanner input = new Scanner(System.in);\n\t\tlong n = input.nextLong();\n\t\tint m = input.nextInt();\n\t\tlong[] a = new long[m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tif(i <= (n%m) && i != 0)\n\t\t\t{\n\t\t\t\ta[i] = n/m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[i] = n/m;\n\t\t\t}\n\t\t}\n\t\tlong result = 0L;\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif((i * i + j * j) % m == 0)\n\t\t\t\t{\n\t\t\t\t\tresult += a[i] * a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}", "index": 530, "complexity": "3"}
{"back-translation": "public class Solution {\n\n    public static void main(String[] args) {\n    Scanner sc =new Scanner(System.in);\n    int n= sc.nextInt();\n    int[] li=new int[n];\n    for(int i = 0 ;i<n;i++){\n    li[i]=sc.nextInt();\n    }\n    int max=0;\n     int c=0;\n    for(int i = 0;i<n;i++){\n       c=0;\n        for(int j=i;j<n;j++){\n            if(j!=n-1&&j!=0&&li[j]-li[j-1]==1&&li[j+1]-li[j]==1){\n                c++;\n                i++;\n            }\n            else if(j!=n-1&&j==0&&li[j+1]-li[j]==1&&li[j]==1){\n                c++;\n                i++;\n            }\n            else if(j==n-1&&j!=0&&li[j]-li[j-1]==1&&li[j]==1000){\n                c++;\n                i++;\n            }\n            else{ break;}\n        }\n        if(c>max){\n            max=c;\n        }\n    }\n    if(c>max){\n            max=c;\n        }\n    System.out.println(max);\n\n\n    }\n\n}", "src": ";\npublic class JavaApplication2 {\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n= sc.nextInt();\n        int li[]=new int[n];\n        for(int i = 0 ;i<n;i++){\n            li[i]=sc.nextInt();\n        }\n        int max=0;\n         int c=0;\n        for(int i = 0;i<n;i++){\n           c=0;\n            for(int j=i;j<n;j++){\n                if(j!=n-1&&j!=0&&li[j]-li[j-1]==1&&li[j+1]-li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j!=n-1&&j==0&&li[j+1]-li[j]==1&&li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j==n-1&&j!=0&&li[j]-li[j-1]==1&&li[j]==1000){\n                    c++;\n                    i++;\n                }\n                else{ break;}\n            }\n            if(c>max){\n                max=c;\n            }\n        }\n        if(c>max){\n                max=c;\n            }\n        System.out.println(max);\n        \n       \n    }\n    \n}", "index": 531, "complexity": "3"}
{"back-translation": "public class Amain {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[] = new int[100005];\n\t\tint vis[] = new int[100005];\n\t\tint maxx = -1;\n\t\tint n , k ;\n\t\tint e = 0  , s = 0 ;\n\t\tint ans = 0  ;\n\t\t\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\n\t\tfor(int i = 1 ; i<=n ; i++ )\n\t\t{\n\t\t\ta[i]=sc.nextInt() ;\n\t\t\tif(a[i]== 1 )\n\t\t\t{\n\t\t\t\te++ ; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts++ ;\n\t\t\t}\n\t\t}\n\t    \n\t\tfor(int i = 1 ; i<=k  ;i++ )\n\t\t{\n\t\t\tint e1 = 0 ; \n\t\t\tint s1 = 0 ;  \n\t\t\tfor(int j = i ; j<=n ;j+=k )\n\t\t\t{\n\t\t\t\tif(a[j]==1 )\n\t\t\t\t{\n\t\t\t\t\te1++ ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1++ ;\n\t\t\t\t}\n\t\t\t}\n\t        \n\t \n\t\t\tans = Math.abs( (s-s1)-(e-e1)) ; \n\t\t\tmaxx = Math.max(maxx,ans) ; \n\t\tSystem.out.print(maxx);\n\t\t}\n\t}\n\n}", "src": "public class Amain {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[] = new int[100005];\n\t\tint vis[] = new int[100005];\n\t\tint maxx = -1;\n\t\tint n , k ;\n\t\tint e = 0  , s = 0 ;\n\t\tint ans = 0  ;\n\t\t\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\n\t\tfor(int i = 1 ; i<=n ; i++ )\n\t\t{\n\t\t\ta[i]=sc.nextInt() ;\n\t\t\tif(a[i]== 1 )\n\t\t\t{\n\t\t\t\te++ ; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts++ ;\n\t\t\t}\n\t\t}\n\t    \n\t\tfor(int i = 1 ; i<=k  ;i++ )\n\t\t{\n\t\t\tint e1 = 0 ; \n\t\t\tint s1 = 0 ;  \n\t\t\tfor(int j = i ; j<=n ;j+=k )\n\t\t\t{\n\t\t\t\tif(a[j]==1 )\n\t\t\t\t{\n\t\t\t\t\te1++ ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1++ ;\n\t\t\t\t}\n\t\t\t}\n\t        \n\t        \n\t \n\t\t\tans = Math.abs(  (s-s1)-(e-e1)) ; \n\t\t\tmaxx = Math.max(maxx,ans) ; \n\t\t}\n       System.out.print(maxx);\n\t}\n\n}", "index": 532, "complexity": "3"}
{"back-translation": "class Main {static class en implements Comparable<en>{int w,h,dex;en(int a,int b,int c){w=a;h=b;dex=c;}public int compareTo(en o) {return w-o.w;}}public static void main(String args[]) {Scanner cin=new Scanner(System.in);int n=cin.nextInt(),ww=cin.nextInt(),hh=cin.nextInt(),num=0;Queue<en> que=new PriorityQueue();for(int i=1;i<=n;i++) {int a=cin.nextInt(),b=cin.nextInt();if(a>ww&&b>hh) {que.add(new en(a,b,i));num++;}}int dp[][]=new int[num+5][2],ans=0,ad=0,arr[][]=new int[num+5][3];for(int i=1;i<=num;i++) {arr[i][0]=que.peek().w;arr[i][1]=que.peek().h;arr[i][2]=que.remove().dex;}for(int i=1;i<=num;i++) {int te=0,td=0;for(int j=1;j<i;j++) {if(arr[j][0]<arr[i][0]&&arr[j][1]<arr[i][1]&&dp[j][0]>te) {te=dp[j][0];td=j;}}dp[i][0]=te+1;dp[i][1]=td;if(dp[i][0]>ans) {ans=dp[i][0];ad=i;}}System.out.println(ans);ArrayList<Integer> an=new ArrayList();int u=ad;while(u>0) {an.add(arr[u][2]);u=dp[u][1];}for(int i=an.size()-1;i>=0;i--) System.out.print(an.get(i)+\" \");}}", "src": "public class Main {\n\tstatic class en implements Comparable<en>{\n\t\tint w,h,dex;\n\t\ten(int a,int b,int c){\n\t\t\tw=a;\n\t\t\th=b;\n\t\t\tdex=c;\n\t\t}\n\t\tpublic int compareTo(en o) {\n\t\t\treturn w-o.w;\n\t\t}\n\t}\n\tpublic static void main(String args[]) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tint n=cin.nextInt(),ww=cin.nextInt(),hh=cin.nextInt(),num=0;\n\t\tQueue<en> que=new PriorityQueue();\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint a=cin.nextInt(),b=cin.nextInt();\n\t\t\tif(a>ww&&b>hh) {\n\t\t\t\tque.add(new en(a,b,i));\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tint dp[][]=new int[num+5][2],ans=0,ad=0,arr[][]=new int[num+5][3];\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tarr[i][0]=que.peek().w;\n\t\t\tarr[i][1]=que.peek().h;\n\t\t\tarr[i][2]=que.remove().dex;\n\t\t}\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tint te=0,td=0;\n\t\t\tfor(int j=1;j<i;j++) {\n\t\t\t\tif(arr[j][0]<arr[i][0]&&arr[j][1]<arr[i][1]&&dp[j][0]>te) {\n\t\t\t\t\tte=dp[j][0];\n\t\t\t\t\ttd=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][0]=te+1;\n\t\t\tdp[i][1]=td;\n\t\t\tif(dp[i][0]>ans) {\n\t\t\t\tans=dp[i][0];\n\t\t\t\tad=i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tArrayList<Integer> an=new ArrayList();\n\t\tint u=ad;\n\t\twhile(u>0) {\n\t\t\tan.add(arr[u][2]);\n\t\t\tu=dp[u][1];\n\t\t\t\n\t\t}\n\t\tfor(int i=an.size()-1;i>=0;i--) System.out.print(an.get(i)+\" \");\n\t}\n}", "index": 533, "complexity": "3"}
{"back-translation": "class GFG { static int findMinDiff(int[] arr, int n) { int diff = 2147483647; for (int i = 0; i < n - 1; i++) for (int j = i + 1; j < n; j++) if (Math.abs((arr[i] - arr[j])) < diff) diff = Math.abs((arr[i] - arr[j])); return diff; } public static void main(String[] args) { int arr[] = new int[]{1, 5, 3, 19, 18, 25}; System.out.println(\"Minimum difference is \" + findMinDiff(arr, arr.length)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nfindMinDiff(\nint\n[] arr, \nint\nn) \n\n{ \n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\nfor\n(\nint\nj=i+\n1\n; j<n; j++) \n\nif\n(Math.abs((arr[i] - arr[j]) )< diff) \n\ndiff = Math.abs((arr[i] - arr[j])); \n\n\n\n\nreturn\ndiff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n5\n, \n3\n, \n19\n, \n18\n, \n25\n}; \n\nSystem.out.println(\n\"Minimum difference is \"\n+ \n\nfindMinDiff(arr, arr.length)); \n\n\n} \n}", "index": 534, "complexity": "3"}
{"back-translation": "class Test { static int arr1[] = new int[]{0, 1, 0, 1, 1, 1, 1}; static int arr2[] = new int[]{1, 1, 1, 1, 1, 0, 1}; static int longestCommonSum(int n) { int maxLen = 0; for (int i = 0; i < n; i++) { int sum1 = 0, sum2 = 0; for (int j = i; j < n; j++) { sum1 += arr1[j]; sum2 += arr2[j]; if (sum1 == sum2) { int len = j - i + 1; if (len > maxLen) maxLen = len; } } } return maxLen; } public static void main(String[] args) { System.out.print(\"Length of the longest common span with same sum is \"); System.out.println(longestCommonSum(arr1.length)); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n0\n, \n1\n, \n0\n, \n1\n, \n1\n, \n1\n, \n1\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n1\n}; \n\n\n\n\n\n\nstatic\nint\nlongestCommonSum(\nint\nn) \n\n{ \n\n\n\nint\nmaxLen = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\nint\nsum1 = \n0\n, sum2 = \n0\n; \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\n\n\nsum1 += arr1[j]; \n\nsum2 += arr2[j]; \n\n\n\n\n\n\nif\n(sum1 == sum2) \n\n{ \n\nint\nlen = j-i+\n1\n; \n\nif\n(len > maxLen) \n\nmaxLen = len; \n\n} \n\n} \n\n} \n\nreturn\nmaxLen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print(\n\"Length of the longest common span with same sum is \"\n); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n}", "index": 535, "complexity": "3"}
{"back-translation": "public class Codechef {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        Set<HashSet> s3 = new HashSet<>();\n\n        for (int j = 0; j < n; j++) {\n            String a = sc.next();\n            HashSet<Character> t = new HashSet<Character>();\n            for (char c : a.toCharArray()) {\n                t.add(c);\n            }\n\n            s3.add(t);\n        }\n        System.out.println(s3.size());\n    }\n}", "src": "public class Codechef{\n      \n\n    public static void main(String []args){\n       Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n\t\tSet<HashSet> s3 = new HashSet<>();\n\n      \n         for(int j=0;j<n;j++){\n         \tString a=sc.next();\n         HashSet<Character> t = new HashSet<Character>();\n\t\t\tfor(char c:a.toCharArray()){\n\t\t\tt.add(c);\n\t\t\t}\n\n        s3.add(t);\n    \n          \n\n         }\n         System.out.println(s3.size());\n    }\n}", "index": 536, "complexity": "3"}
{"back-translation": "public class Main {\n    static int mod = (int) (1e9+7);\n    static InputReader in;\n    static PrintWriter out;\n      \n        public static int n;\n        public static int m;\n      \n        public static boolean valid(int i , int j) {\n            \n            return (i < n && j < m && i >= 0 && j >= 0);\n        }\n        \n   \n    public static void main(String args[] )  {\n            \n          in = new InputReader(System.in);\n          out = new PrintWriter(System.out);\n         \n         n = in.nextInt();\n         m = in.nextInt();\n        \n         String[] s = new String[n];\n         for(int i=0;i<n;i++) {\n            s[i]= in.readString();\n        }\n        int f=0;\n        for(int i=0;i<n;i++) {\n            for(int j=0;j<s[i].length();j++) {\n                int val=-1;\n                if(s[i].charAt(j)=='.' && s[i].charAt(j)!='*') {\n                    val=0;\n                }\n                else if(s[i].charAt(j)=='*' && s[i].charAt(j)!='.') {\n                    continue;\n                }\n                else {\n                    val = s[i].charAt(j)-'0';\n                }\n                int c=0;\n                if(valid(i-1,j) && s[i-1].charAt(j)=='*' && s[i].charAt(j+1)=='*' && s[i+1].charAt(j+1)=='*'){\n                    c++;\n                }\n                if(valid(i,j-1) && s[i].charAt(j-1)=='*' && s[i-1].charAt(j-1)=='*' && s[i+1].charAt(j-1)=='*'){\n                    c++;\n                }\n                if(valid(i,j+1) && s[i].charAt(j+1)=='*' && s[i-1].charAt(j+1)=='*' && s[i+1].charAt(j+1)=='*'){\n                    c++;\n                }\n                if(c!=val) {\n                    f=1;\n                    break;\n                }\n            }\n        }\n        if(f==0) {\n            out.println(\"YES\");\n        }\n        else {\n            out.println(\"NO\");\n        }\n         \n         out.close();\n    }\n        \n\n        \n        static class InputReader\n        {\n\n            private final InputStream stream;\n            private final byte[] buf = new byte[8192];\n            private int curChar, snumChars;\n            private SpaceCharFilter filter;\n\n            public InputReader(InputStream stream)\n            {\n                    this.stream = stream;\n            }\n\n            public int snext()\n            {\n                    if (snumChars == -1)\n                            throw new InputMismatchException();\n                    if (curChar >= snumChars)\n                    {\n                            curChar = 0;\n                            try\n                            {\n                                    snumChars = stream.read(buf);\n                            } catch (IOException e)\n                            {\n                                    throw new InputMismatchException();\n                            }\n                            if (snumChars <= 0)\n                                    return -1;\n                    }\n                    return buf[curChar++];\n            }\n\n            public int nextInt()\n            {\n                    int c = snext();\n                    while (isSpaceChar(c))\n                    {\n                            c = snext();\n                    }\n                    int sgn = 1;\n                    if (c == '-')\n                    {\n                            sgn = -1;\n                            c = snext();\n                    }\n                    int res = 0;\n                    do\n                    {\n                            if (c < '0' || c > '9')\n                                    throw new InputMismatchException();\n                            res *= 10;\n                            res += c - '0';\n                            c = snext();\n                    } while (!isSpaceChar(c));\n                    return res * sgn;\n            }\n\n            public long nextLong()\n            {\n                    int c = snext();\n                    while (isSpaceChar(c))\n                    {\n                            c = snext();\n                    }\n                    int sgn = 1;\n                    if (c == '-')\n                    {\n                            sgn = -1;\n                            c = snext();\n                    }\n                    long res = 0;\n                    do\n                    {\n                            if (c < '0' || c > '9')\n                                    throw new InputMismatchException();\n                            res *= 10;\n                            res += c - '0';\n                            c = snext();\n                    } while (!isSpaceChar(c));\n                    return res * sgn;\n            }\n\n            public int[] nextIntArray(int n)\n            {\n                    int a[] = new int[n];\n                    for (int i = 0; i < n; i++)\n                    {\n                            a[i] = nextInt();\n                    }\n                    return a;\n            }\n\n            public long[] nextLongArray(int n)\n            {\n                    long a[] = new long[n];\n                    for (int i = 0; i < n; i++)\n                    {\n                            a[i] = nextLong();\n                    }\n                    return a;\n            }\n\n            public String readString()\n            {\n                    int c = snext();\n                    while (isSpaceChar(c))\n                    {\n                            c = snext();\n                    }\n                    StringBuilder res = new StringBuilder();\n                    do\n                    {\n                            res.appendCodePoint(c);\n                            c = snext();\n                    } while (!isSpaceChar(c));\n                    return res.toString();\n            }\n\n            public String nextLine()\n            {\n                    int c = snext();\n                    while (isSpaceChar(c))\n                            c = snext();\n                    StringBuilder res = new StringBuilder();\n                    do\n                    {\n                            res.appendCodePoint(c);\n                            c = snext();\n                    } while (!isEndOfLine(c));\n                    return res.toString();\n            }\n\n            public boolean isSpaceChar(int c)\n            {\n                    if (filter != null)\n                            return filter.isSpaceChar(c);\n                    return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n            }\n\n            private boolean isEndOfLine(int c)\n            {\n                    return c == '\\n' || c == '\\r' || c == -1;\n            }\n\n            public interface SpaceCharFilter\n            {\n                    public boolean isSpaceChar(int ch);\n            }\n\n        }\n    }", "src": "public class Main {\n\tstatic int mod = (int) (1e9+7);\n\tstatic InputReader in;\n    static PrintWriter out;\n    \n    \t\tpublic static int n;\n    \t\tpublic static int m;\n    \n    \t\tpublic static boolean valid(int i , int j) {\n    \t\t\t\n    \t\t\treturn ( i<n && j<m && i>=0 && j>=0);\n    \t\t}\n    \t\t\n   \n\t\tpublic static void main(String args[] )  {\n\t\t\t\n\t\t  in = new InputReader(System.in);\n\t      out = new PrintWriter(System.out);\n\t     \n\t     n = in.nextInt();\n\t    \t m = in.nextInt();\n\t    \n\t    \tString[] s = new String[n];\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\ts[i]= in.readString();\n\t    \t}\n\t    \tint f=0;\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\tfor(int j=0;j<s[i].length();j++) {\n\t    \t\t\tint val=-1;\n\t    \t\t\tif(s[i].charAt(j)=='.') {\n\t    \t\t\t\tval=0;\n\t    \t\t\t}\n\t    \t\t\telse if(s[i].charAt(j)=='*') {\n\t    \t\t\t\tcontinue;\n\t    \t\t\t}\n\t    \t\t\telse {\n\t    \t\t\t\tval = s[i].charAt(j)-'0';\n\t    \t\t\t}\n\t    \t\t\tint c=0;\n\t    \t\t\tif(valid(i-1,j) && s[i-1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j-1) && s[i-1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j+1) && s[i-1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j-1) && s[i].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j+1) && s[i].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j) && s[i+1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j+1) && s[i+1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j-1) && s[i+1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(c!=val) {\n\t    \t\t\t\tf=1;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    \tif(f==0) {\n\t    \t\tout.println(\"YES\");\n\t    \t}\n\t    \telse {\n\t    \t\tout.println(\"NO\");\n\t    \t}\n\t     \n\t     \n\t     out.close();\n\t\t}\n\t\t\n\n\t\t\n\t\tstatic class InputReader\n\t    {\n\n\t        private final InputStream stream;\n\t        private final byte[] buf = new byte[8192];\n\t        private int curChar, snumChars;\n\t        private SpaceCharFilter filter;\n\n\t        public InputReader(InputStream stream)\n\t        {\n\t                this.stream = stream;\n\t        }\n\n\t        public int snext()\n\t        {\n\t                if (snumChars == -1)\n\t                        throw new InputMismatchException();\n\t                if (curChar >= snumChars)\n\t                {\n\t                        curChar = 0;\n\t                        try\n\t                        {\n\t                                snumChars = stream.read(buf);\n\t                        } catch (IOException e)\n\t                        {\n\t                                throw new InputMismatchException();\n\t                        }\n\t                        if (snumChars <= 0)\n\t                                return -1;\n\t                }\n\t                return buf[curChar++];\n\t        }\n\n\t        public int nextInt()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                int res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public long nextLong()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                long res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public int[] nextIntArray(int n)\n\t        {\n\t                int a[] = new int[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextInt();\n\t                }\n\t                return a;\n\t        }\n\n\t        public long[] nextLongArray(int n)\n\t        {\n\t                long a[] = new long[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextLong();\n\t                }\n\t                return a;\n\t        }\n\n\t        public String readString()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res.toString();\n\t        }\n\n\t        public String nextLine()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                        c = snext();\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isEndOfLine(c));\n\t                return res.toString();\n\t        }\n\n\t        public boolean isSpaceChar(int c)\n\t        {\n\t                if (filter != null)\n\t                        return filter.isSpaceChar(c);\n\t                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t        }\n\n\t        private boolean isEndOfLine(int c)\n\t        {\n\t                return c == '\\n' || c == '\\r' || c == -1;\n\t        }\n\n\t        public interface SpaceCharFilter\n\t        {\n\t                public boolean isSpaceChar(int ch);\n\t        }\n\n\t    }\n\t\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Pair { \n    int x; \n    int y; \n  \n    \npublic Pair(int x, int y) \n    { \n        this.x = x; \n        this.y = y; \n    } \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass couple implements Comparable<couple>\n{ int x,y;\n  public couple(int m,int f) {\n \t x=m;\n \t y=f;\n  }\n\tpublic int compareTo(couple o) {\n\t\t\n\t\t \n\t\treturn x-o.x;\n\t}  \n}", "index": 537, "complexity": "3"}
{"back-translation": "class Test {\n\nstatic int arr[] = new int[] { 1, 20, 6, 4, 5 };\n\nstatic int getInvCount(int n) {\n\nint inv_count = 0;\n\nint i = 0;\nwhile (i < n - 1) {\n\nint j = i + 1;\nwhile (j < n) {\n\nif (arr[i] > arr[j])\n\ninv_count++;\n\nj++;\n}\ni++;\n}\n\nreturn inv_count;\n}\n\npublic static void main(String[] args) {\n\nSystem.out.println(\"Number of inversions are \" + getInvCount(arr.length));\n}\n}", "src": "class\nTest { \n\nstatic\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\n\nstatic\nint\ngetInvCount(\nint\nn) \n\n{ \n\nint\ninv_count = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\nif\n(arr[i] > arr[j]) \n\ninv_count++; \n\n\nreturn\ninv_count; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Number of inversions are \"\n\n+ getInvCount(arr.length)); \n\n} \n}", "index": 538, "complexity": "3"}
{"back-translation": "class Main { static void minAbsSumPair(int arr[], int arr_size) { int inv_count = 0; int l, r, min_sum, sum, min_l, min_r; if (arr_size < 2) { System.out.println(\"Invalid Input\"); return; } min_l = 0; min_r = 1; min_sum = arr[0] + arr[1]; for (l = 0; l < arr_size - 1; l++) { for (r = l + 1; r < arr_size; r++) { sum = arr[l] + arr[r]; if (Math.abs(min_sum) > Math.abs(sum)) { min_sum = sum; min_l = l; min_r = r; } } } System.out.println(\" The two elements whose \"+ \"sum is minimum are \"+ arr[min_l] + \" and \" + arr[min_r]); } public static void main(String[] args) { int arr[] = { 1, 60, -10, 70, -80, 85 }; minAbsSumPair(arr, 6); } }", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n}", "index": 539, "complexity": "3"}
{"back-translation": "public class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\t\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tvoid run(){\n\t    int q=in.nextInt();\n\t    for(int i=0;i<q;i++){\n\t        out.println(work());\n\t    }\n\t    out.flush();\n\t}\n\tint work() {\n\t\tint n=in.nextInt();\n\t    int k=in.nextInt();\n\t    String str=in.next();\n\t    char[] chs=new char[]{'R','G','B'};\n\t    int c1=0,c2=0,c3=0;\n\t    int ret=99999999;\n\t    for(int i=0,p1=0,p2=1,p3=2;i<n;i++,p1=(p1+1)%3,p2=(p2+1)%3,p3=(p3+1)%3){\n\t        char ch=str.charAt(i);\n\t        if(ch!=chs[p1]){\n\t            c1++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p1-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c1--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c1);\n\t        }\n\t        if(ch!=chs[p2]){\n\t            c2++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p2-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c2--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c2);\n\t        }\n\t        if(ch!=chs[p3]){\n\t            c3++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p3-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c3--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c3);\n\t        }\n\t    }\n\t    return ret;\n\t} \n}", "src": "public class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\t\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tvoid run(){\n\t    int q=in.nextInt();\n\t    for(int i=0;i<q;i++){\n\t        out.println(work());\n\t    }\n\t    out.flush();\n\t}\n\tint work() {\t\t\n\t\tint n=in.nextInt();\n\t    int k=in.nextInt();\n\t    String str=in.next();\n\t    char[] chs=new char[]{'R','G','B'};\n\t    int c1=0,c2=0,c3=0;\n\t    int ret=99999999;\n\t    for(int i=0,p1=0,p2=1,p3=2;i<n;i++,p1=(p1+1)%3,p2=(p2+1)%3,p3=(p3+1)%3){\n\t        char ch=str.charAt(i);\n\t        \n\t        if(ch!=chs[p1]){\n\t            c1++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p1-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c1--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c1);\n\t        }\n\t        \n\t        \n\t        if(ch!=chs[p2]){\n\t            c2++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p2-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c2--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c2);\n\t        }\n\t        \n\t        \n\t        if(ch!=chs[p3]){\n\t            c3++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p3-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c3--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c3);\n\t        }\n\t    } \n\t    return ret;\n\t   \n\t}\n}", "index": 540, "complexity": "3"}
{"back-translation": "ERROR", "src": "public class CodeForces\n{\n\tpublic static void main(String[] args)throws IOException\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\t\n\t\t\n\t\tint t,i,j,n,k,x,y,z,min1,min2,min3,arr1[],arr2[],arr3[];\n\t\tString s;\n\t\tchar[] s1,s2,s3;\n\n\t\tt=sc.nextInt();\n\t\t\n\t\twhile(t-->0)\n\t\t{\n\t\t\tn=sc.nextInt();\n\t\t\tk=sc.nextInt();\n\t\t\ts=sc.next();\n\t\t\ts1=new char[n];\n\t\t\ts2=new char[n];\n\t\t\ts3=new char[n];\n\t\t\t\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(i%3==0)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='R';\n\t\t\t\t\ts2[i]='G';\n\t\t\t\t\ts3[i]='B';\n\t\t\t\t}\n\t\t\t\tif(i%3==1)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='G';\n\t\t\t\t\ts2[i]='B';\n\t\t\t\t\ts3[i]='R';\n\t\t\t\t}\n\t\t\t\tif(i%3==2)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='B';\n\t\t\t\t\ts2[i]='R';\n\t\t\t\t\ts3[i]='G';\n\t\t\t\t}\n\t\t\t}\n\t\t\tarr1=new int[n];\n\t\t\tarr2=new int[n];\n\t\t\tarr3=new int[n];\n\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)!=s1[i])\n\t\t\t\t\tarr1[i]=1;\n\t\t\t\tif(s.charAt(i)!=s2[i])\n\t\t\t\t\tarr2[i]=1;\n\t\t\t\tif(s.charAt(i)!=s3[i])\n\t\t\t\t\tarr3[i]=1;\n\t\t\t}\n\t\t\tfor(i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tarr1[i]=arr1[i]+arr1[i-1];\n\t\t\t\tarr2[i]=arr2[i]+arr2[i-1];\n\t\t\t\tarr3[i]=arr3[i]+arr3[i-1];\n\t\t\t}\n\t\t\t\n\t\t\tmin1=arr1[k-1];\n\t\t\tmin2=arr2[k-1];\n\t\t\tmin3=arr3[k-1];\n\n\t\t\tfor(i=k;i<n;i++)\n\t\t\t{\n\t\t\t\tif(min1>(arr1[i]-arr1[i-k]))\n\t\t\t\t\tmin1=(arr1[i]-arr1[i-k]);\n\t\t\t\tif(min2>(arr2[i]-arr2[i-k]))\n\t\t\t\t\tmin2=(arr2[i]-arr2[i-k]);\n\t\t\t\tif(min3>(arr3[i]-arr3[i-k]))\n\t\t\t\t\tmin3=(arr3[i]-arr3[i-k]);\n\t\t\t}\n\t\t\tSystem.out.println(Math.min(min1,Math.min(min2,min3)));\n\t\t}\n\t}\n}", "index": 541, "complexity": "3"}
{"back-translation": "public class D {\n\n\tpublic static int[][] dp = new int[200005][3];\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tPrintWriter cout = new PrintWriter(System.out);\n\t\t\n\t\tint q = cin.nextInt();\n\t\tint[] a = new int[200005];\n\t\tint n, k;\n\t\twhile (q-- > 0) {\n\t\t\tn = cin.nextInt();\n\t\t\tk = cin.nextInt();\n\t\t\tString chuoi = cin.nextLine();\n\t\t\tchuoi = cin.nextLine();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tchar ch = chuoi.charAt(i-1);\n\t\t\t\tif (ch == 'R') a[i] = 1;\n\t\t\t\tif (ch == 'G') a[i] = 2;\n\t\t\t\tif (ch == 'B') a[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tfor (int x = 0; x < 3; x++) {\n\t\t\t\t\tdp[i][x] = dp[i-1][x];\n\t\t\t\t\tif (a[i] != (x + i)%3) dp[i][x]++;\n\t\t\t\t}\n\t\t\t\n\t\t\tint res = 1000000007;\n\t\t\tfor (int i = k; i <= n; i++) \n\t\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\t\tres = Math.min(res, dp[i][x] - dp[i-k][x]);\n\t\t\t\t\t\n\t\t\tcout.println(res);\n\t\t}\n\t\tcout.close();\n\t}\n}", "src": "public class D {\n\n\tpublic static int[][] dp = new int[200005][3];\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tPrintWriter cout = new PrintWriter(System.out);\n\t\t\n\t\tint q = cin.nextInt();\n\t\tint[] a = new int[200005];\n\t\tint n, k;\n\t\twhile (q-- > 0) {\n\t\t\tn = cin.nextInt();\n\t\t\tk = cin.nextInt();\n\t\t\tString chuoi = cin.nextLine();\n\t\t\tchuoi = cin.nextLine();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tchar ch = chuoi.charAt(i-1);\n\t\t\t\tif (ch == 'R') a[i] = 1;\n\t\t\t\tif (ch == 'G') a[i] = 2;\n\t\t\t\tif (ch == 'B') a[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tfor (int x = 0; x < 3; x++) {\n\t\t\t\t\tdp[i][x] = dp[i-1][x];\n\t\t\t\t\tif (a[i] != (x + i)%3) dp[i][x]++;\n\t\t\t\t}\n\t\t\t\n\t\t\tint res = 1000000007;\n\t\t\tfor (int i = k; i <= n; i++) \n\t\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\t\tres = Math.min(res, dp[i][x] - dp[i-k][x]);\n\t\t\t\t\t\n\t\t\tcout.println(res);\n\t\t}\n\t\tcout.close();\n\t}\n}", "index": 542, "complexity": "3"}
{"back-translation": "public class CodeForces {\n\n\tpublic static int difference(String s, String b, int n, int k) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] pre = new int[n];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i >= 1) {\n\t\t\t\tpre[i - 1] = (s.charAt(i-1) == b.charAt(i-1) ? 0 : 1);\n\t\t\t}\n\t\t\tpre[i] = pre[i - 1] + (s.charAt(i) == b.charAt(i) ? 0 : 1);\n\t\t}\n\t\tint v = 0;\n\t\tfor (int i = k; i <= n; i++) {\n\t\t\tmin = Math.min(min, pre[i - 1] - (v == 0 ? 0 : pre[v]));\n\t\t\tv++;\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint t = sc.nextInt();\n\t\tO: while (t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tString s = sc.nextLine();\n\t\t\tint c = 1;\n\t\t\tStringBuilder R = new StringBuilder();\n\t\t\tStringBuilder G = new StringBuilder();\n\t\t\tStringBuilder B = new StringBuilder();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (c % 3 == 1) {\n\t\t\t\t\tR.append(", "src": "public class CodeForces {\n\n\tpublic static int difference(String s, String b, int n, int k) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] pre = new int[n];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (i == 1) {\n\t\t\t\tpre[i - 1] = (s.charAt(i-1) == b.charAt(i-1) ? 0 : 1);\n\t\t\t}\n\t\t\tpre[i] = pre[i - 1] + (s.charAt(i) == b.charAt(i) ? 0 : 1);\n\t\t}\n\t\tint v = -1;\n\t\tfor (int i = k - 1; i < n; i++) {\n\t\t\tmin = Math.min(min, pre[i] - (v == -1 ? 0 : pre[v]));\n\t\t\tv++;\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint t = sc.nextInt();\n\t\tO: while (t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tString s = sc.nextLine();\n\t\t\tint c = 1;\n\t\t\tStringBuilder R = new StringBuilder();\n\t\t\tStringBuilder G = new StringBuilder();\n\t\t\tStringBuilder B = new StringBuilder();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (c % 3 == 1) {\n\t\t\t\t\tR.append(\"R\") ;\n\t\t\t\t\tG.append(\"G\");\n\t\t\t\t\tB.append(\"B\");\n\t\t\t\t} else if (c % 3 == 2) {\n\t\t\t\t\tR.append(\"G\");\n\t\t\t\t\tG.append(\"B\");\n\t\t\t\t\tB.append(\"R\");\n\t\t\t\t} else {\n\t\t\t\t\tR.append(\"B\");\n\t\t\t\t\tG.append(\"R\");\n\t\t\t\t\tB.append(\"G\");\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tString RR = R.toString(),BB = B.toString() , GG = G.toString();\n\t\t\tString[] arr = new String[] { RR, BB, GG };\n\t\t\tint i = 0;\n\t\t\tint j = k;\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\twhile (i < 3) {\n\t\t\t\tmin = Math.min(min, difference(s, arr[i], n, k));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tpw.println(min);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic class SegmentTree {\n\t\tstatic int[] S, in;\n\t\tstatic int N;\n\n\t\tpublic SegmentTree(int[] arr) {\n\t\t\tin = arr;\n\t\t\tN = in.length - 1;\n\t\t\tS = new int[N << 1];\n\t\t\tbuild(1, 1, N);\n\t\t}\n\n\t\tstatic int stat;\n\n\t\tvoid build(int node, int b, int e) {\n\t\t\tif (b == e) {\n\t\t\t\tS[node] = in[b];\n\t\t\t\tstat = 1;\n\t\t\t} else {\n\t\t\t\tint mid = (b + e) / 2;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[node] = S[node << 1] | S[node << 1 | 1];\n\n\t\t\t\t} else {\n\t\t\t\t\tS[node] = S[node << 1] ^ S[node << 1 | 1];\n\t\t\t\t}\n\t\t\t\tstat = 1 - stat;\n\t\t\t}\n\t\t}\n\n\t\tint update(int idx, int val) {\n\t\t\tidx += (N - 1);\n\n\t\t\tS[idx] = val;\n\t\t\tint stat = 1;\n\t\t\twhile (idx > 1) {\n\t\t\t\tidx >>= 1;\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[idx] = S[idx << 1] | S[idx << 1 | 1];\n\t\t\t\t\tstat = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS[idx] = S[idx << 1] ^ S[idx << 1 | 1];\n\t\t\t\t\tstat = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn S[1];\n\t\t}\n\n\t}\n\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint a, b;\n\n\t\tpublic Pair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic int compareTo(Pair A) {\n\t\t\tif (a != A.a)\n\t\t\t\treturn A.a - a;\n\t\t\treturn A.b - b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader r) {\n\t\t\tbr = new BufferedReader(r);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "index": 543, "complexity": "3"}
{"back-translation": "class GFG { static void findTriplets(int arr[], int n) { boolean found = false; Arrays.sort(arr); for (int i = 0; i < n - 1; i++) { int l = i + 1; int r = n - 1; int x = arr[i]; while (l < r) { if (x + arr[l] + arr[r] == 0) { System.out.print(x + \" \"); System.out.print(arr[l]+ \" \"); System.out.println(arr[r]+ \" \"); l++; r--; found = true; } else if (x + arr[l] + arr[r] < 0) l++; else r--; } } if (found == false) System.out.println(\" No Triplet Found\"); } public static void main (String[] args) { int arr[] = {0, -1, 2, -3, 1}; int n = arr.length; findTriplets(arr, n); } }", "src": "class\nGFG { \n\n\nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n{ \n\nboolean\nfound = \nfalse\n; \n\n\n\n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\n\n\nint\nl = i + \n1\n; \n\nint\nr = n - \n1\n; \n\nint\nx = arr[i]; \n\nwhile\n(l < r) \n\n{ \n\nif\n(x + arr[l] + arr[r] == \n0\n) \n\n{ \n\n\n\nSystem.out.print(x + \n\" \"\n); \n\nSystem.out.print(arr[l]+ \n\" \"\n); \n\nSystem.out.println(arr[r]+ \n\" \"\n); \n\n\nl++; \n\nr--; \n\nfound = \ntrue\n; \n\n} \n\n\n\n\n\n\nelse\nif\n(x + arr[l] + arr[r] < \n0\n) \n\nl++; \n\n\n\n\n\n\nelse\n\nr--; \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\nSystem.out.println(\n\" No Triplet Found\"\n); \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn =arr.length; \n\nfindTriplets(arr, n); \n\n} \n\n}", "index": 544, "complexity": "3"}
{"back-translation": "class GFG {\n\n    static int binomialCoeff(int n, int k) {\n        int C[] = new int[k + 1];\n        C[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = Math.min(i, k); j > 0; j--) {\n                C[j] = C[j] + C[j-1];\n            }\n        }\n        return C[k];\n    }\n\n    public static void main(String[] args) {\n        int n = 5, k = 2;\n        System.out.printf(\"Value of C(%d, %d) is %d \", n, k, binomialCoeff(n, k));\n    }\n}", "src": "class\nGFG { \n\n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[] = \nnew\nint\n[k + \n1\n]; \n\n\n\n\nC[\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = Math.min(i, k); j > \n0\n; j--) \n\nC[j] = C[j] + C[j-\n1\n]; \n\n} \n\nreturn\nC[k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.printf(\n\"Value of C(%d, %d) is %d \"\n\n, n, k, binomialCoeff(n, k)); \n\n} \n}", "index": 545, "complexity": "3"}
{"back-translation": "class GFG { static void printArray(int A[], int size) { for (int i = 0; i < size; i++) System.out.print(A[i] + \" \"); System.out.println(\"\"); } static void reverse(int arr[], int l, int r) { if (l < r) { arr = swap(arr, l, r); reverse(arr, ++l, --r); } } static void merge(int arr[], int l, int m, int r) { int i = l; int j = m + 1; while (i <= m && arr[i] < 0) i++; while (j <= r && arr[j] < 0) j++; reverse(arr, i, m); reverse(arr, m + 1, j - 1); reverse(arr, i, j - 1); } static void RearrangePosNeg(int arr[], int l, int r) { if (l < r) { int m = l + (r - l) / 2; RearrangePosNeg(arr, l, m); RearrangePosNeg(arr, m + 1, r); merge(arr, l, m, r); } } static int[] swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } public static void main(String[] args) { int arr[] = { -12, 11, -13, -5, 6, -7, 5, -3, -6}; int arr_size = arr.length; RearrangePosNeg(arr, 0, arr_size - 1); printArray(arr, arr_size); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nvoid\nprintArray(\nint\nA[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(A[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n; \n\n} \n\n\n\n\nstatic\nvoid\nreverse(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\narr = swap(arr, l, r); \n\nreverse(arr, ++l, --r); \n\n} \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nmerge(\nint\narr[], \nint\nl, \nint\nm, \nint\nr) \n\n{ \n\nint\ni = l; \n\n\nint\nj = m + \n1\n; \n\n\n\nwhile\n(i <= m && arr[i] < \n0\n) \n\ni++; \n\n\n\n\n\nwhile\n(j <= r && arr[j] < \n0\n) \n\nj++; \n\n\n\n\n\n\n\n\n\nreverse(arr, i, m); \n\n\n\n\n\n\nreverse(arr, m + \n1\n, j - \n1\n); \n\n\n\n\nreverse(arr, i, j - \n1\n); \n\n} \n\n\n\n\n\n\nstatic\nvoid\nRearrangePosNeg(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\n\n\n\n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nRearrangePosNeg(arr, l, m); \n\nRearrangePosNeg(arr, m + \n1\n, r); \n\n\nmerge(arr, l, m, r); \n\n} \n\n} \n\nstatic\nint\n[] swap(\nint\n[] arr, \nint\ni, \nint\nj) \n\n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { -\n12\n, \n11\n, -\n13\n, -\n5\n, \n6\n, -\n7\n, \n5\n, -\n3\n, -\n6\n}; \n\nint\narr_size = arr.length; \n\n\nRearrangePosNeg(arr, \n0\n, arr_size - \n1\n); \n\n\nprintArray(arr, arr_size); \n\n} \n}", "index": 546, "complexity": "3"}
{"back-translation": "class GFG {\n    static int minJumps(int arr[], int n) {\n        int[] jumps = new int[n];\n        int min;\n        jumps[n - 1] = 0;\n        for (int i = n - 2; i >= 0; i--) {\n            if (arr[i] == 0)\n                jumps[i] = Integer.MAX_VALUE;\n            else if (arr[i] >= n - i - 1)\n                jumps[i] = 1;\n            else {\n                min = Integer.MAX_VALUE;\n                for (int j = i + 1; j < n && j <= arr[i] + i; j++) {\n                    if (min > jumps[j])\n                        min = jumps[j];\n                }\n                if (min != Integer.MAX_VALUE)\n                    jumps[i] = min + 1;\n                else\n                    jumps[i] = min;\n            }\n        }\n        return jumps[0];\n    }\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 6, 1, 0, 9};\n        int size = arr.length;\n        System.out.println(\"Minimum number of\" + \" jumps to reach end is \" + minJumps(arr, size));\n    }\n}", "src": "class\nGFG \n{ \n\n\nstatic\nint\nminJumps(\nint\narr[], \n\nint\nn) \n{ \n\n\n\n\n\nint\n[] jumps = \nnew\nint\n[n]; \n\nint\nmin; \n\n\n\n\n\n\n\n\n\n\njumps[n - \n1\n] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(arr[i] == \n0\n) \n\njumps[i] = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nelse\nif\n(arr[i] >= n - i - \n1\n) \n\njumps[i] = \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\nmin = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n && \n\nj <= arr[i] + i; j++) \n\n{ \n\nif\n(min > jumps[j]) \n\nmin = jumps[j]; \n\n} \n\n\n\n\nif\n(min != Integer.MAX_VALUE) \n\njumps[i] = min + \n1\n; \n\nelse\n\njumps[i] = min; \n\n\n} \n\n} \n\n\nreturn\njumps[\n0\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\n[] arr = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Minimum number of\"\n+ \n\n\" jumps to reach end is \"\n+ \n\nminJumps(arr, size)); \n\n} \n}", "index": 547, "complexity": "3"}
{"back-translation": "class GFG { static int minJumps(int arr[], int n) { int[] jumps = new int[n]; int min; jumps[n - 1] = 0; for (int i = n - 2; i >= 0; i--) { if (arr[i] == 0) jumps[i] = Integer.MAX_VALUE; else if (arr[i] >= n - i - 1) jumps[i] = 1; else { min = Integer.MAX_VALUE; for (int j = i + 1; j < n && j <= arr[i] + i; j++) { if (min > jumps[j]) min = jumps[j]; } if (min != Integer.MAX_VALUE) jumps[i] = min + 1; else jumps[i] = min; } } return jumps[0]; } public static void main(String[] args) { int[] arr = {1, 3, 6, 1, 0, 9}; int size = arr.length; System.out.println(\"Minimum number of\"+ \" jumps to reach end is \"+ minJumps(arr, size)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nminJumps(\nint\narr[], \n\nint\nn) \n{ \n\n\n\n\n\nint\n[] jumps = \nnew\nint\n[n]; \n\nint\nmin; \n\n\n\n\n\n\n\n\n\n\njumps[n - \n1\n] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(arr[i] == \n0\n) \n\njumps[i] = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nelse\nif\n(arr[i] >= n - i - \n1\n) \n\njumps[i] = \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\nmin = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n && \n\nj <= arr[i] + i; j++) \n\n{ \n\nif\n(min > jumps[j]) \n\nmin = jumps[j]; \n\n} \n\n\n\n\nif\n(min != Integer.MAX_VALUE) \n\njumps[i] = min + \n1\n; \n\nelse\n\njumps[i] = min; \n\n\n} \n\n} \n\n\nreturn\njumps[\n0\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\n[] arr = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Minimum number of\"\n+ \n\n\" jumps to reach end is \"\n+ \n\nminJumps(arr, size)); \n\n} \n}", "index": 548, "complexity": "3"}
{"back-translation": "public class Solution {\n\n    static void rearrangeArr(int arr[], int n) {\n\n        int evenPos = n / 2;\n\n        int oddPos = n - evenPos;\n\n        int[] tempArr = new int[n];\n\n\n\n        for (int i = 0; i < n; i++)\n\n            tempArr[i] = arr[i];\n\n\n        Arrays.sort(tempArr);\n\n\n        int j = oddPos - 1;\n\n\n\n\n\n        for (int i = 0; i < n; i += 2) {\n\n            arr[i] = tempArr[j];\n\n            j--;\n\n        }\n\n\n        j = oddPos;\n\n\n\n\n\n        for (int i = 1; i < n; i += 2) {\n\n            arr[i] = tempArr[j];\n\n            j++;\n\n        }\n\n\n\n        for (int i = 0; i < n; i++)\n\n            System.out.print(arr[i] + \" \");\n\n    }\n\n\n    public static void main(String argc[]) {\n\n        int[] arr = new int[]{1, 2, 3, 4, 5, 6, 7};\n\n        int size = 7;\n\n        rearrangeArr(arr, size);\n\n    }\n}", "src": "public\nclass\nGfG{ \n\n\n\npublic\nstatic\nvoid\nrearrangeArr(\nint\narr[], \n\nint\nn) \n\n{ \n\n\n\nint\nevenPos = n / \n2\n; \n\n\n\n\nint\noddPos = n - evenPos; \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ntempArr[i] = arr[i]; \n\n\n\n\nArrays.sort(tempArr); \n\n\nint\nj = oddPos - \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj--; \n\n} \n\n\nj = oddPos; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj++; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\nint\n[] arr = \nnew\nint\n[]{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n\n6\n, \n7\n}; \n\nint\nsize = \n7\n; \n\nrearrangeArr(arr, size); \n\n\n} \n}", "index": 549, "complexity": "5"}
{"back-translation": "public class Ladder {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int problems = sc.nextInt();\n        for (int i = 0; i < problems; i++) {\n            int numPlanks = sc.nextInt();\n            solve(numPlanks, sc);\n        }\n    }\n\n    public static void solve(int numPlanks, Scanner sc) {\n        int answer;\n        List<Integer> planks = new ArrayList<>();\n        for (int i = 0; i < numPlanks; i++) {\n            planks.add(sc.nextInt());\n        }\n        Collections.sort(planks);\n        planks.remove(numPlanks - 1);\n        planks.add(planks.get(numPlanks - 2));\n        int base = planks.get(numPlanks - 1) - 1;\n        if ((numPlanks - 2) > base) {\n            answer = base;\n        } else {\n            answer = numPlanks - 2;\n        }\n        if (base == 0) {\n            answer = 0;\n        }\n        System.out.println(answer);\n    }\n}", "src": "public class ladder {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int problems = sc.nextInt();\n        for (int i = 0; i < problems; i++) {\n            int numPlanks = sc.nextInt();\n            solve(numPlanks, sc);\n        }\n\n\n\n\n\n    }\n    public static void solve(int numPlanks, Scanner sc) {\n        int answer;\n        ArrayList<Integer> planks  = new ArrayList<>();\n        for (int i = 0; i < numPlanks; i++) {\n            planks.add(sc.nextInt());\n        }\n\n        Collections.sort(planks);\n\n        planks.remove(numPlanks - 1);\n        planks.add(planks.get(numPlanks - 2));\n        int base = planks.get(numPlanks - 1) - 1;\n        if ((numPlanks - 2) > base) {\n            answer = base;\n        }\n        else {\n            answer = numPlanks - 2;\n        }\n        if (base == 0) {\n            answer = 0;\n        }\n        System.out.println(answer);\n    }\n}", "index": 550, "complexity": "5"}
{"back-translation": "public class Main {\n    static void merge(int arr[], int l, int m, int r) {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n        for (int i = 0; i < n1; ++i) L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j) R[j] = arr[m + 1 + j];\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n    static void sort(int arr[], int l, int r) {\n        if (l < r) {\n            int m = (l + r) / 2;\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n            merge(arr, l, m, r);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int q = sc.nextInt();\n        while (q > 0) {\n            int n = sc.nextInt();\n            int a[] = new int[n];\n            int i = 0;\n            for (i = 0; i < n; i++) a[i] = sc.nextInt();\n            sort(a, 0, n - 1);\n            int p = a[n - 2] - 1;\n            if (n - 2 >= p) System.out.println(p);\n            else if (n - 2 == 0) System.out.println(0);\n            else System.out.println(n - 2);\n            q--;\n        }\n    }\n}", "src": "public class Main\n{\n    \n     static void merge(int arr[], int l, int m, int r) \n    { \n        \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        \n  \n        \n        int i = 0, j = 0; \n  \n        \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        \n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    \n    \n    static void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            \n            int m = (l+r)/2; \n  \n            \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            \n            merge(arr, l, m, r); \n        } \n    } \n  \n    public static void main(String args[]) throws Exception\n    {\n        Scanner sc=new Scanner(System.in);\n        int q=sc.nextInt();\n        while(q>0)\n        {\n            \n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int i=0;\n            for(i=0;i<n;i++)\n                a[i]=sc.nextInt();\n           sort(a,0,n-1);\n           int p=a[n-2]-1;\n            if(n-2>=p)\n                System.out.println(p);\n            else if (n-2==0)\n            System.out.println(0);\n            else \n                System.out.println(n-2);\n            q--;\n        }\n        \n    }\n        \n    }", "index": 551, "complexity": "5"}
{"back-translation": "public class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        long[] a = new long[n];\n        for(int i=0;i<n;i++) a[i] = Long.parseLong(st.nextToken());\n        Queue<Long> ts = new PriorityQueue<Long>();\n        for(int i=1;i<n;i++) ts.add(a[i]-a[i-1]);\n        long sum = 0;\n        for(int i=0;i<n-k;i++){\n            sum += ts.poll();\n        }\n        System.out.println(sum);\n    }\n}", "src": "public class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        long[] a = new long[n];\n        for(int i=0;i<n;i++) a[i] = Long.parseLong(st.nextToken());\n        Queue<Long> ts = new PriorityQueue<Long>();\n        for(int i=1;i<n;i++) ts.add(a[i]-a[i-1]);\n        long sum = 0;\n        for(int i=0;i<n-k;i++){\n            sum += ts.poll();\n        }\n        System.out.println(sum);\n    }\n}", "index": 552, "complexity": "5"}
{"back-translation": "public final class Cf {\n    public static void main(String[] args) {\n        FastReader ob = new FastReader();\n\n        {\n            int n = ob.nextInt();\n            int k = ob.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = ob.nextInt();\n            int x = a[n - 1] - a[0];\n            ArrayList<Integer> b = new ArrayList<>();\n            for (int i = 0; i < n - 1; i++)\n                b.add(-a[i + 1] + a[i]);\n            Collections.sort(b);\n            for (int i = 0; i < k - 1; i++)\n                x += b.get(i);\n            System.out.println(x);\n        }\n    }\n}\n\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    public String nextLine() {\n        String s = \"\";\n        try {\n            s = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}", "src": "public final class Cf\n{\n    public static void main(String[]args)\n    {\n        FastReader ob=new FastReader();\n        \n        \n        {\n            int n=ob.nextInt();\n            int k=ob.nextInt();\n            int a[]=new int[n];\n            for(int i=0;i<n;i++)\n            a[i]=ob.nextInt();\n            int x=a[n-1]-a[0];\n            ArrayList<Integer> b=new ArrayList<>();\n            for(int i=0;i<n-1;i++)\n            b.add(-a[i+1]+a[i]);\n            Collections.sort(b);\n            for(int i=0;i<k-1;i++)\n            x+=b.get(i);\n            System.out.println(x);\n        }\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextLine()\n    {\n        String s=\"\";\n        try {\n        s=br.readLine();\n        } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        return s;\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}", "index": 553, "complexity": "5"}
{"back-translation": "class GfG { public static int minMaxProduct(int[] arr1, int[] arr2, int n1, int n2) { Arrays.sort(arr1); Arrays.sort(arr2); return arr1[n1 - 1] * arr2[0]; } public static void main(String argc[]) { int[] arr1 = new int[]{ 10, 2, 3, 6, 4, 1 }; int[] arr2 = new int[]{ 5, 1, 4, 2, 6, 9 }; int n1 = 6; int n2 = 6; System.out.println(minMaxProduct(arr1, arr2, n1, n2)); } }", "src": "class\nGfG \n{ \n\n\n\n\n\n\npublic\nstatic\nint\nminMaxProduct(\nint\narr1[], \n\nint\narr2[], \n\nint\nn1, \n\nint\nn2) \n\n{ \n\n\n\n\n\n\n\n\nArrays.sort(arr1); \n\nArrays.sort(arr2); \n\n\n\n\n\n\nreturn\narr1[n1 - \n1\n] * arr2[\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]) \n\n{ \n\nint\n[] arr1= \nnew\nint\n[]{ \n10\n, \n2\n, \n3\n, \n\n6\n, \n4\n, \n1\n}; \n\nint\n[] arr2 = \nnew\nint\n[]{ \n5\n, \n1\n, \n4\n, \n\n2\n, \n6\n, \n9\n}; \n\nint\nn1 = \n6\n; \n\nint\nn2 = \n6\n; \n\nSystem.out.println(minMaxProduct(arr1, \n\narr2, \n\nn1, n2)); \n\n} \n}", "index": 554, "complexity": "5"}
{"back-translation": "class GFG { static int findMaxSubarraySumUtil(int A[], int B[], int n, int m) { int max_so_far = Integer.MIN_VALUE, curr_max = 0; for (int i = 0; i < n; i++) { if (Arrays.binarySearch(B, A[i]) >= 0) { curr_max = 0; continue; } curr_max = Math.max(A[i], curr_max + A[i]); max_so_far = Math.max(max_so_far, curr_max); } return max_so_far; } static void findMaxSubarraySum(int A[], int B[], int n, int m) { Arrays.sort(B); int maxSubarraySum = findMaxSubarraySumUtil(A, B, n, m); if (maxSubarraySum == Integer.MIN_VALUE) { System.out.println(\"Maximum subarray sum cant be found\"); } else { System.out.println(\"The Maximum subarray sum = \" + maxSubarraySum); } } public static void main(String[] args) { int A[] = {3, 4, 5, -4, 6}; int B[] = {1, 8, 5}; int n = A.length; int m = B.length; findMaxSubarraySum(A, B, n, m); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxSubarraySumUtil(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\n\nint\nmax_so_far = Integer.MIN_VALUE, curr_max = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\n\nif\n(Arrays.binarySearch(B, A[i]) >= \n0\n) \n\n{ \n\ncurr_max = \n0\n; \n\ncontinue\n; \n\n} \n\n\n\n\ncurr_max = Math.max(A[i], curr_max + A[i]); \n\nmax_so_far = Math.max(max_so_far, curr_max); \n\n} \n\nreturn\nmax_so_far; \n\n} \n\n\n\n\nstatic\nvoid\nfindMaxSubarraySum(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\nArrays.sort(B); \n\n\nint\nmaxSubarraySum = findMaxSubarraySumUtil(A, B, \n\nn, m); \n\n\n\n\n\n\n\n\nif\n(maxSubarraySum == Integer.MIN_VALUE) \n\n{ \n\nSystem.out.println(\n\"Maximum subarray sum cant be found\"\n); \n\n} \n\nelse\n\n{ \n\nSystem.out.println(\n\"The Maximum subarray sum = \"\n\n+ maxSubarraySum); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = {\n3\n, \n4\n, \n5\n, -\n4\n, \n6\n}; \n\nint\nB[] = {\n1\n, \n8\n, \n5\n}; \n\n\nint\nn = A.length; \n\nint\nm = B.length; \n\n\n\n\nfindMaxSubarraySum(A, B, n, m); \n\n} \n}", "index": 555, "complexity": "5"}
{"back-translation": "class GFG { \n\nstatic int maxTripletSum(int arr[], int n) { \nArrays.sort(arr); \nreturn arr[n - 1] + arr[n - 2] + arr[n - 3]; \n} \n\npublic static void main(String args[]) { \nint arr[] = { 1, 0, 8, 6, 4, 2 }; \nint n = arr.length; \nSystem.out.println(maxTripletSum(arr, n)); \n} \n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxTripletSum(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\nreturn\narr[n - \n1\n] + arr[n - \n2\n] + arr[n - \n3\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n0\n, \n8\n, \n6\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxTripletSum(arr, n)); \n\n} \n}", "index": 556, "complexity": "5"}
{"back-translation": "class GFG { static int maximum(int a, int b, int c) { return Math.max(Math.max(a, b), c); } static int minimum(int a, int b, int c) { return Math.min(Math.min(a, b), c); } static void smallestDifferenceTriplet(int[] arr1, int[] arr2, int[] arr3, int n) { Arrays.sort(arr1); Arrays.sort(arr2); Arrays.sort(arr3); int res_min = 0, res_max = 0, res_mid = 0; int i = 0, j = 0, k = 0; int diff = 2147483647; while (i < n && j < n && k < n) { int sum = arr1[i] + arr2[j] + arr3[k]; int max = maximum(arr1[i], arr2[j], arr3[k]); int min = minimum(arr1[i], arr2[j], arr3[k]); if (min == arr1[i]) i++; else if (min == arr2[j]) j++; else k++; if (diff > (max - min)) { diff = max - min; res_max = max; res_mid = sum - (max + min); res_min = min; } } System.out.print(res_max + \", \" + res_mid + \", \" + res_min); } public static void main(String[] args) { int[] arr1 = {5, 2, 8}; int[] arr2 = {10, 7, 12}; int[] arr3 = {9, 14, 6}; int n = arr1.length; smallestDifferenceTriplet(arr1, arr2, arr3, n); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nmaximum(\nint\na, \nint\nb, \nint\nc) \n\n{ \n\nreturn\nMath.max(Math.max(a, b), c); \n\n} \n\n\n\n\nstatic\nint\nminimum(\nint\na, \nint\nb, \nint\nc) \n\n{ \n\nreturn\nMath.min(Math.min(a, b), c); \n\n} \n\n\n\n\n\n\nstatic\nvoid\nsmallestDifferenceTriplet(\nint\narr1[], \n\nint\narr2[], \nint\narr3[], \nint\nn) \n\n{ \n\n\n\n\nArrays.sort(arr1); \n\nArrays.sort(arr2); \n\nArrays.sort(arr3); \n\n\n\n\nint\nres_min=\n0\n, res_max=\n0\n, res_mid=\n0\n; \n\n\n\n\n\n\nint\ni = \n0\n, j = \n0\n, k = \n0\n; \n\n\n\n\n\n\nint\ndiff = \n2147483647\n; \n\n\nwhile\n(i < n && j < n && k < n) \n\n{ \n\nint\nsum = arr1[i] + arr2[j] + arr3[k]; \n\n\n\n\nint\nmax = maximum(arr1[i], arr2[j], arr3[k]); \n\n\n\n\nint\nmin = minimum(arr1[i], arr2[j], arr3[k]); \n\nif\n(min == arr1[i]) \n\ni++; \n\nelse\nif\n(min == arr2[j]) \n\nj++; \n\nelse\n\nk++; \n\n\n\n\n\n\nif\n(diff > (max - min)) \n\n{ \n\ndiff = max - min; \n\nres_max = max; \n\nres_mid = sum - (max + min); \n\nres_min = min; \n\n} \n\n} \n\n\n\n\nSystem.out.print(res_max + \n\", \"\n+ res_mid \n\n+ \n\", \"\n+ res_min); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\nint\narr1[] = {\n5\n, \n2\n, \n8\n}; \n\nint\narr2[] = {\n10\n, \n7\n, \n12\n}; \n\nint\narr3[] = {\n9\n, \n14\n, \n6\n}; \n\n\nint\nn = arr1.length; \n\n\nsmallestDifferenceTriplet(arr1, arr2, arr3, n); \n\n} \n}", "index": 557, "complexity": "5"}
{"back-translation": "class GFG { static int R = 4, C = 4; static int first(int arr[], int low, int high) { if(high >= low) { int mid = low + (high - low) / 2; if((mid == 0 || (arr[mid - 1] == 0)) && arr[mid] == 1) return mid; else if(arr[mid] == 0) return first(arr, (mid + 1), high); else return first(arr, low, (mid - 1)); } return -1; } static int rowWithMax1s(int mat[][]) { int max_row_index = 0, max = -1; int i, index; for(i = 0; i < R; i++) { index = first(mat[i], 0, C - 1); if(index != -1 && C - index > max) { max = C - index; max_row_index = i; } } return max_row_index ; } public static void main(String[] args) { int mat[][] = { { 0, 0, 0, 1}, { 0, 1, 1, 1}, { 1, 1, 1, 1}, { 0, 0, 0, 0} }; System.out.println(\"Index of row with maximum 1s is \" + rowWithMax1s(mat)); } }", "src": "class\nGFG { \n\nstatic\nint\nR = \n4\n, C = \n4\n; \n\n\n\n\n\nstatic\nint\nfirst(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) { \n\n\n\nint\nmid = low + (high - low) / \n2\n; \n\n\n\n\nif\n((mid == \n0\n|| (arr[mid - \n1\n] == \n0\n)) && arr[mid] == \n1\n) \n\nreturn\nmid; \n\n\n\n\nelse\nif\n(arr[mid] == \n0\n) \n\nreturn\nfirst(arr, (mid + \n1\n), high); \n\n\n\n\nelse\n\nreturn\nfirst(arr, low, (mid - \n1\n)); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\n\nstatic\nint\nrowWithMax1s(\nint\nmat[][]) \n\n{ \n\n\n\nint\nmax_row_index = \n0\n, max = -\n1\n; \n\n\n\n\n\n\nint\ni, index; \n\nfor\n(i = \n0\n; i < R; i++) { \n\nindex = first(mat[i], \n0\n, C - \n1\n); \n\nif\n(index != -\n1\n&& C - index > max) { \n\nmax = C - index; \n\nmax_row_index = i; \n\n} \n\n} \n\n\nreturn\nmax_row_index; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n0\n, \n0\n, \n0\n, \n1\n}, \n\n{ \n0\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n1\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n0\n, \n0\n, \n0\n, \n0\n} }; \n\nSystem.out.println(\n\"Index of row with maximum 1s is \"\n\n+ rowWithMax1s(mat)); \n\n} \n}", "index": 558, "complexity": "5"}
{"back-translation": "public class GFG {\n\nstatic void rearrangeArray(int arr[], int n) {\n\nArrays.sort(arr);\n\nint[] tempArr = new int[n];\n\nint ArrIndex = 0;\n\nfor(int i = 0, j = n-1; i <= n / 2 || j > n / 2; i++, j--) {\n\nif(ArrIndex < n) {\n\ntempArr[ArrIndex] = arr[i];\n\nArrIndex++;\n\n}\n\nif(ArrIndex < n) {\n\ntempArr[ArrIndex] = arr[j];\n\nArrIndex++;\n\n}\n\n}\n\nfor(int i = 0; i < n; i++)\n\narr[i] = tempArr[i];\n\n}\n\npublic static void main(String args[]) {\n\nint arr[] = {5, 8, 1, 4, 2, 9, 3, 7, 6};\n\nint n = arr.length;\n\nrearrangeArray(arr, n);\n\nfor(int i = 0; i < n; i++)\n\nSystem.out.print(arr[i]+\" \");\n\n}\n\n}", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nvoid\nrearrangeArray(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n\n\n\n\n\n\n\nint\nArrIndex = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n, j = n-\n1\n; i <= n / \n2\n|| j > n / \n2\n; \n\ni++, j--) { \n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[i]; \n\nArrIndex++; \n\n} \n\n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[j]; \n\nArrIndex++; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = tempArr[i]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n5\n, \n8\n, \n1\n, \n4\n, \n2\n, \n9\n, \n3\n, \n7\n, \n6\n}; \n\nint\nn = arr.length; \n\nrearrangeArray(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 559, "complexity": "5"}
{"back-translation": "class LinkedList { static Node head; static class Node { int data; Node next, prev; Node(int d) { data = d; next = prev = null; } } void print(Node node) { Node temp = node; System.out.println(\"Forward Traversal using next pointer\"); while (node != null) { System.out.print(node.data + \" \"); temp = node; node = node.next; } System.out.println(\"\\nBackward Traversal using prev pointer\"); while (temp != null) { System.out.print(temp.data + \" \"); temp = temp.prev; } } Node split(Node head) { Node fast = head, slow = head; while (fast.next != null && fast.next.next != null) { fast = fast.next.next; slow = slow.next; } Node temp = slow.next; slow.next = null; return temp; } Node mergeSort(Node node) { if (node == null || node.next == null) { return node; } Node second = split(node); node = mergeSort(node); second = mergeSort(second); return merge(node, second); } Node merge(Node first, Node second) { if (first == null) { return second; } if (second == null) { return first; } if (first.data < second.data) { first.next = merge(first.next, second); first.next.prev = first; first.prev = null; return first; } else { second.next = merge(first, second.next); second.next.prev = second; second.prev = null; return second; } } public static void main(String[] args) { LinkedList list = new LinkedList(); list.head = new Node(10); list.head.next = new Node(30); list.head.next.next = new Node(3); list.head.next.next.next = new Node(4); list.head.next.next.next.next = new Node(20); list.head.next.next.next.next.next = new Node(5); Node node = null; node = list.mergeSort(head); System.out.println(\"Linked list after sorting :\"); list.print(node); } }", "src": "class\nLinkedList { \n\n\nstatic\nNode head; \n\n\n\n\n\nstatic\nclass\nNode { \n\n\nint\ndata; \n\nNode next, prev; \n\n\n\n\nNode(\nint\nd) { \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\nvoid\nprint(Node node) { \n\nNode temp = node; \n\nSystem.out.println(\n\"Forward Traversal using next pointer\"\n); \n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\ntemp = node; \n\nnode = node.next; \n\n} \n\nSystem.out.println(\n\"\\nBackward Traversal using prev pointer\"\n); \n\nwhile\n(temp != \nnull\n) { \n\nSystem.out.print(temp.data + \n\" \"\n); \n\ntemp = temp.prev; \n\n} \n\n} \n\n\n\n\n\n\nNode split(Node head) { \n\nNode fast = head, slow = head; \n\nwhile\n(fast.next != \nnull\n&& fast.next.next != \nnull\n) { \n\nfast = fast.next.next; \n\nslow = slow.next; \n\n} \n\nNode temp = slow.next; \n\nslow.next = \nnull\n; \n\nreturn\ntemp; \n\n} \n\n\nNode mergeSort(Node node) { \n\nif\n(node == \nnull\n|| node.next == \nnull\n) { \n\nreturn\nnode; \n\n} \n\nNode second = split(node); \n\n\n\n\nnode = mergeSort(node); \n\nsecond = mergeSort(second); \n\n\n\n\nreturn\nmerge(node, second); \n\n} \n\n\n\n\nNode merge(Node first, Node second) { \n\n\n\nif\n(first == \nnull\n) { \n\nreturn\nsecond; \n\n} \n\n\n\n\nif\n(second == \nnull\n) { \n\nreturn\nfirst; \n\n} \n\n\n\n\nif\n(first.data < second.data) { \n\nfirst.next = merge(first.next, second); \n\nfirst.next.prev = first; \n\nfirst.prev = \nnull\n; \n\nreturn\nfirst; \n\n} \nelse\n{ \n\nsecond.next = merge(first, second.next); \n\nsecond.next.prev = second; \n\nsecond.prev = \nnull\n; \n\nreturn\nsecond; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nLinkedList list = \nnew\nLinkedList(); \n\nlist.head = \nnew\nNode(\n10\n); \n\nlist.head.next = \nnew\nNode(\n30\n); \n\nlist.head.next.next = \nnew\nNode(\n3\n); \n\nlist.head.next.next.next = \nnew\nNode(\n4\n); \n\nlist.head.next.next.next.next = \nnew\nNode(\n20\n); \n\nlist.head.next.next.next.next.next = \nnew\nNode(\n5\n); \n\n\n\nNode node = \nnull\n; \n\nnode = list.mergeSort(head); \n\nSystem.out.println(\n\"Linked list after sorting :\"\n); \n\nlist.print(node); \n\n\n} \n}", "index": 560, "complexity": "5"}
{"back-translation": "public class GenerateBNo {\n\n    static void generatePrintBinary(int n) {\n\n        Queue<String> q = new LinkedList<String>();\n\n        q.add(\"1\");\n\n        while (n-- > 0) {\n\n            String s1 = q.peek();\n            q.remove();\n            System.out.println(s1);\n\n            String s2 = s1;\n\n            q.add(s1 + \"0\");\n            q.add(s2 + \"1\");\n        }\n    }\n\n    public static void main(String[] args) {\n\n        int n = 10;\n        generatePrintBinary(n);\n    }\n}", "src": "public\nclass\nGenerateBNo \n{ \n\n\n\nstatic\nvoid\ngeneratePrintBinary(\nint\nn) \n\n{ \n\n\n\nQueue<String> q = \nnew\nLinkedList<String>(); \n\n\n\n\nq.add(\n\"1\"\n); \n\n\n\n\n\n\nwhile\n(n-- > \n0\n) \n\n{ \n\n\n\nString s1 = q.peek(); \n\nq.remove(); \n\nSystem.out.println(s1); \n\n\n\n\nString s2 = s1; \n\n\n\n\nq.add(s1 + \n\"0\"\n); \n\n\n\n\n\n\nq.add(s2 + \n\"1\"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn=\n10\n; \n\ngeneratePrintBinary(n); \n\n} \n}", "index": 561, "complexity": "5"}
{"back-translation": "class LIS {\n\n    static int CeilIndex(int A[], int l, int r, int key) {\n        while (r - l > 1) {\n            int m = l + (r - l) / 2;\n            if (A[m] >= key)\n                r = m;\n            else\n                l = m;\n        }\n        return r;\n    }\n\n    static int LongestIncreasingSubsequenceLength(int A[], int size) {\n        int[] tailTable = new int[size];\n        int len;\n        tailTable[0] = A[0];\n        len = 1;\n        for (int i = 1; i < size; i++) {\n            if (A[i] < tailTable[0])\n                tailTable[0] = A[i];\n            else if (A[i] > tailTable[len - 1])\n                tailTable[len++] = A[i];\n            else\n                tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i];\n        }\n        return len;\n    }\n\n    public static void main(String[] args) {\n        int A[] = {2, 5, 3, 7, 11, 8, 10, 13, 6};\n        int n = A.length;\n        System.out.println(\"Length of Longest Increasing Subsequence is \" + LongestIncreasingSubsequenceLength(A, n));\n    }\n}", "src": "class\nLIS { \n\n\n\n\n\nstatic\nint\nCeilIndex(\nint\nA[], \nint\nl, \nint\nr, \nint\nkey) \n\n{ \n\nwhile\n(r - l > \n1\n) { \n\nint\nm = l + (r - l) / \n2\n; \n\nif\n(A[m] >= key) \n\nr = m; \n\nelse\n\nl = m; \n\n} \n\n\nreturn\nr; \n\n} \n\n\nstatic\nint\nLongestIncreasingSubsequenceLength(\nint\nA[], \nint\nsize) \n\n{ \n\n\n\n\nint\n[] tailTable = \nnew\nint\n[size]; \n\nint\nlen; \n\n\n\ntailTable[\n0\n] = A[\n0\n]; \n\nlen = \n1\n; \n\nfor\n(\nint\ni = \n1\n; i < size; i++) { \n\nif\n(A[i] < tailTable[\n0\n]) \n\n\n\ntailTable[\n0\n] = A[i]; \n\n\nelse\nif\n(A[i] > tailTable[len - \n1\n]) \n\n\n\ntailTable[len++] = A[i]; \n\n\nelse\n\n\n\n\n\ntailTable[CeilIndex(tailTable, -\n1\n, len - \n1\n, A[i])] = A[i]; \n\n} \n\n\nreturn\nlen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n2\n, \n5\n, \n3\n, \n7\n, \n11\n, \n8\n, \n10\n, \n13\n, \n6\n}; \n\nint\nn = A.length; \n\nSystem.out.println(\n\"Length of Longest Increasing Subsequence is \"\n+ LongestIncreasingSubsequenceLength(A, n)); \n\n} \n}", "index": 562, "complexity": "5"}
{"back-translation": "class GFG { static int maxSumPairWithDifferenceLessThanK(int arr[], int N, int K) { Arrays.sort(arr); int dp[] = new int[N]; dp[0] = 0; for (int i = 1; < N; i++) { dp[i] = dp[i-1]; if (arr[i] - arr[i-1] < K) { if (i >= 2) dp[i] = Math.max(dp[i], dp[i-2] + arr[i] + arr[i-1]); else dp[i] = Math.max(dp[i], arr[i] + arr[i-1]); } } return dp[N - 1]; } public static void main(String[] args) { int arr[] = { 3, 5, 10, 15, 17, 12, 9 }; int N = arr.length; int K = 4; System.out.println(maxSumPairWithDifferenceLessThanK(arr, N, K)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumPairWithDifferenceLessThanK(\nint\narr[], \n\nint\nN, \nint\nK) \n\n{ \n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\nint\ndp[] = \nnew\nint\n[N]; \n\n\n\n\ndp[\n0\n] = \n0\n; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\n\n\n\n\ndp[i] = dp[i-\n1\n]; \n\n\n\n\nif\n(arr[i] - arr[i-\n1\n] < K) \n\n{ \n\n\n\n\n\n\nif\n(i >= \n2\n) \n\ndp[i] = Math.max(dp[i], dp[i-\n2\n] + arr[i] + \n\narr[i-\n1\n]); \n\nelse\n\ndp[i] = Math.max(dp[i], arr[i] + arr[i-\n1\n]); \n\n} \n\n} \n\n\n\n\nreturn\ndp[N - \n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n3\n, \n5\n, \n10\n, \n15\n, \n17\n, \n12\n, \n9\n}; \n\nint\nN = arr.length; \n\nint\nK = \n4\n; \n\n\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \n\narr, N, K)); \n\n\n} \n}", "index": 563, "complexity": "5"}
{"back-translation": "class GFG { static int maxSumPairWithDifferenceLessThanK(int arr[], int N, int k) { int maxSum = 0; Arrays.sort(arr); for(int i = N-1; i > 0; --i) { if(arr[i] - arr[i-1] < k) { maxSum += arr[i]; maxSum += arr[i-1]; --i; } } return maxSum; } public static void main(String[] args) { int arr[] = {3, 5, 10, 15, 17, 12, 9}; int N = arr.length; int K = 4; System.out.println(maxSumPairWithDifferenceLessThanK(arr, N, K)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumPairWithDifferenceLessThanK(\nint\narr[], \n\nint\nN, \nint\nk) \n\n{ \n\nint\nmaxSum = \n0\n; \n\n\n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = N-\n1\n; i > \n0\n; --i) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(arr[i] - arr[i-\n1\n] < k) \n\n{ \n\n\n\nmaxSum += arr[i]; \n\nmaxSum += arr[i-\n1\n]; \n\n\n\n\n--i; \n\n} \n\n} \n\n\nreturn\nmaxSum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n3\n, \n5\n, \n10\n, \n15\n, \n17\n, \n12\n, \n9\n}; \n\nint\nN = arr.length; \n\nint\nK = \n4\n; \n\n\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \n\narr, N, K)); \n\n} \n}", "index": 564, "complexity": "5"}
{"back-translation": "public class GFG {\n    public static int kthSmallest(Integer[] arr, int k) {\n        Arrays.sort(arr);\n        return arr[k - 1];\n    }\n\n    public static void main(String[] args) {\n        Integer arr[] = new Integer[]{12, 3, 5, 7, 19};\n        int k = 2;\n        System.out.print(\"K'th smallest element is \" + kthSmallest(arr, k));\n    }\n}", "src": "class\nGFG \n{ \n\n\n\n\n\npublic\nstatic\nint\nkthSmallest(Integer [] arr, \n\nint\nk) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\nreturn\narr[k-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[]{\n12\n, \n3\n, \n5\n, \n7\n, \n19\n}; \n\nint\nk = \n2\n; \n\nSystem.out.print( \n\"K'th smallest element is \"\n+ \n\nkthSmallest(arr, k) ); \n\n} \n}", "index": 565, "complexity": "5"}
{"back-translation": "class GFG {\n\nstatic void find_max(int [] A, int N, int K) {\n\nHashMap<Integer, Integer> Count = new HashMap<>();\n\nfor (int i = 0; i < K - 1; i++)\nif (Count.containsKey(A[i]))\nCount.put(A[i], 1 + Count.get(A[i]));\nelse\nCount.put(A[i], 1);\n\nTreeSet<Integer> Myset = new TreeSet<Integer>();\n\nfor (Map.Entry x : Count.entrySet()) {\nif (Integer.parseInt(String.valueOf(x.getValue())) == 1)\nMyset.add(Integer.parseInt(String.valueOf(x.getKey()));\n}\n\nfor (int i = K - 1; i < N; i++) {\nif (Count.containsKey(A[i]))\nCount.put(A[i], 1 + Count.get(A[i]));\nelse\nCount.put(A[i], 1);\n\nif (Integer.parseInt(String.valueOf(Count.get(A[i]))) == 1)\nMyset.add(A[i]);\nelse\nMyset.remove(A[i]);\n\nif (Myset.size() == 0)\nSystem.out.println(\"Nothing\");\nelse\nSystem.out.println(Myset.last());\n\nint x = A[i - K + 1];\nCount.put(x, Count.get(x) - 1);\n\nif (Integer.parseInt(String.valueOf(Count.get(x))) == 1)\nMyset.add(x);\nif (Integer.parseInt(String.valueOf(Count.get(x))) == 0)\nMyset.remove(x);\n}\n}\n\npublic static void main(String args[]) {\n\nint [] a = {1, 2, 2, 3, 3};\nint n = a.length;\nint k = 3;\nfind_max(a, n, k);\n}\n}", "src": "class\nGFG { \n\n\nstatic\nvoid\nfind_max(\nint\n[] A, \nint\nN, \nint\nK) \n\n{ \n\n\n\n\n\nHashMap<Integer, Integer> Count = \nnew\nHashMap<>(); \n\nfor\n(\nint\ni = \n0\n; i < K - \n1\n; i++) \n\nif\n(Count.containsKey(A[i])) \n\nCount.put(A[i], \n1\n+ Count.get(A[i])); \n\nelse\n\nCount.put(A[i], \n1\n); \n\n\nTreeSet<Integer> Myset = \nnew\nTreeSet<Integer>(); \n\nfor\n(Map.Entry x : Count.entrySet()) { \n\nif\n(Integer.parseInt(String.valueOf(x.getValue())) == \n1\n) \n\nMyset.add(Integer.parseInt(String.valueOf(x.getKey()))); \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = K - \n1\n; i < N; i++) { \n\n\n\n\nif\n(Count.containsKey(A[i])) \n\nCount.put(A[i], \n1\n+ Count.get(A[i])); \n\nelse\n\nCount.put(A[i], \n1\n); \n\n\nif\n(Integer.parseInt(String.valueOf(Count.get(A[i]))) == \n1\n) \n\nMyset.add(A[i]); \n\nelse\n\nMyset.remove(A[i]); \n\n\n\n\n\n\nif\n(Myset.size() == \n0\n) \n\nSystem.out.println(\n\"Nothing\"\n); \n\n\n\n\n\n\nelse\n\nSystem.out.println(Myset.last()); \n\n\n\n\n\n\nint\nx = A[i - K + \n1\n]; \n\nCount.put(x, Count.get(x) - \n1\n); \n\n\nif\n(Integer.parseInt(String.valueOf(Count.get(x))) == \n1\n) \n\nMyset.add(x); \n\nif\n(Integer.parseInt(String.valueOf(Count.get(x))) == \n0\n) \n\nMyset.remove(x); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[] a = { \n1\n, \n2\n, \n2\n, \n3\n, \n3\n}; \n\nint\nn = a.length; \n\nint\nk = \n3\n; \n\nfind_max(a, n, k); \n\n} \n}", "index": 566, "complexity": "5"}
{"back-translation": "class GFG {\n\n    static void pairs(int[] arr, int n, int k) {\n        int smallest = Integer.MAX_VALUE;\n        int count = 0;\n\n        for (int i = 0; i < n; i++)\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(arr[i] + arr[j] - k) < smallest) {\n                    smallest = Math.abs(arr[i] + arr[j] - k);\n                    count = 1;\n                } else if (Math.abs(arr[i] + arr[j] - k) == smallest)\n                    count++;\n            }\n\n        System.out.println(\"Minimal Value = \" + smallest);\n        System.out.println(\"Total Pairs = \" + count);\n    }\n\n    public static void main(String[] args) {\n        int arr[] = { 3, 5, 7, 5, 1, 9, 9 };\n        int k = 12;\n        int n = arr.length;\n        pairs(arr, n, k);\n    }\n}", "src": "class\nGFG { \n\n\n\n\nstatic\nvoid\npairs(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nint\nsmallest = Integer.MAX_VALUE; \n\nint\ncount=\n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nfor\n(\nint\nj=i+\n1\n; j<n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n( Math.abs(arr[i] + arr[j] - k) < \n\nsmallest ) \n\n{ \n\nsmallest = Math.abs(arr[i] + arr[j] \n\n- k); \n\ncount = \n1\n; \n\n} \n\n\n\n\n\n\nelse\nif\n(Math.abs(arr[i] + arr[j] - k) \n\n== smallest) \n\ncount++; \n\n} \n\n\n\n\nSystem.out.println(\n\"Minimal Value = \"\n+ \n\nsmallest); \n\nSystem.out.println(\n\"Total Pairs = \"\n+ \n\ncount); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n3\n, \n5\n, \n7\n, \n5\n, \n1\n, \n9\n, \n9\n}; \n\nint\nk = \n12\n; \n\nint\nn = arr.length; \n\npairs(arr, n, k); \n\n} \n}", "index": 567, "complexity": "5"}
{"back-translation": "class ActivitySelection { public static void printMaxActivities(int s[], int f[], int n) { int i, j; System.out.print(\"Following activities are selected : \"); i = 0; System.out.print(i + \" \"); for (j = 1; j < n; j++) { if (s[j] >= f[i]) { System.out.print(j + \" \"); i = j; } } } public static void main(String[] args) { int s[] = {1, 3, 0, 5, 8, 5}; int f[] = {2, 4, 6, 7, 9, 9}; int n = s.length; printMaxActivities(s, f, n); } }", "src": "class\nActivitySelection \n{ \n\n\n\n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nprintMaxActivities(\nint\ns[], \nint\nf[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\nSystem.out.print(\n\"Following activities are selected : n\"\n); \n\n\n\n\ni = \n0\n; \n\nSystem.out.print(i+\n\" \"\n); \n\n\n\n\nfor\n(j = \n1\n; j < n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(s[j] >= f[i]) \n\n{ \n\nSystem.out.print(j+\n\" \"\n); \n\ni = j; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ns[] = {\n1\n, \n3\n, \n0\n, \n5\n, \n8\n, \n5\n}; \n\nint\nf[] = {\n2\n, \n4\n, \n6\n, \n7\n, \n9\n, \n9\n}; \n\nint\nn = s.length; \n\n\nprintMaxActivities(s, f, n); \n\n} \n\n}", "index": 568, "complexity": "5"}
{"back-translation": "class DisjointSet {\n\n    int parent[];\n\n    DisjointSet(int n) {\n        parent = new int[n + 1];\n        for (int i = 0; i <= n; i++)\n            parent[i] = i;\n    }\n\n    int find(int s) {\n        if (s == parent[s])\n            return s;\n        return parent[s] = find(parent[s]);\n    }\n\n    void merge(int u, int v) {\n        parent[v] = u;\n    }\n}\n\nclass Job implements Comparator<Job> {\n\n    char id;\n    int deadline, profit;\n\n    public Job() { }\n\n    public Job(char id, int deadline, int profit) {\n        this.id = id;\n        this.deadline = deadline;\n        this.profit = profit;\n    }\n\n    public static int findMaxDeadline(ArrayList<Job> arr) {\n        int ans = Integer.MIN_VALUE;\n        for (Job temp : arr)\n            ans = Math.max(temp.deadline, ans);\n        return ans;\n    }\n\n    public static void printJobScheduling(ArrayList<Job> arr) {\n\n        Collections.sort(arr, new Job());\n\n        int maxDeadline = findMaxDeadline(arr);\n        DisjointSet dsu = new DisjointSet(maxDeadline);\n\n        for (Job temp : arr) {\n            int availableSlot = dsu.find(temp.deadline);\n\n            if (availableSlot > 0) {\n                dsu.merge(dsu.find(availableSlot - 1), availableSlot);\n                System.out.print(temp.id + \" \");\n            }\n        }\n\n        System.out.println();\n    }\n\n    public int compare(Job j1, Job j2) {\n        return j1.profit > j2.profit ? -1 : 1;\n    }\n}\n\nclass Main {\n\n    public static void main(String args[]) {\n\n        ArrayList<Job> arr = new ArrayList<Job>();\n        arr.add(new Job('a', 2, 100));\n        arr.add(new Job('b', 1, 19));\n        arr.add(new Job('c', 2, 27));\n        arr.add(new Job('d', 1, 25));\n        arr.add(new Job('e', 3, 15));\n\n        System.out.println(\"Following jobs need to be \" + \"executed for maximum profit\");\n        Job.printJobScheduling(arr);\n    }\n}", "src": "class\nDisjointSet \n{ \n\nint\nparent[]; \n\n\n\n\nDisjointSet(\nint\nn) \n\n{ \n\nparent = \nnew\nint\n[n + \n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nparent[i] = i; \n\n} \n\n\n\n\nint\nfind(\nint\ns) \n\n{ \n\n\n\nif\n(s == parent[s]) \n\nreturn\ns; \n\nreturn\nparent[s] = find(parent[s]); \n\n} \n\n\n\n\nvoid\nmerge(\nint\nu, \nint\nv) \n\n{ \n\n\n\n\n\nparent[v] = u; \n\n} \n} \n\nclass\nJob \nimplements\nComparator<Job> \n{ \n\n\n\nchar\nid; \n\nint\ndeadline, profit; \n\n\n\n\npublic\nJob() { } \n\npublic\nJob(\nchar\nid,\nint\ndeadline,\nint\nprofit) \n\n{ \n\nthis\n.id = id; \n\nthis\n.deadline = deadline; \n\nthis\n.profit = profit; \n\n} \n\n\n\n\npublic\nstatic\nint\nfindMaxDeadline(ArrayList<Job> arr) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n\nfor\n(Job temp : arr) \n\nans = Math.max(temp.deadline, ans); \n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nprintJobScheduling(ArrayList<Job> arr) \n\n{ \n\n\n\n\n\nCollections.sort(arr, \nnew\nJob()); \n\n\n\n\n\n\n\n\nint\nmaxDeadline = findMaxDeadline(arr); \n\nDisjointSet dsu = \nnew\nDisjointSet(maxDeadline); \n\n\n\n\nfor\n(Job temp : arr) \n\n{ \n\n\n\n\n\nint\navailableSlot = dsu.find(temp.deadline); \n\n\n\n\n\n\n\nif\n(availableSlot > \n0\n) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndsu.merge(dsu.find(availableSlot - \n1\n), \n\navailableSlot); \n\nSystem.out.print(temp.id + \n\" \"\n); \n\n} \n\n} \n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\npublic\nint\ncompare(Job j1, Job j2) \n\n{ \n\nreturn\nj1.profit > j2.profit? -\n1\n: \n1\n; \n\n} \n} \n\n\nclass\nMain \n{ \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nArrayList<Job> arr=\nnew\nArrayList<Job>(); \n\narr.add(\nnew\nJob(\n'a'\n,\n2\n,\n100\n)); \n\narr.add(\nnew\nJob(\n'b'\n,\n1\n,\n19\n)); \n\narr.add(\nnew\nJob(\n'c'\n,\n2\n,\n27\n)); \n\narr.add(\nnew\nJob(\n'd'\n,\n1\n,\n25\n)); \n\narr.add(\nnew\nJob(\n'e'\n,\n3\n,\n15\n)); \n\nSystem.out.println(\n\"Following jobs need to be \"\n+ \n\n\"executed for maximum profit\"\n); \n\nJob.printJobScheduling(arr); \n\n} \n}", "index": 569, "complexity": "5"}
{"back-translation": "class GFG { void find3largest(int[] arr) { Arrays.sort(arr); int n = arr.length; int check = 0, count = 1; for (int i = 1; i <= n; i++) { if (count < 4) { if (check != arr[n - i]) { System.out.print(arr[n - i] + \" \"); check = arr[n - i]; count++; } } else break; } } public static void main(String[] args) { GFG obj = new GFG(); int[] arr = {12, 45, 1, -1, 45, 54, 23, 5, 0, -10}; obj.find3largest(arr); } }", "src": "class\nGFG { \n\nvoid\nfind3largest(\nint\n[] arr) \n\n{ \n\nArrays.sort(arr); \n\n\n\n\nint\nn = arr.length; \n\nint\ncheck = \n0\n, count = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++){ \n\n\nif\n(count<\n4\n){ \n\nif\n(check!=arr[n-i]) \n\n{ \n\n\n\nSystem.out.print(arr[n-i]+\n\" \"\n); \n\ncheck = arr[n-i]; \n\ncount++; \n\n} \n\n} \n\nelse\n\nbreak\n; \n\n} \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nGFG obj = \nnew\nGFG(); \n\nint\n[] arr={\n12\n,\n45\n,\n1\n,-\n1\n,\n45\n,\n54\n,\n23\n,\n5\n,\n0\n,-\n10\n}; \n\nobj.find3largest(arr); \n\n} \n\n}", "index": 570, "complexity": "5"}
{"back-translation": "class HuffmanNode { int data; char c; HuffmanNode left; HuffmanNode right; } class MyComparator implements Comparator<HuffmanNode> { public int compare(HuffmanNode x, HuffmanNode y) { return x.data - y.data; } } public class Huffman { public static void printCode(HuffmanNode root, String s) { if (root.left == null && root.right == null && Character.isLetter(root.c)) { System.out.println(root.c + \":\" + s); return; } printCode(root.left, s + \"0\"); printCode(root.right, s + \"1\"); } public static void main(String[] args) { Scanner s = new Scanner(System.in); int n = 6; char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f'}; int[] charfreq = { 5, 9, 12, 13, 16, 45}; PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(n, new MyComparator()); for (int i = 0; i < n; i++) { HuffmanNode hn = new HuffmanNode(); hn.c = charArray[i]; hn.data = charfreq[i]; hn.left = null; hn.right = null; q.add(hn); } HuffmanNode root = null; while (q.size() > 1) { HuffmanNode x = q.peek(); q.poll(); HuffmanNode y = q.peek(); q.poll(); HuffmanNode f = new HuffmanNode(); f.data = x.data + y.data; f.c = '-'; f.left = x; f.right = y; root = f; q.add(f); } printCode(root, \"\"); } }", "src": "class\nHuffmanNode { \n\n\nint\ndata; \n\nchar\nc; \n\n\nHuffmanNode left; \n\nHuffmanNode right; \n} \n\n\n\n\n\nclass\nMyComparator \nimplements\nComparator<HuffmanNode> { \n\npublic\nint\ncompare(HuffmanNode x, HuffmanNode y) \n\n{ \n\n\nreturn\nx.data - y.data; \n\n} \n} \n\npublic\nclass\nHuffman { \n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nprintCode(HuffmanNode root, String s) \n\n{ \n\n\n\n\n\n\n\n\nif\n(root.left \n\n== \nnull\n\n&& root.right \n\n== \nnull\n\n&& Character.isLetter(root.c)) { \n\n\n\n\nSystem.out.println(root.c + \n\":\"\n+ s); \n\n\nreturn\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\nprintCode(root.left, s + \n\"0\"\n); \n\nprintCode(root.right, s + \n\"1\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nScanner s = \nnew\nScanner(System.in); \n\n\n\n\nint\nn = \n6\n; \n\nchar\n[] charArray = { \n'a'\n, \n'b'\n, \n'c'\n, \n'd'\n, \n'e'\n, \n'f'\n}; \n\nint\n[] charfreq = { \n5\n, \n9\n, \n12\n, \n13\n, \n16\n, \n45\n}; \n\n\n\n\n\n\nPriorityQueue<HuffmanNode> q \n\n= \nnew\nPriorityQueue<HuffmanNode>(n, \nnew\nMyComparator()); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nHuffmanNode hn = \nnew\nHuffmanNode(); \n\n\nhn.c = charArray[i]; \n\nhn.data = charfreq[i]; \n\n\nhn.left = \nnull\n; \n\nhn.right = \nnull\n; \n\n\n\n\n\n\nq.add(hn); \n\n} \n\n\n\n\nHuffmanNode root = \nnull\n; \n\n\n\n\n\n\n\n\n\n\nwhile\n(q.size() > \n1\n) { \n\n\n\n\nHuffmanNode x = q.peek(); \n\nq.poll(); \n\n\n\n\nHuffmanNode y = q.peek(); \n\nq.poll(); \n\n\n\n\nHuffmanNode f = \nnew\nHuffmanNode(); \n\n\n\n\n\n\nf.data = x.data + y.data; \n\nf.c = \n'-'\n; \n\n\n\n\nf.left = x; \n\n\n\n\nf.right = y; \n\n\n\n\nroot = f; \n\n\n\n\nq.add(f); \n\n} \n\n\n\n\nprintCode(root, \n\"\"\n); \n\n} \n}", "index": 571, "complexity": "5"}
{"back-translation": "public class Graph { class Edge implements Comparable<Edge> { int src, dest, weight; public int compareTo(Edge compareEdge) { return this.weight - compareEdge.weight; } }; class Subset { int parent, rank; }; int V, E; Edge edge[]; Graph(int v, int e) { V = v; E = e; edge = new Edge[E]; for (int i = 0; i < e; ++i) edge[i] = new Edge(); } int find(Subset subsets[], int i) { if (subsets[i].parent != i) subsets[i].parent = find(subsets, subsets[i].parent); return subsets[i].parent; } void union(Subset subsets[], int x, int y) { int xroot = find(subsets, x); int yroot = find(subsets, y); if (subsets[xroot].rank < subsets[yroot].rank) subsets[xroot].parent = yroot; else if (subsets[xroot].rank > subsets[yroot].rank) subsets[yroot].parent = xroot; else { subsets[yroot].parent = xroot; subsets[xroot].rank++; } } void kruskalMST() { Edge result[] = new Edge[V]; int e = 0; int i = 0; for (i = 0; i < V; ++i) result[i] = new Edge(); Arrays.sort(edge); Subset subsets[] = new Subset[V]; for (i = 0; i < V; ++i) subsets[i] = new Subset(); for (int v = 0; v < V; ++v) { subsets[v].parent = v; subsets[v].rank = 0; } i = 0; while (e < V - 1) { Edge nextEdge = new Edge(); nextEdge = edge[i++]; int x = find(subsets, nextEdge.src); int y = find(subsets, nextEdge.dest); if (x != y) { result[e++] = nextEdge; union(subsets, x, y); } } System.out.println(\"Following are the edges in \" + \"the constructed MST\"); for (i = 0; i < e; ++i) System.out.println(result[i].src + \" -- \" + result[i].dest + \" == \" + result[i].weight); } public static void main(String[] args) { int V = 4; int E = 5; Graph graph = new Graph(V, E); graph.edge[0].src = 0; graph.edge[0].dest = 1; graph.edge[0].weight = 10; graph.edge[1].src = 0; graph.edge[1].dest = 2; graph.edge[1].weight = 6; graph.edge[2].src = 0; graph.edge[2].dest = 3; graph.edge[2].weight = 5; graph.edge[3].src = 1; graph.edge[3].dest = 3; graph.edge[3].weight = 15; graph.edge[4].src = 2; graph.edge[4].dest = 3; graph.edge[4].weight = 4; graph.kruskalMST(); } }", "src": "class\nGraph \n{ \n\n\n\nclass\nEdge \nimplements\nComparable<Edge> \n\n{ \n\nint\nsrc, dest, weight; \n\n\n\n\n\n\npublic\nint\ncompareTo(Edge compareEdge) \n\n{ \n\nreturn\nthis\n.weight-compareEdge.weight; \n\n} \n\n}; \n\n\n\n\nclass\nsubset \n\n{ \n\nint\nparent, rank; \n\n}; \n\n\nint\nV, E; \n\n\nEdge edge[]; \n\n\n\n\n\nGraph(\nint\nv, \nint\ne) \n\n{ \n\nV = v; \n\nE = e; \n\nedge = \nnew\nEdge[E]; \n\nfor\n(\nint\ni=\n0\n; i<e; ++i) \n\nedge[i] = \nnew\nEdge(); \n\n} \n\n\n\n\n\n\nint\nfind(subset subsets[], \nint\ni) \n\n{ \n\n\n\nif\n(subsets[i].parent != i) \n\nsubsets[i].parent = find(subsets, subsets[i].parent); \n\n\nreturn\nsubsets[i].parent; \n\n} \n\n\n\n\n\n\nvoid\nUnion(subset subsets[], \nint\nx, \nint\ny) \n\n{ \n\nint\nxroot = find(subsets, x); \n\nint\nyroot = find(subsets, y); \n\n\n\n\n\n\nif\n(subsets[xroot].rank < subsets[yroot].rank) \n\nsubsets[xroot].parent = yroot; \n\nelse\nif\n(subsets[xroot].rank > subsets[yroot].rank) \n\nsubsets[yroot].parent = xroot; \n\n\n\n\n\n\nelse\n\n{ \n\nsubsets[yroot].parent = xroot; \n\nsubsets[xroot].rank++; \n\n} \n\n} \n\n\n\n\nvoid\nKruskalMST() \n\n{ \n\nEdge result[] = \nnew\nEdge[V]; \n\n\nint\ne = \n0\n; \n\n\nint\ni = \n0\n; \n\n\nfor\n(i=\n0\n; i<V; ++i) \n\nresult[i] = \nnew\nEdge(); \n\n\n\n\n\n\n\n\nArrays.sort(edge); \n\n\n\n\nsubset subsets[] = \nnew\nsubset[V]; \n\nfor\n(i=\n0\n; i<V; ++i) \n\nsubsets[i]=\nnew\nsubset(); \n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; ++v) \n\n{ \n\nsubsets[v].parent = v; \n\nsubsets[v].rank = \n0\n; \n\n} \n\n\ni = \n0\n; \n\n\n\n\n\nwhile\n(e < V - \n1\n) \n\n{ \n\n\n\n\n\nEdge next_edge = \nnew\nEdge(); \n\nnext_edge = edge[i++]; \n\n\nint\nx = find(subsets, next_edge.src); \n\nint\ny = find(subsets, next_edge.dest); \n\n\n\n\n\n\n\n\nif\n(x != y) \n\n{ \n\nresult[e++] = next_edge; \n\nUnion(subsets, x, y); \n\n} \n\n\n\n} \n\n\n\n\n\n\nSystem.out.println(\n\"Following are the edges in \"\n+ \n\n\"the constructed MST\"\n); \n\nfor\n(i = \n0\n; i < e; ++i) \n\nSystem.out.println(result[i].src+\n\" -- \"\n+ \n\nresult[i].dest+\n\" == \"\n+ result[i].weight); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\n\nint\nV = \n4\n; \n\n\nint\nE = \n5\n; \n\n\nGraph graph = \nnew\nGraph(V, E); \n\n\n\n\ngraph.edge[\n0\n].src = \n0\n; \n\ngraph.edge[\n0\n].dest = \n1\n; \n\ngraph.edge[\n0\n].weight = \n10\n; \n\n\n\n\ngraph.edge[\n1\n].src = \n0\n; \n\ngraph.edge[\n1\n].dest = \n2\n; \n\ngraph.edge[\n1\n].weight = \n6\n; \n\n\n\n\ngraph.edge[\n2\n].src = \n0\n; \n\ngraph.edge[\n2\n].dest = \n3\n; \n\ngraph.edge[\n2\n].weight = \n5\n; \n\n\n\n\ngraph.edge[\n3\n].src = \n1\n; \n\ngraph.edge[\n3\n].dest = \n3\n; \n\ngraph.edge[\n3\n].weight = \n15\n; \n\n\n\n\ngraph.edge[\n4\n].src = \n2\n; \n\ngraph.edge[\n4\n].dest = \n3\n; \n\ngraph.edge[\n4\n].weight = \n4\n; \n\n\ngraph.KruskalMST(); \n\n} \n}", "index": 572, "complexity": "5"}
{"back-translation": "public class prims {\n\nstatic class node1 {\n\nint dest;\n\nint weight;\n\nnode1(int a, int b) {\n\ndest = a;\n\nweight = b;\n\n}\n\n}\n\nstatic class Graph {\n\nint V;\n\nLinkedList<node1>[] adj;\n\nGraph(int e) {\n\nV = e;\n\nadj = new LinkedList[V];\n\nfor (int o = 0; o < V; o++)\n\nadj[o] = new LinkedList<>();\n\n}\n\n}\n\nstatic class node {\n\nint vertex;\n\nint key;\n\n}\n\nstatic class comparator implements Comparator<node> {\n\n@Override\n\npublic int compare(node node0, node node1) {\n\nreturn node0.key - node1.key;\n\n}\n\n}\n\nvoid addEdge(Graph graph, int src, int dest, int weight) {\n\nnode1 node0 = new node1(dest, weight);\n\nnode1 node = new node1(src, weight);\n\ngraph.adj[src].addLast(node0);\n\ngraph.adj[dest].addLast(node);\n\n}\n\nvoid prims_mst(Graph graph) {\n\nBoolean[] mstset = new Boolean[graph.V];\n\nnode[] e = new node[graph.V];\n\nint[] parent = new int[graph.V];\n\nfor (int o = 0; o < graph.V; o++)\n\ne[o] = new node();\n\nfor (int o = 0; o < graph.V; o++) {\n\nmstset[o] = false;\n\ne[o].key = Integer.MAX_VALUE;\n\ne[o].vertex = o;\n\nparent[o] = -1;\n\n}\n\nmstset[0] = true;\n\ne[0].key = 0;\n\nTreeSet<node> queue = new TreeSet<node>(new comparator());\n\nfor (int o = 0; o < graph.V; o++)\n\nqueue.add(e[o]);\n\nwhile (!queue.isEmpty()) {\n\nnode node0 = queue.pollFirst();\n\nmstset[node0.vertex] = true;\n\nfor (node1 iterator : graph.adj[node0.vertex]) {\n\nif (mstset[iterator.dest] == false) {\n\nif (e[iterator.dest].key > iterator.weight) {\n\nqueue.remove(e[iterator.dest]);\n\ne[iterator.dest].key = iterator.weight;\n\nqueue.add(e[iterator.dest]);\n\nparent[iterator.dest] = node0.vertex;\n\n}\n\n}\n\n}\n\n}\n\nfor (int o = 1; o < graph.V; o++)\n\nSystem.out.println(parent[o] + \" \" + \"-\" + \" \" + o);\n\n}\n\npublic static void main(String[] args) {\n\nint V = 9;\n\nGraph graph = new Graph(V);\n\nprims e = new prims();\n\ne.addEdge(graph, 0, 1, 4);\n\ne.addEdge(graph, 0, 7, 8);\n\ne.addEdge(graph, 1, 2, 8);\n\ne.addEdge(graph, 1, 7, 11);\n\ne.addEdge(graph, 2, 3, 7);\n\ne.addEdge(graph, 2, 8, 2);\n\ne.addEdge(graph, 2, 5, 4);\n\ne.addEdge(graph, 3, 4, 9);\n\ne.addEdge(graph, 3, 5, 14);\n\ne.addEdge(graph, 4, 5, 10);\n\ne.addEdge(graph, 5, 6, 2);\n\ne.addEdge(graph, 6, 7, 1);\n\ne.addEdge(graph, 6, 8, 6);\n\ne.addEdge(graph, 7, 8, 7);\n\ne.prims_mst(graph);\n\n}\n\n}", "src": "public\nclass\nprims { \n\nclass\nnode1 { \n\n\n\n\nint\ndest; \n\n\n\n\nint\nweight; \n\n\n\n\nnode1(\nint\na, \nint\nb) \n\n{ \n\ndest = a; \n\nweight = b; \n\n} \n\n} \n\nstatic\nclass\nGraph { \n\n\n\n\nint\nV; \n\n\n\n\nLinkedList<node1>[] adj; \n\n\n\n\nGraph(\nint\ne) \n\n{ \n\nV = e; \n\nadj = \nnew\nLinkedList[V]; \n\nfor\n(\nint\no = \n0\n; o < V; o++) \n\nadj[o] = \nnew\nLinkedList<>(); \n\n} \n\n} \n\n\n\n\n\n\n\n\nclass\nnode { \n\nint\nvertex; \n\nint\nkey; \n\n} \n\n\n\n\n\n\n\n\n\n\nclass\ncomparator \nimplements\nComparator<node> { \n\n\n@Override\n\npublic\nint\ncompare(node node0, node node1) \n\n{ \n\nreturn\nnode0.key - node1.key; \n\n} \n\n} \n\n\n\n\n\n\nvoid\naddEdge(Graph graph, \nint\nsrc, \nint\ndest, \nint\nweight) \n\n{ \n\n\nnode1 node0 = \nnew\nnode1(dest, weight); \n\nnode1 node = \nnew\nnode1(src, weight); \n\ngraph.adj[src].addLast(node0); \n\ngraph.adj[dest].addLast(node); \n\n} \n\n\n\n\nvoid\nprims_mst(Graph graph) \n\n{ \n\n\n\n\nBoolean[] mstset = \nnew\nBoolean[graph.V]; \n\nnode[] e = \nnew\nnode[graph.V]; \n\n\n\n\nint\n[] parent = \nnew\nint\n[graph.V]; \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) \n\ne[o] = \nnew\nnode(); \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) { \n\n\n\n\nmstset[o] = \nfalse\n; \n\n\n\n\ne[o].key = Integer.MAX_VALUE; \n\ne[o].vertex = o; \n\nparent[o] = -\n1\n; \n\n} \n\n\n\n\nmstset[\n0\n] = \ntrue\n; \n\n\n\n\n\n\n\n\ne[\n0\n].key = \n0\n; \n\n\n\n\nTreeSet<node> queue = \nnew\nTreeSet<node>(\nnew\ncomparator()); \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) \n\nqueue.add(e[o]); \n\n\n\n\nwhile\n(!queue.isEmpty()) { \n\n\n\n\nnode node0 = queue.pollFirst(); \n\n\n\n\nmstset[node0.vertex] = \ntrue\n; \n\n\n\n\nfor\n(node1 iterator : graph.adj[node0.vertex]) { \n\n\n\n\nif\n(mstset[iterator.dest] == \nfalse\n) { \n\n\n\n\n\n\n\n\n\nif\n(e[iterator.dest].key > iterator.weight) { \n\nqueue.remove(e[iterator.dest]); \n\ne[iterator.dest].key = iterator.weight; \n\nqueue.add(e[iterator.dest]); \n\nparent[iterator.dest] = node0.vertex; \n\n} \n\n} \n\n} \n\n} \n\n\n\n\nfor\n(\nint\no = \n1\n; o < graph.V; o++) \n\nSystem.out.println(parent[o] + \n\" \"\n\n+ \n\"-\"\n\n+ \n\" \"\n+ o); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nV = \n9\n; \n\n\nGraph graph = \nnew\nGraph(V); \n\n\nprims e = \nnew\nprims(); \n\n\ne.addEdge(graph, \n0\n, \n1\n, \n4\n); \n\ne.addEdge(graph, \n0\n, \n7\n, \n8\n); \n\ne.addEdge(graph, \n1\n, \n2\n, \n8\n); \n\ne.addEdge(graph, \n1\n, \n7\n, \n11\n); \n\ne.addEdge(graph, \n2\n, \n3\n, \n7\n); \n\ne.addEdge(graph, \n2\n, \n8\n, \n2\n); \n\ne.addEdge(graph, \n2\n, \n5\n, \n4\n); \n\ne.addEdge(graph, \n3\n, \n4\n, \n9\n); \n\ne.addEdge(graph, \n3\n, \n5\n, \n14\n); \n\ne.addEdge(graph, \n4\n, \n5\n, \n10\n); \n\ne.addEdge(graph, \n5\n, \n6\n, \n2\n); \n\ne.addEdge(graph, \n6\n, \n7\n, \n1\n); \n\ne.addEdge(graph, \n6\n, \n8\n, \n6\n); \n\ne.addEdge(graph, \n7\n, \n8\n, \n7\n); \n\n\n\n\ne.prims_mst(graph); \n\n} \n}", "index": 573, "complexity": "5"}
{"back-translation": "public class GFG {\n\n    static int MaxSumDifference(Integer[] a, int n) {\n\n        List<Integer> finalSequence = new ArrayList<Integer>();\n\n        Arrays.sort(a);\n\n        for (int i = 0; i < n / 2; ++i) {\n            finalSequence.add(a[i]);\n            finalSequence.add(a[n - i - 1]);\n        }\n\n        int MaximumSum = 0;\n\n        for (int i = 0; i < n - 1; ++i) {\n            MaximumSum = MaximumSum + Math.abs(finalSequence.get(i) - finalSequence.get(i + 1));\n        }\n\n        MaximumSum = MaximumSum + Math.abs(finalSequence.get(n - 1) - finalSequence.get(0));\n\n        return MaximumSum;\n    }\n\n    public static void main(String args[]) {\n        Integer[] a = {1, 2, 4, 8};\n        int n = a.length;\n\n        System.out.print(MaxSumDifference(a, n));\n    }\n}", "src": "public\nclass\nGFG { \n\n\nstatic\nint\nMaxSumDifference(Integer []a, \nint\nn) \n\n{ \n\n\n\n\nList<Integer> finalSequence = \n\nnew\nArrayList<Integer>(); \n\n\n\n\n\n\n\n\n\n\nArrays.sort(a); \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n / \n2\n; ++i) { \n\nfinalSequence.add(a[i]); \n\nfinalSequence.add(a[n - i - \n1\n]); \n\n} \n\n\n\n\n\n\n\n\nint\nMaximumSum = \n0\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(i) \n\n- finalSequence.get(i + \n1\n)); \n\n} \n\n\n\n\n\n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(n - \n1\n) \n\n- finalSequence.get(\n0\n)); \n\n\n\n\nreturn\nMaximumSum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nInteger []a = { \n1\n, \n2\n, \n4\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxSumDifference(a, n)); \n\n} \n}", "index": 574, "complexity": "5"}
{"back-translation": "class MaxSum { static int maxSum(int arr[], int n) { int sum = 0; Arrays.sort(arr); for (int i = 0; i < n/2; i++) { sum -= (2 * arr[i]); sum += (2 * arr[n - i - 1]); } return sum; } public static void main(String[] args) { int arr[] = { 4, 2, 1, 8 }; int n = arr.length; System.out.println(maxSum(arr, n)); } }", "src": "class\nMaxSum \n{ \n\n\n\n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n/\n2\n; i++) \n\n{ \n\nsum -= (\n2\n* arr[i]); \n\nsum += (\n2\n* arr[n - i - \n1\n]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n4\n, \n2\n, \n1\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n\n} \n}", "index": 575, "complexity": "5"}
{"back-translation": "class GFG {\n    static int maxLevel(int[] boxes, int n) {\n        Arrays.sort(boxes);\n        int ans = 1;\n        int prev_width = boxes[0];\n        int prev_count = 1;\n        int curr_count = 0;\n        int curr_width = 0;\n        for (int i = 1; i < n; i++) {\n            curr_width += boxes[i];\n            curr_count += 1;\n            if (curr_width > prev_width && curr_count > prev_count) {\n                prev_width = curr_width;\n                prev_count = curr_count;\n                curr_count = 0;\n                curr_width = 0;\n                ans++;\n            }\n        }\n        return ans;\n    }\n    static public void main (String[] args) {\n        int[] boxes = {10, 20, 30, 50, 60, 70};\n        int n = boxes.length;\n        System.out.println(maxLevel(boxes, n));\n    }\n}", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxLevel(\nint\n[]boxes, \nint\nn) \n\n{ \n\n\n\n\n\n\nArrays.sort(boxes); \n\n\nint\nans = \n1\n; \n\n\n\n\n\n\n\n\n\nint\nprev_width = boxes[\n0\n]; \n\nint\nprev_count = \n1\n; \n\n\n\n\n\n\nint\ncurr_count = \n0\n; \n\n\n\n\nint\ncurr_width = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\ncurr_width += boxes[i]; \n\ncurr_count += \n1\n; \n\n\n\n\n\n\n\n\nif\n(curr_width > prev_width && \n\ncurr_count > prev_count) \n\n{ \n\n\n\n\n\n\n\n\nprev_width = curr_width; \n\nprev_count = curr_count; \n\n\n\n\n\n\n\n\ncurr_count = \n0\n; \n\ncurr_width = \n0\n; \n\n\n\n\n\n\nans++; \n\n} \n\n} \n\n\nreturn\nans; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]boxes = {\n10\n, \n20\n, \n30\n, \n50\n, \n60\n, \n70\n}; \n\nint\nn = boxes.length; \n\nSystem.out.println(maxLevel(boxes, n)); \n\n} \n}", "index": 576, "complexity": "5"}
{"back-translation": "class GFG { static int maxDifference(int[] arr, int N, int k) { int M, S = 0, S1 = 0, max_difference = 0; for (int i = 0; i < N; i++) S += arr[i]; int temp; for (int i = 0; i < N; i++) { for (int j = i + 1; j < N; j++) { if (arr[i] < arr[j]) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } M = Math.max(k, N - k); for (int i = 0; i < M; i++) S1 += arr[i]; max_difference = S1 - (S - S1); return max_difference; } public static void main(String args[]) { int arr[] = { 8, 4, 5, 2, 10 }; int N = arr.length; int k = 2; System.out.println(maxDifference(arr, N, k)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmaxDifference(\nint\narr[], \nint\nN, \nint\nk) \n{ \n\nint\nM, S = \n0\n, S1 = \n0\n, max_difference = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\nS += arr[i]; \n\nint\ntemp; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\n{ \n\nfor\n(\nint\nj = i + \n1\n; j < N; j++) \n\n{ \n\nif\n(arr[i] < arr[j]) \n\n{ \n\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n} \n\n\nM = Math.max(k, N - k); \n\nfor\n(\nint\ni = \n0\n; i < M; i++) \n\nS1 += arr[i]; \n\n\n\n\nmax_difference = S1 - (S - S1); \n\nreturn\nmax_difference; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n8\n, \n4\n, \n5\n, \n2\n, \n10\n}; \n\nint\nN = arr.length; \n\nint\nk = \n2\n; \n\nSystem.out.println(maxDifference(arr, N, k)); \n} \n}", "index": 577, "complexity": "5"}
{"back-translation": "class GFG { static void findElements(int[] arr, int n) { Arrays.sort(arr); for (int i = 0; i < n - 2; i++) System.out.print(arr[i] + \" \"); } public static void main(String args[]) { int[] arr = { 2, -6, 3, 5, 1 }; int n = arr.length; findElements(arr, n); } }", "src": "class\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n2\n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n,\n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n\n} \n}", "index": 578, "complexity": "5"}
{"back-translation": "class MinSum {\n\n    static long findMinSum(long[] a, long[] b, long n) {\n        Arrays.sort(a);\n        Arrays.sort(b);\n\n        long sum = 0;\n\n        for (int i = 0; i < n; i++)\n            sum = sum + Math.abs(a[i] - b[i]);\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        long a[] = {4, 1, 8, 7};\n        long b[] = {2, 3, 6, 5};\n        int n = a.length;\n\n        System.out.println(findMinSum(a, b, n));\n    }\n}", "src": "class\nMinSum \n{ \n\n\n\n\n\nstatic\nlong\nfindMinSum(\nlong\na[], \nlong\nb[], \nlong\nn) \n\n{ \n\n\n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n\nlong\nsum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nsum = sum + Math.abs(a[i] - b[i]); \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nlong\na[] = {\n4\n, \n1\n, \n8\n, \n7\n}; \n\nlong\nb[] = {\n2\n, \n3\n, \n6\n, \n5\n}; \n\nint\nn = a.length; \n\nSystem.out.println(findMinSum(a, b, n)); \n\n} \n}", "index": 579, "complexity": "5"}
{"back-translation": "class MinSum {\n    public static long solve(int[] a) {\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\n        StringBuilder num1 = new StringBuilder();\n        StringBuilder num2 = new StringBuilder();\n        for (int x : a)\n            pq.add(x);\n        while (!pq.isEmpty()) {\n            num1.append(pq.poll() + \"\");\n            if (!pq.isEmpty())\n                num2.append(pq.poll() + \"\");\n        }\n        long sum = Long.parseLong(num1.toString()) + Long.parseLong(num2.toString());\n        return sum;\n    }\n    public static void main(String[] args) {\n        int arr[] = {6, 8, 4, 5, 2, 3};\n        System.out.println(\"The required sum is \" + solve(arr));\n    }\n}", "src": "class\nMinSum \n{ \n\n\n\n\n\npublic\nstatic\nlong\nsolve(\nint\n[] a) \n\n{ \n\n\n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<Integer>(); \n\n\n\n\n\n\nStringBuilder num1 = \nnew\nStringBuilder(); \n\nStringBuilder num2 = \nnew\nStringBuilder(); \n\n\n\n\nfor\n(\nint\nx : a) \n\npq.add(x); \n\n\n\n\nwhile\n(!pq.isEmpty()) \n\n{ \n\nnum1.append(pq.poll()+ \n\"\"\n); \n\nif\n(!pq.isEmpty()) \n\nnum2.append(pq.poll()+ \n\"\"\n); \n\n} \n\n\n\n\nlong\nsum = Long.parseLong(num1.toString()) + \n\nLong.parseLong(num2.toString()); \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n6\n, \n8\n, \n4\n, \n5\n, \n2\n, \n3\n}; \n\nSystem.out.println(\n\"The required sum is \"\n+ solve(arr)); \n\n} \n}", "index": 580, "complexity": "5"}
{"back-translation": "class GFG { public static int DecreasingArray(int[] a, int n) { int sum = 0, dif = 0; PriorityQueue<Integer> pq = new PriorityQueue<>(); for (int i = 0; i < n; i++) { if (!pq.isEmpty() && pq.peek() < a[i]) { dif = a[i] - pq.peek(); sum += dif; pq.poll(); pq.add(a[i]); } pq.add(a[i]); } return sum; } public static void main(String[] args) { int[] a = {3, 1, 2, 1}; int n = a.length; System.out.println(DecreasingArray(a, n)); } }", "src": "class\nGFG \n{ \n\npublic\nstatic\nint\nDecreasingArray(\nint\na[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n, dif = \n0\n; \n\n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<>(); \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(!pq.isEmpty() && pq.element() < a[i]) \n\n{ \n\ndif = a[i] - pq.element(); \n\nsum += dif; \n\npq.remove(); \n\npq.add(a[i]); \n\n} \n\npq.add(a[i]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] a = {\n3\n, \n1\n, \n2\n, \n1\n}; \n\n\nint\nn = a.length; \n\n\nSystem.out.println(DecreasingArray(a, n)); \n\n} \n}", "index": 581, "complexity": "5"}
{"back-translation": "class GFG { static int MinOperation(int[] a, int[] b, int n) { Arrays.sort(a); Arrays.sort(b); int result = 0; for (int i = 0; i < n; ++i) { if (a[i] > b[i]) result = result + Math.abs(a[i] - b[i]); else if (a[i] < b[i]) result = result + Math.abs(a[i] - b[i]); } return result; } public static void main(String[] args) { int a[] = {3, 1, 1}; int b[] = {1, 2, 2}; int n = a.length; System.out.println(MinOperation(a, b, n)); } }", "src": "class\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nb[], \n\nint\nn) \n{ \n\n\n\n\n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n\n\n\n\nint\nresult = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\nif\n(a[i] > b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n\nelse\nif\n(a[i] < b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = {\n3\n, \n1\n, \n1\n}; \n\nint\nb[] = {\n1\n, \n2\n, \n2\n}; \n\nint\nn = a.length; \n\nSystem.out.println(MinOperation(a, b, n)); \n} \n}", "index": 582, "complexity": "5"}
{"back-translation": "class GFG { static boolean ifPossible(int arr[], int n) { int copy[] = Arrays.copyOf(arr, arr.length); Arrays.sort(copy); for (int i = 0; i < n; i++) { if (!(arr[i] == copy[i]) && !(arr[n - 1 - i] == copy[i])) return false; } return true; } public static void main(String[] args) { int arr[] = {1, 7, 6, 4, 5, 3, 2, 8}; int n = arr.length; if (ifPossible(arr, n)) System.out.println(\"Yes\"); else System.out.println(\"No\"); } }", "src": "class\nGFG { \n\n\nstatic\nboolean\nifPossible(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\nint\ncopy[] = Arrays.copyOf(arr, arr.length); \n\n\n\n\nArrays.sort(copy); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\nif\n(!(arr[i] == copy[i]) && !(arr[n - \n1\n- i] == copy[i])) \n\nreturn\nfalse\n; \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n7\n, \n6\n, \n4\n, \n5\n, \n3\n, \n2\n, \n8\n}; \n\nint\nn = arr.length; \n\nif\n(ifPossible(arr, n)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 583, "complexity": "5"}
{"back-translation": "class GFG { static int MaxTotalRectangleArea(int[] a, int n) { Arrays.sort(a); int sum = 0; boolean flag = false; int len = 0; for (int i = 0; i < n; i++) { if ((a[i] == a[i + 1] || a[i] - a[i + 1] == 1) && !flag) { flag = true; len = a[i + 1]; i++; } else if ((a[i] == a[i + 1] || a[i] - a[i + 1] == 1) && (flag)) { sum = sum + a[i + 1] * len; flag = false; i++; } } return sum; } public static void main(String args[]) { int[] a = { 10, 10, 10, 10, 11, 10, 11, 10, 9, 9, 8, 8 }; int n = a.length; System.out.print(MaxTotalRectangleArea(a, n)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nMaxTotalRectangleArea(\nint\n[]a, \n\nint\nn) \n\n{ \n\n\n\n\n\n\nArrays.sort(a); \n\n\n\n\n\n\n\n\nint\nsum = \n0\n; \n\nboolean\nflag = \nfalse\n; \n\n\n\n\n\n\nint\nlen = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n!flag) \n\n{ \n\n\n\n\n\n\n\nflag = \ntrue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlen = a[i + \n1\n]; \n\n\n\n\n\n\n\n\n\n\ni++; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\nelse\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n(flag)) \n\n{ \n\n\n\n\n\nsum = sum + a[i + \n1\n] * len; \n\n\n\n\n\n\n\n\n\n\nflag = \nfalse\n; \n\n\n\n\n\n\n\n\n\n\ni++; \n\n} \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\n[]a = { \n10\n, \n10\n, \n10\n, \n10\n, \n\n11\n, \n10\n, \n11\n, \n10\n, \n\n9\n, \n9\n, \n8\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxTotalRectangleArea(a, n)); \n\n} \n}", "index": 584, "complexity": "5"}
{"back-translation": "public class FractionalKnapSack {\n\n    public static void main(String[] args) {\n        int[] wt = { 10, 40, 20, 30 };\n        int[] val = { 60, 40, 100, 120 };\n        int capacity = 50;\n\n        double maxValue = getMaxValue(wt, val, capacity);\n\n        System.out.println(\"Maximum value we can obtain = \" + maxValue);\n    }\n\n    private static double getMaxValue(int[] wt, int[] val, int capacity) {\n        ItemValue[] iVal = new ItemValue[wt.length];\n\n        for (int i = 0; i < wt.length; i++) {\n            iVal[i] = new ItemValue(wt[i], val[i], i);\n        }\n\n        Arrays.sort(iVal, new Comparator<ItemValue>() {\n            @Override\n            public int compare(ItemValue o1, ItemValue o2) {\n                return o2.cost.compareTo(o1.cost);\n            }\n        });\n\n        double totalValue = 0d;\n\n        for (ItemValue i : iVal) {\n            int curWt = (int) i.wt;\n            int curVal = (int) i.val;\n\n            if (capacity - curWt >= 0) {\n                capacity = capacity - curWt;\n                totalValue += curVal;\n            } else {\n                double fraction = ((double) capacity / (double) curWt);\n                totalValue += (curVal * fraction);\n                capacity = (int) (capacity - (curWt * fraction));\n                break;\n            }\n        }\n\n        return totalValue;\n    }\n\n    static class ItemValue {\n        Double cost;\n        double wt, val, ind;\n\n        public ItemValue(int wt, int val, int ind) {\n            this.wt = wt;\n            this.val = val;\n            this.ind = ind;\n            cost = new Double(val / wt);\n        }\n    }\n}", "src": "public\nclass\nFractionalKnapSack \n{ \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\n[] wt = {\n10\n, \n40\n, \n20\n, \n30\n}; \n\nint\n[] val = {\n60\n, \n40\n, \n100\n, \n120\n}; \n\nint\ncapacity = \n50\n; \n\n\ndouble\nmaxValue = getMaxValue(wt, val, capacity); \n\nSystem.out.println(\n\"Maximum value we can obtain = \"\n+ \n\nmaxValue); \n\n\n} \n\n\n\n\nprivate\nstatic\ndouble\ngetMaxValue(\nint\n[] wt, \n\nint\n[] val, \nint\ncapacity) \n\n{ \n\nItemValue[] iVal = \nnew\nItemValue[wt.length]; \n\n\nfor\n(\nint\ni = \n0\n; i < wt.length; i++) \n\n{ \n\niVal[i] = \nnew\nItemValue(wt[i], val[i], i); \n\n} \n\n\n\n\nArrays.sort(iVal, \nnew\nComparator<ItemValue>() \n\n{ \n\n@Override\n\npublic\nint\ncompare(ItemValue o1, ItemValue o2) \n\n{ \n\nreturn\no2.cost.compareTo(o1.cost) ; \n\n} \n\n}); \n\n\n\ndouble\ntotalValue = 0d; \n\n\nfor\n(ItemValue i: iVal) \n\n{ \n\n\nint\ncurWt = (\nint\n) i.wt; \n\nint\ncurVal = (\nint\n) i.val; \n\n\nif\n(capacity - curWt >= \n0\n) \n\n{ \n\n\n\ncapacity = capacity-curWt; \n\ntotalValue += curVal; \n\n\n} \n\nelse\n\n{ \n\n\n\ndouble\nfraction = ((\ndouble\n)capacity/(\ndouble\n)curWt); \n\ntotalValue += (curVal*fraction); \n\ncapacity = (\nint\n)(capacity - (curWt*fraction)); \n\nbreak\n; \n\n} \n\n\n\n} \n\n\nreturn\ntotalValue; \n\n} \n\n\n\n\nstatic\nclass\nItemValue \n\n{ \n\nDouble cost; \n\ndouble\nwt, val, ind; \n\n\n\n\npublic\nItemValue(\nint\nwt, \nint\nval, \nint\nind) \n\n{ \n\nthis\n.wt = wt; \n\nthis\n.val = val; \n\nthis\n.ind = ind; \n\ncost = \nnew\nDouble(val/wt ); \n\n} \n\n} \n}", "index": 585, "complexity": "5"}
{"back-translation": "class GFG { static int findMinimum(int arr[], int n, int k) { int res = 0; for (int i = 0; i < n; i++) { res += arr[i]; n = n - k; } return res; } static int findMaximum(int arr[], int n, int k) { int res = 0, index = 0; for (int i = n - 1; i >= index; i--) { res += arr[i]; index += k; } return res; } public static void main(String[] args) { int arr[] = { 3, 2, 1, 4 }; int n = arr.length; int k = 2; Arrays.sort(arr); System.out.println(findMinimum(arr, n, k) + \" \" + findMaximum(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMinimum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\nres += arr[i]; \n\n\n\n\n\n\nn = n - k; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n, index = \n0\n; \n\n\nfor\n(\nint\ni = n - \n1\n; i >= index; i--) \n\n{ \n\n\n\nres += arr[i]; \n\n\n\n\n\n\nindex += k; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n3\n, \n2\n, \n1\n, \n4\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\nArrays.sort(arr); \n\n\nSystem.out.println(findMinimum(arr, n, k) + \n\n\" \"\n+ findMaximum(arr, n, k)); \n\n} \n}", "index": 586, "complexity": "5"}
{"back-translation": "class GFG { static long calculate(long a[], int n) { Arrays.sort(a); int i, j; Vector<Long> s = new Vector<>(); for (i = 0, j = n - 1; i < n / 2; i++, j--) s.add((a[i] + a[j])); long mini = Collections.min(s); long maxi = Collections.max(s); return Math.abs(maxi - mini); } public static void main(String[] args) { long a[] = {2, 6, 4, 3}; int n = a.length; System.out.println(calculate(a, n)); } }", "src": "class\nGFG { \n\nstatic\nlong\ncalculate(\nlong\na[], \nint\nn) \n{ \n\n\n\nArrays.sort(a); \n\nint\ni,j; \n\n\n\n\nVector<Long> s = \nnew\nVector<>(); \n\nfor\n(i = \n0\n, j = n - \n1\n; i < j; i++, j--) \n\ns.add((a[i] + a[j])); \n\n\nlong\nmini = Collections.min(s); \n\nlong\nmaxi = Collections.max(s); \n\nreturn\nMath.abs(maxi - mini); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nlong\na[] = { \n2\n, \n6\n, \n4\n, \n3\n}; \n\nint\nn = a.length; \n\nSystem.out.println(calculate(a, n)); \n\n} \n}", "index": 587, "complexity": "5"}
{"back-translation": "class MinHeap { int[] harr; int heap_size; int capacity; public MinHeap(int a[], int size) { heap_size = size; capacity = size; harr = a; int i = (heap_size - 1) / 2; while (i >= 0) { MinHeapify(i); i--; } } void MinHeapify(int i) { int l = left(i); int r = right(i); int smallest = i; if (l < heap_size && harr[l] < harr[i]) smallest = l; if (r < heap_size && harr[r] < harr[smallest]) smallest = r; if (smallest != i) { swap(i, smallest); MinHeapify(smallest); } } int parent(int i) { return (i - 1) / 2; } int left(int i) { return (2 * i + 1); } int right(int i) { return (2 * i + 2); } int extractMin() { if (heap_size <= 0) return Integer.MAX_VALUE; if (heap_size == 1) { heap_size--; return harr[0]; } int root = harr[0]; harr[0] = harr[heap_size - 1]; heap_size--; MinHeapify(0); return root; } void insertKey(int k) { if (heap_size == capacity) { System.out.println(\\", "src": "class\nMinHeap { \n\nint\n[] harr; \n\n\nint\nheap_size; \n\n\nint\ncapacity; \n\n\n\n\n\n\n\npublic\nMinHeap(\nint\na[], \nint\nsize) \n\n{ \n\nheap_size = size; \n\ncapacity = size; \n\nharr = a; \n\nint\ni = (heap_size - \n1\n) / \n2\n; \n\nwhile\n(i >= \n0\n) { \n\nMinHeapify(i); \n\ni--; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\n\nvoid\nMinHeapify(\nint\ni) \n\n{ \n\nint\nl = left(i); \n\nint\nr = right(i); \n\nint\nsmallest = i; \n\nif\n(l < heap_size && harr[l] < harr[i]) \n\nsmallest = l; \n\nif\n(r < heap_size && harr[r] < harr[smallest]) \n\nsmallest = r; \n\nif\n(smallest != i) { \n\nswap(i, smallest); \n\nMinHeapify(smallest); \n\n} \n\n} \n\n\nint\nparent(\nint\ni) { \nreturn\n(i - \n1\n) / \n2\n; } \n\n\n\n\nint\nleft(\nint\ni) { \nreturn\n(\n2\n* i + \n1\n); } \n\n\n\n\nint\nright(\nint\ni) { \nreturn\n(\n2\n* i + \n2\n); } \n\n\n\n\nint\nextractMin() \n\n{ \n\nif\n(heap_size <= \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\nif\n(heap_size == \n1\n) { \n\nheap_size--; \n\nreturn\nharr[\n0\n]; \n\n} \n\n\n\n\nint\nroot = harr[\n0\n]; \n\nharr[\n0\n] = harr[heap_size - \n1\n]; \n\nheap_size--; \n\nMinHeapify(\n0\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\nvoid\ninsertKey(\nint\nk) \n\n{ \n\nif\n(heap_size == capacity) { \n\nSystem.out.println(\n\"Overflow: Could not insertKey\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nheap_size++; \n\nint\ni = heap_size - \n1\n; \n\nharr[i] = k; \n\n\n\n\nwhile\n(i != \n0\n&& harr[parent(i)] > harr[i]) { \n\nswap(i, parent(i)); \n\ni = parent(i); \n\n} \n\n} \n\n\n\n\n\n\nboolean\nisSizeOne() \n\n{ \n\nreturn\n(heap_size == \n1\n); \n\n} \n\n\n\n\nvoid\nswap(\nint\nx, \nint\ny) \n\n{ \n\nint\ntemp = harr[x]; \n\nharr[x] = harr[y]; \n\nharr[y] = temp; \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nminCost(\nint\nlen[], \nint\nn) \n\n{ \n\nint\ncost = \n0\n; \n\n\n\n\n\n\n\nMinHeap minHeap = \nnew\nMinHeap(len, n); \n\n\n\n\nwhile\n(!minHeap.isSizeOne()) { \n\n\n\nint\nmin = minHeap.extractMin(); \n\nint\nsec_min = minHeap.extractMin(); \n\n\ncost += (min + sec_min); \n\n\n\n\n\n\n\nminHeap.insertKey(min + sec_min); \n\n} \n\n\n\n\n\n\nreturn\ncost; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nlen[] = { \n4\n, \n3\n, \n2\n, \n6\n}; \n\nint\nsize = len.length; \n\n\nSystem.out.println(\n\"Total cost for connecting ropes is \"\n+ minCost(len, size)); \n\n} \n};", "index": 588, "complexity": "5"}
{"back-translation": "class GFG { static int minCost(int coin[], int n, int k) { Arrays.sort(coin); int coins_needed = (int)Math.ceil(1.0 * n / (k + 1)); int ans = 0; for (int i = 0; i <= coins_needed - 1; i++) ans += coin[i]; return ans; } public static void main(String arg[]) { int coin[] = { 8, 5, 3, 10, 2, 1, 15, 25 }; int n = coin.length; int k = 3; System.out.print(minCost(coin, n, k)); } }", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nint\nminCost(\nint\ncoin[], \n\nint\nn, \nint\nk) \n\n{ \n\n\n\n\nArrays.sort(coin); \n\n\n\n\n\n\nint\ncoins_needed = (\nint\n)Math.ceil(\n1.0\n* \n\nn / (k + \n1\n)); \n\n\n\n\n\n\nint\nans = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i <= coins_needed - \n1\n; \n\ni++) \n\nans += coin[i]; \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ncoin[] = { \n8\n, \n5\n, \n3\n, \n10\n, \n\n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\nint\nk = \n3\n; \n\n\nSystem.out.print(minCost(coin, n, k)); \n\n} \n}", "index": 589, "complexity": "5"}
{"back-translation": "public class GFG {\n    static void preprocess(int[] coin, int n) {\n        Arrays.sort(coin);\n        for (int i = 1; i <= n - 1; i++)\n            coin[i] += coin[i - 1];\n    }\n\n    static int minCost(int[] coin, int n, int k) {\n        int coins_needed = (int) Math.ceil(1.0 * n / (k + 1));\n        return coin[coins_needed - 1];\n    }\n\n    public static void main(String[] args) {\n        int[] coin = { 8, 5, 3, 10, 2, 1, 15, 25 };\n        int n = coin.length;\n\n        preprocess(coin, n);\n\n        int k = 3;\n        System.out.println(minCost(coin, n, k));\n\n        k = 7;\n        System.out.println(minCost(coin, n, k));\n    }\n}", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nvoid\npreprocess(\nint\n[]coin, \nint\nn) \n\n{ \n\n\n\n\nArrays.sort(coin); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n - \n1\n; i++) \n\ncoin[i] += coin[i - \n1\n]; \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nminCost(\nint\n[]coin, \nint\nn, \nint\nk) \n\n{ \n\n\n\n\nint\ncoins_needed =(\nint\n) Math.ceil(\n1.0\n\n* n / (k + \n1\n)); \n\n\n\n\nreturn\ncoin[coins_needed - \n1\n]; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]coin = {\n8\n, \n5\n, \n3\n, \n10\n, \n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\n\npreprocess(coin, n); \n\n\nint\nk = \n3\n; \n\nSystem.out.println(minCost(coin, n, k)); \n\n\nk = \n7\n; \n\nSystem.out.println( minCost(coin, n, k)); \n\n} \n}", "index": 590, "complexity": "5"}
{"back-translation": "static int findPlatform(int arr[], int dep[], int n) {Arrays.sort(arr);Arrays.sort(dep);int plat_needed = 1, result = 1;int i = 1, j = 0;while (i < n && j < n) {if (arr[i] <= dep[j]) {plat_needed++;i++;if (plat_needed > result) {result = plat_needed;}} else {plat_needed--;j++;}}return result;}public static void main(String[] args) {int arr[] = {900, 940, 950, 1100, 1500, 1800};int dep[] = {910, 1200, 1120, 1130, 1900, 2000};int n = arr.length;System.out.println(\"Minimum Number of Platforms Required = \" + findPlatform(arr, dep, n));}", "src": "class\nGFG { \n\n\nstatic\nint\nfindPlatform(\nint\narr[], \nint\ndep[], \nint\nn) \n{ \n\n\n\nArrays.sort(arr); \n\nArrays.sort(dep); \n\n\n\n\n\n\nint\nplat_needed = \n1\n, result = \n1\n; \n\nint\ni = \n1\n, j = \n0\n; \n\n\n\n\n\n\nwhile\n(i < n && j < n) \n\n{ \n\n\n\n\n\nif\n(arr[i] <= dep[j]) \n\n{ \n\nplat_needed++; \n\ni++; \n\n\n\n\nif\n(plat_needed > result) \n\nresult = plat_needed; \n\n} \n\n\n\n\nelse\n\n{ \n\nplat_needed--; \n\nj++; \n\n} \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n900\n, \n940\n, \n950\n, \n1100\n, \n1500\n, \n1800\n}; \n\nint\ndep[] = {\n910\n, \n1200\n, \n1120\n, \n1130\n, \n1900\n, \n2000\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Minimum Number of Platforms Required = \"\n\n+ findPlatform(arr, dep, n)); \n} \n}", "index": 591, "complexity": "5"}
{"back-translation": "class GFG { static int getMinDiff(int arr[], int n, int k) { if (n == 1) return 0; Arrays.sort(arr); int ans = arr[n-1] - arr[0]; int small = arr[0] + k; int big = arr[n-1] - k; int temp = 0; if (small > big) { temp = small; small = big; big = temp; } for (int i = 1; i < n-1; i ++) { int subtract = arr[i] - k; int add = arr[i] + k; if (subtract >= small || add <= big) continue; if (big - subtract <= add - small) small = subtract; else big = add; } return Math.min(ans, big - small); } public static void main(String[] args) { int arr[] = {4, 6}; int n = arr.length; int k = 10; System.out.println(\"Maximum difference is \" + getMinDiff(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n\n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n\n\n\n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n}", "index": 592, "complexity": "5"}
{"back-translation": "class GFG { static int minOps(int arr[], int n, int k) { Arrays.sort(arr); int max = arr[arr.length - 1]; int res = 0; for (int i = 0; i < n; i++) { if ((max - arr[i]) % k != 0) return -1; else res += (max - arr[i]) / k; } return res; } public static void main(String[] args) { int arr[] = { 21, 33, 9, 45, 63 }; int n = arr.length; int k = 6; System.out.println(minOps(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\nstatic\nint\nminOps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nArrays.sort(arr); \n\nint\nmax = arr[arr.length - \n1\n]; \n\nint\nres = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n((max - arr[i]) % k != \n0\n) \n\nreturn\n-\n1\n; \n\n\n\n\nelse\n\nres += (max - arr[i]) / k; \n\n} \n\n\n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n21\n, \n33\n, \n9\n, \n45\n, \n63\n}; \n\nint\nn = arr.length; \n\nint\nk = \n6\n; \n\nSystem.out.println(minOps(arr, n, k)); \n\n} \n}", "index": 593, "complexity": "5"}
{"back-translation": "class GFG { static int minElements(int arr[], int n) { int halfSum = 0; for (int i = 0; i < n; i++) halfSum = halfSum + arr[i]; halfSum = halfSum / 2; Arrays.sort(arr); int res = 0, curr_sum = 0; for (int i = n-1; i >= 0; i--) { curr_sum += arr[i]; res++; if (curr_sum > halfSum) return res; } return res; } public static void main(String[] args) { int arr[] = {3, 1, 7, 1}; int n = arr.length; System.out.println(minElements(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nminElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nhalfSum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nhalfSum = halfSum + arr[i]; \n\nhalfSum = halfSum / \n2\n; \n\n\n\n\n\n\n\n\n\nArrays.sort(arr); \n\n\nint\nres = \n0\n, curr_sum = \n0\n; \n\nfor\n(\nint\ni = n-\n1\n; i >= \n0\n; i--) { \n\n\ncurr_sum += arr[i]; \n\nres++; \n\n\n\n\nif\n(curr_sum > halfSum) \n\nreturn\nres; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n3\n, \n1\n, \n7\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(minElements(arr, n)); \n\n} \n\n}", "index": 594, "complexity": "5"}
{"back-translation": "class Main {\n\nstatic void minAbsSumPair(int arr[], int n) {\n\nint sum, min_sum = 999999;\n\nint l = 0, r = n-1;\n\nint min_l = l, min_r = n-1;\n\nif (n < 2) {\n\nSystem.out.println(\"Invalid Input\");\n\nreturn;\n\n}\n\nsort(arr, l, r);\n\nwhile (l < r) {\n\nsum = arr[l] + arr[r];\n\nif (Math.abs(sum) < Math.abs(min_sum)) {\n\nmin_sum = sum;\n\nmin_l = l;\n\nmin_r = r;\n\n}\n\nif (sum < 0)\n\nl++;\n\nelse\n\nr--;\n\n}\n\nSystem.out.println(\" The two elements whose \"+\"sum is minimum are \"+ arr[min_l] + \" and \" + arr[min_r]);\n\n}\n\npublic static void main(String[] args) {\n\nint arr[] = {1, 60, -10, 70, -80, 85};\n\nint n = arr.length;\n\nminAbsSumPair(arr, n);\n\n}\n\nstatic int partition(int arr[], int low, int high) {\n\nint pivot = arr[high];\n\nint i = (low-1);\n\nfor (int j = low; j < high; j++) {\n\nif (arr[j] <= pivot) {\n\ni++;\n\nint temp = arr[i];\n\narr[i] = arr[j];\n\narr[j] = temp;\n\n}\n\n}\n\nint temp = arr[i+1];\n\narr[i+1] = arr[high];\n\narr[high] = temp;\n\nreturn i+1;\n\n}\n\nstatic void sort(int arr[], int low, int high) {\n\nif (low < high) {\n\nint pi = partition(arr, low, high);\n\nsort(arr, low, pi-1);\n\nsort(arr, pi+1, high);\n\n}\n\n}\n}", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nsum, min_sum = \n999999\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n\n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n\n\n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n\n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n\n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n\n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n\n\nint\npi = partition(arr, low, high); \n\n\n\n\n\n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n}", "index": 595, "complexity": "5"}
{"back-translation": "class GFG { public static void kLargest(Integer[] arr, int k) { Arrays.sort(arr, Collections.reverseOrder()); for(int i = 0; i < k; i++) System.out.print(arr[i] + \" \"); } public static void main(String[] args) { Integer arr[] = new Integer[] { 1, 23, 12, 9, 30, 2, 50 }; int k = 3; kLargest(arr, k); } }", "src": "class\nGFG { \n\npublic\nstatic\nvoid\nkLargest(Integer[] arr, \nint\nk) \n\n{ \n\n\n\n\n\n\n\n\n\nArrays.sort(arr, Collections.reverseOrder()); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[] { \n1\n, \n23\n, \n12\n, \n9\n, \n\n30\n, \n2\n, \n50\n}; \n\nint\nk = \n3\n; \n\nkLargest(arr, k); \n\n} \n}", "index": 596, "complexity": "5"}
{"back-translation": "class GFG { public static int kthSmallest(Integer[] arr, int k) { Arrays.sort(arr); return arr[k-1]; } public static void main(String[] args) { Integer arr[] = new Integer[]{12, 3, 5, 7, 19}; int k = 2; System.out.print(\"K'th smallest element is \"+ kthSmallest(arr, k)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\npublic\nstatic\nint\nkthSmallest(Integer [] arr, \n\nint\nk) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\nreturn\narr[k-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[]{\n12\n, \n3\n, \n5\n, \n7\n, \n19\n}; \n\nint\nk = \n2\n; \n\nSystem.out.print( \n\"K'th smallest element is \"\n+ \n\nkthSmallest(arr, k) ); \n\n} \n}", "index": 597, "complexity": "5"}
{"back-translation": "public class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[] a = new int[n + 1];\n        int[] b = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n\n        for (int i = 0; i < n; i++) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max = 1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n            mid /= 2;\n            boolean v = isValid(a, b, m, n, mid);\n\n            if (v) {\n                max = mid;\n            } else {\n                min = mid;\n            }\n            if (max - min <= ERROR && v) {\n\n                found = true;\n                break;\n            }\n            if (max == min) {\n                break;\n            }\n        }\n\n        if (found) {\n            System.out.println(max);\n        } else\n            System.out.println(-1);\n    }\n\n\n    static boolean isValid(int[] a, int[] b, int m, int n, double fuel) {\n        double total = m + fuel;\n        for (int i = 0; i < n; i++) {\n            double lost = total;\n            lost /= a[i];\n            total -= lost;\n\n            lost = total;\n            lost /= b[i + 1];\n            total -= lost;\n            if ((total - m) < 0) {\n                return false;\n            }\n        }\n        if ((total - m) < 0)\n            return false;\n        return true;\n    }\n}", "src": "public class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        for(int i =0; i< n; i++ ) {\n            a[i] = scanner.nextInt();\n        }\n\n        for(int i =0; i< n; i++ ) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             \n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 \n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        \n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;i++) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}", "index": 598, "complexity": "5"}
{"back-translation": "public class TransformedBigInteger7 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}", "src": "public class BigInteger7 {\n    public static void main(String[] args) {\n        \n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}", "index": 599, "complexity": "5"}
{"back-translation": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0){\n\t\t\tans = -1;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 600, "complexity": "5"}
{"back-translation": "class GFG { static int k = 16; static int N = 100000; static long table[][] = new long[N][k + 1]; static void buildSparseTable(int arr[], int n) { for (int i = 0; i < n; i++) table[i][0] = arr[i]; for (int j = 1; j <= k; j++) for (int i = 0; i <= n - (1 << j); i++) table[i][j] = table[i][j - 1] + table[i + (1 << (j - 1))][j - 1]; } static long query(int L, int R) { long answer = 0; for (int j = k; j >= 0; j--) { if (L + (1 << j) - 1 <= R) { answer = answer + table[L][j]; L += 1 << j; } } return answer; } public static void main(String args[]) { int arr[] = { 3, 7, 2, 5, 8, 9 }; int n = arr.length; buildSparseTable(arr, n); System.out.println(query(0, 5)); System.out.println(query(3, 5)); System.out.println(query(2, 4)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nk = \n16\n; \n\n\nstatic\nint\nN = \n100000\n; \n\n\n\nstatic\nlong\ntable[][] = \nnew\nlong\n[N][k + \n1\n]; \n\n\nstatic\nvoid\nbuildSparseTable(\nint\narr[], \n\nint\nn) \n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ntable[i][\n0\n] = arr[i]; \n\n\nfor\n(\nint\nj = \n1\n; j <= k; j++) \n\nfor\n(\nint\ni = \n0\n; i <= n - (\n1\n<< j); i++) \n\ntable[i][j] = table[i][j - \n1\n] + \n\ntable[i + (\n1\n<< (j - \n1\n))][j - \n1\n]; \n} \n\n\n\nstatic\nlong\nquery(\nint\nL, \nint\nR) \n{ \n\n\n\n\n\nlong\nanswer = \n0\n; \n\nfor\n(\nint\nj = k; j >= \n0\n; j--) \n\n{ \n\nif\n(L + (\n1\n<< j) - \n1\n<= R) \n\n{ \n\nanswer = answer + table[L][j]; \n\n\n\n\n\n\nL += \n1\n<< j; \n\n} \n\n} \n\nreturn\nanswer; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n3\n, \n7\n, \n2\n, \n5\n, \n8\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nbuildSparseTable(arr, n); \n\n\nSystem.out.println(query(\n0\n, \n5\n)); \n\nSystem.out.println(query(\n3\n, \n5\n)); \n\nSystem.out.println(query(\n2\n, \n4\n)); \n} \n}", "index": 601, "complexity": "5"}
{"back-translation": "public class winner\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        Map<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n                m.put(t,m.get(t)+1);\n            else\n                m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "index": 602, "complexity": "5"}
{"back-translation": "public class FlyBack {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[] a = new int[n + 1];\n        int[] b = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n\n        for (int i = 0; i < n; i++) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max = 1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n            mid /= 2;\n            boolean v = isValid(a, b, m, n, mid);\n\n            if (v) {\n                max = mid;\n            } else {\n                min = mid;\n            }\n            if (max - min <= ERROR && v) {\n\n                found = true;\n                break;\n            }\n            if (max == min) {\n                break;\n            }\n        }\n\n        if (found) {\n            System.out.println(max);\n        } else System.out.println(-1);\n    }\n\n    static boolean isValid(int[] a, int[] b, int m, int n, double fuel) {\n        double total = m + fuel;\n        for (int i = 0; i < n; i++) {\n            double lost = total;\n            lost /= a[i];\n            total -= lost;\n\n            lost = total;\n            lost /= b[i + 1];\n            total -= lost;\n            if ((total - m) < 0) {\n                return false;\n            }\n        }\n        if ((total - m) < 0) return false;\n        return true;\n    }\n}", "src": "public class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        for(int i =0; i< n; i++ ) {\n            a[i] = scanner.nextInt();\n        }\n\n        for(int i =0; i< n; i++ ) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             \n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 \n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        \n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;i++) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}", "index": 603, "complexity": "5"}
{"back-translation": "public class BigInteger7 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.compareTo(k) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}", "src": "public class BigInteger7 {\n    public static void main(String[] args) {\n        \n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}", "index": 604, "complexity": "5"}
{"back-translation": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar[] s = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif (k == 0) continue;\n\t\t\tif (x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif (k > 0) ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 605, "complexity": "5"}
{"back-translation": "class GFG { static int getMinDiff(int[] arr, int n, int k) { if (n == 1) return 0; Arrays.sort(arr); int ans = arr[n - 1] - arr[0]; int small = arr[0] + k; int big = arr[n - 1] - k; int temp = 0; if (small > big) { temp = small; small = big; big = temp; } for (int i = 1; i < n - 1; i++) { int subtract = arr[i] - k; int add = arr[i] + k; if (subtract >= small || add <= big) continue; if (big - subtract <= add - small) small = subtract; else big = add; } return Math.min(ans, big - small); } public static void main(String[] args) { int arr[] = {4, 6}; int n = arr.length; int k = 10; System.out.println(\"Maximum difference is \" + getMinDiff(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n\n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n\n\n\n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n}", "index": 606, "complexity": "5"}
{"back-translation": "public class Main implements Runnable {static class InputReader {private InputStream stream;private byte[] buf = new byte[1024];private int curChar;private int numChars;private SpaceCharFilter filter;private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));public InputReader(InputStream stream) {this.stream = stream;}public int read() {if (numChars==-1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try {numChars = stream.read(buf);}catch (IOException e) {throw new InputMismatchException();}if(numChars <= 0) return -1;}return buf[curChar++];}public String nextLine() {String str = \"\";try {str = br.readLine();}catch (IOException e) {e.printStackTrace();}return str;}public int nextInt() {int c = read();while(isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') {sgn = -1;c = read();}int res = 0;do {if(c<'0'||c>'9') throw new InputMismatchException();res *= 10;res += c - '0';c = read();}while (!isSpaceChar(c));return res * sgn;}public long nextLong() {int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') {sgn = -1;c = read();}long res = 0;do {if (c < '0' || c > '9') throw new InputMismatchException();res *= 10;res += c - '0';c = read();}while (!isSpaceChar(c));return res * sgn;}public double nextDouble() {int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') {sgn = -1;c = read();}double res = 0;while (!isSpaceChar(c) && c != '.') {if (c == 'e' || c == 'E') return res * Math.pow(10, nextInt());if (c < '0' || c > '9') throw new InputMismatchException();res *= 10;res += c - '0';c = read();}if (c == '.') {c = read();double m = 1;while (!isSpaceChar(c)) {if (c == 'e' || c == 'E') return res * Math.pow(10, nextInt());if (c < '0' || c > '9') throw new InputMismatchException();m /= 10;res += (c - '0') * m;c = read();}}return res * sgn;}public String readString() {int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();}public boolean isSpaceChar(int c) {if (filter != null) return filter.isSpaceChar(c);return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;}public String next() {return readString();}public interface SpaceCharFilter {public boolean isSpaceChar(int ch);}}public static void main(String args[]) throws Exception {new Thread(null, new Main(),", "src": "public class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n             \n            int n=sc.nextInt();\n            long s=sc.nextLong();\n            long arr[]=new long[n];\n            int i=0;\n            for(i=0;i<n;i++)\n            {\n                              arr[i]=sc.nextLong();\n            }\n            Arrays.sort(arr);\n            \n            \n            long count=0;\n            if(arr[n/2]==s)\n            {\n                              \n                              w.print(0);\n            }\n            else\n            {\n                              int temp=n/2;\n                              \n                              if(arr[temp]>s)\n                              {\n                                                while(arr[temp]>s)\n                                                {\n                                                                  count=count+(arr[temp]-s);\n                                                                  temp--;\n                                                                  if(temp<0)\n                                                                  {\n                                                                                    break;\n                                                                  }\n                                                }\n                              }\n                              else\n                              {\n                                               \n                                               while(arr[temp]<s)\n                                               {\n                                                                 \n                                                                 count=count+(s-arr[temp]);\n                                                                 temp++;\n                                                                 if(temp>=n)\n                                                                 {\n                                                                                   break;\n                                                                 }\n                                               }\n                              }\n                              w.print(count);\n            }\n            \n               \n               \n\n        w.close();\n    }\n}", "index": 607, "complexity": "5"}
{"back-translation": "public class gambling_back {\n    public static void main(String[] args) throws IOException{\n        Reader rd = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = rd.nextInt();\n        Integer[] a = new Integer[n];\n        Integer[] b = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = rd.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = rd.nextInt();\n        }\n        solve(n, a, b, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, Integer[] a, Integer[] b, PrintWriter out) {\n        Arrays.sort(a, Collections.reverseOrder());\n        Arrays.sort(b, Collections.reverseOrder());\n        int aP = 0, bP = 0;\n        long aScore = 0, bScore = 0;\n        for (int i = 0; i < 2 * n; i++) {\n                if(i % 2 == 0) {\n                    if(bP == n || (aP < n && a[aP] > b[bP])){\n                        aScore += a[aP];\n                        aP++;\n                    }\n                    else bP++;\n                }\n                else{\n                    if(aP == n || (bP < n && b[bP] > a[aP])) {\n                        bScore += b[bP];\n                        bP++;\n                    }\n                    else aP++;\n                }\n        }\n        out.println(aScore-bScore);\n    }\n\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; \n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}", "src": "public class gambling {\n    public static void main(String[] args) throws IOException{\n        Reader rd = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = rd.nextInt();\n        Integer[] a = new Integer[n];\n        Integer[] b = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = rd.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = rd.nextInt();\n        }\n        solve(n, a, b, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, Integer[] a, Integer[] b, PrintWriter out) {\n        Arrays.sort(a, Collections.reverseOrder());\n        Arrays.sort(b, Collections.reverseOrder());\n        int aP = 0, bP = 0;\n        long aScore = 0, bScore = 0;\n        for (int i = 0; i < n * 2; i++) {\n                if(i % 2 == 0) {\n                    if(bP ==  n || (aP < n && a[aP] > b[bP])){\n                        aScore += a[aP];\n                        aP++;\n                    }\n                    else bP++;\n                }\n                else{\n                    if(aP == n || (bP < n && b[bP] > a[aP])) {\n                        bScore += b[bP];\n                        bP++;\n                    }\n                    else aP++;\n                }\n        }\n        out.println(aScore-bScore);\n    }\n\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; \n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}", "index": 608, "complexity": "5"}
{"back-translation": "public class cf {\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n\n    static int mod = 1000000007;\n    \n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out); \n\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int[] a = new int[n + 1];\n\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        a[n] = 0;\n        Arrays.sort(a);\n\n        for (int i = 1; i <= n; i++) {\n            if (k == 0) {\n                break;\n            }\n            if (a[i] != a[i - 1]) {\n                k--;\n                pw.println(a[i] - a[i - 1]);\n            }\n        }\n        for (int i = 0; i < k; i++) pw.println(0);\n        pw.close();\n    }\n}", "src": "public class cf {\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n\n    static int mod = 1000000007;\n    \n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out); \n\n        int n=sc.nextInt(), k = sc.nextInt();\n        int[] a = new int[n+1];\n\n        for(int i=0;i<n;i++) {\n            a[i] = sc.nextInt();\n        }\n        a[n] = 0;\n        Arrays.sort(a);\n\n        for(int i=1;i<=n;i++) {\n            if(k == 0) {\n                break;\n            }\n            if(a[i] != a[i-1]) {\n                k--;\n                pw.println(a[i] - a[i-1]);\n            }\n        }\n        for(int i=0;i<k;i++) pw.println(0);\n        pw.close();\n    }\n}", "index": 609, "complexity": "5"}
{"back-translation": "public class Box {\n\n    public static void main(String[] ars) {\n\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        int max = 0;\n\n        HashMap<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            int x = s.nextInt();\n            if (!map.containsKey(x)) {\n                map.put(x, 1);\n                max = Math.max(max, 1);\n            } else {\n                map.put(x, map.get(x) + 1);\n                max = Math.max(max, map.get(x));\n            }\n        }\n\n        System.out.println(max);\n    }\n\n}", "src": "public class bOX {\n\n    public static void main(String ars[]){\n\n        Scanner  s = new Scanner(System.in);\n        int n = s.nextInt();\n        int max = 0;\n\n        Map<Integer,Integer> map = new HashMap<>();\n\n        for(int i=0;i<n;i++){\n            int x = s.nextInt();\n            if(!map.containsKey(x)){\n                map.put(x,1);\n                max = Math.max(max,1);\n            }\n            else{\n                map.put(x,map.get(x)+1);\n                max = Math.max(max,map.get(x));\n            }\n        }\n\n        System.out.println(max);\n    }\n\n}", "index": 610, "complexity": "5"}
{"back-translation": "class GFG { static int findMinDiff(int[] arr, int n) { Arrays.sort(arr); int diff = Integer.MAX_VALUE; for (int i = 0; i < n - 1; i++) if (arr[i + 1] - arr[i] < diff) diff = arr[i + 1] - arr[i]; return diff; } public static void main(String[] args) { int arr[] = new int[]{ 1, 5, 3, 19, 18, 25 }; System.out.println(\"Minimum difference is \" + findMinDiff(arr, arr.length)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nfindMinDiff(\nint\n[] arr, \nint\nn) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\nif\n(arr[i+\n1\n] - arr[i] < diff) \n\ndiff = arr[i+\n1\n] - arr[i]; \n\n\n\n\nreturn\ndiff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n5\n, \n3\n, \n19\n, \n18\n, \n25\n}; \n\nSystem.out.println(\n\"Minimum difference is \"\n+ \n\nfindMinDiff(arr, arr.length)); \n\n\n} \n}", "index": 611, "complexity": "5"}
{"back-translation": "public class RadioStation {\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n    public static StringTokenizer st;\n    \n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        int m = nextInt();\n        Map<String, String> map = new HashMap<String, String>();\n        for (int i = 0; i < n; i++) {\n            String s = nextString();\n            String t = nextString();\n            map.put(t, s);\n        }\n        for (int i = 0; i < m; i++) {\n            String s = nextString();\n            String t = nextString();\n            System.out.println(s + \" \" + t + \" #\" + map.get(t.substring(0, t.length()-1)));\n        }\n    }\n    \n    public static String nextLine() throws IOException {\n        return in.readLine();\n    }\n\n    public static String nextString() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(in.readLine());\n        return st.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(nextString());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(nextString());\n    }\n\n    public static int[] intArray(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextInt();\n        return a;\n    }\n\n    public static int[][] intArray(int n, int m) throws IOException {\n        int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                a[i][j] = nextInt();\n        return a;\n    }\n\n    public static long[] longArray(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nextLong();\n        return a;\n    }\n}", "src": "public class RadioStation {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tmap.put(t, s);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tSystem.out.println(s + \" \" + t + \" #\" + map.get(t.substring(0, t.length()-1)));\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 612, "complexity": "5"}
{"back-translation": "class AlternativeString {\n\n    static void alternateSort(int[] arr, int n) {\n        Arrays.sort(arr);\n        int i = 0, j = n-1;\n        while (i < j) {\n            System.out.print(arr[j--] + \" \");\n            System.out.print(arr[i++] + \" \");\n        }\n        if (n % 2 != 0)\n            System.out.print(arr[i]);\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {1, 12, 4, 6, 7, 10};\n        int n = arr.length;\n        alternateSort(arr, n);\n    }\n}", "src": "class\nAlternativeString \n{ \n\n\n\nstatic\nvoid\nalternateSort(\nint\narr[], \nint\nn) \n\n{ \n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\n\n\nint\ni = \n0\n, j = n-\n1\n; \n\nwhile\n(i < j) { \n\nSystem.out.print(arr[j--] + \n\" \"\n); \n\nSystem.out.print(arr[i++] + \n\" \"\n); \n\n} \n\n\n\n\n\n\nif\n(n % \n2\n!= \n0\n) \n\nSystem.out.print(arr[i]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, \n4\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nalternateSort(arr, n); \n\n} \n}", "index": 613, "complexity": "5"}
{"back-translation": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int height = in.nextInt();\n            int width = in.nextInt();\n            int n1 = in.nextInt();\n            int n2 = in.nextInt();\n            int v = in.nextInt();\n            int[] p1 = new int[n1];\n            for (int i = 0; i < n1; ++i) p1[i] = in.nextInt();\n            int[] p2 = new int[n2];\n            for (int i = 0; i < n2; ++i) p2[i] = in.nextInt();\n            int nq = in.nextInt();\n            for (int iq = 0; iq < nq; ++iq) {\n                int r1 = in.nextInt();\n                int c1 = in.nextInt();\n                int r2 = in.nextInt();\n                int c2 = in.nextInt();\n                if (r1 == r2) {\n                    out.println(Math.abs(c1 - c2));\n                } else {\n                    long res = Long.MAX_VALUE;\n                    int pos = Arrays.binarySearch(p1, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    pos = Arrays.binarySearch(p2, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    out.println(res);\n                }\n            }\n        }\n\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int height = in.nextInt();\n            int width = in.nextInt();\n            int n1 = in.nextInt();\n            int n2 = in.nextInt();\n            int v = in.nextInt();\n            int[] p1 = new int[n1];\n            for (int i = 0; i < n1; ++i) p1[i] = in.nextInt();\n            int[] p2 = new int[n2];\n            for (int i = 0; i < n2; ++i) p2[i] = in.nextInt();\n            int nq = in.nextInt();\n            for (int iq = 0; iq < nq; ++iq) {\n                int r1 = in.nextInt();\n                int c1 = in.nextInt();\n                int r2 = in.nextInt();\n                int c2 = in.nextInt();\n                if (r1 == r2) {\n                    out.println(Math.abs(c1 - c2));\n                } else {\n                    long res = Long.MAX_VALUE;\n                    int pos = Arrays.binarySearch(p1, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    pos = Arrays.binarySearch(p2, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    out.println(res);\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}", "index": 614, "complexity": "5"}
{"back-translation": "class GFG { static void rearrange(int[] arr, int n, int x) { TreeMap<Integer, ArrayList<Integer>> m = new TreeMap<>(); for(int i = 0; i < n; i++) { int diff = Math.abs(x - arr[i]); if(m.containsKey(diff)) { ArrayList<Integer> al = m.get(diff); al.add(arr[i]); m.put(diff, al); } else { ArrayList<Integer> al = new ArrayList<>(); al.add(arr[i]); m.put(diff, al); } } int index = 0; for(Map.Entry entry : m.entrySet()) { ArrayList<Integer> al = m.get(entry.getKey()); for(int i = 0; i < al.size(); i++) arr[index++] = al.get(i); } } static void printArray(int[] arr, int n) { for(int i = 0; i < n; i++) System.out.print(arr[i] + ", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nvoid\nrearrange(\nint\n[] arr, \nint\nn, \nint\nx) \n\n{ \n\nTreeMap<Integer, ArrayList<Integer>> m = \nnew\nTreeMap<>(); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndiff = Math.abs(x - arr[i]); \n\nif\n(m.containsKey(diff)) \n\n{ \n\nArrayList<Integer> al = m.get(diff); \n\nal.add(arr[i]); \n\nm.put(diff, al); \n\n} \n\nelse\n\n{ \n\nArrayList<Integer> al = \nnew\nArrayList<>(); \n\nal.add(arr[i]); \n\nm.put(diff,al); \n\n} \n\n} \n\n\n\n\nint\nindex = \n0\n; \n\nfor\n(Map.Entry entry : m.entrySet()) \n\n{ \n\nArrayList<Integer> al = m.get(entry.getKey()); \n\nfor\n(\nint\ni = \n0\n; i < al.size(); i++) \n\narr[index++] = al.get(i); \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\n[] arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[] arr = {\n10\n, \n5\n, \n3\n, \n9\n,\n2\n}; \n\nint\nn = arr.length; \n\nint\nx = \n7\n; \n\nrearrange(arr, n, x); \n\nprintArray(arr, n); \n\n} \n}", "index": 615, "complexity": "5"}
{"back-translation": "public class LessorEqual_CodeForces {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String temp[]=br.readLine().split(\" \");\n        int n = Integer.parseInt(temp[0]);\n        int k = Integer.parseInt(temp[1]);\n        temp=br.readLine().split(\" \");\n        int [] num = new int[n];\n\n        PriorityQueue<Integer>pq = new PriorityQueue<Integer>();\n        for(int i=0;i<n;i++){\n            num[i]=Integer.parseInt(temp[i]);\n            pq.add(num[i]);\n\n        }\n        if(k==0){\n            int y= pq.poll();\n            if(y==1){\n                System.out.println(-1);\n                System.exit(0);\n            }\n            else \n                {\n                System.out.println(y-1);\n                System.exit(0);\n            }\n\n        }\n\n        int count=0;\n        int max=0;\n        while (!pq.isEmpty()){\n            int x = pq.poll();\n            while(count<=k&&!pq.isEmpty()&& pq.peek()==x){\n                pq.poll();\n                count++;\n            }\n\n            count++;\n            max=x;\n            if(count==k)\n                break;\n        }\n\n        if(count==k){\n            if(!pq.contains(max+1)&& max<1e9)\n                System.out.println(max+1);\n            else \n                System.out.println(max);\n            }\n        else \n            System.out.println(-1);\n\n    }\n\n}", "src": "public class LessorEqual_CodeForces {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString temp[]=br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(temp[0]);\n\t\tint k = Integer.parseInt(temp[1]);\n\t\ttemp=br.readLine().split(\" \");\n\t\tint [] num = new int[n];\n\n\t\tPriorityQueue<Integer>pq = new PriorityQueue<Integer>();  \n\t\tfor(int i=0;i<n;i++){\n\t\t\tnum[i]=Integer.parseInt(temp[i]);\n\t\t\tpq.add(num[i]);\n\t\t\n\t\t\t\t\t\t\n\t\t}\n\t\tif(k==0){\n\t\t\tint y= pq.poll();\n\t\t\tif(y==1){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\tSystem.out.println(y-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tint count=0;\n\t\tint max=0;\n\t\twhile (!pq.isEmpty()){\n\t\t\tint x = pq.poll();\n\t\t\twhile(count<=k&&!pq.isEmpty()&& pq.peek()==x){\n\t\t\t\tpq.poll();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\n\t\t\tcount++;\n\t\t\tmax=x;\n\t\t\tif(count==k)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\tif(count==k){\n\t\t\tif(!pq.contains(max+1)&& max<1e9)\n\t\t\t\tSystem.out.println(max+1);\n\t\t\telse \n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\telse \n\t\t\tSystem.out.println(-1);\n \n\t\t\n\t}\n\n}", "index": 616, "complexity": "5"}
{"back-translation": "public class JavaApplication7 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        long sum = 0;\n        long[] d = new long[n];\n        long[] ds = new long[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = sc.nextLong();\n            sum += d[i];\n            ds[i] = sum;\n        }\n        long[] le = new long[m];\n        for (int i = 0; i < m; i++) {\n            le[i] = sc.nextLong();\n        }\n        int l = 0;\n        int h = n;\n        int k = (h - l) / 2;\n        k += l;\n        for (int i = 0; i < m; i++) {\n            l = 0;\n            h = n;\n            k = (h - l) / 2;\n            k += l;\n            for (; l <= h; ) {\n                k = (h - l) / 2;\n                k += l;\n                if (ds[k] < le[i]) {\n                    l = k + 1;\n                } else if (ds[k] == le[i]) {\n                    break;\n                } else {\n                    h = k - 1;\n                }\n            }\n            if (ds[k] < le[i]) {\n                k++;\n            }\n            if (k == 0) {\n                System.out.println((int) (k + 1) + \" \" + le[i]);\n            } else {\n                System.out.println((int) (k + 1) + \" \" + (long) (le[i] - ds[k - 1]));\n            }\n        }\n    }\n}", "src": "public class JavaApplication7 {\n\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n= sc.nextInt();\n        int m=sc.nextInt();\n        long sum=0;\n        long []d=new long[n];\n        long[]ds=new long[n];\n        for(int i =0;i<n;i++){\n            d[i]=sc.nextLong();\n            sum+=d[i];\n            ds[i]=sum;\n        }\n        long[]le=new long[m];\n        for(int i =0;i<m;i++){\n            le[i]=sc.nextLong();\n        }\n        int l=0;\n        int h=n;\n        int k=(h-l)/2;\n        k+=l;\n        for(int i=0;i<m;i++){\n        l=0;\n        h=n;\n        k=(h-l)/2;\n        k+=l;\n            for(;l<=h;){\n                k=(h-l)/2;\n                k+=l;\n                if(ds[k]<le[i]){\n                    l=k+1;\n                }\n                else if(ds[k]==le[i]){break;}\n                else{\n                    h=k-1;\n                }\n            }\n            \n            if(ds[k]<le[i]){\n                    k++;\n                }\n          if(k==0){\n              System.out.println((int)(k+1)+\" \"+le[i]);\n           }\n            else{\n                System.out.println((int)(k+1)+\" \"+(long)(le[i]-ds[k-1]));\n           }\n        }\n        \n    }\n    \n}", "index": 617, "complexity": "5"}
{"back-translation": "public class CodeforcesFinal {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        List<Integer> list = new ArrayList<Integer>();\n        for (int i = 0; i < n; i++) {\n            int temp = sc.nextInt();\n            list.add(temp);\n        }\n        Collections.sort(list);\n        if (n % 2 == 0) {\n            System.out.println(list.get((n / 2) - 1));\n        } else {\n            System.out.println(list.get(n / 2));\n        }\n    }\n}", "src": "public final class Codeforces\n{\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    Scanner sc=new Scanner(System.in);\n\t\t\tint n=sc.nextInt();\n\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint temp=sc.nextInt();\n\t\t\t\tlist.add(temp);\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\tif(n%2==0)\n\t\t\tSystem.out.println(list.get((n/2)-1));\n\t\t\telse\n\t\t\tSystem.out.println(list.get(n/2));\n\t}\n}", "index": 618, "complexity": "5"}
{"back-translation": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n / 2];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(p));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] p) {\n\t\tint total = 0;\n\t\tArrays.sort(p);\n\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\ttotal += Math.abs(p[i] - (i * 2 + 1));\n\t\t}\n\n\t\tint total2 = 0;\n\t\tArrays.sort(p);\n\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\ttotal2 += Math.abs(p[i] - (i * 2 + 2));\n\t\t}\n\n\t\treturn Math.min(total, total2);\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n / 2];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(p));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] p) {\n\t\treturn Math.min(computeMoveNum(p, 1), computeMoveNum(p, 2));\n\t}\n\n\tstatic int computeMoveNum(int[] p, int offset) {\n\t\tArrays.sort(p);\n\n\t\treturn IntStream.range(0, p.length).map(i -> Math.abs(p[i] - (i * 2 + offset))).sum();\n\t}\n}", "index": 619, "complexity": "5"}
{"back-translation": "ERROR", "src": "public class Sol {\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tInteger[] a = new Integer[n*k];\n\t\tfor(int i = 0; i < n*k; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tif (a[n - 1] - a[0] > l) {\n\t\t\tout.println(0);\n\t\t} else {\n\t\t\tint maxPos = n*k - 1;\n\t\t\tfor (int i = 0; i < n*k; i++) {\n\t\t\t\tif (a[i] - a[0] > l) {\n\t\t\t\t\tmaxPos = i-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong o = a[0];\n\t\t\tint s = 0;\n\t\t\tint t = 1;\n\t\t\tfor (int i = 1; i <= maxPos; i++) {\n\t\t\t\t\n\t\t\t\tif (s < k - 1 && maxPos-i+1 > n-t) {\n\t\t\t\t\t\n\t\t\t\t\ts++;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\ts = 0;\n\t\t\t\t\tt++;\n\t\t\t\t\to += a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(o);\n\t\t}\n\t\tout.close();\n\t}\n\n\t\n\tpublic static PrintWriter out;\n\n\t\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t}\n\t\n}", "index": 620, "complexity": "5"}
{"back-translation": "public class MicroWorld {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        Integer[] a = new Integer[n];\n\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n\n        Arrays.sort(a);\n\n        int count = 1;\n        int remaining = n;\n        for (int i = 0; i < n - 1; i++) {\n            if ((int) a[i] == (int) a[i + 1]) {\n                count++;\n                continue;\n            }\n            if ((a[i] + k) >= a[i + 1]) {\n                remaining -= count;\n            }\n            count = 1;\n        }\n        System.out.println(remaining);\n    }\n}", "src": "public class MicroWorld {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        Integer[] a = new Integer[n];\n\n        st = new StringTokenizer(br.readLine());\n        for(int i=0; i<n; i++){\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n\n        Arrays.sort(a);\n\n        int count = 1;\n        int remaining = n;\n        for(int i=0; i<n-1; i++){\n            if((int)a[i] == (int)a[i+1]){\n                count++;\n                continue;\n            }\n            if((a[i] + k) >= a[i+1]){\n                remaining -= count;\n            }\n            count = 1;\n        }\n        System.out.println(remaining);\n    }\n}", "index": 621, "complexity": "5"}
{"back-translation": "public class gr1 {\n\n    class InputReader {\n        BufferedReader br;\n        StringTokenizer token;\n\n        InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n            token = null;\n        }\n\n        String next() {\n            while (token == null || !token.hasMoreTokens()) {\n                try {\n                    token = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    class card {\n        long a;\n        int cnt;\n        int i;\n\n        card(long a, int cnt, int i) {\n            this.a = a;\n            this.cnt = cnt;\n            this.i = i;\n        }\n    }\n\n    class ascend implements Comparator<pair> {\n        public int compare(pair o1, pair o2) {\n            if (o1.b != o2.b)\n                return (int) (o1.b - o2.b);\n            else\n                return (int) (o1.a - o2.a);\n        }\n    }\n\n    class extra {\n\n        void shuffle(long a[]) {\n            List<Long> l = new ArrayList<>();\n            for (int i = 0; i < a.length; i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for (int i = 0; i < a.length; i++)\n                a[i] = l.get(i);\n        }\n\n        long gcd(long a, long b) {\n            if (b == 0)\n                return a;\n            else\n                return gcd(b, a % b);\n        }\n\n        boolean valid(int i, int j, int r, int c) {\n            if (i >= 0 && i < r && j >= 0 && j < c)\n                return true;\n            else\n                return false;\n        }\n\n        boolean v[] = new boolean[100001];\n        List<Integer> l = new ArrayList<>();\n        int t;\n\n        void seive() {\n            for (int i = 2; i < 100001; i++) {\n                if (!v[i]) {\n                    t++;\n                    l.add(i);\n                    for (int j = 2 * i; j < 100001; j += i)\n                        v[j] = true;\n                }\n            }\n        }\n\n        int binary(pair a[], int val, int n) {\n            int mid = 0, l = 0, r = n - 1, ans = 0;\n            while (l <= r) {\n                mid = (l + r) >> 1;\n                if (a[mid].a == val) {\n                    r = mid - 1;\n                    ans = mid;\n                } else if (a[mid].a > val)\n                    r = mid - 1;\n                else {\n                    l = mid + 1;\n                    ans = l;\n                }\n            }\n            return (ans);\n        }\n    }\n\n    class pair {\n        long a;\n        int b;\n\n        pair(long a, int n) {\n            this.a = a;\n            this.b = n;\n        }\n    }\n\n    InputReader sc = new InputReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        solver s = new solver();\n        int t = 1;\n        while (t > 0) {\n            s.solve();\n            t--;\n        }\n    }\n\n    class solver {\n        void solve() {\n            int n = sc.nextInt();\n            int a[] = new int[n];\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n                sum += a[i];\n            }\n            Arrays.sort(a);\n            int k = (int) Math.round(4.5 * n) - sum;\n\n            if (k <= 0) {\n                System.out.println(0);\n            } else {\n                int p = 0, ans = 0;\n                for (int i = 0; i < n; i++) {\n                    if (a[i] != 5) {\n                        p += 5 - a[i];\n                        if (p >= k) {\n                            ans++;\n                            System.out.println(ans);\n                            break;\n                        }\n                        ans++;\n                    }\n                }\n            }\n        }\n    }\n}", "src": "public class gr1 {\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class card{\n        long a;\n        int cnt;\n        int i;\n        public card(long a,int cnt,int i)\n        {\n            this.a=a;\n            this.cnt=cnt;\n            this.i=i;\n        }\n    }\n\n    static class ascend implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.b!=o2.b)\n                return (int)(o1.b-o2.b);\n            else \n                return (int)(o1.a-o2.a);\n        }\n    }\n\n    \n\n    static class extra\n    {\n\n        static void shuffle(long a[])\n        {\n            List<Long> l=new ArrayList<>();\n            for(int i=0;i<a.length;i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for(int i=0;i<a.length;i++)\n                a[i]=l.get(i);\n        }\n\n        static long gcd(long a,long b)\n        {\n            if(b==0)\n                return a;\n            else\n                return gcd(b,a%b);\n        }\n\n        static boolean valid(int i,int j,int r,int c)\n        {\n            if(i>=0 && i<r && j>=0 && j<c)\n                return true;\n            else\n                return false;\n        }\n\n        static boolean v[]=new boolean[100001];\n        static List<Integer> l=new ArrayList<>();\n        static int t;\n        static void seive()\n        {\n            for(int i=2;i<100001;i++)\n            {\n                if(!v[i])\n                {\n                    t++;\n                    l.add(i);\n                    for(int j=2*i;j<100001;j+=i)\n                        v[j]=true;\n                }\n            }\n        }\n\n        static int binary(pair a[],int val,int n)\n        {\n            int mid=0,l=0,r=n-1,ans=0;\n            while(l<=r)\n            {\n                mid=(l+r)>>1;\n                if(a[mid].a==val)\n                {\n                    r=mid-1;\n                    ans=mid;\n                }\n                else if(a[mid].a>val)\n                    r=mid-1;\n                else\n                {\n                    l=mid+1;\n                    ans=l;\n                }\n            }\n            return (ans);\n        }\n    }\n\n    static class pair{\n        long a;\n        int b;\n        public pair(long a,int n)\n        {\n            this.a=a;\n            this.b=n;\n        }\n    }\n    static InputReader sc=new InputReader(System.in);\n    static PrintWriter out=new PrintWriter(System.out);\n    public static void main(String[] args) {\n        solver s=new solver();\n        int t=1;\n        while(t>0)\n        {\n            s.solve();\n            t--;\n        }\n    }\n    static class solver\n    {\n        void solve()\n        {\n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int sum=0;\n            for(int i=0;i<n;i++)\n            {\n                a[i]=sc.nextInt();\n                sum+=a[i];\n            }\n            Arrays.sort(a);\n            int k=(int)Math.round(4.5*n)-sum;\n           \n            if(k<=0)\n            {\n                System.out.println(0);\n            }\n            else\n            {\n                int p=0,ans=0;\n                for(int i=0;i<n;i++)\n                {\n                    if(a[i]!=5)\n                    {\n                        p+=5-a[i];\n                        if(p>=k){\n                            ans++;\n                            System.out.println(ans);\n                            break;\n                        }\n                        ans++;\n                    }\n                }\n            }\n        }\n    }\n}", "index": 622, "complexity": "5"}
{"back-translation": "class Test {\n\nstatic int mergeSort(int arr[], int array_size) {\nint temp[] = new int[array_size];\nreturn _mergeSort(arr, temp, 0, array_size - 1);\n}\n\nstatic int _mergeSort(int arr[], int temp[], int left, int right) {\nint mid, inv_count = 0;\nif (right > left) {\nmid = (right + left) / 2;\ninv_count = _mergeSort(arr, temp, left, mid);\ninv_count += _mergeSort(arr, temp, mid + 1, right);\ninv_count += merge(arr, temp, left, mid + 1, right);\n}\nreturn inv_count;\n}\n\nstatic int merge(int arr[], int temp[], int left, int mid, int right) {\nint i, j, k;\nint inv_count = 0;\ni = left;\nj = mid;\nk = left;\nwhile ((i <= mid - 1) && (j <= right)) {\nif (arr[i] <= arr[j]) {\ntemp[k++] = arr[i++];\n}\nelse {\ntemp[k++] = arr[j++];\ninv_count = inv_count + (mid - i);\n}\n}\nwhile (i <= mid - 1) {\ntemp[k++] = arr[i++];\n}\nwhile (j <= right) {\ntemp[k++] = arr[j++];\n}\nfor (i = left; i <= right; i++) {\narr[i] = temp[i];\n}\nreturn inv_count;\n}\n\npublic static void main(String[] args) {\nint arr[] = new int[] {1, 20, 6, 4, 5};\nSystem.out.println(\"Number of inversions are \" + mergeSort(arr, 5));\n}\n}", "src": "class\nTest { \n\n\n\n\nstatic\nint\nmergeSort(\nint\narr[], \nint\narray_size) \n\n{ \n\nint\ntemp[] = \nnew\nint\n[array_size]; \n\nreturn\n_mergeSort(arr, temp, \n0\n, array_size - \n1\n); \n\n} \n\n\n\n\nstatic\nint\n_mergeSort(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nright) \n\n{ \n\nint\nmid, inv_count = \n0\n; \n\nif\n(right > left) { \n\n\n\nmid = (right + left) / \n2\n; \n\n\n\n\ninv_count = _mergeSort(arr, temp, left, mid); \n\ninv_count += _mergeSort(arr, temp, mid + \n1\n, right); \n\n\n\n\ninv_count += merge(arr, temp, left, mid + \n1\n, right); \n\n} \n\nreturn\ninv_count; \n\n} \n\n\n\n\nstatic\nint\nmerge(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nmid, \nint\nright) \n\n{ \n\nint\ni, j, k; \n\nint\ninv_count = \n0\n; \n\n\ni = left; \n\n\nj = mid; \n\n\nk = left; \n\n\nwhile\n((i <= mid - \n1\n) && (j <= right)) { \n\nif\n(arr[i] <= arr[j]) { \n\ntemp[k++] = arr[i++]; \n\n} \n\nelse\n{ \n\ntemp[k++] = arr[j++]; \n\n\n\n\ninv_count = inv_count + (mid - i); \n\n} \n\n} \n\n\n\n\nwhile\n(i <= mid - \n1\n) \n\ntemp[k++] = arr[i++]; \n\n\n\n\nwhile\n(j <= right) \n\ntemp[k++] = arr[j++]; \n\n\n\n\nfor\n(i = left; i <= right; i++) \n\narr[i] = temp[i]; \n\n\nreturn\ninv_count; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\nSystem.out.println(\n\"Number of inversions are \"\n+ mergeSort(arr, \n5\n)); \n\n} \n}", "index": 623, "complexity": "5"}
{"back-translation": "class Main { static void minAbsSumPair(int arr[], int n) { int sum, min_sum = 999999; int l = 0, r = n-1; int min_l = l, min_r = n-1; if (n < 2) { System.out.println(\"Invalid Input\"); return; } sort(arr, l, r); while (l < r) { sum = arr[l] + arr[r]; if (Math.abs(sum) < Math.abs(min_sum)) { min_sum = sum; min_l = l; min_r = r; } if (sum < 0) l++; else r--; } System.out.println(\" The two elements whose \"+ \"sum is minimum are \"+ arr[min_l]+ \" and \"+ arr[min_r]); } public static void main (String[] args) { int arr[] = {1, 60, -10, 70, -80, 85}; int n = arr.length; minAbsSumPair(arr, n); } static int partition(int arr[], int low, int high) { int pivot = arr[high]; int i = (low-1); for (int j=low; j<high; j++) { if (arr[j] <= pivot) { i++; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } int temp = arr[i+1]; arr[i+1] = arr[high]; arr[high] = temp; return i+1; } static void sort(int arr[], int low, int high) { if (low < high) { int pi = partition(arr, low, high); sort(arr, low, pi-1); sort(arr, pi+1, high); } } }", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nsum, min_sum = \n999999\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n\n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n\n\n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n\n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n\n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n\n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n\n\nint\npi = partition(arr, low, high); \n\n\n\n\n\n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n}", "index": 624, "complexity": "5"}
{"back-translation": "public class Test {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = reader.readLine().split(\" \");\n        int w = Integer.valueOf(line[0]);\n        int h = Integer.valueOf(line[1]);\n        int n = Integer.valueOf(line[2]);\n\n        Request[] requests = generate(w, h, n);\n\n        for (Request request : requests) {\n            System.out.println(request.type + \" \" + request.coordinate);\n        }\n    }\n\n    private static Request[] generate(int w, int h, int n) {\n        Request[] requests = new Request[n];\n        Random rnd = new Random();\n\n        for (int i = 0; i < n; i++) {\n            requests[i] = rnd.nextBoolean() ? new Request(\"V\", rnd.nextInt(w)) : new Request(\"H\", rnd.nextInt(h));\n        }\n\n        return requests;\n    }\n\n    private static class Request {\n\n        private final String type;\n\n        private final int coordinate;\n\n        public Request(String type, int coordinate) {\n            this.type = type;\n            this.coordinate = coordinate;\n        }\n    }\n}", "src": "public class Test {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = reader.readLine().split(\" \");\n        int w = Integer.valueOf(line[0]);\n        int h = Integer.valueOf(line[1]);\n        int n = Integer.valueOf(line[2]);\n\n        Request[] requests = new Request[n];\n\n        for (int i = 0; i < n; i++) {\n            line = reader.readLine().split(\" \");\n            requests[i] = new Request(line[0], Integer.valueOf(line[1]));\n        }\n\n        for (long e : solve(h, w, requests))\n            System.out.println(e);\n\n\n\n\n\n\n\n\n\n    }\n\n    private static Request[] generate(int w, int h, int n) {\n        Request[] requests = new Request[n];\n        Random rnd = new Random();\n\n        for (int i = 0; i < n; i++) {\n            requests[i] = rnd.nextBoolean() ? new Request(\"V\", rnd.nextInt(w)) : new Request(\"H\", rnd.nextInt(h));\n        }\n\n        return requests;\n    }\n\n    private static long[] solve(int h, int w, Request[] requests) {\n        TreeSet<Integer> hTree = new TreeSet<>();\n        TreeSet<Integer> wTree = new TreeSet<>();\n\n        Queue<CoordinateWithSize> hHeap = new PriorityQueue<>();\n        Queue<CoordinateWithSize> wHeap = new PriorityQueue<>();\n\n        hTree.add(0);\n        hTree.add(h);\n        wTree.add(0);\n        wTree.add(w);\n\n        hHeap.add(new CoordinateWithSize(0, h));\n        wHeap.add(new CoordinateWithSize(0, w));\n\n        long[] res = new long[requests.length];\n        for (int i = 0; i < requests.length; i++) {\n            Request request = requests[i];\n\n            switch (request.type) {\n                case \"H\": {\n                    if (!hTree.contains(request.coordinate)) {\n                        int higher = hTree.higher(request.coordinate);\n                        int lower = hTree.lower(request.coordinate);\n\n                        hHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        hHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        hTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                case \"V\": {\n                    if (!wTree.contains(request.coordinate)) {\n                        int higher = wTree.higher(request.coordinate);\n                        int lower = wTree.lower(request.coordinate);\n\n                        wHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        wHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        wTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                default:\n                    throw new IllegalStateException(\"Unknown type [type=\" + request.type + \"]\");\n            }\n\n            while (true) {\n                CoordinateWithSize c = hHeap.peek();\n                if (hTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                hHeap.remove();\n            }\n\n            while (true) {\n                CoordinateWithSize c = wHeap.peek();\n                if (wTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                wHeap.remove();\n            }\n\n            res[i] = 1L * hHeap.peek().size * wHeap.peek().size;\n        }\n\n        return res;\n    }\n\n    private static class CoordinateWithSize implements Comparable<CoordinateWithSize> {\n\n        private final int coordinate;\n\n        private final int size;\n\n        public CoordinateWithSize(int coordinate, int size) {\n            this.coordinate = coordinate;\n            this.size = size;\n        }\n\n        @Override public int compareTo(CoordinateWithSize o) {\n            return Integer.compare(o.size, size);\n        }\n    }\n\n    private static class Request {\n\n        private final String type;\n\n        private final int coordinate;\n\n        public Request(String type, int coordinate) {\n            this.type = type;\n            this.coordinate = coordinate;\n        }\n    }\n}", "index": 625, "complexity": "5"}
{"back-translation": "import java.io.*;\nimport java.util.*;\n\nclass Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        InputReader.OutputWriter out = new InputReader.OutputWriter(outputStream);\n\n\n        int n = in.nextInt();\n        int s = in.nextInt();\n        Lift[] lifts = new Lift[n];\n        for (int i = 0; i < n; i++) {\n            lifts[i] = new Lift(in.nextInt(), in.nextInt());\n        }\n        Arrays.sort(lifts, (x, y) -> y.getLevel() - x.getLevel());\n\n        int ans = 0;\n        for (int i = 0; i < lifts.length; i++) {\n            Lift current = lifts[i];\n            ans += s - current.getLevel();\n            if (current.getTime() > ans) {\n                ans += current.getTime() - ans;\n            }\n            s = current.getLevel();\n        }\n        ans += s;\n        out.println(ans);\n        out.flush();\n    }\n}\n\nclass Lift {\n\n    int level;\n    int time;\n\n    public int getLevel() {\n        return level;\n    }\n\n    public int getTime() {\n        return time;\n    }\n\n    public Lift(int level, int time) {\n        this.level = level;\n        this.time = time;\n    }\n}\n\nclass InputReader extends BufferedReader {\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputStream) {\n        super(new InputStreamReader(inputStream), 32768);\n    }\n\n    public InputReader(String filename) {\n        super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(readLine());\n            } catch (IOException e) {\n                throw new RuntimeException();\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public Integer nextInt() {\n        return Integer.valueOf(next());\n    }\n\n    public Long nextLong() {\n        return Long.valueOf(next());\n    }\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        InputReader.OutputWriter out = new InputReader.OutputWriter(outputStream);\n\n\n        int n = in.nextInt();\n        int s = in.nextInt();\n        Lift [] lifts = new Lift[n];\n        for (int i = 0; i < n; i++) {\n            lifts[i] = new Lift(in.nextInt(),in.nextInt());\n        }\n        Arrays.sort(lifts,(x,y)->y.getLevel() - x.getLevel());\n        \n        int ans = 0;\n        for (int i = 0; i < lifts.length; i++) {\n            Lift current = lifts[i];\n            ans+=s-current.getLevel();\n            if(current.getTime()>ans) {\n                ans+=current.getTime() - ans;\n            }\n            s = current.getLevel();\n        }\n        ans+=s;\n        out.println(ans);\n        out.flush();\n    }\n}\n\nclass Lift {\n\n    int level;\n    int time;\n\n    public int getLevel() {\n        return level;\n    }\n\n    public int getTime() {\n        return time;\n    }\n\n    public Lift(int level, int time) {\n        this.level = level;\n        this.time = time;\n    }\n}\n\nclass InputReader extends BufferedReader {\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputStream) {\n        super(new InputStreamReader(inputStream), 32768);\n    }\n\n    public InputReader(String filename) {\n        super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(readLine());\n            } catch (IOException e) {\n                throw new RuntimeException();\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public Integer nextInt() {\n        return Integer.valueOf(next());\n    }\n    public Long nextLong() {return  Long.valueOf(next());}\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n    }\n}", "index": 626, "complexity": "5"}
{"back-translation": "class Main { static class FastScanner { BufferedReader br; StringTokenizer st; public FastScanner() { try { br = new BufferedReader(new InputStreamReader(System.in)); st = new StringTokenizer(br.readLine()); } catch (Exception e) { e.printStackTrace(); } } public String next() { if (st.hasMoreTokens()) return st.nextToken(); try { st = new StringTokenizer(br.readLine()); } catch (Exception e) { e.printStackTrace(); } return st.nextToken(); } public int nextInt() { return Integer.parseInt(next()); } public long nextLong() { return Long.parseLong(next()); } public double nextDouble() { return Double.parseDouble(next()); } public String nextLine() { String line = \"\"; if (st.hasMoreTokens()) line = st.nextToken(); else try { return br.readLine(); } catch (IOException e) { e.printStackTrace(); } while (st.hasMoreTokens()) line += \" \" + st.nextToken(); return line; } } static class Pair { int a; int b; public Pair(int a, int b) { this.a = a; this.b = b; } } public static void main(String[] args) { FastScanner sc = new FastScanner(); PrintWriter pw = new PrintWriter(System.out); int n = sc.nextInt(); int floor = sc.nextInt(); int time = 0; Pair[] arr = new Pair[n]; for (int i = 0; i < n; i++) arr[i] = new Pair(sc.nextInt(), sc.nextInt()); Arrays.sort(arr, new Comparator<Pair>() { public int compare(Pair cur, Pair other) { return other.a - cur.a; } }); for (int i = 0; i < n; i++) { time += floor - arr[i].a; floor = arr[i].a; time = Math.max(time, arr[i].b); } time += arr[n - 1].a; pw.println(time); pw.close(); } }", "src": "public class Main {\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n    static class Pair {\n        int a;\n        int b;\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int floor = sc.nextInt();\n        int time = 0;\n\n        Pair[] arr = new Pair[n];\n        for(int i=0;i<n;i++) arr[i] = new Pair(sc.nextInt(), sc.nextInt());\n\n        Arrays.sort(arr, (Pair cur, Pair other) -> (other.a - cur.a));\n\n        for(int i=0;i<n;i++) {\n            time += floor - arr[i].a;\n            floor = arr[i].a;\n            time = Math.max(time, arr[i].b);\n            \n        }\n\n        time += arr[n-1].a;\n\n        pw.println(time);\n        pw.close();\n    }\n}", "index": 627, "complexity": "5"}
