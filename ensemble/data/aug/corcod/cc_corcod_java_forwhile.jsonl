{"forwhile": "public class Codechef\n{     \n  static String reverse(String s){\n    String reverse=\"\";\n    int i=s.length()-1;\n    while(i>=0){\n        reverse=reverse + s.charAt(i);\n        i--;\n    }\n    return reverse;\n  }\n\n      \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc=new Scanner(System.in);\n         int n=sc.nextInt();\n         int m=sc.nextInt();\n         int x=m%(int)Math.pow(2,n);\n         System.out.println(x);\n\n\n\n}\n}", "src": "public class Codechef\n{     \n  static String reverse(String s){\n    String reverse=\"\";\n    for(int i=s.length()-1;i>=0;i--){\n        reverse=reverse + s.charAt(i);\n    }\n    return reverse;\n  }\n\n      \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc=new Scanner(System.in);\n         int n=sc.nextInt();\n         int m=sc.nextInt();\n         int x=m%(int)Math.pow(2,n);\n         System.out.println(x);\n\n\n\n}\n}", "index": 2, "complexity": "0"}
{"forwhile": "public class C\n{\n\n\tstatic StringBuilder st = new StringBuilder();\n\t\n\tpublic static void main(String[] args) throws Exception \n\t{\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint [] freq = new int [5] ; \n\t\tint k = 3;  \n\t\tfor(; k-- > 0;) {\n\t\t\tint x = sc.nextInt();\n\t\t\tif(x <= 4) freq[x]++;\n\t\t}\n\t\tfreq[2] += freq[4]/ 2 ;\n\t\tif(freq[1] >= 1 || freq[2] >= 2 || freq[3] >= 3)\n\t\t\tout.println(\"YES\");\n\t\telse\n\t\t\tout.println(\"NO\");\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in) \n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\tfor(; st == null || !st.hasMoreTokens();) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n}", "src": "public class C\n{\n\n\tstatic StringBuilder st = new StringBuilder();\n\t\n\tpublic static void main(String[] args) throws Exception \n\t{\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint [] freq = new int [5] ; \n\t\t\n\t\tint k = 3;  \n\t\twhile(k -- >0)\n\t\t{\n\t\t\tint x = sc.nextInt();\n\t\t\t\n\t\t\tif(x <= 4) freq[x]++;\n\t\t\t\n\t\t}\n\t\tfreq[2] += freq[4]/ 2 ;\n\t\t\n\t\tif(freq[1] >= 1 || freq[2] >= 2 || freq[3] >= 3)\n\t\t\tout.println(\"YES\");\n\t\telse\n\t\t\tout.println(\"NO\");\n\t\t\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in) \n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws Exception {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws Exception {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws Exception {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n}", "index": 4, "complexity": "0"}
{"forwhile": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\tfor(; st == null || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())){\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\tfor(; !(st == null || !st.hasMoreTokens()); st = new StringTokenizer(in.readLine())){\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\tfor (; !(st == null || !st.hasMoreTokens()); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn Integer.parseInt(st.nextToken());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\tfor (; !(st == null || !st.hasMoreTokens()); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn Long.parseLong(st.nextToken());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\twhile(i < n){\n\t\t\ta[i] = nextInt();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\twhile(i < n){\n\t\t\tint j = 0;\n\t\t\twhile(j < m){\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\twhile(i < n){\n\t\t\ta[i] = nextLong();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 5, "complexity": "0"}
{"forwhile": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;sc.hasNext();) {\n\t\tint n = sc.nextInt();\n\t\tint pos = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\t\n\t\tif(l==1&&r==n) {\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(l==1&&r<n) {\n\t\t\tSystem.out.println(Math.abs(r-pos)+1);\n\t\t}\n\t\telse if(l>1&&r==n) {\n\t\t\tSystem.out.println(Math.abs(l-pos)+1);\n\t\t}\n\t\telse if(l>1&&r<n) {\n\t\t\tint c = Math.min(Math.abs(r-pos), Math.abs(l-pos));\n\t\t\tSystem.out.println(c+2+r-l);\n\t\t}\n\t\t}\n\t}\t\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\tint n = sc.nextInt();\n\t\tint pos = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\t\n\t\tif(l==1&&r==n) {\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse if(l==1&&r<n) {\n\t\t\tSystem.out.println(Math.abs(r-pos)+1);\n\t\t}\n\t\telse if(l>1&&r==n) {\n\t\t\tSystem.out.println(Math.abs(l-pos)+1);\n\t\t}\n\t\telse if(l>1&&r<n) {\n\t\t\tint c = Math.min(Math.abs(r-pos), Math.abs(l-pos));\n\t\t\tSystem.out.println(c+2+r-l);\n\t\t}\n\t\t}\n\t}\t\n}", "index": 9, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class A {\n\tstatic FastReader scan;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tSolver solver = new Solver();\n\t\tscan = new FastReader();\n\t\tout = new PrintWriter(System.out);\n\t\tint testCases = 1;\n\t\tfor(int i = 1; i <= testCases; i++) {\n\n\t\t\tsolver.solve();\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic class Solver {\n\t\t\n\t\tvoid solve() {\n\t\t\tint a = scan.nextInt(), b = scan.nextInt();\n\t\t\tif(b <= a) out.println(1);\n\t\t\telse out.println(b/a + Math.min(1, b%a));\n\t\t}\n\t\t\n\t}\n\n\t\n\n\tstatic class DSU {\n\t\tint[] root, size;\n\t\tint n;\n\n\t\tDSU(int n) {\n\t\t\tthis.n = n;\n\t\t\troot = new int[n];\n\t\t\tsize = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\troot[i] = i;\n\t\t\t\tsize[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tint findParent(int idx) {\n\t\t\twhile (root[idx] != idx) {\n\t\t\t\troot[idx] = root[root[idx]];\n\t\t\t\tidx = root[idx];\n\t\t\t}\n\t\t\treturn idx;\n\t\t}\n\n\t\tboolean union(int x, int y) {\n\t\t\tint parX = findParent(x);\n\t\t\tint parY = findParent(y);\n\t\t\tif (parX == parY)\n\t\t\t\treturn false;\n\t\t\tif (size[parX] < size[parY]) {\n\t\t\t\troot[parY] = parX;\n\t\t\t\tsize[parX] += size[parY];\n\t\t\t} else {\n\t\t\t\troot[parX] = parY;\n\t\t\t\tsize[parY] += size[parX];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic class Extra {\n\t\tstatic void sort(int[] a) {\n\t\t\tInteger[] aa = new Integer[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(long[] a) {\n\t\t\tLong[] aa = new Long[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(double[] a) {\n\t\t\tDouble[] aa = new Double[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(char[] a) {\n\t\t\tCharacter[] aa = new Character[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic long gcd(long a, long b) {\n\t\t\twhile (b > 0) {\n\t\t\t\tlong temp = b;\n\t\t\t\tb = a % b;\n\t\t\t\ta = temp;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n\n\t\tstatic boolean isPrime(long n) {\n\t\t\tif (n <= 1)\n\t\t\t\treturn false;\n\t\t\tif (n <= 3)\n\t\t\t\treturn true;\n\t\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\t\treturn false;\n\t\t\tfor (long i = 5; i * i <= n; i = i + 6) {\n\t\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tstatic HashSet<Integer> sieve(int n) {\n\t\t\tboolean[] prime = new boolean[n + 1];\n\t\t\tHashSet<Integer> res = new HashSet<>();\n\t\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\tif (!prime[p]) {\n\t\t\t\t\tres.add(p);\n\t\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\t\tprime[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic HashMap<Long, Integer> primeFactorization(long n) {\n\t\t\tHashMap<Long, Integer> res = new HashMap<>();\n\t\t\twhile (n % 2 == 0) {\n\t\t\t\tres.put(2L, res.getOrDefault(2L, 0) + 1);\n\t\t\t\tn /= 2;\n\t\t\t}\n\t\t\tfor (long i = 3; i * i <= n; i += 2) {\n\t\t\t\twhile (n % i == 0) {\n\t\t\t\t\tres.put(i, res.getOrDefault(i, 0) + 1);\n\t\t\t\t\tn /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n > 2)\n\t\t\t\tres.put(n, 1);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] a = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextDouble();\n\t\t\treturn a;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n}", "index": 10, "complexity": "0"}
{"forwhile": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 11, "complexity": "0"}
{"forwhile": "public class EhabAndAnotherConstructionProblem {\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n    public static StringTokenizer st;\n    \n    public static void main(String[] args) throws IOException {\n        int x = nextInt();\n        System.out.println(x == 1 ? -1 : x + \" \" + x);\n    }\n    \n    public static String nextLine() throws IOException {\n        return in.readLine();\n    }\n\n    public static String nextString() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(nextString());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(nextString());\n    }\n\n    public static int[] intArray(int n) throws IOException {\n        int[] a = new int[n];\n        int i = 0;\n        while (i < n) {\n            a[i] = nextInt();\n            i++;\n        }\n        return a;\n    }\n\n    public static int[][] intArray(int n, int m) throws IOException {\n        int[][] a = new int[n][m];\n        int i = 0;\n        while (i < n) {\n            int j = 0;\n            while (j < m) {\n                a[i][j] = nextInt();\n                j++;\n            }\n            i++;\n        }\n        return a;\n    }\n\n    public static long[] longArray(int n) throws IOException {\n        long[] a = new long[n];\n        int i = 0;\n        while (i < n) {\n            a[i] = nextLong();\n            i++;\n        }\n        return a;\n    }\n}", "src": "public class EhabAndAnotherConstructionProblem {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint x = nextInt();\n\t\tSystem.out.println(x == 1 ? -1 : x + \" \" + x);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 16, "complexity": "0"}
{"forwhile": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        long l = Math.max(1, k - n), r = (k + 1) / 2;\n        l = Math.max(0, r - l);\n        pw.print(l);\n\n    }\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        for(; tokenizer == null || !tokenizer.hasMoreTokens();) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        for(; tokenizer == null || !tokenizer.hasMoreTokens();) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "src": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        long l = Math.max(1, k - n), r = (k + 1) / 2;\n        l = Math.max(0, r - l);\n        pw.print(l);\n\n    }\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "index": 17, "complexity": "0"}
{"forwhile": "public class B \n{\n\t\n\tstatic StringBuilder st ; \n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner sc = new Scanner () ;\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tString first = \"\" ; \n\t\tString second = \"\" ; \n\t\t\n\t\t\n\t\tint i = 0 ;\n\t\twhile (i < 126)\n\t\t{\n\t\t\tfirst += \"9\";\n\t\t\tsecond += \"9\";\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tint j = 0;\n\t\twhile (j < 125)\n\t\t{\n\t\t\tfirst += \"0\";\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tfirst += \"1\";\n\t\t\n\t\tout.println(first+\" \"+second);\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t\n\t}\n\t\n\tstatic int sumDigits(int num)\n\t{\n\t\tint ans = 0 ;\n\t\t\n\t\tfor (;num > 0;)\n\t\t{\n\t\t\tans += num % 10  ;\n\t\t\t\n\t\t\tnum /= 10;\n\t\t}\n\t\t\n\t\treturn ans ;\n\t\t\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\n\t\tString next() throws Exception \n\t\t{\n\t\t\tfor (; st == null || !st.hasMoreTokens();)\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception { return Integer.parseInt(next()); }\n\t\t\n\t\tlong nextLong() throws Exception { return Long.parseLong(next()); }\n\n\t\tdouble nextDouble() throws Exception { return Double.parseDouble(next()); }\n\n\t\tchar nextChar() throws Exception { return next().charAt(0); }\n\t\t\n\t\tchar [] nextCharArray() throws Exception{ return next().toCharArray() ; }\n\t}\n\n}", "src": "public class B \n{\n\t\n\tstatic StringBuilder st ; \n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tScanner sc = new Scanner () ;\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tString first = \"\" ; \n\t\tString second = \"\" ; \n\t\t\n\t\t\n\t\tfor(int i = 0 ; i < 126 ;i++ )\n\t\t{\n\t\t\tfirst+= \"9\";\n\t\t\tsecond+=\"9\";\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < 125 ;i++ )\n\t\t\tfirst+= \"0\";\n\t\t\n\t\tfirst += \"1\";\n\t\t\n\t\tout.println(first+\" \"+second);\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t\n\t}\n\t\n\tstatic int sumDigits(int num)\n\t{\n\t\tint ans = 0 ;\n\t\t\n\t\twhile(num > 0)\n\t\t{\n\t\t\tans += num % 10  ;\n\t\t\t\n\t\t\tnum /= 10;\n\t\t}\n\t\t\n\t\treturn ans ;\n\t\t\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\n\t\tString next() throws Exception \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws Exception { return Integer.parseInt(next()); }\n\t\t\n\t\tlong nextLong() throws Exception { return Long.parseLong(next()); }\n\n\t\tdouble nextDouble() throws Exception { return Double.parseDouble(next()); }\n\n\t\tchar nextChar() throws Exception { return next().charAt(0); }\n\t\t\n\t\tchar [] nextCharArray() throws Exception{ return next().toCharArray() ; }\n\t}\n\n}", "index": 18, "complexity": "0"}
{"forwhile": "public class A_KingEscape {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            int Qx = inp.nextInt(), Qy = inp.nextInt();\n            int Kx = inp.nextInt(), Ky = inp.nextInt();\n            int Tx = inp.nextInt(), Ty = inp.nextInt();\n            if (((Kx < Qx && Tx < Qx) || (Kx > Qx && Tx > Qx)) && ((Ky < Qy && Ty < Qy) || (Ky > Qy && Ty > Qy))) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            for(; tokenizer == null || !tokenizer.hasMoreTokens(); tokenizer = new StringTokenizer(reader.readLine())) {\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "src": "public class A_KingEscape {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            int Qx = inp.nextInt(), Qy = inp.nextInt();\n            int Kx = inp.nextInt(), Ky = inp.nextInt();\n            int Tx = inp.nextInt(), Ty = inp.nextInt();\n            if (((Kx < Qx && Tx < Qx) || (Kx > Qx && Tx > Qx)) && ((Ky < Qy && Ty < Qy) || (Ky > Qy && Ty > Qy))) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 20, "complexity": "0"}
{"forwhile": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        pw.print((n + k - 1) / n);\n\n    }\n\n    private static void Qsort(int[] array, int low, int high) {\n\n        int i = low;\n        int j = high;\n        int x = array[low + (high - low) / 2];\n\n        do {\n            for(; array[i] < x;) {\n                i++;\n            }\n            for(; array[j] > x;) {\n                j--;\n            }\n            if (i <= j) {\n                int tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                i++;\n                j--;\n            }\n        } while (i <= j);\n\n        if (low < j) Qsort(array, low, j);\n        if (i < high) Qsort(array, i, high);\n\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "src": "public class A1008 {\n    public static void main(String [] args)  {\n        InputStream inputReader = System.in;\n        OutputStream outputReader = System.out;\n        InputReader in = new InputReader(inputReader);\n        PrintWriter out = new PrintWriter(outputReader);\n        Algorithm solver = new Algorithm();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Algorithm {\n    void solve(InputReader ir, PrintWriter pw) {\n\n        long n = ir.nextLong(), k = ir.nextLong();\n        pw.print((n + k - 1) / n);\n\n    }\n\n    private static void Qsort(int[] array, int low, int high) {\n\n        int i = low;\n        int j = high;\n        int x = array[low + (high - low) / 2];\n\n        do {\n            while (array[i] < x) ++i;\n            while (array[j] > x) --j;\n            if (i <= j) {\n                int tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                i++;\n                j--;\n            }\n        } while (i <= j);\n\n        if (low < j) Qsort(array, low, j);\n        if (i < high) Qsort(array, i, high);\n\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    String nextLine(){\n        String fullLine = null;\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                fullLine = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return fullLine;\n        }\n        return fullLine;\n    }\n\n    String [] toArray() {\n        return nextLine().split(\" \");\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}", "index": 22, "complexity": "0"}
{"forwhile": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          for(; st == null || !st.hasMoreElements(); ) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n      int highestcoin=param.nextInt();\n      int sum=param.nextInt();\n      int remainder=sum%highestcoin;\n      if(remainder!=0){\n         remainder=1;\n      }\n      else{\n         remainder=0;\n      }\n      int count=(sum-remainder)/highestcoin;\n     \n       if (highestcoin>=sum){\n         System.out.println(\"1\");\n      }\n      else{\n      System.out.println(count+remainder);\n      }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 23, "complexity": "0"}
{"forwhile": "public class Main {\n\n    public static void main(String[] args) {\n        SpeedScanner speedScanner = new SpeedScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        taskSolver(speedScanner, out);\n        out.close();\n    }\n\n\n    public static void taskSolver(SpeedScanner speedScanner, PrintWriter out) {\n        long n = speedScanner.nextLong();\n        long m = speedScanner.nextLong();\n        long k = speedScanner.nextLong();\n        long l = speedScanner.nextLong();\n\n        long tempM ;\n\n        if ((k+l) < m){\n            for(long i = 0; i < 1; i++) {\n                if (n < m)\n                    out.print(-1);\n                else\n                    out.print(1);\n            }\n        }else {\n            tempM = (k+l)/m;\n            if ((k+l)%m == 0){\n                for(long i = 0; i < 1; i++) {\n                    if (tempM*m <= n)\n                        out.print(tempM);\n                    else\n                        out.print(-1);\n                }\n            }else {\n                for(long i = 0; !((tempM+1)*m <= n); tempM++) {\n                    if ((tempM+1)*m <= n)\n                        out.print(tempM+1);\n                    else\n                        out.print(-1);\n                }\n            }\n        }\n    }\n\n\n    public static class SpeedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public SpeedScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            for(String token = null; token==null || !st.hasMoreElements(); ) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n}", "src": "public class Main {\n\n    public static void main(String[] args) {\n        SpeedScanner speedScanner = new SpeedScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        taskSolver(speedScanner, out);\n        out.close();\n    }\n\n\n    public static void taskSolver(SpeedScanner speedScanner, PrintWriter out) {\n        long n = speedScanner.nextLong();\n        long m = speedScanner.nextLong();\n        long k = speedScanner.nextLong();\n        long l = speedScanner.nextLong();\n\n        long tempM ;\n\n        if ((k+l) < m){\n            if (n<m)\n                out.print(-1);\n            else\n                out.print(1);\n        }else {\n            tempM = (k+l)/m;\n            if ((k+l)%m == 0){\n                if (tempM*m <= n)\n                    out.print(tempM);\n                else\n                    out.print(-1);\n            }else {\n                if ((tempM+1)*m <= n)\n                    out.print(tempM+1);\n                else\n                    out.print(-1);\n            }\n        }\n    }\n\n\n    public static class SpeedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public SpeedScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n\n}", "index": 24, "complexity": "0"}
{"forwhile": "public class Main {\n\n    static StringBuilder data;\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt();\n        long answ = 0;\n        if (n * 2 > k) {\n            if((n*2)%k==0){\n                answ+=(n*2)/k;\n            }else{\n                answ+=((n*2)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n        if (n * 5 > k) {\n            if((n*5)%k==0){\n                answ+=(n*5)/k;\n            }else{\n                answ+=((n*5)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n        if (n * 8 > k) {\n            if((n*8)%k==0){\n                answ+=(n*8)/k;\n            }else{\n                answ+=((n*8)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            for(; st == null || !st.hasMoreElements(); ) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "src": "public class Main {\n\n    static StringBuilder data;\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt();\n               long answ = 0;\n        if (n * 2 > k) {\n         if((n*2)%k==0){\n             answ+=(n*2)/k;\n         }else{\n             answ+=((n*2)/k)+1;\n         }\n        }else{\n            answ++;\n        }\n        if (n * 5 > k) {\n            if((n*5)%k==0){\n                answ+=(n*5)/k;\n            }else{\n                answ+=((n*5)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n        if (n * 8 > k) {\n            if((n*8)%k==0){\n                answ+=(n*8)/k;\n            }else{\n                answ+=((n*8)/k)+1;\n            }\n        }else{\n            answ++;\n        }\n\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 25, "complexity": "0"}
{"forwhile": "public class bhaa {\n\n    InputStream is;\n    PrintWriter o;\n    \n\n\n\n    boolean chpr(int n)\n    {\n    \tif(n==1)\n    \t{\n    \t\treturn true;\n    \t}if(n==2)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n==3)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n%2==0)\n    \t{\n    \t\treturn false;\n\n    \t}\n    \tif(n%3==0)\n    \t{\n    \t\treturn false;\n    \t}\n    \t\n    \tint w=2;\n \t\tint i=5;\n    for(; i*i<=n; i+=w,w=6-w) \n    \t{\n    \t\tif(n%i==0)\n    \t\t{\n    \t\t\treturn false;\n    \t\t}\n    \t}\n    \treturn true;\n\n    }\n    \n    void solve() {\n\n\n        int n=ni();\n        int k=ni();\n        int rr=2*n;\n        int gr=5*n;\n        int br=8*n;\n        o.println((long)(Math.ceil(rr*1.0/k)+Math.ceil(gr*1.0/k)+Math.ceil(br*1.0/k)));\n\n\n\n    \t\n\n    }\n\n\n\n\n\n   \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    public static void main(String[] args) { new bhaa().run(); }\n    void run() { \n        is = System.in; \n        o = new PrintWriter(System.out);\n        solve();\n        o.flush();\n    }\n    \n    byte input[] = new byte[1024];\n    int len = 0, ptr = 0;\n    \n    int readByte() { \n        if(ptr >= len) { ptr = 0; \n            try { len = is.read(input); } \n            catch(IOException e) { throw new InputMismatchException(); } \n            if(len <= 0) { return -1; } \n        } return input[ptr++];\n    }\n    boolean isSpaceChar(int c) { return !( c >= 33 && c <= 126 ); }\n    int skip() { \n        int b = readByte(); \n        while(b != -1 && isSpaceChar(b)) { b = readByte(); } \n        return b;\n    }\n    \n    char nc() { return (char)skip(); }\n    String ns() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while(!isSpaceChar(b)) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    String nLine() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while( !(isSpaceChar(b) && b != ' ') ) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    int ni() { \n        int n = 0, b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        if(b == -1) { return -1; }  \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n    long nl() { \n        long n = 0L;    int b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n\n    double nd() { return Double.parseDouble(ns()); }\n    float nf() { return Float.parseFloat(ns()); }\n    int[] nia(int n) { \n        int a[] = new int[n]; \n        for(int i = 0; i < n; i++) { a[i] = ni(); } \n        return a;\n    }\n    long[] nla(int n) { \n        long a[] = new long[n]; \n        for(int i = 0; i < n; i++) { a[i] = nl(); } \n        return a;\n    }\n    int [][] nim(int n)\n    {\n        int mat[][]=new int[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=ni();\n            }\n        }\n        return mat;\n    }\n    long [][] nlm(int n)\n    {\n        long mat[][]=new long[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=nl();\n            }\n        }\n        return mat;\n    }\n    \n\n\n\n\n    \n    char[] ns(int n) { \n        char c[] = new char[n]; \n        int i, b = skip(); \n        for(i = 0; i < n; i++) { \n            if(isSpaceChar(b)) { break; } \n            c[i] = (char)b; b = readByte(); \n        } return i == n ? c : Arrays.copyOf(c,i);\n    }\n    void piarr(int arr[])\n    {\n        int i=0;\n        while(i<arr.length)\n        {\n            o.print(arr[i]+\" \");\n            i++;\n\n        }\n        o.println();\n    }\n    void plarr(long arr[])\n    {\n        int i=0;\n        while(i<arr.length)\n        {\n            o.print(arr[i]+\" \");\n            i++;\n\n        }\n        o.println();\n    }\n    \n    void pimat(int mat[][])\n    {\n        int i=0;\n        while(i<mat.length)\n        {\n            int j=0;\n            while(j<mat[0].length)\n            {\n                o.print(mat[i][j]);\n                j++;\n            }\n            o.println();\n            i++;\n        }\n    }\n    void plmat(long mat[][])\n    {\n        int i=0;\n        while(i<mat.length)\n        {\n            int j=0;\n            while(j<mat[0].length)\n            {\n                o.print(mat[i][j]);\n                j++;\n            }\n            o.println();\n            i++;\n        }\n\n    }\n\n\n\n\n    \n\n\n\n}", "src": "public class bhaa {\n\n    InputStream is;\n    PrintWriter o;\n    \n\n\n\n    boolean chpr(int n)\n    {\n    \tif(n==1)\n    \t{\n    \t\treturn true;\n    \t}if(n==2)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n==3)\n    \t{\n    \t\treturn true;\n    \t}\n    \tif(n%2==0)\n    \t{\n    \t\treturn false;\n\n    \t}\n    \tif(n%3==0)\n    \t{\n    \t\treturn false;\n    \t}\n    \t\n    \tint w=2;\n \t\tint i=5;\n    \twhile(i*i<=n)\n    \t{\n    \t\tif(n%i==0)\n    \t\t{\n    \t\t\treturn false;\n    \t\t}\n    \t\ti+=w;\n    \t\tw=6-w;\n    \t}\n    \treturn true;\n\n    }\n    \n    void solve() {\n\n\n        int n=ni();\n        int k=ni();\n        int rr=2*n;\n        int gr=5*n;\n        int br=8*n;\n        o.println((long)(Math.ceil(rr*1.0/k)+Math.ceil(gr*1.0/k)+Math.ceil(br*1.0/k)));\n\n\n\n    \t\n\n    }\n\n\n\n\n\n   \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    public static void main(String[] args) { new bhaa().run(); }\n    void run() { \n        is = System.in; \n        o = new PrintWriter(System.out);\n        solve();\n        o.flush();\n    }\n    \n    byte input[] = new byte[1024];\n    int len = 0, ptr = 0;\n    \n    int readByte() { \n        if(ptr >= len) { ptr = 0; \n            try { len = is.read(input); } \n            catch(IOException e) { throw new InputMismatchException(); } \n            if(len <= 0) { return -1; } \n        } return input[ptr++];\n    }\n    boolean isSpaceChar(int c) { return !( c >= 33 && c <= 126 ); }\n    int skip() { \n        int b = readByte(); \n        while(b != -1 && isSpaceChar(b)) { b = readByte(); } \n        return b;\n    }\n    \n    char nc() { return (char)skip(); }\n    String ns() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while(!isSpaceChar(b)) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    String nLine() { \n        int b = skip(); \n        StringBuilder sb = new StringBuilder(); \n        while( !(isSpaceChar(b) && b != ' ') ) { sb.appendCodePoint(b); b = readByte(); } \n        return sb.toString();\n    }\n    int ni() { \n        int n = 0, b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        if(b == -1) { return -1; }  \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n    long nl() { \n        long n = 0L;    int b = readByte(); \n        boolean minus = false; \n        while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')) { b = readByte(); } \n        if(b == '-') { minus = true; b = readByte(); } \n        while(b >= '0' && b <= '9') { n = n * 10 + (b - '0'); b = readByte(); } \n        return minus ? -n : n;\n    }\n\n    double nd() { return Double.parseDouble(ns()); }\n    float nf() { return Float.parseFloat(ns()); }\n    int[] nia(int n) { \n        int a[] = new int[n]; \n        for(int i = 0; i < n; i++) { a[i] = ni(); } \n        return a;\n    }\n    long[] nla(int n) { \n        long a[] = new long[n]; \n        for(int i = 0; i < n; i++) { a[i] = nl(); } \n        return a;\n    }\n    int [][] nim(int n)\n    {\n        int mat[][]=new int[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=ni();\n            }\n        }\n        return mat;\n    }\n    long [][] nlm(int n)\n    {\n        long mat[][]=new long[n][n];\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                mat[i][j]=nl();\n            }\n        }\n        return mat;\n    }\n    \n\n\n\n\n    \n    char[] ns(int n) { \n        char c[] = new char[n]; \n        int i, b = skip(); \n        for(i = 0; i < n; i++) { \n            if(isSpaceChar(b)) { break; } \n            c[i] = (char)b; b = readByte(); \n        } return i == n ? c : Arrays.copyOf(c,i);\n    }\n    void piarr(int arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    void plarr(long arr[])\n    {\n        for(int i=0;i<arr.length;i++)\n        {\n            o.print(arr[i]+\" \");\n\n        }\n        o.println();\n    }\n    \n    void pimat(int mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n    }\n    void plmat(long mat[][])\n    {\n        for(int i=0;i<mat.length;i++)\n        {\n            for(int j=0;j<mat[0].length;j++)\n            {\n                o.print(mat[i][j]);\n            }\n            o.println();\n        }\n\n    }\n\n\n\n\n    \n\n\n\n}", "index": 27, "complexity": "0"}
{"forwhile": "public class FirstApp {\n    \n    \n \n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solve = new TaskA();\n        solve.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int number = in.nextInt();\n\n            if(number > 2 && number % 2 == 0) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n        }\n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            for(; tokenizer == null || !tokenizer.hasMoreTokens(); tokenizer = new StringTokenizer(reader.readLine())) {\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n    }\n    \n}", "src": "public class FirstApp {\n    \n    \n \n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solve = new TaskA();\n        solve.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int number = in.nextInt();\n\n            if(number > 2 && number % 2 == 0) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n        }\n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n    }\n    \n}", "index": 30, "complexity": "0"}
{"forwhile": "public class Main implements Runnable {\n  static String readLn(int maxLength) {\n\n    byte line[] = new byte[maxLength];\n    int length = 0;\n    int input = -1;\n    try {\n      int i = 0;\n      while (i < maxLength) {\n        input = System.in.read();\n        if ((input < 0) || (input == '\\n')) {\n          break;\n        }\n\n        line[length++] += input;\n        i++;\n      }\n\n      if ((input < 0) && (length == 0)) {\n        return null;\n      }\n\n      return new String(line, 0, length);\n    } catch (IOException e) {\n      return null;\n    }\n  }\n\n  public static void main(String args[]) {\n    Main myWork = new Main();\n    myWork.run();\n  }\n\n  public void run() {\n    new Watermelon().run();\n  }\n}\n\nclass Watermelon implements Runnable {\n  public void run() {\n    String line = Main.readLn(100).trim();\n    int weight = Integer.parseInt(line);\n    System.out.println(weight % 2 == 0 && weight > 2 ? \"YES\": \"NO\");\n  }\n}", "src": "public class Main implements Runnable {\n  static String readLn(int maxLength) {\n\n    byte line[] = new byte[maxLength];\n    int length = 0;\n    int input = -1;\n    try {\n      while (length < maxLength) {\n        input = System.in.read();\n        if ((input < 0) || (input == '\\n')) {\n          break;\n        }\n\n        line[length++] += input;\n      }\n\n      if ((input < 0) && (length == 0)) {\n        return null;\n      }\n\n      return new String(line, 0, length);\n    } catch (IOException e) {\n      return null;\n    }\n  }\n\n  public static void main(String args[]) {\n    Main myWork = new Main();\n    myWork.run();\n  }\n\n  public void run() {\n    new Watermelon().run();\n  }\n}\n\nclass Watermelon implements Runnable {\n  public void run() {\n    String line = Main.readLn(100).trim();\n    int weight = Integer.parseInt(line);\n    System.out.println(weight % 2 == 0 && weight > 2 ? \"YES\": \"NO\");\n  }\n}", "index": 31, "complexity": "0"}
{"forwhile": "public class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner kai = new Scanner(System.in);\n\t\tfor(; kai.hasNext();) {\n\t\t\tint a = kai.nextInt();\n\t\t\twhile((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}\n\t\t\tfor(; (a & 1) != 0;) {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 33, "complexity": "0"}
{"forwhile": "public class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n        while (st == null || !st.hasMoreElements())\n        {\n            try\n            {\n                st = new StringTokenizer(br.readLine());\n            }\n            catch (IOException  e)\n            {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    \n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n        String str = \"\";\n        try\n        {\n            str = br.readLine();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    \n  {\n    long result = 1;\n    for(; n > 0; n=n/2)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    for(; a!=0; ) {\n        long temp = a;\n        a = b % a;\n        b = temp;\n    }\n    return b;\n  }\n  public static void main(String[] args)\n    throws IOException\n  {\n    FastReader fr = new FastReader();\n    System.out.println((int)(fr.nextInt()/2) + 1);\n\n  }\n}\nclass pair\n{\n  public int first;\n  public int second;\n  public pair(int first,int second)\n  {\n    this.first = first;\n    this.second = second;\n  }\n  public int first() { return first; }\n  public int second() { return second; }\n  public void setFirst(int first) { this.first = first; }\n  public void setSecond(int second) { this.second = second; }\n}\nclass myComp implements Comparator<pair>\n{\n  public int compare(pair a,pair b)\n  {\n    return a.first - b.first;\n  }\n}\nclass BIT       \n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    int i = 0;\n    while(i < dat.length)    {\n        m_array[i + 1] = dat[i];\n        i++;\n    }\n    i = 1;\n    while(i < m_array.length)    {\n        int j = i + (i & -i);\n        if(j < m_array.length)\n        {\n            m_array[j] = m_array[j] + m_array[i];\n        }\n        i++;\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(int j = i + 1; j > 0; j = j - (j & -j))\n    {\n        result = result + m_array[j];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n        return prefix_query(to);\n    }\n    else\n    {\n        return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(int j = i + 1; j < m_array.length; j = j + (j & -j))    {\n        m_array[j] = m_array[j] + add;\n    }\n  }\n}", "src": "public class Main\n{\n  static class FastReader\n  {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader(){ br = new BufferedReader(new InputStreamReader(System.in)); }\n\n    String next()\n    {\n      while (st == null || !st.hasMoreElements())\n      {\n        try\n        {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException  e)\n        {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong(){ return Long.parseLong(next()); }\n\n    double nextDouble(){ return Double.parseDouble(next()); }\n\n    float nextFloat() { return Float.parseFloat(next()); }\n\n    boolean nextBoolean() { return Boolean.parseBoolean(next()); }\n\n    String nextLine()\n    {\n      String str = \"\";\n      try\n      {\n        str = br.readLine();\n      }\n      catch (IOException e)\n      {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n  static long modExp(long x, long n, long mod)    \n  {\n    long result = 1;\n    while(n > 0)\n    {\n        if(n % 2 == 1)\n            result = (result%mod * x%mod)%mod;\n        x = (x%mod * x%mod)%mod;\n        n=n/2;\n    }\n    return result;\n  }\n  static long gcd(long a, long b)\n  {\n    if(a==0) return b;\n    return gcd(b%a,a);\n  }\n  public static void main(String[] args)\n  throws IOException\n  {\n    FastReader fr = new FastReader();\n    System.out.println((int)(fr.nextInt()/2) + 1);\n\n  }\n}\nclass pair\n{\n  public int first;\n  public int second;\n  public pair(int first,int second)\n  {\n    this.first = first;\n    this.second = second;\n  }\n  public int first() { return first; }\n  public int second() { return second; }\n  public void setFirst(int first) { this.first = first; }\n  public void setSecond(int second) { this.second = second; }\n}\nclass myComp implements Comparator<pair>\n{\n  public int compare(pair a,pair b)\n  {\n    return (a.first - b.first);\n  }\n}\nclass BIT       \n{\n  public long[] m_array;\n\n  public BIT(long[] dat)\n  {\n    m_array = new long[dat.length + 1];\n    Arrays.fill(m_array,0);\n    for(int i = 0; i < dat.length; i++)\n    {\n      m_array[i + 1] = dat[i];\n    }\n    for(int i = 1; i < m_array.length; i++)\n    {\n      int j = i + (i & -i);\n      if(j < m_array.length)\n      {\n        m_array[j] = m_array[j] + m_array[i];\n      }\n    }\n  }\n\n  public final long prefix_query(int i)\n  {\n    long result = 0;\n    for(++i; i > 0; i = i - (i & -i))\n    {\n      result = result + m_array[i];\n    }\n    return result;\n  }\n\n  public final long range_query(int fro, int to)\n  {\n    if(fro == 0)\n    {\n      return prefix_query(to);\n    }\n    else\n    {\n      return (prefix_query(to) - prefix_query(fro - 1));\n    }\n  }\n\n  public void update(int i, long add)\n  {\n    for(++i; i < m_array.length; i = i + (i & -i))\n    {\n      m_array[i] = m_array[i] + add;\n    }\n  }\n}", "index": 34, "complexity": "0"}
{"forwhile": "public class SolutionB {\n    \n    public static void main(String args[])throws IOException{\n        Scanner sc = new Scanner(System.in);\n        long a[] = new long[14];\n        int i = 0;\n        while(i < 14){\n            a[i] = sc.nextLong();\n            i++;\n        }\n        long cpy[] = new long[14];\n        long max = 0;\n        int i = 0;\n        while(i < 14){\n            if(a[i] == 0)continue;\n            long score = 0;\n            long curr = a[i];\n            int j = 0;\n            while(j < 14){\n                cpy[j] = a[j];\n                j++;\n            }\n            cpy[i] = 0;\n            long amnt = curr / 14l;\n            int j = 0;\n            while(j < 14){\n                cpy[j] += amnt;\n                j++;\n            }\n            amnt = curr % 14;\n            int j = i + 1;\n            while(j < i + 1 + amnt){\n                cpy[j % 14]++;\n                j++;\n            }\n            int j = 0;\n            while(j < 14){\n                if(cpy[j] % 2 == 0)\n                    score += cpy[j];\n                j++;\n            }\n            max = Math.max(max, score);\n            i++;\n        }\n        System.out.println(max);\n    }\n}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              long a[] = new long[14];\n              for(int i = 0; i < 14; i++)\n                     a[i] = sc.nextLong();\n              long cpy[] = new long[14];\n              long max = 0;\n              for(int i = 0; i < 14; i++){\n                     if(a[i] == 0)continue;\n                     long score = 0;\n                     long curr = a[i];\n                     for(int j = 0; j < 14; j++)\n                            cpy[j] = a[j];\n                     cpy[i] = 0;\n                     long amnt = curr / 14l;\n                     for(int j = 0; j < 14; j++){\n                            cpy[j] += amnt;\n                     }\n                     amnt = curr % 14;\n                     for(int j = i + 1; j < i + 1 + amnt; j++){\n                            cpy[j % 14]++;\n                     }\n                     for(int j = 0; j < 14; j++){\n                            if(cpy[j] % 2 == 0)\n                                   score += cpy[j];\n                     }\n                     max = Math.max(max, score);\n              }\n              System.out.println(max);\n      }\n}", "index": 35, "complexity": "0"}
{"forwhile": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        A979 solver = new A979();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A979 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            long n = in.nextLong();\n            n = n + 1;\n            if (n % 2 == 0) {\n                out.println(n / 2);\n            } else {\n                if (n != 1) {\n                    out.println(n);\n                } else {\n                    out.println(0);\n                }\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            for (int c = read(); isSpaceChar(c); c = read()) {\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            for (;;) {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n                if (isSpaceChar(c))\n                    break;\n            }\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public void isSpaceChar(SpaceCharFilter filter) {\n            this.filter = filter;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        A979 solver = new A979();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A979 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            long n = in.nextLong();\n            n = n + 1;\n            if (n % 2 == 0) {\n                out.println(n / 2);\n            } else {\n                if (n != 1) {\n                    out.println(n);\n                } else {\n                    out.println(0);\n                }\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 36, "complexity": "0"}
{"forwhile": "public class Main implements Runnable {\nstatic class InputReader {\nprivate InputStream stream;\nprivate byte[] buf = new byte[1024];\nprivate int curChar;\nprivate int numChars;\nprivate SpaceCharFilter filter;\nprivate BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\npublic InputReader(InputStream stream) {\nthis.stream = stream;\n}\npublic int read() {\nif (numChars==-1)\nthrow new InputMismatchException();\nif (curChar >= numChars) {\ncurChar = 0;\ntry {\nnumChars = stream.read(buf);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(numChars <= 0)\nreturn -1;\n}\nreturn buf[curChar++];\n}\npublic String nextLine() {\nString str = \"\";\ntry {\nstr = br.readLine();\n}\ncatch (IOException e) {\ne.printStackTrace();\n}\nreturn str;\n}\npublic int nextInt() {\nint c = read();\nwhile(isSpaceChar(c))\nc = read();\nint sgn = 1;\nif (c == '-') {\nsgn = -1;\nc = read();\n}\nint res = 0;\ndo {\nif(c<'0'||c>'9')\nthrow new InputMismatchException();\nres *= 10;\nres += c - '0';\nc = read();\n}\nwhile (!isSpaceChar(c));\nreturn res * sgn;\n}\npublic long nextLong() {\nint c = read();\nfor(; isSpaceChar(c); c = read());\nint sgn = 1;\nif (c == '-') {\nsgn = -1;\nc = read();\n}\nlong res = 0;\ndo {\nif (c < '0' || c >'9')\nthrow new InputMismatchException();\nres *= 10;\nres += c - '0';\nc = read();\n}\nwhile (!isSpaceChar(c));\nreturn res * sgn;\n}\npublic double nextDouble() {\nint c = read();\nfor(; isSpaceChar(c); c = read());\nint sgn = 1;\nif (c == '-') {\nsgn = -1;\nc = read();\n}\ndouble res = 0;\ndo {\nif (c == 'e' || c == 'E')\nreturn res * Math.pow(10, nextInt());\nif (c < '0' || c > '9')\nthrow new InputMismatchException();\nres *= 10;\nres += c - '0';\nc = read();\n}\nwhile (!isSpaceChar(c) && c != '.');\nif (c == '.') {\nc = read();\ndouble m = 1;\nwhile (!isSpaceChar(c)) {\nif (c == 'e' || c == 'E')\nreturn res * Math.pow(10, nextInt());\nif (c < '0' || c > '9')\nthrow new InputMismatchException();\nm /= 10;\nres += (c - '0') * m;\nc = read();\n}\n}\nreturn res * sgn;\n}\npublic String readString() {\nint c = read();\nfor(; isSpaceChar(c); c = read());\nStringBuilder res = new StringBuilder();\ndo {\nres.appendCodePoint(c);\nc = read();\n}\nwhile (!isSpaceChar(c));\nreturn res.toString();\n}\npublic boolean isSpaceChar(int c) {\nif (filter != null)\nreturn filter.isSpaceChar(c);\nreturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n}\npublic String next() {\nreturn readString();\n}\npublic interface SpaceCharFilter {\npublic boolean isSpaceChar(int ch);\n}\n}\npublic static void main(String args[]) throws Exception {\nnew Thread(null, new Main(),\"Main\",1<<26).start();\n}\nstatic void merge(int arr[], int l, int m, int r) {\nint n1 = m - l + 1;\nint n2 = r - m;\nint L[] = new int [n1];\nint R[] = new int [n2];\nfor (int i=0; i<n1; ++i)\nL[i] = arr[l + i];\nfor (int j=0; j<n2; ++j)\nR[j] = arr[m + 1+ j];\nint i = 0, j = 0;\nint k = l;\nwhile (i < n1 && j < n2){\nif (L[i] <= R[j]){\narr[k] = L[i];\ni++;\n}\nelse{\narr[k] = R[j];\nj++;\n}\nk++;\n}\nwhile (i < n1){\narr[k] = L[i];\ni++;\nk++;\n}\nwhile (j < n2)\n{\narr[k] = R[j];\nj++;\nk++;\n}\n}\nstatic void sort(int arr[], int l, int r) {\nif (l < r)\n{\nint m = (l+r)/2;\nsort(arr, l, m);\nsort(arr , m+1, r);\nmerge(arr, l, m, r);\n}\n}\nstatic void merge(long arr[], int l, int m, int r) {\nint n1 = m - l + 1;\nint n2 = r - m;\nlong L[] = new long [n1];\nlong R[] = new long [n2];\nfor (int i=0; i<n1; ++i)\nL[i] = arr[l + i];\nfor (int j=0; j<n2; ++j)\nR[j] = arr[m + 1+ j];\nint i = 0, j = 0;\nint k = l;\nwhile (i < n1 && j < n2){\nif (L[i] <= R[j]){\narr[k] = L[i];\ni++;\n}\nelse{\narr[k] = R[j];\nj++;\n}\nk++;\n}\nwhile (i < n1){\narr[k] = L[i];\ni++;\nk++;\n}\nwhile (j < n2)\n{\narr[k] = R[j];\nj++;\nk++;\n}\n}\nstatic void sort(long arr[], int l, int r) {\nif (l < r)\n{\nint m = (l+r)/2;\nsort(arr, l, m);\nsort(arr , m+1, r);\nmerge(arr, l, m, r);\n}\n}\nstatic int gcd(int a, int b){\nfor(; b != 0; b = a % b){\nint temp = a;\na = b;\nb = temp;\n}\nreturn a;\n}\nstatic long gcd(long a, long b){\nfor(; b != 0; b = a % b){\nlong temp = a;\na = b;\nb = temp;\n}\nreturn a;\n}\npublic long m=(long)1e9+7;;\npublic void run() {\nInputReader in = new InputReader(System.in);\nPrintWriter out = new PrintWriter(System.out);\nint a=in.nextInt(),b=in.nextInt(),c=in.nextInt(),n=in.nextInt();\nint nnew=a+b-c;\nif((n>nnew) && (a>=c) && (b>=c))\nout.println(n-nnew);\nelse\nout.println(-1);\nout.close();\n}\n}", "src": "public class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    \n    static void merge(int arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(int arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    } \n    \n    static void merge(long arr[], int l, int m, int r) { \n        int n1 = m - l + 1; \n        int n2 = r - m; \n        long L[] = new long [n1]; \n        long R[] = new long [n2]; \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n        int i = 0, j = 0; \n        int k = l; \n        while (i < n1 && j < n2){ \n            if (L[i] <= R[j]){ \n                arr[k] = L[i]; \n                i++; \n            } \n            else{ \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n        while (i < n1){ \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n    static void sort(long arr[], int l, int r) { \n        if (l < r) \n        { \n            int m = (l+r)/2; \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n            merge(arr, l, m, r); \n        } \n    }\n    static int gcd(int a, int b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    }\n    static long gcd(long a, long b){ \n        if (b == 0) \n            return a; \n        return gcd(b, a % b);  \n    } \n    public long m=(long)1e9+7;;\n    \n    public void run() {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int a=in.nextInt(),b=in.nextInt(),c=in.nextInt(),n=in.nextInt();\n        int nnew=a+b-c;\n        if((n>nnew) && (a>=c) && (b>=c))\n            out.println(n-nnew);\n        else\n            out.println(-1);\n        \n        out.close();\n    }\n}", "index": 37, "complexity": "0"}
{"forwhile": "public class C_NNAndTheOpticalIllusion {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            double n = inp.nextInt(), r = inp.nextInt();\n            double x = Math.cos((n - 2) * Math.PI / (2 * n));\n            out.print((r * x) / (1 - x));\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            for(; tokenizer == null || !tokenizer.hasMoreTokens(); tokenizer = new StringTokenizer(reader.readLine())) {\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            for(; ; ) {\n                try {\n                    if(!(tokenizer == null || !tokenizer.hasMoreTokens())) break;\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            } \n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            for(; ; ) {\n                try {\n                    if(!(tokenizer == null || !tokenizer.hasMoreTokens())) break;\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            } \n            return Long.parseLong(next());\n        }\n    }", "src": "public class C_NNAndTheOpticalIllusion {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            double n = inp.nextInt(), r = inp.nextInt();\n            double x = Math.cos((n - 2) * Math.PI / (2 * n));\n            out.print((r * x) / (1 - x));\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 39, "complexity": "0"}
{"forwhile": "public class HelloWorld {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Palindrome solver = new Palindrome();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class Palindrome {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long l = in.nextLong();\n            \n            if(l%4 == 0 || l%4 == 3)\n            {\n                out.print(\"0\");\n            }\n            else\n            {\n                out.print(\"1\");\n            }\n        }\n \n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            for(; tokenizer == null || !tokenizer.hasMoreTokens();) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n \n    }\n}", "src": "public class HelloWorld {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Palindrome solver = new Palindrome();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class Palindrome {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long l = in.nextLong();\n            \n            if(l%4 == 0 || l%4 == 3)\n            {\n                out.print(\"0\");\n            }\n            else\n            {\n                out.print(\"1\");\n            }\n        }\n \n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n \n    }\n}", "index": 40, "complexity": "0"}
{"forwhile": "public class Main { private static final FS scanner = new FS(System.in); public static void main(String[] args) throws Exception { int n = scanner.nextInt(); int sumA = 0; int sumB = 0; int rem = n % 4; int i = rem; while(i >= 1) { if (sumB <= sumA) { sumB += i; } else { sumA += i; } i--; } System.out.println(Math.abs(sumA - sumB)); } static class FS { BufferedReader br; StringTokenizer st; public FS(InputStream i) { br = new BufferedReader(new InputStreamReader(i)); st = new StringTokenizer(\"\"); } public String next() throws IOException { if(st.hasMoreTokens()) return st.nextToken(); else st = new StringTokenizer(br.readLine()); return next(); } public int nextInt() throws IOException { return Integer.parseInt(next()); } public long nextLong() throws IOException { return Long.parseLong(next()); } public double nextDouble() throws IOException { return Double.parseDouble(next()); } } }", "src": "public class Main {\n \n    private static final FS scanner = new FS(System.in);\n\t\n\t\n\tpublic static void main(String[] args) throws Exception {\n\n        int n = scanner.nextInt();\n        int sumA = 0;\n        int sumB = 0;\n        int rem = n % 4;\n        for (int i = rem; i >= 1 ; i--) {\n            if (sumB <= sumA) {\n                sumB += i;\n            }\n            else {\n                sumA +=i;\n            }\n        }\n\n        System.out.println(Math.abs(sumA - sumB));\n    }\n\t\n    static class FS {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FS(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer(\"\");\n        }\n\n        public String next() throws IOException {\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n \n}", "index": 41, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class usd {\n\t\t\n\t\tstatic int r=0;static int c=0;\n\t\tstatic void fillzero(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[j][i]==0&&a[j+1][i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][i]=1;a[j+1][i]=1;\n\t\t\t\t\t\tr=j;c=i;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic void fillone(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(a[i][j]==0&&a[i][j+1]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i][j]=1;a[i][j+1]=1;\n\t\t\t\t\t\tr=i;c=j;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void check(int a[][],int n)\n\t\t{\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[i][0]==1&&a[i][1]==1&&a[i][2]==1&&a[i][3]==1)\n\t\t\t\t{\n\t\t\t\t\ta[i][0]=0;a[i][1]=0;a[i][2]=0;a[i][3]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(a[0][i]==1&&a[1][i]==1&&a[2][i]==1&&a[3][i]==1)\n\t\t\t\t{\n\t\t\t\t\ta[0][i]=0;a[1][i]=0;a[2][i]=0;a[3][i]=0;;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t\t\n\t\t\t\n\t\tScanner in=new Scanner (System.in);\n\t\tHashMap<String,Integer>map=new HashMap<String,Integer>();\n\t\tArrayList<Integer>list=new ArrayList<Integer>();\n\t\nlong n=in.nextLong();\nlong ans=Long.MAX_VALUE;\nlong sum=0;long sum2=(n*(n+1))/2;\nif(sum2%2==0)\nSystem.out.println(0);\nelse\n\tSystem.out.println(1);\n\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t}\n\t\t\n\t\t\n\t}", "index": 42, "complexity": "0"}
{"forwhile": "public class Main {\n    public static void main(String args[]) {\n        FastReader fr = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = fr.nextInt(), v = fr.nextInt();\n        if (v >= n)\n            out.println(n - 1);\n        else\n            out.println((n - v) * (n - v + 1) / 2 + v - 1);\n        out.flush();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            int i = 0;\n            while (i < n) {\n                a[i] = nextInt();\n                i++;\n            }\n            return a;\n        }\n\n        int[] memset(int n, int val) {\n            int ar[] = new int[n];\n            for(int i = 0; i < n; i++) {\n                ar[i] = val;\n            }\n            return ar;\n        }\n    }\n}", "src": "public class Main {\n    public static void main(String args[]) {\n        FastReader fr = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = fr.nextInt(), v = fr.nextInt();\n        if (v >= n)\n            out.println(n - 1);\n        else\n            out.println((n - v) * (n - v + 1) / 2 + v - 1);\n        out.flush();\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        int[] memset(int n, int val) {\n            int ar[] = new int[n];\n            Arrays.fill(ar, val);\n            return ar;\n        }\n    }\n}", "index": 44, "complexity": "0"}
{"forwhile": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n % 2 != 0) {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n % 2 != 0) {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}", "index": 45, "complexity": "0"}
{"forwhile": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\tfor(;sc.hasNext();) {\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n%2==0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n%2==0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 46, "complexity": "0"}
{"forwhile": "public class A {\n\tstatic int n;\n\tstatic TreeSet<Integer> Primes;\n\tstatic int[] arr;\n\tstatic int[] arr2;\n\n\tpublic static int[] copyOf(int[] arr) {\n\t\tint i = 0;\n\t\twhile (i < arr.length) {\n\t\t\tarr2[i] += arr[i];\n\t\t\ti++;\n\t\t}\n\t\treturn arr2;\n\t}\n\n\tpublic static long addEvens(int[] arr) {\n\t\tlong r = 0;\n\t\tint i = 0;\n\t\twhile (i < arr.length) {\n\t\t\tif (arr[i] % 2 == 0)\n\t\t\t\tr += arr[i];\n\t\t\ti++;\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tarr = new int[14];\n\t\tint i = 0;\n\t\twhile (i < 14) {\n\t\t\tarr[i] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tint x = 5535;\n\t\tint y = x;\n\t\tint s;\n\t\tlong max = Integer.MIN_VALUE;\n\t\tint i = 0;\n\t\twhile (i < 14) {\n\t\t\tint a = arr[i];\n\t\t\tarr2 = new int[14];\n\t\t\tarr2 = copyOf(arr);\n\t\t\tarr2[i] = 0;\n\t\t\tint j = 0;\n\t\t\tint rem = arr[i] / 14;\n\t\t\tint steps = 0;\n\t\t\tint c = 0;\n\t\t\tfor (j = i + 1; c < 14; j++) {\n\t\t\t\tif (j >= 14)\n\t\t\t\t\tj = 0;\n\t\t\t\tarr2[c] += rem;\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tsteps = arr[i] % 14;\n\t\t\tj = i;\n\t\t\tc = 0;\n\t\t\tint adasd;\n\t\t\tfor (j = i + 1; c < steps; j++) {\n\t\t\t\tif (j >= 14)\n\t\t\t\t\tj = 0;\n\t\t\t\tarr2[j] += 1;\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tmax = Math.max(max, addEvens(arr2));\n\t\t\ti++;\n\t\t}\n\t\tpw.print(max);\n\n\t\tpw.flush();\n\t}\n}", "src": "public class A {\n\t\tstatic int n;\n\t\tstatic TreeSet<Integer> Primes;\n\t\tstatic int[] arr;\n\t\tstatic int[] arr2;\n\t\n\t\tpublic static int[] copyOf(int[] arr) {\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tarr2[i] += arr[i];\n\t\t\treturn arr2;\n\t\t}\n\t\n\t\tpublic static long addEvens(int[] arr) {\n\t\t\tlong r = 0;\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tif (arr[i] % 2 == 0)\n\t\t\t\t\tr += arr[i];\n\t\t\treturn r;\n\t\t}\n\t\n\t\tpublic static void main(String[] args) throws IOException {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\tarr = new int[14];\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tarr[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint x = 5535;\n\t\t\tint y = x;\n\t\t\tint s;\n\t\t\tlong max = Integer.MIN_VALUE;\n\t\t\tfor (int i = 0; i < 14; i++) {\n\t\t\t\tint a = arr[i];\n\t\t\t\tarr2 = new int[14];\n\t\t\t\tarr2 = copyOf(arr);\n\t\t\t\tarr2[i]=0;\n\t\t\t\tint j =0;\n\t\t\t\tint rem = arr[i] / 14;\n\t\t\t\tint steps = 0;\n\t\t\t\tint c = 0;\n\t\t\t\tfor (  j = i+1;c<14; j++) {\n\t\t\t\t\tif (j >=14 )\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[c] += rem;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tsteps = arr[i] % 14;\n\t\t\t\tj = i;\n\t\t\t\tc=0;\n\t\t\t\tint adasd;\n\t\t\t\tfor ( j = i+1;c<steps; j++) {\n\t\t\t\t\tif (j >= 14)\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\tarr2[j] += 1;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, addEvens(arr2));\n\t\t\t}\n\t\t\tpw.print(max);\n\t\n\t\t\tpw.flush();\n\t\t}\n\t\n\t\n\t\n\t}", "index": 48, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Main_1100C {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\n\t\tdouble sin = Math.sin(Math.PI / n);\n\t\tdouble ans = r * sin / (1 - sin);\n\t\t\n\t\tpr.printf(\"%.7f%n\", ans);\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\t\t\t\n\t\tsolve();\n\t\t\t\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tint[][] nextIntArrays(int n, int m) {\n\t\t\tint[][] ret = new int[m][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tret[j][i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t\t\n\t\tvoid printInts(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printLongs(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder(64);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printStrings(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t}\n}", "index": 53, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class IntegerSequenceDividing {\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n%2==0)\n\t\t{\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}else\n\t\t{\n\t\t\tn++;\n\t\t\tn=n/2;\n\t\t\tif(n%2==0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(1);\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "index": 54, "complexity": "0"}
{"forwhile": "public class Codechef\n{   static PrintWriter out=new PrintWriter(System.out);\n\tstatic FastScanner in = new FastScanner(System.in);\n     static class FastScanner {BufferedReader br;StringTokenizer stok;FastScanner(InputStream is) {br = new BufferedReader(new InputStreamReader(is));}\n        String next() throws IOException {while (stok == null || !stok.hasMoreTokens()) {String s = br.readLine();if (s == null) {return null;}\n                stok = new StringTokenizer(s);}return stok.nextToken();}\n        int ni() throws IOException {    return Integer.parseInt(next());}\n        long nl() throws IOException {return Long.parseLong(next());}\n        double nd() throws IOException {return Double.parseDouble(next());}\n        char nc() throws IOException {return (char) (br.read());}\n        String ns() throws IOException {return br.readLine();}\n        int[] nia(int n) throws IOException{int a[] = new int[n];int i = 0;if (i < n) {a[i] = ni();i++;}};return a;}\n        long[] nla(int n) throws IOException {\n            long a[] = new long[n];int i = 0;if (i < n) {a[i] = nl();i++;}};return a;}\n        double[] nda(int n)throws IOException {double a[] = new double[n];int i = 0;if (i < n) {        a[i] = nd();i++;}};return a;}\n        int [][] imat(int n,int m) throws IOException\n        {   int mat[][]=new int[n][m];int i=0;if(i<n){   int j=0;if(j<m){mat[i][j]=ni();j++;}};i++;};return mat;}\n    }\n        \n    \n    \n    \n    \n    \n\tstatic long mod=Long.MAX_VALUE;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{   int i = 0;int j = 0;\n\t    HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();\n\t\t       \n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        HashSet<Integer> set=new HashSet<Integer>();\n        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\n        \n        long n=in.nl();\n        long v=in.nl();\n        long temp=n-1;\n        long ans=0;\n          \n        ans+=Math.min(v,temp);\n        temp-=v;\n\t    \n\t    if(temp>0)\n            ans+=((temp+1)*(temp+2))/(long)2-1;\n        \n        \n        out.println(ans);\n        out.close();\n\t}\n\t\n\t\n\t\n\t\n\t\n\tstatic long gcd(long a,long b)\n\t{   if(b==0)\n\t        return a;\n\t    int n = 0;if(n!=0){   if(n%2==1){            ans=(ans*a)%mod;n=(n>>1);}};return ans;\n\t}\n\tint n = 0;long a = 1;int exponent(long n){while(n!=0)\n\t    {   if(n%2==1)\n\t            a=(a*a)%mod;\n\t       a=(a*a)%mod;\n\t       n=n>>1;\n\t    }\n\t    return a;\n\t}\n\tint binarySearch(int a[], int item, int low, int high) \n    {   int n = 0;int mid = 0;if (high <= low) \n            return (item > a[low])?  (low + 1): low; \n       if(item == a[mid]) \n            return mid+1; \n       if(item > a[mid]) \n            return binarySearch(a, item, mid+1, high); \n        return binarySearch(a, item, low, mid-1); \n    } \n   void merge(int arr[], int l, int m, int r) \n    {   int n1 = m - l + 1; int n2 = r - m; int L[] = new int [n1]; int R[] = new int [n2]; \n        \n        int i = 0;int j = 0;int k = l; \n        while (i < n1 && j < n2) {   if (L[i] <= R[j]) {   arr[k] = L[i]; i++; } else{   arr[k] = R[j]; j++; } k++; } while (i < n1){   arr[k] = L[i]; i++; k++; } while (j < n2) { arr[k] = R[j];   j++;     k++; } \n    } \n    void Sort(int arr[], int l, int r) \n    {    if (l < r) {   int m = (l+r)/2; Sort(arr, l, m); Sort(arr , m+1, r); merge(arr, l, m, r); } } \n    \n    void sort(int a[])\n    {Sort(a,0,a.length-1);}\n\n}", "src": "public class Codechef\n{   static PrintWriter out=new PrintWriter(System.out);\n\tstatic FastScanner in = new FastScanner(System.in);\n     static class FastScanner {BufferedReader br;StringTokenizer stok;FastScanner(InputStream is) {br = new BufferedReader(new InputStreamReader(is));}\n        String next() throws IOException {while (stok == null || !stok.hasMoreTokens()) {String s = br.readLine();if (s == null) {return null;}\n                stok = new StringTokenizer(s);}return stok.nextToken();}\n        int ni() throws IOException {    return Integer.parseInt(next());}\n        long nl() throws IOException {return Long.parseLong(next());}\n        double nd() throws IOException {return Double.parseDouble(next());}\n        char nc() throws IOException {return (char) (br.read());}\n        String ns() throws IOException {return br.readLine();}\n        int[] nia(int n) throws IOException{int a[] = new int[n];for (int i = 0; i < n; i++)a[i] = ni();return a;}\n        long[] nla(int n) throws IOException {\n            long a[] = new long[n];for (int i = 0; i < n; i++)a[i] = nl();return a;}\n        double[] nda(int n)throws IOException {double a[] = new double[n];for (int i = 0; i < n; i++)        a[i] = nd();    return a;}\n        int [][] imat(int n,int m) throws IOException\n        {   int mat[][]=new int[n][m];for(int i=0;i<n;i++){   for(int j=0;j<m;j++)mat[i][j]=ni();}return mat;}\n    }\n        \n    \n    \n    \n    \n    \n\tstatic long mod=Long.MAX_VALUE;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{   int i,j;\n\t    HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();\n\t\t       \n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        HashSet<Integer> set=new HashSet<Integer>();\n        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\n        \n        long n=in.nl();\n        long v=in.nl();\n        long temp=n-1;\n        long ans=0;\n          \n        ans+=Math.min(v,temp);\n        temp-=v;\n\t    \n\t    if(temp>0)\n            ans+=((temp+1)*(temp+2))/(long)2-1;\n        \n        \n        out.println(ans);\n        out.close();\n\t}\n\t\n\t\n\t\n\t\n\t\n\tstatic long gcd(long a,long b)\n\t{   if(b==0)\n\t        return a;\n\t    return gcd(b,a%b);    \n\t}\n\tstatic long exponent(long a,long n)\n\t{   long ans=1;\n\t    while(n!=0)\n\t    {   if(n%2==1)\n\t            ans=(ans*a)%mod;\n\t       a=(a*a)%mod;\n\t       n=n>>1;\n\t    }\n\t    return ans;\n\t}\n\tstatic int binarySearch(int a[], int item, int low, int high) \n    {   if (high <= low) \n            return (item > a[low])?  (low + 1): low; \n        int mid = (low + high)/2; \n        if(item == a[mid]) \n            return mid+1; \n        if(item > a[mid]) \n            return binarySearch(a, item, mid+1, high); \n        return binarySearch(a, item, low, mid-1); \n    } \n   static void merge(int arr[], int l, int m, int r) \n    {   int n1 = m - l + 1; int n2 = r - m; int L[] = new int [n1]; int R[] = new int [n2]; \n        \n        for (int i=0; i<n1; ++i) L[i] = arr[l + i]; for (int j=0; j<n2; ++j) R[j] = arr[m + 1+ j]; int i = 0, j = 0; int k = l; \n        while (i < n1 && j < n2) {   if (L[i] <= R[j]) {   arr[k] = L[i]; i++; } else{   arr[k] = R[j]; j++; } k++; } while (i < n1){   arr[k] = L[i]; i++; k++; } while (j < n2) { arr[k] = R[j];   j++;     k++; } \n    } \n    static void Sort(int arr[], int l, int r) \n    {    if (l < r) {   int m = (l+r)/2; Sort(arr, l, m); Sort(arr , m+1, r); merge(arr, l, m, r); } } \n    \n    static void sort(int a[])\n    {Sort(a,0,a.length-1);}\n\n}", "index": 55, "complexity": "0"}
{"forwhile": "public class SashaAndHisTrip {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint v = nextInt();\n\t\t\n\t\tif (v >= n-1)\n\t\t\tSystem.out.println(n-1);\n\t\telse\n\t\t\tSystem.out.println((n-v)*(n-v+1)/2+v-1);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\tfor(; st == null || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\ta[i] = nextInt();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\tint j = 0;\n\t\t\twhile(j < m) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\ta[i] = nextLong();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class SashaAndHisTrip {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint v = nextInt();\n\t\t\n\t\tif (v >= n-1)\n\t\t\tSystem.out.println(n-1);\n\t\telse\n\t\t\tSystem.out.println((n-v)*(n-v+1)/2+v-1);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 56, "complexity": "0"}
{"forwhile": "public class DLL { Node head; class Node { int data; Node prev; Node next; Node(int d) { data = d; } } public void push(int new_data) { Node new_Node = new Node(new_data); new_Node.next = head; new_Node.prev = null; if (head != null) head.prev = new_Node; head = new_Node; } public void printlist(Node node) { Node last = null; while(node != null) { System.out.print(node.data + \" \"); last = node; node = node.next; } System.out.println(); } void deleteNode(Node head_ref, Node del) { if (head == null || del == null) { return; } if (head == del) { head = del.next; } if (del.next != null) { del.next.prev = del.prev; } if (del.prev != null) { del.prev.next = del.next; } return; } public static void main(String[] args) { DLL dll = new DLL(); dll.push(2); dll.push(4); dll.push(8); dll.push(10); System.out.print(\"Created DLL is: \"); dll.printlist(dll.head); dll.deleteNode(dll.head, dll.head); System.out.print(\"\\nList after deleting first node: \"); dll.printlist(dll.head); dll.deleteNode(dll.head, dll.head.next); System.out.print(\"\\nList after Deleting middle node: \"); dll.printlist(dll.head); } }", "src": "public\nclass\nDLL { \n\nNode head; \n\n\n\n\n\nclass\nNode { \n\nint\ndata; \n\nNode prev; \n\nNode next; \n\n\n\n\n\n\n\n\nNode(\nint\nd) { data = d; } \n\n} \n\n\n\n\npublic\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\n\n\nNode new_Node = \nnew\nNode(new_data); \n\n\n\n\n\n\nnew_Node.next = head; \n\nnew_Node.prev = \nnull\n; \n\n\n\n\nif\n(head != \nnull\n) \n\nhead.prev = new_Node; \n\n\n\n\nhead = new_Node; \n\n} \n\n\n\n\n\n\npublic\nvoid\nprintlist(Node node) \n\n{ \n\nNode last = \nnull\n; \n\n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nlast = node; \n\nnode = node.next; \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nvoid\ndeleteNode(Node head_ref, Node del) \n\n{ \n\n\n\n\nif\n(head == \nnull\n|| del == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\n\nif\n(head == del) { \n\nhead = del.next; \n\n} \n\n\n\n\n\n\nif\n(del.next != \nnull\n) { \n\ndel.next.prev = del.prev; \n\n} \n\n\n\n\n\n\nif\n(del.prev != \nnull\n) { \n\ndel.prev.next = del.next; \n\n} \n\n\n\n\nreturn\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nDLL dll = \nnew\nDLL(); \n\n\n\n\ndll.push(\n2\n); \n\n\n\n\ndll.push(\n4\n); \n\n\n\n\ndll.push(\n8\n); \n\n\n\n\ndll.push(\n10\n); \n\n\nSystem.out.print(\n\"Created DLL is: \"\n); \n\ndll.printlist(dll.head); \n\n\n\n\ndll.deleteNode(dll.head, dll.head); \n\n\n\n\n\n\nSystem.out.print(\n\"\\nList after deleting first node: \"\n); \n\ndll.printlist(dll.head); \n\n\n\n\ndll.deleteNode(dll.head, dll.head.next); \n\n\nSystem.out.print(\n\"\\nList after Deleting middle node: \"\n); \n\ndll.printlist(dll.head); \n\n} \n}", "index": 57, "complexity": "0"}
{"forwhile": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n       long l2 =param.nextLong();\n       long dice1=param.nextLong();\n       long dice2=param.nextLong();\n      \n       long l1=1;\n       long r1=1;\n       long r2=l2;\n       long count=0;\n       long check=0;\n       count=l2-dice1;\n       count=count+(r2-dice2);\n       check=dice1-l1;\n       check=check+(dice2-r1);\n       if(check<=count){\n          System.out.println(\"White\");\n       }\n       else{\n          System.out.println(\"Black\");\n       }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          for(; st == null || !st.hasMoreElements(); ) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          for(; ; ) {\n return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          for(; ; ) {\n return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n      for(; ; ) {\n return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n      String str = \"\";\n      for( ; ; ) {\n      try {\n      str = br.readLine();\n      } catch (IOException e) {\n      e.printStackTrace();\n      }\n      return str;\n      }\n}\n}\n}", "src": "public class Param\n{\n                \n      public static  void main( String[]args) \n    {\n       MyScanner param = new MyScanner();\n      out = new PrintWriter(new BufferedOutputStream(System.out));\n       long l2 =param.nextLong();\n       long dice1=param.nextLong();\n       long dice2=param.nextLong();\n      \n       long l1=1;\n       long r1=1;\n       long r2=l2;\n       long count=0;\n       long check=0;\n       count=l2-dice1;\n       count=count+(r2-dice2);\n       check=dice1-l1;\n       check=check+(dice2-r1);\n       if(check<=count){\n          System.out.println(\"White\");\n       }\n       else{\n          System.out.println(\"Black\");\n       }\n      out.close();\n}\npublic static PrintWriter out;\n      \n   \n   public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n      public MyScanner() {\n         br = new BufferedReader(new InputStreamReader(System.in));\n      }\n \n      String next() {\n          while (st == null || !st.hasMoreElements()) {\n              try {\n                  st = new StringTokenizer(br.readLine());\n              } catch (IOException e) {\n                  e.printStackTrace();\n              }\n          }\n          return st.nextToken();\n      }\n \n      int nextInt() {\n          return Integer.parseInt(next());\n      }\n \n      long nextLong() {\n          return Long.parseLong(next());\n      }\n \n      double nextDouble() {\n          return Double.parseDouble(next());\n      }\n \n      String nextLine(){\n          String str = \"\";\n\t  try {\n\t     str = br.readLine();\n\t  } catch (IOException e) {\n\t     e.printStackTrace();\n\t  }\n\t  return str;\n      }\n}\n}", "index": 63, "complexity": "0"}
{"forwhile": "public class Dont {static BufferedReader jin = new BufferedReader( new InputStreamReader( System.in ) );static long n;static long x, y;public static void main(String[] args) throws Exception {n = nextLong();x = nextLong();y = nextLong();System.out.println( (max(n-x, n-y) < max(x-1, y-1))? \"Black\" : \"White\" );}static long max(long a, long b) {return (a > b)? a : b ;}static long nextLong() throws Exception {long res = 0;int ch = jin.read();for(;ch < '0' || '9' < ch;) ch = jin.read();for(; '0'<= ch && ch <= '9';){res = res*10 + ch - '0';ch = jin.read();}return res;}}", "src": "public class Dont {\n    static BufferedReader jin = new BufferedReader( new InputStreamReader( System.in ) );\n    static long n;\n    static long x, y;\n\n    public static void main(String[] args) throws Exception {\n        n = nextLong();\n        x = nextLong();\n        y = nextLong();\n        System.out.println( (max(n-x, n-y) < max(x-1, y-1))? \"Black\" : \"White\" );\n    }\n\n    static long max(long a, long b) {\n        return (a > b)? a : b ;\n    }\n\n    static long nextLong() throws Exception {\n        long res = 0;\n        int ch = jin.read();\n        while(ch < '0' || '9' < ch) ch = jin.read();\n        while('0'<= ch && ch <= '9') {\n            res = res*10 + ch - '0';\n            ch = jin.read();\n        }\n        return res;\n    }\n}", "index": 64, "complexity": "0"}
{"forwhile": "class GFG { public static int N = 1000; static int prefixans[] = new int[1000]; public static void countIndex(int a[], int n) { int i = 0; while(i < n) { if(i + 1 < n && a[i] == a[i + 1]) prefixans[i] = 1; if(i != 0) prefixans[i] += prefixans[i - 1]; i++; } } public static int answer_query(int l, int r) { if(l == 0) return prefixans[r - 1]; else return prefixans[r - 1] - prefixans[l - 1]; } public static void main(String args[]) { int a[] = {1, 2, 2, 2, 3, 3, 4, 4, 4}; int n = 9; countIndex(a, n); int L, R; for(L = 1, R = 8; ; ) { System.out.println(answer_query(L, R)); break; } for(L = 0, R = 4; ; ) { System.out.println(answer_query(L, R)); break; } } }", "src": "class\nGFG { \n\npublic\nstatic\nint\nN = \n1000\n; \n\n\n\n\nstatic\nint\nprefixans[] = \nnew\nint\n[\n1000\n]; \n\n\npublic\nstatic\nvoid\ncountIndex(\nint\na[], \nint\nn) \n{ \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(i + \n1\n< n && a[i] == a[i + \n1\n]) \n\nprefixans[i] = \n1\n; \n\n\nif\n(i != \n0\n) \n\nprefixans[i] += prefixans[i - \n1\n]; \n\n} \n} \n\n\n\npublic\nstatic\nint\nanswer_query(\nint\nl, \nint\nr) \n{ \n\nif\n(l == \n0\n) \n\nreturn\nprefixans[r - \n1\n]; \n\nelse\n\nreturn\nprefixans[r - \n1\n] - \n\nprefixans[l - \n1\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = \n9\n; \n\n\n\n\ncountIndex(a, n); \n\n\nint\nL, R; \n\n\n\n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println(answer_query(L, R)); \n\n\n\n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println(answer_query(L, R)); \n} \n}", "index": 65, "complexity": "0"}
{"forwhile": "public class mainA {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        int x=enter.nextInt();\n        if(x%4==0){\n            System.out.println(1 +\" A\");\n        }\n        else if(x%4==1){\n            System.out.println(0+\" A\");\n        }\n        else if(x%4==2){\n            System.out.println(1+\" B\");\n        }\n        else if(x%4==3){\n            System.out.println(2+\" A\");\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            for(; stok == null || !stok.hasMoreTokens(); ) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            while(true) {\n                return Integer.parseInt(next());\n            }\n        }\n\n        long nextLong() throws IOException {\n            while(true) {\n                return Long.parseLong(next());\n            }\n        }\n\n        double nextDouble() throws IOException {\n            while(true) {\n                return Double.parseDouble(next());\n            }\n        }\n\n        char nextChar() throws IOException {\n            for(; (char) (br.read())!='\n'; ) {\n                return (char) (br.read());\n            }\n        }\n\n        String nextLine() throws IOException {\n            while(true) {\n                return br.readLine();\n            }\n        }\n    }\n}", "src": "public class mainA {\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static FastScanner enter = new FastScanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        int x=enter.nextInt();\n        if(x%4==0){\n            System.out.println(1 +\" A\");\n        }\n        else if(x%4==1){\n            System.out.println(0+\" A\");\n        }\n        else if(x%4==2){\n            System.out.println(1+\" B\");\n        }\n        else if(x%4==3){\n            System.out.println(2+\" A\");\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer stok;\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String next() throws IOException {\n            while (stok == null || !stok.hasMoreTokens()) {\n                String s = br.readLine();\n                if (s == null) {\n                    return null;\n                }\n                stok = new StringTokenizer(s);\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() throws IOException {\n            return (char) (br.read());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}", "index": 67, "complexity": "0"}
{"forwhile": "public class problem2 {\n    static class tile implements Comparable<tile> {\n        int number;\n        int suit;\n\n        public int compareTo(tile b){\n\n            return number - b.number;\n        }\n\n    }\n    public static void main(String[] args) {\n\n\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] parts = line.split(\" \");\n\n        tile[] tiles = new tile[3];\n        int i = 0;\n        while(i < 3){\n\n            tiles[i] = new tile();\n            tiles[i].number = parts[i].charAt(0) - '0';\n            if(parts[i].substring(1,2).equals(\"s\"))tiles[i].suit = 1;\n            if(parts[i].substring(1,2).equals(\"m\"))tiles[i].suit = 2;\n            if(parts[i].substring(1,2).equals(\"p\"))tiles[i].suit = 3;\n            i++;\n        }\n        Arrays.sort(tiles);\n\n        int[][] tilesObtained = new int[10][4];\n        int[][] stairCases = new int[10][4];\n        int[][] stairCases2 = new int[10][4];\n        int j = 0;\n        while(j < 3){\n            int currNumber = tiles[j].number;\n            int currSuit = tiles[j].suit;\n\n            tilesObtained[currNumber][currSuit]++;\n            stairCases[currNumber][currSuit] = 1 + stairCases[currNumber-1][currSuit];\n            if(currNumber != 1){\n                int k = currNumber-2;\n                while(stairCases2[k][currSuit] != 0){\n                    stairCases2[currNumber][currSuit] = 2;\n                    break;\n                }\n                if(stairCases2[currNumber][currSuit] != 2){\n                    stairCases2[currNumber][currSuit] = 1;\n                }\n            }\n            else{\n                stairCases2[currNumber][currSuit]++;\n            }\n            j++;\n\n\n        }\n        int best = 3;\n\n        for(int i = 1; i <= 9; i++){\n\n            for(int j = 1; j <= 3; j++){\n\n                best = Math.min(best, 3 - tilesObtained[i][j]);\n                best = Math.min(best, 3 - stairCases[i][j]);\n                best = Math.min(best, 3- stairCases2[i][j]);\n                if(best < 0) best = 0;\n            }\n        }\n        System.out.println(best);\n\n\n    }\n}", "src": "public class problem2 {\n    static class tile implements Comparable<tile> {\n        int number;\n        int suit;\n\n        public int compareTo(tile b){\n\n            return number - b.number;\n        }\n\n    }\n    public static void main(String[] args) {\n\n\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] parts = line.split(\" \");\n\n        tile[] tiles = new tile[3];\n        for(int i = 0; i < 3; i++){\n\n            tiles[i] = new tile();\n            tiles[i].number = parts[i].charAt(0) - '0';\n            if(parts[i].substring(1,2).equals(\"s\"))tiles[i].suit = 1;\n            if(parts[i].substring(1,2).equals(\"m\"))tiles[i].suit = 2;\n            if(parts[i].substring(1,2).equals(\"p\"))tiles[i].suit = 3;\n            \n        }\n        Arrays.sort(tiles);\n\n        int[][] tilesObtained = new int[10][4];\n        int[][] stairCases = new int[10][4];\n        int[][] stairCases2 = new int[10][4];\n        for(int i = 0; i < 3; i++){\n            int currNumber = tiles[i].number;\n            int currSuit = tiles[i].suit;\n\n            tilesObtained[currNumber][currSuit]++;\n            stairCases[currNumber][currSuit] = 1 + stairCases[currNumber-1][currSuit];\n            if(currNumber != 1){\n                if(stairCases2[currNumber-2][currSuit] != 0){\n                    stairCases2[currNumber][currSuit] = 2;\n                }\n                else{\n                    stairCases2[currNumber][currSuit] = 1;\n                }\n            }\n            else{\n                stairCases2[currNumber][currSuit]++;\n            }\n\n\n        }\n        int best = 3;\n\n        for(int i = 1; i <= 9; i++){\n\n            for(int j = 1; j <= 3; j++){\n\n                best = Math.min(best, 3 - tilesObtained[i][j]);\n                best = Math.min(best, 3 - stairCases[i][j]);\n                best = Math.min(best, 3- stairCases2[i][j]);\n                if(best <0)best = 0;\n            }\n        }\n        System.out.println(best);\n\n\n    }\n}", "index": 69, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static char returnLetter(int n)\n\t{\n\t\tif(n%4==1)\n\t\t{\n\t\t\treturn 'A';\n\t\t}\n\t\telse if(n%4==3)\n\t\t{\n\t\t\treturn 'B';\n\t\t}\n\t\telse if(n%4==2)\n\t\t{\n\t\t\treturn 'C';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'D';\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tString[] a= new String[3];\n\t\t\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i]=sc.next();\n\t\t}\n\t\tboolean equal=true;\n\t\t\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)!=a[i-1].charAt(0))\n\t\t\t{\n\t\t\t\tequal=false;break;\n\t\t\t}\n\t\t}\n\t\tif(equal)\n\t\t{\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tArrays.sort(a);\n\t\t\tboolean ord=true;\n\t\t\t\n\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\tif(a[i].charAt(1)!=a[i-1].charAt(1) || a[i].charAt(0)-a[i-1].charAt(0)!=1)\n\t\t\t\t{\n\t\t\t\t\tord=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord)\n\t\t\t{\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==2)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[2].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[0].charAt(1) && a[2].charAt(0)-a[0].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[1].charAt(1) && a[0].charAt(0)-a[1].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[2].charAt(1) && a[1].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[0].charAt(1)==a[2].charAt(1) && a[0].charAt(0)-a[2].charAt(0)==1)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[1].charAt(1)==a[0].charAt(1) && a[1].charAt(0)==a[0].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse if(a[2].charAt(1)==a[1].charAt(1) && a[1].charAt(0)==a[2].charAt(0))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(1);\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tint start = 0;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t}\n}", "index": 70, "complexity": "0"}
{"forwhile": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        KingEscape solver = new KingEscape();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class KingEscape {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int qx = in.nextInt();\n            int qy = in.nextInt();\n            int kx = in.nextInt();\n            int ky = in.nextInt();\n            int safex = in.nextInt();\n            int safey = in.nextInt();\n            boolean possible = false;\n            if (qx > Math.max(kx, safex) || qx < Math.min(kx, safex)) {\n                if (qy > Math.max(ky, safey) || qy < Math.min(ky, safey)) {\n                    possible = true;\n                }\n            }\n            if (possible) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            int i = 0;\n            while (i < objects.length) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n                i++;\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            int res = 0;\n            for (; numChars != -1;) {\n                if (curChar >= numChars) {\n                    curChar = 0;\n                    try {\n                        numChars = stream.read(buf);\n                    } catch (IOException e) {\n                        throw new InputMismatchException();\n                    }\n                    if (numChars <= 0) {\n                        return -1;\n                    }\n                }\n                res = buf[curChar++];\n                return res;\n            }\n            return res;\n        }\n\n        public int nextInt() {\n            int c = read();\n            for (; !isSpaceChar(c);) {\n                c = read();\n            }\n            int sgn = 1;\n            for (; c == '-';) {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            boolean isSpace = false;\n            for (; filter != null;) {\n                return filter.isSpaceChar(c);\n            }\n            for (; !isWhitespace(c);) {\n                return isSpace;\n            }\n            return isSpace;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        KingEscape solver = new KingEscape();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class KingEscape {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int qx = in.nextInt();\n            int qy = in.nextInt();\n            int kx = in.nextInt();\n            int ky = in.nextInt();\n            int safex = in.nextInt();\n            int safey = in.nextInt();\n            boolean possible = false;\n            if (qx > Math.max(kx, safex) || qx < Math.min(kx, safex)) {\n                if (qy > Math.max(ky, safey) || qy < Math.min(ky, safey)) {\n                    possible = true;\n                }\n            }\n            if (possible) out.println(\"YES\");\n            else out.println(\"NO\");\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 71, "complexity": "0"}
{"forwhile": "public class main {\n    public static void main(String[] args) throws IOException {\n        init();\n        int x = nextInt();\n        int y = nextInt();\n        int z = nextInt();\n        int t1 = nextInt();\n        int t2 = nextInt();\n        int t3 = nextInt();\n        int lift = Math.abs(z - x) * t2 + 2 * t3 + Math.abs(x - y) * t2 + t3;\n        int stair = Math.abs(x - y) * t1;\n        if (lift <= stair) {\n            pw.print(\"YES\");\n        } else {\n            pw.print(\"NO\");\n        }\n        pw.close();\n    }\n\n    static StringTokenizer st;\n    static BufferedReader sc;\n    static PrintWriter pw;\n\n    static String next() throws IOException {\n        for(; st == null || !st.hasMoreElements(); st = new StringTokenizer(sc.readLine())) {\n        }\n        return st.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static void init(String in, String out) throws IOException {\n        for(sc = new BufferedReader(new FileReader(in)), pw = new PrintWriter(out);; ) {\n        }\n    }\n\n    static void init() {\n        for(sc = new BufferedReader(new InputStreamReader(System.in)), pw = new PrintWriter(System.out);; ) {\n        }\n    }\n}\n\nclass DSU {\n    int parent[];\n    public DSU(int n){\n        for(int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int get(int i){\n        for(; i != parent[i]; i = parent[i]) {\n        }\n        return i;\n    }\n\n    boolean union(int a, int b){\n        for(a = get(a), b = get(b); a != b; parent[a] = b, a = get(a), b = get(b)) {\n        }\n        return a != b;\n    }\n}", "src": "public class main {\n    public static void main(String[] args) throws IOException {\n        init();\n        int x = nextInt();\n        int y = nextInt();\n        int z = nextInt();\n        int t1 = nextInt();\n        int t2 = nextInt();\n        int t3 = nextInt();\n        int lift = Math.abs(z - x) * t2 + 2 * t3 + Math.abs(x - y) * t2 + t3;\n        int stair = Math.abs(x - y) * t1;\n        if (lift <= stair) {\n            pw.print(\"YES\");\n        } else {\n            pw.print(\"NO\");\n        }\n        pw.close();\n    }\n\n    static StringTokenizer st;\n    static BufferedReader sc;\n    static PrintWriter pw;\n\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreElements()) {\n            st = new StringTokenizer(sc.readLine());\n        }\n        return st.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static void init(String in, String out) throws IOException {\n        sc = new BufferedReader(new FileReader(in));\n        pw = new PrintWriter(out);\n    }\n\n    static void init() {\n        sc = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n    }\n}\n\nclass DSU {\n    int parent[];\n    public DSU(int n){\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int get(int i){\n        if (i == parent[i]){\n            return i;\n        }\n        int p = get(parent[i]);\n        parent[i] = p;\n        return p;\n    }\n\n    boolean union(int a, int b){\n        a = get(a);\n        b = get(b);\n        if (a == b) return false;\n        parent[a] = b;\n        return true;\n    }\n}", "index": 73, "complexity": "0"}
{"forwhile": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int q=scan.nextInt();\n        int i = 1;\n        while(i<=q)\n        {\n            int a=scan.nextInt();\n            int ans=a/7+1;\n            System.out.println(ans);\n            i++;\n        }\n    }\n}", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int q=scan.nextInt();\n        int i;\n        for(i=1;i<=q;i++)\n        {\n            int a=scan.nextInt();\n            int ans=a/7+1;\n            System.out.println(ans);\n        }\n    }\n}", "index": 77, "complexity": "0"}
{"forwhile": "public class Main {\n    static Scanner scan = new Scanner(System.in);\n\n    public static void main(String [] args){\n        int num = scan.nextInt();\n        int i = 0;\n        while(i<num){\n            int a = scan.nextInt();\n            int b = scan.nextInt();\n            System.out.println(a+\" \"+2*a);\n            i++;\n        }\n    }\n}", "src": "public class Main {\n    static Scanner scan = new Scanner(System.in);\n\n    public static void main(String [] args){\n        int num = scan.nextInt();\n        for(int i=0;i<num;i++){\n            int a = scan.nextInt();\n            int b = scan.nextInt();\n            System.out.println(a+\" \"+2*a);\n        }\n    }\n}", "index": 78, "complexity": "0"}
{"forwhile": "public class b {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        Scanner zizo = new Scanner(System.in);\n        PrintWriter wr = new PrintWriter(System.out);\n        \n        int n1 = 0, n2 = 0, n3 = 0, n4 = 0;\n        int n = 3;\n        for(; n --> 0;) {\n            int x = zizo.nextInt();\n            switch(x) {\n                case 1: n1++; break;\n                case 4: n4++; break;\n                case 2: n2++; break;\n                case 3: n3++; break;\n            }\n        }\n        n2 += n4 / 2;\n        if (n1 > 0 || n2 > 1 || n3 > 2)\n            System.out.println(\"YES\");\n        else System.out.println(\"NO\");\n        wr.close();\n    }\n}\n\nclass pair{\n    int l,r;\n    pair(int a, int b){\n        l = a;\n        r = b;\n    }\n}\n\nclass Scanner \n{\n    StringTokenizer st;\n    BufferedReader br;\n\n    public Scanner(InputStream s){\n        br = new BufferedReader(new InputStreamReader(s));\n    }\n\n    public String next() throws IOException \n    {\n        while (st == null || !st.hasMoreTokens()) \n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public String nextLine() throws IOException {\n        return br.readLine();\n    }\n\n    public double nextDouble() throws IOException\n    {\n        String x = next();\n        StringBuilder sb = new StringBuilder(\"0\");\n        double res = 0, f = 1;\n        boolean dec = false, neg = false;\n        int start = 0;\n        if(x.charAt(0) == \\'-\")\n        {\n            neg = true;\n            start++;\n        }\n        for(; start < x.length(); start++)\n            if(x.charAt(start) == \\'.'\")\n            {\n                res = Long.parseLong(sb.toString());\n                sb = new StringBuilder(\"0\");\n                dec = true;\n            }\n            else\n            {\n                sb.append(x.charAt(start));\n                if(dec)\n                    f *= 10;\n            }\n        res += Long.parseLong(sb.toString()) / f;\n        return res * (neg?-1:1);\n    }\n\n    public boolean ready() throws IOException {\n        return br.ready();\n    }\n}", "src": "public class b {\n\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tScanner zizo = new Scanner(System.in);\n\t\tPrintWriter wr = new PrintWriter(System.out);\n\t\t\n\t\tint n1 = 0,n2 = 0,n3 = 0,n4 = 0;\n\t\tint n = 3;\n\t\twhile(n --> 0) {\n\t\t\tint x = zizo.nextInt();\n\t\t\tswitch(x) {\n\t\t\tcase 1:n1++;break;\n\t\t\tcase 4:n4++;break;\n\t\t\tcase 2:n2++;break;\n\t\t\tcase 3:n3++;break;\n\t\t\t}\n\t\t}\n\t\tn2 += n4/2;\n\t\tif(n1>0 || n2>1 || n3>2)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t\twr.close();\n\t}\n}\nclass pair{\n\tint l,r;\n\tpair(int a,int b){l = a;r = b;}\n}\n\nclass Scanner \n{\n\tStringTokenizer st;\n\tBufferedReader br;\n\n\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\tpublic String next() throws IOException \n\t{\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\tpublic double nextDouble() throws IOException\n\t{\n\t\tString x = next();\n\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\tdouble res = 0, f = 1;\n\t\tboolean dec = false, neg = false;\n\t\tint start = 0;\n\t\tif(x.charAt(0) == '-')\n\t\t{\n\t\t\tneg = true;\n\t\t\tstart++;\n\t\t}\n\t\tfor(int i = start; i < x.length(); i++)\n\t\t\tif(x.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\tdec = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\tif(dec)\n\t\t\t\t\tf *= 10;\n\t\t\t}\n\t\tres += Long.parseLong(sb.toString()) / f;\n\t\treturn res * (neg?-1:1);\n\t}\n\n\tpublic boolean ready() throws IOException {return br.ready();}\n}", "index": 80, "complexity": "0"}
{"forwhile": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\tfor(; st == null || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\twhile (i < n) {\n\t\t\ta[i] = nextInt();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (; i < n; i++) {\n\t\t\tfor (; j < m; j++) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\twhile (i < n) {\n\t\t\ta[i] = nextLong();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class TrickyAlchemy {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong a = nextLong();\n\t\tlong b = nextLong();\n\t\tlong x = nextLong();\n\t\tlong y = nextLong();\n\t\tlong z = nextLong();\n\t\tSystem.out.println(Math.max(2*x+y-a, 0) + Math.max(y+3*z-b, 0));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 81, "complexity": "0"}
{"forwhile": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner kai = new Scanner(System.in);\n\t\tfor(; kai.hasNext(); ) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner kai = new Scanner(System.in);\n\t\twhile (kai.hasNext()) {\n\t\t\tint a = kai.nextInt();\n\t\t\tif ((a & 1) == 0) {\n\t\t\t\tSystem.out.println(\"Mahmoud\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"Ehab\");\n\t\t\t}\n\t\t}\n\t}\n}", "index": 84, "complexity": "0"}
{"forwhile": "public class PizzaPizzaPizza {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong n = nextLong();\n\t\tif (n == 0)\n\t\t\tSystem.out.println(0);\n\t\telse if (n % 2 == 0)\n\t\t\tSystem.out.println(n+1);\n\t\telse\n\t\t\tSystem.out.println((n+1)/2);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\tfor(; !(st != null && st.hasMoreTokens()); st = new StringTokenizer(in.readLine())){\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\tfor(; !(st != null && st.hasMoreTokens()); st = new StringTokenizer(in.readLine())){\n\t\t}\n\t\treturn Integer.parseInt(st.nextToken());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\tfor(; !(st != null && st.hasMoreTokens()); st = new StringTokenizer(in.readLine())){\n\t\t}\n\t\treturn Long.parseLong(st.nextToken());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\ta[i] = nextInt();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\tint j = 0;\n\t\t\twhile(j < m) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\ta[i] = nextLong();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class PizzaPizzaPizza {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tlong n = nextLong();\n\t\tif (n == 0)\n\t\t\tSystem.out.println(0);\n\t\telse if (n % 2 == 0)\n\t\t\tSystem.out.println(n+1);\n\t\telse\n\t\t\tSystem.out.println((n+1)/2);\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 85, "complexity": "0"}
{"forwhile": "public class AlexAndARhombus {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tSystem.out.println(n*n+(n-1)*(n-1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\tfor(; st == null || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\tfor(; !(st == null) || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\tfor(; !(st == null) || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn Integer.parseInt(st.nextToken());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\tfor(; !(st == null) || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn Long.parseLong(st.nextToken());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\ta[i] = nextInt();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\tint j = 0;\n\t\t\twhile(j < m) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\ta[i] = nextLong();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class AlexAndARhombus {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tSystem.out.println(n*n+(n-1)*(n-1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 87, "complexity": "0"}
{"forwhile": "ERROR:Unterminated string starting at: line 6 column 33 (char 8845)", "src": "public class simple implements Runnable {\n\n\n    public void run()\n    {\n\n        InputReader input = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = input.nextInt();\n\n            System.out.println((2*n*n)-(2*n)+1);\n    }\n\n\n\n    class Graph{\n        private final int v;\n        private List<List<Integer>> adj;\n        Graph(int v){\n            this.v = v;\n            adj = new ArrayList<>(v);\n            for(int i=0;i<v;i++){\n                adj.add(new LinkedList<>());\n            }\n        }\n        private void addEdge(int a,int b){\n            adj.get(a).add(b);\n        }\n        private boolean isCyclic()\n        {\n            boolean[] visited = new boolean[v];\n            boolean[] recStack = new boolean[v];\n            for (int i = 0; i < v; i++)\n                if (isCyclicUtil(i, visited, recStack))\n                    return true;\n\n            return false;\n        }\n        private boolean isCyclicUtil(int i, boolean[] visited, boolean[] recStack)\n        {\n            if (recStack[i])\n                return true;\n            if (visited[i])\n                return false;\n            visited[i] = true;\n            recStack[i] = true;\n            List<Integer> children = adj.get(i);\n            for (Integer c: children)\n                if (isCyclicUtil(c, visited, recStack))\n                    return true;\n            recStack[i] = false;\n            return false;\n        }\n    }\n    public static void sortbyColumn(int arr[][], int col)\n    {\n\n        Arrays.sort(arr, new Comparator<int[]>()\n        {\n            public int compare(int[] o1, int[] o2){\n                return(Integer.valueOf(o1[col]).compareTo(o2[col]));\n            }\n        });\n\n    }\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public static class DJSet {\n        public int[] upper;\n\n        public DJSet(int n) {\n            upper = new int[n];\n            Arrays.fill(upper, -1);\n        }\n\n        public int root(int x) {\n            return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n        }\n\n        public boolean equiv(int x, int y) {\n            return root(x) == root(y);\n        }\n\n        public boolean union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if (x != y) {\n                if (upper[y] < upper[x]) {\n                    int d = x;\n                    x = y;\n                    y = d;\n                }\n                upper[x] += upper[y];\n                upper[y] = x;\n            }\n            return x == y;\n        }\n    }\n    public static int[] radixSort(int[] f)\n    {\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]&0xffff)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]&0xffff]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for(int i = 0;i < f.length;i++)b[1+(f[i]>>>16)]++;\n            for(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n            for(int i = 0;i < f.length;i++)to[b[f[i]>>>16]++] = f[i];\n            int[] d = f; f = to;to = d;\n        }\n        return f;\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new simple(),\"TaskA\",1<<26).start();\n    }\n}", "index": 88, "complexity": "0"}
{"forwhile": "class Test { static int binarySearch(int arr[], int l, int r, int x) { if(r>=l) { int mid = l + (r - l)/2; if(arr[mid] == x) return mid; if(arr[mid] > x) return binarySearch(arr, l, mid-1, x); return binarySearch(arr, mid+1, r, x); } return -1; } static int findPos(int arr[], int key) { int l = 0, h = 1; int val = arr[0]; for(; val < key; l = h) { if(2*h < arr.length-1) h = 2*h; else h = arr.length-1; val = arr[h]; } return binarySearch(arr, l, h, key); } public static void main(String[] args) { int arr[] = new int[]{3, 5, 7, 9, 10, 90, 100, 130, 140, 160, 170}; int ans = findPos(arr, 10); if(ans==-1) System.out.println(\"Element not found\"); else System.out.println(\"Element found at index \"+ ans); } }", "src": "class\nTest \n{ \n\n\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nif\n(r>=l) \n\n{ \n\nint\nmid = l + (r - l)/\n2\n; \n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, mid-\n1\n, x); \n\nreturn\nbinarySearch(arr, mid+\n1\n, r, x); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindPos(\nint\narr[],\nint\nkey) \n\n{ \n\nint\nl = \n0\n, h = \n1\n; \n\nint\nval = arr[\n0\n]; \n\n\n\n\nwhile\n(val < key) \n\n{ \n\nl = h; \n\n\n\n\n\n\nif\n(\n2\n*h < arr.length-\n1\n) \n\nh = \n2\n*h; \n\nelse\n\nh = arr.length-\n1\n; \n\n\nval = arr[h]; \n\n\n} \n\n\n\n\n\n\n\n\nreturn\nbinarySearch(arr, l, h, key); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n3\n, \n5\n, \n7\n, \n9\n, \n10\n, \n90\n, \n\n100\n, \n130\n, \n140\n, \n160\n, \n170\n}; \n\nint\nans = findPos(arr,\n10\n); \n\n\nif\n(ans==-\n1\n) \n\nSystem.out.println(\n\"Element not found\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at index \"\n+ ans); \n\n} \n}", "index": 90, "complexity": "2"}
{"forwhile": "public class BinarySearch {\n\n    \n    private static int binarySearch(int[] a, int n) {\n        return binarySearch(a, n, 0, a.length - 1);\n    }\n\n    public static int binarySearch(int[] a, int n, int low, int high) {\n\n        int i = low;\n        while (i <= high) {\n            int mid = (i + high) / 2; \n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                return binarySearch(a, n, 0, mid - 1);\n            } else {\n                return binarySearch(a, n, mid + 1, high);\n            }\n            i++;\n        }\n        return -1;\n    }\n\n    \n    private static int binarySearchNonRecursive(int[] a, int n) {\n        int low = 0, high = a.length, mid;\n        for(int i = low; i <= high; i++) {\n            mid = (i + high) / 2; \n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    \n    public static void main(String[] args) {\n        System.out.println(binarySearch(new int[]{0, 2}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearch(new int[]{0, 2}, 0));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 2, 2, 3, 3}, 2)); \n        System.out.println(\"---------\");\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 0));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 2, 2, 3, 3}, 2));\n    }\n}", "src": "public class BinarySearch {\n\n    \n    private static int binarySearch(int[] a, int n) {\n        return binarySearch(a, n, 0, a.length - 1);\n    }\n\n    public static int binarySearch(int[] a, int n, int low, int high) {\n\n        if (low <= high) {\n            int mid = (low + high) / 2; \n\n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                return binarySearch(a, n, 0, mid - 1);\n            } else {\n                return binarySearch(a, n, mid + 1, high);\n            }\n        } else {\n            return -1;\n        }\n    }\n\n    \n    private static int binarySearchNonRecursive(int[] a, int n) {\n        int low = 0, high = a.length, mid;\n        while (low <= high) {\n            mid = (low + high) / 2; \n            if (n == a[mid]) {\n                return mid;\n            } else if (n < a[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    \n    public static void main(String[] args) {\n        System.out.println(binarySearch(new int[]{0, 2}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearch(new int[]{0, 2}, 0));\n        System.out.println(binarySearch(new int[]{0, 1, 2, 2, 2, 3, 3}, 2)); \n        System.out.println(\"---------\");\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 2));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 3}, 3));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 2}, 0));\n        System.out.println(binarySearchNonRecursive(new int[]{0, 1, 2, 2, 2, 3, 3}, 2));\n    }\n}", "index": 93, "complexity": "2"}
{"forwhile": "public class MedianOfTwoSortedArrayOfDifferentLength {\n\n    public double findMedianSortedArrays(int input1[], int input2[]) {\n        \n        if (input1.length > input2.length) {\n            return findMedianSortedArrays(input2, input1);\n        }\n        int x = input1.length;\n        int y = input2.length;\n\n        int low = 0;\n        int high = x;\n        for(int partitionX = (low + high)/2, partitionY = (x + y + 1)/2 - partitionX; low <= high; partitionX = (low + high)/2, partitionY = (x + y + 1)/2 - partitionX) {\n\n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : input1[partitionX - 1];\n            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : input1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : input2[partitionY - 1];\n            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : input2[partitionY];\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                \n                \n                \n                if ((x + y) % 2 == 0) {\n                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY))/2;\n                } else {\n                    return (double)Math.max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) { \n                high = partitionX - 1;\n            } else { \n                low = partitionX + 1;\n            }\n        }\n\n        \n        throw new IllegalArgumentException();\n    }\n\n    public static void main(String[] args) {\n        int[] x = {1, 3, 8, 9, 15};\n        int[] y = {7, 11, 19, 21, 18, 25};\n\n        MedianOfTwoSortedArrayOfDifferentLength mm = new MedianOfTwoSortedArrayOfDifferentLength();\n        mm.findMedianSortedArrays(x, y);\n    }\n}", "src": "public class MedianOfTwoSortedArrayOfDifferentLength {\n\n    public double findMedianSortedArrays(int input1[], int input2[]) {\n        \n        if (input1.length > input2.length) {\n            return findMedianSortedArrays(input2, input1);\n        }\n        int x = input1.length;\n        int y = input2.length;\n\n        int low = 0;\n        int high = x;\n        while (low <= high) {\n            int partitionX = (low + high)/2;\n            int partitionY = (x + y + 1)/2 - partitionX;\n\n            \n            \n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : input1[partitionX - 1];\n            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : input1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : input2[partitionY - 1];\n            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : input2[partitionY];\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                \n                \n                \n                if ((x + y) % 2 == 0) {\n                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY))/2;\n                } else {\n                    return (double)Math.max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) { \n                high = partitionX - 1;\n            } else { \n                low = partitionX + 1;\n            }\n        }\n\n        \n        throw new IllegalArgumentException();\n    }\n\n    public static void main(String[] args) {\n        int[] x = {1, 3, 8, 9, 15};\n        int[] y = {7, 11, 19, 21, 18, 25};\n\n        MedianOfTwoSortedArrayOfDifferentLength mm = new MedianOfTwoSortedArrayOfDifferentLength();\n        mm.findMedianSortedArrays(x, y);\n    }\n}", "index": 95, "complexity": "2"}
{"forwhile": "public class FloorAndCeilingSortedArray {\n\n    public int floor(int input[], int x){\n        for(int low = 0,  high = input.length-1; low <= high;) {\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] < x && (middle == input.length-1 || input[middle+1] > x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n\n    public int ceiling(int input[], int x){\n        for(int low = 0, high = input.length-1; low <= high;) {\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] > x && (middle == 0 || input[middle-1] < x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        int input[] = {1,2,5,6,11,15};\n        FloorAndCeilingSortedArray foc = new FloorAndCeilingSortedArray();\n        System.out.println(foc.floor(input, 15));\n        System.out.println(foc.ceiling(input, 2));\n    }\n}", "src": "public class FloorAndCeilingSortedArray {\n\n    public int floor(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] < x && (middle == input.length-1 || input[middle+1] > x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n\n    public int ceiling(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x || (input[middle] > x && (middle == 0 || input[middle-1] < x))){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        int input[] = {1,2,5,6,11,15};\n        FloorAndCeilingSortedArray foc = new FloorAndCeilingSortedArray();\n        System.out.println(foc.floor(input, 15));\n        System.out.println(foc.ceiling(input, 2));\n    }\n}", "index": 96, "complexity": "2"}
{"forwhile": "public class BinarySearch {\n\n    public int search(final int input[], int search) {\n        int low = 0;\n        int high = input.length - 1;\n        int mid;\n        for (int index = 0; index <= high; index++) {\n            mid = low + ((high - low) / 2);\n            if (input[mid] == search) {\n                return mid;\n            } else if (input[mid] < search) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        BinarySearch bSearch = new BinarySearch();\n        final int arr1[] = {1, 2, 4, 5, 7, 8};\n        System.out.println(bSearch.search(arr1, -1));\n        System.out.println(bSearch.search(arr1, 1));\n        System.out.println(bSearch.search(arr1, 8));\n        System.out.println(bSearch.search(arr1, 2));\n    }\n}", "src": "public class BinarySearch {\n\n    public int search(final int input[], int search) {\n        int low = 0;\n        int high = input.length - 1;\n        int mid;\n        while (low <= high) {\n            mid = low + ((high - low) / 2);\n            if (input[mid] == search) {\n                return mid;\n            } else if (input[mid] < search) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        BinarySearch bSearch = new BinarySearch();\n        final int arr1[] = {1, 2, 4, 5, 7, 8};\n        System.out.println(bSearch.search(arr1, -1));\n        System.out.println(bSearch.search(arr1, 1));\n        System.out.println(bSearch.search(arr1, 8));\n        System.out.println(bSearch.search(arr1, 2));\n    }\n}", "index": 99, "complexity": "2"}
{"forwhile": "public class CircularBinarySearch {\n\n    \n    \n    public int search(int arr[]) {\n        int low = 0;\n        int high = arr.length - 1;\n        int mid = 0;\n        for(; low < high; mid = (low + high) / 2) {\n            \n            if((low == mid || arr[mid] < arr[mid-1])&& arr[mid] < arr[mid+1]){\n                return arr[mid];\n            }\n            if ((arr[mid] >= arr[low] && arr[mid] >= arr[high])){\n                if(arr[low] < arr[high]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }else{\n                if(arr[mid-1] < arr[mid+1]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return arr[low];\n    }\n\n    public static void main(String args[]) {\n        CircularBinarySearch cbs = new CircularBinarySearch();\n        int arr[] = { 7, 10, 8, 5, 2, 3, 5 };\n        System.out.print(cbs.search(arr));\n\n        int arr1[] = { 5, 8, 10, 7, 5, 3, 2 };\n        System.out.print(cbs.search(arr1));\n\n        int arr2[] = { 3, 5, 7, 10, 8, 5, 2 };\n        System.out.print(cbs.search(arr2));\n\n        int arr3[] = { 8, 5, 2, 3, 5, 7, 10 };\n        System.out.print(cbs.search(arr3));\n\n        int arr4[] = { 5, 3, 2, 5, 8, 10, 7 };\n        System.out.print(cbs.search(arr4));\n\n        int arr5[] = {100,20,10,5,2,8,11,16,19};\n        System.out.print(cbs.search(arr5));\n\n        int arr6[] = {200,2,10,15,20,80,110,160,190};\n        System.out.print(cbs.search(arr6));\n\n        int arr7[] = {5,10,20,50,200,800,1100,1600,1900,2};\n        System.out.print(cbs.search(arr7));\n\n        int arr8[] = {2,5,10,20,50,200,800,1100,1600,1900};\n        System.out.print(cbs.search(arr8));\n        \n        int arr9[] = {3,1,8,5,4};\n        System.out.print(cbs.search(arr9));\n        \n    }\n}", "src": "public class CircularBinarySearch {\n\n    \n    \n    public int search(int arr[]) {\n        int low = 0;\n        int high = arr.length - 1;\n        int mid = 0;\n        while (low < high) {\n            mid = (low + high) / 2;\n            \n            if((low == mid || arr[mid] < arr[mid-1])&& arr[mid] < arr[mid+1]){\n                return arr[mid];\n            }\n            if ((arr[mid] >= arr[low] && arr[mid] >= arr[high])){\n                if(arr[low] < arr[high]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }else{\n                if(arr[mid-1] < arr[mid+1]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return arr[low];\n    }\n\n    public static void main(String args[]) {\n        CircularBinarySearch cbs = new CircularBinarySearch();\n        int arr[] = { 7, 10, 8, 5, 2, 3, 5 };\n        System.out.print(cbs.search(arr));\n\n        int arr1[] = { 5, 8, 10, 7, 5, 3, 2 };\n        System.out.print(cbs.search(arr1));\n\n        int arr2[] = { 3, 5, 7, 10, 8, 5, 2 };\n        System.out.print(cbs.search(arr2));\n\n        int arr3[] = { 8, 5, 2, 3, 5, 7, 10 };\n        System.out.print(cbs.search(arr3));\n\n        int arr4[] = { 5, 3, 2, 5, 8, 10, 7 };\n        System.out.print(cbs.search(arr4));\n\n        int arr5[] = {100,20,10,5,2,8,11,16,19};\n        System.out.print(cbs.search(arr5));\n\n        int arr6[] = {200,2,10,15,20,80,110,160,190};\n        System.out.print(cbs.search(arr6));\n\n        int arr7[] = {5,10,20,50,200,800,1100,1600,1900,2};\n        System.out.print(cbs.search(arr7));\n\n        int arr8[] = {2,5,10,20,50,200,800,1100,1600,1900};\n        System.out.print(cbs.search(arr8));\n        \n        int arr9[] = {3,1,8,5,4};\n        System.out.print(cbs.search(arr9));\n        \n    }\n}", "index": 100, "complexity": "2"}
{"forwhile": "public class MonotonicallyIncreasingFunctionBecomesPositive {\n\n    private int f(int x){\n        return x*x - 10*x - 20;\n    }\n    \n    public int findPoint(){\n        int i=1;\n        for(; f(i) <= 0; i = i*2){\n        }\n        return binarySearch(i/2,i);\n    }\n    \n    private int binarySearch(int start,int end){\n        int mid = (start+end)/2;\n        for(; start < end; mid = (start+end)/2){\n            if(f(mid) > 0 && f(mid-1) <= 0){\n                return mid;\n            }\n            if(f(mid) <= 0 && f(mid+1) > 0){\n                return mid+1;\n            }\n            if(f(mid) <= 0){\n                start = mid+1;\n            }else{\n                end = mid-1;\n            }\n        }\n        return mid;\n    }\n    \n    public static void main(String args[]){\n        MonotonicallyIncreasingFunctionBecomesPositive mif = new MonotonicallyIncreasingFunctionBecomesPositive();\n        System.out.print(mif.findPoint());\n    }\n}", "src": "public class MonotonicallyIncreasingFunctionBecomesPositive {\n\n    private int f(int x){\n        return x*x - 10*x - 20;\n    }\n    \n    public int findPoint(){\n        int i=1;\n        while(f(i) <=0 ){\n            i = i*2;\n        }\n        return binarySearch(i/2,i);\n    }\n    \n    private int binarySearch(int start,int end){\n        int mid = (start+end)/2;\n        while(start < end){\n            mid = (start+end)/2;\n            if(f(mid) >0 && f(mid-1) <=0){\n                return mid;\n            }\n            if(f(mid) <=0 && f(mid+1)>0){\n                return mid+1;\n            }\n            if(f(mid) <= 0){\n                start = mid+1;\n            }else{\n                end = mid-1;\n            }\n        }\n        return mid;\n    }\n    \n    public static void main(String args[]){\n        MonotonicallyIncreasingFunctionBecomesPositive mif = new MonotonicallyIncreasingFunctionBecomesPositive();\n        System.out.print(mif.findPoint());\n    }\n}", "index": 101, "complexity": "2"}
{"forwhile": "public class SortedAndRotatedArraySearch {\n\n    \n    public int search(int arr[],int search){\n        int low =0;\n        int high = arr.length-1;\n        for(int mid = (low + high)/2; low <= high; mid = (low + high)/2) {\n            if(arr[mid] == search){\n                return mid;\n            }\n            \n            if(arr[mid] < arr[high]){\n                if(arr[mid] < search && search <= arr[high]){\n                    low = mid+1;\n                }else{\n                    high = mid-1;\n                }\n            }else{\n                if(search >= arr[low] && search < arr[mid]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return -1;\n    }\n\n    \n    public boolean searchWithDuplicates(int[] arr, int search) {\n        int low =0;\n        int high = arr.length-1;\n        for(int mid = (low + high)/2; low <= high; mid = (low + high)/2) {\n            if(arr[mid] == search) {\n                return true;\n            }\n            \n            if (arr[mid] == arr[low]) {\n                low++;\n            } else if (arr[mid] == arr[high]) { \n                high--;\n            } else if (arr[mid] < arr[high]) {\n                if(arr[mid] < search && search <= arr[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if(search >= arr[low] && search < arr[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String args[]){\n        SortedAndRotatedArraySearch ras = new SortedAndRotatedArraySearch();\n        int arr1[] = {1,2,5,6,7,8,11,21};\n        System.out.print(ras.search(arr1, 1));\n        System.out.print(ras.search(arr1, 5));\n        System.out.print(ras.search(arr1, 22));\n        System.out.println();\n    \n        int arr2[] = {18,21,1,2,5,6,7,8,10,15};\n        System.out.print(ras.search(arr2, 1));\n        System.out.print(ras.search(arr2, 5));\n        System.out.print(ras.search(arr2, 10));\n        System.out.print(ras.search(arr2, 14));\n        System.out.println();\n\n        int arr3[] = {7,8,15,17,18,21,1,2,5,6};\n        System.out.print(ras.search(arr3, 1));\n        System.out.print(ras.search(arr3, 5));\n        System.out.print(ras.search(arr3, 10));\n        System.out.print(ras.search(arr3, 7));\n        System.out.print(ras.search(arr3, 6));\n        System.out.print(ras.search(arr3, 16));\n    }\n}", "src": "public class SortedAndRotatedArraySearch {\n\n    \n    public int search(int arr[],int search){\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search){\n                return mid;\n            }\n            \n            if(arr[mid] < arr[high]){\n                if(arr[mid] < search && search <= arr[high]){\n                    low = mid+1;\n                }else{\n                    high = mid-1;\n                }\n            }else{\n                if(search >= arr[low] && search < arr[mid]){\n                    high = mid-1;\n                }else{\n                    low = mid+1;\n                }\n            }\n        }\n        return -1;\n    }\n\n    \n    public boolean searchWithDuplicates(int[] arr, int search) {\n        int low =0;\n        int high = arr.length-1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(arr[mid] == search) {\n                return true;\n            }\n            \n            if (arr[mid] == arr[low]) {\n                low++;\n            } else if (arr[mid] == arr[high]) { \n                high--;\n            } else if (arr[mid] < arr[high]) {\n                if(arr[mid] < search && search <= arr[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            } else {\n                if(search >= arr[low] && search < arr[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String args[]){\n        SortedAndRotatedArraySearch ras = new SortedAndRotatedArraySearch();\n        int arr1[] = {1,2,5,6,7,8,11,21};\n        System.out.print(ras.search(arr1, 1));\n        System.out.print(ras.search(arr1, 5));\n        System.out.print(ras.search(arr1, 22));\n        System.out.println();\n    \n        int arr2[] = {18,21,1,2,5,6,7,8,10,15};\n        System.out.print(ras.search(arr2, 1));\n        System.out.print(ras.search(arr2, 5));\n        System.out.print(ras.search(arr2, 10));\n        System.out.print(ras.search(arr2, 14));\n        System.out.println();\n\n        int arr3[] = {7,8,15,17,18,21,1,2,5,6};\n        System.out.print(ras.search(arr3, 1));\n        System.out.print(ras.search(arr3, 5));\n        System.out.print(ras.search(arr3, 10));\n        System.out.print(ras.search(arr3, 7));\n        System.out.print(ras.search(arr3, 6));\n        System.out.print(ras.search(arr3, 16));\n    }\n}", "index": 102, "complexity": "2"}
{"forwhile": "public class SearchForRange {\n    public int[] searchRange(int[] nums, int target) {\n        int first = firstOccurence(nums, target);\n        if (first == -1) {\n            return new int[]{-1, -1};\n        }\n        int last = lastOccurence(nums, target);\n        return new int[]{first, last};\n    }\n\n    private int firstOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        for(; low <= high; ) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == 0 || nums[mid - 1] < target)) {\n                return mid;\n            } else if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    private int lastOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        for(; low <= high; ) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == nums.length - 1 || nums[mid + 1] > target)) {\n                return mid;\n            } else if (nums[mid] <= target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        SearchForRange searchForRange = new SearchForRange();\n        int[] nums = {0, 1, 1, 3, 6, 9, 11};\n        int[] r = searchForRange.searchRange(nums, 11);\n        System.out.println(r[0] + \" \" + r[1]);\n        r = searchForRange.searchRange(nums, 0);\n        System.out.println(r[0] + \" \" + r[1]);\n    }\n}", "src": "public class SearchForRange {\n    public int[] searchRange(int[] nums, int target) {\n        int first = firstOccurence(nums, target);\n        if (first == -1) {\n            return new int[]{-1, -1};\n        }\n        int last = lastOccurence(nums, target);\n        return new int[]{first, last};\n    }\n\n    private int firstOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == 0 || nums[mid - 1] < target)) {\n                return mid;\n            } else if (nums[mid] >= target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    private int lastOccurence(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low)/2;\n            if (nums[mid] == target && (mid == nums.length - 1 || nums[mid + 1] > target)) {\n                return mid;\n            } else if (nums[mid] <= target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        SearchForRange searchForRange = new SearchForRange();\n        int[] nums = {0, 1, 1, 3, 6, 9, 11};\n        int[] r = searchForRange.searchRange(nums, 11);\n        System.out.println(r[0] + \" \" + r[1]);\n        r = searchForRange.searchRange(nums, 0);\n        System.out.println(r[0] + \" \" + r[1]);\n    }\n}", "index": 103, "complexity": "2"}
{"forwhile": "public class PeakElement {\n\n    public int findPeakElement(int[] nums) {\n        int low = 0;\n        int high = nums.length - 1;\n        int middle = 0;\n        for (; low <= high;) {\n            middle = (low + high)/2;\n            int before = Integer.MIN_VALUE;\n            if (middle > 0) {\n                before = nums[middle - 1];\n            }\n            int after = Integer.MIN_VALUE;\n            if (middle < nums.length - 1) {\n                after = nums[middle + 1];\n            }\n            if (nums[middle] > before && nums[middle] > after) {\n                return middle;\n            } else if (before > after) {\n                high = middle - 1;\n            } else {\n                low = middle + 1;\n            }\n        }\n        return middle;\n    }\n\n    public static void main(String args[]){\n        int arr[] = {10,5,15,2,23,90,67};\n        PeakElement pe = new PeakElement();\n        System.out.println(pe.findPeakElement(arr));\n        int arr1[] = {10,20,30,40,50};\n        System.out.println(pe.findPeakElement(arr1));\n        int arr2[] = {100,90,80,70,60};\n        System.out.println(pe.findPeakElement(arr2));\n                \n    }\n}", "src": "public class PeakElement {\n\n    public int findPeakElement(int[] nums) {\n        int low = 0;\n        int high = nums.length - 1;\n        int middle = 0;\n        while (low <= high) {\n            middle = (low + high)/2;\n            int before = Integer.MIN_VALUE;\n            if (middle > 0) {\n                before = nums[middle - 1];\n            }\n            int after = Integer.MIN_VALUE;\n            if (middle < nums.length - 1) {\n                after = nums[middle + 1];\n            }\n            if (nums[middle] > before && nums[middle] > after) {\n                return middle;\n            } else if (before > after) {\n                high = middle - 1;\n            } else {\n                low = middle + 1;\n            }\n        }\n        return middle;\n    }\n\n    public static void main(String args[]){\n        int arr[] = {10,5,15,2,23,90,67};\n        PeakElement pe = new PeakElement();\n        System.out.println(pe.findPeakElement(arr));\n        int arr1[] = {10,20,30,40,50};\n        System.out.println(pe.findPeakElement(arr1));\n        int arr2[] = {100,90,80,70,60};\n        System.out.println(pe.findPeakElement(arr2));\n                \n    }\n}", "index": 104, "complexity": "2"}
{"forwhile": "public class FirstOccurrenceOfNumberInSortedArray {\n\n    public int firstOccurrence(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        \n        for(int i = 0; i <= high; i++){\n            int middle = (low + high)/2;\n            if(input[middle] == x && (middle == 0 || input[middle-1] < x)){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        FirstOccurrenceOfNumberInSortedArray fos = new FirstOccurrenceOfNumberInSortedArray();\n        int input[] = {1,2,2,2,2,2,5,7,7};\n        System.out.println(fos.firstOccurrence(input, 6));\n    }\n    \n}", "src": "public class FirstOccurrenceOfNumberInSortedArray {\n\n    public int firstOccurrence(int input[], int x){\n        int low = 0;\n        int high = input.length-1;\n        \n        while(low <= high){\n            int middle = (low + high)/2;\n            if(input[middle] == x && (middle == 0 || input[middle-1] < x)){\n                return middle;\n            }else if(input[middle] < x){\n                low = middle+1;\n            }else{\n                high = middle-1;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String args[]){\n        FirstOccurrenceOfNumberInSortedArray fos = new FirstOccurrenceOfNumberInSortedArray();\n        int input[] = {1,2,2,2,2,2,5,7,7};\n        System.out.println(fos.firstOccurrence(input, 6));\n    }\n    \n}", "index": 105, "complexity": "2"}
{"forwhile": "class CountOne {\n\n  public static void main(String[] args) {\n    int[] arr={0, 0, 0, 0, 0, 0, 0};\n    \n    \n    countOne(arr);\n  }\n\n  public static void countOne(int[] a)\n  {\n       int l = 0;\n       int h = a.length-1;\n       int mid = -1;\n      \n       for(int i = l; i<=h; i++)\n       {\n         mid = (l+h)/2;\n         \n         if( (mid == h || a[mid+1] == 0) && a[mid] == 1)\n         {\n             System.out.println(\"Count \" + (mid + 1));\n             return;\n         }\n           \n         if( a[mid] < 1)\n         {\n             h = mid - 1;\n         } else {\n             l = mid + 1;\n         } \n       }\n       System.out.println(\" No one's found \");\n       return;\n  }\n}", "src": "class CountOne {\n\n  public static void main(String[] args) {\n    int[] arr={0, 0, 0, 0, 0, 0, 0};\n    \n    \n    countOne(arr);\n  }\n\n  public static void countOne(int[] a)\n  {\n       int l = 0;\n       int h = a.length-1;\n       int mid = -1;\n      \n       while(l<=h)\n       {\n         mid = (l+h)/2;\n         \n         if( (mid == h || a[mid+1] == 0) && a[mid] == 1)\n         {\n             System.out.println(\"Count \" + (mid + 1));\n             return;\n         }\n           \n         if( a[mid] < 1)\n         {\n             h = mid - 1;\n         } else {\n             l = mid + 1;\n         } \n       }\n       System.out.println(\" No one's found \");\n       return;\n  }\n}", "index": 106, "complexity": "2"}
{"forwhile": "public\nclass\nGFG \n{ \n\n\n\nstatic\nStack<Integer> st= \nnew\nStack<>(); \n\n\n\n\nstatic\nvoid\npush_digits(\nint\nnumber) \n\n{ \n\nint i = 0; \nwhile(number != \n0\n) \n\n{ \n\nst.push(number % \n10\n); \n\nnumber = number / \n10\n; \n\ni++; \n} \n\n} \n\n\n\n\nstatic\nint\nreverse_number(\nint\nnumber) \n\n{ \n\n\n\n\n\npush_digits(number); \n\nint\nreverse = \n0\n; \n\nint\ni = \n1\n; \n\n\n\nfor(; !st.isEmpty(); st.pop()) \n\n{ \n\nreverse = reverse + (st.peek() * i); \n\ni = i * \n10\n; \n\n} \n\n\n\n\nreturn\nreverse; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nnumber = \n39997\n; \n\nSystem.out.println(reverse_number(number)); \n\n} \n}", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nStack<Integer> st= \nnew\nStack<>(); \n\n\n\n\nstatic\nvoid\npush_digits(\nint\nnumber) \n\n{ \n\nwhile\n(number != \n0\n) \n\n{ \n\nst.push(number % \n10\n); \n\nnumber = number / \n10\n; \n\n} \n\n} \n\n\n\n\nstatic\nint\nreverse_number(\nint\nnumber) \n\n{ \n\n\n\n\n\npush_digits(number); \n\nint\nreverse = \n0\n; \n\nint\ni = \n1\n; \n\n\n\n\n\n\nwhile\n(!st.isEmpty()) \n\n{ \n\nreverse = reverse + (st.peek() * i); \n\nst.pop(); \n\ni = i * \n10\n; \n\n} \n\n\n\n\nreturn\nreverse; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nnumber = \n39997\n; \n\nSystem.out.println(reverse_number(number)); \n\n} \n}", "index": 108, "complexity": "2"}
{"forwhile": "class BinarySearch { int binarySearch(int arr[], int x) { int l = 0, r = arr.length - 1; for(; l <= r; l <= r) { int m = l + (r - l) / 2; if(arr[m] == x) return m; if(arr[m] < x) l = m + 1; else r = m - 1; } return -1; } public static void main(String args[]) { BinarySearch ob = new BinarySearch(); int arr[] = { 2, 3, 4, 10, 40 }; int n = arr.length; int x = 10; int result = ob.binarySearch(arr, x); if(result == -1) System.out.println(", "src": "class\nBinarySearch { \n\n\n\n\n\nint\nbinarySearch(\nint\narr[], \nint\nx) \n\n{ \n\nint\nl = \n0\n, r = arr.length - \n1\n; \n\nwhile\n(l <= r) { \n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nif\n(arr[m] == x) \n\nreturn\nm; \n\n\n\n\nif\n(arr[m] < x) \n\nl = m + \n1\n; \n\n\n\n\nelse\n\nr = m - \n1\n; \n\n} \n\n\n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinarySearch ob = \nnew\nBinarySearch(); \n\nint\narr[] = { \n2\n, \n3\n, \n4\n, \n10\n, \n40\n}; \n\nint\nn = arr.length; \n\nint\nx = \n10\n; \n\nint\nresult = ob.binarySearch(arr, x); \n\nif\n(result == -\n1\n) \n\nSystem.out.println(\n\"Element not present\"\n); \n\nelse\n\nSystem.out.println(\n\"Element found at \"\n\n+ \n\"index \"\n+ result); \n\n} \n}", "index": 112, "complexity": "2"}
{"forwhile": "class Binary { public static int f(int x) { return (x*x - 10*x - 20); } public static int findFirstPositive() { if (f(0) > 0) return 0; int i = 1; for(; f(i) <= 0;) { i = i * 2; } return binarySearch(i / 2, i); } public static int binarySearch(int low, int high) { for(; high >= low;) { int mid = low + (high - low)/2; if (f(mid) > 0 && (mid == low || f(mid-1) <= 0)) return mid; if (f(mid) <= 0) return binarySearch((mid + 1), high); else return binarySearch(low, (mid - 1)); } return -1; } public static void main(String[] args) { System.out.print (\"The value n where f() \"+ \"becomes positive first is \"+ findFirstPositive()); } }", "src": "class\nBinary \n{ \n\npublic\nstatic\nint\nf(\nint\nx) \n\n{ \nreturn\n(x*x - \n10\n*x - \n20\n); } \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nfindFirstPositive() \n\n{ \n\n\n\nif\n(f(\n0\n) > \n0\n) \n\nreturn\n0\n; \n\n\n\n\n\n\nint\ni = \n1\n; \n\nwhile\n(f(i) <= \n0\n) \n\ni = i * \n2\n; \n\n\n\n\nreturn\nbinarySearch(i / \n2\n, i); \n\n} \n\n\n\n\n\n\npublic\nstatic\nint\nbinarySearch(\nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) \n\n{ \n\n\n\nint\nmid = low + (high - low)/\n2\n; \n\n\n\n\n\n\n\n\n\n\n\n\nif\n(f(mid) > \n0\n&& (mid == low || f(mid-\n1\n) <= \n0\n)) \n\nreturn\nmid; \n\n\n\n\nif\n(f(mid) <= \n0\n) \n\nreturn\nbinarySearch((mid + \n1\n), high); \n\nelse\n\n\nreturn\nbinarySearch(low, (mid -\n1\n)); \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print (\n\"The value n where f() \"\n+ \n\n\"becomes positive first is \"\n+ \n\nfindFirstPositive()); \n\n} \n}", "index": 113, "complexity": "2"}
{"forwhile": "class GfG { static int getMedian(int ar1[], int ar2[], int n) { if (n <= 0) return -1; if (n == 1) return (ar1[0] + ar2[0]) / 2; if (n == 2) return (Math.max(ar1[0], ar2[0]) + Math.min(ar1[1], ar2[1])) / 2; int m1 = median(ar1, n); int m2 = median(ar2, n); if (m1 == m2) return m1; if (m1 < m2) { if (n % 2 == 0) return getMedian(ar1, ar2, n - 1); return getMedian(ar1, ar2, n); } if (n % 2 == 0) return getMedian(ar2, ar1, n - 1); return getMedian(ar2, ar1, n); } static int median(int arr[], int n) { if (n % 2 == 0) return (arr[n / 2] + arr[n / 2 - 1]) / 2; else return arr[n / 2]; } public static void main(String[] args) { int ar1[] = {1, 2, 3, 6}; int ar2[] = {4, 6, 8, 10}; int n1 = ar1.length; int n2 = ar2.length; if (n1 == n2) System.out.println(\"Median is \" + getMedian(ar1, ar2, n1)); else System.out.println(\"Doesn't work for arrays of unequal size\"); }}", "src": "class\nGfG { \n\n\nstatic\nint\ngetMedian(\nint\nar1[], \nint\nar2[], \nint\nn) \n{ \n\n\n\nif\n(n <= \n0\n) \n\nreturn\n-\n1\n; \n\nif\n(n == \n1\n) \n\nreturn\n(ar1[\n0\n] + ar2[\n0\n]) / \n2\n; \n\nif\n(n == \n2\n) \n\nreturn\n(Math.max(ar1[\n0\n], ar2[\n0\n]) + Math.min(ar1[\n1\n], ar2[\n1\n])) / \n2\n; \n\n\n\n\nint\nm1 = median(ar1, n); \n\n\n\n\nint\nm2 = median(ar2, n); \n\n\n\n\nif\n(m1 == m2) \n\nreturn\nm1; \n\n\n\n\nif\n(m1 < m2) \n\n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar1 + n / \n2\n- \n1\n, ar2, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar1 + n / \n2\n, ar2, n - n / \n2\n); \n\n} \n\n\n\n\nif\n(n % \n2\n== \n0\n) \n\nreturn\ngetMedian(ar2 + n / \n2\n- \n1\n, ar1, n - n / \n2\n+ \n1\n); \n\nreturn\ngetMedian(ar2 + n / \n2\n, ar1, n - n / \n2\n); \n} \n\n\nstatic\nint\nmedian(\nint\narr[], \nint\nn) \n{ \n\nif\n(n % \n2\n== \n0\n) \n\nreturn\n(arr[n / \n2\n] + arr[n / \n2\n- \n1\n]) / \n2\n; \n\nelse\n\nreturn\narr[n / \n2\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nar1[] = {\n1\n, \n2\n, \n3\n, \n6\n}; \n\nint\nar2[] = {\n4\n, \n6\n, \n8\n, \n10\n}; \n\nint\nn1 = ar1.length; \n\nint\nn2 = ar2.length; \n\nif\n(n1 == n2) \n\nSystem.out.println(\n\"Median is \"\n+ getMedian(ar1, ar2, n1)); \n\nelse\n\nSystem.out.println(\n\"Doesn't work for arrays \"\n+ \n\"of unequal size\"\n); \n} \n}", "index": 115, "complexity": "2"}
{"forwhile": "class GFG { static int binarySearch(int arr[], int l, int r, int x) { if(r < l) return -1; int mid = l + (r - l) / 2; if(arr[mid] == x) return mid; if(arr[mid] > x) return binarySearch(arr, l, mid - 1, x); return binarySearch(arr, mid + 1, r, x); } static int countOccurrences(int arr[], int n, int x) { int ind = binarySearch(arr, 0, n - 1, x); if(ind == -1) return 0; int count = 1; int left = ind - 1; for(; left >= 0 && arr[left] == x; count++, left--); int right = ind + 1; for(; right < n && arr[right] == x; count++, right++); return count; } public static void main(String[] args) { int arr[] = { 1, 2, 2, 2, 2, 3, 4, 7, 8, 8 }; int n = arr.length; int x = 2; System.out.print(countOccurrences(arr, n, x)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\nstatic\nint\nbinarySearch(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n\n{ \n\nif\n(r < l) \n\nreturn\n-\n1\n; \n\n\nint\nmid = l + (r - l) / \n2\n; \n\n\n\n\n\n\nif\n(arr[mid] == x) \n\nreturn\nmid; \n\n\n\n\n\n\n\n\nif\n(arr[mid] > x) \n\nreturn\nbinarySearch(arr, l, \n\nmid - \n1\n, x); \n\n\n\n\n\n\n\n\nreturn\nbinarySearch(arr, mid + \n1\n, r, x); \n\n} \n\n\n\n\n\n\nstatic\nint\ncountOccurrences(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\nint\nind = binarySearch(arr, \n0\n, \n\nn - \n1\n, x); \n\n\n\n\nif\n(ind == -\n1\n) \n\nreturn\n0\n; \n\n\n\n\nint\ncount = \n1\n; \n\nint\nleft = ind - \n1\n; \n\nwhile\n(left >= \n0\n&& \n\narr[left] == x) \n\n{ \n\ncount++; \n\nleft--; \n\n} \n\n\n\n\n\n\nint\nright = ind + \n1\n; \n\nwhile\n(right < n && \n\narr[right] == x) \n\n{ \n\ncount++; \n\nright++; \n\n} \n\n\nreturn\ncount; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n\n3\n, \n4\n, \n7\n, \n8\n, \n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.print(countOccurrences(arr, n, x)); \n\n} \n}", "index": 117, "complexity": "2"}
{"forwhile": "public class A1180 {\n\n    public static void main(String[] args) throws FileNotFoundException \n    { \n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint layers = n-1;\n\t\tint counter =0;\n\t\tint i = 1;\n\t\twhile( i < layers + 1 ) {\n\t\t\tcounter += i ;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tSystem.out.println(1 + counter*4);\n    } \n}", "src": "public class A1180 {\n\n    public static void main(String[] args) throws FileNotFoundException \n    { \n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint layers = n-1;\n\t\tint counter =0;\n\t\tfor(int i =1 ;i < layers + 1 ; i ++) {\n\t\t\tcounter += i ;\n\t\t}\n\t\t\n\t\tSystem.out.println(1 + counter*4);\n    } \n}", "index": 126, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class round569d2b {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tif (n % 2 == 0) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint max = Integer.MIN_VALUE;\n\t\t\tint maxIndex = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint elem = arr[i];\n\t\t\t\tif (elem < 0) {\n\t\t\t\t\telem = -1*elem-1;\n\t\t\t\t}\n\t\t\t\tif (elem > max) {\n\t\t\t\t\tmax = elem;\n\t\t\t\t\tmaxIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i == maxIndex) {\n\t\t\t\t\tif (arr[i] < 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (arr[i] >= 0) {\n\t\t\t\t\t\tarr[i] = -1*arr[i]-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < n ;i++) {\n\t\t\tsb.append(arr[i] + \" \");\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 127, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint n = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tif(n % 2 == 0) {\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint maxi = -1, max = -1;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tint x = a[i] >= 0 ? -a[i] - 1 : a[i];\n\t\t\t\tx = -x;\n\t\t\t\tif(x > max) {\n\t\t\t\t\tmax = x; maxi = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max == 1) {\n\t\t\t\ta[0] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\t\tif(i == maxi) {\n\t\t\t\t\t\tif(a[i] < 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(a[i] >= 0)\n\t\t\t\t\t\t\ta[i] = -a[i] - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int x : a)\n\t\t\tSystem.out.print(x + \" \");\n\t\t\n\t\tout.close();\n\t}\n\t\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "index": 128, "complexity": "1"}
{"forwhile": "public class MyClass {\n    public static void main(String args[]) {\n        Scanner sc= new Scanner(System.in);\n        int n=sc.nextInt();\n        int [] a= new int[n];\n        int k=0;\n        int m=0;\n        int i=0;\n        while(i<n){\n            a[i]=sc.nextInt();\n            if (a[i]>=0){\n                a[i]=-a[i]-1;\n            }\n            if (a[i]<m){\n                m=a[i];\n                k=i;\n            }\n            i++;\n        }\n        if (n%2==1){\n            a[k]=-a[k]-1;\n        }\n        i=0;\n        while(i<n){\n            System.out.print(a[i]+\" \");\n            i++;\n        }\n    }\n}", "src": "public class MyClass {\n    public static void main(String args[]) {\n        Scanner sc= new Scanner(System.in);\n        int n=sc.nextInt();\n        int [] a= new int[n];\n        int k=0;\n        int m=0;\n        for (int i=0;i<n;i++){\n            a[i]=sc.nextInt();\n            if (a[i]>=0){\n                a[i]=-a[i]-1;\n            }\n            if (a[i]<m){\n                m=a[i];\n                k=i;\n            }\n        }\n        if (n%2==1){\n            a[k]=-a[k]-1;\n        }\n        for (int i=0;i<n;i++){\n            System.out.print(a[i]+\" \");\n        }\n    }\n}", "index": 129, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class round569d2c {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tArrayDeque<Integer> deq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdeq.addLast(in.nextInt());\n\t\t}\n\t\tlong[] queries = new long[q];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tqueries[i] = in.nextLong();\n\t\t}\n\t\tint[] origAs = new int[n-1];\n\t\tint[] origBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\torigAs[i] = a;\n\t\t\torigBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tint[] repeatAs = new int[n-1];\n\t\tint[] repeatBs = new int[n-1];\n\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\tint a = deq.pollFirst();\n\t\t\tint b = deq.pollFirst();\n\t\t\trepeatAs[i] = a;\n\t\t\trepeatBs[i] = b;\n\t\t\tif (a > b) {\n\t\t\t\tdeq.addFirst(a);\n\t\t\t\tdeq.addLast(b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdeq.addFirst(b);\n\t\t\t\tdeq.addLast(a);\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tlong query = queries[i] - 1;\n\t\t\tif (query < n-1) {\n\t\t\t\tsb.append(origAs[(int)query] + \" \" + origBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquery %= (n-1);\n\t\t\t\tsb.append(repeatAs[(int)query] + \" \" + repeatBs[(int)query] + \"\\n\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 130, "complexity": "1"}
{"forwhile": "public class Kello\n{\npublic static void  main(String args[])\n{\nScanner sc =new Scanner(System.in);\nint n,q,m,max,inp,k,i;\nlong in_q;\nn=sc.nextInt();\nq=sc.nextInt();\nint a[]=new int[n-1];\nint b[]=new int[n-1];\nint c[]=new int[n-1];\nmax=sc.nextInt();\ni=0;\nwhile(i<n-1)\n{\ninp=sc.nextInt();\na[i]=max;\nb[i]=inp;\nif(inp>max)\n{\nc[i]=max;\nmax=inp;\n}\nelse\n{\nc[i]=inp;\n}\ni++;\n}\ni=0;\nfor(;i<q;i++)\n{\nin_q=sc.nextLong();\nif(in_q<n)\n{\nSystem.out.println(a[(int)in_q-1]+\" \"+b[(int)in_q-1]);\n}\nelse\n{\nk=(int)(in_q %(n-1))-1;\nif(k==-1)\n{\nk=n-2;\n}\nSystem.out.println(max+\" \"+c[k]);\n}\n}\n}\npublic static void display(int a[],int b[])\n{\nint i=0;\nfor(;i<a.length;i++)\n{\nSystem.out.println(a[i]+\" \"+b[i]);\n}\n}\n}", "src": "public class Kello\n{\n    public static void  main(String args[])\n    {\n        Scanner sc =new Scanner(System.in);\n        int n,q,m,max,inp,k,i;\n        long in_q;\n        n=sc.nextInt();\n        q=sc.nextInt();\n        int a[]=new int[n-1];\n        int b[]=new int[n-1];\n        int c[]=new int[n-1];\n        max=sc.nextInt();\n        for(i=0;i<n-1;i++)\n        {\n            inp=sc.nextInt();\n            a[i]=max;\n            b[i]=inp;\n            if(inp>max)\n            {\n                c[i]=max;\n             max=inp;\n        }\n        else\n        c[i]=inp;\n    }\n   \n        for(i=0;i<q;i++)\n        {\n            in_q=sc.nextLong();\n            if(in_q<n)\n            System.out.println(a[(int)in_q-1]+\" \"+b[(int)in_q-1]);\n          else   {\n          k=(int)(in_q %(n-1))-1;\n          if(k==-1)\n          k=n-2;\n          System.out.println(max+\" \"+c[k]);\n            }\n        }\n    }\n    public static void display(int a[],int b[])\n    {\n        int i;\n        for(i=0;i<a.length;i++)\n        System.out.println(a[i]+\" \"+b[i]);\n}\n}", "index": 131, "complexity": "1"}
{"forwhile": "class Main { static void printUnsorted( int arr[], int n) { int s = 0, e = n-1, i, max, min; s = 0; while(s < n-1) { if(arr[s] > arr[s+1]) break; s++; } if(s == n-1) { System.out.println('The complete array is sorted'); return; } e = n - 1; while(e > 0) { if(arr[e] < arr[e-1]) break; e--; } max = arr[s]; min = arr[s]; i = s + 1; while(i <= e) { if(arr[i] > max) max = arr[i]; if(arr[i] < min) min = arr[i]; i++; } i = 0; while(i < s) { if(arr[i] > min) { s = i; break; } i++; } i = n - 1; while(i >= e+1) { if(arr[i] < max) { e = i; break; } i--; } System.out.println(' The unsorted subarray which' + ' makes the given array sorted lies' + ' between the indices ' + s + ' and ' + e); return; } public static void main(String args[]) { int arr[] = { 10, 12, 20, 30, 25, 40, 32, 31, 35, 50, 60 }; int arr_size = arr.length; printUnsorted(arr, arr_size); } }", "src": "class\nMain \n{ \n\nstatic\nvoid\nprintUnsorted(\nint\narr[], \nint\nn) \n\n{ \n\nint\ns = \n0\n, e = n-\n1\n, i, max, min; \n\n\n\n\nfor\n(s = \n0\n; s < n-\n1\n; s++) \n\n{ \n\nif\n(arr[s] > arr[s+\n1\n]) \n\nbreak\n; \n\n} \n\nif\n(s == n-\n1\n) \n\n{ \n\nSystem.out.println(\n\"The complete array is sorted\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nfor\n(e = n - \n1\n; e > \n0\n; e--) \n\n{ \n\nif\n(arr[e] < arr[e-\n1\n]) \n\nbreak\n; \n\n} \n\n\n\n\nmax = arr[s]; min = arr[s]; \n\nfor\n(i = s + \n1\n; i <= e; i++) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\nif\n(arr[i] < min) \n\nmin = arr[i]; \n\n} \n\n\n\n\nfor\n( i = \n0\n; i < s; i++) \n\n{ \n\nif\n(arr[i] > min) \n\n{ \n\ns = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nfor\n( i = n -\n1\n; i >= e+\n1\n; i--) \n\n{ \n\nif\n(arr[i] < max) \n\n{ \n\ne = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nSystem.out.println(\n\" The unsorted subarray which\"\n+ \n\n\" makes the given array sorted lies\"\n+ \n\n\" between the indices \"\n+s+\n\" and \"\n+e); \n\nreturn\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n10\n, \n12\n, \n20\n, \n30\n, \n25\n, \n40\n, \n32\n, \n31\n, \n35\n, \n50\n, \n60\n}; \n\nint\narr_size = arr.length; \n\nprintUnsorted(arr, arr_size); \n\n} \n}", "index": 132, "complexity": "1"}
{"forwhile": "public class C {\n    static class FastWriter {\n        private final BufferedWriter bw;\n\n        public FastWriter() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        public void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            for (; st == null || !st.hasMoreElements(); ) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        BigInteger nextBigInteger() {\n            try {\n                return new BigInteger(nextLine());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int q = fr.nextInt();\n        int[] aa = new int[n - 1];\n        int[] ab = new int[n - 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        int i = 0;\n        while(i < n) {\n            dq.addLast(fr.nextInt());\n            i++;\n        }\n        i = 0;\n        while(i < n - 1) {\n            int a = dq.removeFirst();\n            int b = dq.removeFirst();\n            aa[i] = a;\n            ab[i] = b;\n            int mi = Math.min(a, b);\n            int ma = Math.max(a, b);\n            dq.addFirst(ma);\n            dq.addLast(mi);\n            i++;\n        }\n        int fm = dq.removeFirst();\n        int[] arr = new int[n - 1];\n        i = 0;\n        while(i < arr.length) {\n            arr[i] = dq.removeFirst();\n            i++;\n        }\n        for (; q-- > 0; ) {\n            long m = fr.nextLong() - 1;\n            if (m < n - 1) {\n                fw.println(aa[(int) m] + \" \" + ab[(int) m]);\n            } else {\n                m = m % (n - 1);\n                fw.println(fm + \" \" + arr[(int) m]);\n            }\n        }\n        fw.close();\n    }\n}", "src": "public class C {\n    static class FastWriter {\n        private final BufferedWriter bw;\n\n        public FastWriter() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        }\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n        public void close() throws IOException {\n            bw.close();\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        BigInteger nextBigInteger() {\n            try {\n                return new BigInteger(nextLine());\n            } catch (NumberFormatException e) {\n                throw new InputMismatchException();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader fr = new FastReader();\n        FastWriter fw = new FastWriter();\n        int n = fr.nextInt();\n        int q = fr.nextInt();\n        int[] aa = new int[n - 1];\n        int[] ab = new int[n - 1];\n        Deque<Integer> dq = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) dq.addLast(fr.nextInt());\n        for (int i = 0; i < n - 1; i++) {\n            int a = dq.removeFirst();\n            int b = dq.removeFirst();\n            aa[i] = a;\n            ab[i] = b;\n            int mi = Math.min(a, b);\n            int ma = Math.max(a, b);\n            dq.addFirst(ma);\n            dq.addLast(mi);\n        }\n        int fm = dq.removeFirst();\n        int[] arr = new int[n - 1];\n        for (int i = 0; i < arr.length; i++) arr[i] = dq.removeFirst();\n        while (q-- > 0) {\n            long m = fr.nextLong() - 1;\n            if (m < n - 1) {\n                System.out.println(aa[(int) m] + \" \" + ab[(int) m]);\n            } else {\n                m = m % (n - 1);\n                System.out.println(fm + \" \" + arr[(int) m]);\n            }\n        }\n    }\n}", "index": 133, "complexity": "1"}
{"forwhile": "public class Main {\n \n    public static void main(String[] args) {\n\t\n        Scanner scan = new Scanner(System.in);\n        int T = scan.nextInt();\n        while(T > 0) {\n            int n = scan.nextInt();\n            int[] arr = new int[n];\n            int i = 0;\n            while(i < n) { arr[i] = scan.nextInt(); i++; }\n            int m1 = 1, m2 = 1;\n            i = 0;\n            while(i < n) {\n                if(arr[i] >= m1) {\n                    m2 = m1;\n                    m1 = arr[i];\n                } else if (arr[i] >= m2) {\n                    m2 = arr[i];\n                }\n                i++;\n            }\n            System.out.println(Math.min(Math.min(m1, m2) - 1, n - 2));\n            T--;\n        }\n    }\n}", "src": "public class Main {\n \n    public static void main(String[] args) {\n\t\n        Scanner scan = new Scanner(System.in);\n        int T = scan.nextInt();\n        for(; T > 0; T--) {\n            int n = scan.nextInt();\n            int[] arr = new int[n];\n            for(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n            int m1 = 1, m2 = 1;\n            for(int i = 0; i < n; i++) {\n                if(arr[i] >= m1) {\n                    m2 = m1;\n                    m1 = arr[i];\n                } else if (arr[i] >= m2) {\n                    m2 = arr[i];\n                }\n            }\n            System.out.println(Math.min(Math.min(m1, m2) - 1, n - 2));\n        }\n    }\n}", "index": 134, "complexity": "1"}
{"forwhile": "public class CF111111 { BufferedReader in; StringTokenizer as; int nums[],nums2[]; int[] nums1[]; boolean con = true; ArrayList<Integer> ar = new ArrayList<Integer>(); ArrayList<Integer> fi = new ArrayList<Integer>(); Map<Integer,Integer> map = new HashMap<Integer, Integer>(); public static void main (String[] args) { new CF111111(); } public int GCD(int a, int b) { if (b == 0) return a; return GCD(b,a%b); } public int LIS(int arr[]) { int n = arr.length; int sun[] = new int[n]; int cur = 0; int x = 0; while (x < n) { int temp = Arrays.binarySearch(sun,0,cur,arr[x]); if (temp < 0) temp = -temp - 1; sun[temp] = arr[x]; if (temp == cur) cur++; x++; } return cur; } public void no() { System.out.println(\"NO\"); System.exit(0); } public CF111111() { try { in = new BufferedReader(new InputStreamReader(System.in)); int a = nextInt(); nums = new int[a]; int max = -1; int index = -1; int x = 0; while (x < a) { nums[x] = nextInt(); if (nums[x] > max) { max = nums[x]; index = x; } x++; } int lindex = index - 1; int rindex = index + 1; int done = 1; int top = max; for( ; ; ) { done++; if (lindex < 0) { if (nums[rindex] > top) { no(); } else top = nums[rindex]; rindex++; } else if (rindex >= a) { if (nums[lindex] > top) no(); else top = nums[lindex]; lindex--; } else { if (nums[lindex] > top || nums[rindex] > top) no(); else { if (nums[lindex] > nums[rindex]) { top = nums[lindex]; lindex--; } else { top = nums[rindex]; rindex++; } } } if (done == a) { System.out.println(\"YES\"); System.exit(0); } } } catch(IOException e) { } } String next() throws IOException { while (as == null || !as.hasMoreTokens()) { as = new StringTokenizer(in.readLine().trim()); } return as.nextToken(); } long nextLong() throws IOException { return Long.parseLong(next()); } int nextInt() throws IOException { return Integer.parseInt(next()); } double nextDouble() throws IOException { return Double.parseDouble(next()); } String nextLine() throws IOException { return in.readLine().trim(); } }", "src": "public class   CF111111\n{\n  BufferedReader in;\n  StringTokenizer as;\n  int nums[],nums2[];\n  int[] nums1[];\n  boolean con = true;\n \n  ArrayList < Integer >  ar = new ArrayList < Integer >();\n  ArrayList < Integer >  fi = new ArrayList < Integer >();\n  Map<Integer,Integer > map = new HashMap<Integer, Integer>();\n  public static void main (String[] args)\n  {\n    new CF111111  ();\n  }\n  \n  public int GCD(int a, int b) {\n    if (b==0) return a;\n    return GCD(b,a%b);\n  }\n  \n  public int LIS(int arr[])\n  {\n    int n = arr.length;\n    int sun[] = new int [n];\n    int cur = 0;\n    for(int x = 0;x<n;x++)\n    {\n      int temp = Arrays.binarySearch(sun,0,cur,arr[x]);\n      if(temp < 0)\n        temp = -temp -1;\n      sun[temp] = arr[x];\n      if(temp == cur)\n        cur++;\n    }\n    return cur;\n    \n  }\n  \n  \n  public void no()\n  {\n    System.out.println(\"NO\");\n    System.exit(0);\n  }\n  \n  public CF111111  ()\n  {\n    try\n    {\n      \n      in = new BufferedReader (new InputStreamReader (System.in));\n      int a = nextInt();\n      nums = new int [a];\n      int max = -1;\n      int index = -1;\n     for(int x = 0;x<a;x++)\n     {\n       nums[x] = nextInt();\n       if(nums[x] > max)\n       {\n         max = nums[x];\n         index = x;\n       }\n     }\n      int lindex = index-1;\n      int rindex = index+1;\n      int done = 1;\n      int top = max;\n      for(;;)\n      {\n        done++;\n      \n        if(lindex < 0)\n        {\n           if(nums[rindex] > top)\n           {\n             no();\n           }\n           else\n             top = nums[rindex];\n           rindex++;\n        }\n        else if(rindex >= a)\n        {\n          if(nums[lindex] > top)\n            no();\n          else\n            top = nums[lindex];\n          lindex--;\n        }\n        else\n        {\n          if(nums[lindex] > top || nums[rindex] > top)\n            no();\n          else\n          {\n            if(nums[lindex] > nums[rindex])\n            {\n              top = nums[lindex];\n              lindex--;\n            }\n            else\n            {\n              top = nums[rindex];\n              rindex++;\n            }\n          }\n        }\n        if(done == a)\n        {\n          System.out.println(\"YES\");\n          System.exit(0);\n        }\n      }\n    }\n    catch(IOException e)\n    {\n\n    }\n  }\n  \n  \n  \n  \n  \n  \n  \n  String next () throws IOException\n  {\n    while (as == null || !as.hasMoreTokens ())\n    {\n      as = new StringTokenizer (in.readLine ().trim ());\n    }\n    \n    \n    return as.nextToken ();\n  }\n  \n  \n  \n  long nextLong () throws IOException\n  {\n    return Long.parseLong (next ());\n  }\n  \n  \n  int nextInt () throws IOException\n  {\n    return Integer.parseInt (next ());\n  }\n  \n  \n  double nextDouble () throws IOException\n  {\n    return Double.parseDouble (next ());\n  }\n  \n  \n  String nextLine () throws IOException\n  {\n    return in.readLine ().trim ();\n  }\n}", "index": 135, "complexity": "1"}
{"forwhile": "public class codef\n{\n    public static void main(String ar[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        String st[]=br.readLine().split(\" \");\n        int a[]=new int[n];\n        int i=0;\n        while(i<n)\n        {\n            a[i]=Integer.parseInt(st[i]);\n            i++;\n        }\n\n        int max=0;\n        int i=0;\n        for(; i<n; i++)\n        {\n            if(i!=0 && a[i]>a[max])\n                max=i;\n        }\n       \n        int maxi=max;\n        for(int i=max-1; i>=0; i--)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n        }\n        max=maxi;\n        for(int i=max+1; i<n; i++)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n        }\n        System.out.println(\"YES\");\n    }\n}", "src": "public class codef\n{\n    public static void main(String ar[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        String st[]=br.readLine().split(\" \");\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n            a[i]=Integer.parseInt(st[i]);\n\n        int max=0;\n        for(int i=0;i<n;i++)\n        {\n            if(i!=0 && a[i]>a[max])\n                max=i;\n        }\n       \n        int maxi=max;\n        int i=max-1;\n        while(i>=0)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i--;\n        }\n        max=maxi;\n        i=max+1;\n        while(i<n)\n        {\n            if(a[i]>a[max])\n            {\n                System.out.println(\"NO\");\n                return;\n            }\n            max=i;\n            i++;\n        }\n        System.out.println(\"YES\");\n    }\n}", "index": 136, "complexity": "1"}
{"forwhile": "class PairSum { static void constructArr(int arr[], int pair[], int n) { arr[0] = (pair[0]+pair[1]-pair[n-1]) / 2; int i=1; while(i<n) { arr[i] = pair[i-1]-arr[0]; i++; } } public static void main(String[] args) { int pair[] = {15, 13, 11, 10, 12, 10, 9, 8, 7, 5}; int n = 5; int[] arr = new int[n]; constructArr(arr, pair, n); int i = 0; while(i < n) { System.out.print(arr[i]+\" \"); i++; } } }", "src": "class\nPairSum { \n\n\n\n\n\n\nstatic\nvoid\nconstructArr(\nint\narr[], \nint\npair[], \nint\nn) \n\n{ \n\narr[\n0\n] = (pair[\n0\n]+pair[\n1\n]-pair[n-\n1\n]) / \n2\n; \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\narr[i] = pair[i-\n1\n]-arr[\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\npair[] = {\n15\n, \n13\n, \n11\n, \n10\n, \n12\n, \n10\n, \n9\n, \n8\n, \n7\n, \n5\n}; \n\nint\nn = \n5\n; \n\nint\n[] arr = \nnew\nint\n[n]; \n\nconstructArr(arr, pair, n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 137, "complexity": "1"}
{"forwhile": "class GfG { public static int minMaxProduct(int arr1[], int arr2[], int n1, int n2) { int max = arr1[0]; int min = arr2[0]; int i = 1; while(i < n1 && i < n2) { if(arr1[i] > max) max = arr1[i]; if(arr2[i] < min) min = arr2[i]; i++; } for(; i < n1; i++) { if(arr1[i] > max) max = arr1[i]; } for(; i < n2; i++) { if(arr2[i] < min) min = arr2[i]; } return max * min; } public static void main(String argc[]) { int[] arr1= new int[]{ 10, 2, 3, 6, 4, 1}; int[] arr2 = new int[]{ 5, 1, 4, 2, 6, 9}; int n1 = 6; int n2 = 6; System.out.println(minMaxProduct(arr1, arr2, n1, n2)); } }", "src": "class\nGfG \n{ \n\n\n\n\npublic\nstatic\nint\nminMaxProduct(\nint\narr1[], \n\nint\narr2[], \n\nint\nn1, \n\nint\nn2) \n\n{ \n\n\n\n\n\n\nint\nmax = arr1[\n0\n]; \n\n\n\n\n\n\nint\nmin = arr2[\n0\n]; \n\n\nint\ni; \n\nfor\n(i = \n1\n; i < n1 && i < n2; ++i) \n\n{ \n\n\n\n\n\n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\n\n\n\n\n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\n} \n\n\n\n\nwhile\n(i < n1) \n\n{ \n\nif\n(arr1[i] > max) \n\nmax = arr1[i]; \n\ni++; \n\n} \n\nwhile\n(i < n2) \n\n{ \n\nif\n(arr2[i] < min) \n\nmin = arr2[i]; \n\ni++; \n\n} \n\n\nreturn\nmax * min; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]) \n\n{ \n\nint\n[] arr1= \nnew\nint\n[]{ \n10\n, \n2\n, \n3\n, \n\n6\n, \n4\n, \n1\n}; \n\nint\n[] arr2 = \nnew\nint\n[]{ \n5\n, \n1\n, \n4\n, \n\n2\n, \n6\n, \n9\n}; \n\nint\nn1 = \n6\n; \n\nint\nn2 = \n6\n; \n\nSystem.out.println(minMaxProduct(arr1, arr2, \n\nn1, n2)); \n\n} \n}", "index": 138, "complexity": "1"}
{"forwhile": "class GFG { static int MAX_CHAR = 26; public static void commonCharacters(String str[], int n) { Boolean[] prim = new Boolean[MAX_CHAR]; Arrays.fill(prim, new Boolean(true)); int i = 0; while (i < n) { Boolean[] sec = new Boolean[MAX_CHAR]; Arrays.fill(sec, new Boolean(false)); int j = 0; while (j < str[i].length()) { if (prim[str[i].charAt(j) - 'a']) sec[str[i].charAt(j) - 'a'] = true; j++; } System.arraycopy(sec, 0, prim, 0, MAX_CHAR); i++; } int k = 0; for (; k < 26; k++) { if (prim[k]) { System.out.print(Character.toChars(k + 97)); System.out.print(\" \"); } } } public static void main(String[] args) { String str[] = { \"geeksforgeeks\", \"gemkstones\", \"acknowledges\", \"aguelikes\" }; int n = str.length; commonCharacters(str, n); } }", "src": "class\nGFG { \n\n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\npublic\nstatic\nvoid\ncommonCharacters(String str[], \n\nint\nn) \n\n{ \n\n\n\n\n\n\nBoolean[] prim = \nnew\nBoolean[MAX_CHAR]; \n\nArrays.fill(prim, \nnew\nBoolean(\ntrue\n)); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nBoolean[] sec = \nnew\nBoolean[MAX_CHAR]; \n\nArrays.fill(sec, \nnew\nBoolean(\nfalse\n)); \n\n\n\n\nfor\n(\nint\nj = \n0\n; j < str[i].length(); j++) \n\n{ \n\n\n\n\n\n\nif\n(prim[str[i].charAt(j) - \n'a'\n]) \n\nsec[str[i].charAt(j) - \n'a'\n] = \ntrue\n; \n\n} \n\n\n\n\nSystem.arraycopy(sec, \n0\n, prim, \n0\n, MAX_CHAR); \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < \n26\n; i++) \n\nif\n(prim[i]){ \n\nSystem.out.print(Character.toChars(i \n\n+ \n97\n)); \n\nSystem.out.print(\n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str[] = { \n\"geeksforgeeks\"\n, \n\n\"gemkstones\"\n, \n\n\"acknowledges\"\n, \n\n\"aguelikes\"\n}; \n\n\nint\nn = str.length; \n\ncommonCharacters(str, n); \n\n} \n}", "index": 139, "complexity": "1"}
{"forwhile": "class GFG { static int MAX_CHAR = 26; static void findAndPrintUncommonChars(String str1, String str2) { int present[] = new int[MAX_CHAR]; int i = 0; while(i < MAX_CHAR) { present[i] = 0; i++; } int l1 = str1.length(); int l2 = str2.length(); i = 0; while(i < l1) { present[str1.charAt(i) - 'a'] = 1; i++; } i = 0; while(i < l2) { if(present[str2.charAt(i) - 'a'] == 1 || present[str2.charAt(i) - 'a'] == -1) { present[str2.charAt(i) - 'a'] = -1; } else { present[str2.charAt(i) - 'a'] = 2; } i++; } i = 0; while(i < MAX_CHAR) { if(present[i] == 1 || present[i] == 2) { System.out.print((char) (i + 'a') + ", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nvoid\nfindAndPrintUncommonChars(String str1, \n\nString str2) \n\n{ \n\n\n\n\n\nint\npresent[] = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\npresent[i] = \n0\n; \n\n} \n\n\nint\nl1 = str1.length(); \n\nint\nl2 = str2.length(); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < l1; i++) \n\n{ \n\npresent[str1.charAt(i) - \n'a'\n] = \n1\n; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < l2; i++) \n\n{ \n\n\n\n\n\n\nif\n(present[str2.charAt(i) - \n'a'\n] == \n1\n\n|| present[str2.charAt(i) - \n'a'\n] == -\n1\n) \n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = -\n1\n; \n\n} \n\n\n\n\nelse\n\n{ \n\npresent[str2.charAt(i) - \n'a'\n] = \n2\n; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\n{ \n\nif\n(present[i] == \n1\n|| present[i] == \n2\n) \n\n{ \n\nSystem.out.print((\nchar\n) (i + \n'a'\n) + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str1 = \n\"characters\"\n; \n\nString str2 = \n\"alphabets\"\n; \n\nfindAndPrintUncommonChars(str1, str2); \n\n} \n}", "index": 140, "complexity": "1"}
{"forwhile": "class GFG { static boolean isVowel(char ch) { if(ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') return true; return false; } static String createAltStr(String str1, String str2, int start, int l) { String finalStr = \"\"; int i = 0, j = start; while(j < l) { finalStr = (finalStr + str1.charAt(i)) + str2.charAt(j); i++; j++; } return finalStr; } static String findAltStr(String str) { int nv = 0, nc = 0; String vstr = \"\", cstr = \"\"; int l = str.length(); int i = 0; while(i < l) { char ch = str.charAt(i); if(isVowel(ch)) { nv++; vstr = vstr + ch; } else { nc++; cstr = cstr + ch; } i++; } if(Math.abs(nv - nc) >= 2) return \"no such string\"; if(nv > nc) return (vstr.charAt(0) + createAltStr(cstr, vstr, 1, nv)); if(nc > nv) return (cstr.charAt(0) + createAltStr(vstr, cstr, 1, nc)); if(cstr.charAt(0) < vstr.charAt(0)) return createAltStr(cstr, vstr, 0, nv); return createAltStr(vstr, cstr, 0, nc); } public static void main(String args[]) { String str = \"geeks\"; System.out.println(findAltStr(str)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nboolean\nisVowel(\nchar\nch) \n{ \n\nif\n(ch == \n'a'\n|| ch == \n'e'\n|| ch == \n'i'\n|| \n\nch == \n'o'\n|| ch ==\n'u'\n) \n\nreturn\ntrue\n; \n\nreturn\nfalse\n; \n} \n\n\n\nstatic\nString createAltStr(String str1, String str2, \n\nint\nstart, \nint\nl) \n{ \n\nString finalStr = \n\"\"\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n, j = start; j < l; i++, j++) \n\nfinalStr = (finalStr + str1.charAt(i)) + \n\nstr2.charAt(j); \n\nreturn\nfinalStr; \n} \n\n\n\nstatic\nString findAltStr(String str) \n{ \n\nint\nnv = \n0\n, nc = \n0\n; \n\nString vstr = \n\"\"\n, cstr = \n\"\"\n; \n\nint\nl = str.length(); \n\nfor\n(\nint\ni = \n0\n; i < l; i++) \n\n{ \n\nchar\nch = str.charAt(i); \n\n\n\n\nif\n(isVowel(ch)) \n\n{ \n\nnv++; \n\nvstr = vstr + ch; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\nnc++; \n\ncstr = cstr + ch; \n\n} \n\n} \n\n\n\n\nif\n(Math.abs(nv - nc) >= \n2\n) \n\nreturn\n\"no such string\"\n; \n\n\n\n\n\n\n\n\nif\n(nv > nc) \n\nreturn\n(vstr.charAt(\n0\n) + createAltStr(cstr, vstr, \n1\n, nv)); \n\n\n\n\n\n\n\n\nif\n(nc > nv) \n\nreturn\n(cstr.charAt(\n0\n) + createAltStr(vstr, cstr, \n1\n, nc)); \n\n\n\n\n\n\n\n\nif\n(cstr.charAt(\n0\n) < vstr.charAt(\n0\n)) \n\nreturn\ncreateAltStr(cstr, vstr, \n0\n, nv); \n\n\n\n\nreturn\ncreateAltStr(vstr, cstr, \n0\n, nc); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nString str = \n\"geeks\"\n; \n\nSystem.out.println(findAltStr(str)); \n} \n}", "index": 141, "complexity": "1"}
{"forwhile": "class CountSubString { int countSubStr(char str[], int n) { int m = 0; int i = 0; while (i < n) { if (str[i] == '1') m++; i++; } return m * (m - 1) / 2; } public static void main(String[] args) { CountSubString count = new CountSubString(); String string = \"00100101\"; char str[] = string.toCharArray(); int n = str.length; System.out.println(count.countSubStr(str, n)); } }", "src": "class\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[], \nint\nn) \n\n{ \n\nint\nm = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\nm++; \n\n} \n\n\n\n\nreturn\nm * (m - \n1\n) / \n2\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str, n)); \n\n} \n}", "index": 142, "complexity": "1"}
{"forwhile": "public class GFG { static final int M = 26; static int getIdx(char ch) { return (ch - 'a'); } static boolean allSame(int freq[], int N) { int same = 0; int i = 0; while(i < N) { if(freq[i] > 0) { same = freq[i]; break; } i++; } int j = i + 1; while(j < N) if(freq[j] > 0 && freq[j] != same) return false; return true; } static boolean possibleSameCharFreqByOneRemoval(String str) { int l = str.length(); int[] freq = new int[M]; int i = 0; while(i < l) { freq[getIdx(str.charAt(i))]++; i++; } if(allSame(freq, M)) return true; char c = 'a'; while(c <= 'z') { int idx = getIdx(c); if(freq[idx] > 0) { freq[idx]--; if(allSame(freq, M)) return true; freq[idx]++; } c++; } return false; } public static void main(String args[]) { String str = \"xyyzz\"; if(possibleSameCharFreqByOneRemoval(str)) System.out.println(\"Yes\"); else System.out.println(\"No\"); } }", "src": "public\nclass\nGFG { \n\n\nstatic\nfinal\nint\nM = \n26\n; \n\n\n\n\n\n\nstatic\nint\ngetIdx(\nchar\nch) \n\n{ \n\nreturn\n(ch - \n'a'\n); \n\n} \n\n\n\n\n\n\nstatic\nboolean\nallSame(\nint\nfreq[], \nint\nN) \n\n{ \n\nint\nsame = \n0\n; \n\n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < N; i++) { \n\nif\n(freq[i] > \n0\n) { \n\nsame = freq[i]; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < N; j++) \n\nif\n(freq[j] > \n0\n&& freq[j] != same) \n\nreturn\nfalse\n; \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\n\n\nstatic\nboolean\npossibleSameCharFreqByOneRemoval(String str) \n\n{ \n\nint\nl = str.length(); \n\n\n\n\nint\n[] freq = \nnew\nint\n[M]; \n\n\nfor\n(\nint\ni = \n0\n; i < l; i++) \n\nfreq[getIdx(str.charAt(i))]++; \n\n\n\n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\n\n\n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\ni = getIdx(c); \n\n\n\n\nif\n(freq[i] > \n0\n) { \n\nfreq[i]--; \n\n\nif\n(allSame(freq, M)) \n\nreturn\ntrue\n; \n\nfreq[i]++; \n\n} \n\n} \n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"xyyzz\"\n; \n\nif\n(possibleSameCharFreqByOneRemoval(str)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 143, "complexity": "1"}
{"forwhile": "public\\nclass\\nGFG \\n{ \\n\\n\\n\\nstatic\\nvoid\\nprintMinIndexChar(String str, String patt) \\n\\n{ \\n\\n\\n\\nHashMap<Character, Integer> hm = \\nnew\\nHashMap<>(); \\n\\n\\n\\n\\n\\nint\\nminIndex = Integer.MAX_VALUE; \\n\\n\\n\\nint\\nm = str.length(); \\n\\nint\\nn = patt.length(); \\n\\n\\n\\n\\nint\\ni = 0; \\nwhile(i < m) \\n\\nif\\n(!hm.containsKey(str.charAt(i))) \\n\\nhm.put(str.charAt(i),i); \\n\\n\\n\\ni++; \\n\\n\\nint\\ni = 0; \\nwhile(i < n) \\n\\n\\n\\n\\n\\nif\\n(hm.containsKey(patt.charAt(i)) && \\n\\nhm.get(patt.charAt(i)) < minIndex) \\n\\nminIndex = hm.get(patt.charAt(i)); \\n\\n\\n\\nif\\n(minIndex != Integer.MAX_VALUE) \\n\\nSystem.out.println(\\n\"Minimum Index Character = \"\\n+ \\n\\nstr.charAt(minIndex)); \\n\\n\\n\\nelse\\n\\nSystem.out.println(\\n\"No character present\"\\n); \\n\\n} \\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nString str = \\n\"geeksforgeeks\"\\n; \\n\\nString patt = \\n\"set\"\\n; \\n\\nprintMinIndexChar(str, patt); \\n\\n} \\n}", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n\n\nHashMap<Character, Integer> hm = \nnew\nHashMap<>(); \n\n\n\n\n\n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n\n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(!hm.containsKey(str.charAt(i))) \n\nhm.put(str.charAt(i),i); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\n\n\n\nif\n(hm.containsKey(patt.charAt(i)) && \n\nhm.get(patt.charAt(i)) < minIndex) \n\nminIndex = hm.get(patt.charAt(i)); \n\n\n\n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n\n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n}", "index": 144, "complexity": "1"}
{"forwhile": "public\nclass\nGFG \n{ \n\nstatic\nfinal\nint\nNO_OF_CHARS = \n256\n; \n\n\n\n\nstatic\nint\n[] getCharCountArray(String str) \n\n{ \n\nint\ncount[] = \nnew\nint\n[NO_OF_CHARS]; \n\nint\ni = \n0\n; \nwhile(i<str.length()) \n\ncount[str.charAt(i++)]++; \n\n\nreturn\ncount; \n\n} \n\n\n\n\nstatic\nString removeDirtyChars(String str, String mask_str) \n\n{ \n\nint\ncount[] = getCharCountArray(mask_str); \n\nint\nip_ind = \n0\n, res_ind = \n0\n; \n\n\nchar\narr[] = str.toCharArray(); \n\n\nfor(; ip_ind != arr.length;) \n\n{ \n\nchar\ntemp = arr[ip_ind]; \n\nif\n(count[temp] == \n0\n) \n\n{ \n\narr[res_ind] = arr[ip_ind]; \n\nres_ind ++; \n\n} \n\nip_ind++; \n\n\n} \n\n\nstr = \nnew\nString(arr); \n\n\n\n\n\nreturn\nstr.substring(\n0\n, res_ind); \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString mask_str = \n\"mask\"\n; \n\nSystem.out.println(removeDirtyChars(str, mask_str)); \n\n} \n}", "src": "public\nclass\nGFG \n{ \n\nstatic\nfinal\nint\nNO_OF_CHARS = \n256\n; \n\n\n\n\nstatic\nint\n[] getCharCountArray(String str) \n\n{ \n\nint\ncount[] = \nnew\nint\n[NO_OF_CHARS]; \n\nfor\n(\nint\ni = \n0\n; i<str.length(); i++) \n\ncount[str.charAt(i)]++; \n\n\nreturn\ncount; \n\n} \n\n\n\n\nstatic\nString removeDirtyChars(String str, String mask_str) \n\n{ \n\nint\ncount[] = getCharCountArray(mask_str); \n\nint\nip_ind = \n0\n, res_ind = \n0\n; \n\n\nchar\narr[] = str.toCharArray(); \n\n\nwhile\n(ip_ind != arr.length) \n\n{ \n\nchar\ntemp = arr[ip_ind]; \n\nif\n(count[temp] == \n0\n) \n\n{ \n\narr[res_ind] = arr[ip_ind]; \n\nres_ind ++; \n\n} \n\nip_ind++; \n\n\n} \n\n\nstr = \nnew\nString(arr); \n\n\n\n\n\nreturn\nstr.substring(\n0\n, res_ind); \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString mask_str = \n\"mask\"\n; \n\nSystem.out.println(removeDirtyChars(str, mask_str)); \n\n} \n}", "index": 145, "complexity": "1"}
{"forwhile": "public\\nclass\\nGFG \\n{ \\n\\n\\n\\nstatic\\nclass\\nPair{ \\n\\nchar\\nfirst; \\n\\nint\\nsecond; \\n\\nPair(\\nchar\\nfirst, \\nint\\nsecond){ \\n\\nthis\\n.first = first; \\n\\nthis\\n.second = second; \\n\\n} \\n\\n} \\n\\n\\n\\n\\nstatic\\nint\\nlongestNull(String str) \\n\\n{ \\n\\nArrayList<Pair> arr = \\nnew\\nArrayList<>(); \\n\\n\\n\\n\\narr.add(\\nnew\\nPair(\\n'@'\\n, -\\n1\\n)); \\n\\n\\nint\\nmaxlen = \\n0\\n; \\n\\n\\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile(i < str.length()) \\n\\n{ \\n\\n\\n\\n\\narr.add(\\nnew\\nPair(str.charAt(i), i)); \\n\\n\\n\\n\\n\\n\\nint\\nloopCount = \\n0\\n; \\nfor( ; arr.size() >= \\n3\\n && \\n\\narr.get(arr.size()-\\n3\\n).first==\\n'1'\\n && \\n\\narr.get(arr.size()-\\n2\\n).first==\\n'0'\\n && \\n\\narr.get(arr.size()-\\n1\\n).first==\\n'0'\\n; loopCount++) \\n\\n{ \\n\\n\\n\\n\\narr.remove(arr.size() - \\n3\\n); \\n\\narr.remove(arr.size() - \\n2\\n); \\n\\narr.remove(arr.size() - \\n1\\n); \\n\\n} \\n\\n\\nint\\ntmp = arr.get(arr.size() - \\n1\\n).second; \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nmaxlen = Math.max(maxlen, i - tmp); \\n\\n\\n\\n\\n\\ni++; \\n} \\n\\n\\nreturn\\nmaxlen; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nSystem.out.println(longestNull(\\n\"1011100000100\"\\n)); \\n\\n} \\n}", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nclass\nPair{ \n\nchar\nfirst; \n\nint\nsecond; \n\nPair(\nchar\nfirst, \nint\nsecond){ \n\nthis\n.first = first; \n\nthis\n.second = second; \n\n} \n\n} \n\n\n\n\nstatic\nint\nlongestNull(String str) \n\n{ \n\nArrayList<Pair> arr = \nnew\nArrayList<>(); \n\n\n\n\n\n\narr.add(\nnew\nPair(\n'@'\n, -\n1\n)); \n\n\nint\nmaxlen = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < str.length(); ++i) \n\n{ \n\n\n\n\n\narr.add(\nnew\nPair(str.charAt(i), i)); \n\n\n\n\n\n\nwhile\n(arr.size() >= \n3\n&& \n\narr.get(arr.size()-\n3\n).first==\n'1'\n&& \n\narr.get(arr.size()-\n2\n).first==\n'0'\n&& \n\narr.get(arr.size()-\n1\n).first==\n'0'\n) \n\n{ \n\n\n\n\n\narr.remove(arr.size() - \n3\n); \n\narr.remove(arr.size() - \n2\n); \n\narr.remove(arr.size() - \n1\n); \n\n} \n\n\n\n\nint\ntmp = arr.get(arr.size() - \n1\n).second; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmaxlen = Math.max(maxlen, i - tmp); \n\n} \n\n\nreturn\nmaxlen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(longestNull(\n\"1011100000100\"\n)); \n\n} \n}", "index": 146, "complexity": "1"}
{"forwhile": "class Test { static final int MAX_CHAR = 26; static int countPairs(String str) { int result = 0; int n = str.length(); int i = 0; for(; i < n;) { int j = 1; while((i + j) < n && j <= MAX_CHAR) { if((Math.abs(str.charAt(i + j) - str.charAt(i)) == j)) result++; j++; } i++; } return result; } public static void main(String args[]) { String str = \"geeksforgeeks\"; System.out.println(countPairs(str)); } }", "src": "class\nTest { \n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\nfor\n(\nint\nj = \n1\n; (i + j) < n && j <= MAX_CHAR; j++) \n\nif\n((Math.abs(str.charAt(i + j) - str.charAt(i)) == j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n}", "index": 147, "complexity": "1"}
{"forwhile": "class ReverseArray { static void rvereseArray(int arr[], int start, int end) { int temp; if(start >= end) return; temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; rvereseArray(arr, start+1, end-1); } static void printArray(int arr[], int size) { int i = 0; while(i < size) { System.out.print(arr[i] + \" \"); i++; } System.out.println(\"\"); } public static void main (String[] args) { int arr[] = {1, 2, 3, 4, 5, 6}; printArray(arr, 6); int i = 0; while(i < 6) { System.out.println(\"Reversed array is \"); rvereseArray(arr, 0, 5); printArray(arr, 6); break; } } }", "src": "class\nReverseArray { \n\n\n\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n\n{ \n\nint\ntemp; \n\nif\n(start >= end) \n\nreturn\n; \n\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nrvereseArray(arr, start+\n1\n, end-\n1\n); \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nprintArray(arr, \n6\n); \n\nrvereseArray(arr, \n0\n, \n5\n); \n\nSystem.out.println(\n\"Reversed array is \"\n); \n\nprintArray(arr, \n6\n); \n\n} \n}", "index": 148, "complexity": "1"}
{"forwhile": "class GFG { static final int MAX_CHARS = 26; static void longestSubseqWithK(String str, int k) { int n = str.length(); int freq[] = new int[MAX_CHARS]; int i = 0; while(i < n) { freq[str.charAt(i) - 'a']++; i++; } i = 0; while(i < n) { if(freq[str.charAt(i) - 'a'] >= k) { System.out.print(str.charAt(i)); } i++; } } static public void main(String[] args) { String str = \"geeksforgeeks\"; int k = 2; longestSubseqWithK(str, k); } }", "src": "class\nGFG { \n\n\nstatic\nfinal\nint\nMAX_CHARS = \n26\n; \n\n\nstatic\nvoid\nlongestSubseqWithK(String str, \nint\nk) { \n\nint\nn = str.length(); \n\n\n\n\nint\nfreq[] = \nnew\nint\n[MAX_CHARS]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nfreq[str.charAt(i) - \n'a'\n]++; \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(freq[str.charAt(i) - \n'a'\n] >= k) { \n\nSystem.out.print(str.charAt(i)); \n\n} \n\n} \n\n} \n\n\n\nstatic\npublic\nvoid\nmain(String[] args) { \n\nString str = \n\"geeksforgeeks\"\n; \n\nint\nk = \n2\n; \n\nlongestSubseqWithK(str, k); \n\n\n} \n}", "index": 149, "complexity": "1"}
{"forwhile": "public class No_of_subsequence { static int countSubsequences(String s) { int aCount = 0; int bCount = 0; int cCount = 0; int i=0; while( i<s.length() ) { if( s.charAt(i) == 'a' ) aCount = (1 + 2 * aCount); else if( s.charAt(i) == 'b' ) bCount = (aCount + 2 * bCount); else if( s.charAt(i) == 'c' ) cCount = (bCount + 2 * cCount); i++; } return cCount; } public static void main(String args[]) { String s = \"abbc\"; System.out.println(countSubsequences(s)); } }", "src": "public\nclass\nNo_of_subsequence { \n\n\n\n\n\n\nstatic\nint\ncountSubsequences(String s) \n\n{ \n\n\n\n\n\nint\naCount = \n0\n; \n\n\n\n\n\n\n\n\nint\nbCount = \n0\n; \n\n\n\n\n\n\n\n\nint\ncCount = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i< s.length(); i++) \n\n{ \n\n\n\nif\n(s.charAt(i) == \n'a'\n) \n\naCount = (\n1\n+ \n2\n* aCount); \n\n\n\n\nelse\nif\n(s.charAt(i) == \n'b'\n) \n\nbCount = (aCount + \n2\n* bCount); \n\n\n\n\nelse\nif\n(s.charAt(i) == \n'c'\n) \n\ncCount = (bCount + \n2\n* cCount); \n\n} \n\n\nreturn\ncCount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abbc\"\n; \n\nSystem.out.println(countSubsequences(s)); \n\n} \n}", "index": 150, "complexity": "1"}
{"forwhile": "class GFG { static int countOccurrences(String s, int K) { int n = s.length(); int C = 0, c1 = 0, c2 = 0; int i = 0; while(i < n) { if(s.charAt(i) == 'a') c1++; if(s.charAt(i) == 'b') { c2++; C += c1; } i++; } return C * K + (K * (K - 1) / 2) * c1 * c2; } public static void main(String[] args) { String S = \"abcb\"; int k = 2; System.out.println(countOccurrences(S, k)); } }", "src": "class\nGFG { \n\n\nstatic\nint\ncountOccurrences(String s, \nint\nK) \n\n{ \n\nint\nn = s.length(); \n\nint\nC = \n0\n, c1 = \n0\n, c2 = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(s.charAt(i) == \n'a'\n) \n\nc1++; \n\n\nif\n(s.charAt(i) == \n'b'\n) { \n\nc2++; \n\n\n\n\n\n\n\nC += c1; \n\n} \n\n} \n\n\n\n\n\n\n\n\nreturn\nC * K + (K * (K - \n1\n) / \n2\n) * c1 * c2; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString S = \n\"abcb\"\n; \n\nint\nk = \n2\n; \n\n\nSystem.out.println(countOccurrences(S, k)); \n\n} \n}", "index": 151, "complexity": "1"}
{"forwhile": "public\nclass\nGFG { \n\n\nstatic\nint\nmax = \n100\n; \n\n\n\n\n\n\nstatic\nvoid\ncountSubsequence(String s, \nint\nn) \n\n{ \n\nint\ncntG = \n0\n, cntF = \n0\n, result = \n0\n, C=\n0\n; \n\n\n\n\nint\ni = \n0\n; \nwhile(i < n) { \n\nswitch\n(s.charAt(i)) { \n\n\n\n\n\n\n\n\n\n\ncase\n'G'\n: \n\ncntG++; \n\nresult+=C; \n\nbreak\n; \n\n\n\n\n\n\n\n\ncase\n'F'\n: \n\ncntF++; \n\nC+=cntG; \n\nbreak\n; \n\n\n\n\ndefault\n: \n\ni++; \n\ncontinue\n; \n\n} \n\ni++; \n\n} \n\n\nSystem.out.println(result); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nString s= \n\"GFGFG\"\n; \n\nint\nn = s.length(); \n\ncountSubsequence(s, n); \n\n} \n}", "src": "public\nclass\nGFG { \n\n\nstatic\nint\nmax = \n100\n; \n\n\n\n\n\n\nstatic\nvoid\ncountSubsequence(String s, \nint\nn) \n\n{ \n\nint\ncntG = \n0\n, cntF = \n0\n, result = \n0\n, C=\n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nswitch\n(s.charAt(i)) { \n\n\n\n\n\n\n\n\n\n\ncase\n'G'\n: \n\ncntG++; \n\nresult+=C; \n\nbreak\n; \n\n\n\n\n\n\n\n\ncase\n'F'\n: \n\ncntF++; \n\nC+=cntG; \n\nbreak\n; \n\n\n\n\ndefault\n: \n\ncontinue\n; \n\n} \n\n} \n\n\nSystem.out.println(result); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nString s= \n\"GFGFG\"\n; \n\nint\nn = s.length(); \n\ncountSubsequence(s, n); \n\n} \n}", "index": 152, "complexity": "1"}
{"forwhile": "public class Count_Subsequences { static final int MAX_CHAR = 256; static int countSub(String str) { int[] last = new int[MAX_CHAR]; java.util.Arrays.fill(last, -1); int n = str.length(); int[] dp = new int[n+1]; dp[0] = 1; int i = 1; while(i<=n) { dp[i] = 2*dp[i-1]; if(last[(int)str.charAt(i-1)] != -1) dp[i] = dp[i] - dp[last[(int)str.charAt(i-1)]]; last[(int)str.charAt(i-1)] = (i-1); i++; } return dp[n]; } public static void main(String args[]) { System.out.println(countSub(\"gfg\")); } }", "src": "public\nclass\nCount_Subsequences { \n\n\nstatic\nfinal\nint\nMAX_CHAR = \n256\n; \n\n\n\n\nstatic\nint\ncountSub(String str) \n\n{ \n\n\n\n\n\nint\n[] last = \nnew\nint\n[MAX_CHAR]; \n\nArrays.fill(last, -\n1\n); \n\n\n\n\nint\nn = str.length(); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\n\n\n\ndp[\n0\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n\n\n\n\ndp[i] = \n2\n*dp[i-\n1\n]; \n\n\n\n\n\n\n\n\nif\n(last[(\nint\n)str.charAt(i-\n1\n)] != -\n1\n) \n\ndp[i] = dp[i] - dp[last[(\nint\n)str.charAt(i-\n1\n)]]; \n\n\n\n\nlast[(\nint\n)str.charAt(i-\n1\n)] = (i-\n1\n); \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nSystem.out.println(countSub(\n\"gfg\"\n)); \n\n} \n}", "index": 153, "complexity": "1"}
{"forwhile": "class UglyNumber  {  int getNthUglyNo( int n) {  int ugly[] = new int [n];  int i2 = 0 , i3 = 0 , i5 = 0;  int next_multiple_of_2 = 2;  int next_multiple_of_3 = 3;  int next_multiple_of_5 = 5;  int next_ugly_no = 1;  ugly[0] = 1;  int i = 1;  while(i < n) {  next_ugly_no = Math.min(next_multiple_of_2, Math.min(next_multiple_of_3, next_multiple_of_5));  ugly[i] = next_ugly_no;  if(next_ugly_no == next_multiple_of_2) {  i2 = i2+1;  next_multiple_of_2 = ugly[i2]*2;  }  if(next_ugly_no == next_multiple_of_3) {  i3 = i3+1;  next_multiple_of_3 = ugly[i3]*3;  }  if(next_ugly_no == next_multiple_of_5) {  i5 = i5+1;  next_multiple_of_5 = ugly[i5]*5;  }  i++;  }  return next_ugly_no;  }  public static void main(String args[]) {  int n = 150;  UglyNumber obj = new UglyNumber();  System.out.println(obj.getNthUglyNo(n));  } }", "src": "class\nUglyNumber \n{ \n\n\n\nint\ngetNthUglyNo(\nint\nn) \n\n{ \n\nint\nugly[] = \nnew\nint\n[n]; \n\n\nint\ni2 = \n0\n, i3 = \n0\n, i5 = \n0\n; \n\nint\nnext_multiple_of_2 = \n2\n; \n\nint\nnext_multiple_of_3 = \n3\n; \n\nint\nnext_multiple_of_5 = \n5\n; \n\nint\nnext_ugly_no = \n1\n; \n\n\nugly[\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nnext_ugly_no = Math.min(next_multiple_of_2, \n\nMath.min(next_multiple_of_3, \n\nnext_multiple_of_5)); \n\n\nugly[i] = next_ugly_no; \n\nif\n(next_ugly_no == next_multiple_of_2) \n\n{ \n\ni2 = i2+\n1\n; \n\nnext_multiple_of_2 = ugly[i2]*\n2\n; \n\n} \n\nif\n(next_ugly_no == next_multiple_of_3) \n\n{ \n\ni3 = i3+\n1\n; \n\nnext_multiple_of_3 = ugly[i3]*\n3\n; \n\n} \n\nif\n(next_ugly_no == next_multiple_of_5) \n\n{ \n\ni5 = i5+\n1\n; \n\nnext_multiple_of_5 = ugly[i5]*\n5\n; \n\n} \n\n} \n\n\nreturn\nnext_ugly_no; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n150\n; \n\nUglyNumber obj = \nnew\nUglyNumber(); \n\nSystem.out.println(obj.getNthUglyNo(n)); \n\n} \n}", "index": 154, "complexity": "1"}
{"forwhile": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\n[]fact = \nnew\nint\n[n+\n1\n]; \n\n\n\n\nfact[\n0\n] = \n1\n; \n\n\n\n\n\n\nint\ni = \n1\n; \nwhile(i <= n) \n\n{ fact[i] = i * fact[i - \n1\n]; \ni++; } \n\n\n\n\nreturn\nfact[n] / fact[n - k]; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of\"\n\n+ \n\" P( \"\n+ n + \n\", \"\n+ k + \n\") is \"\n\n+ permutationCoeff(n, k) ); \n\n} \n}", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\n[]fact = \nnew\nint\n[n+\n1\n]; \n\n\n\n\nfact[\n0\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfact[i] = i * fact[i - \n1\n]; \n\n\n\n\nreturn\nfact[n] / fact[n - k]; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of\"\n\n+ \n\" P( \"\n+ n + \n\", \"\n+ k + \n\") is \"\n\n+ permutationCoeff(n, k) ); \n\n} \n}", "index": 155, "complexity": "1"}
{"forwhile": "class GFG { static int countFriendsPairings(int n) { int dp[] = new int[n + 1]; int i = 0; while(i <= n) { if(i <= 2) dp[i] = i; else dp[i] = dp[i - 1] + (i - 1) * dp[i - 2]; i++; } return dp[n]; } public static void main(String[] args) { int n = 4; System.out.println(countFriendsPairings(n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n + \n1\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) { \n\nif\n(i <= \n2\n) \n\ndp[i] = i; \n\nelse\n\ndp[i] = dp[i - \n1\n] + (i - \n1\n) * dp[i - \n2\n]; \n\n} \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}", "index": 156, "complexity": "1"}
{"forwhile": "public class Test  {\n\nstatic int arr[] = new int[]{1 , 2 , 3 , 4 , 5}; \n\n\n\n\nstatic void rotate() \n\n{ \n\nint x = arr[arr.length-1], i; \n\ni = arr.length-1;\nwhile(i > 0) \n\n{arr[i] = arr[i-1]; i--;} \n\narr[0] = x; \n\n} \n\n\n\n\npublic static void main(String[] args) \n\n{ \n\nSystem.out.println(\"Given Array is\"); \n\nSystem.out.println(Arrays.toString(arr)); \n\n\nrotate(); \n\n\nSystem.out.println(\"Rotated Array is\"); \n\nSystem.out.println(Arrays.toString(arr)); \n\n} \n}", "src": "public\nclass\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n1\n, \n2\n, \n3\n, \n4\n, \n5\n}; \n\n\n\n\nstatic\nvoid\nrotate() \n\n{ \n\nint\nx = arr[arr.length-\n1\n], i; \n\nfor\n(i = arr.length-\n1\n; i > \n0\n; i--) \n\narr[i] = arr[i-\n1\n]; \n\narr[\n0\n] = x; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Given Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n\nrotate(); \n\n\nSystem.out.println(\n\"Rotated Array is\"\n); \n\nSystem.out.println(Arrays.toString(arr)); \n\n} \n}", "index": 157, "complexity": "1"}
{"forwhile": "class GFG { static int [] dp = new int [1000]; static int countFriendsPairings(int n) { if (dp[n] != -1) return dp[n]; if (n > 2) return dp[n] = countFriendsPairings(n - 1) + (n - 1) * countFriendsPairings(n - 2); else return dp[n] = n; } public static void main(String[] args) { int i = 0; while (i < 1000) { dp[i] = -1; i++; } int n = 4; System.out.println(countFriendsPairings(n)); } }", "src": "class\nGFG { \n\nstatic\nint\n[] dp = \nnew\nint\n[\n1000\n]; \n\n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nif\n(dp[n] != -\n1\n) \n\nreturn\ndp[n]; \n\n\nif\n(n > \n2\n) \n\nreturn\ndp[n] = countFriendsPairings(n - \n1\n) + (n - \n1\n) * countFriendsPairings(n - \n2\n); \n\nelse\n\nreturn\ndp[n] = n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < \n1000\n; i++) \n\ndp[i] = -\n1\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}", "index": 158, "complexity": "1"}
{"forwhile": "class GFG { static int sequence(int n) { int f[] = new int[n + 1]; f[0] = 0; f[1] = 1; f[2] = 1; int i = 3; while(i <= n) { f[i] = f[f[i - 1]] + f[i - f[i - 1]]; i++; } return f[n]; } public static void main(String[] args) { int n = 10; System.out.println(sequence(n)); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nsequence(\nint\nn) \n\n{ \n\n\n\nint\nf[] = \nnew\nint\n[n + \n1\n]; \n\nf[\n0\n] = \n0\n; \n\nf[\n1\n] = \n1\n; \n\nf[\n2\n] = \n1\n; \n\n\nint\ni; \n\n\nfor\n(i = \n3\n; i <= n; i++) \n\nf[i] = f[f[i - \n1\n]] + \n\nf[i - f[i - \n1\n]]; \n\n\nreturn\nf[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(sequence(n)); \n\n\n} \n}", "index": 160, "complexity": "1"}
{"forwhile": "class RearrangeArray { void rearrangeNaive(int arr[], int n) { int temp[] = new int[n]; int i = 0; while(i < n) temp[arr[i]] = i++; i = 0; while(i < n) arr[i] = temp[i++;;} void printArray(int arr[], int n) { int i = 0; while(i < n) { System.out.print(arr[i] + \" \"); } System.out.println(\"\"); } public static void main(String[] args) { RearrangeArray arrange = new RearrangeArray(); int arr[] = { 1, 3, 0, 2 }; int n = arr.length; System.out.println(\"Given array is \"); arrange.printArray(arr, n); arrange.rearrangeNaive(arr, n); System.out.println(\"Modified array is \"); arrange.printArray(arr, n); }}", "src": "class\nRearrangeArray { \n\n\n\n\n\nvoid\nrearrangeNaive(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\ntemp[] = \nnew\nint\n[n]; \n\nint\ni; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\ntemp[arr[i]] = i; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n1\n, \n3\n, \n0\n, \n2\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrangeNaive(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n}", "index": 161, "complexity": "1"}
{"forwhile": "class GFG { static int maxSumWO3Consec( int arr[], int n) { int sum[] = new int[n]; if(n >= 1) sum[0] = arr[0]; if(n >= 2) sum[1] = arr[0] + arr[1]; if(n > 2) sum[2] = Math.max(sum[1], Math.max(arr[1] + arr[2], arr[0] + arr[2])); int i = 3; while(i < n) { sum[i] = Math.max(Math.max(sum[i - 1], sum[i - 2] + arr[i]), arr[i] + arr[i - 1] + sum[i - 3]); i++; } return sum[n - 1]; } public static void main(String[] args) { int arr[] = { 100, 1000, 100, 1000, 1 }; int n = arr.length; System.out.println(maxSumWO3Consec(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumWO3Consec(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\nsum[] = \nnew\nint\n[n]; \n\n\n\n\nif\n(n >= \n1\n) \n\nsum[\n0\n] = arr[\n0\n]; \n\n\nif\n(n >= \n2\n) \n\nsum[\n1\n] = arr[\n0\n] + arr[\n1\n]; \n\n\nif\n(n > \n2\n) \n\nsum[\n2\n] = Math.max(sum[\n1\n], Math.max(arr[\n1\n] + arr[\n2\n], arr[\n0\n] + arr[\n2\n])); \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n3\n; i < n; i++) \n\nsum[i] = Math.max(Math.max(sum[i - \n1\n], sum[i - \n2\n] + arr[i]), \n\narr[i] + arr[i - \n1\n] + sum[i - \n3\n]); \n\n\nreturn\nsum[n - \n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n100\n, \n1000\n, \n100\n, \n1000\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSumWO3Consec(arr, n)); \n\n} \n}", "index": 162, "complexity": "1"}
{"forwhile": "class GFG { static int maximumSegments(int n, int a, int b, int c) { int dp[] = new int[n + 10]; Arrays.fill(dp, -1); dp[0] = 0; int i = 0; while (i < n) { if (dp[i] != -1) { if (i + a <= n ) dp[i + a] = Math.max(dp[i] + 1, dp[i + a]); if (i + b <= n ) dp[i + b] = Math.max(dp[i] + 1, dp[i + b]); if (i + c <= n ) dp[i + c] = Math.max(dp[i] + 1, dp[i + c]); } i++; } return dp[n]; } public static void main(String arg[]) { int n = 7, a = 5, b = 2, c = 5; System.out.print(maximumSegments(n, a, b, c)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\nmaximumSegments(\nint\nn, \nint\na, \n\nint\nb, \nint\nc) \n\n{ \n\n\n\n\n\nint\ndp[] = \nnew\nint\n[n + \n10\n]; \n\n\n\n\nArrays.fill(dp, -\n1\n); \n\n\n\n\n\n\ndp[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(dp[i] != -\n1\n) \n\n{ \n\n\n\n\nif\n(i + a <= n ) \n\n\ndp[i + a] = Math.max(dp[i] + \n1\n, \n\ndp[i + a]); \n\n\nif\n(i + b <= n ) \n\n\ndp[i + b] = Math.max(dp[i] + \n1\n, \n\ndp[i + b]); \n\n\nif\n(i + c <= n ) \n\n\ndp[i + c] = Math.max(dp[i] + \n1\n, \n\ndp[i + c]); \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nn = \n7\n, a = \n5\n, b = \n2\n, c = \n5\n; \n\nSystem.out.print(maximumSegments(n, a, b, c)); \n\n} \n}", "index": 164, "complexity": "1"}
{"forwhile": "class RearrangeArray { void rearrangeUtil(int arr[], int n, int i) { int val = -(i + 1); i = arr[i] - 1; while(arr[i] > 0) { int new_i = arr[i] - 1; arr[i] = val; val = -(i + 1); i = new_i; } } void rearrange(int arr[], int n) { int i = 0; while(i < n) { arr[i]++; i++; } i = 0; while(i < n) { if(arr[i] > 0) rearrangeUtil(arr, n, i); i++; } i = 0; while(i < n) { arr[i] = (-arr[i]) - 1; i++; } } void printArray(int arr[], int n) { int i = 0; while(i < n) { System.out.print(arr[i] + \" \"); i++; } System.out.println(\"\"); } public static void main(String[] args) { RearrangeArray arrange = new RearrangeArray(); int arr[] = { 2, 0, 1, 4, 5, 3}; int n = arr.length; System.out.println(\"Given array is \"); arrange.printArray(arr, n); arrange.rearrange(arr, n); System.out.println(\"Modified array is \"); arrange.printArray(arr, n); } }", "src": "class\nRearrangeArray { \n\n\n\n\n\n\n\n\n\nvoid\nrearrangeUtil(\nint\narr[], \nint\nn, \nint\ni) \n\n{ \n\n\n\n\n\n\nint\nval = -(i + \n1\n); \n\n\n\n\n\n\ni = arr[i] - \n1\n; \n\n\n\n\nwhile\n(arr[i] > \n0\n) { \n\n\n\n\n\nint\nnew_i = arr[i] - \n1\n; \n\n\n\n\narr[i] = val; \n\n\n\n\nval = -(i + \n1\n); \n\ni = new_i; \n\n} \n\n} \n\n\n\n\n\n\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i]++; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\n\n\n\n\nif\n(arr[i] > \n0\n) \n\nrearrangeUtil(arr, n, i); \n\n} \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\narr[i] = (-arr[i]) - \n1\n; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRearrangeArray arrange = \nnew\nRearrangeArray(); \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is \"\n); \n\narrange.printArray(arr, n); \n\n\narrange.rearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is \"\n); \n\narrange.printArray(arr, n); \n\n} \n}", "index": 165, "complexity": "1"}
{"forwhile": "class GFG { final int MAX = 1000000; static int breakSum(int n) { int dp[] = new int[n+1]; dp[0] = 0; dp[1] = 1; int i = 2; while(i<=n) { dp[i] = Math.max(dp[i/2] + dp[i/3] + dp[i/4], i); i++; } return dp[n]; } public static void main (String[] args) { int n = 24; System.out.println(breakSum(n)); } }", "src": "class\nGFG { \n\n\nfinal\nint\nMAX = \n1000000\n; \n\n\n\n\nstatic\nint\nbreakSum(\nint\nn) \n\n{ \n\nint\ndp[] = \nnew\nint\n[n+\n1\n]; \n\n\n\n\ndp[\n0\n] = \n0\n; dp[\n1\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni=\n2\n; i<=n; i++) \n\ndp[i] = Math.max(dp[i/\n2\n] + dp[i/\n3\n] + dp[i/\n4\n], i); \n\n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\nn = \n24\n; \n\nSystem.out.println(breakSum(n)); \n\n} \n}", "index": 166, "complexity": "1"}
{"forwhile": "class GFG { public static int maxSum(int grid[][], int n) { int incl = Math.max(grid[0][0], grid[1][0]); int excl = 0, excl_new; int i = 1; while(i < n) { excl_new = Math.max(excl, incl); incl = excl + Math.max(grid[0][i], grid[1][i]); excl = excl_new; i++; } return Math.max(excl, incl); } public static void main(String[] args) { int grid[][] = {{ 1, 2, 3, 4, 5}, { 6, 7, 8, 9, 10}}; int n = 5; System.out.println(maxSum(grid, n)); } }", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nmaxSum(\nint\ngrid[][], \nint\nn) \n\n{ \n\n\n\n\n\nint\nincl = Math.max(grid[\n0\n][\n0\n], grid[\n1\n][\n0\n]); \n\n\n\n\nint\nexcl = \n0\n, excl_new; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++ ) \n\n{ \n\n\n\n\n\nexcl_new = Math.max(excl, incl); \n\n\n\n\n\n\nincl = excl + Math.max(grid[\n0\n][i], grid[\n1\n][i]); \n\n\n\n\nexcl = excl_new; \n\n} \n\n\n\n\n\n\nreturn\nMath.max(excl, incl); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ngrid[][] = {{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n}, \n\n{ \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}}; \n\n\nint\nn = \n5\n; \n\nSystem.out.println(maxSum(grid, n)); \n\n} \n\n}", "index": 167, "complexity": "1"}
{"forwhile": "class GFG { public static int findLength(String str, int n) { int current_sum = 0; int max_sum = 0; int i = 0; while(i < n) { current_sum += (str.charAt(i) == '0' ? 1 : -1); if(current_sum < 0) current_sum = 0; max_sum = Math.max(current_sum, max_sum); i++; } return max_sum == 0 ? -1 : max_sum; } public static void main(String[] args) { String str = \"11000010001\"; int n = str.length(); System.out.println(findLength(str, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nfindLength(String str, \nint\nn) \n\n{ \n\n\nint\ncurrent_sum = \n0\n; \n\nint\nmax_sum = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\ncurrent_sum += (str.charAt(i) == \n'0'\n? \n1\n: -\n1\n); \n\n\nif\n(current_sum < \n0\n) \n\ncurrent_sum = \n0\n; \n\n\n\n\nmax_sum = Math.max(current_sum, max_sum); \n\n} \n\n\n\n\n\nreturn\nmax_sum == \n0\n? -\n1\n: max_sum; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"11000010001\"\n; \n\nint\nn = str.length(); \n\n\nSystem.out.println(findLength(str, n)); \n\n} \n}", "index": 168, "complexity": "1"}
{"forwhile": "public\nclass\nGFG{ \n\n\n\n\n\n\nstatic\nint\nminTimeForWritingChars(\nint\nN, \nint\ninsert, \n\nint\nremove, \nint\ncopy) \n\n{ \n\nif\n(N == \n0\n) \n\nreturn\n0\n; \n\nif\n(N == \n1\n) \n\nreturn\ninsert; \n\n\n\n\nint\ndp[] = \nnew\nint\n[N + \n1\n]; \n\n\nint\ni = \n1\n;\nwhile(i <= N) { \n\n\n\nif\n(i % \n2\n== \n0\n) \n\ndp[i] = Math.min(dp[i-\n1\n] + insert, dp[i/\n2\n] + copy); \n\n\n\n\nelse\n\ndp[i] = Math.min(dp[i-\n1\n] + insert, \n\ndp[(i+\n1\n)/\n2\n] + copy + remove); \n\ni++; \n}\n\nreturn\ndp[N]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String []args) \n\n{ \n\nint\nN = \n9\n; \n\nint\ninsert = \n1\n, remove = \n2\n, copy = \n1\n; \n\nSystem.out.println(minTimeForWritingChars(N, insert,remove, copy)); \n\n} \n\n\n}", "src": "public\nclass\nGFG{ \n\n\n\n\n\n\nstatic\nint\nminTimeForWritingChars(\nint\nN, \nint\ninsert, \n\nint\nremove, \nint\ncopy) \n\n{ \n\nif\n(N == \n0\n) \n\nreturn\n0\n; \n\nif\n(N == \n1\n) \n\nreturn\ninsert; \n\n\n\n\nint\ndp[] = \nnew\nint\n[N + \n1\n]; \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= N; i++) \n\n{ \n\n\n\nif\n(i % \n2\n== \n0\n) \n\ndp[i] = Math.min(dp[i-\n1\n] + insert, dp[i/\n2\n] + copy); \n\n\n\n\nelse\n\ndp[i] = Math.min(dp[i-\n1\n] + insert, \n\ndp[(i+\n1\n)/\n2\n] + copy + remove); \n\n} \n\nreturn\ndp[N]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String []args) \n\n{ \n\nint\nN = \n9\n; \n\nint\ninsert = \n1\n, remove = \n2\n, copy = \n1\n; \n\nSystem.out.println(minTimeForWritingChars(N, insert,remove, copy)); \n\n} \n\n\n}", "index": 169, "complexity": "1"}
{"forwhile": "class GFG{ public static int sumOfSubstrings(String num) { int n = num.length(); int[] sumofdigit = new int[n]; sumofdigit[0] = num.charAt(0)-'0'; int res = sumofdigit[0]; int i = 1; while(i < n) { int numi = num.charAt(i)-'0'; sumofdigit[i] = (i+1) * numi + 10* sumofdigit[i-1]; res += sumofdigit[i]; i++; } return res; } public static void main(String[] args) { String num = \"1234\"; System.out.println(sumOfSubstrings(num)); } }", "src": "class\nGFG{ \n\n\n\n\npublic\nstatic\nint\nsumOfSubstrings(String num) \n\n{ \n\nint\nn = num.length(); \n\n\n\n\nint\nsumofdigit[] = \nnew\nint\n[n]; \n\n\n\n\nsumofdigit[\n0\n] = num.charAt(\n0\n)-\n'0'\n; \n\nint\nres = sumofdigit[\n0\n]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nint\nnumi = num.charAt(i)-\n'0'\n; \n\n\n\n\nsumofdigit[i] = (i+\n1\n) * numi + \n\n10\n* sumofdigit[i-\n1\n]; \n\n\n\n\nres += sumofdigit[i]; \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString num = \n\"1234\"\n; \n\n\nSystem.out.println(sumOfSubstrings(num)); \n\n\n} \n}", "index": 170, "complexity": "1"}
{"forwhile": "class GFG \n{ \n\n\n\nstatic int maxLoot( int hval[], int n) \n\n{ \n\nif (n == 0 ) \n\nreturn 0 ; \n\nif (n == 1 ) \n\nreturn hval[ 0 ]; \n\nif (n == 2 ) \n\nreturn Math.max(hval[ 0 ], hval[ 1 ]); \n\n\n\n\n\n\nint [] dp = new int [ n ]; \n\n\n\n\ndp[ 0 ] = hval[ 0 ]; \n\ndp[ 1 ] = Math.max(hval[ 0 ], hval[ 1 ]); \n\n\n\n\nint i = 2 ; \n\nwhile(i<n){ \n\n    dp[i] = Math.max(hval[i]+dp[i- 2 ], dp[i- 1 ]); \n\n    i++; \n\n} \n\nreturn dp[n- 1 ]; \n\n} \n\n\n\n\npublic static void main (String[] args) \n\n{ \n\nint hval[] = { 6 , 7 , 1 , 3 , 8 , 2 , 4 }; \n\nint n = hval.length; \n\nSystem.out.println( \"Maximum loot value : \"+ maxLoot(hval, n)); \n\n} \n}", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\nif\n(n == \n1\n) \n\nreturn\nhval[\n0\n]; \n\nif\n(n == \n2\n) \n\nreturn\nMath.max(hval[\n0\n], hval[\n1\n]); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n]; \n\n\n\n\ndp[\n0\n] = hval[\n0\n]; \n\ndp[\n1\n] = Math.max(hval[\n0\n], hval[\n1\n]); \n\n\n\n\nfor\n(\nint\ni = \n2\n; i<n; i++) \n\ndp[i] = Math.max(hval[i]+dp[i-\n2\n], dp[i-\n1\n]); \n\n\nreturn\ndp[n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n}", "index": 171, "complexity": "1"}
{"forwhile": "ERROR:Expecting ':' delimiter: line 2 column 609 (char 610)", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxLoot(\nint\nhval[], \nint\nn) \n\n{ \n\nif\n(n == \n0\n) \n\nreturn\n0\n; \n\n\nint\nvalue1 = hval[\n0\n]; \n\nif\n(n == \n1\n) \n\nreturn\nvalue1; \n\n\nint\nvalue2 = Math.max(hval[\n0\n], hval[\n1\n]); \n\nif\n(n == \n2\n) \n\nreturn\nvalue2; \n\n\n\n\nint\nmax_val = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n2\n; i<n; i++) \n\n{ \n\nmax_val = Math.max(hval[i]+value1, value2); \n\nvalue1 = value2; \n\nvalue2 = max_val; \n\n} \n\n\nreturn\nmax_val; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nhval[] = {\n6\n, \n7\n, \n1\n, \n3\n, \n8\n, \n2\n, \n4\n}; \n\nint\nn = hval.length; \n\nSystem.out.println(\n\"Maximum loot value : \"\n+ maxLoot(hval, n)); \n\n} \n}", "index": 172, "complexity": "1"}
{"forwhile": "class GFG { static int countWays(int n) { int DP[] = new int[n + 1]; DP[0] = DP[1] = DP[2] = 1; DP[3] = 2; int i = 4; while(i <= n) { DP[i] = DP[i - 1] + DP[i - 3] + DP[i - 4]; i++; } return DP[n]; } public static void main(String[] args) { int n = 10; System.out.println(countWays(n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ncountWays(\nint\nn) \n\n{ \n\nint\nDP[] = \nnew\nint\n[n + \n1\n]; \n\n\n\n\nDP[\n0\n] = DP[\n1\n] = DP[\n2\n] = \n1\n; \n\nDP[\n3\n] = \n2\n; \n\n\n\n\nfor\n(\nint\ni = \n4\n; i <= n; i++) \n\nDP[i] = DP[i - \n1\n] + DP[i - \n3\n] \n\n+ DP[i - \n4\n]; \n\n\nreturn\nDP[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n10\n; \n\nSystem.out.println(countWays(n)); \n\n} \n}", "index": 173, "complexity": "1"}
{"forwhile": "public class GFG { static long countWays(int n) { long dp[][] = new long[2][n + 1]; dp[0][1] = 1; dp[1][1] = 2; int i = 2; while(i <= n) { dp[0][i] = dp[0][i - 1] + dp[1][i - 1]; dp[1][i] = dp[0][i - 1] * 2 + dp[1][i - 1]; i++; } return dp[0][n] + dp[1][n]; } public static void main(String[] args) { int n = 5; System.out.print(\"Total no of ways with n = \" + n + \" are: \" + countWays(n)); } }", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nlong\ncountWays(\nint\nn) { \n\nlong\ndp[][] = \nnew\nlong\n[\n2\n][n + \n1\n]; \n\n\n\n\ndp[\n0\n][\n1\n] = \n1\n; \n\ndp[\n1\n][\n1\n] = \n2\n; \n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\n\n\n\n\n\ndp[\n0\n][i] = dp[\n0\n][i - \n1\n] + dp[\n1\n][i - \n1\n]; \n\n\n\n\n\n\ndp[\n1\n][i] = dp[\n0\n][i - \n1\n] * \n2\n+ dp[\n1\n][i - \n1\n]; \n\n} \n\n\n\n\nreturn\ndp[\n0\n][n] + dp[\n1\n][n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nint\nn = \n5\n; \n\nSystem.out.print(\n\"Total no of ways with n = \"\n+ n \n\n+ \n\" are: \"\n+ countWays(n)); \n\n} \n\n}", "index": 174, "complexity": "1"}
{"forwhile": "class GFG { static int countWays( int n, int m) { int count[] = new int[n + 1]; count[0] = 0; int i = 1; while(i <= n) { if(i > m) count[i] = count[i - 1] + count[i - m]; else if(i < m) count[i] = 1; else count[i] = 2; i++; } return count[n]; } public static void main(String[] args) { int n = 7; int m = 4; System.out.println(\"Number of ways = \" + countWays(n, m)); } }", "src": "class\nGFG { \n\n\n\nstatic\nint\ncountWays(\nint\nn, \nint\nm) \n\n{ \n\n\n\n\n\nint\ncount[] = \nnew\nint\n[n + \n1\n]; \n\ncount[\n0\n] = \n0\n; \n\n\n\n\nint\ni; \n\nfor\n(i = \n1\n; i <= n; i++) { \n\n\n\nif\n(i > m) \n\ncount[i] = count[i - \n1\n] + count[i - m]; \n\n\n\n\nelse\nif\n(i < m) \n\ncount[i] = \n1\n; \n\n\n\n\nelse\n\ncount[i] = \n2\n; \n\n} \n\n\n\n\nreturn\ncount[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n7\n; \n\nint\nm = \n4\n; \n\nSystem.out.println(\n\"Number of ways = \"\n\n+ countWays(n, m)); \n\n} \n}", "index": 175, "complexity": "1"}
{"forwhile": "class Grid { static int count(int n) { int[] dp = new int[n+1]; dp[0] = 0; int i = 1; while(i <= n) { if(i >= 1 && i <= 3) dp[i] = 1; else if(i == 4) dp[i] = 2; else { dp[i] = dp[i-1] + dp[i-4]; } i++; } return dp[n]; } public static void main (String[] args) { int n = 5; System.out.println(\"Count of ways is: \"+ count(n)); } }", "src": "class\nGrid \n{ \n\n\n\n\n\nstatic\nint\ncount(\nint\nn) \n\n{ \n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n+\n1\n]; \n\ndp[\n0\n] = \n0\n; \n\n\n\nfor\n(\nint\ni=\n1\n;i<=n;i++) \n\n{ \n\n\n\nif\n(i >= \n1\n&& i <= \n3\n) \n\ndp[i] = \n1\n; \n\nelse\nif\n(i==\n4\n) \n\ndp[i] = \n2\n; \n\n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\ndp[i] = dp[i-\n1\n] + dp[i-\n4\n]; \n\n} \n\n} \n\nreturn\ndp[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nSystem.out.println(\n\"Count of ways is: \"\n+ count(n)); \n\n} \n}", "index": 176, "complexity": "1"}
{"forwhile": "class GFG { static int nonDecNums(int n) { int[][] a = new int[n + 1][10]; int i = 0; while(i <= 9) a[0][i] = 1; i = 1; while(i <= n) { a[i][9] = 1; i++; } i = 1; while(i <= n) { int j = 8; while(j >= 0) { a[i][j] = a[i - 1][j] + a[i][j + 1]; j--; } i++; } return a[n][0]; } public static void main(String[] args) { int n = 2; System.out.println(\"Non-decreasing digits = \" + nonDecNums(n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nnonDecNums(\nint\nn) \n\n{ \n\n\n\n\n\nint\n[][] a = \nnew\nint\n[n + \n1\n][\n10\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= \n9\n; i++) \n\na[\n0\n][i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\na[i][\n9\n] = \n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\nfor\n(\nint\nj = \n8\n; j >= \n0\n; j--) \n\na[i][j] = a[i - \n1\n][j] + a[i][j + \n1\n]; \n\n\nreturn\na[n][\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Non-decreasing digits = \"\n+ nonDecNums(n)); \n\n} \n}", "index": 177, "complexity": "1"}
{"forwhile": "class GFG  { static int maxRevenue( int m,  int[] x,  int[] revenue,  int n,  int t) {  int[] maxRev = new int[m + 1]; int i = 0;  while(i < m + 1)  { maxRev[i] = 0; i++; }  int nxtbb = 0;  i = 1;  while(i <= m)  { if(nxtbb < n)  { if(!(x[nxtbb] != i))  { if(i <= t)  maxRev[i] = Math.max(maxRev[i - 1],  revenue[nxtbb]);  else maxRev[i] = Math.max(maxRev[i -  t - 1] +  revenue[nxtbb],  maxRev[i - 1]); nxtbb++; }  else maxRev[i] = maxRev[i - 1]; }  i++; }  return maxRev[m]; }  public static void main(String []args)  { int m = 20; int[] x = new int[]{6, 7, 12, 13, 14}; int[] revenue = new int[]{5, 6, 5, 3, 1}; int n = x.length; int t = 5; System.out.println(maxRevenue(m, x, revenue, n, t)); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nmaxRevenue(\nint\nm, \nint\n[] x, \n\nint\n[] revenue, \n\nint\nn, \nint\nt) \n{ \n\n\n\n\n\n\nint\n[] maxRev = \nnew\nint\n[m + \n1\n]; \n\nfor\n(\nint\ni = \n0\n; i < m + \n1\n; i++) \n\nmaxRev[i] = \n0\n; \n\n\n\n\n\n\nint\nnxtbb = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\n{ \n\n\n\n\n\nif\n(nxtbb < n) \n\n{ \n\n\n\n\n\n\n\nif\n(x[nxtbb] != i) \n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n\n\n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\nif\n(i <= t) \n\nmaxRev[i] = Math.max(maxRev[i - \n1\n], \n\nrevenue[nxtbb]); \n\n\n\n\n\n\nelse\n\nmaxRev[i] = Math.max(maxRev[i - t - \n1\n] + \n\nrevenue[nxtbb], \n\nmaxRev[i - \n1\n]); \n\n\nnxtbb++; \n\n} \n\n} \n\nelse\n\nmaxRev[i] = maxRev[i - \n1\n]; \n\n} \n\n\nreturn\nmaxRev[m]; \n} \n\n\npublic\nstatic\nvoid\nmain(String []args) \n{ \n\nint\nm = \n20\n; \n\nint\n[] x = \nnew\nint\n[]{\n6\n, \n7\n, \n12\n, \n13\n, \n14\n}; \n\nint\n[] revenue = \nnew\nint\n[]{\n5\n, \n6\n, \n5\n, \n3\n, \n1\n}; \n\nint\nn = x.length; \n\nint\nt = \n5\n; \n\nSystem.out.println(maxRevenue(m, x, revenue, n, t)); \n} \n}", "index": 178, "complexity": "1"}
{"forwhile": "public class Main { public static void rearrange(int arr[], int n) { int max_ele = arr[n - 1]; int min_ele = arr[0]; int i = 0; while(i < n) { if(i % 2 == 0) { arr[i] = max_ele; max_ele -= 1; } else { arr[i] = min_ele; min_ele += 1; } i++; } } public static void main(String args[]) { int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int n = arr.length; System.out.println(\"Original Array\"); int i = 0; while(i < n) { System.out.print(arr[i] + \" \"); i++; } rearrange(arr, n); System.out.print(\"\\nModified Array\\n\"); i = 0; while(i < n) { System.out.print(arr[i] + \" \"); i++; } } }", "src": "public\nclass\nMain { \n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\nmax_ele = arr[n - \n1\n]; \n\nint\nmin_ele = arr[\n0\n]; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\nif\n(i % \n2\n== \n0\n) { \n\narr[i] = max_ele; \n\nmax_ele -= \n1\n; \n\n} \n\n\n\n\nelse\n{ \n\narr[i] = min_ele; \n\nmin_ele += \n1\n; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Original Array\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"\\nModified Array\\n\"\n); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 179, "complexity": "1"}
{"forwhile": "class GFG  {   static int max( int x,  int y) {   return (x > y ? x : y); }    static int maxTasks( int[]high,  int[]low,  int n) {       int[] task_dp = new int[n + 1];       task_dp[0] = 0;       task_dp[1] = high[0];       int i = 2;       while(i <= n) task_dp[i] = Math.max(high[i - 1] + task_dp[i - 2],  low[i - 1] + task_dp[i - 1]);           return task_dp[n]; }    public static void main(String[] args) {       int n = 5;       int[]high = { 3 , 6 , 8 , 7 , 6 };       int[]low = { 1 , 5 , 4 , 5 , 3 };       System.out.println(maxTasks(high, low, n)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmax(\nint\nx, \nint\ny) \n{ \n\nreturn\n(x > y ? x : y); \n} \n\n\n\nstatic\nint\nmaxTasks(\nint\n[]high, \nint\n[]low, \nint\nn) \n{ \n\n\n\n\n\nint\n[] task_dp = \nnew\nint\n[n + \n1\n]; \n\n\n\n\ntask_dp[\n0\n] = \n0\n; \n\n\n\n\n\n\ntask_dp[\n1\n] = high[\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) \n\ntask_dp[i] = Math.max(high[i - \n1\n] + task_dp[i - \n2\n], \n\nlow[i - \n1\n] + task_dp[i - \n1\n]); \n\nreturn\ntask_dp[n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n5\n; \n\nint\n[]high = {\n3\n, \n6\n, \n8\n, \n7\n, \n6\n}; \n\nint\n[]low = {\n1\n, \n5\n, \n4\n, \n5\n, \n3\n}; \n\nSystem.out.println(maxTasks(high, low, n)); \n} \n}", "index": 181, "complexity": "1"}
{"forwhile": "class GFG { static void segregateElements(int arr[], int n) { int temp[] = new int[n]; int j = 0; int i = 0; while (i < n) { if (arr[i] >= 0) temp[j++] = arr[i]; i++; } if (j == n || j == 0) return; i = 0; while (i < n) { if (arr[i] < 0) temp[j++] = arr[i]; i++; } i = 0; while (i < n) { arr[i] = temp[i]; i++; } } public static void main(String arg[]) { int arr[] = { 1, -1, -3, -2, 7, 5, 11, 6 }; int n = arr.length; segregateElements(arr, n); int i = 0; for (; i < n; i++) System.out.print(arr[i] + \" \"); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\nsegregateElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\nint\ntemp[] = \nnew\nint\n[n]; \n\n\n\n\n\n\nint\nj = \n0\n; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] >= \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n\n\n\n\nif\n(j == n || j == \n0\n) \n\nreturn\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < \n0\n) \n\ntemp[j++] = arr[i]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = temp[i]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = { \n1\n, -\n1\n, -\n3\n, -\n2\n, \n7\n, \n5\n, \n11\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nsegregateElements(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 182, "complexity": "1"}
{"forwhile": "class GFG { static void rearrange(int arr[], int n) { int temp; int i = 0; while (i < n - 1) { if (i % 2 == 0 && arr[i] > arr[i + 1]) { temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } if (i % 2 != 0 && arr[i] < arr[i + 1]) { temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } i++; } } static void printArray(int arr[], int size) { int i = 0; for (; i < size; i++) System.out.print(arr[i] + \" \"); System.out.println(); } public static void main(String[] args) { int arr[] = { 6 , 4 , 2 , 1 , 8 , 3 }; int n = arr.length; System.out.print(\"Before rearranging: \\n\"); printArray(arr, n); rearrange(arr, n); System.out.print(\"After rearranging: \\n\"); printArray(arr, n); } }", "src": "class\nGFG { \n\n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\n\nint\ntemp; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) { \n\nif\n(i % \n2\n== \n0\n&& arr[i] > arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\nif\n(i % \n2\n!= \n0\n&& arr[i] < arr[i + \n1\n]) { \n\ntemp = arr[i]; \n\narr[i] = arr[i + \n1\n]; \n\narr[i + \n1\n] = temp; \n\n} \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n6\n, \n4\n, \n2\n, \n1\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.print(\n\"Before rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.print(\n\"After rearranging: \\n\"\n); \n\nprintArray(arr, n); \n\n} \n}", "index": 186, "complexity": "1"}
{"forwhile": "class\nSolution \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode temp = \nnew\nNode(); \n\n\nstatic\nNode newNode(\nint\ndata) \n\n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode leftMostNode(Node node) \n\n{ \n\nNode nodeCopy = node; \n\nfor(; nodeCopy != \nnull\n && nodeCopy.left != \nnull\n; ) \n\nnodeCopy = nodeCopy.left; \n\nreturn\nnodeCopy; \n} \n\n\nstatic\nNode rightMostNode(Node node) \n\n{ \n\nNode nodeCopy = node;\n\nfor(; nodeCopy != \nnull\n && nodeCopy.right != \nnull\n; ) \n\nnodeCopy = nodeCopy.right; \n\nreturn\nnodeCopy; \n} \n\n\n\nstatic\nNode findInorderRecursive(Node root, Node x) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\nnull\n; \n\n\nNode temp;\n\nif\n(root == x || (temp = findInorderRecursive(root.left, x)) != \nnull\n || \n\n(temp = findInorderRecursive(root.right, x)) != \nnull\n) \n\n{ \n\nif\n(temp != \nnull\n) \n\n{ \n\nif\n(root.left == temp) \n\n{ \n\nSystem.out.print(\n\"Inorder Successor of \"+ x.data); \n\nSystem.out.print(\n\" is \"+ root.data + \"\\n\"); \n\nreturn\nnull\n; \n\n} \n\n} \n\n\nreturn\nroot; \n\n} \n\n\nreturn\nnull\n; \n} \n\n\n\nstatic\nvoid\ninorderSuccesor(Node root, Node x) \n\n{ \n\n\n\nif\n(x.right != \nnull\n) \n\n{ \n\nNode inorderSucc = leftMostNode(x.right); \n\nSystem.out.print(\n\"Inorder Successor of \"+ x.data + \n\" is \"); \n\nSystem.out.print(inorderSucc.data + \"\\n\"); \n\n} \n\n\n\n\nif\n(x.right == \nnull\n) \n\n{ \n\nint\nf = 0; \n\n\nNode rightMost = rightMostNode(root); \n\n\n\n\nif\n(rightMost == x) \n\nSystem.out.print(\n\"No inorder successor! Right most node.\\n\"); \n\nelse\nfindInorderRecursive(root, x); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.right.right = newNode(\n6\n); \n\n\n\n\nNode currentNode = root; \nfor(; currentNode.right != \nnull\n; currentNode = currentNode.right) { } \n\ninorderSuccesor(root, currentNode); \n\n\n\n\nNode currentNode2 = root; \nfor(; currentNode2.left != \nnull\n || currentNode2.right != \nnull\n; ) { \n\nif\n(currentNode2.left != \nnull\n) \n\n{ \n\nNode nextNode = currentNode2.left; \n\ninorderSuccesor(root, nextNode); \n\n} \nelse\n{\nNode nextNode = currentNode2.right; \n\ninorderSuccesor(root, nextNode); \n\n} \n\nbreak;\n} \n\n\n\n\nNode currentNode3 = root; \nfor(; currentNode3.left != \nnull\n; currentNode3 = currentNode3.left) { } \n\ninorderSuccesor(root, currentNode3); \n\n} \n}", "src": "class\nSolution \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode temp = \nnew\nNode(); \n\n\nstatic\nNode newNode(\nint\ndata) \n\n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode leftMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.left != \nnull\n) \n\nnode = node.left; \n\nreturn\nnode; \n} \n\n\nstatic\nNode rightMostNode(Node node) \n\n{ \n\nwhile\n(node != \nnull\n&& node.right != \nnull\n) \n\nnode = node.right; \n\nreturn\nnode; \n} \n\n\n\nstatic\nNode findInorderRecursive(Node root, Node x ) \n\n{ \n\nif\n(root==\nnull\n) \n\nreturn\nnull\n; \n\n\nif\n(root==x || (temp = findInorderRecursive(root.left,x))!=\nnull\n|| \n\n(temp = findInorderRecursive(root.right,x))!=\nnull\n) \n\n{ \n\nif\n(temp!=\nnull\n) \n\n{ \n\nif\n(root.left == temp) \n\n{ \n\nSystem.out.print( \n\"Inorder Successor of \"\n+x.data); \n\nSystem.out.print( \n\" is \"\n+ root.data + \n\"\\n\"\n); \n\nreturn\nnull\n; \n\n} \n\n} \n\n\nreturn\nroot; \n\n} \n\n\nreturn\nnull\n; \n} \n\n\n\nstatic\nvoid\ninorderSuccesor(Node root, Node x) \n\n{ \n\n\n\nif\n(x.right != \nnull\n) \n\n{ \n\nNode inorderSucc = leftMostNode(x.right); \n\nSystem.out.print(\n\"Inorder Successor of \"\n+x.data+\n\" is \"\n); \n\nSystem.out.print(inorderSucc.data+\n\"\\n\"\n); \n\n} \n\n\n\n\nif\n(x.right == \nnull\n) \n\n{ \n\nint\nf = \n0\n; \n\n\nNode rightMost = rightMostNode(root); \n\n\n\n\nif\n(rightMost == x) \n\nSystem.out.print(\n\"No inorder successor! Right most node.\\n\"\n); \n\nelse\n\nfindInorderRecursive(root, x); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\n\n\n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nroot.right.right = newNode(\n6\n); \n\n\n\n\ninorderSuccesor(root, root.right); \n\n\n\n\ninorderSuccesor(root, root.left.left); \n\n\n\n\ninorderSuccesor(root, root.right.right); \n\n} \n}", "index": 187, "complexity": "1"}
{"forwhile": "class Node { int data; Node left, right; public Node(int item) { data = item; left = right = null; } } class BinaryTree { static Node root; void printSpiral(Node node) { if(node == null) return; Stack<Node> s1 = new Stack<Node>(); Stack<Node> s2 = new Stack<Node>(); s1.push(node); for(; !s1.empty() || !s2.empty(); ) { for(; !s1.empty(); ) { Node temp = s1.peek(); s1.pop(); System.out.print(temp.data + \" \"); if(temp.right != null) s2.push(temp.right); if(temp.left != null) s2.push(temp.left); } for(; !s2.empty(); ) { Node temp = s2.peek(); s2.pop(); System.out.print(temp.data + \" \"); if(temp.left != null) s1.push(temp.left); if(temp.right != null) s1.push(temp.right); } } } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(7); tree.root.left.right = new Node(6); tree.root.right.left = new Node(5); tree.root.right.right = new Node(4); System.out.println(\"Spiral Order traversal of Binary Tree is \"); tree.printSpiral(root); } }", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\n\n\n\nStack<Node> s1 = \nnew\nStack<Node>(); \n\n\n\nStack<Node> s2 = \nnew\nStack<Node>(); \n\n\n\n\ns1.push(node); \n\n\n\n\nwhile\n(!s1.empty() || !s2.empty()) { \n\n\n\n\n\nwhile\n(!s1.empty()) { \n\nNode temp = s1.peek(); \n\ns1.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n\n\nif\n(temp.right != \nnull\n) \n\ns2.push(temp.right); \n\n\nif\n(temp.left != \nnull\n) \n\ns2.push(temp.left); \n\n} \n\n\n\n\n\n\nwhile\n(!s2.empty()) { \n\nNode temp = s2.peek(); \n\ns2.pop(); \n\nSystem.out.print(temp.data + \n\" \"\n); \n\n\n\n\nif\n(temp.left != \nnull\n) \n\ns1.push(temp.left); \n\nif\n(temp.right != \nnull\n) \n\ns1.push(temp.right); \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral Order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(root); \n\n} \n}", "index": 190, "complexity": "1"}
{"forwhile": "public\nclass\nGFG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n\n\n\n\nstatic\nvoid\nlevelOrder(Node root) { \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\n\n\n\nq.add(root); \n\n\n\n\nq.add(\nnull\n); \n\n\n\n\n\n\nfor(Node curr = q.poll(); curr != \nnull\n;) { \n\n\n\nif\n(curr == \nnull\n) { \n\nif\n(!q.isEmpty()) { \n\nq.add(\nnull\n); \n\nSystem.out.println(); \n\n} \n\n} \nelse\n{ \n\n\n\nif\n(curr.left != \nnull\n) \n\nq.add(curr.left); \n\n\n\n\nif\n(curr.right != \nnull\n) \n\nq.add(curr.right); \n\n\nSystem.out.print(curr.data + \n\" \"\n); \n\n} \n\ncurr = q.poll(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nfor(Queue<Node> q = \nnew\nLinkedList<>(); !q.isEmpty();) { \n\nNode curr = q.poll(); \n\n\n\nif\n(curr == \nnull\n) { \n\nif\n(!q.isEmpty()) { \n\nq.add(\nnull\n); \n\nSystem.out.println(); \n\n} \n\n} \nelse\n{ \n\n\n\nif\n(curr.left != \nnull\n) \n\nq.add(curr.left); \n\n\n\n\nif\n(curr.right != \nnull\n) \n\nq.add(curr.right); \n\n\nSystem.out.print(curr.data + \n\" \"\n); \n\n} \n\n} \n\n} \n\n}", "src": "public\nclass\nGFG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n\n\n\n\nstatic\nvoid\nlevelOrder(Node root) { \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\n\n\n\nq.add(root); \n\n\n\n\nq.add(\nnull\n); \n\n\n\n\n\n\nwhile\n(!q.isEmpty()) { \n\n\nNode curr = q.poll(); \n\n\n\n\n\n\nif\n(curr == \nnull\n) { \n\nif\n(!q.isEmpty()) { \n\nq.add(\nnull\n); \n\nSystem.out.println(); \n\n} \n\n} \nelse\n{ \n\n\n\nif\n(curr.left != \nnull\n) \n\nq.add(curr.left); \n\n\n\n\nif\n(curr.right != \nnull\n) \n\nq.add(curr.right); \n\n\nSystem.out.print(curr.data + \n\" \"\n); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nlevelOrder(root); \n\n} \n}", "index": 191, "complexity": "1"}
{"forwhile": "class Node { int data; Node left, right; Node(int item) { data = item; left = right; } } class BinaryTree { Node root; void reverseLevelOrder(Node node) { Stack<Node> S = new Stack(); Queue<Node> Q = new LinkedList(); Q.add(node); while (Q.isEmpty() == false) { node = Q.peek(); Q.remove(); S.push(node); if (node.right != null) Q.add(node.right); if (node.left != null) Q.add(node.left); } while (S.empty() == false) { node = S.peek(); System.out.print(node.data + \" \"); S.pop(); } } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(4); tree.root.left.right = new Node(5); tree.root.right.left = new Node(6); tree.root.right.right = new Node(7); System.out.println(\"Level Order traversal of binary tree is :\"); tree.reverseLevelOrder(tree.root); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack(); \n\nQueue<Node> Q = \nnew\nLinkedList(); \n\nQ.add(node); \n\n\n\n\n\n\n\n\n\n\nwhile\n(Q.isEmpty() == \nfalse\n) \n\n{ \n\n\n\nnode = Q.peek(); \n\nQ.remove(); \n\nS.push(node); \n\n\n\n\nif\n(node.right != \nnull\n) \n\n\n\nQ.add(node.right); \n\n\n\n\nif\n(node.left != \nnull\n) \n\nQ.add(node.left); \n\n} \n\n\n\n\nwhile\n(S.empty() == \nfalse\n) \n\n{ \n\nnode = S.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nS.pop(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is :\"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n\n} \n}", "index": 192, "complexity": "1"}
{"forwhile": "class Node  { int data; Node left, right; public Node(int item) { data = item; left = right = null; } } class BinaryTree { Node root; void printSpecificLevelOrder(Node node) { if (node == null) return; System.out.print(node.data); if (node.left != null) System.out.print(\" \"+ node.left.data + \" \" + node.right.data); if (node.left.left == null) return; Queue<Node> q = new LinkedList<Node>(); q.add(node.left); q.add(node.right); Node first = null, second = null; for(; !q.isEmpty(); ) { first = q.peek(); q.remove(); second = q.peek(); q.remove(); System.out.print(\" \"+ first.left.data + \" \"+second.right.data); System.out.print(\" \"+ first.right.data + \" \"+second.left.data); if (first.left.left != null) { q.add(first.left); q.add(second.right); q.add(first.right); q.add(second.left); } } } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(4); tree.root.left.right = new Node(5); tree.root.right.left = new Node(6); tree.root.right.right = new Node(7); tree.root.left.left.left = new Node(8); tree.root.left.left.right = new Node(9); tree.root.left.right.left = new Node(10); tree.root.left.right.right = new Node(11); tree.root.right.left.left = new Node(12); tree.root.right.left.right = new Node(13); tree.root.right.right.left = new Node(14); tree.root.right.right.right = new Node(15); tree.root.left.left.left.left = new Node(16); tree.root.left.left.left.right = new Node(17); tree.root.left.left.right.left = new Node(18); tree.root.left.left.right.right = new Node(19); tree.root.left.right.left.left = new Node(20); tree.root.left.right.left.right = new Node(21); tree.root.left.right.right.left = new Node(22); tree.root.left.right.right.right = new Node(23); tree.root.right.left.left.left = new Node(24); tree.root.right.left.left.right = new Node(25); tree.root.right.left.right.left = new Node(26); tree.root.right.left.right.right = new Node(27); tree.root.right.right.left.left = new Node(28); tree.root.right.right.left.right = new Node(29); tree.root.right.right.right.left = new Node(30); tree.root.right.right.right.right = new Node(31); System.out.println(\"Specific Level Order traversal of binary\" + \"tree is \"); tree.printSpecificLevelOrder(tree.root); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nprintSpecificLevelOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nSystem.out.print(node.data); \n\n\n\n\nif\n(node.left != \nnull\n) \n\nSystem.out.print(\n\" \"\n+ node.left.data + \n\" \"\n+ node.right.data); \n\n\n\n\n\n\nif\n(node.left.left == \nnull\n) \n\nreturn\n; \n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\nq.add(node.left); \n\nq.add(node.right); \n\n\n\n\n\n\nNode first = \nnull\n, second = \nnull\n; \n\n\n\n\nwhile\n(!q.isEmpty()) \n\n{ \n\n\n\nfirst = q.peek(); \n\nq.remove(); \n\nsecond = q.peek(); \n\nq.remove(); \n\n\n\n\nSystem.out.print(\n\" \"\n+ first.left.data + \n\" \"\n+second.right.data); \n\nSystem.out.print(\n\" \"\n+ first.right.data + \n\" \"\n+second.left.data); \n\n\n\n\n\n\nif\n(first.left.left != \nnull\n) \n\n{ \n\nq.add(first.left); \n\nq.add(second.right); \n\nq.add(first.right); \n\nq.add(second.left); \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\ntree.root.left.left.left = \nnew\nNode(\n8\n); \n\ntree.root.left.left.right = \nnew\nNode(\n9\n); \n\ntree.root.left.right.left = \nnew\nNode(\n10\n); \n\ntree.root.left.right.right = \nnew\nNode(\n11\n); \n\ntree.root.right.left.left = \nnew\nNode(\n12\n); \n\ntree.root.right.left.right = \nnew\nNode(\n13\n); \n\ntree.root.right.right.left = \nnew\nNode(\n14\n); \n\ntree.root.right.right.right = \nnew\nNode(\n15\n); \n\n\ntree.root.left.left.left.left = \nnew\nNode(\n16\n); \n\ntree.root.left.left.left.right = \nnew\nNode(\n17\n); \n\ntree.root.left.left.right.left = \nnew\nNode(\n18\n); \n\ntree.root.left.left.right.right = \nnew\nNode(\n19\n); \n\ntree.root.left.right.left.left = \nnew\nNode(\n20\n); \n\ntree.root.left.right.left.right = \nnew\nNode(\n21\n); \n\ntree.root.left.right.right.left = \nnew\nNode(\n22\n); \n\ntree.root.left.right.right.right = \nnew\nNode(\n23\n); \n\ntree.root.right.left.left.left = \nnew\nNode(\n24\n); \n\ntree.root.right.left.left.right = \nnew\nNode(\n25\n); \n\ntree.root.right.left.right.left = \nnew\nNode(\n26\n); \n\ntree.root.right.left.right.right = \nnew\nNode(\n27\n); \n\ntree.root.right.right.left.left = \nnew\nNode(\n28\n); \n\ntree.root.right.right.left.right = \nnew\nNode(\n29\n); \n\ntree.root.right.right.right.left = \nnew\nNode(\n30\n); \n\ntree.root.right.right.right.right = \nnew\nNode(\n31\n); \n\n\nSystem.out.println(\n\"Specific Level Order traversal of binary\"\n\n+\n\"tree is \"\n); \n\ntree.printSpecificLevelOrder(tree.root); \n\n} \n}", "index": 193, "complexity": "1"}
{"forwhile": "class\nMultipy \n{ \n\nstatic\nvoid\nmodify(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nif\n(n <= \n1\n) \n\nreturn\n; \n\n\n\n\nint\nprev = arr[\n0\n]; \n\narr[\n0\n] = arr[\n0\n] * arr[\n1\n]; \n\n\n\n\nint\ni=\n1\n; \nwhile(i<n-\n1\n) \n\n{ \n\n\n\nint\ncurr = arr[i]; \n\n\n\n\narr[i] = prev * arr[i+\n1\n]; \n\n\n\n\nprev = curr; \n\ni++; \n} \n\n\n\n\narr[n-\n1\n] = prev * arr[n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nmodify(arr, n); \n\nint\ni=\n0\n; \nfor(; i<n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "src": "class\nMultipy \n{ \n\nstatic\nvoid\nmodify(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nif\n(n <= \n1\n) \n\nreturn\n; \n\n\n\n\nint\nprev = arr[\n0\n]; \n\narr[\n0\n] = arr[\n0\n] * arr[\n1\n]; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<n-\n1\n; i++) \n\n{ \n\n\n\nint\ncurr = arr[i]; \n\n\n\n\narr[i] = prev * arr[i+\n1\n]; \n\n\n\n\nprev = curr; \n\n} \n\n\n\n\narr[n-\n1\n] = prev * arr[n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n3\n, \n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nmodify(arr, n); \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 194, "complexity": "1"}
{"forwhile": "class Node { char data; Node left, right; Node(char item) { data = item; left = right = null; } } class Index { int index; } class BinaryTree { Node root; Index index_obj = new Index(); void storeAlternate(Node node, char arr[], Index index, int l) { if(node == null) { return; } storeAlternate(node.left, arr, index, l + 1); if(l % 2 != 0) { arr[index.index] = node.data; index.index++; } storeAlternate(node.right, arr, index, l + 1); } void modifyTree(Node node, char arr[], Index index, int l) { if(node == null) { return; } modifyTree(node.left, arr, index, l + 1); if(l % 2 != 0) { node.data = arr[index.index]; (index.index)++; } modifyTree(node.right, arr, index, l + 1); } void reverse(char arr[], int n) { int l = 0, r = n - 1; for(; l < r; l++, r--) { char temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; } } void reverseAlternate() { reverseAlternate(root); } void reverseAlternate(Node node) { char[] arr = new char[100]; storeAlternate(node, arr, index_obj, 0); reverse(arr, index_obj.index); index_obj.index = 0; modifyTree(node, arr, index_obj, 0); } void printInorder() { printInorder(root); } void printInorder(Node node) { if(node == null) { return; } printInorder(node.left); System.out.print(node.data + \" \"); printInorder(node.right); } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); tree.root = new Node('a'); tree.root.left = new Node('b'); tree.root.right = new Node('c'); tree.root.left.left = new Node('d'); tree.root.left.right = new Node('e'); tree.root.right.left = new Node('f'); tree.root.right.right = new Node('g'); tree.root.left.left.left = new Node('h'); tree.root.left.left.right = new Node('i'); tree.root.left.right.left = new Node('j'); tree.root.left.right.right = new Node('k'); tree.root.right.left.left = new Node('l'); tree.root.right.left.right = new Node('m'); tree.root.right.right.left = new Node('n'); tree.root.right.right.right = new Node('o'); System.out.println(\"Inorder Traversal of given tree\"); tree.printInorder(); tree.reverseAlternate(); System.out.println(\"\"); System.out.println(\"\"); System.out.println(\"Inorder Traversal of modified tree\"); tree.printInorder(); } }", "src": "class\nNode { \n\n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) { \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\n\nclass\nIndex { \n\n\nint\nindex; \n} \n\nclass\nBinaryTree { \n\n\nNode root; \n\nIndex index_obj = \nnew\nIndex(); \n\n\n\n\nvoid\nstoreAlternate(Node node, \nchar\narr[], Index index, \nint\nl) { \n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\nstoreAlternate(node.left, arr, index, l + \n1\n); \n\n\n\n\nif\n(l % \n2\n!= \n0\n) { \n\narr[index.index] = node.data; \n\nindex.index++; \n\n} \n\n\nstoreAlternate(node.right, arr, index, l + \n1\n); \n\n} \n\n\n\n\n\n\nvoid\nmodifyTree(Node node, \nchar\narr[], Index index, \nint\nl) { \n\n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\n\n\n\nmodifyTree(node.left, arr, index, l + \n1\n); \n\n\n\n\nif\n(l % \n2\n!= \n0\n) { \n\nnode.data = arr[index.index]; \n\n(index.index)++; \n\n} \n\n\n\n\nmodifyTree(node.right, arr, index, l + \n1\n); \n\n} \n\n\n\n\n\n\nvoid\nreverse(\nchar\narr[], \nint\nn) { \n\nint\nl = \n0\n, r = n - \n1\n; \n\nwhile\n(l < r) { \n\nchar\ntemp = arr[l]; \n\narr[l] = arr[r]; \n\narr[r] = temp; \n\nl++; \n\nr--; \n\n} \n\n} \n\n\nvoid\nreverseAlternate() { \n\nreverseAlternate(root); \n\n} \n\n\n\n\nvoid\nreverseAlternate(Node node) { \n\n\n\n\nchar\n[] arr = \nnew\nchar\n[\n100\n]; \n\n\n\n\nstoreAlternate(node, arr, index_obj, \n0\n); \n\n\n\n\n\n\n\nreverse(arr, index_obj.index); \n\n\n\n\nindex_obj.index = \n0\n; \n\nmodifyTree(node, arr, index_obj, \n0\n); \n\n} \n\n\nvoid\nprintInorder() { \n\nprintInorder(root); \n\n} \n\n\n\n\n\n\nvoid\nprintInorder(Node node) { \n\nif\n(node == \nnull\n) { \n\nreturn\n; \n\n} \n\nprintInorder(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n'a'\n); \n\ntree.root.left = \nnew\nNode(\n'b'\n); \n\ntree.root.right = \nnew\nNode(\n'c'\n); \n\ntree.root.left.left = \nnew\nNode(\n'd'\n); \n\ntree.root.left.right = \nnew\nNode(\n'e'\n); \n\ntree.root.right.left = \nnew\nNode(\n'f'\n); \n\ntree.root.right.right = \nnew\nNode(\n'g'\n); \n\ntree.root.left.left.left = \nnew\nNode(\n'h'\n); \n\ntree.root.left.left.right = \nnew\nNode(\n'i'\n); \n\ntree.root.left.right.left = \nnew\nNode(\n'j'\n); \n\ntree.root.left.right.right = \nnew\nNode(\n'k'\n); \n\ntree.root.right.left.left = \nnew\nNode(\n'l'\n); \n\ntree.root.right.left.right = \nnew\nNode(\n'm'\n); \n\ntree.root.right.right.left = \nnew\nNode(\n'n'\n); \n\ntree.root.right.right.right = \nnew\nNode(\n'o'\n); \n\nSystem.out.println(\n\"Inorder Traversal of given tree\"\n); \n\ntree.printInorder(); \n\n\ntree.reverseAlternate(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Inorder Traversal of modified tree\"\n); \n\ntree.printInorder(); \n\n} \n}", "index": 195, "complexity": "1"}
{"forwhile": "class Node { int data; Node left, right; Node(int item) { data = item; left = right; } } class BinaryTree { Node root; ArrayList<Integer> list = new ArrayList<Integer>(); ArrayList<Integer> postOrderIterative(Node node) { Stack<Node> S = new Stack<Node>(); if(node == null) return list; S.push(node); Node prev = null; for(; !S.isEmpty(); ) { Node current = S.peek(); if(prev == null || prev.left == current || prev.right == current) { if(current.left != null) S.push(current.left); else if(current.right != null) S.push(current.right); else { S.pop(); list.add(current.data); } } else if(current.left == prev) { if(current.right != null) S.push(current.right); else { S.pop(); list.add(current.data); } } else if(current.right == prev) { S.pop(); list.add(current.data); } prev = current; } return list; } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(4); tree.root.left.right = new Node(5); tree.root.right.left = new Node(6); tree.root.right.right = new Node(7); ArrayList<Integer> mylist = tree.postOrderIterative(tree.root); System.out.println(\"Post order traversal of binary tree is :\"); System.out.println(mylist); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\nArrayList<Integer> list = \nnew\nArrayList<Integer>(); \n\n\n\n\n\n\nArrayList<Integer> postOrderIterative(Node node) \n\n{ \n\nStack<Node> S = \nnew\nStack<Node>(); \n\n\n\n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\nS.push(node); \n\nNode prev = \nnull\n; \n\nwhile\n(!S.isEmpty()) \n\n{ \n\nNode current = S.peek(); \n\n\n\n\nif\n(prev == \nnull\n|| prev.left == current || \n\nprev.right == current) \n\n{ \n\nif\n(current.left != \nnull\n) \n\nS.push(current.left); \n\nelse\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n\n\n} \n\nelse\nif\n(current.left == prev) \n\n{ \n\nif\n(current.right != \nnull\n) \n\nS.push(current.right); \n\nelse\n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\n\n\n} \n\nelse\nif\n(current.right == prev) \n\n{ \n\nS.pop(); \n\nlist.add(current.data); \n\n} \n\n\nprev = current; \n\n} \n\n\nreturn\nlist; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\ntree.root.right.left = \nnew\nNode(\n6\n); \n\ntree.root.right.right = \nnew\nNode(\n7\n); \n\n\nArrayList<Integer> mylist = tree.postOrderIterative(tree.root); \n\n\nSystem.out.println(\n\"Post order traversal of binary tree is :\"\n); \n\nSystem.out.println(mylist); \n\n} \n}", "index": 197, "complexity": "1"}
{"forwhile": "class\nListNode \n{ \n\nint\ndata; \n\nListNode next; \n\nListNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n} \n\n\nclass\nBinaryTreeNode \n{ \n\nint\ndata; \n\nBinaryTreeNode left, right = \nnull\n; \n\nBinaryTreeNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nListNode head; \n\nBinaryTreeNode root; \n\n\n\n\n\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\nListNode new_node = \nnew\nListNode(new_data); \n\n\n\n\nnew_node.next = head; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\n\n\n\n\nBinaryTreeNode convertList2Binary(BinaryTreeNode node) \n\n{ \n\n\n\nQueue<BinaryTreeNode> q = \n\nnew\nLinkedList<BinaryTreeNode>(); \n\n\n\n\nif\n(head == \nnull\n) \n\n{ \n\nnode = \nnull\n; \n\nreturn\nnull\n; \n\n} \n\n\n\n\n\n\nnode = \nnew\nBinaryTreeNode(head.data); \n\nq.add(node); \n\n\n\n\nhead = head.next; \n\n\n\n\n\n\nwhile(head != \nnull\n) \n\n{ \n\n\n\n\n\nBinaryTreeNode parent = q.peek(); \n\nBinaryTreeNode pp = q.poll(); \n\n\n\n\n\n\n\n\n\n\n\n\nBinaryTreeNode leftChild = \nnull\n, rightChild = \nnull\n; \n\nleftChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(leftChild); \n\nhead = head.next; \n\nif(head != \nnull\n) \n\n{ \n\nrightChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(rightChild); \n\nhead = head.next; \n\n} \n\n\n\n\n\n\nparent.left = leftChild; \n\nparent.right = rightChild; \n\n} \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\nvoid\ninorderTraversal(BinaryTreeNode node) \n\n{ \n\nif\n(node != \nnull\n) \n\n{ \n\ninorderTraversal(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderTraversal(node.right); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.push(\n36\n); \n\ntree.push(\n30\n); \n\ntree.push(\n25\n); \n\ntree.push(\n15\n); \n\ntree.push(\n12\n); \n\ntree.push(\n10\n); \n\n\nBinaryTreeNode node = tree.convertList2Binary(tree.root); \n\n\nSystem.out.println(\n\"Inorder Traversal of the\"\n+ \n\n\" constructed Binary Tree is:\" \n); \n\ntree.inorderTraversal(node); \n\n} \n}", "src": "class\nListNode \n{ \n\nint\ndata; \n\nListNode next; \n\nListNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n} \n\n\nclass\nBinaryTreeNode \n{ \n\nint\ndata; \n\nBinaryTreeNode left, right = \nnull\n; \n\nBinaryTreeNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nListNode head; \n\nBinaryTreeNode root; \n\n\n\n\n\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\nListNode new_node = \nnew\nListNode(new_data); \n\n\n\n\nnew_node.next = head; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\n\n\n\n\nBinaryTreeNode convertList2Binary(BinaryTreeNode node) \n\n{ \n\n\n\nQueue<BinaryTreeNode> q = \n\nnew\nLinkedList<BinaryTreeNode>(); \n\n\n\n\nif\n(head == \nnull\n) \n\n{ \n\nnode = \nnull\n; \n\nreturn\nnull\n; \n\n} \n\n\n\n\n\n\nnode = \nnew\nBinaryTreeNode(head.data); \n\nq.add(node); \n\n\n\n\nhead = head.next; \n\n\n\n\n\n\nwhile\n(head != \nnull\n) \n\n{ \n\n\n\n\n\nBinaryTreeNode parent = q.peek(); \n\nBinaryTreeNode pp = q.poll(); \n\n\n\n\n\n\n\n\n\n\n\n\nBinaryTreeNode leftChild = \nnull\n, rightChild = \nnull\n; \n\nleftChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(leftChild); \n\nhead = head.next; \n\nif\n(head != \nnull\n) \n\n{ \n\nrightChild = \nnew\nBinaryTreeNode(head.data); \n\nq.add(rightChild); \n\nhead = head.next; \n\n} \n\n\n\n\n\n\nparent.left = leftChild; \n\nparent.right = rightChild; \n\n} \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\nvoid\ninorderTraversal(BinaryTreeNode node) \n\n{ \n\nif\n(node != \nnull\n) \n\n{ \n\ninorderTraversal(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderTraversal(node.right); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.push(\n36\n); \n\n\ntree.push(\n30\n); \n\ntree.push(\n25\n); \n\ntree.push(\n15\n); \n\ntree.push(\n12\n); \n\ntree.push(\n10\n); \n\n\nBinaryTreeNode node = tree.convertList2Binary(tree.root); \n\n\nSystem.out.println(\n\"Inorder Traversal of the\"\n+ \n\n\" constructed Binary Tree is:\"\n); \n\ntree.inorderTraversal(node); \n\n} \n}", "index": 199, "complexity": "1"}
{"forwhile": "class PairInSortedRotated  { static boolean pairInSortedRotated( int arr[],  int n, int x) { int i = 0; while(i < n - 1) { if(arr[i] > arr[i+1]) break; i++; } int l = (i + 1) % n;  int r = i;  for(; l != r;) { if(arr[l] + arr[r] == x) return true; if(arr[l] + arr[r] < x) l = (l + 1) % n; else r = (n + r - 1) % n; } return false; } public static void main (String[] args) { int arr[] = { 11 , 15 , 6 , 8 , 9 , 10 };  int sum = 16;  int n = arr.length; if(pairInSortedRotated(arr, n, sum)) System.out.print(\"Array has two elements\"+ \" with sum 16\"); else System.out.print(\"Array doesn't have two\"+ \" elements with sum 16 \"); } }", "src": "class\nPairInSortedRotated \n{ \n\n\n\n\n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n\n\n\n\n\nint\nr = i; \n\n\n\n\n\n\n\nwhile\n(l != r) \n\n{ \n\n\n\n\n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n\n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n}", "index": 201, "complexity": "1"}
{"forwhile": "public class BinaryTreeToDLL { static class node { int data; node left, right; public node(int data) { this.data = data; }} static node prev; static void fixPrevptr(node root) { if(root == null) return; node current = root; while(current != null) { current = current.left; } } static node fixNextptr(node root) { while(root.right != null) { root = root.right; } while(root != null && root.left != null) { node left = root.left; left.right = root; root = root.left; } return root; } static node BTTtoDLL(node root) { prev = null; fixPrevptr(root); return fixNextptr(root); } static void printlist(node root) { for(; root != null; root = root.right) { System.out.print(root.data + \" \"); } } static void inorder(node root) { if(root == null) return; inorder(root.left); System.out.print(root.data + \" \"); inorder(root.right); } public static void main(String[] args) { node root = new node(10); root.left = new node(12); root.right = new node(15); root.left.left = new node(25); root.left.right = new node(30); root.right.left = new node(36); System.out.println(\"Inorder Tree Traversal\"); inorder(root); node head = BTTtoDLL(root); System.out.println(\"\\nDLL Traversal\"); printlist(head); } }", "src": "public\nclass\nBinaryTreeToDLL \n{ \n\nstatic\nclass\nnode \n\n{ \n\nint\ndata; \n\nnode left, right; \n\n\npublic\nnode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\n} \n\n} \n\n\nstatic\nnode prev; \n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nfixPrevptr(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\nfixPrevptr(root.left); \n\nroot.left = prev; \n\nprev = root; \n\nfixPrevptr(root.right); \n\n\n} \n\n\n\n\n\n\nstatic\nnode fixNextptr(node root) \n\n{ \n\n\n\n\n\nwhile\n(root.right != \nnull\n) \n\nroot = root.right; \n\n\n\n\n\n\n\n\nwhile\n(root != \nnull\n&& root.left != \nnull\n) \n\n{ \n\nnode left = root.left; \n\nleft.right = root; \n\nroot = root.left; \n\n} \n\n\n\n\nreturn\nroot; \n\n} \n\n\nstatic\nnode BTTtoDLL(node root) \n\n{ \n\nprev = \nnull\n; \n\n\n\n\nfixPrevptr(root); \n\n\n\n\nreturn\nfixNextptr(root); \n\n} \n\n\n\n\nstatic\nvoid\nprintlist(node root) \n\n{ \n\nwhile\n(root != \nnull\n) \n\n{ \n\nSystem.out.print(root.data + \n\" \"\n); \n\nroot = root.right; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\ninorder(node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\n; \n\ninorder(root.left); \n\nSystem.out.print(root.data + \n\" \"\n); \n\ninorder(root.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nnode root = \nnew\nnode(\n10\n); \n\nroot.left = \nnew\nnode(\n12\n); \n\nroot.right = \nnew\nnode(\n15\n); \n\nroot.left.left = \nnew\nnode(\n25\n); \n\nroot.left.right = \nnew\nnode(\n30\n); \n\nroot.right.left = \nnew\nnode(\n36\n); \n\n\nSystem.out.println(\n\"Inorder Tree Traversal\"\n); \n\ninorder(root); \n\n\nnode head = BTTtoDLL(root); \n\n\nSystem.out.println(\n\"\\nDLL Traversal\"\n); \n\nprintlist(head); \n\n} \n}", "index": 203, "complexity": "1"}
{"forwhile": "class Node { int data; Node left, right; public Node(int data) { this.data = data; left = right = null; } } class BinaryTree { Node root; Node head; static Node prev = null; void BinaryTree2DoubleLinkedList(Node root) { if (root == null) return; BinaryTree2DoubleLinkedList(root.right); if (prev == null) head = root; else { root.right = prev; prev.left = root; } prev = root; BinaryTree2DoubleLinkedList(root.left); } void printList(Node node) { for(; node != null; node = node.right) { System.out.print(node.data + ", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nNode head; \n\n\n\n\n\n\n\n\nstatic\nNode prev = \nnull\n; \n\n\n\n\n\n\n\n\nvoid\nBinaryTree2DoubleLinkedList(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\nBinaryTree2DoubleLinkedList(root.left); \n\n\n\n\nif\n(prev == \nnull\n) \n\nhead = root; \n\nelse\n\n{ \n\nroot.left = prev; \n\nprev.right = root; \n\n} \n\nprev = root; \n\n\n\n\nBinaryTree2DoubleLinkedList(root.right); \n\n} \n\n\n\n\nvoid\nprintList(Node node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.right; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n10\n); \n\ntree.root.left = \nnew\nNode(\n12\n); \n\ntree.root.right = \nnew\nNode(\n15\n); \n\ntree.root.left.left = \nnew\nNode(\n25\n); \n\ntree.root.left.right = \nnew\nNode(\n30\n); \n\ntree.root.right.left = \nnew\nNode(\n36\n); \n\n\n\n\ntree.BinaryTree2DoubleLinkedList(tree.root); \n\n\n\n\ntree.printList(tree.head); \n\n\n} \n}", "index": 204, "complexity": "1"}
{"forwhile": "class Node  { int data; Node left, right; public Node(int data) { this.data = data; left = right = null; } } class BinaryTree { Node root; Node head; void BToDLL(Node root) { if (root == null) return; while (root.right != null) { root = root.right; } BToDLL(root.right); root.right = head; if (head != null) { (head).left = root; } head = root; BToDLL(root.left); } void printList(Node head) { System.out.println(\\", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\n\n\nNode root; \n\n\n\n\n\n\nNode head; \n\n\n\n\n\n\nvoid\nBToDLL(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\n; \n\n\n\n\nBToDLL(root.right); \n\n\n\n\nroot.right = head; \n\n\n\n\nif\n(head != \nnull\n) \n\n(head).left = root; \n\n\n\n\nhead = root; \n\n\n\n\nBToDLL(root.left); \n\n} \n\n\n\n\nvoid\nprintList(Node head) \n\n{ \n\nSystem.out.println(\n\"Extracted Double Linked List is : \"\n); \n\nwhile\n(head != \nnull\n) \n\n{ \n\nSystem.out.print(head.data + \n\" \"\n); \n\nhead = head.right; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n5\n); \n\ntree.root.left = \nnew\nNode(\n3\n); \n\ntree.root.right = \nnew\nNode(\n6\n); \n\ntree.root.left.right = \nnew\nNode(\n4\n); \n\ntree.root.left.left = \nnew\nNode(\n1\n); \n\ntree.root.right.right = \nnew\nNode(\n8\n); \n\ntree.root.left.left.right = \nnew\nNode(\n2\n); \n\ntree.root.left.left.left = \nnew\nNode(\n0\n); \n\ntree.root.right.right.left = \nnew\nNode(\n7\n); \n\ntree.root.right.right.right = \nnew\nNode(\n9\n); \n\n\ntree.BToDLL(tree.root); \n\ntree.printList(tree.head); \n\n} \n}", "index": 205, "complexity": "1"}
{"forwhile": "class GFG { static int N = 12, ans; static Vector<Vector<Integer>> tree= new Vector<Vector<Integer>>(); static int dfs(int visit[], int node) { int num = 0, temp = 0; visit[node] = 1; int i = 0; while(i < tree.get(node).size()) { if(visit[tree.get(node).get(i)] == 0) { temp = dfs( visit, tree.get(node).get(i)); if(temp%2 != 0) num += temp; else ans++; } i++; } return num + 1; } static int minEdge(int n) { int visit[] = new int[n + 2]; ans = 0; dfs(visit, 1); return ans; } public static void main(String args[]) { int n = 10; int i = 0; while(i < n + 2) { tree.add(new Vector<Integer>()); i++; } tree.get(1).add(3); tree.get(3).add(1); tree.get(1).add(6); tree.get(6).add(1); tree.get(1).add(2); tree.get(2).add(1); tree.get(3).add(4); tree.get(4).add(3); tree.get(6).add(8); tree.get(8).add(6); tree.get(2).add(7); tree.get(7).add(2); tree.get(2).add(5); tree.get(5).add(2); tree.get(4).add(9); tree.get(9).add(4); tree.get(4).add(10); tree.get(10).add(4); System.out.println(minEdge(n)); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nN = \n12\n,ans; \n\n\nstatic\nVector<Vector<Integer>> tree=\nnew\nVector<Vector<Integer>>(); \n\n\n\n\n\n\nstatic\nint\ndfs( \nint\nvisit[], \nint\nnode) \n\n{ \n\nint\nnum = \n0\n, temp = \n0\n; \n\n\n\n\nvisit[node] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < tree.get(node).size(); i++) \n\n{ \n\nif\n(visit[tree.get(node).get(i)] == \n0\n) \n\n{ \n\n\n\n\n\ntemp = dfs( visit, tree.get(node).get(i)); \n\n\n\n\n\n\n\n\nif\n(temp%\n2\n!=\n0\n) \n\nnum += temp; \n\nelse\n\nans++; \n\n} \n\n} \n\n\nreturn\nnum+\n1\n; \n\n} \n\n\n\n\n\n\nstatic\nint\nminEdge( \nint\nn) \n\n{ \n\nint\nvisit[] = \nnew\nint\n[n+\n2\n]; \n\nans = \n0\n; \n\n\ndfs( visit, \n1\n); \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n + \n2\n;i++) \n\ntree.add(\nnew\nVector<Integer>()); \n\n\ntree.get(\n1\n).add(\n3\n); \n\ntree.get(\n3\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n6\n); \n\ntree.get(\n6\n).add(\n1\n); \n\n\ntree.get(\n1\n).add(\n2\n); \n\ntree.get(\n2\n).add(\n1\n); \n\n\ntree.get(\n3\n).add(\n4\n); \n\ntree.get(\n4\n).add(\n3\n); \n\n\ntree.get(\n6\n).add(\n8\n); \n\ntree.get(\n8\n).add(\n6\n); \n\n\ntree.get(\n2\n).add(\n7\n); \n\ntree.get(\n7\n).add(\n2\n); \n\n\ntree.get(\n2\n).add(\n5\n); \n\ntree.get(\n5\n).add(\n2\n); \n\n\ntree.get(\n4\n).add(\n9\n); \n\ntree.get(\n9\n).add(\n4\n); \n\n\ntree.get(\n4\n).add(\n10\n); \n\ntree.get(\n10\n).add(\n4\n); \n\n\nSystem.out.println( minEdge( n)); \n\n} \n}", "index": 209, "complexity": "1"}
{"forwhile": "public\n\n\nclass\nFlipTree { \n\n\n\n\npublic\nstatic\nNode flipBinaryTree(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\nroot; \n\nif\n(root.left == \nnull\n&& root.right ==\nnull\n) \n\nreturn\nroot; \n\n\n\n\nNode flippedRoot=flipBinaryTree(root.left); \n\n\n\n\n\n\nroot.left.left=root.right; \n\nroot.left.right=root; \n\nroot.left=root.right=\nnull\n; \n\nreturn\nflippedRoot; \n\n} \n\n\n\n\n\n\npublic\nstatic\nvoid\nprintLevelOrder(Node root) \n\n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nQueue<Node> q=\nnew\nLinkedList<>(); \n\n\n\nq.add(root); \n\nfor(; \ntrue\n;) \n\n{ \n\n\n\n\n\nint\nnodeCount = q.size(); \n\nfor(; nodeCount == \n0\n;) \n\nbreak\n; \n\n\n\n\n\n\nfor(; nodeCount > \n0\n;) \n\n{ \n\nNode node = q.remove(); \n\nSystem.out.print(node.data+\n\" \"\n); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left=\nnew\nNode(\n2\n); \n\nroot.right=\nnew\nNode(\n1\n); \n\nroot.right.left = \nnew\nNode(\n4\n); \n\nroot.right.right = \nnew\nNode(\n5\n); \n\nSystem.out.println(\n\"Level order traversal of given tree\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\nSystem.out.println(\n\"Level order traversal of flipped tree\"\n); \n\nprintLevelOrder(root); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\n} \n};", "src": "public\nclass\nFlipTree { \n\n\n\n\npublic\nstatic\nNode flipBinaryTree(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\nroot; \n\nif\n(root.left == \nnull\n&& root.right ==\nnull\n) \n\nreturn\nroot; \n\n\n\n\nNode flippedRoot=flipBinaryTree(root.left); \n\n\n\n\n\n\nroot.left.left=root.right; \n\nroot.left.right=root; \n\nroot.left=root.right=\nnull\n; \n\nreturn\nflippedRoot; \n\n} \n\n\n\n\n\n\npublic\nstatic\nvoid\nprintLevelOrder(Node root) \n\n{ \n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nQueue<Node> q=\nnew\nLinkedList<>(); \n\n\n\nq.add(root); \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.remove(); \n\nSystem.out.print(node.data+\n\" \"\n); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left=\nnew\nNode(\n2\n); \n\nroot.right=\nnew\nNode(\n1\n); \n\nroot.right.left = \nnew\nNode(\n4\n); \n\nroot.right.right = \nnew\nNode(\n5\n); \n\nSystem.out.println(\n\"Level order traversal of given tree\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\nSystem.out.println(\n\"Level order traversal of flipped tree\"\n); \n\nprintLevelOrder(root); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\n} \n};", "index": 211, "complexity": "1"}
{"forwhile": "class GFG  { static class Node { int data; Node left, right; }; static Node newNode( int data) { Node temp = new Node(); temp.data = data; temp.left = temp.right = null ; return temp; } static Node flipBinaryTree(Node root) { Node curr = root; Node next = null ; Node temp = null ; Node prev = null ; for(curr = root; curr != null ; ) { next = curr.left; curr.left = temp; temp = curr.right; curr.right = prev; prev = curr; curr = next; } return prev; } static void printLevelOrder(Node root) { if(root == null) return ; Queue<Node> q = new LinkedList<Node>(); q.add(root); for(; true ; ) { int nodeCount = q.size(); if(nodeCount == 0 ) break ; for(; nodeCount > 0 ; ) { Node node = q.peek(); System.out.print(node.data + \" \"); q.remove(); if(node.left != null) q.add(node.left); if(node.right != null) q.add(node.right); nodeCount--; } System.out.println(); } } public static void main(String args[]) { Node root = newNode( 1 ); root.left = newNode( 2 ); root.right = newNode( 3 ); root.right.left = newNode( 4 ); root.right.right = newNode( 5 ); System.out.print( \"Level order traversal \" + \"of given tree\\n\"); printLevelOrder(root); root = flipBinaryTree(root); System.out.print(\"\\nLevel order traversal \" + \"of the flipped tree\\n\"); printLevelOrder(root); } }", "src": "class\nGFG \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n\n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode flipBinaryTree(Node root) \n{ \n\n\n\nNode curr = root; \n\nNode next = \nnull\n; \n\nNode temp = \nnull\n; \n\nNode prev = \nnull\n; \n\n\n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\nnext = curr.left; \n\n\n\n\n\n\n\n\n\n\n\n\n\ncurr.left = temp; \n\n\n\n\ntemp = curr.right; \n\n\n\n\n\n\ncurr.right = prev; \n\n\nprev = curr; \n\ncurr = next; \n\n} \n\nreturn\nprev; \n} \n\n\n\n\nstatic\nvoid\nprintLevelOrder(Node root) \n{ \n\n\n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node>(); \n\n\n\n\n\n\nq.add(root); \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\nSystem.out.println(); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n4\n); \n\nroot.right.right = newNode(\n5\n); \n\n\nSystem.out.print(\n\"Level order traversal \"\n+ \n\n\"of given tree\\n\"\n); \n\nprintLevelOrder(root); \n\n\nroot = flipBinaryTree(root); \n\n\nSystem.out.print(\n\"\\nLevel order traversal \"\n+ \n\n\"of the flipped tree\\n\"\n); \n\nprintLevelOrder(root); \n} \n}", "index": 212, "complexity": "1"}
{"forwhile": "class Node { int data; Node left, right; Node(int key) { int data = key; left = right = null; } } class GFG { static boolean checkLevelLeafNode(Node root) { if(root == null) return true; Queue<Node> q = new LinkedList<>(); q.add(root); int result = Integer.MAX_VALUE; int level = 0; for(; q.size() != 0;) { int size = q.size(); level++; for(; size > 0;) { Node temp = q.remove(); if(temp.left != null) { q.add(temp.left); if(temp.left.left == null && temp.left.right == null) { if(result == Integer.MAX_VALUE) result = level; else if(result != level) return false; } } if(temp.right != null) { q.add(temp.right); if(temp.right.left == null && temp.right.right == null) { if(result == Integer.MAX_VALUE) result = level; else if(result != level) return false; } } size--; } } return true; } public static void main(String args[]) { Node root = new Node(1); root.left = new Node(2); root.right = new Node(3); root.left.right = new Node(4); root.right.left = new Node(5); root.right.right = new Node(6); boolean result = checkLevelLeafNode(root); for(; result == true;) { System.out.println(\"All leaf nodes are at same level\"); } if(result != true) System.out.println(\"Leaf nodes not at same level\"); } }", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n\n\nNode(\nint\nkey) { \n\nint\ndata = key; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nGFG { \n\n\n\n\n\n\nstatic\nboolean\ncheckLevelLeafNode(Node root) \n\n{ \n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<>(); \n\nq.add(root); \n\n\nint\nresult = Integer.MAX_VALUE; \n\nint\nlevel = \n0\n; \n\n\n\n\nwhile\n(q.size() != \n0\n) { \n\nint\nsize = q.size(); \n\nlevel++; \n\n\n\n\nwhile\n(size > \n0\n) { \n\nNode temp = q.remove(); \n\n\n\n\nif\n(temp.left != \nnull\n) { \n\nq.add(temp.left); \n\n\n\n\nif\n(temp.left.left == \nnull\n&& temp.left.right == \nnull\n) { \n\n\n\n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n\n\n\n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n\n\nif\n(temp.right != \nnull\n) { \n\nq.add(temp.right); \n\n\n\n\nif\n(temp.right.left == \nnull\n&& temp.right.right == \nnull\n) { \n\n\n\n\nif\n(result == Integer.MAX_VALUE) \n\nresult = level; \n\n\n\n\n\n\nelse\nif\n(result != level) \n\nreturn\nfalse\n; \n\n} \n\n} \n\nsize--; \n\n} \n\n\n} \n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.right = \nnew\nNode(\n4\n); \n\nroot.right.left = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nboolean\nresult = checkLevelLeafNode(root); \n\nif\n(result == \ntrue\n) \n\nSystem.out.println(\n\"All leaf nodes are at same level\"\n); \n\nelse\n\nSystem.out.println(\n\"Leaf nodes not at same level\"\n); \n\n} \n}", "index": 217, "complexity": "1"}
{"forwhile": "class GfG { static class Node { int key; Node left, right; } static int findADepth(Node node) { int d = 0; for(; node != null; node = node.left) { d++; } return d; } static boolean isPerfectRec(Node root, int d, int level) { if(root == null) return true; if(root.left == null && root.right == null) return (d == level+1); if(root.left == null || root.right == null) return false; return isPerfectRec(root.left, d, level+1) && isPerfectRec(root.right, d, level+1); } static boolean isPerfect(Node root) { int d = findADepth(root); return isPerfectRec(root, d, 0); } static Node newNode(int k) { Node node = new Node(); node.key = k; node.right = null; node.left = null; return node; } public static void main(String args[]) { Node root = null; root = newNode(10); root.left = newNode(20); root.right = newNode(30); root.left.left = newNode(40); root.left.right = newNode(50); root.right.left = newNode(60); root.right.right = newNode(70); for(; isPerfect(root) == true;) { System.out.println(\"Yes\"); break; } for(; !(isPerfect(root) == true);) { System.out.println(\"No\"); break; } } }", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n} \n\n\nstatic\nint\nfindADepth(Node node) \n{ \nint\nd = \n0\n; \nwhile\n(node != \nnull\n) \n{ \n\nd++; \n\nnode = node.left; \n} \nreturn\nd; \n} \n\n\nstatic\nboolean\nisPerfectRec(Node root, \nint\nd, \nint\nlevel) \n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(root.left == \nnull\n&& root.right == \nnull\n) \n\nreturn\n(d == level+\n1\n); \n\n\n\n\nif\n(root.left == \nnull\n|| root.right == \nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\nreturn\nisPerfectRec(root.left, d, level+\n1\n) && isPerfectRec(root.right, d, level+\n1\n); \n} \n\n\nstatic\nboolean\nisPerfect(Node root) \n{ \nint\nd = findADepth(root); \nreturn\nisPerfectRec(root, d, \n0\n); \n} \n\n\nstatic\nNode newNode(\nint\nk) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.key = k; \n\nnode.right = \nnull\n; \n\nnode.left = \nnull\n; \n\nreturn\nnode; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nNode root = \nnull\n; \n\nroot = newNode(\n10\n); \n\nroot.left = newNode(\n20\n); \n\nroot.right = newNode(\n30\n); \n\n\nroot.left.left = newNode(\n40\n); \n\nroot.left.right = newNode(\n50\n); \n\nroot.right.left = newNode(\n60\n); \n\nroot.right.right = newNode(\n70\n); \n\n\nif\n(isPerfect(root) == \ntrue\n) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n} \n}", "index": 219, "complexity": "1"}
{"forwhile": "public\\nclass\\nCompleteBTree \\n{ \\n\\n\\n\\nstatic\\nclass\\nNode \\n\\n{ \\n\\nint\\ndata; \\n\\nNode left; \\n\\nNode right; \\n\\n\\n\\n\\nNode(\\nint\\nd) \\n\\n{ \\n\\ndata = d; \\n\\nleft = \\nnull\\; \\n\\nright = \\nnull\\; \\n\\n} \\n\\n} \\n\\n\\n\\nstatic\\nboolean\\nisCompleteBT(Node root) \\n\\n{ \\n\\n\\n\\nif\\n(root == \\nnull\\) \\n\\nreturn\\ntrue\\; \\n\\n\\n\\n\\n\\nQueue<Node> queue =\\nnew\\nLinkedList<>(); \\n\\n\\n\\n\\n\\n\\n\\nboolean\\nflag = \\nfalse\\; \\n\\n\\n\\n\\n\\nqueue.add(root); \\n\\nfor(; !queue.isEmpty(); ) \\n\\n{ \\n\\nNode temp_node = queue.remove(); \\n\\n\\n\\nif\\n(temp_node.left != \\nnull\\) \\n\\n{ \\n\\n\\n\\n\\n\\nif\\n(flag == \\ntrue\\) \\n\\nreturn\\nfalse\\; \\n\\n\\n\\n\\n\\nqueue.add(temp_node.left); \\n\\n} \\n\\n\\n\\nelse\\n\\nflag = \\ntrue\\; \\n\\n\\n\\nif\\n(temp_node.right != \\nnull\\) \\n\\n{ \\n\\n\\n\\n\\n\\nif\\n(flag == \\ntrue\\) \\n\\nreturn\\nfalse\\; \\n\\n\\n\\n\\n\\nqueue.add(temp_node.right); \\n\\n\\n} \\n\\n\\n\\nelse\\n\\nflag = \\ntrue\\; \\n\\n} \\n\\n\\n\\nreturn\\ntrue\\; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\n\\n\\n\\nNode root = \\nnew\\nNode(\\n1\\); \\n\\nroot.left = \\nnew\\nNode(\\n2\\); \\n\\nroot.right = \\nnew\\nNode(\\n3\\); \\n\\nroot.left.left = \\nnew\\nNode(\\n4\\); \\n\\nroot.left.right = \\nnew\\nNode(\\n5\\); \\n\\nroot.right.right = \\nnew\\nNode(\\n6\\); \\n\\n\\nfor(; isCompleteBT(root) == \\ntrue\\; ) \\n\\nSystem.out.println(\\n\"Complete Binary Tree\"\\); \\n\\nelse\\n\\nSystem.out.println(\\n\"NOT Complete Binary Tree\"\\); \\n\\n} \\n\\n}", "src": "public\nclass\nCompleteBTree \n{ \n\n\n\nstatic\nclass\nNode \n\n{ \n\nint\ndata; \n\nNode left; \n\nNode right; \n\n\n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\n\n\nstatic\nboolean\nisCompleteBT(Node root) \n\n{ \n\n\n\nif\n(root == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<Node> queue =\nnew\nLinkedList<>(); \n\n\n\n\n\n\nboolean\nflag = \nfalse\n; \n\n\n\n\nqueue.add(root); \n\nwhile\n(!queue.isEmpty()) \n\n{ \n\nNode temp_node = queue.remove(); \n\n\n\n\nif\n(temp_node.left != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n\n\nqueue.add(temp_node.left); \n\n} \n\n\n\nelse\n\nflag = \ntrue\n; \n\n\n\n\nif\n(temp_node.right != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(flag == \ntrue\n) \n\nreturn\nfalse\n; \n\n\n\n\nqueue.add(temp_node.right); \n\n\n} \n\n\n\nelse\n\nflag = \ntrue\n; \n\n} \n\n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\n\nNode root = \nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.right = \nnew\nNode(\n6\n); \n\n\nif\n(isCompleteBT(root) == \ntrue\n) \n\nSystem.out.println(\n\"Complete Binary Tree\"\n); \n\nelse\n\nSystem.out.println(\n\"NOT Complete Binary Tree\"\n); \n\n} \n\n}", "index": 221, "complexity": "1"}
{"forwhile": "class Node { char data; Node left, right; Node(char item) { data = item; left = right = null; } } class Passing { int i; int m = 0; int n = 0; } class BinaryTree { static Node root; Passing p = new Passing(); String strstr(String haystack, String needle) { if (haystack == null || needle == null) { return null; } int hLength = haystack.length(); int nLength = needle.length(); if (hLength < nLength) { return null; } if (nLength == 0) { return haystack; } int i = 0; while (i <= hLength - nLength) { if (haystack.charAt(i) == needle.charAt(0)) { int j = 0; for (; j < nLength; j++) { if (haystack.charAt(i + j) != needle.charAt(j)) { break; } } if (j == nLength) { return haystack.substring(i); } } i++; } return null; } void storeInorder(Node node, char arr[], Passing i) { if (node == null) { arr[i.i++] = '$'; return; } storeInorder(node.left, arr, i); arr[i.i++] = node.data; storeInorder(node.right, arr, i); } void storePreOrder(Node node, char arr[], Passing i) { if (node == null) { arr[i.i++] = '$'; return; } arr[i.i++] = node.data; storePreOrder(node.left, arr, i); storePreOrder(node.right, arr, i); } boolean isSubtree(Node T, Node S) { if (S == null) { return true; } if (T == null) { return false; } char inT[] = new char[100]; String op1 = String.valueOf(inT); char inS[] = new char[100]; String op2 = String.valueOf(inS); storeInorder(T, inT, p); storeInorder(S, inS, p); inT[p.m] = '\\0'; inS[p.m] = '\\0'; if (strstr(op1, op2) != null) { return false; } p.m = 0; p.n = 0; char preT[] = new char[100]; char preS[] = new char[100]; String op3 = String.valueOf(preT); String op4 = String.valueOf(preS); storePreOrder(T, preT, p); storePreOrder(S, preS, p); preT[p.m] = '\\0'; preS[p.n] = '\\0'; return (strstr(op3, op4) != null); } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); Node T = new Node('a'); T.left = new Node('b'); T.right = new Node('d'); T.left.left = new Node('c'); T.right.right = new Node('e'); Node S = new Node('a'); S.left = new Node('b'); S.right = new Node('d'); S.left.left = new Node('c'); int i = 0; while (i <= 1) { if (tree.isSubtree(T, S)) { System.out.println(\"Yes, S is a subtree of T\"); } else { System.out.println(\"No, S is not a subtree of T\"); } i++; } } }", "src": "class\nNode { \n\n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nPassing { \n\n\nint\ni; \n\nint\nm = \n0\n; \n\nint\nn = \n0\n; \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode root; \n\nPassing p = \nnew\nPassing(); \n\n\nString strstr(String haystack, String needle) \n\n{ \n\nif\n(haystack == \nnull\n|| needle == \nnull\n) { \n\nreturn\nnull\n; \n\n} \n\nint\nhLength = haystack.length(); \n\nint\nnLength = needle.length(); \n\nif\n(hLength < nLength) { \n\nreturn\nnull\n; \n\n} \n\nif\n(nLength == \n0\n) { \n\nreturn\nhaystack; \n\n} \n\nfor\n(\nint\ni = \n0\n; i <= hLength - nLength; i++) { \n\nif\n(haystack.charAt(i) == needle.charAt(\n0\n)) { \n\nint\nj = \n0\n; \n\nfor\n(; j < nLength; j++) { \n\nif\n(haystack.charAt(i + j) != needle.charAt(j)) { \n\nbreak\n; \n\n} \n\n} \n\nif\n(j == nLength) { \n\nreturn\nhaystack.substring(i); \n\n} \n\n} \n\n} \n\nreturn\nnull\n; \n\n} \n\n\n\n\n\n\nvoid\nstoreInorder(Node node, \nchar\narr[], Passing i) \n\n{ \n\nif\n(node == \nnull\n) { \n\narr[i.i++] = \n'$'\n; \n\nreturn\n; \n\n} \n\nstoreInorder(node.left, arr, i); \n\narr[i.i++] = node.data; \n\nstoreInorder(node.right, arr, i); \n\n} \n\n\n\n\n\n\nvoid\nstorePreOrder(Node node, \nchar\narr[], Passing i) \n\n{ \n\nif\n(node == \nnull\n) { \n\narr[i.i++] = \n'$'\n; \n\nreturn\n; \n\n} \n\narr[i.i++] = node.data; \n\nstorePreOrder(node.left, arr, i); \n\nstorePreOrder(node.right, arr, i); \n\n} \n\n\n\n\nboolean\nisSubtree(Node T, Node S) \n\n{ \n\n\n\nif\n(S == \nnull\n) { \n\nreturn\ntrue\n; \n\n} \n\nif\n(T == \nnull\n) { \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\nchar\ninT[] = \nnew\nchar\n[\n100\n]; \n\nString op1 = String.valueOf(inT); \n\nchar\ninS[] = \nnew\nchar\n[\n100\n]; \n\nString op2 = String.valueOf(inS); \n\nstoreInorder(T, inT, p); \n\nstoreInorder(S, inS, p); \n\ninT[p.m] = \n'\\0'\n; \n\ninS[p.m] = \n'\\0'\n; \n\n\n\n\nif\n(strstr(op1, op2) != \nnull\n) { \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\np.m = \n0\n; \n\np.n = \n0\n; \n\nchar\npreT[] = \nnew\nchar\n[\n100\n]; \n\nchar\npreS[] = \nnew\nchar\n[\n100\n]; \n\nString op3 = String.valueOf(preT); \n\nString op4 = String.valueOf(preS); \n\nstorePreOrder(T, preT, p); \n\nstorePreOrder(S, preS, p); \n\npreT[p.m] = \n'\\0'\n; \n\npreS[p.n] = \n'\\0'\n; \n\n\n\n\n\n\nreturn\n(strstr(op3, op4) != \nnull\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode T = \nnew\nNode(\n'a'\n); \n\nT.left = \nnew\nNode(\n'b'\n); \n\nT.right = \nnew\nNode(\n'd'\n); \n\nT.left.left = \nnew\nNode(\n'c'\n); \n\nT.right.right = \nnew\nNode(\n'e'\n); \n\n\nNode S = \nnew\nNode(\n'a'\n); \n\nS.left = \nnew\nNode(\n'b'\n); \n\nS.right = \nnew\nNode(\n'd'\n); \n\nS.left.left = \nnew\nNode(\n'c'\n); \n\n\nif\n(tree.isSubtree(T, S)) { \n\nSystem.out.println(\n\"Yes, S is a subtree of T\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"No, S is not a subtree of T\"\n); \n\n} \n\n} \n}", "index": 222, "complexity": "1"}
{"forwhile": "class GFG { static int findMedian(int arr[], int i, int n) { if(i <= n) Arrays.sort(arr, i, n); else Arrays.sort(arr, n, i); return arr[n/ 2]; } static int kthSmallest(int arr[], int l, int r, int k) { if(k > 0 && k <= r - l + 1) { int n = r - l + 1; int i = 0; int[] median = new int[(n + 4) / 5]; while(i < n / 5){ median[i] = findMedian(arr, l + i * 5, 5); i++; } if(i * 5 < n) { median[i] = findMedian(arr, l + i * 5, n % 5); i++; } int medOfMed = (i == 1) ? median[i - 1] : kthSmallest(median, 0, i - 1, i / 2); int pos = partition(arr, l, r, medOfMed); while(pos - l != k - 1) { if(pos - l == k - 1) return arr[pos]; if(pos - l > k - 1) kthSmallest(arr, l, pos - 1, k); kthSmallest(arr, pos + 1, r, k - pos + l - 1); } return Integer.MAX_VALUE; } return Integer.MAX_VALUE; } static int[] swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } static int partition(int arr[], int l, int r, int x) { int i; for(i = l; i < r; i++) if(arr[i] == x) break; swap(arr, i, r); i = l; for(int j = l; j <= r - 1; j++) { if(arr[j] <= x) { swap(arr, i, j); i++; } } swap(arr, i, r); return i; } public static void main(String[] args) { int arr[] = {12, 3, 5, 7, 4, 19, 26}; int n = arr.length, k = 3; System.out.println(\"K'th smallest element is \" + kthSmallest(arr, 0, n - 1, k)); } } ", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nfindMedian(\nint\narr[], \nint\ni,\nint\nn) \n{ \n\nif\n(i <= n) \n\nArrays.sort(arr, i, n); \n\n\nelse\n\nArrays.sort(arr, n, i); \n\nreturn\narr[n/\n2\n]; \n\n} \n\n\n\n\n\nstatic\nint\nkthSmallest(\nint\narr[], \nint\nl, \nint\nr, \nint\nk) \n{ \n\n\n\n\n\nif\n(k > \n0\n&& k <= r - l + \n1\n) \n\n{ \n\nint\nn = r - l + \n1\n; \n\n\n\n\n\n\n\n\n\nint\ni; \n\n\n\n\nint\n[]median = \nnew\nint\n[(n + \n4\n) / \n5\n]; \n\nfor\n(i = \n0\n; i < n/\n5\n; i++) \n\nmedian[i] = findMedian(arr,l + i * \n5\n, \n5\n); \n\n\n\n\nif\n(i*\n5\n< n) \n\n{ \n\nmedian[i] = findMedian(arr,l + i * \n5\n, n % \n5\n); \n\ni++; \n\n} \n\n\n\n\n\n\n\n\nint\nmedOfMed = (i == \n1\n)? median[i - \n1\n]: \n\nkthSmallest(median, \n0\n, i - \n1\n, i / \n2\n); \n\n\n\n\n\n\nint\npos = partition(arr, l, r, medOfMed); \n\n\n\n\nif\n(pos-l == k - \n1\n) \n\nreturn\narr[pos]; \n\nif\n(pos-l > k - \n1\n) \n\n\nreturn\nkthSmallest(arr, l, pos - \n1\n, k); \n\n\n\n\nreturn\nkthSmallest(arr, pos + \n1\n, r, k - pos + l - \n1\n); \n\n} \n\n\n\n\nreturn\nInteger.MAX_VALUE; \n} \n\nstatic\nint\n[] swap(\nint\n[]arr, \nint\ni, \nint\nj) \n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n} \n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nl, \n\nint\nr, \nint\nx) \n{ \n\n\n\nint\ni; \n\nfor\n(i = l; i < r; i++) \n\nif\n(arr[i] == x) \n\nbreak\n; \n\nswap(arr, i, r); \n\n\n\n\ni = l; \n\nfor\n(\nint\nj = l; j <= r - \n1\n; j++) \n\n{ \n\nif\n(arr[j] <= x) \n\n{ \n\nswap(arr, i, j); \n\ni++; \n\n} \n\n} \n\nswap(arr, i, r); \n\nreturn\ni; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n12\n, \n3\n, \n5\n, \n7\n, \n4\n, \n19\n, \n26\n}; \n\nint\nn = arr.length, k = \n3\n; \n\nSystem.out.println(\n\"K'th smallest element is \"\n\n+ kthSmallest(arr, \n0\n, n - \n1\n, k)); \n} \n}", "index": 224, "complexity": "1"}
{"forwhile": "class GfG { static class Node { int data; Node left, right; } static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.left = null; temp.right = null; return temp; } static String areMirrors(Node root1, Node root2) { Stack<Node> st1 = new Stack<Node> (); Stack<Node> st2 = new Stack<Node> (); for(;;) { for(; root1 != null && root2 != null;) { if(root1.data != root2.data) return 'No'; st1.push(root1); st2.push(root2); root1 = root1.left; root2 = root2.right; } if(!(root1 == null && root2 == null)) return 'No'; if (!st1.isEmpty() && !st2.isEmpty()) { root1 = st1.peek(); root2 = st2.peek(); st1.pop(); st2.pop(); root1 = root1.right; root2 = root2.left; } else break; } return 'Yes'; } public static void main(String[] args) { Node root1 = newNode(1); root1.left = newNode(3); root1.right = newNode(2); root1.right.left = newNode(5); root1.right.right = newNode(4); Node root2 = newNode(1); root2.left = newNode(2); root2.right = newNode(3); root2.left.left = newNode(4); root2.left.right = newNode(5); System.out.println(areMirrors(root1, root2)); } }", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\n\nstatic\nString areMirrors(Node root1, Node root2) \n{ \n\nStack<Node> st1 = \nnew\nStack<Node> (); \n\nStack<Node> st2 = \nnew\nStack<Node> (); \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nwhile\n(root1 != \nnull\n&& root2 != \nnull\n) \n\n{ \n\n\n\n\n\n\n\nif\n(root1.data != root2.data) \n\nreturn\n\"No\"\n; \n\n\nst1.push(root1); \n\nst2.push(root2); \n\nroot1 = root1.left; \n\nroot2 = root2.right; \n\n} \n\n\n\n\n\n\n\n\n\n\nif\n(!(root1 == \nnull\n&& root2 == \nnull\n)) \n\nreturn\n\"No\"\n; \n\n\nif\n(!st1.isEmpty() && !st2.isEmpty()) \n\n{ \n\nroot1 = st1.peek(); \n\nroot2 = st2.peek(); \n\nst1.pop(); \n\nst2.pop(); \n\n\n\n\nroot1 = root1.right; \n\n\n\n\nroot2 = root2.left; \n\n} \n\n\n\n\nelse\n\nbreak\n; \n\n} \n\n\n\n\nreturn\n\"Yes\"\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\nNode root1 = newNode(\n1\n); \n\n\nroot1.left = newNode(\n3\n); \n\n\nroot1.right = newNode(\n2\n); \n\n\nroot1.right.left = newNode(\n5\n); \n\n\nroot1.right.right = newNode(\n4\n); \n\n\n\n\n\nNode root2 = newNode(\n1\n); \n\n\nroot2.left = newNode(\n2\n); \n\n\nroot2.right = newNode(\n3\n); \n\n\nroot2.left.left = newNode(\n4\n); \n\n\nroot2.left.right = newNode(\n5\n); \n\n\n\nSystem.out.println(areMirrors(root1, root2)); \n} \n}", "index": 225, "complexity": "1"}
{"forwhile": "public\\nclass\\nPrintPath { \\n\\n\\n\\n\\n\\n\\npublic\\nstatic\\nboolean\\nhasPath(Node root, ArrayList<Integer> arr, \\nint\\nx) \\n\\n{ \\n\\n\\n\\n\\nif\\n(root==\\nnull\\n) \\n\\nreturn\\nfalse\\n; \\n\\n\\n\\narr.add(root.data); \\n\\n\\n\\n\\nif\\n(root.data == x) \\n\\nreturn\\ntrue\\n; \\n\\n\\n\\n\\n\\n\\nfor(int i=0; i<arr.size()-\\n1\\;) { \\nSystem.out.print(arr.get(i)+\\n\"->\"\\n); \\ni++; \\n} \\nSystem.out.print(arr.get(arr.size() - \\n1\\)); \\n\\n\\nif\\n(hasPath(root.left, arr, x) || \\n\\nhasPath(root.right, arr, x)) \\n\\nreturn\\ntrue\\n; \\n\\n\\n\\n\\n\\n\\narr.remove(arr.size()-\\n1\\); \\n\\nreturn\\nfalse\\n; \\n\\n} \\n\\n\\n\\n\\npublic\\nstatic\\nvoid\\nprintPath(Node root, \\nint\\nx) \\n\\n{ \\n\\n\\n\\nArrayList<Integer> arr=\\nnew\\nArrayList<>(); \\n\\n\\n\\n\\nif\\n(hasPath(root, arr, x)) \\n\\n{ \\n\\n\\n\\nwhile(!arr.isEmpty()) { \\nint i=0; \\nSystem.out.print(arr.get(i)+\\n\"->\"\\n); \\ni++; \\n} \\n\\nSystem.out.print(arr.get(arr.size() - \\n1\\)); \\n\\n} \\n\\n\\n\\nelse\\n\\nSystem.out.print(\\n\"No Path\"\\n); \\n\\n} \\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) { \\n\\nNode root=\\nnew\\nNode(\\n1\\); \\n\\nroot.left = \\nnew\\nNode(\\n2\\); \\n\\nroot.right = \\nnew\\nNode(\\n3\\); \\n\\nroot.left.left = \\nnew\\nNode(\\n4\\); \\n\\nroot.left.right = \\nnew\\nNode(\\n5\\); \\n\\nroot.right.left = \\nnew\\nNode(\\n6\\); \\n\\nroot.right.right = \\nnew\\nNode(\\n7\\); \\n\\nint\\nx=\\n5\\; \\nprintPath(root, x); \\n\\n} \\n} \\n\\n\\nclass\\nNode \\n{ \\n\\nint\\ndata; \\n\\nNode left, right; \\n\\nNode(\\nint\\ndata) \\n\\n{ \\n\\nthis\\n.data=data; \\n\\nleft=right=\\nnull\\n; \\n\\n} \\n};", "src": "public\nclass\nPrintPath { \n\n\n\n\n\n\n\n\npublic\nstatic\nboolean\nhasPath(Node root, ArrayList<Integer> arr, \nint\nx) \n\n{ \n\n\n\n\n\nif\n(root==\nnull\n) \n\nreturn\nfalse\n; \n\n\n\n\narr.add(root.data); \n\n\n\n\n\n\nif\n(root.data == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\nif\n(hasPath(root.left, arr, x) || \n\nhasPath(root.right, arr, x)) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\narr.remove(arr.size()-\n1\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\npublic\nstatic\nvoid\nprintPath(Node root, \nint\nx) \n\n{ \n\n\n\nArrayList<Integer> arr=\nnew\nArrayList<>(); \n\n\n\n\n\n\nif\n(hasPath(root, arr, x)) \n\n{ \n\nfor\n(\nint\ni=\n0\n; i<arr.size()-\n1\n; i++) \n\nSystem.out.print(arr.get(i)+\n\"->\"\n); \n\nSystem.out.print(arr.get(arr.size() - \n1\n)); \n\n} \n\n\n\n\nelse\n\nSystem.out.print(\n\"No Path\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) { \n\nNode root=\nnew\nNode(\n1\n); \n\nroot.left = \nnew\nNode(\n2\n); \n\nroot.right = \nnew\nNode(\n3\n); \n\nroot.left.left = \nnew\nNode(\n4\n); \n\nroot.left.right = \nnew\nNode(\n5\n); \n\nroot.right.left = \nnew\nNode(\n6\n); \n\nroot.right.right = \nnew\nNode(\n7\n); \n\nint\nx=\n5\n; \n\nprintPath(root, x); \n\n} \n} \n\n\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\nNode(\nint\ndata) \n\n{ \n\nthis\n.data=data; \n\nleft=right=\nnull\n; \n\n} \n};", "index": 229, "complexity": "1"}
{"forwhile": "class GfG { static class Node { int data; Node left, right; } static void printOddNodes(Node root) { if (root == null) return; Queue<Node> q = new LinkedList<Node> (); q.add(root); boolean isOdd = true; while (true) { int nodeCount = q.size(); if (nodeCount == 0) break; while (nodeCount > 0) { Node node = q.peek(); if (isOdd == true) System.out.print(node.data + \" \"); q.remove(); if (node.left != null) q.add(node.left); if (node.right != null) q.add(node.right); nodeCount--; } isOdd = !isOdd; } } static Node newNode(int data) { Node node = new Node(); node.data = data; node.left = null; node.right = null; return (node); } public static void main(String[] args) { Node root = newNode(1); root.left = newNode(2); root.right = newNode(3); root.left.left = newNode(4); root.left.right = newNode(5); printOddNodes(root); } }", "src": "class\nGfG { \n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nvoid\nprintOddNodes(Node root) \n{ \n\n\n\nif\n(root == \nnull\n) \nreturn\n; \n\n\n\n\n\n\nQueue<Node> q = \nnew\nLinkedList<Node> (); \n\n\n\n\nq.add(root); \n\nboolean\nisOdd = \ntrue\n; \n\n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\n\n\nint\nnodeCount = q.size(); \n\nif\n(nodeCount == \n0\n) \n\nbreak\n; \n\n\n\n\n\n\nwhile\n(nodeCount > \n0\n) \n\n{ \n\nNode node = q.peek(); \n\nif\n(isOdd == \ntrue\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nq.remove(); \n\nif\n(node.left != \nnull\n) \n\nq.add(node.left); \n\nif\n(node.right != \nnull\n) \n\nq.add(node.right); \n\nnodeCount--; \n\n} \n\n\nisOdd = !isOdd; \n\n} \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode node = \nnew\nNode(); \n\nnode.data = data; \n\nnode.left = \nnull\n; \n\nnode.right = \nnull\n; \n\nreturn\n(node); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nNode root = newNode(\n1\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n3\n); \n\nroot.left.left = newNode(\n4\n); \n\nroot.left.right = newNode(\n5\n); \n\nprintOddNodes(root); \n} \n}", "index": 231, "complexity": "1"}
{"forwhile": "ERROR:Expecting ':' delimiter: line 2 column 3700 (char 3701)", "src": "class\nLinkedList { \n\n\n\n\nstatic\nLNode head; \n\n\n\n\nclass\nLNode \n\n{ \n\nint\ndata; \n\nLNode next, prev; \n\n\nLNode(\nint\nd) \n\n{ \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\n\n\nclass\nTNode \n\n{ \n\nint\ndata; \n\nTNode left, right; \n\n\nTNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n\n} \n\n\n\n\nTNode sortedListToBST() \n\n{ \n\n\n\nint\nn = countNodes(head); \n\n\n\n\nreturn\nsortedListToBSTRecur(n); \n\n} \n\n\n\n\nTNode sortedListToBSTRecur(\nint\nn) \n\n{ \n\n\n\nif\n(n <= \n0\n) \n\nreturn\nnull\n; \n\n\n\n\nTNode left = sortedListToBSTRecur(n / \n2\n); \n\n\n\n\nTNode root = \nnew\nTNode(head.data); \n\n\n\n\nroot.left = left; \n\n\n\n\nhead = head.next; \n\n\n\n\nroot.right = sortedListToBSTRecur(n - n / \n2\n- \n1\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\n\n\nint\ncountNodes(LNode head) \n\n{ \n\nint\ncount = \n0\n; \n\nLNode temp = head; \n\nwhile\n(temp != \nnull\n) \n\n{ \n\ntemp = temp.next; \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n\n\nvoid\npush(\nint\nnew_data) \n\n{ \n\n\n\nLNode new_node = \nnew\nLNode(new_data); \n\n\n\n\nnew_node.prev = \nnull\n; \n\n\n\n\nnew_node.next = head; \n\n\n\n\nif\n(head != \nnull\n) \n\nhead.prev = new_node; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\nvoid\nprintList(LNode node) \n\n{ \n\nwhile\n(node != \nnull\n) \n\n{ \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.next; \n\n} \n\n} \n\n\n\n\nvoid\npreOrder(TNode node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList llist = \nnew\nLinkedList(); \n\n\n\n\nllist.push(\n7\n); \n\nllist.push(\n6\n); \n\nllist.push(\n5\n); \n\nllist.push(\n4\n); \n\nllist.push(\n3\n); \n\nllist.push(\n2\n); \n\nllist.push(\n1\n); \n\n\nSystem.out.println(\n\"Given Linked List \"\n); \n\nllist.printList(head); \n\n\n\n\nTNode root = llist.sortedListToBST(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Pre-Order Traversal of constructed BST \"\n); \n\nllist.preOrder(root); \n\n} \n}", "index": 234, "complexity": "1"}
{"forwhile": "class Test  { static int arr[] = { 10 , 324 , 45 , 90 , 9808}; static int largest()  { int i; int max = arr[0];  i = 1;  while(i < arr.length) if(arr[i] > max) max = arr[i]; i++; return max; } public static void main(String[] args)  { System.out.println(\"Largest in given array is \"+ largest()); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = {\n10\n, \n324\n, \n45\n, \n90\n, \n9808\n}; \n\n\n\n\nstatic\nint\nlargest() \n\n{ \n\nint\ni; \n\n\n\n\nint\nmax = arr[\n0\n]; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < arr.length; i++) \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Largest in given array is \"\n+ largest()); \n\n} \n\n}", "index": 235, "complexity": "1"}
{"forwhile": "ERROR:Expecting ',' delimiter: line 2 column 841 (char 842)", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\n\nstatic\nNode head; \n\n\n\n\nNode insert(Node node, \nint\ndata) { \n\n\n\n\nif\n(node == \nnull\n) { \n\nreturn\n(\nnew\nNode(data)); \n\n} \nelse\n{ \n\n\n\n\nif\n(data <= node.data) { \n\nnode.left = insert(node.left, data); \n\n} \nelse\n{ \n\nnode.right = insert(node.right, data); \n\n} \n\n\n\n\nreturn\nnode; \n\n} \n\n} \n\n\n\n\nint\nminvalue(Node node) { \n\nNode current = node; \n\n\n\n\nwhile\n(current.left != \nnull\n) { \n\ncurrent = current.left; \n\n} \n\nreturn\n(current.data); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nNode root = \nnull\n; \n\nroot = tree.insert(root, \n4\n); \n\ntree.insert(root, \n2\n); \n\ntree.insert(root, \n1\n); \n\ntree.insert(root, \n3\n); \n\ntree.insert(root, \n6\n); \n\ntree.insert(root, \n5\n); \n\n\nSystem.out.println(\n\"Minimum value of BST is \"\n+ tree.minvalue(root)); \n\n} \n}", "index": 238, "complexity": "1"}
{"forwhile": "class Solution { static class NodeDetails { int data; int min, max; }; static boolean levelOrderIsOfBST(int arr[], int n) { if(n == 0) return true; Queue<NodeDetails> q = new LinkedList<NodeDetails>(); int i = 0; NodeDetails newNode=new NodeDetails(); newNode.data = arr[i++]; newNode.min = Integer.MIN_VALUE; newNode.max = Integer.MAX_VALUE; q.add(newNode); for(; i != n && q.size() > 0;) { NodeDetails temp = q.peek(); q.remove(); newNode = new NodeDetails(); if(i < n && (arr[i] < (int)temp.data && arr[i] > (int)temp.min)) { newNode.data = arr[i++]; newNode.min = temp.min; newNode.max = temp.data; q.add(newNode); } newNode=new NodeDetails(); if(i < n && (arr[i] > (int)temp.data && arr[i] < (int)temp.max)) { newNode.data = arr[i++]; newNode.min = temp.data; newNode.max = temp.max; q.add(newNode); } } if(i == n) return true; return false; } public static void main(String args[]) { int arr[] = { 7, 4, 12, 3, 6, 8, 1, 5, 10}; int n = arr.length; if(levelOrderIsOfBST(arr, n)) System.out.print(\"Yes\"); else System.out.print(\"No\"); } }", "src": "class\nSolution \n{ \n\n\n\n\n\nstatic\nclass\nNodeDetails \n{ \n\nint\ndata; \n\nint\nmin, max; \n}; \n\n\n\n\nstatic\nboolean\nlevelOrderIsOfBST(\nint\narr[], \nint\nn) \n{ \n\n\n\nif\n(n == \n0\n) \n\nreturn\ntrue\n; \n\n\n\n\nQueue<NodeDetails> q = \nnew\nLinkedList<NodeDetails>(); \n\n\n\n\nint\ni = \n0\n; \n\n\n\n\n\n\nNodeDetails newNode=\nnew\nNodeDetails(); \n\nnewNode.data = arr[i++]; \n\nnewNode.min = Integer.MIN_VALUE; \n\nnewNode.max = Integer.MAX_VALUE; \n\nq.add(newNode); \n\n\n\n\n\n\nwhile\n(i != n && q.size() > \n0\n) \n\n{ \n\n\n\n\n\nNodeDetails temp = q.peek(); \n\nq.remove(); \n\nnewNode = \nnew\nNodeDetails(); \n\n\n\n\n\n\n\n\nif\n(i < n && (arr[i] < (\nint\n)temp.data && \n\narr[i] > (\nint\n)temp.min)) \n\n{ \n\n\n\n\n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.min; \n\nnewNode.max = temp.data; \n\nq.add(newNode); \n\n} \n\n\nnewNode=\nnew\nNodeDetails(); \n\n\n\n\n\n\n\n\nif\n(i < n && (arr[i] > (\nint\n)temp.data && \n\narr[i] < (\nint\n)temp.max)) \n\n{ \n\n\n\n\n\nnewNode.data = arr[i++]; \n\nnewNode.min = temp.data; \n\nnewNode.max = temp.max; \n\nq.add(newNode); \n\n} \n\n} \n\n\n\n\n\n\nif\n(i == n) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nreturn\nfalse\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n7\n, \n4\n, \n12\n, \n3\n, \n6\n, \n8\n, \n1\n, \n5\n, \n10\n}; \n\nint\nn = arr.length; \n\nif\n(levelOrderIsOfBST(arr, n)) \n\nSystem.out.print( \n\"Yes\"\n); \n\nelse\n\nSystem.out.print( \n\"No\"\n); \n\n} \n}", "index": 239, "complexity": "1"}
{"forwhile": "class GfG { static class Node { int data; Node left, right; } static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.right = null; temp.left = null; return temp; } static Node KthLargestUsingMorrisTraversal(Node root, int k) { Node curr = root; Node Klargest = null; int count = 0; for(; curr != null; ) { if(curr.right == null) { if(++count == k) Klargest = curr; curr = curr.left; } else { Node succ = curr.right; while(succ.left != null && succ.left != curr) succ = succ.left; if(succ.left == null) { succ.left = curr; curr = curr.right; } else { succ.left = null; if(++count == k) Klargest = curr; curr = curr.left; } } } return Klargest; } public static void main(String[] args) { Node root = newNode(4); root.left = newNode(2); root.right = newNode(7); root.left.left = newNode(1); root.left.right = newNode(3); root.right.left = newNode(6); root.right.right = newNode(10); System.out.println(\"Finding K-th largest Node in BST : \" + KthLargestUsingMorrisTraversal(root, 2).data); } }", "src": "class\nGfG \n{ \n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.right = \nnull\n; \n\ntemp.left = \nnull\n; \n\nreturn\ntemp; \n} \n\nstatic\nNode KthLargestUsingMorrisTraversal(Node root, \nint\nk) \n{ \n\nNode curr = root; \n\nNode Klargest = \nnull\n; \n\n\n\n\nint\ncount = \n0\n; \n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\n\n\nif\n(curr.right == \nnull\n) \n\n{ \n\n\n\n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n\n\ncurr = curr.left; \n\n} \n\n\nelse\n\n{ \n\n\n\n\nNode succ = curr.right; \n\n\nwhile\n(succ.left != \nnull\n&& succ.left != curr) \n\nsucc = succ.left; \n\n\nif\n(succ.left == \nnull\n) \n\n{ \n\n\n\n\n\n\nsucc.left = curr; \n\n\n\n\ncurr = curr.right; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\n\nsucc.left = \nnull\n; \n\n\nif\n(++count == k) \n\nKlargest = curr; \n\n\n\n\ncurr = curr.left; \n\n} \n\n} \n\n} \n\nreturn\nKlargest; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\n\n\n\nNode root = newNode(\n4\n); \n\nroot.left = newNode(\n2\n); \n\nroot.right = newNode(\n7\n); \n\nroot.left.left = newNode(\n1\n); \n\nroot.left.right = newNode(\n3\n); \n\nroot.right.left = newNode(\n6\n); \n\nroot.right.right = newNode(\n10\n); \n\n\nSystem.out.println(\n\"Finding K-th largest Node in BST : \"\n+ \n\nKthLargestUsingMorrisTraversal(root, \n2\n).data); \n} \n}", "index": 240, "complexity": "1"}
{"forwhile": "class GfG { static class Node { int key; Node left, right; } static int KSmallestUsingMorris(Node root, int k) { int count = 0; int ksmall = Integer.MIN_VALUE; Node curr = root; for(; curr != null; curr = curr.right) { if(curr.left == null) { count++; if(count==k) ksmall = curr.key; } else { Node pre = curr.left; for(; pre.right != null && pre.right != curr; pre = pre.right) {} if(pre.right== null) { pre.right = curr; curr = curr.left; } else { pre.right = null; count++; if(count==k) ksmall = curr.key; curr = curr.right; } } } return ksmall; } static Node newNode(int item) { Node temp = new Node(); temp.key = item; temp.left = null; temp.right = null; return temp; } static Node insert(Node node, int key) { if(node == null) return newNode(key); if(key < node.key) node.left = insert(node.left, key); else if(key > node.key) node.right = insert(node.right, key); return node; } public static void main(String[] args) { Node root = null; root = insert(root, 50); insert(root, 30); insert(root, 20); insert(root, 40); insert(root, 70); insert(root, 60); insert(root, 80); int k = 1; while(k <= 7) { System.out.print(KSmallestUsingMorris(root, k) + \" \"); k++; } } }", "src": "class\nGfG { \n\n\nstatic\nclass\nNode \n{ \n\nint\nkey; \n\nNode left, right; \n} \n\n\nstatic\nint\nKSmallestUsingMorris(Node root, \nint\nk) \n{ \n\n\n\n\n\nint\ncount = \n0\n; \n\n\nint\nksmall = Integer.MIN_VALUE; \n\n\nNode curr = root; \n\n\n\nwhile\n(curr != \nnull\n) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\nif\n(curr.left == \nnull\n) \n\n{ \n\ncount++; \n\n\n\n\n\n\nif\n(count==k) \n\nksmall = curr.key; \n\n\n\n\ncurr = curr.right; \n\n} \n\nelse\n\n{ \n\n\n\n\n\nNode pre = curr.left; \n\nwhile\n(pre.right != \nnull\n&& pre.right != curr) \n\npre = pre.right; \n\n\n\n\nif\n(pre.right== \nnull\n) \n\n{ \n\n\n\npre.right = curr; \n\ncurr = curr.left; \n\n} \n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\n\n\npre.right = \nnull\n; \n\n\ncount++; \n\n\n\n\n\n\nif\n(count==k) \n\nksmall = curr.key; \n\n\ncurr = curr.right; \n\n} \n\n} \n\n} \n\nreturn\nksmall; \n\n} \n\n\nstatic\nNode newNode(\nint\nitem) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.key = item; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode insert(Node node, \nint\nkey) \n{ \n\n\n\nif\n(node == \nnull\n) \nreturn\nnewNode(key); \n\n\n\n\nif\n(key < node.key) \n\nnode.left = insert(node.left, key); \n\nelse\nif\n(key > node.key) \n\nnode.right = insert(node.right, key); \n\n\n\n\nreturn\nnode; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\n\n\nNode root = \nnull\n; \n\nroot = insert(root, \n50\n); \n\ninsert(root, \n30\n); \n\ninsert(root, \n20\n); \n\ninsert(root, \n40\n); \n\ninsert(root, \n70\n); \n\ninsert(root, \n60\n); \n\ninsert(root, \n80\n); \n\n\nfor\n(\nint\nk=\n1\n; k<=\n7\n; k++) \n\nSystem.out.print(KSmallestUsingMorris(root, k) + \n\" \"\n); \n\n} \n}", "index": 242, "complexity": "1"}
{"forwhile": "class GFG { static boolean isInorder(int[] arr, int n) { if (n == 0 || n == 1) { return true; } int i = 1; while (i < n) { if (arr[i - 1] > arr[i]) { return false; } i++; } return true; } public static void main(String[] args) { int arr[] = {19, 23, 25, 30, 45}; int n = arr.length; if (isInorder(arr, n)) { System.out.println(\"Yes\"); } else { System.out.println(\"Non\"); } } }", "src": "class\nGFG { \n\n\n\n\nstatic\nboolean\nisInorder(\nint\n[] arr, \nint\nn) { \n\n\n\nif\n(n == \n0\n|| n == \n1\n) { \n\nreturn\ntrue\n; \n\n} \n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n\n{ \n\nif\n(arr[i - \n1\n] > arr[i]) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\n\n\nreturn\ntrue\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n19\n, \n23\n, \n25\n, \n30\n, \n45\n}; \n\nint\nn = arr.length; \n\nif\n(isInorder(arr, n)) { \n\nSystem.out.println(\n\"Yes\"\n); \n\n} \nelse\n{ \n\nSystem.out.println(\n\"Non\"\n); \n\n} \n\n} \n}", "index": 243, "complexity": "1"}
{"forwhile": "class PrintLargest  { static void print3largest( int arr[], int arr_size) { int i, first, second, third; if (arr_size < 3) { System.out.print(\\\" Invalid Input \\\"); return; } third = first = second = Integer.MIN_VALUE; i = 0; while(i < arr_size ) { if (arr[i] > first) { third = second; second = first; first = arr[i]; } else if (arr[i] > second) { third = second; second = arr[i]; } else if (arr[i] > third) third = arr[i]; i++; } System.out.println(\\\"Three largest elements are \\", "src": "class\nPrintLargest \n{ \n\n\n\nstatic\nvoid\nprint3largest(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ni, first, second, third; \n\n\n\n\nif\n(arr_size < \n3\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nthird = first = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nthird = second; \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second) \n\n{ \n\nthird = second; \n\nsecond = arr[i]; \n\n} \n\n\nelse\nif\n(arr[i] > third) \n\nthird = arr[i]; \n\n} \n\n\nSystem.out.println(\n\"Three largest elements are \"\n+ \n\nfirst + \n\" \"\n+ second + \n\" \"\n+ third); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint3largest(arr, n); \n\n} \n}", "index": 244, "complexity": "1"}
{"forwhile": "public class GFG { static class Node { int data; Node left, right; public Node(int data) { this .data = data; left = null ; right = null ; } } static Node root1; static Node root2; static int countPairs(Node root1, Node root2, int x) { if(root1 == null || root2 == null ) return 0 ; Stack<Node> st1 = new Stack<>(); Stack<Node> st2 = new Stack<>(); Node top1, top2; int count = 0 ; while(true ) { while(root1 != null ) { st1.push(root1); root1 = root1.left; } while(root2 != null ) { st2.push(root2); root2 = root2.right; } if(st1.empty() || st2.empty()) break ; top1 = st1.peek(); top2 = st2.peek(); if((top1.data + top2.data) == x) { count++; st1.pop(); st2.pop(); root1 = top1.right; root2 = top2.left; } else if((top1.data + top2.data) < x) { st1.pop(); root1 = top1.right; } else { st2.pop(); root2 = top2.left; } } return count; } public static void main(String args[]) { root1 = new Node(5 ); root1.left = new Node(3 ); root1.right = new Node(7 ); root1.left.left = new Node(2 ); root1.left.right = new Node(4 ); root1.right.left = new Node(6 ); root1.right.right = new Node(8 ); root2 = new Node(10 ); root2.left = new Node(6 ); root2.right = new Node(15 ); root2.left.left = new Node(3 ); root2.left.right = new Node(8 ); root2.right.left = new Node(11 ); root2.right.right = new Node(18 ); int x = 16 ; System.out.println( \"Pairs = \" + countPairs(root1, root2, x)); } }", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nclass\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\n\n\npublic\nNode(\nint\ndata) { \n\nthis\n.data = data; \n\nleft = \nnull\n; \n\nright = \nnull\n; \n\n} \n\n} \n\n\nstatic\nNode root1; \n\nstatic\nNode root2; \n\n\n\n\n\nstatic\nint\ncountPairs(Node root1, Node root2, \n\nint\nx) \n\n{ \n\n\n\nif\n(root1 == \nnull\n|| root2 == \nnull\n) \n\nreturn\n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\nStack<Node> st1 = \nnew\nStack<>(); \n\nStack<Node> st2 = \nnew\nStack<>(); \n\nNode top1, top2; \n\n\nint\ncount = \n0\n; \n\n\n\n\n\n\nwhile\n(\ntrue\n) { \n\n\n\n\n\n\nwhile\n(root1 != \nnull\n) { \n\nst1.push(root1); \n\nroot1 = root1.left; \n\n} \n\n\n\n\n\n\nwhile\n(root2 != \nnull\n) { \n\nst2.push(root2); \n\nroot2 = root2.right; \n\n} \n\n\n\n\n\n\nif\n(st1.empty() || st2.empty()) \n\nbreak\n; \n\n\ntop1 = st1.peek(); \n\ntop2 = st2.peek(); \n\n\n\n\nif\n((top1.data + top2.data) == x) { \n\n\n\ncount++; \n\n\n\n\nst1.pop(); \n\nst2.pop(); \n\n\n\n\n\n\nroot1 = top1.right; \n\nroot2 = top2.left; \n\n} \n\n\n\n\n\n\nelse\nif\n((top1.data + top2.data) < x) { \n\nst1.pop(); \n\nroot1 = top1.right; \n\n} \n\n\n\n\n\n\nelse\n{ \n\nst2.pop(); \n\nroot2 = top2.left; \n\n} \n\n} \n\n\n\n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\n\n\nroot1 = \nnew\nNode(\n5\n); \n\n\nroot1.left = \nnew\nNode(\n3\n); \n\n\nroot1.right = \nnew\nNode(\n7\n); \n\n\nroot1.left.left = \nnew\nNode(\n2\n); \n\n\nroot1.left.right = \nnew\nNode(\n4\n); \n\n\nroot1.right.left = \nnew\nNode(\n6\n); \n\nroot1.right.right = \nnew\nNode(\n8\n); \n\n\n\n\nroot2 = \nnew\nNode(\n10\n); \n\n\nroot2.left = \nnew\nNode(\n6\n); \n\n\nroot2.right = \nnew\nNode(\n15\n); \n\n\nroot2.left.left = \nnew\nNode(\n3\n); \n\n\nroot2.left.right = \nnew\nNode(\n8\n); \n\n\nroot2.right.left = \nnew\nNode(\n11\n); \n\nroot2.right.right = \nnew\nNode(\n18\n); \n\n\nint\nx = \n16\n; \n\nSystem.out.println(\n\"Pairs = \"\n\n+ countPairs(root1, root2, x)); \n\n} \n}", "index": 245, "complexity": "1"}
{"forwhile": "class Node { int data; Node left, right; Node(int d) { data = d; left = right = null; } }\n\nclass BinarySearchTree { Node root; BinarySearchTree() { root = null; } void inorder() { Node tmp_root = root; while(tmp_root != null) { if(tmp_root.left == null) { System.out.print(tmp_root.data + \\\" \\\"); tmp_root = tmp_root.right; } else { Node predecessor = tmp_root.left; while(predecessor.right != null && predecessor.right != tmp_root) { predecessor = predecessor.right; } if(predecessor.right == null) { predecessor.right = tmp_root; tmp_root = tmp_root.left; } else { predecessor.right = null; System.out.print(tmp_root.data + \\\" \\\"); tmp_root = tmp_root.right; } } } }\n\nvoid insert(int key) { Node tmp_root = root; Node parent = null; while(tmp_root != null) { parent = tmp_root; if(key < tmp_root.data) { tmp_root = tmp_root.left; } else if(key > tmp_root.data) { tmp_root = tmp_root.right; } else { return; } } tmp_root = new Node(key); if(parent == null) { root = tmp_root; } else if(key < parent.data) { parent.left = tmp_root; } else { parent.right = tmp_root; } }\n\nArrayList<Integer> treeToList(Node node, ArrayList<Integer> list) { ArrayList<Node> stack = new ArrayList<>(); Node currentNode = node; while(currentNode != null || !stack.isEmpty()) { while(currentNode != null) { stack.add(currentNode); currentNode = currentNode.left; } currentNode = stack.remove(stack.size() - 1); list.add(currentNode.data); currentNode = currentNode.right; } return list; }\n\nboolean isPairPresent(Node node, int target) { ArrayList<Integer> a1 = new ArrayList<>(); int len1 = a1.size(); ArrayList<Integer> a2 = new ArrayList<>(); treeToList(node, a1); int len2 = a2.size(); int start = 0; int end = len2 - 1; for(; start < end;) { if(a2.get(start) + a2.get(end) == target) { System.out.println(\\\"Pair Found: \\\" + a2.get(start) + \\\" + \\\" + a2.get(end) + \\\" = \\\" + target); return true; } if(a2.get(start) + a2.get(end) < target) { start++; } else { end--; } } System.out.println(\\\"No such values are found!\\\"); return false; }\n\npublic static void main(String[] args) { BinarySearchTree tree = new BinarySearchTree(); tree.insert(15); tree.insert(10); tree.insert(20); tree.insert(8); tree.insert(12); tree.insert(16); tree.insert(25); tree.isPairPresent(tree.root, 33); } }", "src": "class\nNode { \n\n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinarySearchTree { \n\n\n\n\nNode root; \n\n\n\n\nBinarySearchTree() \n\n{ \n\nroot = \nnull\n; \n\n} \n\n\n\n\nvoid\ninorder() \n\n{ \n\ninorderUtil(\nthis\n.root); \n\n} \n\n\n\n\nvoid\ninorderUtil(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\ninorderUtil(node.left); \n\nSystem.out.print(node.data + \n\" \"\n); \n\ninorderUtil(node.right); \n\n} \n\n\n\n\nvoid\ninsert(\nint\nkey) \n\n{ \n\nroot = insertRec(root, key); \n\n} \n\n\n\n\nNode insertRec(Node root, \nint\ndata) \n\n{ \n\n\n\n\nif\n(root == \nnull\n) { \n\nroot = \nnew\nNode(data); \n\nreturn\nroot; \n\n} \n\n\n\n\nif\n(data < root.data) \n\nroot.left = insertRec(root.left, data); \n\nelse\nif\n(data > root.data) \n\nroot.right = insertRec(root.right, data); \n\n\nreturn\nroot; \n\n} \n\n\n\n\n\n\nArrayList<Integer> treeToList(Node node, ArrayList<Integer> \n\nlist) \n\n{ \n\n\n\nif\n(node == \nnull\n) \n\nreturn\nlist; \n\n\ntreeToList(node.left, list); \n\nlist.add(node.data); \n\ntreeToList(node.right, list); \n\n\nreturn\nlist; \n\n} \n\n\n\n\nboolean\nisPairPresent(Node node, \nint\ntarget) \n\n{ \n\n\n\n\n\n\n\nArrayList<Integer> a1 = \nnew\nArrayList<>(); \n\n\n\n\n\n\nArrayList<Integer> a2 = treeToList(node, a1); \n\n\nint\nstart = \n0\n; \n\n\n\nint\nend = a2.size() - \n1\n; \n\n\n\nwhile\n(start < end) { \n\n\nif\n(a2.get(start) + a2.get(end) == target) \n\n\n{ \n\nSystem.out.println(\n\"Pair Found: \"\n+ a2.get(start) + \n\" + \"\n+ a2.get(end) + \n\" \"\n\n+ \n\"= \"\n+ target); \n\nreturn\ntrue\n; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) > target) \n\n\n{ \n\nend--; \n\n} \n\n\nif\n(a2.get(start) + a2.get(end) < target) \n\n\n{ \n\nstart++; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No such values are found!\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinarySearchTree tree = \nnew\nBinarySearchTree(); \n\n\n\ntree.insert(\n15\n); \n\ntree.insert(\n10\n); \n\ntree.insert(\n20\n); \n\ntree.insert(\n8\n); \n\ntree.insert(\n12\n); \n\ntree.insert(\n16\n); \n\ntree.insert(\n25\n); \n\n\ntree.isPairPresent(tree.root, \n33\n); \n\n} \n}", "index": 247, "complexity": "1"}
{"forwhile": "class\nSolution \n{ \n\nstatic\nclass\nNode \n{ \n\nNode left, right; \n\nint\ndata; \n} \n\n\nstatic\nNode createNode(\nint\nx) \n{ \n\nNode p = \nnew\nNode(); \n\np . data = x; \n\np . left = p . right = \nnull\n; \n\nreturn\np; \n} \n\n\nstatic\nvoid\ninsertNode( Node root, \nint\nx) \n{ \n\nNode p = root, q = \nnull\n; \n\n\nfor\n(; p != \nnull\n;) \n\n{ \n\nq = p; \n\n\nif\n(p . data < x) \n\np = p . right; \n\nelse\n\np = p . left; \n\n} \n\n\nif\n(q == \nnull\n) \n\np = createNode(x); \n\nelse\n\n{ \n\nif\n(q . data < x) \n\nq . right = createNode(x); \n\nelse\n\nq . left = createNode(x); \n\n} \n} \n\n\n\nstatic\nint\nmaxelpath(Node q, \nint\nx) \n{ \n\nNode p = q; \n\n\nint\nmx = -\n1\n; \n\n\n\nfor\n(; p . data != x;) \n\n{ \n\n\nif\n(p . data > x) \n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . left; \n\n} \n\nelse\n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . right; \n\n} \n\n} \n\n\nreturn\nMath.max(mx, x); \n} \n\n\n\nstatic\nint\nmaximumElement( Node root, \nint\nx, \nint\ny) \n{ \n\nNode p = root; \n\n\n\n\nfor\n(; (x < p . data && y < p . data) || \n\n(x > p . data && y > p . data);) \n\n{ \n\n\n\n\n\nif\n(x < p . data && y < p . data) \n\np = p . left; \n\n\n\n\n\n\nelse\nif\n(x > p . data && y > p . data) \n\np = p . right; \n\n} \n\n\n\n\n\n\nreturn\nMath.max(maxelpath(p, x), maxelpath(p, y)); \n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n18\n, \n36\n, \n9\n, \n6\n, \n12\n, \n10\n, \n1\n, \n8\n}; \n\nint\na = \n1\n, b = \n10\n; \n\nint\nn =arr.length; \n\n\n\n\nNode root = createNode(arr[\n0\n]); \n\n\n\nint\ni = \n1\n; \n\nwhile(i < n) \n\n{ \n\ninsertNode(root, arr[i]); \n\ni++; \n\n} \n\n\nSystem.out.println( maximumElement(root, a, b) ); \n\n} \n}", "src": "class\nSolution \n{ \n\nstatic\nclass\nNode \n{ \n\nNode left, right; \n\nint\ndata; \n} \n\n\nstatic\nNode createNode(\nint\nx) \n{ \n\nNode p = \nnew\nNode(); \n\np . data = x; \n\np . left = p . right = \nnull\n; \n\nreturn\np; \n} \n\n\nstatic\nvoid\ninsertNode( Node root, \nint\nx) \n{ \n\nNode p = root, q = \nnull\n; \n\n\nwhile\n(p != \nnull\n) \n\n{ \n\nq = p; \n\nif\n(p . data < x) \n\np = p . right; \n\nelse\n\np = p . left; \n\n} \n\n\nif\n(q == \nnull\n) \n\np = createNode(x); \n\nelse\n\n{ \n\nif\n(q . data < x) \n\nq . right = createNode(x); \n\nelse\n\nq . left = createNode(x); \n\n} \n} \n\n\n\nstatic\nint\nmaxelpath(Node q, \nint\nx) \n{ \n\nNode p = q; \n\n\nint\nmx = -\n1\n; \n\n\n\n\n\n\nwhile\n(p . data != x) \n\n{ \n\nif\n(p . data > x) \n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . left; \n\n} \n\nelse\n\n{ \n\nmx = Math.max(mx, p . data); \n\np = p . right; \n\n} \n\n} \n\n\nreturn\nMath.max(mx, x); \n} \n\n\n\nstatic\nint\nmaximumElement( Node root, \nint\nx, \nint\ny) \n{ \n\nNode p = root; \n\n\n\n\nwhile\n((x < p . data && y < p . data) || \n\n(x > p . data && y > p . data)) \n\n{ \n\n\n\n\n\nif\n(x < p . data && y < p . data) \n\np = p . left; \n\n\n\n\n\n\nelse\nif\n(x > p . data && y > p . data) \n\np = p . right; \n\n} \n\n\n\n\n\n\nreturn\nMath.max(maxelpath(p, x), maxelpath(p, y)); \n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n18\n, \n36\n, \n9\n, \n6\n, \n12\n, \n10\n, \n1\n, \n8\n}; \n\nint\na = \n1\n, b = \n10\n; \n\nint\nn =arr.length; \n\n\n\n\nNode root = createNode(arr[\n0\n]); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\ninsertNode(root, arr[i]); \n\n\nSystem.out.println( maximumElement(root, a, b) ); \n\n} \n}", "index": 248, "complexity": "1"}
{"forwhile": "class solution { static class Node { int data; Node left, right; }; static Node newNode(int num) { Node temp = new Node(); temp.data = num; temp.left = temp.right = null; return temp; } static Node insert(Node root, int key) { if (root == null) return newNode(key); if (root.data > key) root.left = insert(root.left, key); else root.right = insert(root.right, key); return root; } static void storeInorder(Node ptr, Vector<Integer> vect) { if (ptr==null) return; storeInorder(ptr.left, vect); vect.add(ptr.data); storeInorder(ptr.right, vect); } static void pairSumUtil(Vector<Integer> vect1, Vector<Integer> vect2, int sum) { int left = 0; int right = vect2.size() - 1; for(; left < vect1.size() && right >= 0; left++, right--) { if (vect1.get(left) + vect2.get(right) == sum) { System.out.print(\"(\"+vect1.get(left) + \", \"+ vect2.get(right) + \"), \"); } else if (vect1.get(left) + vect2.get(right) < sum) left++; else right--; } } static void pairSum(Node root1, Node root2, int sum) { Vector<Integer> vect1= new Vector<Integer>(), vect2= new Vector<Integer>(); storeInorder(root1, vect1); storeInorder(root2, vect2); pairSumUtil(vect1, vect2, sum); } public static void main(String args[]) { Node root1 = null; root1 = insert(root1, 8); root1 = insert(root1, 10); root1 = insert(root1, 3); root1 = insert(root1, 6); root1 = insert(root1, 1); root1 = insert(root1, 5); root1 = insert(root1, 7); root1 = insert(root1, 14); root1 = insert(root1, 13); Node root2 = null; root2 = insert(root2, 5); root2 = insert(root2, 18); root2 = insert(root2, 2); root2 = insert(root2, 1); root2 = insert(root2, 3); root2 = insert(root2, 4); int sum = 10; pairSum(root1, root2, sum); } }", "src": "class\nsolution \n{ \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n}; \n\n\n\nstatic\nNode newNode(\nint\nnum) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = num; \n\ntemp.left = temp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nNode insert(Node root, \nint\nkey) \n{ \n\nif\n(root == \nnull\n) \n\nreturn\nnewNode(key); \n\nif\n(root.data > key) \n\nroot.left = insert(root.left, key); \n\nelse\n\nroot.right = insert(root.right, key); \n\nreturn\nroot; \n} \n\n\nstatic\nvoid\nstoreInorder(Node ptr, Vector<Integer> vect) \n{ \n\nif\n(ptr==\nnull\n) \n\nreturn\n; \n\nstoreInorder(ptr.left, vect); \n\nvect.add(ptr.data); \n\nstoreInorder(ptr.right, vect); \n} \n\n\n\n\nstatic\nvoid\npairSumUtil(Vector<Integer> vect1, Vector<Integer> vect2, \n\nint\nsum) \n{ \n\n\n\n\n\nint\nleft = \n0\n; \n\nint\nright = vect2.size() - \n1\n; \n\n\n\n\nwhile\n(left < vect1.size() && right >= \n0\n) \n\n{ \n\n\n\nif\n(vect1.get(left) + vect2.get(right) == sum) \n\n{ \n\nSystem.out.print( \n\"(\"\n+vect1.get(left) + \n\", \"\n+ vect2.get(right) + \n\"), \"\n); \n\nleft++; \n\nright--; \n\n} \n\n\n\n\n\n\nelse\nif\n(vect1.get(left) + vect2.get(right) < sum) \n\nleft++; \n\n\n\n\n\n\nelse\n\nright--; \n\n} \n} \n\n\n\n\nstatic\nvoid\npairSum(Node root1, Node root2, \nint\nsum) \n{ \n\n\n\n\n\nVector<Integer> vect1= \nnew\nVector<Integer>(), vect2= \nnew\nVector<Integer>(); \n\nstoreInorder(root1, vect1); \n\nstoreInorder(root2, vect2); \n\n\n\n\n\n\n\n\npairSumUtil(vect1, vect2, sum); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nNode root1 = \nnull\n; \n\nroot1 = insert(root1, \n8\n); \n\nroot1 = insert(root1, \n10\n); \n\nroot1 = insert(root1, \n3\n); \n\nroot1 = insert(root1, \n6\n); \n\nroot1 = insert(root1, \n1\n); \n\nroot1 = insert(root1, \n5\n); \n\nroot1 = insert(root1, \n7\n); \n\nroot1 = insert(root1, \n14\n); \n\nroot1 = insert(root1, \n13\n); \n\n\n\n\nNode root2 = \nnull\n; \n\nroot2 = insert(root2, \n5\n); \n\nroot2 = insert(root2, \n18\n); \n\nroot2 = insert(root2, \n2\n); \n\nroot2 = insert(root2, \n1\n); \n\nroot2 = insert(root2, \n3\n); \n\nroot2 = insert(root2, \n4\n); \n\n\nint\nsum = \n10\n; \n\npairSum(root1, root2, sum); \n} \n}", "index": 249, "complexity": "1"}
{"forwhile": "class GFG { static int n, p; static int rd[] = new int[1100]; static int wt[] = new int[1100]; static int cd[] = new int[1100]; static List<Integer> a = new ArrayList<Integer>(); static List<Integer> b = new ArrayList<Integer>(); static List<Integer> c = new ArrayList<Integer>(); static int ans; static int dfs(int w) { if (cd[w] == 0) return w; if (wt[w] < ans) ans = wt[w]; return dfs(cd[w]); } static void solve(int arr[]) { int i = 0; while (i < p) { int q = arr[i][0]; int h = arr[i][1]; int t = arr[i][2]; cd[q] = h; wt[q] = t; rd[h] = q; i++; } a = new ArrayList<Integer>(); b = new ArrayList<Integer>(); c = new ArrayList<Integer>(); for (int j = 1; j <= n; ++j) if (rd[j] == 0 && cd[j] > 0) { ans = 1000000000; int w = dfs(j); a.add(j); b.add(w); c.add(ans); } System.out.println(a.size()); for (int j = 0; j < a.size(); ++j) System.out.println(a.get(j) + \" \" + b.get(j) + \" \" + c.get(j)); } public static void main(String args[]) { n = 9; p = 6; for (int i = 0; i < 1100; i++) rd[i] = cd[i] = wt[i] = 0; int arr[][] = { { 7, 4, 98 }, { 5, 9, 72 }, { 4, 6, 10 }, { 2, 8, 22 }, { 9, 7, 17 }, { 3, 1, 66 } }; solve(arr); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nn, p; \n\n\n\n\n\n\nstatic\nint\nrd[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nint\nwt[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nint\ncd[] = \nnew\nint\n[\n1100\n]; \n\n\n\n\n\n\nstatic\nList <Integer> a = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nList <Integer> b = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nList <Integer> c = \n\nnew\nArrayList<Integer>(); \n\n\nstatic\nint\nans; \n\n\nstatic\nint\ndfs(\nint\nw) \n\n{ \n\nif\n(cd[w] == \n0\n) \n\nreturn\nw; \n\nif\n(wt[w] < ans) \n\nans = wt[w]; \n\n\nreturn\ndfs(cd[w]); \n\n} \n\n\n\n\nstatic\nvoid\nsolve(\nint\narr[][]) \n\n{ \n\nint\ni = \n0\n; \n\n\nwhile\n(i < p) \n\n{ \n\n\nint\nq = arr[i][\n0\n]; \n\nint\nh = arr[i][\n1\n]; \n\nint\nt = arr[i][\n2\n]; \n\n\ncd[q] = h; \n\nwt[q] = t; \n\nrd[h] = q; \n\ni++; \n\n} \n\n\na=\nnew\nArrayList<Integer>(); \n\nb=\nnew\nArrayList<Integer>(); \n\nc=\nnew\nArrayList<Integer>(); \n\n\nfor\n(\nint\nj = \n1\n; j <= n; ++j) \n\n\n\n\nif\n(rd[j] == \n0\n&& cd[j]>\n0\n) { \n\nans = \n1000000000\n; \n\nint\nw = dfs(j); \n\n\n\n\n\n\n\n\na.add(j); \n\nb.add(w); \n\nc.add(ans); \n\n} \n\n\nSystem.out.println(a.size()); \n\n\nfor\n(\nint\nj = \n0\n; j < a.size(); ++j) \n\nSystem.out.println(a.get(j) + \n\" \"\n\n+ b.get(j) + \n\" \"\n+ c.get(j)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nn = \n9\n; \n\np = \n6\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < \n1100\n; i++) \n\nrd[i] = cd[i] = wt[i] = \n0\n; \n\n\nint\narr[][] = { { \n7\n, \n4\n, \n98\n}, \n\n{ \n5\n, \n9\n, \n72\n}, \n\n{ \n4\n, \n6\n, \n10\n}, \n\n{ \n2\n, \n8\n, \n22\n}, \n\n{ \n9\n, \n7\n, \n17\n}, \n\n{ \n3\n, \n1\n, \n66\n} }; \n\nsolve(arr); \n\n} \n}", "index": 251, "complexity": "1"}
{"forwhile": "class GFG { static int policeThief(char arr[], int n, int k) { int res = 0; ArrayList<Integer> thi = new ArrayList<Integer>(); ArrayList<Integer> pol = new ArrayList<Integer>(); int i = 0; while(i < n) { if(arr[i] == 'P') pol.add(i); else if(arr[i] == 'T') thi.add(i); i++; } int l = 0, r = 0; for(; l < thi.size() && r < pol.size(); ) { if(Math.abs(thi.get(l) - pol.get(r)) <= k) { res++; l++; r++; } else if(thi.get(l) < pol.get(r)) l++; else r++; } return res; } public static void main(String args[]) { int k, n; char arr1[] = new char[] { 'P', 'T', 'T', 'P', 'T' }; k = 2; n = arr1.length; System.out.println(\"Maximum thieves caught: \"+policeThief(arr1, n, k)); char arr2[] = new char[] { 'T', 'T', 'P', 'P', 'T', 'P' }; k = 2; n = arr2.length; System.out.println(\"Maximum thieves caught: \"+policeThief(arr2, n, k)); char arr3[] = new char[]{ 'P', 'T', 'P', 'T', 'T', 'P' }; k = 3; n = arr3.length; System.out.println(\"Maximum thieves caught: \"+policeThief(arr3, n, k)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\npoliceThief(\nchar\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nArrayList<Integer> thi = \nnew\nArrayList<Integer>(); \n\nArrayList<Integer> pol = \nnew\nArrayList<Integer>(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(arr[i] == \n'P'\n) \n\npol.add(i); \n\nelse\nif\n(arr[i] == \n'T'\n) \n\nthi.add(i); \n\n} \n\n\n\n\n\n\nint\nl = \n0\n, r = \n0\n; \n\nwhile\n(l < thi.size() && r < pol.size()) { \n\n\n\n\nif\n(Math.abs(thi.get(l) - pol.get(r)) <= k) { \n\nres++; \n\nl++; \n\nr++; \n\n} \n\n\n\n\nelse\nif\n(thi.get(l) < pol.get(r)) \n\nl++; \n\nelse\n\nr++; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nk, n; \n\nchar\narr1[] =\nnew\nchar\n[] { \n'P'\n, \n'T'\n, \n'T'\n, \n\n'P'\n, \n'T'\n}; \n\nk = \n2\n; \n\nn = arr1.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr1, n, k)); \n\n\nchar\narr2[] =\nnew\nchar\n[] { \n'T'\n, \n'T'\n, \n'P'\n, \n'P'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n2\n; \n\nn = arr2.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr2, n, k)); \n\n\nchar\narr3[] = \nnew\nchar\n[]{ \n'P'\n, \n'T'\n, \n'P'\n, \n'T'\n, \n\n'T'\n, \n'P'\n}; \n\nk = \n3\n; \n\nn = arr3.length; \n\nSystem.out.println(\n\"Maximum thieves caught: \"\n\n+policeThief(arr3, n, k)); \n\n} \n}", "index": 252, "complexity": "1"}
{"forwhile": "class GFG { static int minProductSubset(int a[], int n) { if (n == 1) return a[0]; int negmax = Integer.MIN_VALUE; int posmin = Integer.MAX_VALUE; int count_neg = 0, count_zero = 0; int product = 1; int i = 0; while(i < n) { if (a[i] == 0) { count_zero++; i++; continue; } if (a[i] < 0) { count_neg++; negmax = Math.max(negmax, a[i]); } if (a[i] > 0 && a[i] < posmin) posmin = a[i]; product *= a[i]; i++; } if (count_zero == n || (count_neg == 0 && count_zero > 0)) return 0; if (count_neg == 0) return posmin; if (count_neg % 2 == 0 && count_neg != 0) { product = product / negmax; } return product; } public static void main(String[] args) { int a[] = { -1, -1, -2, 4, 3 }; int n = 5; System.out.println(minProductSubset(a, n)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nminProductSubset(\nint\na[], \nint\nn) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\na[\n0\n]; \n\n\n\n\n\n\n\n\n\n\n\n\nint\nnegmax = Integer.MIN_VALUE; \n\nint\nposmin = Integer.MAX_VALUE; \n\nint\ncount_neg = \n0\n, count_zero = \n0\n; \n\nint\nproduct = \n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\nif\n(a[i] == \n0\n){ \n\ncount_zero++; \n\ncontinue\n; \n\n} \n\n\n\n\n\n\nif\n(a[i] < \n0\n) \n\n{ \n\ncount_neg++; \n\nnegmax = Math.max(negmax, a[i]); \n\n} \n\n\n\n\nif\n(a[i] > \n0\n&& a[i] < posmin) \n\nposmin = a[i]; \n\n\nproduct *= a[i]; \n\n} \n\n\n\n\n\n\n\n\nif\n(count_zero == n || \n\n(count_neg == \n0\n&& count_zero > \n0\n)) \n\nreturn\n0\n; \n\n\n\n\nif\n(count_neg == \n0\n) \n\nreturn\nposmin; \n\n\n\n\n\n\nif\n(count_neg % \n2\n== \n0\n&& count_neg != \n0\n) \n\n{ \n\n\n\n\n\n\n\n\nproduct = product / negmax; \n\n} \n\n\nreturn\nproduct; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\na[] = { -\n1\n, -\n1\n, -\n2\n, \n4\n, \n3\n}; \n\nint\nn = \n5\n; \n\n\nSystem.out.println(minProductSubset(a, n)); \n\n} \n}", "index": 253, "complexity": "1"}
{"forwhile": "class GFG { static int maxProductSubset(int a[], int n) { if (n == 1) { return a[0]; } int max_neg = Integer.MIN_VALUE; int count_neg = 0, count_zero = 0; int prod = 1; int i = 0; while(i < n) { if (a[i] == 0) { count_zero++; i++; continue; } if (a[i] < 0) { count_neg++; max_neg = Math.max(max_neg, a[i]); } prod = prod * a[i]; i++; } if (count_zero == n) { return 0; } if (count_neg % 2 == 1) { if (count_neg == 1 && count_zero > 0 && count_zero + count_neg == n) { return 0; } prod = prod / max_neg; } return prod; } public static void main(String[] args) { int a[] = {-1, -1, -2, 4, 3}; int n = a.length; System.out.println(maxProductSubset(a, n)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nmaxProductSubset(\nint\na[], \nint\nn) { \n\nif\n(n == \n1\n) { \n\nreturn\na[\n0\n]; \n\n} \n\n\n\n\n\n\n\n\nint\nmax_neg = Integer.MIN_VALUE; \n\nint\ncount_neg = \n0\n, count_zero = \n0\n; \n\nint\nprod = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n(a[i] == \n0\n) { \n\ncount_zero++; \n\ncontinue\n; \n\n} \n\n\n\n\n\n\nif\n(a[i] < \n0\n) { \n\ncount_neg++; \n\nmax_neg = Math.max(max_neg, a[i]); \n\n} \n\n\nprod = prod * a[i]; \n\n} \n\n\n\n\nif\n(count_zero == n) { \n\nreturn\n0\n; \n\n} \n\n\n\n\n\n\nif\n(count_neg % \n2\n== \n1\n) { \n\n\n\n\n\n\nif\n(count_neg == \n1\n\n&& count_zero > \n0\n\n&& count_zero + count_neg == n) { \n\nreturn\n0\n; \n\n} \n\n\n\n\n\n\n\n\nprod = prod / max_neg; \n\n} \n\n\nreturn\nprod; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\na[] = {-\n1\n, -\n1\n, -\n2\n, \n4\n, \n3\n}; \n\nint\nn = a.length; \n\nSystem.out.println(maxProductSubset(a, n)); \n\n\n} \n}", "index": 254, "complexity": "1"}
{"forwhile": "class GFG { static int MinOperation( int a[], int n, int k) { int result = 0; int i = 0; while (i < n) { if (a[i] != 1 && a[i] > k) { result = result + Math.min(a[i] % k, k - a[i] % k); } else { result = result + k - a[i]; } i++; } return result; } public static void main (String[] args) { int arr[] = { 4 , 5 , 6 }; int n = arr.length; int k = 5; System.out.println(MinOperation(arr, n, k)); } }", "src": "class\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nn, \nint\nk) \n{ \n\n\nint\nresult = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(a[i] != \n1\n&& a[i] > k) \n\n{ \n\nresult = result + \n\nMath.min(a[i] % k, \n\nk - a[i] % k); \n\n} \n\nelse\n\n{ \n\n\n\n\n\n\n\n\n\n\nresult = result + k - a[i]; \n\n} \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\narr[] = {\n4\n, \n5\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n5\n; \n\nSystem.out.println(MinOperation(arr, n, k)); \n} \n}", "index": 256, "complexity": "1"}
{"forwhile": "class GFG { public static int maxSum(int stack1[], int stack2[], int stack3[], int n1, int n2, int n3) { int sum1 = 0, sum2 = 0, sum3 = 0; int i = 0; while(i < n1) { sum1 += stack1[i]; i++; } i = 0; while(i < n2) { sum2 += stack2[i]; i++; } i = 0; while(i < n3) { sum3 += stack3[i]; i++; } int top1 = 0, top2 = 0, top3 = 0; int ans = 0; for(; true;) { if(top1 == n1 || top2 == n2 || top3 == n3) return 0; if(sum1 == sum2 && sum2 == sum3) return sum1; if(sum1 >= sum2 && sum1 >= sum3) sum1 -= stack1[top1++]; else if(sum2 >= sum3 && sum2 >= sum3) sum2 -= stack2[top2++]; else if(sum3 >= sum2 && sum3 >= sum1) sum3 -= stack3[top3++]; } } public static void main(String[] args) { int stack1[] = { 3, 2, 1, 1, 1 }; int stack2[] = { 4, 3, 2 }; int stack3[] = { 1, 1, 4, 1 }; int n1 = stack1.length; int n2 = stack2.length; int n3 = stack3.length; System.out.println(maxSum(stack1, stack2, stack3, n1, n2, n3)); } }", "src": "class\nGFG { \n\n\n\n\n\n\npublic\nstatic\nint\nmaxSum(\nint\nstack1[], \nint\nstack2[], \n\nint\nstack3[], \nint\nn1, \nint\nn2, \n\nint\nn3) \n\n{ \n\nint\nsum1 = \n0\n, sum2 = \n0\n, sum3 = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n1; i++) \n\nsum1 += stack1[i]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n2; i++) \n\nsum2 += stack2[i]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i < n3; i++) \n\nsum3 += stack3[i]; \n\n\n\n\n\n\nint\ntop1 =\n0\n, top2 = \n0\n, top3 = \n0\n; \n\nint\nans = \n0\n; \n\nwhile\n(\ntrue\n) \n\n{ \n\n\n\nif\n(top1 == n1 || top2 == n2 || top3 == n3) \n\nreturn\n0\n; \n\n\n\n\nif\n(sum1 == sum2 && sum2 == sum3) \n\nreturn\nsum1; \n\n\n\n\n\n\nif\n(sum1 >= sum2 && sum1 >= sum3) \n\nsum1 -= stack1[top1++]; \n\nelse\nif\n(sum2 >= sum3 && sum2 >= sum3) \n\nsum2 -= stack2[top2++]; \n\nelse\nif\n(sum3 >= sum2 && sum3 >= sum1) \n\nsum3 -= stack3[top3++]; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nstack1[] = { \n3\n, \n2\n, \n1\n, \n1\n, \n1\n}; \n\nint\nstack2[] = { \n4\n, \n3\n, \n2\n}; \n\nint\nstack3[] = { \n1\n, \n1\n, \n4\n, \n1\n}; \n\n\nint\nn1 = stack1.length; \n\nint\nn2 = stack2.length; \n\nint\nn3 = stack3.length; \n\n\nSystem.out.println(maxSum(stack1, stack2, \n\nstack3, n1, n2, n3)); \n\n} \n\n}", "index": 257, "complexity": "1"}
{"forwhile": "class GFG { static void printVector(Vector<Integer> v) { System.out.println(v.size()); int i = 0; while(i < v.size()) System.out.print(v.get(i) + \" \"); System.out.println(); } static void findTwoGroup(int n) { int sum = n * (n + 1) / 2; int group1Sum = sum / 2; Vector<Integer> group1 = new Vector<Integer>(); Vector<Integer> group2 = new Vector<Integer>(); int i = n; while(i > 0) { if(group1Sum - i >= 0) { group1.add(i); group1Sum -= i; } else { group2.add(i); } i--; } printVector(group1); printVector(group2); } public static void main (String[] args) { int n = 5; findTwoGroup(n); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nvoid\nprintVector(Vector<Integer> v) \n\n{ \n\n\n\nSystem.out.println(v.size()); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < v.size(); i++) \n\nSystem.out.print(v.get(i) + \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nfindTwoGroup(\nint\nn) \n\n{ \n\n\n\nint\nsum = n * (n + \n1\n) / \n2\n; \n\n\n\n\nint\ngroup1Sum = sum / \n2\n; \n\n\nVector<Integer> group1 = \nnew\nVector<Integer>(); \n\nVector<Integer> group2 = \nnew\nVector<Integer>(); \n\n\nfor\n(\nint\ni = n; i > \n0\n; i--) { \n\n\n\n\n\n\n\n\nif\n(group1Sum - i >= \n0\n) { \n\n\ngroup1.add(i); \n\n\n\n\ngroup1Sum -= i; \n\n} \n\nelse\n{ \n\ngroup2.add(i); \n\n} \n\n} \n\n\n\n\nprintVector(group1); \n\nprintVector(group2); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nn = \n5\n; \n\nfindTwoGroup(n); \n\n} \n}", "index": 258, "complexity": "1"}
{"forwhile": "public\\nclass\\nGFG { \\n\\n\\n\\n\\n\\nstatic\\nint\\ncost(\\nint\\n[]a, \\nint\\nn) \\n\\n{ \\n\\nint\\nmin = a[\\n0\\]; \\n\\n\\n\\n\\nint\\ni = \\n1\\; while(i< a.length) \\n\\n{ \\n\\nif\\n(a[i] < min) \\n\\nmin = a[i]; \\n\\ni++; \\n\\n} \\n\\n\\n\\n\\n\\nreturn\\n(n - \\n1\\) * min; \\n\\n} \\n\\n\\n\\n\\n\\nstatic\\npublic\\nvoid\\nmain (String[] args) \\n\\n{ \\n\\n\\nint\\n[]a = { \\n4\\, \\n3\\, \\n2\\}; \\n\\nint\\nn = a.length; \\n\\n\\nSystem.out.println(cost(a, n)); \\n\\n} \\n}", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\ncost(\nint\n[]a, \nint\nn) \n\n{ \n\nint\nmin = a[\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i< a.length; i++) \n\n{ \n\nif\n(a[i] < min) \n\nmin = a[i]; \n\n} \n\n\n\n\n\n\nreturn\n(n - \n1\n) * min; \n\n} \n\n\n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\n\nint\n[]a = { \n4\n, \n3\n, \n2\n}; \n\nint\nn = a.length; \n\n\nSystem.out.println(cost(a, n)); \n\n} \n}", "index": 259, "complexity": "1"}
{"forwhile": "class GFG { static void digitsNum(int N) { if(N == 0) System.out.println(\"0\"); if(N % 9 != 0) System.out.print((N % 9)); int i = 1; while(i <= (N / 9)) { System.out.print(\"9\"); i++; } i = 1; while(i <= N) { System.out.print(\"0\"); i++; } System.out.print(\"\"); } public static void main (String[] args) { int N = 5; System.out.print(\"The number is : \"); digitsNum(N); } }", "src": "class\nGFG \n{ \n\nstatic\nvoid\ndigitsNum(\nint\nN) \n{ \n\n\n\nif\n(N == \n0\n) \n\nSystem.out.println(\n\"0\"\n); \n\n\n\n\n\n\n\nif\n(N % \n9\n!= \n0\n) \n\nSystem.out.print((N % \n9\n)); \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= (N / \n9\n); ++i) \n\nSystem.out.print(\n\"9\"\n); \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= N; ++i) \n\nSystem.out.print(\n\"0\"\n); \n\nSystem.out.print(\n\"\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nN = \n5\n; \n\nSystem.out.print(\n\"The number is : \"\n); \n\ndigitsNum(N); \n\n} \n}", "index": 260, "complexity": "1"}
{"forwhile": "class GFG { static void findSmallest(int m, int s) { if (s == 0) { System.out.print(m == 1 ? \"Smallest number is 0\" : \"Not possible\"); return; } if (s > 9 * m) { System.out.println(\"Not possible\"); return; } int[] res = new int[m]; s -= 1; int i = m - 1; while (i > 0) { if (s > 9) { res[i] = 9; s -= 9; } else { res[i] = s; s = 0; } i--; } res[0] = s + 1; System.out.print(\"Smallest number is \"); int i = 0; while (i < m) System.out.print(res[i++]); } public static void main(String[] args) { int s = 9, m = 2; findSmallest(m, s); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nvoid\nfindSmallest(\nint\nm, \nint\ns) \n\n{ \n\n\n\n\n\nif\n(s == \n0\n) \n\n{ \n\nSystem.out.print(m == \n1\n? \n\"Smallest number is 0\"\n: \n\"Not possible\"\n); \n\n\nreturn\n; \n\n} \n\n\n\n\nif\n(s > \n9\n*m) \n\n{ \n\nSystem.out.println(\n\"Not possible\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nint\n[] res = \nnew\nint\n[m]; \n\n\n\n\n\n\n\n\ns -= \n1\n; \n\n\n\n\nfor\n(\nint\ni=m-\n1\n; i>\n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(s > \n9\n) \n\n{ \n\nres[i] = \n9\n; \n\ns -= \n9\n; \n\n} \n\nelse\n\n{ \n\nres[i] = s; \n\ns = \n0\n; \n\n} \n\n} \n\n\n\n\n\n\nres[\n0\n] = s + \n1\n; \n\n\n\n\n\nSystem.out.print(\n\"Smallest number is \"\n); \n\nfor\n(\nint\ni=\n0\n; i<m; i++) \n\nSystem.out.print(res[i]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\ns = \n9\n, m = \n2\n; \n\nfindSmallest(m, s); \n\n} \n}", "index": 261, "complexity": "1"}
{"forwhile": "class KeyComparator implements Comparator<Key> { public int compare(Key k1, Key k2) { if (k1.freq < k2.freq) return 1; else if (k1.freq > k2.freq) return -1; return 0; } } class Key { int freq; char ch; Key(int val, char c) { freq = val; ch = c; } } class GFG { static int MAX_CHAR = 26; static void rearrangeString(String str) { int n = str.length(); int[] count = new int[MAX_CHAR]; int i = 0; while (i < n) { count[str.charAt(i) - 'a']++; i++; } PriorityQueue<Key> pq = new PriorityQueue<>(new KeyComparator()); char c = 'a'; while (c <= 'z') { int val = c - 'a'; if (count[val] > 0) pq.add(new Key(count[val], c)); c++; } str = \"\"; Key prev = new Key(-1, '#'); for (; !pq.isEmpty(); ) { Key k = pq.peek(); pq.poll(); str = str + k.ch; if (prev.freq > 0) pq.add(prev); k.freq--; prev = k; } if (n != str.length()) System.out.println(\" Not valid String \"); else System.out.println(str); } public static void main(String args[]) { String str = \"bbbaa\"; rearrangeString(str); } }", "src": "class\nKeyComparator \nimplements\nComparator<Key> { \n\n\n\n\npublic\nint\ncompare(Key k1, Key k2) \n\n{ \n\nif\n(k1.freq < k2.freq) \n\nreturn\n1\n; \n\nelse\nif\n(k1.freq > k2.freq) \n\nreturn\n-\n1\n; \n\nreturn\n0\n; \n\n} \n} \n\nclass\nKey { \n\nint\nfreq; \n\n\nchar\nch; \n\nKey(\nint\nval, \nchar\nc) \n\n{ \n\nfreq = val; \n\nch = c; \n\n} \n} \n\nclass\nGFG { \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\nstatic\nvoid\nrearrangeString(String str) \n\n{ \n\nint\nn = str.length(); \n\n\n\n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[str.charAt(i) - \n'a'\n]++; \n\n\n\n\n\n\nPriorityQueue<Key> pq = \nnew\nPriorityQueue<>(\nnew\n\nKeyComparator()); \n\nfor\n(\nchar\nc = \n'a'\n; c <= \n'z'\n; c++) { \n\nint\nval = c - \n'a'\n; \n\nif\n(count[val] > \n0\n) \n\npq.add(\nnew\nKey(count[val], c)); \n\n} \n\n\n\n\nstr = \n\"\"\n; \n\n\n\n\n\n\n\n\nKey prev = \nnew\nKey(-\n1\n, \n'#'\n); \n\n\n\n\nwhile\n(pq.size() != \n0\n) { \n\n\n\n\n\n\nKey k = pq.peek(); \n\npq.poll(); \n\nstr = str + k.ch; \n\n\n\n\n\n\n\n\nif\n(prev.freq > \n0\n) \n\npq.add(prev); \n\n\n\n\n\n\n(k.freq)--; \n\nprev = k; \n\n} \n\n\n\n\n\n\nif\n(n != str.length()) \n\nSystem.out.println(\n\" Not valid String \"\n); \n\nelse\n\nSystem.out.println(str); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"bbbaa\"\n; \n\nrearrangeString(str); \n\n} \n}", "index": 262, "complexity": "1"}
{"forwhile": "public\\nclass\\nGfG{ \\n\\n\\n\\n\\npublic\\nstatic\\nString noAdjacentDup(String s1) \\n\\n{ \\n\\nint\\nn = s1.length(); \\n\\nchar\\n[] s = s1.toCharArray(); \\n\\ni = \\n1\\n; \\nwhile\\n(i < n) \\n\\n{ \\n\\n\\n\\n\\nif\\n(s[i] == s[i - \\n1\\n]) \\n\\n{ \\n\\n\\n\\ns[i] = \\n'a'\\n; \\n\\n\\n\\n\\n\\n\\nfor\\n(; s[i] == s[i - \\n1\\n] || \\n\\n(i + \\n1\\n< n && s[i] == s[i + \\n1\\n]); s[i]++) { \\n\\n}\\n\\n\\ni++; \\n\\n} \\n\\n} \\n\\nreturn\\n(\\nnew\\nString(s)); \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String argc[]){ \\n\\n\\nString s = \\n\"geeksforgeeks\"\\n; \\n\\nSystem.out.println(noAdjacentDup(s)); \\n\\n\\n} \\n\\n}", "src": "public\nclass\nGfG{ \n\n\n\n\npublic\nstatic\nString noAdjacentDup(String s1) \n\n{ \n\nint\nn = s1.length(); \n\nchar\n[] s = s1.toCharArray(); \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nif\n(s[i] == s[i - \n1\n]) \n\n{ \n\n\n\ns[i] = \n'a'\n; \n\n\n\n\n\n\n\n\nwhile\n(s[i] == s[i - \n1\n] || \n\n(i + \n1\n< n && s[i] == s[i + \n1\n])) \n\ns[i]++; \n\n\ni++; \n\n} \n\n} \n\nreturn\n(\nnew\nString(s)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\n\nString s = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(noAdjacentDup(s)); \n\n\n} \n\n}", "index": 263, "complexity": "1"}
{"forwhile": "class Main { static int getMissingNo(int a[], int n) { int i, total; total = (n + 1) * (n + 2) / 2; i = 0; while(i < n) total -= a[i++]; return total; } public static void main(String args[]) { int a[] = { 1, 2, 4, 5, 6 }; int miss = getMissingNo(a, 5); System.out.println(miss); } }", "src": "class\nMain { \n\n\n\nstatic\nint\ngetMissingNo(\nint\na[], \nint\nn) \n\n{ \n\nint\ni, total; \n\ntotal = (n + \n1\n) * (n + \n2\n) / \n2\n; \n\nfor\n(i = \n0\n; i < n; i++) \n\ntotal -= a[i]; \n\nreturn\ntotal; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\na[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\nmiss = getMissingNo(a, \n5\n); \n\nSystem.out.println(miss); \n\n} \n}", "index": 265, "complexity": "1"}
{"forwhile": "class SecondSmallest  {  static void print2Smallest( int arr[])  {  int first, second, arr_size = arr.length;  if (arr_size < 2)  {  System.out.println( \" Invalid Input \");  return ;  }  first = second = Integer.MAX_VALUE;  int i = 0;  while(i < arr_size )  {  if (arr[i] < first)  {  second = first;  first = arr[i];  }  else if (arr[i] < second && arr[i] != first)  second = arr[i];  i ++;  }  if (second == Integer.MAX_VALUE)  System.out.println(\"There is no second\"+ \"smallest element\");  else System.out.println(\"The smallest element is \"+ first + \" and second Smallest\"+ \" element is \"+ second);  }  public static void main (String[] args)  {  int arr[] = { 12, 13, 1, 10, 34, 1};  print2Smallest(arr);  }  }", "src": "class\nSecondSmallest \n{ \n\n\n\nstatic\nvoid\nprint2Smallest(\nint\narr[]) \n\n{ \n\nint\nfirst, second, arr_size = arr.length; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MAX_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] < first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] < second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nif\n(second == Integer.MAX_VALUE) \n\nSystem.out.println(\n\"There is no second\"\n+ \n\n\"smallest element\"\n); \n\nelse\n\nSystem.out.println(\n\"The smallest element is \"\n+ \n\nfirst + \n\" and second Smallest\"\n+ \n\n\" element is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nprint2Smallest(arr); \n\n} \n}", "index": 266, "complexity": "1"}
{"forwhile": "class Main { static int ceilSearch(int arr[], int low, int high, int x) { int i; if (x <= arr[low]) return low; i=low; while(i < high) { if (arr[i] == x) return i; if(arr[i] < x && arr[i+1] >= x) return i+1; i++; } return -1; } public static void main (String[] args) { int arr[] = { 1, 2, 8, 10, 10, 12, 19}; int n = arr.length; int x = 3; int index = ceilSearch(arr, 0, n-1, x); if(index == -1) System.out.println(\"Ceiling of \" + x + \" doesn't exist in array\"); else System.out.println(\"ceiling of \" + x + \" is \" + arr[index]); } }", "src": "class\nMain \n{ \n\n\n\nstatic\nint\nceilSearch(\nint\narr[], \nint\nlow, \nint\nhigh, \nint\nx) \n\n{ \n\nint\ni; \n\n\n\n\nif\n(x <= arr[low]) \n\nreturn\nlow; \n\n\n\n\nfor\n(i = low; i < high; i++) \n\n{ \n\nif\n(arr[i] == x) \n\nreturn\ni; \n\n\n\n\nif\n(arr[i] < x && arr[i+\n1\n] >= x) \n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n8\n, \n10\n, \n10\n, \n12\n, \n19\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\nindex = ceilSearch(arr, \n0\n, n-\n1\n, x); \n\nif\n(index == -\n1\n) \n\nSystem.out.println(\n\"Ceiling of \"\n+x+\n\" doesn't exist in array\"\n); \n\nelse\n\nSystem.out.println(\n\"ceiling of \"\n+x+\n\" is \"\n+arr[index]); \n\n} \n}", "index": 267, "complexity": "1"}
{"forwhile": "class Main { static int countOccurrences(int arr[], int n, int x) { int res = 0; int i=0; while(i<n) if(x == arr[i]) res++; i++; return res; } public static void main(String args[]) { int arr[] = { 1, 2, 2, 2, 2, 3, 4, 7, 8, 8 }; int n = arr.length; int x = 2; System.out.println(countOccurrences(arr, n, x)); } }", "src": "class\nMain \n{ \n\n\n\nstatic\nint\ncountOccurrences(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nif\n(x == arr[i]) \n\nres++; \n\nreturn\nres; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n2\n, \n3\n, \n4\n, \n7\n,\n8\n,\n8\n}; \n\nint\nn = arr.length; \n\nint\nx = \n2\n; \n\nSystem.out.println(countOccurrences(arr, n, x)); \n\n} \n}", "index": 268, "complexity": "1"}
{"forwhile": "class GFG { static void printTwoElements(int arr[], int size) { int i; System.out.print(\"The repeating element is \"); i = 0; while(i < size) { int abs_val = Math.abs(arr[i]); if(arr[abs_val - 1] > 0) arr[abs_val - 1] = -arr[abs_val - 1]; else System.out.println(abs_val); i++; } System.out.print(\"And the missing element is \"); i = 0; while(i < size) { if(arr[i] > 0) System.out.println(i + 1); i++; } } public static void main(String[] args) { int arr[] = { 7, 3, 4, 5, 5, 6, 2 }; int n = arr.length; printTwoElements(arr, n); } }", "src": "class\nGFG { \n\n\nstatic\nvoid\nprintTwoElements(\nint\narr[], \nint\nsize) \n\n{ \n\nint\ni; \n\nSystem.out.print(\n\"The repeating element is \"\n); \n\n\nfor\n(i = \n0\n; i < size; i++) { \n\nint\nabs_val = Math.abs(arr[i]); \n\nif\n(arr[abs_val - \n1\n] > \n0\n) \n\narr[abs_val - \n1\n] = -arr[abs_val - \n1\n]; \n\nelse\n\nSystem.out.println(abs_val); \n\n} \n\n\nSystem.out.print(\n\"And the missing element is \"\n); \n\nfor\n(i = \n0\n; i < size; i++) { \n\nif\n(arr[i] > \n0\n) \n\nSystem.out.println(i + \n1\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n7\n, \n3\n, \n4\n, \n5\n, \n5\n, \n6\n, \n2\n}; \n\nint\nn = arr.length; \n\nprintTwoElements(arr, n); \n\n} \n}", "index": 269, "complexity": "1"}
{"forwhile": "class GFG { static int x, y; static void getTwoElements(int arr[], int n) { int xor1; int set_bit_no; int i; x = 0; y = 0; xor1 = arr[0]; i = 1; while(i < n) { xor1 = xor1 ^ arr[i]; i++; } i = 1; while(i <= n) { xor1 = xor1 ^ i; i++; } set_bit_no = xor1 & ~(xor1 - 1); i = 0; while(i < n) { if((arr[i] & set_bit_no) != 0) x = x ^ arr[i]; else y = y ^ arr[i]; i++; } i = 1; while(i <= n) { if((i & set_bit_no) != 0) x = x ^ i; else y = y ^ i; i++; } } public static void main(String[] args) { int arr[] = { 1, 3, 4, 5, 1, 6, 2}; int n = arr.length; getTwoElements(arr, n); System.out.println(\" The missing element is \" + x + \"and the \" + \"repeating number is \" + y); } }", "src": "class\nGFG { \n\nstatic\nint\nx, y; \n\n\nstatic\nvoid\ngetTwoElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nxor1; \n\n\n\n\nint\nset_bit_no; \n\n\nint\ni; \n\nx = \n0\n; \n\ny = \n0\n; \n\n\nxor1 = arr[\n0\n]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nxor1 = xor1 ^ arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i <= n; i++) \n\nxor1 = xor1 ^ i; \n\n\n\n\nset_bit_no = xor1 & ~(xor1 - \n1\n); \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n((arr[i] & set_bit_no) != \n0\n) \n\n\n\nx = x ^ arr[i]; \n\n\nelse\n\n\n\ny = y ^ arr[i]; \n\n} \n\nfor\n(i = \n1\n; i <= n; i++) { \n\nif\n((i & set_bit_no) != \n0\n) \n\n\n\nx = x ^ i; \n\n\nelse\n\n\n\ny = y ^ i; \n\n} \n\n\n\n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n4\n, \n5\n, \n1\n, \n6\n, \n2\n}; \n\n\nint\nn = arr.length; \n\ngetTwoElements(arr, n); \n\nSystem.out.println(\n\" The missing element is \"\n\n+ x + \n\"and the \"\n\n+ \n\"repeating number is \"\n\n+ y); \n\n} \n}", "index": 270, "complexity": "1"}
{"forwhile": "class Main {\n\nstatic int linearSearch(int arr[], int n) {\nint i = 0;\nwhile(i < n) {\nif(arr[i] == i)\nreturn i;\ni++;\n}\nreturn -1;\n}\n\npublic static void main(String args[]) {\nint arr[] = {-10, -1, 0, 3, 10, 11, 30, 50, 100};\nint n = arr.length;\nSystem.out.println(\"Fixed Point is \" + linearSearch(arr, n));\n}\n}", "src": "class\nMain \n{ \n\nstatic\nint\nlinearSearch(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] == i) \n\nreturn\ni; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {-\n10\n, -\n1\n, \n0\n, \n3\n, \n10\n, \n11\n, \n30\n, \n50\n, \n100\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Fixed Point is \"\n\n+ linearSearch(arr, n)); \n\n} \n}", "index": 271, "complexity": "1"}
{"forwhile": "class\nMain \n{ \n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\nmax = arr[low]; \n\nint\ni = low; \n\nwhile(i <= high) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\ni++; \n\n} \n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n30\n, \n40\n, \n50\n, \n60\n, \n70\n, \n23\n, \n20\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"The maximum element is \"\n+ \n\nfindMaximum(arr, \n0\n, n-\n1\n)); \n\n} \n}", "src": "class\nMain \n{ \n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\nmax = arr[low]; \n\nint\ni; \n\nfor\n(i = low; i <= high; i++) \n\n{ \n\nif\n(arr[i] > max) \n\nmax = arr[i]; \n\n} \n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n30\n, \n40\n, \n50\n, \n60\n, \n70\n, \n23\n, \n20\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"The maximum element is \"\n+ \n\nfindMaximum(arr, \n0\n, n-\n1\n)); \n\n} \n}", "index": 272, "complexity": "1"}
{"forwhile": "class PairDifference { static boolean findPair(int arr[], int n) { int size = arr.length; int i = 0, j = 1; for(; i < size && j < size;){ if(i != j && arr[j]-arr[i] == n) { System.out.print(\"Pair Found: \"+ \"( \"+arr[i]+\", \"+ arr[j]+\" )\"); return true; } else if(arr[j] - arr[i] < n) j++; else i++; } System.out.print(\"No such pair\"); return false; } public static void main (String[] args) { int arr[] = { 1, 8, 30, 40, 100 }; int n = 60; findPair(arr, n); } }", "src": "class\nPairDifference \n{ \n\n\n\nstatic\nboolean\nfindPair(\nint\narr[],\nint\nn) \n\n{ \n\nint\nsize = arr.length; \n\n\n\n\nint\ni = \n0\n, j = \n1\n; \n\n\n\n\nwhile\n(i < size && j < size) \n\n{ \n\nif\n(i != j && arr[j]-arr[i] == n) \n\n{ \n\nSystem.out.print(\n\"Pair Found: \"\n+ \n\n\"( \"\n+arr[i]+\n\", \"\n+ arr[j]+\n\" )\"\n); \n\nreturn\ntrue\n; \n\n} \n\nelse\nif\n(arr[j] - arr[i] < n) \n\nj++; \n\nelse\n\ni++; \n\n} \n\n\nSystem.out.print(\n\"No such pair\"\n); \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n8\n, \n30\n, \n40\n, \n100\n}; \n\nint\nn = \n60\n; \n\nfindPair(arr,n); \n\n} \n}", "index": 273, "complexity": "1"}
{"forwhile": "class GFG { public static void print2largest(int arr[], int arr_size) { int i, first, second; if (arr_size < 2) { System.out.print(\" Invalid Input \"); return; } first = second = Integer.MIN_VALUE; i = 0; while(i < arr_size) { if (arr[i] > first) { second = first; first = arr[i]; } else if (arr[i] > second && arr[i] != first) second = arr[i]; i++; } if (second == Integer.MIN_VALUE) System.out.print(\"There is no second largest\"+ \" element\\n\"); else System.out.print(\"The second largest element\"+ \" is \"+ second); } public static void main(String[] args) { int arr[] = {12, 35, 1, 10, 34, 1}; int n = arr.length; print2largest(arr, n); } }", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nvoid\nprint2largest(\nint\narr[], \n\nint\narr_size) \n\n{ \n\nint\ni, first, second; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.print(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MIN_VALUE; \n\nfor\n(i = \n0\n; i < arr_size ; i++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\n\nif\n(second == Integer.MIN_VALUE) \n\nSystem.out.print(\n\"There is no second largest\"\n+ \n\n\" element\\n\"\n); \n\nelse\n\nSystem.out.print(\n\"The second largest element\"\n+ \n\n\" is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n35\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nint\nn = arr.length; \n\nprint2largest(arr, n); \n\n} \n}", "index": 274, "complexity": "1"}
{"forwhile": "class Main { static void printFirstRepeating(int arr[]) { int min = -1; HashSet<Integer> set = new HashSet<>(); int i = arr.length - 1; while(i >= 0) { if(set.contains(arr[i])) min = i; else set.add(arr[i]); i--; } if(min != -1) System.out.println(\"The first repeating element is \" + arr[min]); else System.out.println(\"There are no repeating elements\"); } public static void main (String[] args) throws java.lang.Exception { int arr[] = {10, 5, 3, 4, 3, 5, 6}; printFirstRepeating(arr); }} ", "src": "class\nMain \n{ \n\n\n\nstatic\nvoid\nprintFirstRepeating(\nint\narr[]) \n\n{ \n\n\n\nint\nmin = -\n1\n; \n\n\n\n\nHashSet<Integer> set = \nnew\nHashSet<>(); \n\n\n\n\nfor\n(\nint\ni=arr.length-\n1\n; i>=\n0\n; i--) \n\n{ \n\n\n\nif\n(set.contains(arr[i])) \n\nmin = i; \n\n\nelse\n\n\nset.add(arr[i]); \n\n} \n\n\n\n\nif\n(min != -\n1\n) \n\nSystem.out.println(\n\"The first repeating element is \"\n+ arr[min]); \n\nelse\n\nSystem.out.println(\n\"There are no repeating elements\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \nthrows\njava.lang.Exception \n\n{ \n\nint\narr[] = {\n10\n, \n5\n, \n3\n, \n4\n, \n3\n, \n5\n, \n6\n}; \n\nprintFirstRepeating(arr); \n\n} \n}", "index": 275, "complexity": "1"}
{"forwhile": "class FindCommon { void findCommon(int ar1[], int ar2[], int ar3[]) { int i = 0, j = 0, k = 0; for(; i < ar1.length && j < ar2.length && k < ar3.length;) { if(ar1[i] == ar2[j] && ar2[j] == ar3[k]) { System.out.print(ar1[i]+\" \"); i++; j++; k++; } else if(ar1[i] < ar2[j]) i++; else if(ar2[j] < ar3[k]) j++; else k++; } } public static void main(String args[]) { FindCommon ob = new FindCommon(); int ar1[] = {1, 5, 10, 20, 40, 80}; int ar2[] = {6, 7, 20, 80, 100}; int ar3[] = {3, 4, 15, 20, 30, 70, 80, 120}; System.out.print(\"Common elements are \"); ob.findCommon(ar1, ar2, ar3); } } ", "src": "class\nFindCommon \n{ \n\n\n\nvoid\nfindCommon(\nint\nar1[], \nint\nar2[], \nint\nar3[]) \n\n{ \n\n\n\nint\ni = \n0\n, j = \n0\n, k = \n0\n; \n\n\n\n\nwhile\n(i < ar1.length && j < ar2.length && k < ar3.length) \n\n{ \n\n\n\n\n\nif\n(ar1[i] == ar2[j] && ar2[j] == ar3[k]) \n\n{ System.out.print(ar1[i]+\n\" \"\n); i++; j++; k++; } \n\n\n\n\nelse\nif\n(ar1[i] < ar2[j]) \n\ni++; \n\n\n\n\nelse\nif\n(ar2[j] < ar3[k]) \n\nj++; \n\n\n\n\nelse\n\nk++; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nFindCommon ob = \nnew\nFindCommon(); \n\n\nint\nar1[] = {\n1\n, \n5\n, \n10\n, \n20\n, \n40\n, \n80\n}; \n\nint\nar2[] = {\n6\n, \n7\n, \n20\n, \n80\n, \n100\n}; \n\nint\nar3[] = {\n3\n, \n4\n, \n15\n, \n20\n, \n30\n, \n70\n, \n80\n, \n120\n}; \n\n\nSystem.out.print(\n\"Common elements are \"\n); \n\nob.findCommon(ar1, ar2, ar3); \n\n} \n}", "index": 276, "complexity": "1"}
{"forwhile": "class CloseSum { static void printClosest(int arr[], int n, int x) { int res_l=0, res_r=0; int l = 0, r = n-1, diff = Integer.MAX_VALUE; for(r = n-1; r > l; r--) { if(Math.abs(arr[l] + arr[r] - x) < diff) { res_l = l; res_r = r; diff = Math.abs(arr[l] + arr[r] - x); } if(arr[l] + arr[r] > x) r--; else l++; } System.out.println(\" The closest pair is \"+arr[res_l]+\" and \"+ arr[res_r]); } public static void main(String[] args) { int arr[] = { 10, 22, 28, 29, 30, 40}, x = 54; int n = arr.length; printClosest(arr, n, x); } }", "src": "class\nCloseSum { \n\n\n\n\nstatic\nvoid\nprintClosest(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\nint\nres_l=\n0\n, res_r=\n0\n; \n\n\n\n\n\n\n\nint\nl = \n0\n, r = n-\n1\n, diff = Integer.MAX_VALUE; \n\n\n\n\nwhile\n(r > l) \n\n{ \n\n\n\nif\n(Math.abs(arr[l] + arr[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(arr[l] + arr[r] - x); \n\n} \n\n\n\n\nif\n(arr[l] + arr[r] > x) \n\nr--; \n\nelse\n\n\nl++; \n\n} \n\n\nSystem.out.println(\n\" The closest pair is \"\n+arr[res_l]+\n\" and \"\n+ arr[res_r]); \n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n22\n, \n28\n, \n29\n, \n30\n, \n40\n}, x = \n54\n; \n\nint\nn = arr.length; \n\nprintClosest(arr, n, x); \n\n} \n}", "index": 277, "complexity": "1"}
{"forwhile": "class ClosestPair { void printClosest( int ar1[], int ar2[], int m, int n, int x) { int diff = Integer.MAX_VALUE; int res_l = 0, res_r = 0; int l = 0, r = n-1; for(; l < m && r >= 0;) { if(Math.abs(ar1[l] + ar2[r] - x) < diff) { res_l = l; res_r = r; diff = Math.abs(ar1[l] + ar2[r] - x); } if(ar1[l] + ar2[r] > x) r--; else l++; } System.out.print(\"The closest pair is [\"+ ar1[res_l] + \", \" + ar2[res_r] + \"]\"); } public static void main(String args[]) { ClosestPair ob = new ClosestPair(); int ar1[] = { 1, 4, 5, 7}; int ar2[] = { 10, 20, 30, 40}; int m = ar1.length; int n = ar2.length; int x = 38; ob.printClosest(ar1, ar2, m, n, x); } }", "src": "class\nClosestPair \n{ \n\n\n\n\n\n\n\n\n\nvoid\nprintClosest(\nint\nar1[], \nint\nar2[], \nint\nm, \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nint\nres_l = \n0\n, res_r = \n0\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\nwhile\n(l<m && r>=\n0\n) \n\n{ \n\n\n\n\n\nif\n(Math.abs(ar1[l] + ar2[r] - x) < diff) \n\n{ \n\nres_l = l; \n\nres_r = r; \n\ndiff = Math.abs(ar1[l] + ar2[r] - x); \n\n} \n\n\n\n\n\n\nif\n(ar1[l] + ar2[r] > x) \n\nr--; \n\nelse\n\n\nl++; \n\n} \n\n\n\n\nSystem.out.print(\n\"The closest pair is [\"\n+ ar1[res_l] + \n\n\", \"\n+ ar2[res_r] + \n\"]\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nClosestPair ob = \nnew\nClosestPair(); \n\nint\nar1[] = {\n1\n, \n4\n, \n5\n, \n7\n}; \n\nint\nar2[] = {\n10\n, \n20\n, \n30\n, \n40\n}; \n\nint\nm = ar1.length; \n\nint\nn = ar2.length; \n\nint\nx = \n38\n; \n\nob.printClosest(ar1, ar2, m, n, x); \n\n} \n}", "index": 278, "complexity": "1"}
{"forwhile": "class PairInSortedRotated  {  static boolean pairInSortedRotated( int arr[],  int n, int x) {  int i = 0; while (i < n - 1) {  if (arr[i] > arr[i+1])  break; i++;  }  int l = (i + 1) % n;  int r = i;  for (; l != r;) {  if (arr[l] + arr[r] == x)  return true;  if (arr[l] + arr[r] < x)  l = (l + 1) % n;  else  r = (n + r - 1) % n;  }  return false;  }  public static void main (String[] args) {  int arr[] = { 11 , 15 , 6 , 8 , 9 , 10 };  int sum = 16;  int n = arr.length;  if (pairInSortedRotated(arr, n, sum))  System.out.print(", ");  else  System.out.print(": ");  } } ", "src": "class\nPairInSortedRotated \n{ \n\n\n\n\n\nstatic\nboolean\npairInSortedRotated(\nint\narr[], \n\nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ni; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\nif\n(arr[i] > arr[i+\n1\n]) \n\nbreak\n; \n\n\nint\nl = (i + \n1\n) % n; \n\n\n\n\n\nint\nr = i; \n\n\n\n\n\n\n\nwhile\n(l != r) \n\n{ \n\n\n\n\n\nif\n(arr[l] + arr[r] == x) \n\nreturn\ntrue\n; \n\n\n\n\n\n\nif\n(arr[l] + arr[r] < x) \n\nl = (l + \n1\n) % n; \n\n\nelse\n\n\nr = (n + r - \n1\n) % n; \n\n} \n\nreturn\nfalse\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n11\n, \n15\n, \n6\n, \n8\n, \n9\n, \n10\n}; \n\nint\nsum = \n16\n; \n\nint\nn = arr.length; \n\n\nif\n(pairInSortedRotated(arr, n, sum)) \n\nSystem.out.print(\n\"Array has two elements\"\n+ \n\n\" with sum 16\"\n); \n\nelse\n\nSystem.out.print(\n\"Array doesn't have two\"\n+ \n\n\" elements with sum 16 \"\n); \n\n} \n}", "index": 279, "complexity": "1"}
{"forwhile": "class Test { static int arr[] = new int[]{ 12 , 34 , 10 , 6 , 40}; static int findLargestSumPair() { int first, second; if (arr[0] > arr[1]) { first = arr[0]; second = arr[1]; } else { first = arr[1]; second = arr[0]; } int i = 2; while(i < arr.length) { if (arr[i] > first) { second = first; first = arr[i]; } else if (arr[i] > second && arr[i] != first) second = arr[i]; i++; } return (first + second); } public static void main(String[] args) { System.out.println(\"Max Pair Sum is \" + findLargestSumPair()); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n12\n, \n34\n, \n10\n, \n6\n, \n40\n}; \n\n\n\n\nstatic\nint\nfindLargestSumPair() \n\n{ \n\n\n\nint\nfirst, second; \n\nif\n(arr[\n0\n] > arr[\n1\n]) \n\n{ \n\nfirst = arr[\n0\n]; \n\nsecond = arr[\n1\n]; \n\n} \n\nelse\n\n{ \n\nfirst = arr[\n1\n]; \n\nsecond = arr[\n0\n]; \n\n} \n\n\n\n\n\n\nfor\n(\nint\ni = \n2\n; i<arr.length; i ++) \n\n{ \n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nreturn\n(first + second); \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nSystem.out.println(\n\"Max Pair Sum is \"\n+ findLargestSumPair()); \n\n\n} \n}", "index": 280, "complexity": "1"}
{"forwhile": "class SecondSmallest  { static void print2Smallest(int arr[])   { int first, second, arr_size = arr.length; if (arr_size < 2)   { System.out.println(\" Invalid Input \"); return ; } first = second = Integer.MAX_VALUE; int i = 0; while(i < arr_size )   { if (arr[i] < first)   { second = first; first = arr[i]; }  else if (arr[i] < second && arr[i] != first)   second = arr[i]; i ++; } if (second == Integer.MAX_VALUE)   System.out.println(\"There is no second\"+ \"smallest element\");   else  System.out.println(\"The smallest element is \"+ first + \" and second Smallest\"+ \" element is \"+ second); } public static void main (String[] args)   { int arr[] = { 12 , 13 , 1 , 10 , 34 , 1 }; print2Smallest(arr); } }", "src": "class\nSecondSmallest \n{ \n\n\n\nstatic\nvoid\nprint2Smallest(\nint\narr[]) \n\n{ \n\nint\nfirst, second, arr_size = arr.length; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\" Invalid Input \"\n); \n\nreturn\n; \n\n} \n\n\nfirst = second = Integer.MAX_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < arr_size ; i ++) \n\n{ \n\n\n\nif\n(arr[i] < first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] < second && arr[i] != first) \n\nsecond = arr[i]; \n\n} \n\nif\n(second == Integer.MAX_VALUE) \n\nSystem.out.println(\n\"There is no second\"\n+ \n\n\"smallest element\"\n); \n\nelse\n\nSystem.out.println(\n\"The smallest element is \"\n+ \n\nfirst + \n\" and second Smallest\"\n+ \n\n\" element is \"\n+ second); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n12\n, \n13\n, \n1\n, \n10\n, \n34\n, \n1\n}; \n\nprint2Smallest(arr); \n\n} \n}", "index": 281, "complexity": "1"}
{"forwhile": "public class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = 0;\n\t\tString inp = s.nextLine();\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\tchar k = inp.charAt(i);\n\t\t\tif (k == '+')\n\t\t\t\tans++;\n\t\t\tif (k == '-') {\n\t\t\t\tif (ans>0)\n\t\t\t\t\tans--;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = 0;\n\t\tString inp = s.nextLine();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchar k = inp.charAt(i);\n\t\t\tif (k == '+')\n\t\t\t\tans++;\n\t\t\tif (k == '-') {\n\t\t\t\tif (ans>0)\n\t\t\t\t\tans--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 282, "complexity": "1"}
{"forwhile": "public class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint arr[] = new int[n];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\tarr[i] = s.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tint i = 1;\n\t\tfor(; i < n; i++) {\n\t\t\tans = Math.min(ans, Math.min(arr[i], arr[0]) / i);\n\t\t}\n\t\tint i = n - 2;\n\t\tfor(; i >= 0; i--) {\n\t\t\tans = Math.min(ans, Math.min(arr[n - 1], arr[i]) / (n - i - 1));\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = Integer.parseInt(s.nextLine());\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint arr[] = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t}\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tans = Math.min(ans, Math.min(arr[i],arr[0])/i);\n\t\t}\n\t\tfor (int i=n-2;i>=0;i--){\n\t\t\tans = Math.min(ans, Math.min(arr[n-1],arr[i])/(n-i-1));\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 283, "complexity": "1"}
{"forwhile": "public class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint tmp;\n\t\tint min=Integer.MAX_VALUE;\n\t\tint i=0;\n\t\twhile(i<n) {\n\t\t\ttmp=sc.nextInt();\n\t\t\tif(i>n-1-i) {\n\t\t\t\ttmp=tmp/i;\n\t\t\t}else {\n\t\t\t\ttmp=tmp/(n-1-i);\n\t\t\t}\n\t\t\tif(tmp<min) {\n\t\t\t\tmin=tmp;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint tmp;\n\t\tint min=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ttmp=sc.nextInt();\n\t\t\tif(i>n-1-i) {\n\t\t\t\ttmp=tmp/i;\n\t\t\t}else {\n\t\t\t\ttmp=tmp/(n-1-i);\n\t\t\t}\n\t\t\tif(tmp<min) {\n\t\t\t\tmin=tmp;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "index": 284, "complexity": "1"}
{"forwhile": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            int i=0;\n            while(i<k){\n                s=s+\"1\";\n                i++;\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n            int i=0;\n            while(i<a && s.length()<n){\n                s=s+\"1\";\n                i++;\n            }\n            if(s.length()<n){\n                s=s+\"0\";\n            }\n            for(;s.length()<n;){\n                s=s+s;\n            }\n            String s1=new String();\n            for(int i=0;i<n;i++){\n                s1=s1+Character.toString(s.charAt(i));\n            }\n            System.out.println(s1);\n        }\n\t}\n}", "src": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            while(s.length()<n){\n                s=s+s;\n            }\n            String s1=new String();\n            for(int i=0;i<n;i++){\n                s1=s1+Character.toString(s.charAt(i));\n            }\n            System.out.println(s1);\n        }\n\t}\n}", "index": 285, "complexity": "1"}
{"forwhile": "class MaximumSum {\n\nint FindMaxSum(int arr[], int n) {\n\nint incl = arr[0];\n\nint excl = 0;\n\nint excl_new;\n\nint i = 1;\n\nwhile(i < n) {\n\nexcl_new = (incl > excl) ? incl : excl;\n\nincl = excl + arr[i];\n\nexcl = excl_new;\n\ni++;\n\n}\n\nreturn ((incl > excl) ? incl : excl);\n\n}\n\npublic static void main(String[] args) {\n\nMaximumSum sum = new MaximumSum();\n\nint arr[] = new int[]{5, 5, 10, 100, 10, 5};\n\nSystem.out.println(sum.FindMaxSum(arr, arr.length));\n\n}\n}", "src": "class\nMaximumSum \n{ \n\n\n\nint\nFindMaxSum(\nint\narr[], \nint\nn) \n\n{ \n\nint\nincl = arr[\n0\n]; \n\nint\nexcl = \n0\n; \n\nint\nexcl_new; \n\nint\ni; \n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\n\n\nexcl_new = (incl > excl) ? incl : excl; \n\n\n\n\nincl = excl + arr[i]; \n\nexcl = excl_new; \n\n} \n\n\n\n\nreturn\n((incl > excl) ? incl : excl); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMaximumSum sum = \nnew\nMaximumSum(); \n\nint\narr[] = \nnew\nint\n[]{\n5\n, \n5\n, \n10\n, \n100\n, \n10\n, \n5\n}; \n\nSystem.out.println(sum.FindMaxSum(arr, arr.length)); \n\n} \n}", "index": 286, "complexity": "1"}
{"forwhile": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            int i=0;\n            while(i<k){\n                s=s+\"1\";\n                i++;\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n            for(;s.length()<n;){\n                int i=0;\n                while(i<a && s.length()<n){\n                    s=s+\"1\";\n                    i++;\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            }\n            System.out.println(s);\n        }\n\t}\n}", "src": "public class Main{\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        if(n==k){\n            String s=new String();\n            for(int i=0;i<k;i++){\n                s=s+\"1\";\n            }\n            System.out.println(s);\n        }\n        else{\n            int a=(n-k)/2;\n            String s=new String();\n            while(s.length()<n){\n                for(int i=0;i<a && s.length()<n;i++){\n                    s=s+\"1\";\n                }\n                if(s.length()<n){\n                    s=s+\"0\";\n                }\n            }\n            System.out.println(s);\n        }\n\t}\n}", "index": 287, "complexity": "1"}
{"forwhile": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t    i++;\n\t\t}\n\t\t\n\t\tint k = 2;\n\t\twhile(k <= m) {\n\t\t\tint i = 'a';\n\t\t\twhile(i <= 'z') {\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tint j = i+2;\n\t\t\t\t\twhile(j <= 'z') {\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tint i = 'a';\n\t\tfor(; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 288, "complexity": "1"}
{"forwhile": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tint i = 0;\n\t\twhile(i < n)\n\t\t{\n\t\t\tcnt += in.nextInt();\n\t\t\ti++;\n\t\t}\n\t\t\n\t\ti = 0;\n\t\twhile(i < n)\n\t\t{\n\t\t\tcnt -= in.nextInt();\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}", "index": 289, "complexity": "1"}
{"forwhile": "public class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tk = 0;\n\t\twhile(k<arr.length) {\n\t\t\tsum = sum + arr[k];\n\t\t\tk++;\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tint i=0;\n\t\t\tfor(;i<n;) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tint j=0;\n\t\t\tfor(;j<n;) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tfor(k=0;k<arr.length;k++) {\n\t\t\tsum = sum + arr[k];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n}", "index": 290, "complexity": "1"}
{"forwhile": "class GFG { public static int findFrequency(int arr[], int n, int left, int right, int element) { int count = 0; int i = left - 1; while(i < right) { if(arr[i] == element) count++; i++; } return count; } public static void main(String[] args) { int arr[] = {2, 8, 6, 9, 8, 6, 8, 2, 11}; int n = arr.length; System.out.println(\"Frequency of 2 from 1 to 6 = \" + findFrequency(arr, n, 1, 6, 2)); System.out.println(\"Frequency of 8 from 4 to 9 = \" + findFrequency(arr, n, 4, 9, 8)); } }", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nfindFrequency(\nint\narr[], \nint\nn, \n\nint\nleft, \nint\nright, \n\nint\nelement) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = left - \n1\n; i < right; ++i) \n\nif\n(arr[i] == element) \n\n++count; \n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n8\n, \n6\n, \n9\n, \n8\n, \n6\n, \n8\n, \n2\n, \n11\n}; \n\nint\nn = arr.length; \n\n\n\n\nSystem.out.println(\n\"Frequency of 2 from 1 to 6 = \"\n+ \n\nfindFrequency(arr, n, \n1\n, \n6\n, \n2\n)); \n\n\n\n\nSystem.out.println(\n\"Frequency of 8 from 4 to 9 = \"\n+ \n\nfindFrequency(arr, n, \n4\n, \n9\n, \n8\n)); \n\n\n} \n\n}", "index": 291, "complexity": "1"}
{"forwhile": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tint i=0;\n\t\twhile(i<n)\n\t\t{\n\t\t\ts1+=input.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tint i=0;\n\t\twhile(i<n)\n\t\t{\n\t\t\ts2+=input.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "src": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts1+=input.nextInt();\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts2+=input.nextInt();\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "index": 292, "complexity": "1"}
{"forwhile": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tint i = 0; while(i < 2) { int j = 0; while(j < x) { a[i] += scan.nextInt(); j++; } i++; }\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}", "src": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}", "index": 293, "complexity": "1"}
{"forwhile": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              int i = 0;\n              while(i < n){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n                     i++;\n              }\n              i = 0;\n              while(i < n){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     i++;\n              }\n              i = 0;\n              while(i < n){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n                     i++;\n              }\n              System.out.println(-1);\n      }\n}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     \n                            \n                     \n                       \n                         \n                     \n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "index": 294, "complexity": "1"}
{"forwhile": "public class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        int i = 1;\n        while (i <= n && ans == -1) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0;\n                break;\n            }\n            f[a]++;\n            arr[i] = a;\n            i++;\n        }\n\n        i = 1;\n        while (i <= n && ans == -1) {\n            int a = arr[i] & x;\n            if ((a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)) {\n                ans = 1;\n                break;\n            }\n            g[a]++;\n            i++;\n        }\n\n        i = 1;\n        while (i <= n && ans == -1) {\n            int a = arr[i] & x;\n            if(g[a] > 1) {\n                ans = 2;\n                break;\n            }\n            i++;\n        }\n\n        pw.println(ans);\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try {\n                    lenbuf = is.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if(lenbuf <= 0)\n                    return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num << 3) + (num << 1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + ints[b];\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public char[] next(int n) {\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while (p < n && !(isSpaceChar(b))) {\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n    }\n}", "src": "public class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            \n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ \n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       \n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        \n    }\n}", "index": 295, "complexity": "1"}
{"forwhile": "class Test { static int arr[] = new int[]{10, 1, 2, 3, 4, 5, 6, 7, 8, 9}; static int maxSum() { int arrSum = 0; int currVal = 0; int i = 0; while(i < arr.length) { arrSum = arrSum + arr[i]; currVal = currVal + (i * arr[i]); i++; } int maxVal = currVal; int j = 1; while(j < arr.length) { currVal = currVal + arrSum - arr.length * arr[arr.length - j]; if(currVal > maxVal) maxVal = currVal; j++; } return maxVal; } public static void main(String[] args) { System.out.println(\"Max sum is \" + maxSum()); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr[] = \nnew\nint\n[]{\n10\n, \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n}; \n\n\n\n\nstatic\nint\nmaxSum() \n\n{ \n\n\n\nint\narrSum = \n0\n; \n\n\nint\ncurrVal = \n0\n; \n\n\nfor\n(\nint\ni=\n0\n; i<arr.length; i++) \n\n{ \n\narrSum = arrSum + arr[i]; \n\ncurrVal = currVal+(i*arr[i]); \n\n} \n\n\n\n\nint\nmaxVal = currVal; \n\n\n\n\n\n\nfor\n(\nint\nj=\n1\n; j<arr.length; j++) \n\n{ \n\ncurrVal = currVal + arrSum-arr.length*arr[arr.length-j]; \n\nif\n(currVal > maxVal) \n\nmaxVal = currVal; \n\n} \n\n\n\n\nreturn\nmaxVal; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Max sum is \"\n+ maxSum()); \n\n} \n}", "index": 296, "complexity": "1"}
{"forwhile": "public class TaskA {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tlong i = sc.nextInt();\n\t\tlong goal = sc.nextLong();\n\nif(i>goal) {\n\ti=goal;\n}\n\t\tint count = 0;\n\t\tfor(; goal >= 0;) {\n\t\t\tif (goal - i >= 0) {\n\t\t\t\tgoal = goal - i;\n\t\t\t\tcount++;\n\t\t\t} else\n\t\t\t\ti--;\n\t\t\tif (goal == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tout.print(count);\n\n\t\tout.flush();\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "src": "public class TaskA {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tlong i = sc.nextInt();\n\t\tlong goal = sc.nextLong();\n\nif(i>goal) {\n\ti=goal;\n}\n\t\tint count = 0;\n\t\twhile (goal >= 0) {\n\t\t\tif (goal - i >= 0) {\n\t\t\t\tgoal = goal - i;\n\t\t\t\tcount++;\n\t\t\t} else\n\t\t\t\ti--;\n\t\t\tif (goal == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tout.print(count);\n\n\t\tout.flush();\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "index": 297, "complexity": "1"}
{"forwhile": "public class CoinsTask {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint S = in.nextInt();\n\t\tint mCoins = 0;\n\t\tfor(; S / n != 0; ) {\n\t\t\tmCoins += 1;\n\t\t\tS -= n;\n\t\t}\n\t\tmCoins = S == 0 ? mCoins : mCoins + 1;\n\t\tSystem.out.print(mCoins);\n\t}\n\n}", "src": "public class CoinsTask {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint S = in.nextInt();\n\t\tint mCoins = 0;\n\t\twhile(S/n != 0) {\n\t\t\tmCoins+=1;\n\t\t\tS-=n;\n\t\t}\n\t\tmCoins = S == 0? mCoins : mCoins+1;\n\t\tSystem.out.print(mCoins);\n\t}\n\n}", "index": 298, "complexity": "1"}
{"forwhile": "public class P1075A\n{\n\tpublic static void main(String[] args)\n\t{\n\t Scanner scan=new Scanner(System.in);\n\t long n,x,y;\n\t n=scan.nextLong();\n\t x=scan.nextLong();\n\t y=scan.nextLong();\n\t boolean flag=true,flag1=false,flag2=false;\n\t long w1,w2,b1,b2;\n\t long W=0l,B=0l;\n\t w1=w2=1;\t\tb1=b2=n;\n\t for(long w1=1, w2=1; w1<n; ++w1, ++w2, ++W)\n\t\t{\n\t\t if(w1==x)\n\t\t\t{flag1=true;\tbreak;}\n\t\t if(w2==y)\n\t\t\tbreak;\n\t\t}\n\t if(flag1)\n\t\tW+=(y-w2);\n\t else\n\t\tW+=(x-w1);\n\t for(long b1=n, b2=n; b1>1; --b1, --b2, ++B)\n\t\t{\n\t\t if(b1==x)\n\t\t\t{flag2=true;\tbreak;}\n\t\t if(b2==y)\n\t\t\tbreak;\n\t\t}\n\t if(flag2)\n\t\tB+=(b2-y);\n\t else\n\t\tB+=(b1-x);\n\t if(B<W)\n\t\tSystem.out.println(\"Black\");\n\t else\n\t\tSystem.out.println(\"White\");\n\t}\n}", "src": "public class P1075A\n{\n\tpublic static void main(String[] args)\n\t{\n\t Scanner scan=new Scanner(System.in);\n\t long n,x,y;\n\t n=scan.nextLong();\n\t x=scan.nextLong();\n\t y=scan.nextLong();\n\t boolean flag=true,flag1=false,flag2=false;\n\t long w1,w2,b1,b2;\n\t long W=0l,B=0l;\n\t w1=w2=1;\t\tb1=b2=n;\n\t while(w1<n)\n\t\t{\n\t\t if(w1==x)\n\t\t\t{flag1=true;\tbreak;}\n\t\t if(w2==y)\n\t\t\tbreak;\n\t\t ++w1;\t++w2;\t++W;\n\t\t}\n\t if(flag1)\n\t\tW+=(y-w2);\n\t else\n\t\tW+=(x-w1);\n\t while(b1>1)\n\t\t{\n\t\t if(b1==x)\n\t\t\t{flag2=true;\tbreak;}\n\t\t if(b2==y)\n\t\t\tbreak;\n\t\t --b1;\t--b2;\t++B;\n\t\t}\n\t if(flag2)\n\t\tB+=(b2-y);\n\t else\n\t\tB+=(b1-x);\n\t if(B<W)\n\t\tSystem.out.println(\"Black\");\n\t else\n\t\tSystem.out.println(\"White\");\n\t}\n}", "index": 299, "complexity": "1"}
{"forwhile": "public class kingrace {public static void main(String[] args) \n{ \n    Scanner input=new Scanner(System.in);\n    long a = input.nextLong();\n   input.nextLine();\n    String [] coo = input.nextLine().split(\" \");\n    long xcoin = Long.parseLong(coo[0]);\n    long ycoin = Long.parseLong(coo[1]);\n    coordinates first = new coordinates(1,1,a);\n    coordinates second = new coordinates(a,a,a);\n    double x = (double)Math.sqrt(Math.abs((xcoin-1)*(xcoin-1)+(ycoin-1)*(ycoin-1)));\n    double y = (double)Math.sqrt(Math.abs((xcoin-a)*(xcoin-a)+(ycoin-a)*(ycoin-a));\n   long c = 0;\n   long d = 0;\n    if (x>y)\n    {\n    \tSystem.out.println(\"Black\");\n    }\n    else if(x<y)\n    {\n    \tSystem.out.println(\"White\");\n    }\n    else {\n    c = first.Distance(new coordinates(xcoin,ycoin,a));\n    d = second.Distance(new coordinates(xcoin,ycoin,a));\n    }\n    if(d!=0&&c!=0)\n    if (d<c)\n    {\n    \tSystem.out.println(\"Black\");\n    \t\n    }\n    else \n    {\n    \tSystem.out.println(\"White\");\n    }\n  \n  input.close();\n} \n\n}\nclass coordinates{\n\tprivate long xcoord;\n\tprivate long ycoord;\n\tprivate long dim; \n\tpublic coordinates(long x, long y, long dimensions)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\tdim = dimensions;\n\t\t\n\t}\n\tpublic void setCoordinates(long x, long y)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\t\n\t}\n\tpublic long Distance(coordinates num)\n\t{\n\t\tlong distance = 0; \n\t\t\n\t\tfor(; this.xcoord!=num.xcoord||this.ycoord!=num.ycoord;)\n\t\t{\n\t\t\n\t\t\tif (num.xcoord-this.xcoord==1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\n\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==-1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==1)\n\t\t\t{distance ++; this.setCoordinates(this.xcoord, this.ycoord+1);}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==-1) {\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord, this.ycoord-1);\n\t\t\t}\n\t\t\t\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord-1); \n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord+1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord-1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t\t\t{distance ++; this.setCoordinates(this.xcoord-1, this.ycoord+1);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\treturn distance;\n\t}\n\t\n\t\n}", "src": "public class kingrace {public static void main(String[] args) \n{ \n    Scanner input=new Scanner(System.in);\n    long a = input.nextLong();\n   input.nextLine();\n    String [] coo = input.nextLine().split(\" \");\n    long xcoin = Long.parseLong(coo[0]);\n    long ycoin = Long.parseLong(coo[1]);\n    coordinates first = new coordinates(1,1,a);\n    coordinates second = new coordinates(a,a,a);\n    double x = (double)Math.sqrt(Math.abs((xcoin-1)*(xcoin-1)+(ycoin-1)*(ycoin-1)));\n    double y = (double)Math.sqrt(Math.abs((xcoin-a)*(xcoin-a)+(ycoin-a)*(ycoin-a)));\n   long c = 0;\n   long d = 0;\n    if (x>y)\n    {\n    \tSystem.out.println(\"Black\");\n    }\n    else if(x<y)\n    {\n    \tSystem.out.println(\"White\");\n    }\n    else {\n    c = first.Distance(new coordinates(xcoin,ycoin,a));\n    d = second.Distance(new coordinates(xcoin,ycoin,a));\n    }\n    if(d!=0&&c!=0)\n    if (d<c)\n    {\n    \tSystem.out.println(\"Black\");\n    \t\n    }\n    else \n    {\n    \tSystem.out.println(\"White\");\n    }\n  \n  input.close();\n} \n\n}\nclass coordinates{\n\tprivate long xcoord;\n\tprivate long ycoord;\n\tprivate long dim; \n\tpublic coordinates(long x, long y, long dimensions)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\tdim = dimensions;\n\t\t\n\t}\n\tpublic void setCoordinates(long x, long y)\n\t{\n\t\txcoord = x;\n\t\tycoord = y;\n\t\t\n\t}\n\tpublic long Distance(coordinates num)\n\t{\n\t\tlong distance = 0; \n\t\t\n\t\t\n\t\twhile ((this.xcoord!=num.xcoord||this.ycoord!=num.ycoord))\n\t\t{\n\t\t\n\t\t\tif (num.xcoord-this.xcoord==1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\n\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==-1 &&num.ycoord==this.ycoord)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==1)\n\t\t\t{distance ++; this.setCoordinates(this.xcoord, this.ycoord+1);}\n\t\t\telse if (num.xcoord-this.xcoord==0 &&num.ycoord-this.ycoord==-1) {\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord, this.ycoord-1);\n\t\t\t}\n\t\t\t\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t{\n\t\t\t\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord-1); \n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord>=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord+1, this.ycoord+1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord<=0)\n\t\t\t\n\t\t\t{\n\t\t\t\tdistance ++; this.setCoordinates(this.xcoord-1, this.ycoord-1);\n\t\t\t}\n\t\t\telse if (num.xcoord-this.xcoord<=0 &&num.ycoord-this.ycoord>=0)\n\t\t\t\t\t{distance ++; this.setCoordinates(this.xcoord-1, this.ycoord+1);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\treturn distance;\n\t}\n\t\n\t\n}", "index": 300, "complexity": "1"}
{"forwhile": "class GFG { static int answer_query(int a[], int n, int l, int r) { int count = 0; int i = l; while(i < r) if(a[i] == a[i + 1]) count += 1; i++; return count; } public static void main(String[] args) { int a[] = {1, 2, 2, 2, 3, 3, 4, 4, 4}; int n = a.length; int L, R; L = 1; R = 8; System.out.println(answer_query(a, n, L, R)); L = 0; R = 4; System.out.println(answer_query(a, n, L, R)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nanswer_query(\nint\na[], \nint\nn, \n\nint\nl, \nint\nr) \n\n{ \n\n\n\n\n\n\nint\ncount = \n0\n; \n\nfor\n(\nint\ni = l; i < r; i++) \n\nif\n(a[i] == a[i + \n1\n]) \n\ncount += \n1\n; \n\n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n, \n3\n, \n4\n, \n4\n, \n4\n}; \n\nint\nn = a.length; \n\n\n\n\nint\nL, R; \n\nL = \n1\n; \n\nR = \n8\n; \n\n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n\n\n\nL = \n0\n; \n\nR = \n4\n; \n\nSystem.out.println( \n\nanswer_query(a, n, L, R)); \n\n} \n}", "index": 301, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Solution {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc= new Scanner(System.in);\n\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\tint loca[]=new int[n+m];\n\t\tint res[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++)\n\t\t\tloca[i]=sc.nextInt();\n\t\t\n\t\tint y=0;\n\t\tint driver[]=new int[m];\n\t\tfor(int i=0;i<n+m;i++){\n\t\t\tint x=sc.nextInt();\n\t\t\tif(x==1)\n\t\t\t\tdriver[y++]=i;\n\t\t}\n\t\t\n\t\tint i=0,j=0,p=0,q=0;\n\t\tfor(i=0;i<m+n;i++) {\n\t\t\tif(i==driver[0])\n\t\t\t\t{i++;break;}\n\t\t\tif(loca[i]<loca[driver[0]])\n\t\t\t\tres[0]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(;i<n+m;i++){\n\t\t\t\n\t\t\tint coor=loca[i];\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif(j==m-1)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tp=driver[j];q=driver[j+1];\t\t\n\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint d1=coor-loca[p],d2=loca[q]-coor;\n\t\t\t\n\t\t\tif(d2==0)\n\t\t\t\t{j++;continue;}\n\t\t\tif(d1<=d2)\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tres[j+1]++;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(;i<m+n;i++) {\n\t\t\t\n\t\t\tif(i==driver[j])\n\t\t\t{i++;break;}\n\t\t\t\n\t\t\tif(loca[i]>loca[driver[j]])\n\t\t\t\tres[j]++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(i=0;i<m;i++)\n\t\t\tSystem.out.print(res[i]+\" \");\n\t}\n}", "index": 302, "complexity": "1"}
{"forwhile": "class GFG { static int repeated_digit( int n ) { LinkedHashSet<Integer> s = new LinkedHashSet<>(); for( ; n != 0 ; ) { int d = n % 10; if( s.contains(d) ) return 0; s.add(d); n = n / 10; } return 1; } static int calculate( int L, int R ) { int answer = 0; int i = L; while( i < R + 1 ) { answer = answer + repeated_digit(i); i++; } return answer; } public static void main(String[] args) { int L = 1, R = 100; System.out.println(calculate(L, R)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nrepeated_digit(\nint\nn) \n{ \n\nLinkedHashSet<Integer> s = \nnew\nLinkedHashSet<>(); \n\n\n\n\nwhile\n(n != \n0\n) \n\n{ \n\nint\nd = n % \n10\n; \n\n\n\n\n\n\n\n\nif\n(s.contains(d)) \n\n{ \n\n\n\n\n\nreturn\n0\n; \n\n} \n\ns.add(d); \n\nn = n / \n10\n; \n\n} \n\n\n\n\n\n\nreturn\n1\n; \n} \n\n\n\n\nstatic\nint\ncalculate(\nint\nL, \nint\nR) \n{ \n\nint\nanswer = \n0\n; \n\n\n\n\nfor\n(\nint\ni = L; i < R + \n1\n; ++i) \n\n{ \n\n\n\n\n\n\nanswer = answer + repeated_digit(i); \n\n} \n\n\nreturn\nanswer; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nL = \n1\n, R = \n100\n; \n\n\n\n\nSystem.out.println(calculate(L, R)); \n} \n}", "index": 303, "complexity": "1"}
{"forwhile": "class GFG { static void initializeDiffArray(int A[], int D[]) { int n = A.length; D[0] = A[0]; D[n] = 0; int i = 1; while (i < n) { D[i] = A[i] - A[i - 1]; i++; } } static void update(int D[], int l, int r, int x) { D[l] += x; D[r + 1] -= x; } static int printArray(int A[], int D[]) { int i = 0; int len = A.length; while (i < len) { if (i == 0) A[i] = D[i]; else A[i] = D[i] + A[i - 1]; System.out.print(A[i] + \" \"); i++; } System.out.println(); return 0; } public static void main(String[] args) { int A[] = { 10, 5, 20, 40 }; int n = A.length; int D[] = new int[n + 1]; initializeDiffArray(A, D); int i = 0; int len = A.length; while (i < len) { if (i == 0) A[i] = D[i]; else A[i] = D[i] + A[i - 1]; System.out.print(A[i] + \" \"); i++; } System.out.println(); update(D, 0, 1, 10); i = 0; len = A.length; while (i < len) { if (i == 0) A[i] = D[i]; else A[i] = D[i] + A[i - 1]; System.out.print(A[i] + \" \"); i++; } System.out.println(); update(D, 1, 3, 20); update(D, 2, 2, 30); i = 0; len = A.length; while (i < len) { if (i == 0) A[i] = D[i]; else A[i] = D[i] + A[i - 1]; System.out.print(A[i] + \" \"); i++; } System.out.println(); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\ninitializeDiffArray(\nint\nA[], \nint\nD[]) \n\n{ \n\n\nint\nn = A.length; \n\n\nD[\n0\n] = A[\n0\n]; \n\nD[n] = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nD[i] = A[i] - A[i - \n1\n]; \n\n} \n\n\n\n\nstatic\nvoid\nupdate(\nint\nD[], \nint\nl, \nint\nr, \nint\nx) \n\n{ \n\nD[l] += x; \n\nD[r + \n1\n] -= x; \n\n} \n\n\n\n\nstatic\nint\nprintArray(\nint\nA[], \nint\nD[]) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < A.length; i++) { \n\n\nif\n(i == \n0\n) \n\nA[i] = D[i]; \n\n\n\n\n\n\nelse\n\nA[i] = D[i] + A[i - \n1\n]; \n\n\nSystem.out.print(A[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n\nreturn\n0\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nint\nA[] = { \n10\n, \n5\n, \n20\n, \n40\n}; \n\nint\nn = A.length; \n\n\n\n\n\n\n\nint\nD[] = \nnew\nint\n[n + \n1\n]; \n\ninitializeDiffArray(A, D); \n\n\n\n\n\n\nupdate(D, \n0\n, \n1\n, \n10\n); \n\nprintArray(A, D); \n\n\n\n\n\n\nupdate(D, \n1\n, \n3\n, \n20\n); \n\nupdate(D, \n2\n, \n2\n, \n30\n); \n\n\nprintArray(A, D); \n\n} \n}", "index": 304, "complexity": "1"}
{"forwhile": "public class Cf1003A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int[] arr = new int[100];\n        int max = 0;\n        int tmp;\n        int i = 0;\n        while (i < n) {\n            tmp = Integer.parseInt(stk.nextToken()) - 1;\n           max = max < ++arr[tmp] ? arr[tmp] : max;\n           i++;\n        }\n        System.out.println(max);\n    }\n}", "src": "public class Cf1003A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int[] arr = new int[100];\n        int max = 0;\n        int tmp;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken()) - 1;\n           max = max < ++arr[tmp] ? arr[tmp] : max;\n        }\n        System.out.println(max);\n    }\n}", "index": 305, "complexity": "1"}
{"forwhile": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        contest1 solver = new contest1();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class contest1 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int x = in.nextInt();\n            String s = \"\";\n            int count = 0;\n\n            int copya = a;\n            int copyb = b;\n            int change = 0;\n\n            if (x == 1) {\n                if (copya > copyb) {\n                    int i = 0;\n                    while (i < a) {\n                        s += '0';\n                        i++;\n                    }\n                    i = 0;\n                    while (i < b) {\n                        s += '1';\n                        i++;\n                    }\n                } else {\n                    int i = 0;\n                    while (i < b) {\n                        s += '1';\n                        i++;\n                    }\n                    i = 0;\n                    while (i < a) {\n                        s += '0';\n                        i++;\n                    }\n\n                }\n\n            } else {\n                \n                if (copya > copyb) {\n                    for (int i = 0; i <= x - 1; i++) {\n                        if (i % 2 == 0) {\n                            s += '0';\n                            change++;\n                            a--;\n                        } else {\n                            s += '1';\n                            change++;\n                            b--;\n                        }\n                    }\n\n                } else if (copyb >= copya) {\n                    \n                    for (int i = 0; i <= x - 1; i++) {\n                        \n                        if (i % 2 == 0) {\n                            s += '1';\n                            change++;\n                            b--;\n                        } else {\n                            s += '0';\n                            change++;\n                            a--;\n                        }\n                    }\n                }\n\n                char z = s.charAt(s.length() - 1);\n                \n                if (z == '0') {\n                    int i = 0;\n                    while (i < a) {\n                        s += '0';\n                        i++;\n                    }\n                    i = 0;\n                    while (i < b) {\n                        s += '1';\n                        i++;\n                    }\n                } else {\n                    int i = 0;\n                    while (i < b) {\n                        s += '1';\n                        i++;\n                    }\n                    i = 0;\n                    while (i < a) {\n                        s += '0';\n                        i++;\n                    }\n                }\n            }\n            out.println(s);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        contest1 solver = new contest1();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class contest1 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int x = in.nextInt();\n            String s = \"\";\n            int count = 0;\n\n            int copya = a;\n            int copyb = b;\n            int change = 0;\n\n            if (x == 1) {\n                if (copya > copyb) {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n\n                }\n\n            } else {\n                \n                if (copya > copyb) {\n                    while (change <= x - 1) {\n                        if (change % 2 == 0) {\n                            s += '0';\n                            change++;\n                            a--;\n                        } else {\n                            s += '1';\n                            change++;\n                            b--;\n                        }\n                    }\n\n                } else if (copyb >= copya) {\n                    \n                    while (change <= x - 1) {\n                        \n                        if (change % 2 == 0) {\n                            s += '1';\n                            change++;\n                            b--;\n                        } else {\n                            s += '0';\n                            change++;\n                            a--;\n                        }\n                    }\n                }\n\n                char z = s.charAt(s.length() - 1);\n                \n                if (z == '0') {\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                } else {\n                    while (b > 0) {\n                        s += '1';\n                        b--;\n                    }\n                    while (a > 0) {\n                        s += '0';\n                        a--;\n                    }\n                }\n            }\n            out.println(s);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 306, "complexity": "1"}
{"forwhile": "public class programA {\n    public static void main(String[] args)throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int d = Integer.parseInt(st.nextToken());\n        int arr[] = new int[n];\n        st = new StringTokenizer(br.readLine());\n        int i=0;\n        while(i<n){\n            arr[i] = Integer.parseInt(st.nextToken());\n            i++;\n        }\n        int s= 2;\n        int i=0;\n        for(;i<n-1;){\n            long dis = (long)2*d;\n            long dis2 = Math.abs(arr[i]-arr[i+1]);\n            if(dis2 == dis)s++;\n            else if (dis2 > dis)s+=2;\n            i++;\n        }\n        System.out.println(s);\n    }\n}", "src": "public class programA {\n   \tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint d = Integer.parseInt(st.nextToken());\n\t\tint arr[] = new int[n];\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tarr[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tint s= 2;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tlong dis = (long)2*d;\n\t\t\tlong dis2 = Math.abs(arr[i]-arr[i+1]);\n\t\t\tif(dis2 == dis)s++;\n\t\t\telse if (dis2 > dis)s+=2;\n\t\t}\n\t\tSystem.out.println(s);\n   \t\t}\n}", "index": 307, "complexity": "1"}
{"forwhile": "public class Cf1005A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int numberOfStairs = 0;\n        StringBuilder result = new StringBuilder(\"\");\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int previousNum = 0;\n        int tmp = 0;\n        int i = 0;\n        while(i < n) {\n            tmp = Integer.parseInt(stk.nextToken());\n            if (tmp == 1) {\n                ++numberOfStairs;\n                if (previousNum != 0)\n                    result.append(previousNum + \" \");\n            }\n            previousNum = tmp;\n            i++;\n        }\n        result.append(previousNum);\n        System.out.println(numberOfStairs);\n        System.out.println(result);\n    }\n}", "src": "public class Cf1005A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int numberOfStairs = 0;\n        StringBuilder result = new StringBuilder(\"\");\n        StringTokenizer stk = new StringTokenizer(br.readLine());\n        int previousNum = 0;\n        int tmp = 0;\n        for (int i = 0; i < n; i++) {\n            tmp = Integer.parseInt(stk.nextToken());\n            if (tmp == 1){\n                ++numberOfStairs;\n                if (previousNum != 0)\n                    result.append(previousNum + \" \");\n            }\n            previousNum = tmp;\n        }\n        result.append(previousNum);\n        System.out.println(numberOfStairs);\n        System.out.println(result);\n    }\n}", "index": 308, "complexity": "1"}
{"forwhile": "class Profit { static int maxProfit(int price[], int n) { int profit[] = new int[n]; int i = 0; while(i<n) profit[i++] = 0; int max_price = price[n-1]; i = n-2; while(i>=0) { if(price[i] > max_price) max_price = price[i]; profit[i] = Math.max(profit[i+1], max_price-price[i]); i--; } int min_price = price[0]; i = 1; while(i<n) { if(price[i] < min_price) min_price = price[i]; profit[i] = Math.max(profit[i-1], profit[i] + (price[i]-min_price) ); i++; } int result = profit[n-1]; return result; } public static void main(String args[]) { int price[] = { 2, 30, 15, 10, 8, 25, 80 }; int n = price.length; System.out.println(\"Maximum Profit = \"+ maxProfit(price, n)); } } ", "src": "class\nProfit \n{ \n\n\n\n\n\nstatic\nint\nmaxProfit(\nint\nprice[], \nint\nn) \n\n{ \n\n\n\nint\nprofit[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nprofit[i] = \n0\n; \n\n\n\n\nint\nmax_price = price[n-\n1\n]; \n\nfor\n(\nint\ni=n-\n2\n;i>=\n0\n;i--) \n\n{ \n\n\n\nif\n(price[i] > max_price) \n\nmax_price = price[i]; \n\n\n\n\n\n\n\n\n\n\nprofit[i] = Math.max(profit[i+\n1\n], max_price-price[i]); \n\n} \n\n\n\n\nint\nmin_price = price[\n0\n]; \n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\n\n\nif\n(price[i] < min_price) \n\nmin_price = price[i]; \n\n\n\n\n\n\n\n\n\n\nprofit[i] = Math.max(profit[i-\n1\n], profit[i] + \n\n(price[i]-min_price) ); \n\n} \n\nint\nresult = profit[n-\n1\n]; \n\nreturn\nresult; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nprice[] = {\n2\n, \n30\n, \n15\n, \n10\n, \n8\n, \n25\n, \n80\n}; \n\nint\nn = price.length; \n\nSystem.out.println(\n\"Maximum Profit = \"\n+ maxProfit(price, n)); \n\n} \n\n}", "index": 309, "complexity": "1"}
{"forwhile": "public class CodeForce {\n    \n    \n        public static void main(String[] args) {\n            Scanner sc=new Scanner(System.in);\n            String s=sc.next();\n            String t=sc.next();\n            int count=s.length()+t.length();\n            int i=0;\n            while(i<Math.min(s.length(), t.length())){\n                if(s.charAt(s.length()-1-i)==t.charAt(t.length()-1-i))count=count-2;\n                else break;\n                i++;\n            }\n            System.out.println(count);\n            \n            \n            \n            \n           \n            \n                \n        }    \n    }", "src": "public class CodeForce {\n    \n    \n        public static void main(String[] args) {\n            Scanner sc=new Scanner(System.in);\n            String s=sc.next();\n            String t=sc.next();\n            int count=s.length()+t.length();\n            for(int i=0;i<Math.min(s.length(), t.length());i++){\n                if(s.charAt(s.length()-1-i)==t.charAt(t.length()-1-i))count=count-2;\n                else break;\n            }\n            System.out.println(count);\n            \n            \n            \n            \n           \n            \n                \n        }    \n    }", "index": 310, "complexity": "1"}
{"forwhile": "public class Codeforces {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = new int[n];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int i = 0;\n        while(i < n){\n            arr[i] = Integer.parseInt(st.nextToken());\n            i++;\n        }\n        i = 0;\n        while(i < n){\n            if(arr[i] % 2 == 0){\n                arr[i]--;\n            }\n            i++;\n        }\n        i = 0;\n        while(i < n){\n            pw.print(arr[i] + \" \");\n            i++;\n        }\n        pw.flush();\n        pw.close();\n    }\n}", "src": "public class Codeforces {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = new int[n];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for(int i = 0; i < n; i++){\n            arr[i] = Integer.parseInt(st.nextToken());\n        }\n        for(int i = 0; i < n; i++){\n            if(arr[i] % 2 == 0){\n                arr[i]--;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            pw.print(arr[i] + \" \");\n        }\n        pw.flush();\n        pw.close();\n    }\n}", "index": 311, "complexity": "1"}
{"forwhile": "public class Main\n{\n    public static void main(String[] args)\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskC\n    {\n        public void solve(int testNumber, FastScanner in, FastPrinter out)\n        {\n            int n = in.nextInt();\n            long[] a = new long[n];\n            long[] b = new long[n];\n            int i = 0;\n            while (i < n)\n            {\n                b[i] = a[i] = in.nextInt();\n                if (i > 0)\n                {\n                    a[i] += a[i - 1];\n                }\n                i++;\n            }\n            int i = n - 2;\n            while (i >= 0)\n            {\n                b[i] += b[i + 1];\n                i--;\n            }\n            \n            \n            long sum1 = 0;\n            long sum3 = 0;\n            long result = 0;\n            int i = 0;\n            int j = n - 1;\n            for (; i < j;)\n            {\n                sum1 = a[i];\n                sum3 = b[j];\n                if (sum1 == sum3)\n                {\n                    result = Math.max(result, sum1);\n                    i++;\n                    j--;\n                }\n                else if (sum1 < sum3)\n                {\n                    i++;\n                }\n                else\n                {\n                    j--;\n                }\n            }\n            out.println(result);\n            \n            \n        }\n        \n    }\n    \n    static class FastScanner\n    {\n        public BufferedReader br;\n        public StringTokenizer st;\n        \n        public FastScanner(InputStream is)\n        {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n        \n        public FastScanner(File f)\n        {\n            try\n            {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        \n        public String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                String s = null;\n                try\n                {\n                    s = br.readLine();\n                } catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                {\n                    return null;\n                }\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        \n    }\n    \n    static class FastPrinter extends PrintWriter\n    {\n        public FastPrinter(OutputStream out)\n        {\n            super(out);\n        }\n        \n        public FastPrinter(Writer out)\n        {\n            super(out);\n        }\n        \n    }\n}", "src": "public class Main\n{\n    public static void main(String[] args)\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    \n    static class TaskC\n    {\n        public void solve(int testNumber, FastScanner in, FastPrinter out)\n        {\n            int n = in.nextInt();\n            long[] a = new long[n];\n            long[] b = new long[n];\n            for (int i = 0; i < n; i++)\n            {\n                b[i] = a[i] = in.nextInt();\n                if (i > 0)\n                {\n                    a[i] += a[i - 1];\n                }\n            }\n            for (int i = n - 2; i >= 0; i--)\n            {\n                b[i] += b[i + 1];\n            }\n            \n            long sum1 = 0;\n            long sum3 = 0;\n            long result = 0;\n            for (int i = 0, j = n - 1; i < j; )\n            {\n                sum1 = a[i];\n                sum3 = b[j];\n                if (sum1 == sum3)\n                {\n                    result = Math.max(result, sum1);\n                    i++;\n                    j--;\n                }\n                else if (sum1 < sum3)\n                {\n                    i++;\n                }\n                else\n                {\n                    j--;\n                }\n            }\n            out.println(result);\n            \n            \n        }\n        \n    }\n    \n    static class FastScanner\n    {\n        public BufferedReader br;\n        public StringTokenizer st;\n        \n        public FastScanner(InputStream is)\n        {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n        \n        public FastScanner(File f)\n        {\n            try\n            {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        \n        public String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                String s = null;\n                try\n                {\n                    s = br.readLine();\n                } catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                {\n                    return null;\n                }\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        \n    }\n    \n    static class FastPrinter extends PrintWriter\n    {\n        public FastPrinter(OutputStream out)\n        {\n            super(out);\n        }\n        \n        public FastPrinter(Writer out)\n        {\n            super(out);\n        }\n        \n    }\n}", "index": 312, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,ans=0;\n\t\tString sa,sb;\n\t\tchar[] a,b;\n\t\tn=sc.nextInt();\n\t\tsa=sc.next();\n\t\tsb=sc.next();\n\t\ta=sa.toCharArray();\n\t\tb=sb.toCharArray();\n\t\tans=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(i==n/2)\n\t\t\t{\n\t\t\t\tif(a[i]!=b[i])\n\t\t\t\t\tans++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] vis=new int[28];\n\t\t\tvis[a[i]-'a']++;\n\t\t\tvis[b[i]-'a']++;\n\t\t\tvis[a[n-1-i]-'a']++;\n\t\t\tvis[b[n-1-i]-'a']++;\n\t\t\tint num=0,ans1=0,ans2=0;\n\t\t\tfor(int j=0;j<26;j++)\n\t\t\t\tif(vis[j]!=0)\n\t\t\t\t{\n\t\t\t\t\tnum++;\n\t\t\t\t\tif(num==1)\n\t\t\t\t\t\tans1=vis[j];\n\t\t\t\t\telse\n\t\t\t\t\t\tans2=vis[j];\n\t\t\t\t}\n\t\t\tif(num==2)\n\t\t\t{\n\t\t\t\tif(ans1==1||ans2==1)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==3)\n\t\t\t{\n\t\t\t\tif(a[i]==a[n-i-1])\n\t\t\t\t\tans+=2;\n\t\t\t\telse\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\telse if(num==4)\n\t\t\t\tans+=2;\n\t\t\ta[i]=b[i];\n\t\t\ta[n-1-i]=b[n-1-i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 313, "complexity": "1"}
{"forwhile": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EMilitaryProblem solver = new EMilitaryProblem();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EMilitaryProblem {\n        ArrayList<Integer>[] adj;\n        int[] sz;\n        int[] preorder;\n        int curPos;\n        int[] pos;\n\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            int q = br.nextInt();\n            preorder = new int[n];\n            sz = new int[n];\n            pos = new int[n];\n            curPos = 0;\n            adj = new ArrayList[n];\n            int i = 0;\n            while (i < n) {\n                adj[i] = new ArrayList<Integer>();\n                i++;\n            }\n            i = 1;\n            while (i < n) {\n                int u = br.nextInt();\n                u--;\n                adj[u].add(i);\n                i++;\n            }\n            dfs(0);\n            i = 0;\n            while (i < n) {\n                pos[preorder[i]] = i;\n                i++;\n            }\n            i = 0;\n            while (i < q) {\n                int u = br.nextInt();\n                int k = br.nextInt();\n                u--;\n                if (sz[u] < k) {\n                    pw.println(\"-1\");\n                } else {\n                    pw.println(preorder[pos[u] + k - 1] + 1);\n                }\n                i++;\n            }\n            pw.close();\n        }\n\n        public int dfs(int u) {\n            i = 0;\n            while (i < n) {\n                preorder[curPos] = u;\n                curPos++;\n                sz[u]++;\n                int e : adj[u];\n                sz[u] += dfs(e);\n                i++;\n            }\n            return sz[u];\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == \\\"-\\\") {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < \\\\'0\\\\' || c > \\\\'9\\\\') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - \\\\'0\\\\';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == \\\\' \\\\' || c == \\\\'\\n\\\\' || c == \\\\'\\r\\\\' || c == \\\\'\\t\\\\' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EMilitaryProblem solver = new EMilitaryProblem();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EMilitaryProblem {\n        ArrayList<Integer>[] adj;\n        int[] sz;\n        int[] preorder;\n        int curPos;\n        int[] pos;\n\n        public void solve(int testNumber, FastScanner br, PrintWriter pw) {\n            int n = br.nextInt();\n            int q = br.nextInt();\n            preorder = new int[n];\n            sz = new int[n];\n            pos = new int[n];\n            curPos = 0;\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) adj[i] = new ArrayList<Integer>();\n            for (int i = 1; i < n; i++) {\n                int u = br.nextInt();\n                u--;\n                adj[u].add(i);\n            }\n            dfs(0);\n            for (int i = 0; i < n; i++) {\n                pos[preorder[i]] = i;\n            }\n            for (int i = 0; i < q; i++) {\n                int u = br.nextInt();\n                int k = br.nextInt();\n                u--;\n                if (sz[u] < k) {\n                    pw.println(\"-1\");\n                } else {\n                    pw.println(preorder[pos[u] + k - 1] + 1);\n                }\n            }\n            pw.close();\n        }\n\n        public int dfs(int u) {\n            preorder[curPos] = u;\n            curPos++;\n            sz[u]++;\n            for (int e : adj[u]) {\n                sz[u] += dfs(e);\n            }\n            return sz[u];\n        }\n\n    }\n\n    static class FastScanner {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastScanner.SpaceCharFilter filter;\n\n        public FastScanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}", "index": 314, "complexity": "1"}
{"forwhile": "class Test { static int arr[] = new int[] { 3, 7, 90, 20, 10, 50, 40}; static void findMinAvgSubarray(int n, int k) { if (n < k) return; int res_index = 0; int curr_sum = 0; int i = 0; while (i < k) { curr_sum += arr[i]; i++; } int min_sum = curr_sum; i = k; while (i < n) { curr_sum += arr[i] - arr[i - k]; if (curr_sum < min_sum) { min_sum = curr_sum; res_index = (i - k + 1); } i++; } System.out.println(\"Subarray between [\" + res_index + \", \" + (res_index + k - 1) + \"] has minimum average\"); } public static void main(String[] args) { int k = 3; findMinAvgSubarray(arr.length, k); } }", "src": "class\nTest { \n\n\nstatic\nint\narr[] = \nnew\nint\n[] { \n3\n, \n7\n, \n90\n, \n20\n, \n10\n, \n50\n, \n40\n}; \n\n\n\n\n\n\nstatic\nvoid\nfindMinAvgSubarray(\nint\nn, \nint\nk) \n\n{ \n\n\n\nif\n(n < k) \n\nreturn\n; \n\n\n\n\nint\nres_index = \n0\n; \n\n\n\n\nint\ncurr_sum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\ncurr_sum += arr[i]; \n\n\n\n\nint\nmin_sum = curr_sum; \n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\n\n\n\n\ncurr_sum += arr[i] - arr[i - k]; \n\n\n\n\nif\n(curr_sum < min_sum) { \n\nmin_sum = curr_sum; \n\nres_index = (i - k + \n1\n); \n\n} \n\n} \n\n\nSystem.out.println(\n\"Subarray between [\"\n+ \n\nres_index + \n\", \"\n+ (res_index + k - \n1\n) + \n\n\"] has minimum average\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nk = \n3\n; \n\n\nfindMinAvgSubarray(arr.length, k); \n\n} \n}", "index": 315, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString str = in.next();\n\t\tboolean[] exist = new boolean[200];\n\t\tint dn[][] = new int[200][m+1];\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint a = str.charAt(i);\n\t\t\texist[a] = true;\n\t\t\tdn[a][1] = a - 'a' + 1;\n\t\t}\n\t\t\n\t\tfor(int k = 2; k <= m; k++) \n\t\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\t\tif(exist[i]) {\n\t\t\t\t\tint a = 0;\n\t\t\t\t\tfor(int j = i+2; j <= 'z'; j++)\n\t\t\t\t\t\tif(dn[j][k-1] > 0 && (a == 0 || (a > dn[j][k-1]) ) ) \n\t\t\t\t\t\t\ta = dn[j][k-1];\n\t\t\t\t\tif(a > 0)\n\t\t\t\t\t\tdn[i][k] = a + i - 'a' + 1; \n\t\t\t\t}\n\t\t\n\t\tint ans = -1;\n\t\tfor(int i = 'a'; i <= 'z'; i++)\n\t\t\tif(dn[i][m] > 0 && (ans == -1 || ans > dn[i][m]) )\n\t\t\t\tans = dn[i][m];\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 316, "complexity": "1"}
{"forwhile": "class MinimumDistance {\n\nint minDist(int arr[], int n, int x, int y) {\n\nint i = 0;\nint min_dist = Integer.MAX_VALUE;\nint prev=0;\n\n\ni = 0;\nwhile(i < n) {\n\nif(arr[i] == x || arr[i] == y) {\n\nprev = i;\nbreak;\n}\n\ni++;\n}\n\n\nwhile(i < n) {\n\nif(arr[i] == x || arr[i] == y) {\n\n\nif(arr[prev] != arr[i] && (i - prev) < min_dist) {\n\nmin_dist = i - prev;\nprev = i;\n}\nelse\nprev = i;\n}\n\ni++;\n}\n\nreturn min_dist;\n}\n\npublic static void main(String[] args) {\n\nMinimumDistance min = new MinimumDistance();\n\nint arr[] = {3, 5, 4, 2, 6, 3, 0, 0, 5, 4, 8, 3};\nint n = arr.length;\nint x = 3;\nint y = 6;\n\nSystem.out.println(\"Minimum distance between \" + x + \" and \" + y + \" is \" + min.minDist(arr, n, x, y));\n}\n}", "src": "class\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni = \n0\n; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nint\nprev=\n0\n; \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\nprev = i; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\nfor\n(; i < n; i++) \n\n{ \n\nif\n(arr[i] == x || arr[i] == y) \n\n{ \n\n\n\n\n\n\n\n\n\nif\n(arr[prev] != arr[i] && (i - prev) < min_dist) \n\n{ \n\nmin_dist = i - prev; \n\nprev = i; \n\n} \n\nelse\n\nprev = i; \n\n} \n\n} \n\n\nreturn\nmin_dist; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n3\n, \n0\n, \n0\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n}", "index": 317, "complexity": "1"}
{"forwhile": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tint i = 0;\n\t\twhile(i < n)\n\t\t{\n\t\t\tcnt += in.nextInt();\n\t\t\ti++;\n\t\t}\n\t\t\n\t\ti = 0;\n\t\twhile(i < n)\n\t\t{\n\t\t\tcnt -= in.nextInt();\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}", "src": "public class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint cnt = 0;\n\t\tString ans = \"Yes\";\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt += in.nextInt();\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcnt -= in.nextInt();\n\t\t\n\t\tif(cnt < 0)\n\t\t\tans = \"No\";\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\tin.close();\n\t}\n}", "index": 318, "complexity": "1"}
{"forwhile": "public class Piles {\n    static int summation(int arr[]) {\n        int k, sum=0;\n        k=0;\n        while(k<arr.length) {\n            sum = sum + arr[k];\n            k++;\n        }\n        return sum;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        if(n>=1 && n<=50) {\n            int x[] = new int[n];\n            int y[] = new int[n];\n            \n            int i=0;\n            while(i<n) {\n                x[i] = sc.nextInt();\n                i++;\n            }\n            int j=0;\n            while(j<n) {\n                y[j] = sc.nextInt();\n                j++;\n            }\n            int xsum = summation(x);\n            int ysum = summation(y);\n            if(xsum>=ysum) {\n                System.out.println(\"Yes\");\n            }\n            else {\n                System.out.println(\"No\");\n            }\n        }\n    }\n}", "src": "public class Piles {\n\tstatic int summation(int arr[]) {\n\t\tint k, sum=0;\n\t\tfor(k=0;k<arr.length;k++) {\n\t\t\tsum = sum + arr[k];\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif(n>=1 && n<=50) {\n\t\t\tint x[] = new int[n];\n\t\t\tint y[] = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\ty[j] = sc.nextInt();\n\t\t\t}\n\t\t\tint xsum = summation(x);\n\t\t\tint ysum = summation(y);\n\t\t\tif(xsum>=ysum) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t\t\n\n\t}\n\n}", "index": 319, "complexity": "1"}
{"forwhile": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tint i=0;\n\t\twhile(i<n)\n\t\t{\n\t\t\ts1+=input.nextInt();\n\t\t\ti++;\n\t\t}\n\t\ti=0;\n\t\twhile(i<n)\n\t\t{\n\t\t\ts2+=input.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "src": "public class Stones {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input=new Scanner(System.in);\n\t\tint n=input.nextInt();\n\t\tint s1=0;\n\t\tint s2=0;\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts1+=input.nextInt();\n\t\tfor (int i=0;i<n;++i)\n\t\t\ts2+=input.nextInt();\n\t\tif (s1 >= s2)\n\t\t\tSystem.out.println(\"Yes\");\n\t\telse\n\t\t\tSystem.out.println(\"No\");\n\t}\n}", "index": 320, "complexity": "1"}
{"forwhile": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tint i = 0;while(i < 2) { int j = 0;while(j < x) { a[i] += scan.nextInt(); j++; } i++; }\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}", "src": "public class Piles {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] a = new int[2]; int x = scan.nextInt();\n\t\tfor(int i = 0; i < 2; i++) for(int j = 0; j < x; j++) a[i] += scan.nextInt();\n\t\tSystem.out.println(a[1] <= a[0] ? \"Yes\" : \"No\");\n\n\t}\n\n}", "index": 321, "complexity": "1"}
{"forwhile": "public class SolutionB { public static void main(String args[])throws IOException{ Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int k = sc.nextInt(); Set<Integer> set1 = new HashSet<Integer>(); Set<Integer> set2 = new HashSet<Integer>(); int a[] = new int[n]; int i = 0; while(i < n){ a[i] = sc.nextInt(); if(!set1.contains(a[i])){ set1.add(a[i]); }else{ System.out.println(0); return; } i++; } i = 0; while(i < n){ int b = a[i] & k; if(b != a[i] && set1.contains(b)){ System.out.println(1); return; } i++; } i = 0; while(i < n){ int b = a[i] & k; if(b != a[i] && set2.contains(b)){ System.out.println(2); return; }else{ set2.add(b); } i++; } System.out.println(-1); }}", "src": "public class SolutionB {\n       \n      public static void main(String args[])throws IOException{\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int k = sc.nextInt();\n              Set<Integer> set1 = new HashSet<Integer>();\n              Set<Integer> set2 = new HashSet<Integer>();\n              int a[] = new int[n];\n              for(int i = 0; i < n; i++){\n                     a[i] = sc.nextInt();\n                     if(!set1.contains(a[i])){\n                            set1.add(a[i]);\n                     }else{\n                            System.out.println(0);\n                            return;\n                     }\n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set1.contains(b)){\n                            System.out.println(1);\n                            return;\n                     }\n                     \n                            \n                     \n                       \n                         \n                     \n              }\n              for(int i = 0; i < n; i++){\n                     int b = a[i] & k;\n                     if(b != a[i] && set2.contains(b)){\n                            System.out.println(2);\n                            return;\n                     }else{\n                            set2.add(b);\n                     }\n              }\n              System.out.println(-1);\n      }\n}", "index": 322, "complexity": "1"}
{"forwhile": "public class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        int i = 1;\n        while (i <= n && ans == -1) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n            i++;\n        }\n\n        i = 1;\n        while (i <= n && ans == -1) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n            i++;\n        }\n\n        i = 1;\n        while (i <= n && ans == -1) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            \n            i++;\n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ \n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       \n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        \n    }\n}", "src": "public class B {\n    public static void main(String[] args)throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int ans = -1;\n        int f[] = new int[(int)2e5+50];\n        int g[] = new int[(int)2e5+50];\n\n        int n = in.nextInt(), x = in.nextInt();\n\n        int arr[] = new int[n+1];\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = in.nextInt();\n            if(f[a] > 0){\n                ans = 0; break;\n            }\n            f[a]++;\n            arr[i] = a;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if( (a == arr[i] && f[a] > 1) || (a != arr[i] && f[a] > 0)){\n                ans = 1; break;\n            }\n            \n            g[a]++;\n        }\n\n        for (int i = 1; i <= n && ans == -1; i++) {\n            int a = arr[i] & x;\n            if(g[a] > 1){\n                ans = 2; break;\n            }\n            \n        }\n\n        pw.println(ans);\n\n\n\n        pw.close();\n    }\n\n    static void debug(Object...obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n        static final int ints[] = new int[128];\n\n        public FastReader(InputStream is){\n            for(int i='0';i<='9';i++) ints[i]=i-'0';\n            this.is = is;\n        }\n\n        public int readByte(){\n            if(lenbuf == -1)throw new InputMismatchException();\n            if(ptrbuf >= lenbuf){\n                ptrbuf = 0;\n                try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n                if(lenbuf <= 0)return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n        public int skip() {\n            int b;\n            while((b = readByte()) != -1 && isSpaceChar(b));\n            return b;\n        }\n\n        public String next(){\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while(!(isSpaceChar(b))){ \n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt(){\n            int num = 0, b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n            if(b == '-'){\n                minus = true;\n                b = readByte();\n            }\n\n            while(true){\n                if(b >= '0' && b <= '9'){\n                    num = (num<<3) + (num<<1) + ints[b];\n                }else{\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n       \n\n        public char[] next(int n){\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while(p < n && !(isSpaceChar(b))){\n                buf[p++] = (char)b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        \n    }\n}", "index": 323, "complexity": "1"}
{"forwhile": "public class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader in = new FastReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong n = in.nextLong();\n\t\tlong k = in.nextLong();\n\t\tlong s = in.nextLong();\n\t\tif (k > s || k * (n - 1) < s) {\n\t\t\tout.println(\"NO\");\n\t\t} else {\n\t\t\tout.println(\"YES\");\n\t\t\tlong cur = 1;\n\t\t\tfor (long kLoop = k; kLoop > 0; kLoop--) {\n\t\t\t\tlong x = Math.min(n - 1, s - k + 1);\n\t\t\t\tcur = ( cur - x > 0 ? cur  - x : cur + x);\n\t\t\t\tout.print(cur + \" \");\n\t\t\t\ts -= x;\n\t\t\t}\n\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class FastReader {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic FastReader(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic FastReader(FileReader fileReader) {\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader in = new FastReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tlong n = in.nextLong();\n\t\tlong k = in.nextLong();\n\t\tlong s = in.nextLong();\n\t\tif (k > s || k * (n - 1) < s) {\n\t\t\tout.println(\"NO\");\n\t\t} else {\n\t\t\tout.println(\"YES\");\n\t\t\tlong cur = 1;\n\t\t\twhile (k > 0) {\n\t\t\t\tlong x = Math.min(n - 1, s - k + 1);\n\t\t\t\tcur = ( cur - x > 0 ? cur  - x : cur + x);\n\t\t\t\tout.print(cur + \" \");\n\t\t\t\ts -= x;\n\t\t\t\tk--;\n\t\t\t}\n\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class FastReader {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic FastReader(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic FastReader(FileReader fileReader) {\n\t\t\tbr = new BufferedReader(fileReader);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n}", "index": 324, "complexity": "1"}
{"forwhile": "public class DeathNote {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\tint x = 0;\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tx += a[i];\n\t\t\tsb.append(\" \" + (x/m));\n\t\t\tx %= m;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tSystem.out.println(sb.toString().substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\tfor(; st == null || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\tfor(; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\tfor(; i < n; i++) {\n\t\t\tint j = 0;\n\t\t\tfor(; j < m; j++) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\tfor(; i < n; i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class DeathNote {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\tint x = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx += a[i];\n\t\t\tsb.append(\" \" + (x/m));\n\t\t\tx %= m;\n\t\t}\n\t\t\n\t\tSystem.out.println(sb.toString().substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 325, "complexity": "1"}
{"forwhile": "public class Main {\n\n    static String S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        S = sc.next();\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        int ans = -1;\n        int time = 1;\n        int n = S.length();\n        int i = 1;\n        while(i < n*2) {\n            if( S.charAt((i-1)%n) != S.charAt(i%n) ) {\n                time++;\n            } else {\n                ans = Math.max(time, ans);\n                time = 1;\n            }\n            i++;\n        }\n        ans = Math.max(time, ans);\n\n        if( ans == n*2 ) {\n            return n;\n        } else {\n            return ans;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            int i = 0;\n            while (i < n) {\n                a[i] = nextInt();\n                i++;\n            }\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            int i = 0;\n            while (i < n) {\n                a[i] = nextInt() + delta;\n                i++;\n            }\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            int i = 0;\n            while (i < n) {\n                a[i] = nextLong();\n                i++;\n            }\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        int i = 0;\n        while (i < as.length) {\n            pw.println(as[i]);\n            i++;\n        }\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        int i = 0;\n        while (i < as.length) {\n            pw.println(as[i]);\n            i++;\n        }\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        int i = 0;\n        while (i < as.length) {\n            max = Math.max(as[i], max);\n            i++;\n        }\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        int i = 0;\n        while (i < as.length) {\n            min = Math.min(as[i], min);\n            i++;\n        }\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}", "src": "public class Main {\n\n    static String S;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        S = sc.next();\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        int ans = -1;\n        int time = 1;\n        int n = S.length();\n        for (int i = 1; i < n*2; i++) {\n            if( S.charAt((i-1)%n) != S.charAt(i%n) ) {\n                time++;\n            } else {\n                ans = Math.max(time, ans);\n                time = 1;\n            }\n        }\n        ans = Math.max(time, ans);\n\n        if( ans == n*2 ) {\n            return n;\n        } else {\n            return ans;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}", "index": 326, "complexity": "1"}
{"forwhile": "public class Cheast {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] l = new int[n];\n        l[0] = sc.nextInt();\n        int x=1;\n        int c=1;\n        int i=1;\n        while(i<n) {\n            l[i] = sc.nextInt();\n            if (l[i] <= l[i-1]*2) {\n                c++;\n                x = Math.max(x,c);\n            }\n            else\n                c = 1;\n            i++;\n        }\n        System.out.println(x);\n\n\n\n    }\n}", "src": "public class Cheast {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] l = new int[n];\n        l[0] = sc.nextInt();\n        int x=1;\n        int c=1;\n        for (int i=1;i<n;i++) {\n            l[i] = sc.nextInt();\n            if (l[i] <= l[i-1]*2) {\n                c++;\n                x = Math.max(x,c);\n            }\n            else\n                c = 1;\n        }\n        System.out.println(x);\n\n\n\n    }\n}", "index": 327, "complexity": "1"}
{"forwhile": "public class vasyaarray{\npublic static void main(String[] args)throws IOException {\nFastReader in=new FastReader(System.in);\nint n=in.nextInt();\nlong arr1[]=new long[n];\nlong pre1[]=new long[n];\nint i,j;\narr1[0]=in.nextLong();\npre1[0]=arr1[0];\ni = 1;\nwhile(i<n)\n{\narr1[i]=in.nextLong();pre1[i]=pre1[i-1]+arr1[i]; i++;\n}\nint m=in.nextInt();\nlong arr2[]=new long[m];\nlong pre2[]=new long[m];\narr2[0]=in.nextInt();\npre2[0]=arr2[0];\ni = 1;\nwhile(i<m)\n{\narr2[i]=in.nextInt();pre2[i]=pre2[i-1]+arr2[i]; i++;\n}\nif(pre1[n-1]!=pre2[m-1])\nSystem.out.println(\"-1\");\nelse\n{\nlong s1=0,s2=0;\ni=j=0;\nint k=0;\nfor(;;)\n{\nif(s1==s2)\n{\nif(s1==0)\n{\ns1=arr1[i++];s2=arr2[j++];\n}\nelse\n{\nk++;\ns1=s2=0;\nif(i==n && j==m)\nbreak;\n}\n}\nelse if(s1>s2)\n{\ns2+=arr2[j++];\n}\nelse\n{\ns1+=arr1[i++];\n}\n}\nSystem.out.println(k);\n}\n}\n}\n}", "src": "public class vasyaarray{\npublic static void main(String[] args)throws IOException {\n    FastReader in=new FastReader(System.in);\n        int n=in.nextInt();\n        long arr1[]=new long[n];\n        long pre1[]=new long[n];\n        int i,j;\n        arr1[0]=in.nextLong();\n        pre1[0]=arr1[0];\n        for(i=1;i<n;i++)\n        {\n            arr1[i]=in.nextLong();\n            pre1[i]=pre1[i-1]+arr1[i];\n        }\n        int m=in.nextInt();\n        long arr2[]=new long[m];\n        long pre2[]=new long[m];\n        arr2[0]=in.nextInt();\n        pre2[0]=arr2[0];\n        for(i=1;i<m;i++)\n        {\n            arr2[i]=in.nextInt();\n            pre2[i]=pre2[i-1]+arr2[i];\n        }\n        \n         \n        if(pre1[n-1]!=pre2[m-1])\n        System.out.println(\"-1\");\n        else\n        {\n            long s1=0,s2=0;\n            i=j=0;\n            int k=0;\n            while(true)\n            {\n                if(s1==s2)\n                {\n                    if(s1==0)\n                    {\n                        s1=arr1[i++];\n                        s2=arr2[j++];\n                        \n                    }\n                    else\n                    {\n                        k++;\n                        s1=s2=0;\n                        \n                        if(i==n && j==m)\n                        break;\n                    }\n                }\n                else if(s1>s2)\n                {\n                    s2+=arr2[j++];\n                    \n                }\n                else\n                {\n                    s1+=arr1[i++];\n                    \n                }\n            }\n            System.out.println(k);\n        }\n    }\n}\nclass FastReader {\n \n    byte[] buf = new byte[2048];\n    int index, total;\n    InputStream in;\n \n    FastReader(InputStream is) {\n        in = is;\n    }\n \n    int scan() throws IOException {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) {\n                return -1;\n            }\n        }\n        return buf[index++];\n    }\n \n    String next() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    String nextLine() throws IOException {\n        int c;\n        for (c = scan(); c <= 32; c = scan());\n        StringBuilder sb = new StringBuilder();\n        for (; c !=10; c = scan()) {\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n    char nextChar() throws IOException{\n        int c;\n         for (c = scan(); c <= 32; c = scan());\n         return (char)c;\n        }\n \n    int nextInt() throws IOException {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n \n    long nextLong() throws IOException {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') {\n            c = scan();\n        }\n        for (; c >= '0' && c <= '9'; c = scan()) {\n            val = (val << 3) + (val << 1) + (c & 15);\n        }\n        return neg ? -val : val;\n    }\n}", "index": 328, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class helloWorld \n{\n\tstatic ArrayList<Integer> ar;\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tStringBuilder ans = new StringBuilder();\n\t\tif(n <= 2)\n\t\t\tans.append(\"No\");\n\t\telse if(n == 4) {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tans.append(\"1 2\\n\");\n\t\t\tans.append(\"3 1 3 4\\n\");\n\t\t}\n\t\telse  {\n\t\t\tans.append(\"Yes\\n\");\n\t\t\tif(n % 2 == 1) {\n\t\t\t\tint a = (n+1)/2;\n\t\t\t\tans.append(\"1 \");\n\t\t\t\tans.append(a);\n\t\t\t\tans.append(\"\\n\");\n\t\t\t\tans.append(n-1);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+1; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a = n/2;\n\t\t\t\tans.append(\"2 \");\n\t\t\t\tans.append(a + \" \");\n\t\t\t\tans.append(a+1 + \" \\n\");\n\t\t\t\tans.append(n-2);\n\t\t\t\tfor(int i = 1; i < a; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t\tfor(int i = a+2; i <= n; i++)\n\t\t\t\t\tans.append(\" \" + i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tin.close();\n\t}\n}", "index": 329, "complexity": "1"}
{"forwhile": "class\nSmallestSubArraySum \n{ \n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n\n\nint\nstart = \n0\n, end = \n0\n; \n\nfor(; end < n; ) \n\n{ \n\n\n\n\n\nfor(; curr_sum <= x && end < n; ) \n\ncurr_sum += arr[end++]; \n\n\n\n\nfor(; curr_sum > x && start < n; ) \n\n{ \n\n\n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n\n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n}", "src": "class\nSmallestSubArraySum \n{ \n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n\n\nint\nstart = \n0\n, end = \n0\n; \n\nwhile\n(end < n) \n\n{ \n\n\n\n\n\nwhile\n(curr_sum <= x && end < n) \n\ncurr_sum += arr[end++]; \n\n\n\n\nwhile\n(curr_sum > x && start < n) \n\n{ \n\n\n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n\n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n}", "index": 330, "complexity": "1"}
{"forwhile": "public class A\n   {\n      public static void main(String args[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in)); \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int L = Integer.parseInt(st.nextToken());\n         int A = Integer.parseInt(st.nextToken());\n         int[] arr1 = new int[N];\n         int[] arr2 = new int[N];\n         int i = 0;\n         while(i < N)\n         {\n            st = new StringTokenizer(infile.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken())+x;\n            arr1[i] = x;\n            arr2[i] = y;\n            i++;\n         }\n         int res = 0;\n         int i = 1;\n         for(;i < N; i++)\n            res += (arr1[i]-arr2[i-1])/A;\n         if(N > 0)\n            res += (L-arr2[N-1])/A+arr1[0]/A;\n         else\n            res += L/A;\n         System.out.println(res);\n      }\n   }", "src": "public class A\n   {\n      public static void main(String args[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in)); \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int L = Integer.parseInt(st.nextToken());\n         int A = Integer.parseInt(st.nextToken());\n         int[] arr1 = new int[N];\n         int[] arr2 = new int[N];\n         for(int i=0; i < N; i++)\n         {\n            st = new StringTokenizer(infile.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken())+x;\n            arr1[i] = x;\n            arr2[i] = y;\n         }\n         int res = 0;\n         for(int i=1; i < N; i++)\n            res += (arr1[i]-arr2[i-1])/A;\n         if(N > 0)\n            res += (L-arr2[N-1])/A+arr1[0]/A;\n         else\n            res += L/A;\n         System.out.println(res);\n      }\n   }", "index": 331, "complexity": "1"}
{"forwhile": "public class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tint n = input.nextInt();\n\t\tString s = input.next();\n\t\tboolean done = false;\n\n\t\tint i = 0;\n\t\twhile (i < s.length() - 1)\n\t\t{\n\t\t\tif (s.charAt(i) != s.charAt(i + 1))\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tSystem.out.println(s.charAt(i) + \"\" + s.charAt(i + 1));\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif (!done)\n\t\t{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}", "src": "public class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tint n = input.nextInt();\n\t\tString s = input.next();\n\t\tboolean done = false;\n\t\tfor (int i = 0; i < s.length() - 1; i++)\n\t\t{\n\t\t\tif (s.charAt(i) != s.charAt(i + 1))\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tSystem.out.println(s.charAt(i) + \"\" + s.charAt(i + 1));\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!done)\n\t\t{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}", "index": 332, "complexity": "1"}
{"forwhile": "class GFG { static int findMaxAverage(int []arr, int n, int k) { if(k > n) return -1; int []csum = new int[n]; csum[0] = arr[0]; int i = 1; while(i < n) { csum[i] = csum[i - 1] + arr[i]; i++; } int max_sum = csum[k - 1], max_end = k - 1; i = k; while(i < n) { int curr_sum = csum[i] - csum[i - k]; if(curr_sum > max_sum) { max_sum = curr_sum; max_end = i; } i++; } return max_end - k + 1; } static public void main (String[] args) { int []arr = {1, 12, -5, -6, 50, 3}; int k = 4; int n = arr.length; System.out.println(\"The maximum \" + \"average subarray of length \" + k + \" begins at index \" + findMaxAverage(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxAverage(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\n\n\n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n\n\n\n\n\n\n\n\nint\n[]csum = \nnew\nint\n[n]; \n\n\ncsum[\n0\n] = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\ncsum[i] = csum[i - \n1\n] + arr[i]; \n\n\n\n\n\n\nint\nmax_sum = csum[k - \n1\n], \n\nmax_end = k - \n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nint\ncurr_sum = csum[i] - \n\ncsum[i - k]; \n\nif\n(curr_sum > max_sum) \n\n{ \n\nmax_sum = curr_sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]arr = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"The maximum \"\n\n+ \n\"average subarray of length \"\n\n+ k + \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n}", "index": 333, "complexity": "1"}
{"forwhile": "class GFG { static int findMaxAverage(int arr[], int n, int k) { if (k > n) return -1; int sum = arr[0]; int i = 1; while (i < k) { sum += arr[i]; i++; } int max_sum = sum, max_end = k-1; i = k; while (i < n) { sum = sum + arr[i] - arr[i-k]; if (sum > max_sum) { max_sum = sum; max_end = i; } i++; } return max_end - k + 1; } public static void main (String[] args) { int arr[] = { 1, 12, -5, -6, 50, 3 }; int k = 4; int n = arr.length; System.out.println( \"The maximum average\" + \" subarray of length \" + k + \" begins at index \" + findMaxAverage(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMaxAverage(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\n\nif\n(k > n) \n\nreturn\n-\n1\n; \n\n\n\n\nint\nsum = arr[\n0\n]; \n\nfor\n(\nint\ni = \n1\n; i < k; i++) \n\nsum += arr[i]; \n\n\nint\nmax_sum = sum, max_end = k-\n1\n; \n\n\n\n\nfor\n(\nint\ni = k; i < n; i++) \n\n{ \n\nsum = sum + arr[i] - arr[i-k]; \n\nif\n(sum > max_sum) \n\n{ \n\nmax_sum = sum; \n\nmax_end = i; \n\n} \n\n} \n\n\n\n\nreturn\nmax_end - k + \n1\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, -\n5\n, -\n6\n, \n50\n, \n3\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.println( \n\"The maximum average\"\n\n+ \n\" subarray of length \"\n+ k \n\n+ \n\" begins at index \"\n\n+ findMaxAverage(arr, n, k)); \n\n} \n}", "index": 334, "complexity": "1"}
{"forwhile": "public class ehab3 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n    int n = in.nextInt();\n    int[] a = new int[n];\n    int i = 0;\n    while(i < n) {\n        a[i] = in.nextInt();\n        i++;\n    }\n    System.out.println( ( n + 1 ) );\n    int c = 0;\n    for(int i = n - 1; i >= 0; i--) {\n        int cd = n + i - ( ( a[i] + c ) % n );\n        System.out.println( \"1 \" + ( i + 1 ) + \" \" + cd );\n        c += cd;\n    }\n    System.out.println( \"2 \" + n + \" \" + n );\n    }\n}", "src": "public class ehab3 {\n    public static void main( String[] args ) {\n        Scanner in = new Scanner( System.in );\n\tint n = in.nextInt();\n\tint[] a = new int[n];\n\tfor ( int i = 0; i < n; i++ )\n\t    a[i] = in.nextInt();\n\tSystem.out.println( ( n + 1 ) );\n\tint c = 0;\n\tfor ( int i = n - 1; i >= 0; i-- ) {\n\t    int cd = n + i - ( ( a[i] + c ) % n );\n\t    System.out.println( \"1 \" + ( i + 1 ) + \" \" + cd );\n\t    c += cd;\n\t}\n\tSystem.out.println( \"2 \" + n + \" \" + n );\n    }\n}", "index": 335, "complexity": "1"}
{"forwhile": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tlong sum1 = 0, sum2 = 0;\n\t\tint i = 0;\n\t\twhile (i < num * 2) {\n\t\t\tsum1 += sc.nextInt();\n\t\t\tsum2 += sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(sum1 / num + \" \" + sum2 / num);\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint num=sc.nextInt();\n\t\tlong sum1=0,sum2=0;\n\t\tfor(int i=0;i<num*2;i++){\n\t\t\tsum1+=sc.nextInt();\n\t\t\tsum2+=sc.nextInt();\n\t\t}\n\t\tSystem.out.println(sum1/num+\" \"+sum2/num);\n\t}\n}", "index": 336, "complexity": "1"}
{"forwhile": "public class UniformString {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = nextInt();\n\t\tint i = 0;\n\t\twhile(i < t) {\n\t\t\tint n = nextInt();\n\t\t\tint k = nextInt();\n\t\t\tString s = \"\";\n\t\t\tint j = 0;\n\t\t\twhile(j < n) {\n\t\t\t\ts += (char)('a' + (j%k)); \n\t\t\t\tj++;\n\t\t\t}\n\t\t\tSystem.out.println(s);\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\tfor(; st == null || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\tfor(; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\tfor(; i < n; i++) {\n\t\t\tint j = 0;\n\t\t\tfor(; j < m; j++) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\tfor(; i < n; i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class UniformString {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = nextInt();\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tint n = nextInt();\n\t\t\tint k = nextInt();\n\t\t\tString s = \"\";\n\t\t\tfor (int j = 0; j < n; j++) \n\t\t\t\ts += (char)('a' + (j%k)); \n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 337, "complexity": "1"}
{"forwhile": "class arr_rot  {\n\n\n\n\n\nstatic void leftRotate(\nint arr[], int n, \n\nint k) {\n\n\n\nint mod = k % n; \n\n\n\n\nint i = \n0\n; \nwhile(i < n) {\nSystem.out.print(arr[(i + mod) % n] \n\n+ \n\" \"); \n\ni++; }\n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic static void main (String[] args) {\n\nint arr[] = { \n1\n, \n3\n, \n5\n, \n7\n, \n9\n}; \n\nint n = arr.length; \n\n\nint k = \n2\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n3\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n4\n; \n\nleftRotate(arr, n, k); \n\n} \n}", "src": "class\narr_rot \n{ \n\n\n\n\n\nstatic\nvoid\nleftRotate(\nint\narr[], \nint\nn, \n\nint\nk) \n\n{ \n\n\n\nint\nmod = k % n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[(i + mod) % n] \n\n+ \n\" \"\n); \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n3\n, \n5\n, \n7\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nint\nk = \n2\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n3\n; \n\nleftRotate(arr, n, k); \n\n\nk = \n4\n; \n\nleftRotate(arr, n, k); \n\n} \n}", "index": 338, "complexity": "1"}
{"forwhile": "class GFG  { static int findMinOps(int[] arr, int n) { int ans = 0; int i = 0; int j = n - 1; while (i <= j) { if (arr[i] == arr[j]) { i++; j--; } else if (arr[i] > arr[j]) { j--; arr[j] += arr[j + 1]; ans++; } else { i++; arr[i] += arr[i - 1]; ans++; } } return ans; } public static void main(String[] args) { int arr[] = new int[]{1, 4, 5, 9, 1} ; System.out.println(\"Count of minimum operations is \"+ findMinOps(arr, arr.length)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nfindMinOps(\nint\n[] arr, \nint\nn) \n\n{ \n\nint\nans = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni=\n0\n,j=n-\n1\n; i<=j;) \n\n{ \n\n\n\n\n\nif\n(arr[i] == arr[j]) \n\n{ \n\ni++; \n\nj--; \n\n} \n\n\n\n\n\n\nelse\nif\n(arr[i] > arr[j]) \n\n{ \n\n\n\nj--; \n\narr[j] += arr[j+\n1\n] ; \n\nans++; \n\n} \n\n\n\n\nelse\n\n{ \n\ni++; \n\narr[i] += arr[i-\n1\n]; \n\nans++; \n\n} \n\n} \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n4\n, \n5\n, \n9\n, \n1\n} ; \n\nSystem.out.println(\n\"Count of minimum operations is \"\n+ \n\nfindMinOps(arr, arr.length)); \n\n\n} \n}", "index": 339, "complexity": "1"}
{"forwhile": "public class GennadyAndACardGame {\\n\\tpublic static void main(String[] args) throws IOException {\\n\\t\\tBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\\n\\t\\tBufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));\\n\\t\\tString line =null;\\n\\t\\tString[] n={};\\n\\t\\tString s=\"NO\";\\n\\t\\tfor(;(line=bufr.readLine())!=null;)    {\\n\\t\\t\\tif(\"over\".equals(line))\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tn=bufr.readLine().split(\" \");\\n\\t\\t\\tint i=0;\\n\\t\\t\\twhile(i<n.length){\\n\\t\\t\\t\\tif(n[i].contains(line.substring(0,1)) || n[i].contains(line.substring(1))){\\n\\t\\t\\t\\t\\ts=\"YES\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tSystem.out.println(s);\\n\\t\\t\\ts=\"NO\";\\n\\t\\t\\tbufw.flush();\\n\\t\\t}\\n\\t\\tbufw.close();                          \\n\\t}\\n}", "src": "public class GennadyAndACardGame {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tString line =null;\n\t\tString[] n={};\n\t\tString s=\"NO\";\n\t\twhile((line=bufr.readLine())!=null)    {\n\t\t\tif(\"over\".equals(line))\n\t\t\t\tbreak;\n\t\t\tn=bufr.readLine().split(\" \");\n\t\t\tfor(int i=0;i<n.length;i++){\n\t\t\t\tif(n[i].contains(line.substring(0,1)) || n[i].contains(line.substring(1))){\n\t\t\t\t\ts=\"YES\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(s);\n\t\t\ts=\"NO\";\n\t\t\tbufw.flush();\n\t\t}\n\t\tbufw.close();                          \n\t}\n}", "index": 340, "complexity": "1"}
{"forwhile": "class FindSmallestInteger  {     int findSmallest( int arr[], int n)   {     int res = 1;         int i = 0;     while(i < n && arr[i] <= res)     res = res + arr[i++];     return res;   }     public static void main(String[] args)   {     FindSmallestInteger small = new FindSmallestInteger();         int arr1[] = {1, 3, 4, 5};     int n1 = arr1.length;     System.out.println(small.findSmallest(arr1, n1));         int arr2[] = {1, 2, 6, 10, 11, 15};     int n2 = arr2.length;     System.out.println(small.findSmallest(arr2, n2));         int arr3[] = {1, 1, 1, 1};     int n3 = arr3.length;     System.out.println(small.findSmallest(arr3, n3));         int arr4[] = {1, 1, 3, 4};     int n4 = arr4.length;     System.out.println(small.findSmallest(arr4, n4));     } }", "src": "class\nFindSmallestInteger \n{ \n\n\n\n\n\nint\nfindSmallest(\nint\narr[], \nint\nn) \n\n{ \n\nint\nres = \n1\n; \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n && arr[i] <= res; i++) \n\nres = res + arr[i]; \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nFindSmallestInteger small = \nnew\nFindSmallestInteger(); \n\nint\narr1[] = {\n1\n, \n3\n, \n4\n, \n5\n}; \n\nint\nn1 = arr1.length; \n\nSystem.out.println(small.findSmallest(arr1, n1)); \n\n\nint\narr2[] = {\n1\n, \n2\n, \n6\n, \n10\n, \n11\n, \n15\n}; \n\nint\nn2 = arr2.length; \n\nSystem.out.println(small.findSmallest(arr2, n2)); \n\n\nint\narr3[] = {\n1\n, \n1\n, \n1\n, \n1\n}; \n\nint\nn3 = arr3.length; \n\nSystem.out.println(small.findSmallest(arr3, n3)); \n\n\nint\narr4[] = {\n1\n, \n1\n, \n3\n, \n4\n}; \n\nint\nn4 = arr4.length; \n\nSystem.out.println(small.findSmallest(arr4, n4)); \n\n\n} \n}", "index": 341, "complexity": "1"}
{"forwhile": "public class CodeForces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint d = in.nextInt(), sum = in.nextInt();\n\t\tList<Data> data = new ArrayList<>();\n\t\t\n\t\tint i = 0;\n\t\twhile(i < d) {\n\t\t\tint min = in.nextInt(), max = in.nextInt();\n\t\t\tint centre = (min + max) / 2;\n\t\t\tdata.add(new Data(centre - min, max - centre, centre));\n\t\t\tsum -= centre;\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tfor(Iterator<Data> it = data.iterator(); sum != 0;) {\n\t\t\tif (!it.hasNext()) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tData da = it.next();\n\n\t\t\tif (sum > 0) {\n\t\t\t\tda.centre += da.above;\n\t\t\t\tsum -= da.above;\n\t\t\t} else {\n\t\t\t\tda.centre -= da.below;\n\t\t\t\tsum += da.below;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n\t\t\n\t\tfor(Data da : data) {\n\t\t\tSystem.out.print(da.centre + \" \");\n\t\t}\n\t}\n}\n\nclass Data {\n\tint below, above, centre;\n\t\n\tData(int below, int above, int centre) {\n\t\tthis.below = below;\n\t\tthis.above = above;\n\t\tthis.centre = centre;\n\t}\n}", "src": "public class CodeForces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint d = in.nextInt(), sum = in.nextInt();\n\t\tList<Data> data = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < d; ++i) {\n\t\t\tint min = in.nextInt(), max = in.nextInt();\n\t\t\tint centre = (min + max) / 2;\n\t\t\tdata.add(new Data(centre - min, max - centre, centre));\n\t\t\tsum -= centre;\n\t\t}\n\t\t\n\t\tIterator<Data> it = data.iterator();\n\t\t\n\t\twhile (sum != 0) {\n\t\t\tif (!it.hasNext()) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tData da = it.next();\n\n\t\t\tif (sum > 0) {\n\t\t\t\tda.centre += da.above;\n\t\t\t\tsum -= da.above;\n\t\t\t} else {\n\t\t\t\tda.centre -= da.below;\n\t\t\t\tsum += da.below;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n\t\t\n\t\tfor (Data da : data) {\n\t\t\tSystem.out.print(da.centre + \" \");\n\t\t}\n\t}\n}\n\nclass Data {\n\tint below, above, centre;\n\t\n\tData(int below, int above, int centre) {\n\t\tthis.below = below;\n\t\tthis.above = above;\n\t\tthis.centre = centre;\n\t}\n}", "index": 342, "complexity": "1"}
{"forwhile": "public class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int n = in.nextInt(), l[] = new int[n],\n            p = -1000000, d_min = 1000000, min = 1000000000;\n        int i = 0;\n        while(i < n) {\n            l[i] = in.nextInt();\n            min = Math.min(min, l[i]);\n            i++;\n        }\n        i = 0;\n        while(i < n)\n            if(l[i] == min) {\n                d_min = Math.min(d_min, i - p);\n                p = i;\n            }\n            i++;\n        out.print(d_min);\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\" \");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public String nextLine() throws IOException {\n            for(; !st.hasMoreTokens(); st = new StringTokenizer(br.readLine())) {\n            }\n            String r = st.nextToken(\"\\n\");\n            st = new StringTokenizer(br.readLine(), \" \");\n            return r;\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}", "src": "public class Main {\n    \n    static Scanner in = new Scanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) throws IOException {\n        int n = in.nextInt(), l[] = new int[n],\n            p = -1000000, d_min = 1000000, min = 1000000000;\n        for(int i = 0; i < n; i++) {\n            l[i] = in.nextInt();\n            min = Math.min(min, l[i]);\n        }\n        for(int i = 0; i < n; i++)\n            if(l[i] == min) {\n                d_min = Math.min(d_min, i - p);\n                p = i;\n            }\n        out.print(d_min);\n        out.close();\n    }\n    \n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer(\"\");\n        }\n        \n        public String next() throws IOException {\n            if(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        \n        public String nextLine() throws IOException {\n            while(!st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            String r = st.nextToken(\"\\n\");\n            st = new StringTokenizer(br.readLine(), \" \");\n            return r;\n        }\n        \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}", "index": 343, "complexity": "1"}
{"forwhile": "public class Codechef {\n     \n\n  public static void main(String[] args) throws IOException {\n\tScanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a=sc.nextInt();\n    int b=sc.nextInt();\n      int res=0;\n     int i = 1;\n     while(i < n) {\n         res = Math.max(res, Math.min(a/i, b/(n-i) ) );\n         i++;\n     }\n     System.out.println(res);\n  }\n\n   }", "src": "public class Codechef {\n     \n\n  public static void main(String[] args) throws IOException {\n\tScanner sc=new Scanner(System.in);\n    int n=sc.nextInt();\n    int a=sc.nextInt();\n    int b=sc.nextInt();\n      int res=0;\n     for(int i=1;i<n;i++)\n     res=Math.max(res, Math.min(a/i, b/(n-i) ) );\n     System.out.println(res);\n  }\n\n   }", "index": 344, "complexity": "1"}
{"forwhile": "public class practise {\n    static final int N = 31;\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out, true);\n    static long c[] = new long[N];\n    static int w[] = new int[N];\n    public static void main(String[] args) {\n        w[0] = 1;\n        int i = 1;\n        while(i < N) {\n            w[i] = w[i - 1] * 2;\n            i++;\n        }\n        int n = sc.nextInt();\n        int l = sc.nextInt();\n        int j = 0;\n        while(j < N) {\n            c[j] = Long.MAX_VALUE;\n            j++;\n        }\n        int k = 0;\n        while(k < n) {\n            c[k] = sc.nextInt();\n            k++;\n        }\n        i = 1;\n        while(i < N) {\n            c[i] = min(c[i - 1] * 2, c[i]);\n            i++;\n        }\n        long ans = 0;\n        int m = 0;\n        for(int p = 0; p < N; p++) {\n            if ((l & w[p]) != 0) {\n                ans += c[p];\n            }\n        }\n        for(int q = N - 1; q >= 0; q--) {\n            if ((l & w[q]) != 0) {\n                m += c[q];\n            } else {\n                ans = min(ans, m + c[q]);\n            }\n        }\n        out.println(ans);\n    }\n\n    static long min(long a, long b) {\n        return a < b ? a : b;\n    }\n}", "src": "public class practise {\n    static final int N = 31;\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out,true);\n    static long c[] = new long[N];\n    static int w[] = new int[N];\n    public static void main(String[] args) {\n        w[0] = 1;\n        for(int i=1;i<N;i++) w[i] = w[i-1]*2;\n        int n = sc.nextInt(); int l = sc.nextInt();\n        for(int i=0;i<N;i++) c[i] = Long.MAX_VALUE;\n        for(int i=0;i<n;i++) c[i] = sc.nextInt();\n        for(int i=1;i<N;i++) {\n            c[i] = min(c[i-1]*2,c[i]);\n        }\n        long ans = 0;\n        for(int i=0;i<N;i++) {\n            if( (l&w[i])!=0) {\n                ans += c[i];\n            }\n        }\n        long m = 0;\n        for(int i=N - 1;i>=0;i--) {\n            if((l&w[i])!=0) {\n                m += c[i];\n            } else {\n                ans = min(ans,m+c[i]);\n            }\n        }\n        out.println(ans);\n    }\n\n    static long min(long a,long b) {\n        return a<b?a:b;\n    }\n}", "index": 345, "complexity": "1"}
{"forwhile": "public class Main{\n    public static void main(String[] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        char c[]=new char[n];\n        Arrays.fill(c,'o');\n        int x=1,y=1,z;\n        for(y=1; y<=n; )\n        {\n            c[y-1]='O';\n            z=x+y;\n            x=y;\n            y=z;\n        }\n        String ans=new String(c);\n        System.out.println(ans);\n    }\n}", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        char c[]=new char[n];\n        Arrays.fill(c,'o');\n        int x=1,y=1,z;\n        while(y<=n)\n        {\n            c[y-1]='O';\n            z=x+y;\n            x=y;\n            y=z;\n        }\n        String ans=new String(c);\n        System.out.println(ans);\n    }\n}", "index": 346, "complexity": "1"}
{"forwhile": "public class java{\n          public static void main(String[]arg) {\n        \t Scanner sc=new Scanner(System.in); \n        \t int x=sc.nextInt();\n        \t String s=sc.next();\n        \t boolean f=true;\n        \t boolean f2=true;\n        \t boolean f3=true;\n        \t boolean f4=true;\n        \t int v=0;\n        \t int i=0;\n        \t while(i<s.length()-1) {\n        \t\t if(s.charAt(i)==s.charAt(i+1)&&(s.charAt(i)!='?'||s.charAt(i+1)!='?')) {\n        \t\t\t f=false;\n        \t\t\t break;\n        \t\t }else {\n        \t\t\t f=true;\n        \t\t }\n        \t\t i++;\n        \t }\n        \t\n        \t \n        \t for(int i=0;i<s.length();i++) {\n        \t\t if(s.charAt(i)=='?') {\n        \t\t\t \n        \t\t\t if(i==0||i==s.length()-1) {\n        \t\t\t\t f2=true; \n        \t\t\t\t v++;\n        \t\t\t }else if(s.charAt(i)==s.charAt(i+1)) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t          }\n        \t\t\t else if(s.charAt(i-1)==s.charAt(i+1)&&i!=0&&i!=s.length()-1) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t         }\n        \t\t\t }else {\n        \t\t\t\t if(v>0) f2=true;\n        \t\t\t\t else f2=false;\n        \t\t\t }\n        \t\t }\n        \t \n        \tif(f&&f2) {\n        \t\tSystem.out.println(\"YES\");\n        \t}else {\n        \t\tSystem.out.println(\"NO\");\n        \t}\n          }\n          \n}", "src": "public class java{\n          public static void main(String[]arg) {\n        \t Scanner sc=new Scanner(System.in); \n        \t int x=sc.nextInt();\n        \t String s=sc.next();\n        \t boolean f=true;\n        \t boolean f2=true;\n        \t boolean f3=true;\n        \t boolean f4=true;\n        \t int v=0;\n        \t for(int i=0;i<s.length()-1;i++) {\n        \t\t if(s.charAt(i)==s.charAt(i+1)&&(s.charAt(i)!='?'||s.charAt(i+1)!='?')) {\n        \t\t\t f=false;\n        \t\t\t break;\n        \t\t }else {\n        \t\t\t f=true;\n        \t\t }\n        \t }\n        \t\n        \t \n        \t for(int i=0;i<s.length();i++) {\n        \t\t if(s.charAt(i)=='?') {\n        \t\t\t \n        \t\t\t if(i==0||i==s.length()-1) {\n        \t\t\t\t f2=true; \n        \t\t\t\t v++;\n        \t\t\t }else if(s.charAt(i)==s.charAt(i+1)) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t          }\n        \t\t\t else if(s.charAt(i-1)==s.charAt(i+1)&&i!=0&&i!=s.length()-1) {\n        \t\t\t\t\t f2=true;\n        \t\t\t\t\t v++;\n        \t\t\t         }\n        \t\t\t }else {\n        \t\t\t\t if(v>0) f2=true;\n        \t\t\t\t else f2=false;\n        \t\t\t }\n        \t\t }\n        \t \n        \tif(f&&f2) {\n        \t\tSystem.out.println(\"YES\");\n        \t}else {\n        \t\tSystem.out.println(\"NO\");\n        \t}\n          }\n          \n}", "index": 347, "complexity": "1"}
{"forwhile": "class Test  {\n\nstatic int arr1[] = new int[]{0, 1, 0, 1, 1, 1, 1}; \n\nstatic int arr2[] = new int[]{1, 1, 1, 1, 1, 0, 1}; \n\nstatic int longestCommonSum(int n) \n\n{ \n\n\nint maxLen = 0; \n\nint preSum1 = 0, preSum2 = 0; \n\n\n\nint diff[] = new int[2*n+1]; \n\nint i = 0;\nwhile(i < diff.length) { \n\ndiff[i] = -1; \n\ni++; \n} \n\nint i=0;\nfor(; i<n; i++) {\n\npreSum1 += arr1[i]; \n\npreSum2 += arr2[i]; \n\nint curr_diff = preSum1 - preSum2; \n\nint diffIndex = n + curr_diff; \n\nif(curr_diff == 0) \n\nmaxLen = i+1; \n\nelse if( diff[diffIndex] == -1) \n\ndiff[diffIndex] = i; \n\nelse\n\n{ \n\nint len = i - diff[diffIndex]; \n\nif(len > maxLen) \n\nmaxLen = len; \n\n} \n} \n\nreturn maxLen; \n\n} \n\npublic static void main(String[] args) \n\n{ \n\nSystem.out.print(\"Length of the longest common span with same sum is \"); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n}", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n0\n, \n1\n, \n0\n, \n1\n, \n1\n, \n1\n, \n1\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n1\n}; \n\n\n\n\n\n\nstatic\nint\nlongestCommonSum(\nint\nn) \n\n{ \n\n\n\nint\nmaxLen = \n0\n; \n\n\n\n\nint\npreSum1 = \n0\n, preSum2 = \n0\n; \n\n\n\n\n\n\n\n\n\n\nint\ndiff[] = \nnew\nint\n[\n2\n*n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < diff.length; i++) { \n\ndiff[i] = -\n1\n; \n\n} \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\npreSum1 += arr1[i]; \n\npreSum2 += arr2[i]; \n\n\n\n\n\n\n\n\nint\ncurr_diff = preSum1 - preSum2; \n\nint\ndiffIndex = n + curr_diff; \n\n\n\n\n\n\n\n\nif\n(curr_diff == \n0\n) \n\nmaxLen = i+\n1\n; \n\n\n\n\n\n\nelse\nif\n( diff[diffIndex] == -\n1\n) \n\ndiff[diffIndex] = i; \n\n\n\n\nelse\n\n{ \n\n\n\nint\nlen = i - diff[diffIndex]; \n\n\n\n\nif\n(len > maxLen) \n\nmaxLen = len; \n\n} \n\n} \n\nreturn\nmaxLen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print(\n\"Length of the longest common span with same sum is \"\n); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n}", "index": 348, "complexity": "1"}
{"forwhile": "public class Codeforces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, f[], c = 0;\n\t\tn = in.nextInt();\n\t\tf = new int[n];\n\t\tn--;\n\t\twhile (n > 0) {\n\t\t\tf[in.nextInt() - 1]++;\n\t\t\tf[in.nextInt() - 1]++;\n\t\t\tin.nextLine();\n\t\t\tn--;\n\t\t}\n\t\tint i = 0;\n\t\twhile (i < f.length) {\n\t\t\tif (f[i] == 1) c++;\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(c);\n\t}\n\n}", "src": "public class Codeforces {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, f[], c=0;\n\t\tn = in.nextInt();\n\t\tf = new int[n];\n\t\twhile (--n>0){\n\t\t\tf[in.nextInt()-1] ++;\n\t\t\tf[in.nextInt()-1]++;\n\t\t\tin.nextLine();\n\t\t}\n\t\tfor(int i=0; i<f.length; i++) if (f[i] == 1) c++;\n\t\tSystem.out.println(c);\n\t}\n\n}", "index": 349, "complexity": "1"}
{"forwhile": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            for(; token==null || !token.hasMoreTokens(); )\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        long a;\n        int i;\n        public card(long a,int i)\n        {\n            this.a=a;\n            this.i=i;\n        }\n    }\n    static class sort implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.a!=o2.a)\n                return (int)(o1.a-o2.a);\n            else\n                return (int)(o1.b-o2.b);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        int i=0;\n        while(i<a.length)\n        {\n            l.add(a[i]);\n            i++;\n        }\n        Collections.shuffle(l);\n        i=0;\n        while(i<a.length)\n        {\n            a[i]=l.get(i);\n            i++;\n        }\n    }\n\n    \n    \n    static class pair{\n        int a,b;\n        public pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        char c[]=sc.next().toCharArray();\n        int l=c.length;\n        int a[]=new int[3];\n        int i=0;\n        while(i<l)\n        {\n            a[c[i]-'a']++;\n           if(i>0 && c[i]<c[i-1])\n           {\n               System.out.println(\"NO\");\n               System.exit(0);\n           }\n           i++;\n        }\n        if(a[0]>0 && a[1]>0 && (a[2]==a[1] || a[2]==a[0]))\n        System.out.println(\"YES\");\n        else\n        System.out.println(\"NO\");\n    }\n}", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        long a;\n        int i;\n        public card(long a,int i)\n        {\n            this.a=a;\n            this.i=i;\n        }\n    }\n    static class sort implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.a!=o2.a)\n                return (int)(o1.a-o2.a);\n            else\n                return (int)(o1.b-o2.b);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    \n    static class pair{\n        int a,b;\n        public pair(int a,int b)\n        {\n            this.a=a;\n            this.b=b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        char c[]=sc.next().toCharArray();\n        int l=c.length;\n        int a[]=new int[3];\n        for(int i=0;i<l;i++)\n        {\n            a[c[i]-'a']++;\n           if(i>0 && c[i]<c[i-1])\n           {\n               System.out.println(\"NO\");\n               System.exit(0);\n           }\n        }\n        if(a[0]>0 && a[1]>0 && (a[2]==a[1] || a[2]==a[0]))\n        System.out.println(\"YES\");\n        else\n        System.out.println(\"NO\");\n    }\n}", "index": 350, "complexity": "1"}
{"forwhile": "public class GFG {\n\tpublic static void main (String[] args) {\n\t    Scanner sc = new Scanner (System.in);\n\t    int n = sc.nextInt();\n\t    int a = sc.nextInt();\n\t    int b = sc.nextInt();\n\t    int c = sc.nextInt();\n\t    int ans = 0;\n\t    int t= sc.nextInt();\n\t    int arr[] = new int[n];\n\t    int i=0;\n\t    while(i<n){\n\t        int nn = sc.nextInt();\n\t        ans+=a;\n\t        if(b<c){\n\t            ans += (t-nn) * (c - b);\n\t        }\n\t        i++;\n\t    }\n\t    System.out.println(ans);\n\t}\n}", "src": "public class GFG {\n\tpublic static void main (String[] args) {\n\t    Scanner sc = new Scanner (System.in);\n\t    int n = sc.nextInt();\n\t    int a = sc.nextInt();\n\t    int b = sc.nextInt();\n\t    int c = sc.nextInt();\n\t    int ans = 0;\n\t    int t= sc.nextInt();\n\t    int arr[] = new int[n];\n\t    for(int i=0;i<n;i++){\n\t        int nn = sc.nextInt();\n\t        ans+=a;\n\t        if(b<c){\n\t            ans += (t-nn) * (c - b);\n\t        }\n\t    }\n\t    System.out.println(ans);\n\t}\n}", "index": 351, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class C {\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\t\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] counts = new int[60];\n\t\tArrayList<ArrayDeque<Long>> nums = new ArrayList<>();\n\t\tfor (int i = 0; i < 60; i++) {\n\t\t\tnums.add(new ArrayDeque<>());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong num = sc.nextLong();\n\t\t\tfor (int j = 1; j <= 60; ++j) {\n\t\t\t\tif (num < (1L<<j)) {\n\t\t\t\t\tnums.get(j-1).add(num);\n\t\t\t\t\t++counts[j-1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong curr = 0;\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= 60; ++j) {\n\t\t\t\tif (j==60) {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (counts[j]==0||(curr&(1L<<j))!=0)\n\t\t\t\t\tcontinue;\n\t\t\t\tlong num = nums.get(j).removeFirst();\n\t\t\t\t--counts[j];\n\t\t\t\tcurr ^= num;\n\t\t\t\tif (i>0)\n\t\t\t\t\tans.append(\" \");\n\t\t\t\tans.append(num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 352, "complexity": "1"}
{"forwhile": "public class TwoGram {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        String s = sc.next();\n\n        HashMap <String, Integer> hm = new HashMap<>();\n        int i = 0;\n        while(i < n - 1) {\n            String curr = s.substring(i, i + 2);\n\n            if (hm.containsKey(curr)) {\n                hm.put(curr, hm.get(curr) + 1);\n            } else {\n                hm.put(curr, 1);\n            }\n            i++;\n        }\n\n        String ans = \"\";\n        int currMax = 0;\n        for (String twoGram : hm.keySet()) {\n            if (hm.get(twoGram) > currMax) {\n                ans = twoGram;\n                currMax = hm.get(twoGram);\n            }\n        }\n\n        System.out.println(ans);\n\n        sc.close();\n    }\n}", "src": "public class TwoGram {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        String s = sc.next();\n\n        HashMap <String, Integer> hm = new HashMap<>();\n        for (int i = 0; i < n - 1; i++) {\n            String curr = s.substring(i, i + 2);\n\n            if (hm.containsKey(curr)) {\n                hm.put(curr, hm.get(curr) + 1);\n            } else {\n                hm.put(curr, 1);\n            }\n        }\n\n        String ans = \"\";\n        int currMax = 0;\n        for (String twoGram : hm.keySet()) {\n            if (hm.get(twoGram) > currMax) {\n                ans = twoGram;\n                currMax = hm.get(twoGram);\n            }\n        }\n\n        System.out.println(ans);\n\n        sc.close();\n    }\n}", "index": 353, "complexity": "1"}
{"forwhile": "public class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(bf.readLine());\n        int[]f=new int[1001];\n        int[]a=new int[n];\n        StringTokenizer tk=new StringTokenizer(bf.readLine());\n        int i = 0;\n        while(i < n) {\n            int element=Integer.parseInt(tk.nextToken());\n            a[i]=element;\n            f[element]++;\n            i++;\n        }\n        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        ArrayList<Integer> h=new ArrayList<>();\n        int counter=0;\n        i = 0;\n        while(i < n) {\n            if(f[a[i]]==1){counter++; h.add(a[i]);}\n            else{f[a[i]]-=1;}\n            i++;\n        }\n        pw.write(counter+\"\\n\");\n        for(i = 0; i < h.size(); i++) {\n            pw.write(h.get(i)+\" \");\n        }\n        pw.flush();\n    }\n}", "src": "public class Main {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(bf.readLine());\n        int[]f=new int[1001];\n        int[]a=new int[n];\n        StringTokenizer tk=new StringTokenizer(bf.readLine());\n        for (int i = 0; i < n; i++) {\n            int element=Integer.parseInt(tk.nextToken());\n            a[i]=element;\n            f[element]++;\n        }\n        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        ArrayList<Integer> h=new ArrayList<>();\n        int counter=0;\n        for (int i = 0; i < n; i++) {\n            if(f[a[i]]==1){counter++; h.add(a[i]);}\n            else{f[a[i]]-=1;}\n        }\n        pw.write(counter+\"\\n\");\n        for (int i = 0; i < h.size(); i++) {\n            pw.write(h.get(i)+\" \");\n        }\n        pw.flush();\n    }\n}", "index": 354, "complexity": "1"}
{"forwhile": "class MergeArrays { void moveToEnd(int mPlusN[], int size) { int i, j = size - 1; while (j >= 0) { if (mPlusN[j] != -1) { mPlusN[j] = mPlusN[j]; j--; } } } void merge(int mPlusN[], int N[], int m, int n) { int i = n; int j = 0; for (int k = 0; k < (m + n); k++) { if ((i < (m + n) && mPlusN[i] <= N[j]) || (j == n)) { mPlusN[k] = mPlusN[i]; k++; i++; } else { mPlusN[k] = N[j]; k++; j++; } } } void printArray(int arr[], int size) { int i = 0; while(i < size) { System.out.print(arr[i] + \" \"); i++; } System.out.println(); } public static void main(String[] args) { MergeArrays mergearray = new MergeArrays(); int mPlusN[] = {2, 8, -1, -1, -1, 13, -1, 15, 20}; int N[] = {5, 7, 9, 25}; int n = N.length; int m = mPlusN.length - n; mergearray.moveToEnd(mPlusN, m + n); mergearray.merge(mPlusN, N, m, n); mergearray.printArray(mPlusN, m + n); } }", "src": "class\nMergeArrays \n{ \n\n\n\nvoid\nmoveToEnd(\nint\nmPlusN[], \nint\nsize) \n\n{ \n\nint\ni, j = size - \n1\n; \n\nfor\n(i = size - \n1\n; i >= \n0\n; i--) \n\n{ \n\nif\n(mPlusN[i] != -\n1\n) \n\n{ \n\nmPlusN[j] = mPlusN[i]; \n\nj--; \n\n} \n\n} \n\n} \n\n\n\n\nvoid\nmerge(\nint\nmPlusN[], \nint\nN[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = n; \n\n\n\n\nint\nj = \n0\n; \n\n\n\n\nint\nk = \n0\n; \n\n\n\n\nwhile\n(k < (m + n)) \n\n{ \n\n\n\nif\n((i < (m + n) && mPlusN[i] <= N[j]) || (j == n)) \n\n{ \n\nmPlusN[k] = mPlusN[i]; \n\nk++; \n\ni++; \n\n} \n\nelse\n\n\n{ \n\nmPlusN[k] = N[j]; \n\nk++; \n\nj++; \n\n} \n\n} \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n\n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n\nSystem.out.println(\n\"\"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMergeArrays mergearray = \nnew\nMergeArrays(); \n\n\n\n\nint\nmPlusN[] = {\n2\n, \n8\n, -\n1\n, -\n1\n, -\n1\n, \n13\n, -\n1\n, \n15\n, \n20\n}; \n\nint\nN[] = {\n5\n, \n7\n, \n9\n, \n25\n}; \n\nint\nn = N.length; \n\nint\nm = mPlusN.length - n; \n\n\n\n\nmergearray.moveToEnd(mPlusN, m + n); \n\n\n\n\nmergearray.merge(mPlusN, N, m, n); \n\n\n\n\nmergearray.printArray(mPlusN, m + n); \n\n} \n}", "index": 355, "complexity": "1"}
{"forwhile": "public class Practice {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.nextLine();\n\t\tint n = 0;\n\t\tint m = 0;\n\t\tint i = 0;\n\t\twhile (i < s.length()) {\n\t\t\tif (s.charAt(i) == '-') {\n\t\t\t\tn++;\n\t\t\t} else {\n\t\t\t\tm++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (m == 0) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t} else {\n\t\t\tif (n % m == 0) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n}", "src": "public class Practice {\n\t\n\t   \n\n\t\tpublic static void main(String []args)\n\t\t{\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\t\n\t\t\t\n\t\t\tString s=sc.nextLine();\n\t\t\tint n=0;\n\t\t\tint m=0;\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)=='-')\n\t\t\t\t{\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif(n%m==0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t}\n\n}", "index": 356, "complexity": "1"}
{"forwhile": "import java.util.*; class\nGeeks \n{ \n\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n{ \n\nfor(int i = start; i < end; i++) { \n\nint\ntemp = arr[i]; \n\narr[i] = arr[end]; \n\narr[end] = temp; \n\nstart++; \n\nend--; \n\n} \n} \n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n{ \n\nint i = 0;\nwhile(i < size) { \n\nSystem.out.print(arr[i] +\n\" \"); \n\ni++; \n\n} \n} \n\n\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nk, \nint\nn) \n{ \n\nint i = 0;\nwhile(i < n - 1) { \n\nrvereseArray(arr, i, n); \n\nrvereseArray(arr, i, n - k - 1); \n\nrvereseArray(arr, n - k, n - 1); \n\ni++; \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n12, 10, 5, 6, 52, 36}; \n\nint\nn = arr.length; \n\nint\nk = \n2;\n\n\n\n\nsplitArr(arr, k, n); \n\nprintArray(arr, n); \n\n} \n\n}", "src": "class\nGeeks \n{ \n\n\nstatic\nvoid\nrvereseArray(\nint\narr[], \nint\nstart, \nint\nend) \n{ \n\nwhile\n(start < end) { \n\nint\ntemp = arr[start]; \n\narr[start] = arr[end]; \n\narr[end] = temp; \n\nstart++; \n\nend--; \n\n} \n} \n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nsize) \n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n} \n\n\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nk, \nint\nn) \n{ \n\nrvereseArray(arr, \n0\n, n - \n1\n); \n\nrvereseArray(arr, \n0\n, n - k - \n1\n); \n\nrvereseArray(arr, n - k, n - \n1\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\n\n\n\nsplitArr(arr, k, n); \n\nprintArray(arr, n); \n\n} \n\n}", "index": 357, "complexity": "1"}
{"forwhile": "public class GFG { static void sortit(int []arr, int n) { int i = 0; while(i < n) { arr[i]=i+1; i++; } } public static void main(String args[]) { int []arr = {10, 7, 9, 2, 8, 3, 5, 4, 6, 1}; int n = arr.length; sortit(arr, n); int i = 0; while(i < n) System.out.print(arr[i] + \" \"); } }", "src": "public\nclass\nGFG { \n\n\n\n\n\nstatic\nvoid\nsortit(\nint\n[]arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i]=i+\n1\n; \n\n\n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n7\n, \n9\n, \n2\n, \n8\n, \n\n3\n, \n5\n, \n4\n, \n6\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n\n\nsortit(arr, n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 358, "complexity": "1"}
{"forwhile": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D2C982_cut_them_all solver = new D2C982_cut_them_all();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D2C982_cut_them_all {\n        int n;\n        ArrayList<Integer>[] adj;\n        int[] sizes;\n        boolean[] visited;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            n = in.nextInt();\n            if ((n & 1) == 1) {\n                out.println(-1);\n                return;\n            }\n            sizes = new int[n];\n            visited = new boolean[n];\n            adj = new ArrayList[n];\n            int i = 0;\n            while (i < n) {\n                adj[i] = new ArrayList<>();\n                i++;\n            }\n\n            int i = 1;\n            while (i < n) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n                i++;\n            }\n\n            int root = 0;\n            int i = 1;\n            while (i < n) {\n                if (adj[i].size() > adj[root].size()) {\n                    root = i;\n                }\n                i++;\n            }\n\n            dfs(root);\n            int cnt = 0;\n            int i = 0;\n            while (i < n) {\n                if ((sizes[i] & 1) == 0) cnt++;\n                i++;\n            }\n            out.println(cnt - 1);\n\n        }\n\n        int dfs(int u) {\n\n            visited[u] = true;\n            int cnt = 1;\n\n            for (int i = 0; i < adj[u].size(); i++) {\n                int w = adj[u].get(i);\n                if (!visited[w])\n                    cnt += dfs(w);\n            }\n\n            sizes[u] = cnt;\n            return cnt;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (c == ' ' || c == '\\n' || c == '\\r' || c == '\\t') {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            while (!(c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1)) {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ';\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D2C982_cut_them_all solver = new D2C982_cut_them_all();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D2C982_cut_them_all {\n        int n;\n        ArrayList<Integer>[] adj;\n        int[] sizes = new int[n];\n        boolean[] visited = new boolean[n];\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            n = in.nextInt();\n            if ((n & 1) == 1) {\n                out.println(-1);\n                return;\n            }\n            sizes = new int[n];\n            visited = new boolean[n];\n            adj = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            for (int i = 1; i < n; i++) {\n                int u = in.nextInt() - 1;\n                int v = in.nextInt() - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n\n            int root = 0;\n            for (int i = 1; i < n; i++) {\n                if (adj[i].size() > adj[root].size()) {\n                    root = i;\n                }\n            }\n\n            dfs(root);\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                if ((sizes[i] & 1) == 0) cnt++;\n            }\n            out.println(cnt - 1);\n\n        }\n\n        int dfs(int u) {\n\n            visited[u] = true;\n            int cnt = 1;\n\n            for (int w : adj[u])\n                if (!visited[w])\n                    cnt += dfs(w);\n\n            sizes[u] = cnt;\n            return cnt;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}", "index": 360, "complexity": "1"}
{"forwhile": "class GFG { static boolean sortedAfterSwap(int A[], boolean B[],int n) { int i, j; i = 0; while(i < n - 1) { if(B[i]) { j = i; for(; B[j]; j++) { } Arrays.sort(A, i, 1 + j); i = j; } i++; } i = 0; for(; i < n;) { if(A[i] != i + 1) { return false; } i++; } return true; } public static void main(String[] args) { int A[] = { 1, 2, 5, 3, 4, 6 }; boolean B[] = { false, true, true, true, false }; int n = A.length; if(sortedAfterSwap(A, B, n)) { System.out.println(\\\"A can be sorted\\\"); } else { System.out.println(\\\"A can not be sorted\\\"); } } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nsortedAfterSwap(\nint\nA[], \n\nboolean\nB[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\n\n\n\n\nfor\n(i = \n0\n; i < n - \n1\n; i++) { \n\nif\n(B[i]) { \n\nj = i; \n\nwhile\n(B[j]) { \n\nj++; \n\n} \n\n\n\nArrays.sort(A, i, \n1\n+ j); \n\ni = j; \n\n} \n\n} \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) { \n\nif\n(A[i] != i + \n1\n) { \n\nreturn\nfalse\n; \n\n} \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n1\n, \n2\n, \n5\n, \n3\n, \n4\n, \n6\n}; \n\nboolean\nB[] = { \nfalse\n, \ntrue\n, \ntrue\n, \ntrue\n, \nfalse\n}; \n\nint\nn = A.length; \n\n\nif\n(sortedAfterSwap(A, B, n)) { \n\nSystem.out.println(\n\"A can be sorted\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"A can not be sorted\"\n); \n\n} \n\n} \n}", "index": 361, "complexity": "1"}
{"forwhile": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt(), t;\n        int[] a = new int[101];\n        int answ = 0;\n        long i = 0;\n        while(i < n) {\n            t = in.nextInt();\n            a[t]++;\n            if (a[t] < 2) {\n                if (answ < k) {\n                    data.append(i + 1).append(\" \");\n                    answ++;\n                }\n            }\n            i++;\n        }\n        if (answ == k) {\n            System.out.println(\"YES\");\n            System.out.println(data);\n        } else {\n            System.out.println(\"NO\");\n        }\n\n\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            st = null;\n            while(st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "src": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), k = in.nextInt(), t;\n        int[] a = new int[101];\n        int answ = 0;\n        for (long i = 0; i < n; i++) {\n            t = in.nextInt();\n            a[t]++;\n            if (a[t] < 2) {\n                if (answ < k) {\n                    data.append(i + 1).append(\" \");\n                    answ++;\n                }\n            }\n\n        }\n        if (answ == k) {\n            System.out.println(\"YES\");\n            System.out.println(data);\n        } else {\n            System.out.println(\"NO\");\n        }\n\n\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 362, "complexity": "1"}
{"forwhile": "public class Main {\n    public static void main(String[] args) {\n        IO io = new IO();\n        String s = io.nextLine();\n        if (s.length() < 3) io.println(\"No\");\n        else {\n            int[] b = new int[200];\n            int i = 2;\n            while (i < s.length()) {\n                b['.'] = b['A'] = b['B'] = b['C'] = 0;\n                b[s.charAt(i - 2)] = 1;\n                b[s.charAt(i - 1)] = 1;\n                b[s.charAt(i)] = 1;\n                if (b['A'] + b['B'] + b['C'] == 3) {\n                    io.println(\"Yes\");\n                    return;\n                }\n                i++;\n            }\n            io.println(\"No\");\n        }\n    }\n\n    static class IO {\n\n        BufferedInputStream din;\n        final int BUFFER_SIZE = 1 << 16;\n        byte[] buffer;\n        int byteRead, bufferPoint;\n\n        StringBuilder builder;\n        PrintWriter pw;\n\n        public IO() {\n            din = new BufferedInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPoint = byteRead = 0;\n\n            builder = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                    System.out\n            )), true);\n        }\n\n        int read() {\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (byteRead == -1) buffer[0] = -1;\n            }\n            return buffer[bufferPoint++];\n        }\n\n        int peek() {\n            if (byteRead == -1) return -1;\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (byteRead <= 0) return -1;\n            }\n            return buffer[bufferPoint];\n        }\n\n        boolean hasNext() {\n            int c = peek();\n            for (; c != -1 && c <= ' '; c = peek()) {\n                read();\n            }\n            return c != -1;\n        }\n\n        char nextChar() {\n            int c = read();\n            for (; c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; c = read()) {\n            }\n            return (char) c;\n        }\n\n        double nextDouble() {\n            double ret = 0, div = 1;\n            int c = read();\n            for (; c <= ' '; c = read()) {\n            }\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        String nextLine() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0;\n            int c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n        String next() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0;\n            int c;\n            while ((c = read()) != -1) {\n                if (Character.isWhitespace(c)) {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n        int nextInt() {\n            int ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        long nextLong() {\n            long ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        void println(Object o) {\n            pw.println(o);\n        }\n\n        void print(Object o) {\n            pw.print(o);\n        }\n\n        void printf(String format, Object... objects) {\n            pw.printf(format, objects);\n        }\n\n        void close() {\n            pw.close();\n        }\n\n        void done(Object o) {\n            print(o);\n            close();\n        }\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        IO io = new IO();\n        String s=io.nextLine();\n        if (s.length()<3)io.println(\"No\");\n        else {\n            int[]b=new int[200];\n            for (int i=2;i<s.length();i++){\n                b['.']=b['A']=b['B']=b['C']=0;\n                b[s.charAt(i-2)]=1;\n                b[s.charAt(i-1)]=1;\n                b[s.charAt(i)]=1;\n                if (b['A']+b['B']+b['C']==3){io.println(\"Yes\");return;}\n            }\n            io.println(\"No\");\n        }\n    }\n\n\n    static class IO {\n\n        BufferedInputStream din;\n        final int BUFFER_SIZE = 1 << 16;\n        byte[] buffer;\n        int byteRead, bufferPoint;\n\n        StringBuilder builder;\n        PrintWriter pw;\n\n        public IO() {\n            din = new BufferedInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPoint = byteRead = 0;\n\n            builder = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                    System.out\n            )), true);\n        }\n\n        int read() {\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (byteRead == -1) buffer[0] = -1;\n            }\n            return buffer[bufferPoint++];\n        }\n\n        int peek() {\n            if (byteRead == -1) return -1;\n            if (bufferPoint >= byteRead) {\n                try {\n                    byteRead = din.read(buffer, bufferPoint = 0, BUFFER_SIZE);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (byteRead <= 0) return -1;\n            }\n            return buffer[bufferPoint];\n        }\n\n        boolean hasNext() {\n            int c = peek();\n            while (c != -1 && c <= ' ') {\n                read();\n                c = peek();\n            }\n            return c != -1;\n        }\n\n        char nextChar() {\n            int c = read();\n            while (c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        double nextDouble() {\n            double ret = 0, div = 1;\n            int c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        String nextLine() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n\n        String next() {\n            byte[] strBuf = new byte[64];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (Character.isWhitespace(c)) {\n                    if (cnt == 0) {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if (strBuf.length == cnt) {\n                    strBuf = Arrays.copyOf(strBuf, strBuf.length * 2);\n                }\n                strBuf[cnt++] = (byte) c;\n            }\n            return new String(strBuf, 0, cnt);\n        }\n\n        int nextInt() {\n            int ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        long nextLong() {\n            long ans = 0;\n            int c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ans = ans * 10 + c - '0';\n            } while ('0' <= (c = read()) && c <= '9');\n            bufferPoint--;\n            return neg ? -ans : ans;\n        }\n\n        void println(Object o) {\n            pw.println(o);\n        }\n\n        void print(Object o) {\n            pw.print(o);\n        }\n\n        void printf(String format, Object... objects) {\n            pw.printf(format, objects);\n        }\n\n        void close() {\n            pw.close();\n        }\n\n        void done(Object o) {\n            print(o);\n            close();\n        }\n\n    }\n}", "index": 363, "complexity": "1"}
{"forwhile": "public class icpc\n{\n    public static void main(String[] args)throws IOException\n    {\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n        String s1[] = in.readLine().split(\" \");\n        int  n = Integer.parseInt(s1[0]);\n        int p = Integer.parseInt(s1[1]);\n        String s = in.readLine();\n        StringBuilder stringBuilder = new StringBuilder(s);\n        boolean flag = false;\nint i=0;\n        while(i<n)\n        {\n            if(i + p < n)\n            {\n                if(s.charAt(i) != \".\" && s.charAt(i + p) != \".\" && s.charAt(i) != s.charAt(i + p))\n                {\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == \".\" && s.charAt(i + p) != \".\")\n                {\n                    int x = s.charAt(i + p) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) != \".\" && s.charAt(i + p) == \".\")\n                {\n                    int x = s.charAt(i) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i + p, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == \".\" && s.charAt(i + p) == \".\")\n                {\n                    stringBuilder.setCharAt(i, '1');\n                    stringBuilder.setCharAt(i + p, '0');\n                    flag = true;\n                    break;\n                }\n            i++;\n        }\n        } \n        if(flag)\n        {\nint i=0;\n            while(i<stringBuilder.length())\n            {\n                if(stringBuilder.charAt(i) == \".\")\n                {\n                    stringBuilder.setCharAt(i, '0');\n                }\n            i++;\n        }\n            System.out.println(stringBuilder);\n        }\n        else\n            System.out.println(\"No\");\n\n\n    }\n}\nclass StringAlgorithms\n{\n    public int[] calculateZ(char input[]) {\n        int Z[] = new int[input.length];\n        int left = 0;\n        int right = 0;\n        for(int k = 1; k < input.length; k++) {\n            if(k > right) {\n                left = right = k;\n                while(right < input.length && input[right] == input[right - left]) {\n                    right++;\n                }\n                Z[k] = right - left;\n                right--;\n            } else {\n                \n                int k1 = k - left;\n                \n                if(Z[k1] < right - k + 1) {\n                    Z[k] = Z[k1];\n                } else { \n                    left = k;\n                    while(right < input.length && input[right] == input[right - left]) {\n                        right++;\n                    }\n                    Z[k] = right - left;\n                    right--;\n                }\n            }\n        }\n        return Z;\n    }\n    public ArrayList<Integer> matchPattern(char text[], char pattern[]) {\n        char newString[] = new char[text.length + pattern.length + 1];\n        int i = 0;\n        for(char ch : pattern) {\n            newString[i] = ch;\n            i++;\n        }\n        newString[i] = '$';\n        i++;\n        for(char ch : text) {\n            newString[i] = ch;\n            i++;\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        int Z[] = calculateZ(newString);\n\n        for(i = 0; i < Z.length ; i++) {\n            if(Z[i] == pattern.length) {\n                result.add(i - pattern.length - 1);\n            }\n        }\n        return result;\n    }\n}\nclass BasicFunctions\n{\n    public long min(long[] A)\n    {\n        long min = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            min = Math.min(min, A[i]);\n        }\n        return min;\n    }\n    public long max(long[] A)\n    {\n        long max = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            max = Math.max(max, A[i]);\n        }\n        return max;\n    }\n}\nclass Name implements Comparable<Name>\n{\n    int x;\n    int y;\n\n    public Name(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public int compareTo(Name ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        return 0;\n    }\n}\nclass Matrix\n{\n    long a;\n    long b;\n    long c;\n    long d;\n\n    public Matrix(long a, long b, long c, long d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n}\nclass Game implements Comparable<Game>\n{\n    long x;\n    long y;\n\n    public Game(long x, long y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public int compareTo(Game ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        else\n        {\n            if(this.y < ob.y)\n                return -1;\n            else if(this.y > ob.y)\n                return 1;\n            else\n                return 0;\n        }\n    }\n}\nclass MergeSortInt\n{\n    \n    \n    \nvoid merge(int arr[], int l, int m, int r) {\n        \n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        \n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        \n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        \nint i = 0, j = 0;\n\n        \n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        \n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        \n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n        \n        \nvoid sort(int arr[], int l, int r) {\n        if (l < r) {\n            \n            int m = (l + r) / 2;\n\n            \n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            \n            merge(arr, l, m, r);\n        }\n    }\n\n}\nclass MergeSortLong\n{\n    \n    \n    \nvoid merge(long arr[], int l, int m, int r) {\n        \n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        \n        long L[] = new long[n1];\n        long R[] = new long[n2];\n\n        \n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        \nint i = 0, j = 0;\n\n        \n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        \n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        \n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n        \n        \nvoid sort(long arr[], int l, int r) {\n        if (l < r) {\n            \n            int m = (l + r) / 2;\n\n            \n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            \n            merge(arr, l, m, r);\n        }\n    }\n}\nclass Node\n{\n    String a;\n    String b;\n    Node(String s1,String s2)\n    {\n        this.a = s1;\n        this.b = s2;\n    }\n    @Override\n    public boolean equals(Object ob)\n    {\n        if(ob == null)\n            return false;\n        if(!(ob instanceof Node))\n            return false;\n        if(ob == this)\n            return true;\n        Node obj = (Node)ob;\n        if(this.a.equals(obj.a) && this.b.equals(obj.b))\n            return true;\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int)this.a.length();\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64]; \n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\nclass FenwickTree\n{\n    public void update(long[] fenwickTree,long delta,int index)\n    {\n        index += 1;\n        while(index < fenwickTree.length)\n        {\n            fenwickTree[index] += delta;\n            index = index + (index & (-index));\n        }\n    }\n    public long prefixSum(long[] fenwickTree,int index)\n    {\n        long sum = 0L;\n        index += 1;\n        while(index > 0)\n        {\n            sum += fenwickTree[index];\n            index -= (index & (-index));\n        }\n        return sum;\n    }\n}\nclass SegmentTree\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n    public int[] createSegmentTree(int[] input)\n    {\n        int np2 = nextPowerOfTwo(input.length);\n        int[] segmentTree = new int[np2 * 2 - 1];\n\n        int i=0;\n        while(i<segmentTree.length)\n        {\n            segmentTree[i] = Integer.MIN_VALUE;\n        i++;\n    }\n        constructSegmentTree(segmentTree,input,0,input.length-1,0);\n        return segmentTree;\n\n    }\n        \n    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/ 2;\n        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);\n        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);\n        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);\n    }\n    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)\n    {\n        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);\n    }\n    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)\n    {\n        if(qlow <= low && qhigh >= high){\n            return segmentTree[pos];\n        }\n        if(qlow > high || qhigh < low){\n            return Integer.MIN_VALUE;\n        }\n        int mid = (low+high)/2;\n        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),\n                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));\n    }\n}", "src": "public class icpc\n{\n    public static void main(String[] args)throws IOException\n    {\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n        String s1[] = in.readLine().split(\" \");\n        int  n = Integer.parseInt(s1[0]);\n        int p = Integer.parseInt(s1[1]);\n        String s = in.readLine();\n        StringBuilder stringBuilder = new StringBuilder(s);\n        boolean flag = false;\n        for(int i=0;i<n;i++)\n        {\n            if(i + p < n)\n            {\n                if(s.charAt(i) != '.' && s.charAt(i + p) != '.' && s.charAt(i) != s.charAt(i + p))\n                {\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) != '.')\n                {\n                    int x = s.charAt(i + p) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) != '.' && s.charAt(i + p) == '.')\n                {\n                    int x = s.charAt(i) - '0';\n                    char ch = (char)((x + 1) % 2 + 48);\n                    stringBuilder.setCharAt(i + p, ch);\n                    flag = true;\n                    break;\n                }\n                else if(s.charAt(i) == '.' && s.charAt(i + p) == '.')\n                {\n                    stringBuilder.setCharAt(i, '1');\n                    stringBuilder.setCharAt(i + p, '0');\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        if(flag)\n        {\n            for(int i=0;i<stringBuilder.length();i++)\n            {\n                if(stringBuilder.charAt(i) == '.')\n                {\n                    stringBuilder.setCharAt(i, '0');\n                }\n            }\n            System.out.println(stringBuilder);\n        }\n        else\n            System.out.println(\"No\");\n\n\n    }\n}\nclass StringAlgorithms\n{\n    public int[] calculateZ(char input[]) {\n        int Z[] = new int[input.length];\n        int left = 0;\n        int right = 0;\n        for(int k = 1; k < input.length; k++) {\n            if(k > right) {\n                left = right = k;\n                while(right < input.length && input[right] == input[right - left]) {\n                    right++;\n                }\n                Z[k] = right - left;\n                right--;\n            } else {\n                \n                int k1 = k - left;\n                \n                if(Z[k1] < right - k + 1) {\n                    Z[k] = Z[k1];\n                } else { \n                    left = k;\n                    while(right < input.length && input[right] == input[right - left]) {\n                        right++;\n                    }\n                    Z[k] = right - left;\n                    right--;\n                }\n            }\n        }\n        return Z;\n    }\n    public ArrayList<Integer> matchPattern(char text[], char pattern[]) {\n        char newString[] = new char[text.length + pattern.length + 1];\n        int i = 0;\n        for(char ch : pattern) {\n            newString[i] = ch;\n            i++;\n        }\n        newString[i] = '$';\n        i++;\n        for(char ch : text) {\n            newString[i] = ch;\n            i++;\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        int Z[] = calculateZ(newString);\n\n        for(i = 0; i < Z.length ; i++) {\n            if(Z[i] == pattern.length) {\n                result.add(i - pattern.length - 1);\n            }\n        }\n        return result;\n    }\n}\nclass BasicFunctions\n{\n    public long min(long[] A)\n    {\n        long min = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            min = Math.min(min, A[i]);\n        }\n        return min;\n    }\n    public long max(long[] A)\n    {\n        long max = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            max = Math.max(max, A[i]);\n        }\n        return max;\n    }\n}\nclass Name implements Comparable<Name>\n{\n    int x;\n    int y;\n\n    public Name(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public int compareTo(Name ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        return 0;\n    }\n}\nclass Matrix\n{\n    long a;\n    long b;\n    long c;\n    long d;\n\n    public Matrix(long a, long b, long c, long d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n}\nclass Game implements Comparable<Game>\n{\n    long x;\n    long y;\n\n    public Game(long x, long y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public int compareTo(Game ob)\n    {\n        if(this.x < ob.x)\n            return -1;\n        else if(this.x > ob.x)\n            return 1;\n        else\n        {\n            if(this.y < ob.y)\n                return -1;\n            else if(this.y > ob.y)\n                return 1;\n            else\n                return 0;\n        }\n    }\n}\nclass MergeSortInt\n{\n    \n    \n    \n    void merge(int arr[], int l, int m, int r) {\n        \n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        \n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        \n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        \n\n        \n        int i = 0, j = 0;\n\n        \n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        \n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        \n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    \n    \n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n            \n            int m = (l + r) / 2;\n\n            \n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            \n            merge(arr, l, m, r);\n        }\n    }\n\n}\nclass MergeSortLong\n{\n    \n    \n    \n    void merge(long arr[], int l, int m, int r) {\n        \n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        \n        long L[] = new long[n1];\n        long R[] = new long[n2];\n\n        \n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        \n\n        \n        int i = 0, j = 0;\n\n        \n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        \n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        \n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    \n    \n    void sort(long arr[], int l, int r) {\n        if (l < r) {\n            \n            int m = (l + r) / 2;\n\n            \n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            \n            merge(arr, l, m, r);\n        }\n    }\n}\nclass Node\n{\n    String a;\n    String b;\n    Node(String s1,String s2)\n    {\n        this.a = s1;\n        this.b = s2;\n    }\n    @Override\n    public boolean equals(Object ob)\n    {\n        if(ob == null)\n            return false;\n        if(!(ob instanceof Node))\n            return false;\n        if(ob == this)\n            return true;\n        Node obj = (Node)ob;\n        if(this.a.equals(obj.a) && this.b.equals(obj.b))\n            return true;\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int)this.a.length();\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64]; \n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\nclass FenwickTree\n{\n    public void update(long[] fenwickTree,long delta,int index)\n    {\n        index += 1;\n        while(index < fenwickTree.length)\n        {\n            fenwickTree[index] += delta;\n            index = index + (index & (-index));\n        }\n    }\n    public long prefixSum(long[] fenwickTree,int index)\n    {\n        long sum = 0L;\n        index += 1;\n        while(index > 0)\n        {\n            sum += fenwickTree[index];\n            index -= (index & (-index));\n        }\n        return sum;\n    }\n}\nclass SegmentTree\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n    public int[] createSegmentTree(int[] input)\n    {\n        int np2 = nextPowerOfTwo(input.length);\n        int[] segmentTree = new int[np2 * 2 - 1];\n\n        for(int i=0;i<segmentTree.length;i++)\n            segmentTree[i] = Integer.MIN_VALUE;\n\n        constructSegmentTree(segmentTree,input,0,input.length-1,0);\n        return segmentTree;\n\n    }\n    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/ 2;\n        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);\n        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);\n        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);\n    }\n    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)\n    {\n        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);\n    }\n    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)\n    {\n        if(qlow <= low && qhigh >= high){\n            return segmentTree[pos];\n        }\n        if(qlow > high || qhigh < low){\n            return Integer.MIN_VALUE;\n        }\n        int mid = (low+high)/2;\n        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),\n                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));\n    }\n}", "index": 364, "complexity": "1"}
{"forwhile": "public class Fingerprints {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tint i = 0;\n\t\twhile(i < m) {\n\t\t\tset.add(nextInt());\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tString s = \"\";\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\tif (set.contains(a[i]))\n\t\t\t\ts += \" \" + a[i];\n\t\t\ti++;\n\t\t}\n\t\t\n\t\tSystem.out.println(s.length() == 0 ? s : s.substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\tfor(; st == null || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "src": "public class Fingerprints {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] a = intArray(n);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tset.add(nextInt());\n\t\t\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (set.contains(a[i]))\n\t\t\t\ts += \" \" + a[i];\n\t\t\n\t\tSystem.out.println(s.length() == 0 ? s : s.substring(1));\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 365, "complexity": "1"}
{"forwhile": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\twhile (i < a.length) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(solve(a));\n\n\t\tsc.close();\n\t}\n\n\tstatic String solve(int[] a) {\n\t\tif (a.length == 1 || (a.length == 2 && a[0] == a[1])) {\n\t\t\treturn \"-1\";\n\t\t}\n\n\t\tint sum = Arrays.stream(a).sum();\n\t\tfor (int i = 0; a[i] * 2 == sum; i++) {\n\t\t}\n\t\treturn String.format(\"1\\n%d\", i + 1);\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(a));\n\n\t\tsc.close();\n\t}\n\n\tstatic String solve(int[] a) {\n\t\tif (a.length == 1 || (a.length == 2 && a[0] == a[1])) {\n\t\t\treturn \"-1\";\n\t\t}\n\n\t\tint sum = Arrays.stream(a).sum();\n\t\tfor (int i = 0;; i++) {\n\t\t\tif (a[i] * 2 != sum) {\n\t\t\t\treturn String.format(\"1\\n%d\", i + 1);\n\t\t\t}\n\t\t}\n\t}\n}", "index": 366, "complexity": "1"}
{"forwhile": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), m = in.nextInt();\n        int[] a = new int[n];\n        int i = 0;\n        while(i < n) {\n            a[i] = in.nextInt();\n            i++;\n        }\n        int h=0,t=n-1,answ=0;\n        for(; h<n&&t>=0;) {\n            if(a[h]<=m) {\n                answ++;\n                h++;\n            }else if(a[t]<=m) {\n                t--;\n                answ++;\n            }else {\n                break;\n            }\n        }\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "src": "public class Main {\n\n    static StringBuilder data = new StringBuilder();\n    final static FastReader in = new FastReader();\n\n\n    public static void main(String[] args) {\n        int n = in.nextInt(), m = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        int h=0,t=n-1,answ=0;\n        while (h<n&&t>=0){\n            if(a[h]<=m){\n                answ++;\n                h++;\n            }else if(a[t]<=m){\n                t--;\n                answ++;\n            }else{\n                break;\n            }\n        }\n        System.out.println(answ);\n    }\n\n\n    static void fileOut(String s) {\n        File out = new File(\"output.txt\");\n        try {\n            FileWriter fw = new FileWriter(out);\n            fw.write(s);\n            fw.flush();\n            fw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        public FastReader(String path) {\n            try {\n                br = new BufferedReader(new\n                        InputStreamReader(new FileInputStream(path)));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "index": 367, "complexity": "1"}
{"forwhile": "public class Solution{\n\tpublic static void main(String sp[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString st = sc.next();\n\t\t\n\t\tchar arr[] = st.toCharArray();\n\t\t\n\t\tboolean b=false;\n\t\tchar j='a';\n\t\twhile(j<='z'){\n\t\t\tint i=0;\n\t\t\twhile(i<arr.length){\n\t\t\t\tif(arr[i]==j){\n\t\t\t\t\tarr[i]='*';\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tif(k==0){\n\t\t\t\t\tb=true;\n\t\t\t\t\tprin(arr);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t}\n\t\n\tpublic static void prin(char arr[]){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i=0;\n\t\twhile(i<arr.length){\n\t\t\tif(arr[i]!='*')\n\t\t\t\tsb.append(arr[i]);\n\t\t\ti++;\n\t\t}\n\t\tif(sb.length()!=0)\n\t\t\tSystem.out.println(sb.toString());\n\t}\n}", "src": "public class Solution{\n\tpublic static void main(String sp[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString st = sc.next();\n\t\t\n\t\tchar arr[] = st.toCharArray();\n\t\t\n\t\tboolean b=false;\n\t\tfor(char j='a';j<='z';j++){\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]==j){\n\t\t\t\tarr[i]='*';\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tif(k==0){\n\t\t\t\tb=true;\n\t\t\t\tprin(arr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}}\n\n\t}\n\t\n\tpublic static void prin(char arr[]){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(arr[i]!='*')\n\t\t\t\tsb.append(arr[i]);\n\t\t}\n\t\tif(sb.length()!=0)\n\t\t\tSystem.out.println(sb.toString());\n\t}\n}", "index": 368, "complexity": "1"}
{"forwhile": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            for(; token==null || !token.hasMoreTokens(); token=new StringTokenizer(br.readLine()))\n            {\n                try\n                {\n                    \n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        int i=0;\n        while(i<a.length)\n        {\n            l.add(a[i]);\n            i++;\n        }\n        Collections.shuffle(l);\n        i=0;\n        while(i<a.length)\n        {\n            a[i]=l.get(i);\n            i++;\n        }\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        int i=0;\n        while(i<n)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n            i++;\n        }\n        int ans=0;\n        i=0;\n        while(i<n)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n            i++;\n        }\n        System.out.println(n-ans);\n    }\n}", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "index": 369, "complexity": "1"}
{"forwhile": "public class pr902A {\n    static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        out.println(solve(n, m));\n        out.flush();\n        out.close();\n    }\n\n    private static String solve(int n, int m) {\n        int[] grid = new int[m+1];\n        int i = 0;\n        while (i < n) {\n            int start = in.nextInt();\n            int end = in.nextInt();\n\n            grid[start]++;\n            grid[end]--;\n\n            i++;\n        }\n        int sum = 0;\n        for(int i = 0; i < m; i++){\n            sum += grid[i];\n            if(sum == 0) return \"NO\";\n        }\n\n        return \"YES\";\n    }\n}", "src": "public class pr902A {\n    static Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        out.println(solve(n, m));\n        out.flush();\n        out.close();\n    }\n\n    private static String solve(int n, int m) {\n        int[] grid = new int[m+1];\n        for (int i = 0; i < n; i++) {\n            int start = in.nextInt();\n            int end = in.nextInt();\n\n            grid[start]++;\n            grid[end]--;\n\n        }\n        int sum = 0;\n        for(int i = 0; i < m; i++){\n            sum += grid[i];\n            if(sum == 0) return \"NO\";\n        }\n\n        return \"YES\";\n    }\n}", "index": 370, "complexity": "1"}
{"forwhile": "public class ErrorCorrectSystem\n{\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tString a = scan.next();\n\t\tString b = scan.next();\n\t\t\n\t\tint[][] mismatch = new int[26][26];\n\t\tint i = 0;\n\t\twhile(i < 26) { \n\t\t\tArrays.fill(mismatch[i], -1);\n\t\t\ti++;\n\t\t} \n\t\tint[][] pair = new int[2][26];\n\t\ti = 0;\n\t\twhile(i < 2) {\n\t\t\tArrays.fill(pair[i], -1);\n\t\t\ti++;\n\t\t}\n\t\tint hd = 0;\n\t\ti = 0;\n\t\twhile(i < n) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\thd++;\n\t\t\t\tmismatch[a.charAt(i)-'a'][b.charAt(i)-'a'] = i;\n\t\t\t\tpair[0][a.charAt(i)-'a'] = i;\n\t\t\t\tpair[1][b.charAt(i)-'a'] = i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\ti = 0;\n\t\twhile(i < 26) {\n\t\t\tint j = i + 1;\n\t\t\twhile(j < 26) {\n\t\t\t\tif(mismatch[i][j] > -1 && mismatch[j][i] > -1) {\n\t\t\t\t\tSystem.out.println(hd-2);\n\t\t\t\t\tSystem.out.println((mismatch[i][j]+1)+", "src": "public class ErrorCorrectSystem\n{\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tString a = scan.next();\n\t\tString b = scan.next();\n\t\t\n\t\tint[][] mismatch = new int[26][26];\n\t\tfor(int i = 0; i < 26; i++) Arrays.fill(mismatch[i], -1);\n\t\tint[][] pair = new int[2][26];\n\t\tfor(int i = 0; i < 2; i++) Arrays.fill(pair[i], -1);\n\t\tint hd = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\thd++;\n\t\t\t\tmismatch[a.charAt(i)-'a'][b.charAt(i)-'a'] = i;\n\t\t\t\tpair[0][a.charAt(i)-'a'] = i;\n\t\t\t\tpair[1][b.charAt(i)-'a'] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tfor(int j = i+1; j < 26; j++) {\n\t\t\t\tif(mismatch[i][j] > -1 && mismatch[j][i] > -1) {\n\t\t\t\t\tSystem.out.println(hd-2);\n\t\t\t\t\tSystem.out.println((mismatch[i][j]+1)+\" \"+(mismatch[j][i]+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(a.charAt(i) != b.charAt(i)) {\n\t\t\t\t\n\t\t\t\tif(pair[0][b.charAt(i)-'a'] > -1) {\n\t\t\t\t\tSystem.out.println(hd-1);\n\t\t\t\t\tSystem.out.println((i+1)+\" \"+(pair[0][b.charAt(i)-'a']+1));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(hd);\n\t\tSystem.out.println(\"-1 -1\");\n\t}\n\n}", "index": 371, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Solution1 implements Runnable\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstatic final long MAX = 1000000007L;\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class InputReader\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate InputStream stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate byte[] buf = new byte[1024];\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int curChar;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate int numChars;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate SpaceCharFilter filter;\n\t\t\t\t\t\t\t\t\t\t\t\t\tprivate BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic InputReader(InputStream stream)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.stream = stream;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int read()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (numChars==-1) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (curChar >= numChars)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String nextLine()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString str = \"\";\n\t\t\t\t\t\t\t\t\t\t\t            try\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                str = br.readLine();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            catch (IOException e)\n\t\t\t\t\t\t\t\t\t\t\t            {\n\t\t\t\t\t\t\t\t\t\t\t                e.printStackTrace();\n\t\t\t\t\t\t\t\t\t\t\t            }\n\t\t\t\t\t\t\t\t\t\t\t            return str;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int nextInt()\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic long nextLong() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlong res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic double nextDouble() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '-') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble res = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == '.') \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdouble m = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm /= 10;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String readString() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint c = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdo \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = read();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (!isSpaceChar(c));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn res.toString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int c) \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic String next() \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn readString();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic interface SpaceCharFilter \n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t \t\n\t\t\t\t\t\t\t\t\t\t\t\tpublic static void main(String args[]) throws Exception\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Thread(null, new Solution1(),\"Solution1\",1<<26).start();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tlong gcd(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t        if (a == 0)\n\t\t\t\t\t\t\t\t\t\t\t            return b;\n\t\t\t\t\t\t\t\t\t\t\t         \n\t\t\t\t\t\t\t\t\t\t\t        return gcd(b%a, a);\n\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t    \n\t\t\t\t\t\t\t\t\t\t\t\t long lcm(long a, long b)\n\t\t\t\t\t\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t\t\t\t\t\t        return (a*b)/gcd(a, b);\n\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t int root(int a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t while(arr[a] != a){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[a] = arr[arr[a]];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t a = arr[a];\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t\t return a;\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t void union(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int xroot = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int yroot = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(arr[xroot] < arr[yroot]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[xroot] = yroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t arr[yroot] = xroot;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t boolean find(int a,int b){\n\t\t\t\t\t\t\t\t\t\t\t\t\t int roota = root(a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t int rootb = root(b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t if(roota == rootb){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t return false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t\t\t\t int[] arr;\n\t\t\t\t\t\t\t\t\t\t\t\t final int level = 20;\n\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t\tpublic void run()\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tInputReader sc= new InputReader(System.in);\n\t\t\t\t\t\t\t\t\t\t\t\t\tPrintWriter w= new PrintWriter(System.out);\n\t\t\t\t\t\t\t\t\t\t\t\t\tint n = sc.nextInt();\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tchar[] ch2 = new char[n];\n\t\t\t\t\t\t\t\t\t\t\t\t\tch = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tch2 = sc.next().toCharArray();\n\t\t\t\t\t\t\t\t\t\t\t\t\tHashSet<Integer> hset[] = new HashSet[26];\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < 26;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[i]  =new HashSet();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thset[ch[i]-97].add(ch2[i]-97);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tboolean flag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap1 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint swap2 = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint rem = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < ch.length;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].size() != 0){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswap1 = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(hset[ch2[i]-97].contains(ch[i]-97)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trem = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount-=2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(flag){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != swap1 && ch[i] == ch2[swap1] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((swap1+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(rem == -1){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(\"-1 -1\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println(count);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(i != rem && ch[i] == ch2[rem] && ch[rem] == ch2[i] && ch[i] != ch2[i]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.println((rem+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSystem.exit(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tw.close();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tboolean fun(long[] prefix,long mid,long temp,long[] arr){\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(temp >= prefix[(int)mid]){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tstatic class Pair implements Comparable<Pair>{\n\t\t\t\t\t\t\t\t\t\t\t\t\tint x;\n\t\t\t\t\t\t\t\t\t\t\t\t\tint y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(){}\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tPair(int x,int y){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tpublic int compareTo(Pair p){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn Long.compare(this.x,p.x);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}", "index": 372, "complexity": "1"}
{"forwhile": "public class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == \\'-\\') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < \\'0\\' || c > \\'9\\') throw new InputMismatchException();res *= 10 ; res += c - \\'0\\' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == \\'-\\') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < \\'0\\' || c > \\'9\\') throw new InputMismatchException();res *= 10 ; res += c - \\'0\\' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == \\' \\' || c == \\'\\\\n\\' || c == \\'\\\\r\\' || c == \\'\\\\t\\' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == \\'\\\\n\\' || c == \\'\\\\r\\' || c == -1; } \n    } \n    \n    \n    \n    \n    public static void main(String args[])\n    {\n        Reader sc=new Reader();\n        PrintWriter out=new PrintWriter(System.out);\n        int n=sc.i();\n        String s1=sc.s();\n        String s2=sc.s();\n        int pos1=-1;\n        int pos2=-1;\n        int arr[][][]=new int[100][100][2];\n        int i=0;\n        while(i < n)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            {\n                int j=0;\n                while(j < 100)\n                {\n                    if(arr[s2.charAt(i)-97][s1.charAt(i)-97][0]==1)\n                    {\n                        pos2=i;\n                        pos1=arr[s2.charAt(i)-97][s1.charAt(i)-97][1];\n                        break;\n                    }\n                    arr[s1.charAt(i)-97][s2.charAt(i)-97][0]=1;\n                    arr[s1.charAt(i)-97][s2.charAt(i)-97][1]=i;\n                    j++;\n                }\n            }\n            i++;\n        }\n        int ham=0;\n        i=0;\n        while(i < n)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            ham++;\n            i++;\n        }\n        if(pos1!=-1&&pos2!=-1)\n        {\n            System.out.println(ham-2);\n            System.out.println(pos1+1+\\", "src": "public class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n    } \n    \n    \n    \n    \n    public static void main(String args[])\n    {\n        Reader sc=new Reader();\n        PrintWriter out=new PrintWriter(System.out);\n        int n=sc.i();\n        String s1=sc.s();\n        String s2=sc.s();\n        int pos1=-1;\n        int pos2=-1;\n        int arr[][][]=new int[100][100][2];\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            {\n                if(arr[s2.charAt(i)-97][s1.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr[s2.charAt(i)-97][s1.charAt(i)-97][1];\n                    break;\n                }\n                arr[s1.charAt(i)-97][s2.charAt(i)-97][0]=1;\n                arr[s1.charAt(i)-97][s2.charAt(i)-97][1]=i;\n            }\n        }\n        int ham=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            ham++;\n        }\n        if(pos1!=-1&&pos2!=-1)\n        {\n            System.out.println(ham-2);\n            System.out.println(pos1+1+\" \"+(pos2+1));\n            System.exit(0);\n        }\n        \n        int arr1[][]=new int[100][2];\n        int arr2[][]=new int[100][2];\n        for(int i=0;i<n;i++)\n        {\n            if(s1.charAt(i)!=s2.charAt(i))\n            {\n                if(arr1[s1.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr1[s1.charAt(i)-97][1];\n                    break;\n                }\n                if(arr2[s2.charAt(i)-97][0]==1)\n                {\n                    pos2=i;\n                    pos1=arr2[s2.charAt(i)-97][1];\n                    break;\n                }\n                arr1[s2.charAt(i)-97][0]=1;\n                arr1[s2.charAt(i)-97][1]=i;\n                arr2[s1.charAt(i)-97][0]=1;\n                arr2[s1.charAt(i)-97][1]=i;\n            }\n        }\n        if(pos1!=-1&&pos2!=-1)\n        {\n            System.out.println(ham-1);\n            System.out.println(pos1+1+\" \"+(pos2+1));\n            System.exit(0);\n        }\n        System.out.println(ham);\n        System.out.println(pos1+\" \"+pos2);\n    }\n}", "index": 373, "complexity": "1"}
{"forwhile": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tint[] f = new int[n];\n\t\tint[] t = new int[n];\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tf[i] = sc.nextInt();\n\t\t\tt[i] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(solve(f, t, s));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] f, int[] t, int s) {\n\t\tint[] maxTimes = new int[s + 1];\n\t\tint i = 0;\n\t\twhile (i < f.length) {\n\t\t\tmaxTimes[f[i]] = Math.max(maxTimes[f[i]], t[i]);\n\t\t\ti++;\n\t\t}\n\n\t\tint time = 0;\n\t\tfor (int i = s; i > 0; i--) {\n\t\t\ttime = Math.max(time, maxTimes[i]);\n\n\t\t\ttime++;\n\t\t}\n\t\treturn time;\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tint[] f = new int[n];\n\t\tint[] t = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = sc.nextInt();\n\t\t\tt[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(f, t, s));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] f, int[] t, int s) {\n\t\tint[] maxTimes = new int[s + 1];\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tmaxTimes[f[i]] = Math.max(maxTimes[f[i]], t[i]);\n\t\t}\n\n\t\tint time = 0;\n\t\tfor (int i = s; i > 0; i--) {\n\t\t\ttime = Math.max(time, maxTimes[i]);\n\n\t\t\ttime++;\n\t\t}\n\t\treturn time;\n\t}\n}", "index": 374, "complexity": "1"}
{"forwhile": "public class Code {\n\n   static int [] reverse(int a[]) \n    { \n        int[] b = new int[a.length]; \n       int j = 0  ;\n        int i = a.length-1;\n        while(i >= 0) {\n            b[i] = a[j] ; \n            j++;\n            i--;\n        }\n        return b ;\n    }\n    public static void main(String[] args) {\n        int pas ; \n        int top ; \n        Scanner in = new Scanner(System.in) ; \n        pas= in.nextInt(); \n        top=in.nextInt() ; \n        int a [] = new int[pas] ; \n        int b [] = new int[pas] ; \n        \n        int i = 0;\n        while (i < pas) {\n            a[i] = in.nextInt() ; \n            b[i] = in.nextInt() ; \n            i++;\n         }\n       a =  reverse(a) ;\n        b = reverse(b) ;\n        int ftime =0 ; \n        int t;\n        int po = top ; \n        i = 0;\n        while (i < pas) {\n             ftime+=(po-a[i]) ; \n            t = Math.max(b[i]-ftime, 0) ; \n            ftime+=t ; \n            po = a[i] ; \n            i++;\n           \n        }\n        if(po!=0) ftime+=po ;\n        System.out.println(ftime);\n        \n    }\n    \n}", "src": "public class Code {\n\n   static int [] reverse(int a[]) \n    { \n        int[] b = new int[a.length]; \n       int j = 0  ;\n        for (int i = a.length-1; i >= 0; i--) {\n            b[i] = a[j] ; \n            j++;\n        }\n        return b ;\n    }\n    public static void main(String[] args) {\n        int pas ; \n        int top ; \n        Scanner in = new Scanner(System.in) ; \n        pas= in.nextInt(); \n        top=in.nextInt() ; \n        int a [] = new int[pas] ; \n        int b [] = new int[pas] ; \n        \n        for (int i = 0; i < pas; i++) {\n            a[i] = in.nextInt() ; \n            b[i] = in.nextInt() ; \n           \n         }\n       a =  reverse(a) ;\n        b = reverse(b) ;\n        int ftime =0 ; \n        int t;\n        int po = top ; \n        for (int i = 0; i < pas; i++) {\n             ftime+=(po-a[i]) ; \n            t = Math.max(b[i]-ftime, 0) ; \n            ftime+=t ; \n            po = a[i] ; \n           \n        }\n        if(po!=0) ftime+=po ;\n        System.out.println(ftime);\n        \n    }\n    \n}", "index": 375, "complexity": "1"}
{"forwhile": "class FindUnion  {  static int printUnion( int arr1[], int arr2[], int m, int n)  {  for(int i = 0, j = 0; i < m && j < n;)  {  if(arr1[i] < arr2[j])  System.out.print(arr1[i++] + \" \");  else if(arr2[j] < arr1[i])  System.out.print(arr2[j++] + \" \");  else  {  System.out.print(arr2[j++] + \" \");  i++;  }  } while(i < m)  System.out.print(arr1[i++] + \" \");  while(j < n)  System.out.print(arr2[j++] + \" \");  return 0;  }  public static void main(String args[])  {  int arr1[] = { 1, 2, 4, 5, 6 };  int arr2[] = { 2, 3, 5, 7 };  int m = arr1.length;  int n = arr2.length;  printUnion(arr1, arr2, m, n);  }  }", "src": "class\nFindUnion \n{ \n\n\n\nstatic\nint\nprintUnion(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nwhile\n(i < m && j < n) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n\n\n\nwhile\n(i < m) \n\nSystem.out.print(arr1[i++]+\n\" \"\n); \n\nwhile\n(j < n) \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintUnion(arr1, arr2, m, n); \n\n} \n}", "index": 376, "complexity": "1"}
{"forwhile": "public class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n\n        String a = scanner.nextLine(), b = scanner.nextLine();\n\n        int n = b.length(), m = a.length();\n\n        int p[] = new int[n];\n\n        p[0] = b.charAt(0) - '0';\n\n        int i = 1;\n        while (i < n) {\n            p[i] = p[i - 1] + (b.charAt(i) - '0');\n            i++;\n        }\n\n        long ans = 0;\n        for (int i = 0; i < m; i++) {\n            int cur = a.charAt(i) - '0';\n\n            int cnt = p[n - m + i] - (i > 0 ? p[i - 1] : 0);\n\n            if (cur == 0) {\n                ans += cnt;\n            } else {\n                ans += n - m + 1 - cnt;\n            }\n        }\n\n        System.out.println(ans);\n\n    }\n\n\n    class Pair {\n        int c, f;\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            int i = 0;\n            for (; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "src": "public class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n\n        String a = scanner.nextLine(), b = scanner.nextLine();\n\n        int n = b.length(), m = a.length();\n\n        int p[] = new int[n];\n\n        p[0] = b.charAt(0) - '0';\n\n        for (int i = 1; i < n; i++) {\n            p[i] = p[i - 1] + (b.charAt(i) - '0');\n        }\n\n        long ans = 0;\n        for (int i = 0; i < m; i++) {\n            int cur = a.charAt(i) - '0';\n\n            int cnt = p[n - m + i] - (i > 0 ? p[i - 1] : 0);\n\n            if (cur == 0) {\n                ans += cnt;\n            } else {\n                ans += n - m + 1  - cnt;\n            }\n        }\n\n        System.out.println(ans);\n\n    }\n\n\n    class Pair {\n        int c, f;\n    }\n\n    class FastScanner {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        Integer[] nextA(int n) {\n            Integer a[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            return a;\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}", "index": 377, "complexity": "1"}
{"forwhile": "public class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint beacon[] = new int[1000001];\n\t\tint i = 0;\n\t\twhile(i < num) {\n\t\t\tbeacon[sc.nextInt()] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tint dp[] = new int[1000001];\n\t\tint max = 1;\n\t\tif (beacon[0] > 0) {\n\t\t\tdp[0] = 1;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} \n\t\t\telse {\n\t\t\t\tint b = beacon[i];\n\t\t\t\tif (i <= b) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = dp[i-b-1] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\t\t\n\t\tSystem.out.println(num-max);\n\t\tsc.close();\n\t}\n\n}", "src": "public class codef8 {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\t\tint beacon[] = new int[1000001];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tbeacon[sc.nextInt()] = sc.nextInt();\n\t\t}\n\t\tint dp[] = new int[1000001];\n\t\tint max = 1;\n\t\tif (beacon[0] > 0) {\n\t\t\tdp[0] = 1;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tif (beacon[i] == 0) {\n\t\t\t\tdp[i] = dp[i-1];\n\t\t\t} \n\t\t\telse {\n\t\t\t\tint b = beacon[i];\n\t\t\t\tif (i <= b) {\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = dp[i-b-1] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\t\t\n\t\tSystem.out.println(num-max);\n\t\tsc.close();\n\t}\n\n}", "index": 378, "complexity": "1"}
{"forwhile": "class\nFindUnion \n{\n\n\nstatic\nvoid\nUnionArray(\nint\narr1[], \n\nint\narr2[]) \n\n{\n\n\n\nint\nm = arr1[arr1.length - 1]; \n\nint\nn = arr2[arr2.length - 1]; \n\n\nint\nans = 0;\n\n\nif\n(m > n) \n\n{\n\nans = m; \n\n} \n\nelse\n\nans = n; \n\n\n\n\nint\nnewtable[] = new\nint\n[ans + 1]; \n\n\n\n\n\n\nSystem.out.print(arr1[0] + \" \"); \n\n\n\n\n\n\n++newtable[arr1[0]];\n\n\nint\ni = 1;\nwhile(i < arr1.length) \n\n{\n\n\n\n\n\nif\n(arr1[i] != arr1[i - 1]) \n\n{\n\nSystem.out.print(arr1[i] + \" \"); \n\n++newtable[arr1[i]];\n\n} \n\ni++;\n\n} \n\n\nint\nj = 0;\nfor(; j < arr2.length; j++) \n\n{\n\n\n\n\n\nif\n(newtable[arr2[j]] == 0) \n\n{\n\nSystem.out.print(arr2[j] + \" \"); \n\n++newtable[arr2[j]];\n\n} \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{\n\nint\narr1[] = {1, 2, 2, 2, 3}; \n\nint\narr2[] = {2, 3, 4, 5}; \n\n\nUnionArray(arr1, arr2); \n\n} \n}", "src": "class\nFindUnion \n{ \n\n\nstatic\nvoid\nUnionArray(\nint\narr1[], \n\nint\narr2[]) \n\n{ \n\n\n\nint\nm = arr1[arr1.length - \n1\n]; \n\nint\nn = arr2[arr2.length - \n1\n]; \n\n\nint\nans = \n0\n; \n\n\nif\n(m > n) \n\n{ \n\nans = m; \n\n} \n\nelse\n\nans = n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nnewtable[] = \nnew\nint\n[ans + \n1\n]; \n\n\n\n\n\n\nSystem.out.print(arr1[\n0\n] + \n\" \"\n); \n\n\n\n\n\n\n++newtable[arr1[\n0\n]]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < arr1.length; i++) \n\n{ \n\n\n\n\n\nif\n(arr1[i] != arr1[i - \n1\n]) \n\n{ \n\nSystem.out.print(arr1[i] + \n\" \"\n); \n\n++newtable[arr1[i]]; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < arr2.length; j++) \n\n{ \n\n\n\n\n\nif\n(newtable[arr2[j]] == \n0\n) \n\n{ \n\nSystem.out.print(arr2[j] + \n\" \"\n); \n\n++newtable[arr2[j]]; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n2\n, \n2\n, \n3\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n4\n, \n5\n}; \n\n\nUnionArray(arr1, arr2); \n\n} \n}", "index": 379, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class round569d2a {\n\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint sum = 1;\n\t\tint tracker = 4;\n\t\twhile (n > 1) {\n\t\t\tsum += tracker;\n\t\t\ttracker += 4;\n\t\t\tn--;\n\t\t}\n\t\tSystem.out.println(sum);\n\n\t}\n\n\t\n\t\n\t\n\n\tstatic int greatestDivisor(int n) {\n\t\tint limit = (int) Math.sqrt(n);\n\t\tint max = 1;\n\t\tfor (int i = 2; i <= limit; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tmax = Integer.max(max, i);\n\t\t\t\tmax = Integer.max(max, n / i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t\n\t\n\tstatic boolean[] sieveOfEratosthenes(int n) {\n\t\t\n\t\t\n\t\t\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\n\t\tfor (int p = 2; p * p <= n; p++) {\n\t\t\t\n\t\t\tif (prime[p] == true) {\n\t\t\t\t\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn prime;\n\t}\n\n\t\n\t\n\tprivate static int bin_gteq(int[] a, int key) {\n\t\tint low = 0;\n\t\tint high = a.length;\n\t\tint max_limit = high;\n\t\twhile (low < high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (a[mid] < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else\n\t\t\t\thigh = mid;\n\t\t}\n\n\t\treturn high == max_limit ? -1 : high;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class Tuple<X, Y> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\n\t\tpublic Tuple(X x, Y y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n\n\tstatic class Tuple3<X, Y, Z> {\n\t\tpublic final X x;\n\t\tpublic final Y y;\n\t\tpublic final Z z;\n\n\t\tpublic Tuple3(X x, Y y, Z z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t\t}\n\t}\n\n\tstatic Tuple3<Integer, Integer, Integer> gcdExtended(int a, int b, int x, int y) {\n\t\t\n\t\tif (a == 0) {\n\t\t\tx = 0;\n\t\t\ty = 1;\n\t\t\treturn new Tuple3(0, 1, b);\n\t\t}\n\n\t\tint x1 = 1, y1 = 1; \n\t\tTuple3<Integer, Integer, Integer> tuple = gcdExtended(b % a, a, x1, y1);\n\t\tint gcd = tuple.z;\n\t\tx1 = tuple.x;\n\t\ty1 = tuple.y;\n\n\t\t\n\t\t\n\t\tx = y1 - (b / a) * x1;\n\t\ty = x1;\n\n\t\treturn new Tuple3(x, y, gcd);\n\t}\n\n\t\n\t\n\t\n\t\n\tstatic int inv(int a, int m) {\n\t\tint m0 = m, t, q;\n\t\tint x0 = 0, x1 = 1;\n\n\t\tif (m == 1)\n\t\t\treturn 0;\n\n\t\t\n\t\twhile (a > 1) {\n\t\t\t\n\t\t\tq = a / m;\n\n\t\t\tt = m;\n\n\t\t\t\n\t\t\t\n\t\t\tm = a % m;\n\t\t\ta = t;\n\n\t\t\tt = x0;\n\n\t\t\tx0 = x1 - q * x0;\n\n\t\t\tx1 = t;\n\t\t}\n\n\t\t\n\t\tif (x1 < 0)\n\t\t\tx1 += m0;\n\n\t\treturn x1;\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic int findMinX(int num[], int rem[], int k) {\n\t\t\n\t\tint prod = 1;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tprod *= num[i];\n\n\t\t\n\t\tint result = 0;\n\n\t\t\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint pp = prod / num[i];\n\t\t\tresult += rem[i] * inv(pp, num[i]) * pp;\n\t\t}\n\n\t\treturn result % prod;\n\t}\n\n\t\n\tstatic class FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int chars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read() {\n\t\t\tif (chars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= chars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tchars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (chars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}", "index": 380, "complexity": "1"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic long oo = 1000000000000L;\n\tstatic int[][] memo;\n\t\n\tpublic static void main(String[] args) throws IOException {\n \n\t\tint[] cnt = new int[101];\n\t\tcnt[1] = 1;\n\t\tfor(int i = 2; i <= 100; ++i) {\n\t\t\tcnt[i] = cnt[i-1] + 4 * (i - 1);\n\t\t}\n\t\tint n = in.nextInt();\n\t\tSystem.out.println( cnt[n] );\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic int maxHit(ArrayList<Integer> a, int p, int i) {\n\t\tif(i == a.size())\n\t\t\treturn 0;\n\t\tif(memo[p][i] != -1)\n\t\t\treturn memo[p][i];\n\t\tint ret = maxHit(a, p, i + 1);\n\t\tif(p == -1 || a.get(p) < a.get(i)) {\n\t\t\tret = Math.max(ret, maxHit(a, i, i + 1) );\n\t\t}\n\t\treturn memo[p][i] = ret;\n\t}\n\t\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}", "index": 381, "complexity": "1"}
{"forwhile": "public class Test{\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint num=1;\n\t\tint add;\n\t\tint i=1;\n\t\twhile(i<n){\n\t\t\tadd=4*i;\n\t\t\tnum+=add;\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(num);\n\t}\n}", "src": "public class Test{\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint num=1;\n\t\tint add;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tadd=4*i;\n\t\t\tnum+=add;\n\t\t}\n\t\tSystem.out.println(num);\n\t}\n}", "index": 382, "complexity": "1"}
{"forwhile": "class GFG  { static int findRepeating( int arr[],  int n) { int res =  0 ; int i = 0; while(i < n -  1 ) res = res ^ (i +  1 ) ^ arr[i]; res = res ^ arr[n -  1 ]; return res; } public static void main(String[] args) { int arr[] = { 9 , 8 , 2 , 6 , 1 , 8 , 5 , 3 , 4 , 7 }; int n = arr.length; System.out.println(findRepeating(arr, n)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nfindRepeating(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nres = res ^ (i + \n1\n) ^ arr[i]; \n\nres = res ^ arr[n - \n1\n]; \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n9\n, \n8\n, \n2\n, \n6\n, \n1\n, \n8\n, \n5\n, \n3\n, \n4\n, \n7\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findRepeating(arr, n)); \n\n} \n}", "index": 383, "complexity": "1"}
{"forwhile": "class MajorityElement {\nprivate static void findMajority(int[] arr) {\nHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\nint i = 0;\nwhile (i < arr.length) {\nif (map.containsKey(arr[i])) {\nint count = map.get(arr[i]) + 1;\nif (count > arr.length / 2) {\nSystem.out.println(\"Majority found :- \" + arr[i]);\nreturn;\n}\nelse\nmap.put(arr[i], count);\n}\nelse\nmap.put(arr[i], 1);\ni++;\n}\nSystem.out.println(\" No Majority element\");\n}\npublic static void main(String[] args) {\nint a[] = new int[]{2, 2, 2, 2, 5, 5, 2, 3, 3};\nfindMajority(a);\n}\n}", "src": "class\nMajorityElement \n{ \n\nprivate\nstatic\nvoid\nfindMajority(\nint\n[] arr) \n\n{ \n\nHashMap<Integer,Integer> map = \nnew\nHashMap<Integer, Integer>(); \n\n\nfor\n(\nint\ni = \n0\n; i < arr.length; i++) { \n\nif\n(map.containsKey(arr[i])) { \n\nint\ncount = map.get(arr[i]) +\n1\n; \n\nif\n(count > arr.length /\n2\n) { \n\nSystem.out.println(\n\"Majority found :- \"\n+ arr[i]); \n\nreturn\n; \n\n} \nelse\n\nmap.put(arr[i], count); \n\n\n} \n\nelse\n\nmap.put(arr[i],\n1\n); \n\n} \n\nSystem.out.println(\n\" No Majority element\"\n); \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = \nnew\nint\n[]{\n2\n,\n2\n,\n2\n,\n2\n,\n5\n,\n5\n,\n2\n,\n3\n,\n3\n}; \n\n\nfindMajority(a); \n\n} \n}", "index": 384, "complexity": "1"}
{"forwhile": "class GFG { static int maxTripletSum(int arr[], int n) { int maxA = -100000000, maxB = -100000000; int maxC = -100000000; int i = 0; while(i < n) { if(arr[i] > maxA) { maxC = maxB; maxB = maxA; maxA = arr[i]; } else if(arr[i] > maxB) { maxC = maxB; maxB = arr[i]; } else if(arr[i] > maxC) maxC = arr[i]; i++; } return (maxA + maxB + maxC); } public static void main(String args[]) { int arr[] = { 1, 0, 8, 6, 4, 2 }; int n = arr.length; System.out.println(maxTripletSum(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxTripletSum(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\n\nint\nmaxA = -\n100000000\n, maxB = -\n100000000\n; \n\nint\nmaxC = -\n100000000\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n(arr[i] > maxA) \n\n{ \n\nmaxC = maxB; \n\nmaxB = maxA; \n\nmaxA = arr[i]; \n\n} \n\n\n\n\n\n\nelse\nif\n(arr[i] > maxB) \n\n{ \n\nmaxC = maxB; \n\nmaxB = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > maxC) \n\nmaxC = arr[i]; \n\n} \n\n\nreturn\n(maxA + maxB + maxC); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n0\n, \n8\n, \n6\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxTripletSum(arr, n)); \n\n} \n}", "index": 385, "complexity": "1"}
{"forwhile": "class\nLinkedList { \n\nNode head; \n\n\nNode left; \n\n\n\n\nclass\nNode { \n\nchar\ndata; \n\nNode next; \n\n\nNode(\nchar\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n\n\nboolean\nisPalindromeUtil(Node right) \n\n{ \n\nleft = head; \n\n\nint i; \nfor(i = 0; right != \nnull\n; i++) { \n\nright = right.next; \n\n} \n\nif\n(right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nboolean\nisp = false; \nfor(; i > 0; i--) { \n\nisp = isPalindromeUtil(right.next); \n\nif\n(isp == \nfalse\n) \n\nreturn\nfalse\n; \n\ndata = right.data; \n\nboolean\nisp1 = (data == (left).data); \n\n\n\n\nleft = left.next; \n\n\nreturn\nisp1; \n\n} \n\n} \n\n\n\n\nboolean\nisPalindrome(Node head) \n\n{ \n\nboolean\nresult = isPalindromeUtil(head); \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nvoid\npush(\nchar\nnew_data) \n\n{ \n\n\n\nNode new_node = \nnew\nNode(new_data); \n\n\n\n\nnew_node.next = head; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\nvoid\nprintList(Node ptr) \n\n{ \n\nfor(; ptr != \nnull\n; ptr = ptr.next) { \n\nSystem.out.print(ptr.data + \n\"->\"\n); \n\n} \n\nSystem.out.println(\n\"NULL\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nLinkedList llist = \nnew\nLinkedList(); \n\n\nchar\nstr[] = { \n'a'\n, \n'b'\n, \n'a'\n, \n'c'\n, \n'a'\n, \n'b'\n, \n'a'\n}; \n\nString string = \nnew\nString(str); \n\nNode ptr = llist.head; \n\nint i = 0; \nwhile(i < 7) { \n\nllist.push(str[i]); \n\nllist.printList(llist.head); \n\nif\n(llist.isPalindrome(llist.head) != \nfalse\n) { \n\nSystem.out.println(\n\"Is Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"Not Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\ni++; \n\n} \n\n} \n}", "src": "class\nLinkedList { \n\nNode head; \n\n\nNode left; \n\n\n\n\nclass\nNode { \n\nchar\ndata; \n\nNode next; \n\n\nNode(\nchar\nd) \n\n{ \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n\n\nboolean\nisPalindromeUtil(Node right) \n\n{ \n\nleft = head; \n\n\n\n\nif\n(right == \nnull\n) \n\nreturn\ntrue\n; \n\n\n\n\nboolean\nisp = isPalindromeUtil(right.next); \n\nif\n(isp == \nfalse\n) \n\nreturn\nfalse\n; \n\n\n\n\nboolean\nisp1 = (right.data == (left).data); \n\n\n\n\nleft = left.next; \n\n\nreturn\nisp1; \n\n} \n\n\n\n\nboolean\nisPalindrome(Node head) \n\n{ \n\nboolean\nresult = isPalindromeUtil(head); \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nvoid\npush(\nchar\nnew_data) \n\n{ \n\n\n\nNode new_node = \nnew\nNode(new_data); \n\n\n\n\nnew_node.next = head; \n\n\n\n\nhead = new_node; \n\n} \n\n\n\n\nvoid\nprintList(Node ptr) \n\n{ \n\nwhile\n(ptr != \nnull\n) { \n\nSystem.out.print(ptr.data + \n\"->\"\n); \n\nptr = ptr.next; \n\n} \n\nSystem.out.println(\n\"NULL\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nLinkedList llist = \nnew\nLinkedList(); \n\n\nchar\nstr[] = { \n'a'\n, \n'b'\n, \n'a'\n, \n'c'\n, \n'a'\n, \n'b'\n, \n'a'\n}; \n\nString string = \nnew\nString(str); \n\nfor\n(\nint\ni = \n0\n; i < \n7\n; i++) { \n\nllist.push(str[i]); \n\nllist.printList(llist.head); \n\nif\n(llist.isPalindrome(llist.head) != \nfalse\n) { \n\nSystem.out.println(\n\"Is Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"Not Palindrome\"\n); \n\nSystem.out.println(\n\"\"\n); \n\n} \n\n} \n\n} \n}", "index": 386, "complexity": "1"}
{"forwhile": "class GFG  {\n\n\nstatic int maxSum( int arr[],  int n)  {\n\nint sum = 0 ; \n\nint i; \n\nint pivot = findPivot(arr, n); \n\n\n\n\n\n\nint diff = n - 1 - pivot; \n\ni = 0 ; \n\nwhile(i < n) \n\n{ \n\nsum= sum + ((i + diff) % n) * arr[i]; \n\ni++; \n}\n\nreturn sum; \n} \n\n\nstatic int findPivot( int arr[],  int n)  {\n\nint i; \n\ni = 0 ; \n\nwhile(i < n) \n\n{ \n\nif(arr[i] > arr[(i + 1) % n]) \n\nreturn i; \n\ni++; \n}\n\nreturn 0 ; \n} \n\n\npublic static void main(String args[])  {\n\n\n\nint arr[] = { 8 , 3 , 1 , 2 }; \n\nint n = arr.length; \n\nint max = maxSum(arr,n); \n\nSystem.out.println(max); \n\n} \n}", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nsum = \n0\n; \n\nint\ni; \n\nint\npivot = findPivot(arr, n); \n\n\n\n\n\n\nint\ndiff = n - \n1\n- pivot; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nsum= sum + ((i + diff) % n) * arr[i]; \n\n} \n\nreturn\nsum; \n} \n\n\nstatic\nint\nfindPivot(\nint\narr[], \nint\nn) \n{ \n\nint\ni; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nif\n(arr[i] > arr[(i + \n1\n) % n]) \n\nreturn\ni; \n\n} \n\nreturn\n0\n; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\n\n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nmax = maxSum(arr,n); \n\nSystem.out.println(max); \n\n} \n}", "index": 387, "complexity": "1"}
{"forwhile": "public class GFG { static final int MAX_CHAR = 26; static int countSubstringWithEqualEnds(String s) { int result = 0; int n = s.length(); int [] count = new int [MAX_CHAR]; int i = 0; while(i < n) count[s.charAt(i)-'a']++; i = 0; while(i < MAX_CHAR) result += (count[i] * (count[i] + 1) / 2); return result; } public static void main(String args[]) { String s = \"abcab\"; System.out.println(countSubstringWithEqualEnds(s)); } }", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\n\n\nint\n[] count = \nnew\nint\n[MAX_CHAR]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ncount[s.charAt(i)-\n'a'\n]++; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nresult += (count[i] * (count[i] + \n1\n) / \n2\n); \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 388, "complexity": "1"}
{"forwhile": "class\nGFG { \n\n\n\nstatic\nlong\nbinomialCoeff(\nint\nn, \nint\nk) { \n\nlong\nres = \n1\n; \n\n\n\n\nif\n(k > n - k) { \n\nk = n - k; \n\n} \n\n\n\n\nint\ni = \n0\n; \nwhile(i < k) { \n\nres *= (n - i); \n\nres /= (i + \n1\n); \n\ni++; \n} \n\n\nreturn\nres; \n\n} \n\n\n\n\nstatic\nlong\ncatalan(\nint\nn) { \n\n\n\nlong\nc = binomialCoeff(\n2\n* n, n); \n\n\n\nreturn\nc / (n + \n1\n); \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\ni = \n0\n; \nwhile(i < \n10\n) { \n\nSystem.out.print(catalan(i) + \n\" \"\n); \n\ni++; \n} \n\n\n} \n}", "src": "class\nGFG { \n\n\n\nstatic\nlong\nbinomialCoeff(\nint\nn, \nint\nk) { \n\nlong\nres = \n1\n; \n\n\n\n\nif\n(k > n - k) { \n\nk = n - k; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < k; ++i) { \n\nres *= (n - i); \n\nres /= (i + \n1\n); \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\nstatic\nlong\ncatalan(\nint\nn) { \n\n\n\nlong\nc = binomialCoeff(\n2\n* n, n); \n\n\n\n\nreturn\nc / (n + \n1\n); \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalan(i) + \n\" \"\n); \n\n} \n\n\n} \n}", "index": 389, "complexity": "1"}
{"forwhile": "class GFG { static int PermutationCoeff(int n, int k) { int Fn = 1, Fk = 1; int i = 1; while(i <= n) { Fn *= i; if(i == n - k) Fk = Fn; i++; } int coeff = Fn / Fk; return coeff; } public static void main(String args[]) { int n = 10, k = 2; System.out.println(\\\"Value of P( \\\"+ n +\\\",\\\"+ k +\\\") is \\\"+ PermutationCoeff(n, k) ); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nPermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nFn = \n1\n, Fk = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\nFn *= i; \n\nif\n(i == n - k) \n\nFk = Fn; \n\n} \n\nint\ncoeff = Fn / Fk; \n\nreturn\ncoeff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ \n\nk +\n\") is \"\n+ \n\nPermutationCoeff(n, k) ); \n\n} \n}", "index": 390, "complexity": "1"}
{"forwhile": "class GFG { static int countFriendsPairings(int n) { int a = 1, b = 2, c = 0; if (n <= 2) { return n; } int i = 3; while (i <= n) { c = b + (i - 1) * a; a = b; b = c; i++; } return c; } public static void main(String[] args) { int n = 4; System.out.println(countFriendsPairings(n)); } }", "src": "class\nGFG { \n\n\n\n\n\nstatic\nint\ncountFriendsPairings(\nint\nn) \n\n{ \n\nint\na = \n1\n, b = \n2\n, c = \n0\n; \n\nif\n(n <= \n2\n) { \n\nreturn\nn; \n\n} \n\nfor\n(\nint\ni = \n3\n; i <= n; i++) { \n\nc = b + (i - \n1\n) * a; \n\na = b; \n\nb = c; \n\n} \n\nreturn\nc; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n4\n; \n\nSystem.out.println(countFriendsPairings(n)); \n\n} \n}", "index": 391, "complexity": "1"}
{"forwhile": "class GFG  {     static int countSeq( int n) {        int nCr = 1 , res = 1;        int r = 1;        while(r <= n )       {            nCr = (nCr * (n + 1 - r)) / r;            res += nCr * nCr;            r++;       }      return res;    }    public static void main(String args[]) {        int n = 2;        System.out.print( \"Count of sequences is \");        System.out.println(countSeq(n));    } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\nstatic\nint\ncountSeq(\nint\nn) \n{ \n\nint\nnCr = \n1\n, res = \n1\n; \n\n\n\n\nfor\n(\nint\nr = \n1\n; r <= n ; r++) \n\n{ \n\n\n\n\n\nnCr = (nCr * (n + \n1\n- r)) / r; \n\n\nres += nCr * nCr; \n\n} \n\n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.print(\n\"Count of sequences is \"\n); \n\nSystem.out.println(countSeq(n)); \n} \n}", "index": 392, "complexity": "1"}
{"forwhile": "class GFG { static void rearrange(int arr[], int n) { int i = 0; while(i < n) { arr[arr[i] % n] += i * n; i++; } i = 0; while(i < n) { arr[i] /= n; i++; } } static void printArray(int arr[], int n) { int i = 0; while(i < n) { System.out.print(arr[i] + \" \"); i++; } System.out.println(); } public static void main(String[] args) { int arr[] = { 2, 0, 1, 4, 5, 3 }; int n = arr.length; System.out.println(\"Given array is : \"); printArray(arr, n); rearrange(arr, n); System.out.println(\"Modified array is :\"); printArray(arr, n); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nvoid\nrearrange(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\narr[arr[i] % n] += i * n; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\narr[i] /= n; \n\n} \n\n} \n\n\n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\nSystem.out.println(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n2\n, \n0\n, \n1\n, \n4\n, \n5\n, \n3\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(\n\"Given array is : \"\n); \n\nprintArray(arr, n); \n\n\nrearrange(arr, n); \n\n\nSystem.out.println(\n\"Modified array is :\"\n); \n\nprintArray(arr, n); \n\n} \n}", "index": 393, "complexity": "1"}
{"forwhile": "class GFG  { static void findElements( int arr[],  int n) {  int first = Integer.MIN_VALUE;  int second = Integer.MAX_VALUE;  int i = 0;  while(i < n) { if (arr[i] > first) { second = first; first = arr[i]; } else if (arr[i] > second) second = arr[i]; i++; }  i = 0;  while(i < n) { if (arr[i] < second) System.out.print(arr[i] + \" \") ; i++; } } public static void main(String args[]) { int arr[] = { 2, -6, 3, 5, 1};  int n = arr.length;  findElements(arr, n); } }", "src": "class\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nint\nfirst = Integer.MIN_VALUE; \n\nint\nsecond = Integer.MAX_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\nif\n(arr[i] > first) \n\n{ \n\nsecond = first; \n\nfirst = arr[i]; \n\n} \n\n\n\n\nelse\nif\n(arr[i] > second) \n\nsecond = arr[i]; \n\n} \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] < second) \n\nSystem.out.print(arr[i] + \n\" \"\n) ; \n} \n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n} \n}", "index": 394, "complexity": "1"}
{"forwhile": "class GFG { static int smallestSubWithSum(int arr[], int n, int x) { int curr_sum = 0, min_len = n + 1; int start = 0, end = 0; for(; end < n;) { for(; curr_sum <= x && end < n;) { if(curr_sum <= 0 && x > 0) { start = end; curr_sum = 0; } curr_sum += arr[end++]; } for(; curr_sum > x && start < n;) { if(end - start < min_len) min_len = end - start; curr_sum -= arr[start++]; } } return min_len; } public static void main (String[] args) { int arr1[] = {- 8, 1, 4, 2, -6}; int x = 6; int n1 = arr1.length; int res1 = smallestSubWithSum(arr1, n1, x); if(res1 == n1 + 1) System.out.println(\"Not possible\"); else System.out.println(res1); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \n\nint\nn, \nint\nx) \n{ \n\n\n\n\n\nint\ncurr_sum = \n0\n, min_len = n + \n1\n; \n\n\n\n\n\n\nint\nstart = \n0\n, end = \n0\n; \n\nwhile\n(end < n) \n\n{ \n\n\n\n\n\n\n\nwhile\n(curr_sum <= x && end < n) \n\n{ \n\n\n\n\n\n\n\nif\n(curr_sum <= \n0\n&& x > \n0\n) \n\n{ \n\nstart = end; \n\ncurr_sum = \n0\n; \n\n} \n\n\ncurr_sum += arr[end++]; \n\n} \n\n\n\n\n\n\nwhile\n(curr_sum > x && start < n) \n\n{ \n\n\n\n\n\nif\n(end - start < min_len) \n\nmin_len = end - start; \n\n\n\n\ncurr_sum -= arr[start++]; \n\n} \n\n} \n\nreturn\nmin_len; \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\narr1[] = {- \n8\n, \n1\n, \n4\n, \n2\n, -\n6\n}; \n\nint\nx = \n6\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, \n\nn1, x); \n\nif\n(res1 == n1 + \n1\n) \n\nSystem.out.println(\n\"Not possible\"\n); \n\nelse\n\nSystem.out.println (res1); \n} \n}", "index": 395, "complexity": "1"}
{"forwhile": "class\nFindIntersection \n{ \n\n\n\nstatic\nvoid\nprintIntersection(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nfor(; i < m && j < n; ) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\ni++; \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nj++; \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintIntersection(arr1, arr2, m, n); \n\n} \n}", "src": "class\nFindIntersection \n{ \n\n\n\nstatic\nvoid\nprintIntersection(\nint\narr1[], \nint\narr2[], \nint\nm, \nint\nn) \n\n{ \n\nint\ni = \n0\n, j = \n0\n; \n\nwhile\n(i < m && j < n) \n\n{ \n\nif\n(arr1[i] < arr2[j]) \n\ni++; \n\nelse\nif\n(arr2[j] < arr1[i]) \n\nj++; \n\nelse\n\n{ \n\nSystem.out.print(arr2[j++]+\n\" \"\n); \n\ni++; \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr1[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}; \n\nint\narr2[] = {\n2\n, \n3\n, \n5\n, \n7\n}; \n\nint\nm = arr1.length; \n\nint\nn = arr2.length; \n\nprintIntersection(arr1, arr2, m, n); \n\n} \n}", "index": 396, "complexity": "1"}
{"forwhile": "class RotateArray { void leftRotate(int arr[], int d, int n) { int i = 0; while(i < d) { leftRotatebyOne(arr, n); i++; } } void leftRotatebyOne(int arr[], int n) { int i, temp; temp = arr[0]; i = 0; while(i < n - 1) { arr[i] = arr[i + 1]; i++; } arr[i] = temp; } void printArray(int arr[], int n) { int i = 0; while(i < n) { System.out.print(arr[i] + \" \"); i++; } } public static void main(String[] args) { RotateArray rotate = new RotateArray(); int arr[] = { 1, 2, 3, 4, 5, 6, 7 }; rotate.leftRotate(arr, 2, 7); rotate.printArray(arr, 7); } }", "src": "class\nRotateArray { \n\n\n\nvoid\nleftRotate(\nint\narr[], \nint\nd, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < d; i++) \n\nleftRotatebyOne(arr, n); \n\n} \n\n\nvoid\nleftRotatebyOne(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, temp; \n\ntemp = arr[\n0\n]; \n\nfor\n(i = \n0\n; i < n - \n1\n; i++) \n\narr[i] = arr[i + \n1\n]; \n\narr[i] = temp; \n\n} \n\n\n\n\nvoid\nprintArray(\nint\narr[], \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nRotateArray rotate = \nnew\nRotateArray(); \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n}; \n\nrotate.leftRotate(arr, \n2\n, \n7\n); \n\nrotate.printArray(arr, \n7\n); \n\n} \n}", "index": 397, "complexity": "3"}
{"forwhile": "class CountTriangles { static int findNumberOfTriangles(int arr[]) { int n = arr.length; Arrays.sort(arr); int count = 0; int i = 0; while(i < n-2) { int k = i + 2; int j = i+1; while(j < n) { k = i + 2; while(k < n && arr[i] + arr[j] > arr[k]) ++k; if(k>j) count += k - j - 1; j++; } i++; } return count; } public static void main (String[] args) { int arr[] = {10, 21, 22, 100, 101, 200, 300}; System.out.println(\"Total number of triangles is \"+ findNumberOfTriangles(arr)); } }", "src": "class\nCountTriangles \n{ \n\n\n\n\n\nstatic\nint\nfindNumberOfTriangles(\nint\narr[]) \n\n{ \n\nint\nn = arr.length; \n\n\n\nArrays.sort(arr); \n\n\n\n\nint\ncount = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n-\n2\n; ++i) \n\n{ \n\n\n\nint\nk = i + \n2\n; \n\n\n\n\nfor\n(\nint\nj = i+\n1\n; j < n; ++j) \n\n{ \n\n\n\nwhile\n(k < n && arr[i] + arr[j] > arr[k]) \n\n++k; \n\n\n\n\nif\n(k>j) \n\ncount += k - j - \n1\n; \n\n} \n\n} \n\nreturn\ncount; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n10\n, \n21\n, \n22\n, \n100\n, \n101\n, \n200\n, \n300\n}; \n\nSystem.out.println(\n\"Total number of triangles is \"\n+ \n\nfindNumberOfTriangles(arr)); \n\n} \n}", "index": 398, "complexity": "3"}
{"forwhile": "class GFG { static int countPairsWithDiffK( int arr[], int n, int k) { int count = 0; int i = 0; while(i < n) { int j = i + 1; while(j < n) { if(arr[i] - arr[j] == k || arr[j] - arr[i] == k) count++; j++; } i++; } return count; } public static void main(String args[]) { int arr[] = { 1, 5, 3, 4, 2 }; int n = arr.length; int k = 3; System.out.println(\"Count of pairs with given diff is \" + countPairsWithDiffK(arr, n, k)); } }", "src": "class\nGFG { \n\n\nstatic\nint\ncountPairsWithDiffK(\nint\narr[], \n\nint\nn, \nint\nk) \n\n{ \n\nint\ncount = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\nif\n(arr[i] - arr[j] == k || \n\narr[j] - arr[i] == k) \n\ncount++; \n\n} \n\nreturn\ncount; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n5\n, \n3\n, \n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Count of pairs with given diff is \"\n\n+ countPairsWithDiffK(arr, n, k)); \n\n} \n}", "index": 399, "complexity": "3"}
{"forwhile": "class Test  {  static int arr1[] = new int[]{ 1 , 5 , 9 , 10 , 15 , 20};  static int arr2[] = new int[]{ 2 , 3 , 8 , 13};    static void merge( int m,  int n)      {            int i = n-1; while(i >= 0)        {                int j; int last = arr1[m-1];                j = m-2; while(j >= 0 && arr1[j] > arr2[i])                {                    arr1[j+1] = arr1[j];                    j--;                }                if(j != m-2 || last > arr2[i])                {                    arr1[j+1] = arr2[i];                    arr2[i] = last;                }                i--;            }      }      public static void main(String[] args)      {            merge(arr1.length, arr2.length);            System.out.print(\"After Merging nFirst Array: \");            System.out.println(java.util.Arrays.toString(arr1));            System.out.print(\"Second Array: \");            System.out.println(java.util.Arrays.toString(arr2));      }  }", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n1\n, \n5\n, \n9\n, \n10\n, \n15\n, \n20\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n2\n, \n3\n, \n8\n, \n13\n}; \n\n\nstatic\nvoid\nmerge(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\nfor\n(\nint\ni=n-\n1\n; i>=\n0\n; i--) \n\n{ \n\n\n\nint\nj, last = arr1[m-\n1\n]; \n\nfor\n(j=m-\n2\n; j >= \n0\n&& arr1[j] > arr2[i]; j--) \n\narr1[j+\n1\n] = arr1[j]; \n\n\n\n\nif\n(j != m-\n2\n|| last > arr2[i]) \n\n{ \n\narr1[j+\n1\n] = arr2[i]; \n\narr2[i] = last; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nmerge(arr1.length,arr2.length); \n\nSystem.out.print(\n\"After Merging nFirst Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr1)); \n\nSystem.out.print(\n\"Second Array: \"\n); \n\nSystem.out.println(Arrays.toString(arr2)); \n\n} \n}", "index": 400, "complexity": "3"}
{"forwhile": "class GFG { static boolean isPresent(int B[], int m, int x) { int i = 0; while(i < m) { if (B[i] == x) return true; i++; } return false; } static int findMaxSubarraySumUtil(int A[], int B[], int n, int m) { int max_so_far = -2147483648, curr_max = 0; int i = 0; while(i < n) { if (isPresent(B, m, A[i])) { curr_max = 0; i++; continue; } curr_max = Math.max(A[i], curr_max + A[i]); max_so_far = Math.max(max_so_far, curr_max); i++; } return max_so_far; } static void findMaxSubarraySum(int A[], int B[], int n, int m) { int maxSubarraySum = findMaxSubarraySumUtil(A, B, n, m); if (maxSubarraySum == -2147483648) { System.out.println(\"Maximum Subarray Sum\" + \" \" + \"can't be found\"); } else { System.out.println(\"The Maximum Subarray Sum = \" + maxSubarraySum); } } public static void main(String[] args) { int A[] = { 3, 4, 5, -4, 6 }; int B[] = { 1, 8, 5 }; int n = A.length; int m = B.length; findMaxSubarraySum(A, B, n, m); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nisPresent(\nint\nB[], \n\nint\nm, \n\nint\nx) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < m; i++) \n\nif\n(B[i] == x) \n\nreturn\ntrue\n; \n\n\nreturn\nfalse\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxSubarraySumUtil(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\n\nint\nmax_so_far = -\n2147483648\n, curr_max = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\nif\n(isPresent(B, m, A[i])) { \n\ncurr_max = \n0\n; \n\ncontinue\n; \n\n} \n\n\n\n\ncurr_max = Math.max(A[i], curr_max + A[i]); \n\nmax_so_far = Math.max(max_so_far, curr_max); \n\n} \n\nreturn\nmax_so_far; \n\n} \n\n\n\n\nstatic\nvoid\nfindMaxSubarraySum(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\nint\nmaxSubarraySum = findMaxSubarraySumUtil(A, B, \n\nn, m); \n\n\n\n\n\n\n\n\nif\n(maxSubarraySum == -\n2147483648\n) { \n\nSystem.out.println(\n\"Maximum Subarray Sum\"\n\n+ \n\" \"\n+ \n\"can't be found\"\n); \n\n\n} \n\nelse\n{ \n\nSystem.out.println(\n\"The Maximum Subarray Sum = \"\n\n+ maxSubarraySum); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\nA[] = { \n3\n, \n4\n, \n5\n, -\n4\n, \n6\n}; \n\nint\nB[] = { \n1\n, \n8\n, \n5\n}; \n\n\nint\nn = A.length; \n\nint\nm = B.length; \n\n\n\n\nfindMaxSubarraySum(A, B, n, m); \n\n} \n}", "index": 401, "complexity": "3"}
{"forwhile": "class GFG { static int findMaxSum(int[]arr, int n) { int res = Integer.MIN_VALUE; int i = 0; while(i < n) { int prefix_sum = arr[i]; int j = 0; while(j < i) prefix_sum += arr[j++]; int suffix_sum = arr[i]; j = n - 1; while(j > i) suffix_sum += arr[j--]; if(prefix_sum == suffix_sum) res = Math.max(res, prefix_sum); i++; } return res; } public static void main (String[] args) { int arr[] = {-2, 5, 3, 1, 2, 6, -4, 2}; int n = arr.length; System.out.println(findMaxSum(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMaxSum(\nint\n[]arr, \nint\nn) \n\n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\nprefix_sum = arr[i]; \n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nprefix_sum += arr[j]; \n\n\nint\nsuffix_sum = arr[i]; \n\n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nsuffix_sum += arr[j]; \n\n\nif\n(prefix_sum == suffix_sum) \n\nres = Math.max(res, prefix_sum); \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {-\n2\n, \n5\n, \n3\n, \n1\n, \n2\n, \n6\n, -\n4\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(findMaxSum(arr, n)); \n\n} \n}", "index": 402, "complexity": "3"}
{"forwhile": "class EquilibriumIndex { int equilibrium(int arr[], int n) { int i, j; int leftsum, rightsum; i = 0; while(i < n) { leftsum = 0; j = 0; while(j < i) leftsum += arr[j++]; rightsum = 0; j = i + 1; for(; j < n; rightsum += arr[j++]); if(leftsum == rightsum) return i; i++; } return -1; } public static void main(String[] args) { EquilibriumIndex equi = new EquilibriumIndex(); int arr[] = { -7, 1, 5, 2, -4, 3, 0}; int arr_size = arr.length; System.out.println(equi.equilibrium(arr, arr_size)); } }", "src": "class\nEquilibriumIndex { \n\nint\nequilibrium(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\nleftsum, rightsum; \n\n\n\n\nfor\n(i = \n0\n; i < n; ++i) { \n\n\n\n\nleftsum = \n0\n; \n\nfor\n(j = \n0\n; j < i; j++) \n\nleftsum += arr[j]; \n\n\n\n\nrightsum = \n0\n; \n\nfor\n(j = i + \n1\n; j < n; j++) \n\nrightsum += arr[j]; \n\n\n\n\nif\n(leftsum == rightsum) \n\nreturn\ni; \n\n} \n\n\n\n\nreturn\n-\n1\n; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nEquilibriumIndex equi = \nnew\nEquilibriumIndex(); \n\nint\narr[] = { -\n7\n, \n1\n, \n5\n, \n2\n, -\n4\n, \n3\n, \n0\n}; \n\nint\narr_size = arr.length; \n\nSystem.out.println(equi.equilibrium(arr, arr_size)); \n\n} \n}", "index": 403, "complexity": "3"}
{"forwhile": "class LeadersInArray  {\n\n\n\nvoid printLeaders( int arr[],  int size) \n\n{ \n\nint i = 0; \nwhile(i < size) \n\n{ \n\nint j; \n\nj = i + 1; \nwhile(j < size) \n\n{ \n\nif(arr[i] <= arr[j]) \n\nbreak; \n\nj++; \n} \n\nif(j == size) \n\n\nSystem.out.print(arr[i] +  \" \"); \n\ni++; \n} \n\n} \n\n\n\n\npublic static void main(String[] args) \n\n{ \n\nLeadersInArray lead = new LeadersInArray(); \n\nint arr[] = new int[]{16, 17, 4, 3, 5, 2}; \n\nint n = arr.length; \n\nlead.printLeaders(arr, n); \n\n} \n}", "src": "class\nLeadersInArray \n{ \n\n\n\nvoid\nprintLeaders(\nint\narr[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nint\nj; \n\nfor\n(j = i + \n1\n; j < size; j++) \n\n{ \n\nif\n(arr[i] <= arr[j]) \n\nbreak\n; \n\n} \n\nif\n(j == size) \n\n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nLeadersInArray lead = \nnew\nLeadersInArray(); \n\nint\narr[] = \nnew\nint\n[]{\n16\n, \n17\n, \n4\n, \n3\n, \n5\n, \n2\n}; \n\nint\nn = arr.length; \n\nlead.printLeaders(arr, n); \n\n} \n}", "index": 404, "complexity": "3"}
{"forwhile": "class GFG { static void findMajority(int arr[], int n) { int maxCount = 0; int index = -1; int i = 0; while(i < n) { int count = 0; int j = 0; while(j < n) { if(arr[i] == arr[j]) count++; j++; } if(count > maxCount) { maxCount = count; index = i; } i++; } if(maxCount > n/2) System.out.println (arr[index]); else System.out.println (\"No Majority Element\"); } public static void main (String[] args) { int arr[] = {1, 1, 2, 1, 3, 5, 1}; int n = arr.length; findMajority(arr, n); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nfindMajority(\nint\narr[], \nint\nn) \n{ \n\nint\nmaxCount = \n0\n; \n\nint\nindex = -\n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ncount = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nif\n(arr[i] == arr[j]) \n\ncount++; \n\n} \n\n\n\n\n\n\nif\n(count > maxCount) \n\n{ \n\nmaxCount = count; \n\nindex = i; \n\n} \n\n} \n\n\n\n\n\n\nif\n(maxCount > n/\n2\n) \n\nSystem.out.println (arr[index]); \n\n\nelse\n\nSystem.out.println (\n\"No Majority Element\"\n); \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n1\n, \n1\n, \n2\n, \n1\n, \n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\n\n\n\nfindMajority(arr, n); \n\n} \n\n}", "index": 405, "complexity": "3"}
{"forwhile": "class SubarraySum  {     int subArraySum(    int arr[],  int n,  int sum) {     int curr_sum, i, j;         i = 0;     while(i < n) {     curr_sum = arr[i];         j = i + 1;     while(j <= n) {     if(curr_sum == sum) {     int p = j - 1;     System.out.println(    \"Sum found between indexes \" + i         + \" and \" + p);     return 1;     }     if(curr_sum > sum || j == n)     break;     curr_sum = curr_sum + arr[j];     j++;     }     i++;     }     System.out.println(    \"No subarray found\");     return 0;     }     public static void main(String[] args) {     SubarraySum arraysum = new SubarraySum();     int arr[] = {    15, 2, 4, 8, 9, 5, 10, 23};     int n = arr.length;     int sum = 23;     arraysum.subArraySum(arr, n, sum);     } }", "src": "class\nSubarraySum \n{ \n\n\n\nint\nsubArraySum(\nint\narr[], \nint\nn, \nint\nsum) \n\n{ \n\nint\ncurr_sum, i, j; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\ncurr_sum = arr[i]; \n\n\n\n\nfor\n(j = i + \n1\n; j <= n; j++) \n\n{ \n\nif\n(curr_sum == sum) \n\n{ \n\nint\np = j - \n1\n; \n\nSystem.out.println(\n\"Sum found between indexes \"\n+ i \n\n+ \n\" and \"\n+ p); \n\nreturn\n1\n; \n\n} \n\nif\n(curr_sum > sum || j == n) \n\nbreak\n; \n\ncurr_sum = curr_sum + arr[j]; \n\n} \n\n} \n\n\nSystem.out.println(\n\"No subarray found\"\n); \n\nreturn\n0\n; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSubarraySum arraysum = \nnew\nSubarraySum(); \n\nint\narr[] = {\n15\n, \n2\n, \n4\n, \n8\n, \n9\n, \n5\n, \n10\n, \n23\n}; \n\nint\nn = arr.length; \n\nint\nsum = \n23\n; \n\narraysum.subArraySum(arr, n, sum); \n\n} \n}", "index": 406, "complexity": "3"}
{"forwhile": "class FindTriplet { boolean find3Numbers(int A[], int arr_size, int sum) { int l, r; quickSort(A, 0 , arr_size - 1); int i = 0; while(i < arr_size - 2) { l = i + 1; r = arr_size - 1; for(; l < r;) { if(A[i] + A[l] + A[r] == sum) { System.out.print(\"Triplet is \" + A[i] + \", \" + A[l] + \", \" + A[r]); return true; } else if(A[i] + A[l] + A[r] < sum) l++; else r--; } i++; } return false; } int partition(int A[], int si, int ei) { int x = A[ei]; int i = (si - 1); int j; for(j = si; j <= ei - 1; j++) { if(A[j] <= x) { i++; int temp = A[i]; A[i] = A[j]; A[j] = temp; } } int temp = A[i + 1]; A[i + 1] = A[ei]; A[ei] = temp; return (i + 1); } void quickSort(int A[], int si, int ei) { int pi; if(si < ei) { pi = partition(A, si, ei); quickSort(A, si, pi - 1); quickSort(A, pi + 1, ei); } } public static void main(String[] args) { FindTriplet triplet = new FindTriplet(); int A[] = { 1, 4, 45, 6, 10, 8 }; int sum = 22; int arr_size = A.length; triplet.find3Numbers(A, arr_size, sum); } }", "src": "class\nFindTriplet { \n\n\n\n\n\n\nboolean\nfind3Numbers(\nint\nA[], \nint\narr_size, \nint\nsum) \n\n{ \n\nint\nl, r; \n\n\n\n\nquickSort(A, \n0\n, arr_size - \n1\n); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < arr_size - \n2\n; i++) { \n\n\n\n\n\n\n\n\nl = i + \n1\n; \n\n\nr = arr_size - \n1\n; \n\n\nwhile\n(l < r) { \n\nif\n(A[i] + A[l] + A[r] == sum) { \n\nSystem.out.print(\n\"Triplet is \"\n+ A[i] + \n\", \"\n+ A[l] + \n\", \"\n+ A[r]); \n\nreturn\ntrue\n; \n\n} \n\nelse\nif\n(A[i] + A[l] + A[r] < sum) \n\nl++; \n\n\nelse\n\n\nr--; \n\n} \n\n} \n\n\n\n\nreturn\nfalse\n; \n\n} \n\n\nint\npartition(\nint\nA[], \nint\nsi, \nint\nei) \n\n{ \n\nint\nx = A[ei]; \n\nint\ni = (si - \n1\n); \n\nint\nj; \n\n\nfor\n(j = si; j <= ei - \n1\n; j++) { \n\nif\n(A[j] <= x) { \n\ni++; \n\nint\ntemp = A[i]; \n\nA[i] = A[j]; \n\nA[j] = temp; \n\n} \n\n} \n\nint\ntemp = A[i + \n1\n]; \n\nA[i + \n1\n] = A[ei]; \n\nA[ei] = temp; \n\nreturn\n(i + \n1\n); \n\n} \n\n\n\n\nvoid\nquickSort(\nint\nA[], \nint\nsi, \nint\nei) \n\n{ \n\nint\npi; \n\n\n\n\nif\n(si < ei) { \n\npi = partition(A, si, ei); \n\nquickSort(A, si, pi - \n1\n); \n\nquickSort(A, pi + \n1\n, ei); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nFindTriplet triplet = \nnew\nFindTriplet(); \n\nint\nA[] = { \n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n8\n}; \n\nint\nsum = \n22\n; \n\nint\narr_size = A.length; \n\n\ntriplet.find3Numbers(A, arr_size, sum); \n\n} \n}", "index": 407, "complexity": "3"}
{"forwhile": "class GFG {\nstatic void findTriplets(int arr[], int n) {\nboolean found = false;\nint i = 0;\nwhile (i < n - 1) {\nHashSet<Integer> s = new HashSet<Integer>();\nint j = i + 1;\nwhile (j < n) {\nint x = -(arr[i] + arr[j]);\nif (s.contains(x)) {\nSystem.out.printf(\"%d %d %d\\n\", x, arr[i], arr[j]);\nfound = true;\n}\nelse {\ns.add(arr[j]);\n}\nj++;\n}\ni++;\n}\nif (found == false) {\nSystem.out.printf(\" No Triplet Found\\n\");\n}\n}\npublic static void main(String[] args) {\nint arr[] = {0, -1, 2, -3, 1};\nint n = arr.length;\nfindTriplets(arr, n);\n}\n}", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n\n{ \n\nboolean\nfound = \nfalse\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\n{ \n\n\n\n\n\nHashSet<Integer> s = \nnew\nHashSet<Integer>(); \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n{ \n\nint\nx = -(arr[i] + arr[j]); \n\nif\n(s.contains(x)) \n\n{ \n\nSystem.out.printf(\n\"%d %d %d\\n\"\n, x, arr[i], arr[j]); \n\nfound = \ntrue\n; \n\n} \n\nelse\n\n{ \n\ns.add(arr[j]); \n\n} \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\n{ \n\nSystem.out.printf(\n\" No Triplet Found\\n\"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindTriplets(arr, n); \n\n} \n}", "index": 408, "complexity": "3"}
{"forwhile": "class GFG { static void spiralPrint(int m, int n, int a[][]) { int i, k = 0, l = 0; while(k < m && l < n) { i = l; while(i < n) { System.out.print(a[k][i] + \" \"); i++; } k++; i = k; while(i < m) { System.out.print(a[i][n - 1] + \" \"); i++; } n--; if(k < m) { i = n - 1; while(i >= l) { System.out.print(a[m - 1][i] + \" \"); i--; } m--; } if(l < n) { i = m - 1; while(i >= k) { System.out.print(a[i][l] + \" \"); i--; } l++; } } } public static void main(String[] args) { int R = 3; int C = 6; int a[][] = { { 1, 2, 3, 4, 5, 6}, { 7, 8, 9, 10, 11, 12}, { 13, 14, 15, 16, 17, 18} }; spiralPrint(R, C, a); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nspiralPrint(\nint\nm, \nint\nn, \nint\na[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n\n\n\nwhile\n(k < m && l < n) { \n\n\n\nfor\n(i = l; i < n; ++i) { \n\nSystem.out.print(a[k][i] + \n\" \"\n); \n\n} \n\nk++; \n\n\n\n\nfor\n(i = k; i < m; ++i) { \n\nSystem.out.print(a[i][n - \n1\n] + \n\" \"\n); \n\n} \n\nn--; \n\n\n\n\nif\n(k < m) { \n\nfor\n(i = n - \n1\n; i >= l; --i) { \n\nSystem.out.print(a[m - \n1\n][i] + \n\" \"\n); \n\n} \n\nm--; \n\n} \n\n\n\n\nif\n(l < n) { \n\nfor\n(i = m - \n1\n; i >= k; --i) { \n\nSystem.out.print(a[i][l] + \n\" \"\n); \n\n} \n\nl++; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nR = \n3\n; \n\nint\nC = \n6\n; \n\nint\na[][] = { { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n}, \n\n{ \n7\n, \n8\n, \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n, \n17\n, \n18\n} }; \n\nspiralPrint(R, C, a); \n\n} \n}", "index": 409, "complexity": "3"}
{"forwhile": "class GFG { static int R = 4; static int C = 4; static void counterClockspiralPrint(int m, int n, int arr[][]) { int i, k = 0, l = 0; int cnt = 0; int total = m * n; for (; k < m && l < n; k++) { if (cnt == total) break; i = k; while (i < m) { System.out.print(arr[i][l] + \" \"); cnt++; i++; } l++; if (cnt == total) break; i = l; while (i < n) { System.out.print(arr[m - 1][i] + \" \"); cnt++; i++; } m--; if (cnt == total) break; if (k < m) { i = m - 1; while (i >= k) { System.out.print(arr[i][n - 1] + \" \"); cnt++; i--; } n--; } if (cnt == total) break; if (l < n) { i = n - 1; while (i >= l) { System.out.print(arr[k][i] + \" \"); cnt++; i--; } k++; } } } public static void main(String[] args) { int arr[][] = { { 1, 2, 3, 4}, { 5, 6, 7, 8}, { 9, 10, 11, 12}, { 13, 14, 15, 16} }; counterClockspiralPrint(R, C, arr); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nR = \n4\n; \n\nstatic\nint\nC = \n4\n; \n\n\n\n\n\n\nstatic\nvoid\ncounterClockspiralPrint(\nint\nm, \n\nint\nn, \n\nint\narr[][]) \n\n{ \n\nint\ni, k = \n0\n, l = \n0\n; \n\n\n\n\n\n\n\nint\ncnt = \n0\n; \n\n\n\n\n\n\nint\ntotal = m * n; \n\n\nwhile\n(k < m && l < n) \n\n{ \n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nfor\n(i = k; i < m; ++i) \n\n{ \n\nSystem.out.print(arr[i][l] + \n\" \"\n); \n\ncnt++; \n\n} \n\nl++; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nfor\n(i = l; i < n; ++i) \n\n{ \n\nSystem.out.print(arr[m - \n1\n][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nm--; \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nif\n(k < m) \n\n{ \n\nfor\n(i = m - \n1\n; i >= k; --i) \n\n{ \n\nSystem.out.print(arr[i][n - \n1\n] + \n\" \"\n); \n\ncnt++; \n\n} \n\nn--; \n\n} \n\n\nif\n(cnt == total) \n\nbreak\n; \n\n\n\n\n\n\nif\n(l < n) \n\n{ \n\nfor\n(i = n - \n1\n; i >= l; --i) \n\n{ \n\nSystem.out.print(arr[k][i] + \n\" \"\n); \n\ncnt++; \n\n} \n\nk++; \n\n} \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[][] = { { \n1\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n5\n, \n6\n, \n7\n, \n8\n}, \n\n{ \n9\n, \n10\n, \n11\n, \n12\n}, \n\n{ \n13\n, \n14\n, \n15\n, \n16\n} }; \n\n\n\n\ncounterClockspiralPrint(R, C, arr); \n} \n}", "index": 410, "complexity": "3"}
{"forwhile": "class GFG { public static int N = 4, M = 6; static int findMaxPath(int mat[]) { int res = -1; int i = 0; while(i < M) { res = max(res, mat[0][i]); i++; } i = 1; while(i < N) { res = -1; int j = 0; while(j < M) { if(j > 0 && j < M - 1) mat[i][j] += max(mat[i - 1][j], max(mat[i - 1][j - 1], mat[i - 1][j + 1])); else if(j > 0) mat[i][j] += max(mat[i - 1][j], mat[i - 1][j - 1]); else if(j < M - 1) mat[i][j] += max(mat[i - 1][j], mat[i - 1][j + 1]); res = max(mat[i][j], res); j++; } i++; } return res; } public static void main (String[] args) { int mat[][] = { { 10, 10, 2, 0, 20, 4}, { 1, 0, 0, 30, 2, 5}, { 0, 10, 4, 0, 2, 0}, { 1, 0, 2, 20, 0, 4} }; System.out.println(findMaxPath(mat)); } }", "src": "class\nGFG \n{ \n\npublic\nstatic\nint\nN = \n4\n, M = \n6\n; \n\n\n\n\nstatic\nint\nfindMaxPath(\nint\nmat[][]) \n\n{ \n\n\n\nint\nres = -\n1\n; \n\nfor\n(\nint\ni = \n0\n; i < M; i++) \n\nres = max(res, mat[\n0\n][i]); \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\nres = -\n1\n; \n\nfor\n(\nint\nj = \n0\n; j < M; j++) \n\n{ \n\n\n\nif\n(j > \n0\n&& j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmax(mat[i - \n1\n][j - \n1\n], \n\nmat[i - \n1\n][j + \n1\n])); \n\n\n\n\nelse\nif\n(j > \n0\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j - \n1\n]); \n\n\n\n\nelse\nif\n(j < M - \n1\n) \n\nmat[i][j] += max(mat[i - \n1\n][j], \n\nmat[i - \n1\n][j + \n1\n]); \n\n\n\n\nres = max(mat[i][j], res); \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nmat[][] = { { \n10\n, \n10\n, \n2\n, \n0\n, \n20\n, \n4\n}, \n\n{ \n1\n, \n0\n, \n0\n, \n30\n, \n2\n, \n5\n}, \n\n{ \n0\n, \n10\n, \n4\n, \n0\n, \n2\n, \n0\n}, \n\n{ \n1\n, \n0\n, \n2\n, \n20\n, \n0\n, \n4\n} \n\n}; \n\n\nSystem.out.println(findMaxPath(mat)); \n\n} \n}", "index": 411, "complexity": "3"}
{"forwhile": "class LinkedList { static Node head; static class Node { int data; Node next; Node(int d) { data = d; next = null; } } void remove_duplicates() { Node ptr1 = null, ptr2 = null, dup = null; ptr1 = head; while (ptr1 != null && ptr1.next != null) { ptr2 = ptr1; while (ptr2.next != null) { if (ptr1.data == ptr2.next.data) { dup = ptr2.next; ptr2.next = ptr2.next.next; System.gc(); } else { ptr2 = ptr2.next; } } ptr1 = ptr1.next; } } void printList(Node node) { for(; node != null; System.out.print(node.data + \" \"), node = node.next); } public static void main(String[] args) { LinkedList list = new LinkedList(); list.head = new Node(10); list.head.next = new Node(12); list.head.next.next = new Node(11); list.head.next.next.next = new Node(11); list.head.next.next.next.next = new Node(12); list.head.next.next.next.next.next = new Node(11); list.head.next.next.next.next.next.next = new Node(10); System.out.println(\"Linked List before removing duplicates : \\n \"); list.printList(head); list.remove_duplicates(); System.out.println(\"\"); System.out.println(\"Linked List after removing duplicates : \\n \"); list.printList(head); } }", "src": "class\nLinkedList { \n\n\nstatic\nNode head; \n\n\nstatic\nclass\nNode { \n\n\nint\ndata; \n\nNode next; \n\n\nNode(\nint\nd) { \n\ndata = d; \n\nnext = \nnull\n; \n\n} \n\n} \n\n\n\n\nvoid\nremove_duplicates() { \n\nNode ptr1 = \nnull\n, ptr2 = \nnull\n, dup = \nnull\n; \n\nptr1 = head; \n\n\n\n\nwhile\n(ptr1 != \nnull\n&& ptr1.next != \nnull\n) { \n\nptr2 = ptr1; \n\n\n\n\nwhile\n(ptr2.next != \nnull\n) { \n\n\n\n\nif\n(ptr1.data == ptr2.next.data) { \n\n\n\n\ndup = ptr2.next; \n\nptr2.next = ptr2.next.next; \n\nSystem.gc(); \n\n} \nelse\n\n{ \n\nptr2 = ptr2.next; \n\n} \n\n} \n\nptr1 = ptr1.next; \n\n} \n\n} \n\n\nvoid\nprintList(Node node) { \n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\nnode = node.next; \n\n} \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nLinkedList list = \nnew\nLinkedList(); \n\nlist.head = \nnew\nNode(\n10\n); \n\nlist.head.next = \nnew\nNode(\n12\n); \n\nlist.head.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next.next = \nnew\nNode(\n12\n); \n\nlist.head.next.next.next.next.next = \nnew\nNode(\n11\n); \n\nlist.head.next.next.next.next.next.next = \nnew\nNode(\n10\n); \n\n\nSystem.out.println(\n\"Linked List before removing duplicates : \\n \"\n); \n\nlist.printList(head); \n\n\nlist.remove_duplicates(); \n\nSystem.out.println(\n\"\"\n); \n\nSystem.out.println(\n\"Linked List after removing duplicates : \\n \"\n); \n\nlist.printList(head); \n\n} \n}", "index": 412, "complexity": "3"}
{"forwhile": "public class GFG { static class Node { public int data ; public Node next; public Node( int data ) { this . data = data; } } static void getJosephusPosition( int m, int n) { Node head = new Node( 1 ); Node prev = head; int i = 2 ; while( i <= n) { prev.next = new Node(i); prev = prev.next; i++; } prev.next = head; Node ptr1 = head, ptr2 = head; for(; ptr1.next != ptr1; ) { int count = 1 ; for(; count != m; ) { ptr2 = ptr1; ptr1 = ptr1.next; count++; } ptr2.next = ptr1.next; ptr1 = ptr2.next; } System.out.println ( \"Last person left standing \" + \"(Josephus Position) is \" + ptr1.data); } public static void main(String args[]) { int n = 14 , m = 2 ; getJosephusPosition(m, n); } }", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nclass\nNode \n\n{ \n\npublic\nint\ndata ; \n\npublic\nNode next; \n\npublic\nNode( \nint\ndata ) \n\n{ \n\nthis\n.data = data; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\ngetJosephusPosition(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\nNode head = \nnew\nNode(\n1\n); \n\nNode prev = head; \n\nfor\n(\nint\ni = \n2\n; i <= n; i++) \n\n{ \n\nprev.next = \nnew\nNode(i); \n\nprev = prev.next; \n\n} \n\n\n\n\nprev.next = head; \n\n\n\n\nNode ptr1 = head, ptr2 = head; \n\n\nwhile\n(ptr1.next != ptr1) \n\n{ \n\n\n\n\nint\ncount = \n1\n; \n\nwhile\n(count != m) \n\n{ \n\nptr2 = ptr1; \n\nptr1 = ptr1.next; \n\ncount++; \n\n} \n\n\n\n\nptr2.next = ptr1.next; \n\nptr1 = ptr2.next; \n\n} \n\nSystem.out.println (\n\"Last person left standing \"\n+ \n\n\"(Josephus Position) is \"\n+ ptr1.data); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n14\n, m = \n2\n; \n\ngetJosephusPosition(m, n); \n\n} \n}", "index": 413, "complexity": "3"}
{"forwhile": "class GFG { static int maxSum(int arr[], int n) { int res = Integer.MIN_VALUE; int i = 0; while(i < n) { int curr_sum = 0; int j = 0; while(j < n) { int index = (i + j) % n; curr_sum += j * arr[index]; j++; } res = Math.max(res, curr_sum); i++; } return res; } public static void main(String args[]) { int arr[] = { 8, 3, 1, 2 }; int n = arr.length; System.out.println(maxSum(arr, n)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n{ \n\n\n\n\nint\ncurr_sum = \n0\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nint\nindex = (i + j) % n; \n\ncurr_sum += j * arr[index]; \n\n} \n\n\n\n\nres = Math.max(res, curr_sum); \n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n} \n\n\n}", "index": 414, "complexity": "3"}
{"forwhile": "class GFG { \n\n\n\nstatic void calculateSpan( int price[], int n, int S[]) \n\n{ \n\n\n\nS[\n0\n] = \n1\n; \n\n\n\n\n\n\nint i = 1;\nwhile(i < n) { \n\nS[i] = \n1\n; \n\n\n\n\n\n\n\nint j = i - \n1\n;\nwhile((j >= \n0\n) && (price[i] >= price[j])) \n{\nS[i]++; \n j--;}\n i++; \n\n}\n\n} \n\n\n\n\nstatic void printArray( int arr[]) \n\n{ \n\nSystem.out.print(Arrays.toString(arr)); \n\n} \n\n\n\n\npublic static void main(String[] args) \n\n{ \n\n int price[] = { \n10\n, \n4\n, \n5\n, \n90\n, \n120\n, \n80\n}; \n\n int n = price.length; \n\n int S[] = new int[n]; \n\n\n\n\nt int i = 0;\nfor(; i < n; i++)\n{ \n\nS[i] = 1; }\n\n\n\n\nprintArray(S); \n\n} \n}", "src": "class\nGFG { \n\n\n\nstatic\nvoid\ncalculateSpan(\nint\nprice[], \nint\nn, \nint\nS[]) \n\n{ \n\n\n\nS[\n0\n] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) { \n\nS[i] = \n1\n; \n\n\n\n\n\n\n\nfor\n(\nint\nj = i - \n1\n; (j >= \n0\n) && (price[i] >= price[j]); j--) \n\nS[i]++; \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\narr[]) \n\n{ \n\nSystem.out.print(Arrays.toString(arr)); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nprice[] = { \n10\n, \n4\n, \n5\n, \n90\n, \n120\n, \n80\n}; \n\nint\nn = price.length; \n\nint\nS[] = \nnew\nint\n[n]; \n\n\n\n\ncalculateSpan(price, n, S); \n\n\n\n\nprintArray(S); \n\n} \n}", "index": 415, "complexity": "3"}
{"forwhile": "class GFG { static Stack<Integer> sortStack(Stack<Integer> input) { Stack<Integer> tmpStack = new Stack<Integer>(); while(!input.empty()) { int tmp = input.peek(); input.pop(); for(; !tmpStack.empty() && tmpStack.peek() < tmp; ) { input.push(tmpStack.peek()); tmpStack.pop(); } tmpStack.push(tmp); } return tmpStack; } static void sortArrayUsingStacks(int[] arr, int n) { Stack<Integer> input = new Stack<Integer>(); int i = 0; while(i < n) { input.push(arr[i]); i++; } Stack<Integer> tmpStack = sortStack(input); i = 0; while(i < n) { arr[i] = tmpStack.peek(); tmpStack.pop(); i++; } } public static void main(String args[]) { int[] arr = { 10, 5, 15, 45 }; int n = arr.length; sortArrayUsingStacks(arr, n); i = 0; while(i < n) { System.out.print(arr[i] + \" \"); i++; } } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nStack<Integer> sortStack(Stack<Integer> input) \n\n{ \n\nStack<Integer> tmpStack = \n\nnew\nStack<Integer>(); \n\n\nwhile\n(!input.empty()) \n\n{ \n\n\n\n\n\nint\ntmp = input.peek(); \n\ninput.pop(); \n\n\n\n\n\n\n\n\nwhile\n(!tmpStack.empty() && \n\ntmpStack.peek() < tmp) \n\n{ \n\n\n\n\n\n\n\ninput.push(tmpStack.peek()); \n\ntmpStack.pop(); \n\n} \n\n\n\n\n\n\ntmpStack.push(tmp); \n\n} \n\n\nreturn\ntmpStack; \n\n} \n\n\nstatic\nvoid\nsortArrayUsingStacks(\nint\n[]arr, \n\nint\nn) \n\n{ \n\n\n\n\n\nStack<Integer> input = \n\nnew\nStack<Integer>(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ninput.push(arr[i]); \n\n\n\n\nStack<Integer> tmpStack = \n\nsortStack(input); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\narr[i] = tmpStack.peek(); \n\ntmpStack.pop(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = {\n10\n, \n5\n, \n15\n, \n45\n}; \n\nint\nn = arr.length; \n\n\nsortArrayUsingStacks(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 416, "complexity": "3"}
{"forwhile": "class GFG { public static int minIndex(Queue<Integer> list, int sortIndex) { int min_index = -1; int min_value = Integer.MAX_VALUE; int s = list.size(); int i = 0; while(i < s) { int current = list.peek(); list.poll(); if(current <= min_value && i <= sortIndex) { min_index = i; min_value = current; } list.add(current); i++; } return min_index; } public static void insertMinToRear(Queue<Integer> list, int min_index) { int min_value = 0; int s = list.size(); int i = 0; while(i < s) { int current = list.peek(); list.poll(); if(i != min_index) list.add(current); else min_value = current; i++; } list.add(min_value); } public static void sortQueue(Queue<Integer> list) { int i = 1; while(i <= list.size()) { int min_index = minIndex(list,list.size() - i); insertMinToRear(list, min_index); i++; } } public static void main (String[] args) { Queue<Integer> list = new LinkedList<Integer>(); list.add(30); list.add(11); list.add(15); list.add(4); sortQueue(list); while(!list.isEmpty()== false) { System.out.print(list.peek() + \" \"); list.poll(); } } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\npublic\nstatic\nint\nminIndex(Queue<Integer> list, \n\nint\nsortIndex) \n\n{ \n\nint\nmin_index = -\n1\n; \n\nint\nmin_value = Integer.MAX_VALUE; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\n\n\n\nlist.poll(); \n\n\n\n\n\n\n\n\n\n\nif\n(current <= min_value && i <= sortIndex) \n\n{ \n\nmin_index = i; \n\nmin_value = current; \n\n} \n\nlist.add(current); \n\n} \n\nreturn\nmin_index; \n} \n\n\n\n\n\n\npublic\nstatic\nvoid\ninsertMinToRear(Queue<Integer> list, \n\nint\nmin_index) \n\n{ \n\nint\nmin_value = \n0\n; \n\nint\ns = list.size(); \n\nfor\n(\nint\ni = \n0\n; i < s; i++) \n\n{ \n\nint\ncurrent = list.peek(); \n\nlist.poll(); \n\nif\n(i != min_index) \n\nlist.add(current); \n\nelse\n\nmin_value = current; \n\n} \n\nlist.add(min_value); \n\n} \n\n\npublic\nstatic\nvoid\nsortQueue(Queue<Integer> list) \n\n{ \n\nfor\n(\nint\ni = \n1\n; i <= list.size(); i++) \n\n{ \n\nint\nmin_index = minIndex(list,list.size() - i); \n\ninsertMinToRear(list, min_index); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nQueue<Integer> list = \nnew\nLinkedList<Integer>(); \n\nlist.add(\n30\n); \n\nlist.add(\n11\n); \n\nlist.add(\n15\n); \n\nlist.add(\n4\n); \n\n\n\n\nsortQueue(list); \n\n\n\n\nwhile\n(list.isEmpty()== \nfalse\n) \n\n{ \n\nSystem.out.print(list.peek() + \n\" \"\n); \n\nlist.poll(); \n\n} \n\n} \n}", "index": 417, "complexity": "3"}
{"forwhile": "class\\nNode { \\n\\nint\\ndata; \\n\\nNode left, right; \\n\\n\\npublic\\nNode(\\nint\\nd) \\n\\n{ \\n\\ndata = d; \\n\\nleft = right = \\nnull\\; \\n\\n} \\n} \\n\\nclass\\nBinaryTree { \\n\\nNode root; \\n\\n\\n\\nvoid\\nprintSpiral(Node node) \\n\\n{ \\n\\nint\\nh = height(node); \\n\\nint\\ni; \\n\\n\\n\\nboolean\\nltr = \\nfalse\\; \\n\\ni = \\n1\\; \\nwhile(i <= h) { \\n\\nprintGivenLevel(node, i, ltr); \\n\\n\\n\\nltr = !ltr; \\n\\ni++; \\n} \\n\\n} \\n\\n\\n\\nint\\nheight(Node node) \\n\\n{ \\n\\nif\\n(node == \\nnull\\) \\n\\nreturn\\n0\\; \\n\\nelse\\{ \\n\\n\\n\\nint\\nlheight = height(node.left); \\n\\nint\\nrheight = height(node.right); \\n\\n\\n\\nif\\n(lheight > rheight) \\n\\nreturn\\n(lheight + \\n1\\); \\n\\nelse\\n\\nreturn\\n(rheight + \\n1\\); \\n\\n} \\n\\n} \\n\\n\\n\\nvoid\\nprintGivenLevel(Node node, \\nint\\nlevel, \\nboolean\\nltr) \\n\\n{ \\n\\nif\\n(node == \\nnull\\) \\n\\nreturn\\; \\n\\ni = \\n0\\; \\nfor(; i < h; i++) { \\n\\nif\\n(level == \\n1\\) \\n\\nSystem.out.print(node.data + \\n\" \"\\); \\n\\nelse\\nif\\n(level > \\n1\\) { \\n\\nif\\n(ltr != \\nfalse\\) { \\n\\nprintGivenLevel(node.left, level - \\n1\\, ltr); \\n\\nprintGivenLevel(node.right, level - \\n1\\, ltr); \\n\\n} \\n\\nelse\\n{ \\n\\nprintGivenLevel(node.right, level - \\n1\\, ltr); \\n\\nprintGivenLevel(node.left, level - \\n1\\, ltr); \\n\\n} \\n\\n} \\n\\n} \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nBinaryTree tree = \\nnew\\BinaryTree(); \\n\\ntree.root = \\nnew\\Node(\\n1\\); \\n\\ntree.root.left = \\nnew\\Node(\\n2\\); \\n\\ntree.root.right = \\nnew\\Node(\\n3\\); \\n\\ntree.root.left.left = \\nnew\\Node(\\n7\\); \\n\\ntree.root.left.right = \\nnew\\Node(\\n6\\); \\n\\ntree.root.right.left = \\nnew\\Node(\\n5\\); \\n\\ntree.root.right.right = \\nnew\\Node(\\n4\\); \\n\\nSystem.out.println(\\n\"Spiral order traversal of Binary Tree is \"\\); \\n\\ntree.printSpiral(tree.root); \\n\\n} \\n}", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\n\n\n\nboolean\nltr = \nfalse\n; \n\nfor\n(i = \n1\n; i <= h; i++) { \n\nprintGivenLevel(node, i, ltr); \n\n\n\n\nltr = !ltr; \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n{ \n\n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel, \nboolean\nltr) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) { \n\nif\n(ltr != \nfalse\n) { \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\n} \n\nelse\n{ \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\n} \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(tree.root); \n\n} \n}", "index": 418, "complexity": "3"}
{"forwhile": "public class GFG { static void printKMax(int arr[], int n, int k) { int j, max; int i = 0; while(i <= n - k) { max = arr[i]; j = 1; while(j < k) { if(arr[i + j] > max) max = arr[i + j]; j++; } System.out.print(max + \" \"); i++; } } public static void main(String args[]) { int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; int k = 3; printKMax(arr, arr.length, k); } }", "src": "public\nclass\nGFG { \n\n\n\nstatic\nvoid\nprintKMax(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nj, max; \n\n\nfor\n(\nint\ni = \n0\n; i <= n - k; i++) { \n\n\nmax = arr[i]; \n\n\nfor\n(j = \n1\n; j < k; j++) { \n\nif\n(arr[i + j] > max) \n\nmax = arr[i + j]; \n\n} \n\nSystem.out.print(max + \n\" \"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n6\n, \n7\n, \n8\n, \n9\n, \n10\n}; \n\nint\nk = \n3\n; \n\nprintKMax(arr, arr.length, k); \n\n} \n}", "index": 419, "complexity": "3"}
{"forwhile": "class solution { static void printFirstNegativeInteger(int arr[], int n, int k) { boolean flag; int i = 0; while (i < (n - k + 1)) { flag = false; int j = 0; while (j < k) { if (arr[i + j] < 0) { System.out.print((arr[i + j]) + \" \"); flag = true; break; } j++; } if (!flag) System.out.print(\"0\" + \" \"); i++; } } public static void main(String args[]) { int arr[] = { 12, -1, -7, 8, -15, 30, 16, 28 }; int n = arr.length; int k = 3; printFirstNegativeInteger(arr, n, k); } }", "src": "class\nsolution \n{ \n\n\n\nstatic\nvoid\nprintFirstNegativeInteger(\nint\narr[], \nint\nn, \nint\nk) \n{ \n\n\n\n\n\nboolean\nflag; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i<(n-k+\n1\n); i++) \n\n{ \n\nflag = \nfalse\n; \n\n\n\n\nfor\n(\nint\nj = \n0\n; j<k; j++) \n\n{ \n\n\n\n\n\n\n\n\n\nif\n(arr[i+j] < \n0\n) \n\n{ \n\nSystem.out.print((arr[i+j])+\n\" \"\n); \n\nflag = \ntrue\n; \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nif\n(!flag) \n\nSystem.out.print(\n\"0\"\n+\n\" \"\n); \n\n} \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n12\n, -\n1\n, -\n7\n, \n8\n, -\n15\n, \n30\n, \n16\n, \n28\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\nprintFirstNegativeInteger(arr, n, k); \n\n} \n}", "index": 420, "complexity": "3"}
{"forwhile": "class GFG { static int maxSubarrayXOR(int arr[], int n) { int ans = Integer.MIN_VALUE; int i = 0; while(i < n) { int curr_xor = 0; int j = i; while(j < n) { curr_xor = curr_xor ^ arr[j]; ans = Math.max(ans, curr_xor); j++; } i++; } return ans; } public static void main(String args[]) { int arr[] = {8, 1, 2, 12}; int n = arr.length; System.out.println(\"Max subarray XOR is \"+ maxSubarrayXOR(arr, n)); } }", "src": "class\nGFG { \n\nstatic\nint\nmaxSubarrayXOR(\nint\narr[], \nint\nn) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\nint\ncurr_xor = \n0\n; \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\ncurr_xor = curr_xor ^ arr[j]; \n\nans = Math.max(ans, curr_xor); \n\n} \n\n} \n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = {\n8\n, \n1\n, \n2\n, \n12\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Max subarray XOR is \"\n+ \n\nmaxSubarrayXOR(arr, n)); \n\n} \n}", "index": 421, "complexity": "3"}
{"forwhile": "class GFG { public static void splitArr(int arr[], int n, int k) { int i = 0; while(i < k) { int x = arr[0]; int j = 0; while(j < n - 1) { arr[j] = arr[j + 1]; j++; } arr[n - 1] = x; i++; } } public static void main(String[] args) { int arr[] = { 12, 10, 5, 6, 52, 36 }; int n = arr.length; int position = 2; splitArr(arr, 6, position); int i = 0; for(; i < n; ++i) System.out.print(arr[i] + \" \"); } }", "src": "class\nGFG { \n\npublic\nstatic\nvoid\nsplitArr(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < k; i++) { \n\n\n\n\nint\nx = arr[\n0\n]; \n\nfor\n(\nint\nj = \n0\n; j < n - \n1\n; ++j) \n\narr[j] = arr[j + \n1\n]; \n\narr[n - \n1\n] = x; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nsplitArr(arr, \n6\n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 422, "complexity": "3"}
{"forwhile": "public\\nclass\\nCountKSubStr \\n{ \\n\\n\\n\\n\\nint\\ncountkDist(String str, \\nint\\nk) \\n\\n{ \\n\\n\\n\\nint\\nres = \\n0\\n; \\n\\n\\nint\\nn = str.length(); \\n\\n\\n\\nint\\ncnt[] = \\nnew\\nint\\n[\\n26\\n]; \\n\\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile( i < n) \\n\\n{ \\n\\nint\\ndist_count = \\n0\\n; \\n\\n\\n\\nArrays.fill(cnt, \\n0\\n); \\n\\n\\n\\n\\nint\\nj=i; while( j<n) \\n\\n{ \\n\\n\\n\\n\\nif\\n(cnt[str.charAt(j) - \\n'a'\\n] == \\n0\\n) \\n\\ndist_count++; \\n\\n\\n\\ncnt[str.charAt(j) - \\n'a'\\n]++; \\n\\n\\n\\n\\n\\nif\\n(dist_count == k) \\n\\nres++; \\n\\n\\n} \\ni++; } \\n\\n\\nreturn\\nres; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nCountKSubStr ob = \\nnew\\nCountKSubStr(); \\n\\nString ch = \\n\"abcbaa\"\\n; \\n\\nint\\nk = \\n3\\n; \\n\\nSystem.out.println(\\n\"Total substrings with exactly \"\\n+ \\nk + \\n\" distinct characters : \"\\n\\n+ ob.countkDist(ch, k)); \\n\\n} \\n}", "src": "public\nclass\nCountKSubStr \n{ \n\n\n\n\n\nint\ncountkDist(String str, \nint\nk) \n\n{ \n\n\n\nint\nres = \n0\n; \n\n\nint\nn = str.length(); \n\n\n\n\nint\ncnt[] = \nnew\nint\n[\n26\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndist_count = \n0\n; \n\n\n\n\nArrays.fill(cnt, \n0\n); \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\n\n\n\n\nif\n(cnt[str.charAt(j) - \n'a'\n] == \n0\n) \n\ndist_count++; \n\n\n\n\ncnt[str.charAt(j) - \n'a'\n]++; \n\n\n\n\n\n\nif\n(dist_count == k) \n\nres++; \n\n} \n\n} \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountKSubStr ob = \nnew\nCountKSubStr(); \n\nString ch = \n\"abcbaa\"\n; \n\nint\nk = \n3\n; \n\nSystem.out.println(\n\"Total substrings with exactly \"\n+ \n\nk + \n\" distinct characters : \"\n\n+ ob.countkDist(ch, k)); \n\n} \n}", "index": 423, "complexity": "3"}
{"forwhile": "class GFG { static int MAX_CHAR = 26; static boolean check(int freq[], int k) { int i = 0; while(i < MAX_CHAR) { if(freq[i] != 0 && freq[i] != k) return false; i++; } return true; } static int substrings(String s, int k) { int res = 0; int i = 0; while(i < s.length()) { int freq[] = new int[MAX_CHAR]; int j = i; while(j < s.length()) { int index = s.charAt(j) - 'a'; freq[index]++; if(freq[index] > k) break; else if(freq[index] == k && check(freq, k) == true) res++; j++; } i++; } return res; } public static void main(String[] args) { String s = \"aabbcc\"; int k = 2; System.out.println(substrings(s, k)); s = \"aabbc\"; k = 2; System.out.println(substrings(s, k)); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nMAX_CHAR = \n26\n; \n\n\n\nstatic\nboolean\ncheck(\nint\nfreq[], \nint\nk) \n{ \n\nfor\n(\nint\ni = \n0\n; i < MAX_CHAR; i++) \n\nif\n(freq[i] !=\n0\n&& freq[i] != k) \n\nreturn\nfalse\n; \n\nreturn\ntrue\n; \n} \n\n\n\nstatic\nint\nsubstrings(String s, \nint\nk) \n{ \n\nint\nres = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i< s.length(); i++) \n\n{ \n\n\n\n\n\n\nint\nfreq[] = \nnew\nint\n[MAX_CHAR]; \n\n\n\n\nfor\n(\nint\nj = i; j<s.length(); j++) \n\n{ \n\n\n\n\nint\nindex = s.charAt(j) - \n'a'\n; \n\nfreq[index]++; \n\n\n\n\n\n\n\n\nif\n(freq[index] > k) \n\nbreak\n; \n\n\n\n\n\n\nelse\nif\n(freq[index] == k && \n\ncheck(freq, k) == \ntrue\n) \n\nres++; \n\n} \n\n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nString s = \n\"aabbcc\"\n; \n\nint\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n\n\ns = \n\"aabbc\"\n; \n\nk = \n2\n; \n\nSystem.out.println(substrings(s, k)); \n} \n}", "index": 424, "complexity": "3"}
{"forwhile": "public\\nclass\\nGFG { \\n\\n\\n\\n\\n\\nstatic\\nboolean\\ncheckEquality(String s) \\n\\n{ \\n\\nreturn\\n(s.charAt(\\n0\\n) == s.charAt(s.length() - \\n1\\n)); \\n\\n} \\n\\n\\nstatic\\nint\\ncountSubstringWithEqualEnds(String s) \\n\\n{ \\n\\nint\\nresult = \\n0\\n; \\n\\nint\\nn = s.length(); \\n\\n\\n\\nint\\ni = \\n0\\n; \\nwhile(i < n) \\n{ \\n\\n\\n\\nint\\nlen = \\n1\\n; \\nwhile(len <= n-i) \\n{ \\n\\n\\nif\\n(checkEquality(s.substring(i, i + len))) \\n\\nresult++; \\n\\nlen++; \\n} \\ni++; \\n} \\n\\nreturn\\nresult; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nString s = \\n\"abcab\"\\n; \\n\\nSystem.out.println(countSubstringWithEqualEnds(s)); \\n\\n} \\n}", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nboolean\ncheckEquality(String s) \n\n{ \n\nreturn\n(s.charAt(\n0\n) == s.charAt(s.length() - \n1\n)); \n\n} \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n\n\n\nfor\n(\nint\nlen = \n1\n; len <= n-i; len++) \n\n\n\n\n\n\nif\n(checkEquality(s.substring(i, i + len))) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 426, "complexity": "3"}
{"forwhile": "public class GFG { static int countSubstringWithEqualEnds(String s) { int result = 0; int n = s.length(); int i = 0; while(i < n) { int j = i; while(j < n) { if(s.charAt(i) == s.charAt(j)) result++; j++; } i++; } return result; } public static void main(String args[]) { String s = \"abcab\"; System.out.println(countSubstringWithEqualEnds(s)); } }", "src": "public\nclass\nGFG { \n\n\nstatic\nint\ncountSubstringWithEqualEnds(String s) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = s.length(); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nfor\n(\nint\nj = i; j < n; j++) \n\nif\n(s.charAt(i) == s.charAt(j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString s = \n\"abcab\"\n; \n\nSystem.out.println(countSubstringWithEqualEnds(s)); \n\n} \n}", "index": 427, "complexity": "3"}
{"forwhile": "class GFG { public static void SplitAndAdd(int [] A, int length, int rotation){ int [] tmp = new int [length*2]; System.arraycopy(A, 0, tmp, 0, length); System.arraycopy(A, 0, tmp, length, length); int i=rotation; while(i<rotation+length){ A[i-rotation]=tmp[i]; i++; } } public static void main(String[] args) { int arr[] = { 12, 10, 5, 6, 52, 36}; int n = arr.length; int position = 2; SplitAndAdd(arr, n, position); int i = 0; for(;i<n;++i) System.out.print(arr[i] + \" \"); } }", "src": "class\nGFG { \n\n\n\n\n\n\npublic\nstatic\nvoid\nSplitAndAdd(\nint\n[] A,\nint\nlength,\nint\nrotation){ \n\n\n\n\nint\n[] tmp = \nnew\nint\n[length*\n2\n]; \n\n\n\n\nSystem.arraycopy(A, \n0\n, tmp, \n0\n, length); \n\nSystem.arraycopy(A, \n0\n, tmp, length, length); \n\nfor\n(\nint\ni=rotation;i<rotation+length;i++) \n\nA[i-rotation]=tmp[i]; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n12\n, \n10\n, \n5\n, \n6\n, \n52\n, \n36\n}; \n\nint\nn = arr.length; \n\nint\nposition = \n2\n; \n\n\nSplitAndAdd(arr, n, position); \n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 428, "complexity": "3"}
{"forwhile": "public\\nclass\\nGFG { \\n\\n\\nstatic\\nfinal\\nint\\nMAX_CHAR = \\n26\\n; \\n\\n\\n\\n\\n\\n\\nstatic\\nString getKey(String str) \\n\\n{ \\n\\nboolean\\n[] visited = \\nnew\\nboolean\\n[MAX_CHAR]; \\n\\nArrays.fill(visited, \\nfalse\\n); \\n\\n\\n\\n\\nint\\nj = \\n0\\n; \\nwhile(j < str.length()) \\n\\n{ \\n\\nvisited[str.charAt(j) - \\n'a'\\n] = \\ntrue\\n; \\n\\nj++; \\n} \\n\\nString key = \\n\"\"\\n; \\n\\nint\\nj=\\n0\\n; \\nwhile (j < MAX_CHAR) \\n\\n{ \\n\\nif\\n(visited[j]) \\n\\nkey = key + (\\nchar\\n)(\\n'a'\\n+j); \\n\\nj++; \\n} \\n\\nreturn\\nkey; \\n\\n} \\n\\n\\n\\nstatic\\nvoid\\nwordsWithSameCharSet(String words[], \\nint\\nn) \\n\\n{ \\n\\n\\n\\n\\n\\nHashMap<String, ArrayList<Integer>> Hash = \\nnew\\nHashMap<>(); \\n\\n\\nfor\\n(; n>0; n--) \\n\\n{ \\n\\nString key = getKey(words[n-1]); \\n\\n\\n\\n\\n\\nif\\n(Hash.containsKey(key)) \\n\\n{ \\n\\nArrayList<Integer> get_al = Hash.get(key); \\n$get_al.add(n-1); \\n\\nHash.put(key, get_al); \\n} \\n\\n\\n\\n\\n\\nelse\\n\\n{ \\n\\nArrayList<Integer> new_al = \\nnew\\nArrayList<>(); \\nnew_al.add(n-1); \\nHash.put(key, new_al); \\n} \\n\\n} \\n\\n\\nfor\\n(Entry<String, ArrayList<Integer>> it : Hash.entrySet()) \\n\\n{ \\n\\nArrayList<Integer> get =it.getValue(); \\n\\nfor\\n(Integer v:get) \\n\\nSystem.out.print( words[v] + \\n\", \"\\n); \\n\\nSystem.out.println(); \\n} \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String args[]) \\n\\n{ \\n\\nString words[] = { \\n\"may\"\\n, \\n\"student\"\\n, \\n\"students\"\\n, \\n\"dog\"\\n, \\n\\n\"studentssess\"\\n, \\n\"god\"\\n, \\n\"cat\"\\n, \\n\"act\"\\n, \\n\"tab\"\\n, \\n\\n\"bat\"\\n, \\n\"flow\"\\n, \\n\"wolf\"\\n, \\n\"lambs\"\\n, \\n\"amy\"\\n, \\n\"yam\"\\n, \\n\\n\"balms\"\\n, \\n\"looped\"\\n, \\n\"poodle\"\\n}; \\n\\nint\\nn = words.length; \\n\\nwordsWithSameCharSet(words, n); \\n\\n} \\n}", "src": "public\nclass\nGFG { \n\n\nstatic\nfinal\nint\nMAX_CHAR = \n26\n; \n\n\n\n\n\n\n\n\nstatic\nString getKey(String str) \n\n{ \n\nboolean\n[] visited = \nnew\nboolean\n[MAX_CHAR]; \n\nArrays.fill(visited, \nfalse\n); \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < str.length(); j++) \n\nvisited[str.charAt(j) - \n'a'\n] = \ntrue\n; \n\nString key = \n\"\"\n; \n\nfor\n(\nint\nj=\n0\n; j < MAX_CHAR; j++) \n\nif\n(visited[j]) \n\nkey = key + (\nchar\n)(\n'a'\n+j); \n\nreturn\nkey; \n\n} \n\n\n\n\nstatic\nvoid\nwordsWithSameCharSet(String words[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nHashMap<String, ArrayList<Integer>> Hash = \nnew\nHashMap<>(); \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\nString key = getKey(words[i]); \n\n\n\n\n\n\n\n\nif\n(Hash.containsKey(key)) \n\n{ \n\nArrayList<Integer> get_al = Hash.get(key); \n\nget_al.add(i); \n\nHash.put(key, get_al); \n\n} \n\n\n\n\n\n\n\n\nelse\n\n{ \n\nArrayList<Integer> new_al = \nnew\nArrayList<>(); \n\nnew_al.add(i); \n\nHash.put(key, new_al); \n\n} \n\n} \n\n\n\n\nfor\n(Entry<String, ArrayList<Integer>> it : Hash.entrySet()) \n\n{ \n\nArrayList<Integer> get =it.getValue(); \n\nfor\n(Integer v:get) \n\nSystem.out.print( words[v] + \n\", \"\n); \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString words[] = { \n\"may\"\n, \n\"student\"\n, \n\"students\"\n, \n\"dog\"\n, \n\n\"studentssess\"\n, \n\"god\"\n, \n\"cat\"\n, \n\"act\"\n, \n\"tab\"\n, \n\n\"bat\"\n, \n\"flow\"\n, \n\"wolf\"\n, \n\"lambs\"\n, \n\"amy\"\n, \n\"yam\"\n, \n\n\"balms\"\n, \n\"looped\"\n, \n\"poodle\"\n}; \n\nint\nn = words.length; \n\nwordsWithSameCharSet(words, n); \n\n} \n}", "index": 429, "complexity": "3"}
{"forwhile": "class CountSubString { int countSubStr(char str[], int n) { int res = 0; int i = 0; while(i < n) { if(str[i] == '1') { int j = i + 1; while(j < n) { if(str[j] == '1') res++; j++; } } i++; } return res; } public static void main(String[] args) { CountSubString count = new CountSubString(); String string = \"00100101\"; char str[] = string.toCharArray(); int n = str.length; System.out.println(count.countSubStr(str,n)); } }", "src": "class\nCountSubString \n{ \n\nint\ncountSubStr(\nchar\nstr[],\nint\nn) \n\n{ \n\nint\nres = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i<n; i++) \n\n{ \n\nif\n(str[i] == \n'1'\n) \n\n{ \n\n\n\nfor\n(\nint\nj = i + \n1\n; j< n; j++) \n\n{ \n\nif\n(str[j] == \n'1'\n) \n\nres++; \n\n} \n\n} \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nCountSubString count = \nnew\nCountSubString(); \n\nString string = \n\"00100101\"\n; \n\nchar\nstr[] = string.toCharArray(); \n\nint\nn = str.length; \n\nSystem.out.println(count.countSubStr(str,n)); \n\n} \n}", "index": 430, "complexity": "3"}
{"forwhile": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n\n\n\n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n\n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n\nint\ni = \n0\n; \n\nwhile(i < n) { \n\n\n\n\nint\nj = \n0\n; \n\nwhile(j < m) { \n\n\n\n\n\n\n\n\nif\n(patt.charAt(i)== str.charAt(j) && j < minIndex) { \n\nminIndex = j; \n\nbreak\n; \n\n} \n\nj++; \n\n} \n\ni++; \n\n} \n\n\n\n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n\n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n}", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMinIndexChar(String str, String patt) \n\n{ \n\n\n\n\n\nint\nminIndex = Integer.MAX_VALUE; \n\n\n\n\nint\nm = str.length(); \n\nint\nn = patt.length(); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) { \n\n\n\n\n\n\n\n\nif\n(patt.charAt(i)== str.charAt(j) && j < minIndex) { \n\nminIndex = j; \n\nbreak\n; \n\n} \n\n} \n\n} \n\n\n\n\nif\n(minIndex != Integer.MAX_VALUE) \n\nSystem.out.println(\n\"Minimum Index Character = \"\n+ \n\nstr.charAt(minIndex)); \n\n\n\n\nelse\n\nSystem.out.println(\n\"No character present\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nString patt = \n\"set\"\n; \n\nprintMinIndexChar(str, patt); \n\n} \n}", "index": 431, "complexity": "3"}
{"forwhile": "class Test { static int countPairs(String str) { int result = 0; int n = str.length(); int i = 0; while (i < n) { int j = i + 1; while (j < n) { if (Math.abs(str.charAt(i) - str.charAt(j)) == Math.abs(i - j)) result++; j++; } i++; } return result; } public static void main(String args[]) { String str = \"geeksforgeeks\"; System.out.println(countPairs(str)); } }", "src": "class\nTest { \n\n\n\n\nstatic\nint\ncountPairs(String str) \n\n{ \n\nint\nresult = \n0\n; \n\nint\nn = str.length(); \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\n\n\n\n\n\nif\n(Math.abs(str.charAt(i) - str.charAt(j)) == \n\nMath.abs(i - j)) \n\nresult++; \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(countPairs(str)); \n\n} \n}", "index": 432, "complexity": "3"}
{"forwhile": "class GFG { static int findSubsequenceCount(String S, String T) { int m = T.length(); int n = S.length(); if (m > n) return 0; int mat[][] = new int[m + 1][n + 1]; int i = 1; while (i <= m) { mat[i][0] = 0; i++; } int j = 0; while (j <= n) { mat[0][j] = 1; j++; } i = 1; while (i <= m) { j = 1; while (j <= n) { if (T.charAt(i - 1) != S.charAt(j - 1)) mat[i][j] = mat[i][j - 1]; else mat[i][j] = mat[i][j - 1] + mat[i - 1][j - 1]; j++; } i++; } return mat[m][n]; } public static void main(String[] args) { String T = \"ge\"; String S = \"geeksforgeeks\"; System.out.println(findSubsequenceCount(S, T)); } }", "src": "class\nGFG { \n\nstatic\nint\nfindSubsequenceCount(String S, String T) \n\n{ \n\nint\nm = T.length(); \n\nint\nn = S.length(); \n\n\n\n\nif\n(m > n) \n\nreturn\n0\n; \n\n\n\n\n\n\nint\nmat[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= m; i++) \n\nmat[i][\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\nmat[\n0\n][j] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= m; i++) { \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) { \n\n\n\n\n\n\n\nif\n(T.charAt(i - \n1\n) != S.charAt(j - \n1\n)) \n\nmat[i][j] = mat[i][j - \n1\n]; \n\n\n\n\n\n\n\n\n\n\nelse\n\nmat[i][j] = mat[i][j - \n1\n] + mat[i - \n1\n][j - \n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\nmat[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString T = \n\"ge\"\n; \n\nString S = \n\"geeksforgeeks\"\n; \n\nSystem.out.println(findSubsequenceCount(S, T)); \n\n} \n}", "index": 433, "complexity": "3"}
{"forwhile": "class GFG  { static int bellNumber(int n) { int[][] bell = new int[n+1][n+1]; bell[0][0] = 1; int i=1; while(i<=n) { bell[i][0] = bell[i-1][i-1]; int j=1; while(j<=i) bell[i][j] = bell[i-1][j-1] + bell[i][j-1]; i++; } return bell[n][0]; } public static void main (String[] args) { int n=0; for(; n<=5; n++) System.out.println(", "Bell Number ": null, " is ": " +bellNumber(n)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nbellNumber(\nint\nn) \n\n{ \n\nint\n[][] bell = \nnew\nint\n[n+\n1\n][n+\n1\n]; \n\nbell[\n0\n][\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni=\n1\n; i<=n; i++) \n\n{ \n\n\n\nbell[i][\n0\n] = bell[i-\n1\n][i-\n1\n]; \n\n\n\n\nfor\n(\nint\nj=\n1\n; j<=i; j++) \n\nbell[i][j] = bell[i-\n1\n][j-\n1\n] + bell[i][j-\n1\n]; \n\n} \n\n\nreturn\nbell[n][\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nfor\n(\nint\nn=\n0\n; n<=\n5\n; n++) \n\nSystem.out.println(\n\"Bell Number \"\n+ n + \n\n\" is \"\n+bellNumber(n)); \n\n} \n}", "index": 434, "complexity": "3"}
{"forwhile": "class GFG{ static int catalanDP(int n) { int catalan[] = new int[n + 2]; catalan[0] = 1; catalan[1] = 1; int i = 2; while(i <= n) { catalan[i] = 0; int j = 0; while(j < i) { catalan[i] += catalan[j] * catalan[i - j - 1]; j++; } i++; } return catalan[n]; } public static void main(String[] args) { int i = 0; for(; i < 10; i++) { System.out.print(catalanDP(i) + \" \"); } }}", "src": "class\nGFG{ \n\n\n\n\nstatic\nint\ncatalanDP(\nint\nn) { \n\n\n\nint\ncatalan[] = \nnew\nint\n[n + \n2\n]; \n\n\n\n\ncatalan[\n0\n] = \n1\n; \n\ncatalan[\n1\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n2\n; i <= n; i++) { \n\ncatalan[i] = \n0\n; \n\nfor\n(\nint\nj = \n0\n; j < i; j++) { \n\ncatalan[i] += catalan[j] * catalan[i - j - \n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\ncatalan[n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nfor\n(\nint\ni = \n0\n; i < \n10\n; i++) { \n\nSystem.out.print(catalanDP(i) + \n\" \"\n); \n\n} \n\n} \n}", "index": 435, "complexity": "3"}
{"forwhile": "class BinomialCoefficient { static int binomialCoeff(int n, int k) { int C[][] = new int[n+1][k+1]; int i = 0; while(i <= n) { int j = 0; while(j <= min(i, k)) { if(j == 0 || j == i) C[i][j] = 1; else C[i][j] = C[i-1][j-1] + C[i-1][j]; j++; } i++; } return C[n][k]; } static int min(int a, int b) { return (a<b)? a: b; } public static void main(String args[]) { int n = 5, k = 2; System.out.println(\"Value of C(\" + n + \",\" + k + \") is \" + binomialCoeff(n, k)); } }", "src": "class\nBinomialCoefficient \n{ \n\n\n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[][] = \nnew\nint\n[n+\n1\n][k+\n1\n]; \n\nint\ni, j; \n\n\n\n\nfor\n(i = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(j = \n0\n; j <= min(i, k); j++) \n\n{ \n\n\n\nif\n(j == \n0\n|| j == i) \n\nC[i][j] = \n1\n; \n\n\n\n\nelse\n\nC[i][j] = C[i-\n1\n][j-\n1\n] + C[i-\n1\n][j]; \n\n} \n\n} \n\n\nreturn\nC[n][k]; \n\n} \n\n\n\n\nstatic\nint\nmin(\nint\na, \nint\nb) \n\n{ \n\nreturn\n(a<b)? a: b; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of C(\"\n+n+\n\",\"\n+k+\n\") is \"\n+binomialCoeff(n, k)); \n\n} \n}", "index": 436, "complexity": "3"}
{"forwhile": "class GFG { static int permutationCoeff(int n, int k) { int P[][] = new int[n + 2][k + 2]; int i = 0; while (i <= n) { int j = 0; while (j <= Math.min(i, k)) { if (j == 0) P[i][j] = 1; else P[i][j] = P[i - 1][j] + (j * P[i - 1][j - 1]); P[i][j + 1] = 0; j++; } i++; } return P[n][k]; } public static void main(String args[]) { int n = 10, k = 2; System.out.println(\"Value of P( \" + n + \",\" + k + \")\" + \" is \" + permutationCoeff(n, k)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nint\npermutationCoeff(\nint\nn, \n\nint\nk) \n\n{ \n\nint\nP[][] = \nnew\nint\n[n + \n2\n][k + \n2\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; \n\nj <= Math.min(i, k); \n\nj++) \n\n{ \n\n\n\nif\n(j == \n0\n) \n\nP[i][j] = \n1\n; \n\n\n\n\n\n\nelse\n\nP[i][j] = P[i - \n1\n][j] + \n\n(j * P[i - \n1\n][j - \n1\n]); \n\n\n\n\n\n\nP[i][j + \n1\n] = \n0\n; \n\n} \n\n} \n\nreturn\nP[n][k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nn = \n10\n, k = \n2\n; \n\nSystem.out.println(\n\"Value of P( \"\n+ n + \n\",\"\n+ k +\n\")\"\n+ \n\n\" is \"\n+ permutationCoeff(n, k) ); \n\n} \n}", "index": 437, "complexity": "3"}
{"forwhile": "class GFG { static final int MAX = 100; static int getMaxGold(int gold[][], int m, int n) { int goldTable[][] = new int[m][n]; int r = 0; while(r < m) { for(int i = 0; i < n; i++) { goldTable[r][i] = 0; } r++; } int col = n-1; while(col >= 0) { int row = 0; while(row < m) { int right = (col == n-1) ? 0 : goldTable[row][col+1]; int right_up = (row == 0 || col == n-1) ? 0 : goldTable[row-1][col+1]; int right_down = (row == m-1 || col == n-1) ? 0 : goldTable[row+1][col+1]; goldTable[row][col] = gold[row][col] + Math.max(right, Math.max(right_up, right_down)); row++; } col--; } int res = goldTable[0][0]; for(int i = 1; i < m; i++) { res = Math.max(res, goldTable[i][0]); } return res; } public static void main(String arg[]) { int gold[][]= { { 1, 3, 1, 5}, {2, 2, 4, 1}, {5, 0, 2, 3}, {0, 6, 1, 2} }; int m = 4, n = 4; System.out.print(getMaxGold(gold, m, n)); } }", "src": "class\nGFG { \n\n\nstatic\nfinal\nint\nMAX = \n100\n; \n\n\n\n\n\n\n\n\n\n\nstatic\nint\ngetMaxGold(\nint\ngold[][], \n\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\ngoldTable[][] = \nnew\nint\n[m][n]; \n\n\nfor\n(\nint\n[] rows:goldTable) \n\nArrays.fill(rows, \n0\n); \n\n\nfor\n(\nint\ncol = n-\n1\n; col >= \n0\n; col--) \n\n{ \n\nfor\n(\nint\nrow = \n0\n; row < m; row++) \n\n{ \n\n\n\n\n\n\nint\nright = (col == n-\n1\n) ? \n0\n\n: goldTable[row][col+\n1\n]; \n\n\n\n\n\n\nint\nright_up = (row == \n0\n|| \n\ncol == n-\n1\n) ? \n0\n: \n\ngoldTable[row-\n1\n][col+\n1\n]; \n\n\n\n\n\n\nint\nright_down = (row == m-\n1\n\n|| col == n-\n1\n) ? \n0\n: \n\ngoldTable[row+\n1\n][col+\n1\n]; \n\n\n\n\n\n\ngoldTable[row][col] = gold[row][col] \n\n+ Math.max(right, Math.max(right_up, \n\nright_down)); \n\n; \n\n} \n\n} \n\n\n\n\n\n\nint\nres = goldTable[\n0\n][\n0\n]; \n\n\nfor\n(\nint\ni = \n1\n; i < m; i++) \n\nres = Math.max(res, goldTable[i][\n0\n]); \n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ngold[][]= { {\n1\n, \n3\n, \n1\n, \n5\n}, \n\n{\n2\n, \n2\n, \n4\n, \n1\n}, \n\n{\n5\n, \n0\n, \n2\n, \n3\n}, \n\n{\n0\n, \n6\n, \n1\n, \n2\n} }; \n\n\nint\nm = \n4\n, n = \n4\n; \n\n\nSystem.out.print(getMaxGold(gold, m, n)); \n\n} \n}", "index": 438, "complexity": "3"}
{"forwhile": "class GFG { static void printArray(int A[], int size) { int i = 0; while(i < size) System.out.print(A[i++] + \" \"); System.out.println(); } static void merge(int arr[], int l, int m, int r) { int i, j, k; int n1 = m - l + 1; int n2 = r - m; int L[] = new int[n1]; int R[] = new int[n2]; i = 0; while(i < n1) L[i] = arr[l + i++]; j = 0; while(j < n2) R[j] = arr[m + 1 + j++]; i = 0; j = 0; k = l; for(; i < n1 && L[i] < 0; ) arr[k++] = L[i++]; for(; j < n2 && R[j] < 0; ) arr[k++] = R[j++]; for(; i < n1; ) arr[k++] = L[i++]; for(; j < n2; ) arr[k++] = R[j++]; } static void RearrangePosNeg(int arr[], int l, int r) { if(l < r) { int m = l + (r - l) / 2; RearrangePosNeg(arr, l, m); RearrangePosNeg(arr, m + 1, r); merge(arr, l, m, r); } } public static void main(String[] args) { int arr[] = { -12, 11, -13, -5, 6, -7, 5, -3, -6 }; int arr_size = arr.length; RearrangePosNeg(arr, 0, arr_size - 1); printArray(arr, arr_size); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nprintArray(\nint\nA[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(A[i] + \n\" \"\n); \n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nmerge(\nint\narr[], \nint\nl, \nint\nm, \nint\nr) \n\n{ \n\nint\ni, j, k; \n\nint\nn1 = m - l + \n1\n; \n\nint\nn2 = r - m; \n\n\n\n\nint\nL[] = \nnew\nint\n[n1]; \n\nint\nR[] = \nnew\nint\n[n2]; \n\n\n\n\nfor\n(i = \n0\n; i < n1; i++) \n\nL[i] = arr[l + i]; \n\nfor\n(j = \n0\n; j < n2; j++) \n\nR[j] = arr[m + \n1\n+ j]; \n\n\n\n\n\n\ni = \n0\n; \n\n\n\n\nj = \n0\n; \n\n\n\n\nk = l; \n\n\n\n\n\n\n\n\n\n\n\nwhile\n(i < n1 && L[i] < \n0\n) \n\narr[k++] = L[i++]; \n\n\n\n\nwhile\n(j < n2 && R[j] < \n0\n) \n\narr[k++] = R[j++]; \n\n\n\n\nwhile\n(i < n1) \n\narr[k++] = L[i++]; \n\n\n\n\nwhile\n(j < n2) \n\narr[k++] = R[j++]; \n\n} \n\n\n\n\n\n\nstatic\nvoid\nRearrangePosNeg(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\n\n\n\n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nRearrangePosNeg(arr, l, m); \n\nRearrangePosNeg(arr, m + \n1\n, r); \n\n\nmerge(arr, l, m, r); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { -\n12\n, \n11\n, -\n13\n, -\n5\n, \n6\n, -\n7\n, \n5\n, -\n3\n, -\n6\n}; \n\nint\narr_size = arr.length; \n\nRearrangePosNeg(arr, \n0\n, arr_size - \n1\n); \n\nprintArray(arr, arr_size); \n\n} \n}", "index": 439, "complexity": "3"}
{"forwhile": "class GFG { static boolean isSubsetSum(int set[], int n, int sum) { boolean subset[][] = new boolean[sum+1][n+1]; int i = 0; while(i <= n) { subset[0][i] = true; i++; } i = 1; while(i <= sum) { subset[i][0] = false; i++; } i = 1; while(i <= sum) { int j = 1; while(j <= n) { subset[i][j] = subset[i][j-1]; if(i >= set[j-1]) subset[i][j] = subset[i][j] || subset[i - set[j-1]][j-1]; j++; } i++; } return subset[sum][n]; } public static void main (String args[]) { int set[] = {3, 34, 4, 12, 5, 2}; int sum = 9; int n = set.length; if(isSubsetSum(set, n, sum) == true) System.out.println(\"Found a subset\" + \" with given sum\"); else System.out.println(\"No subset with\" + \" given sum\"); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nisSubsetSum(\nint\nset[], \n\nint\nn, \nint\nsum) \n\n{ \n\n\n\n\n\n\n\nboolean\nsubset[][] = \n\nnew\nboolean\n[sum+\n1\n][n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nsubset[\n0\n][i] = \ntrue\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\nsubset[i][\n0\n] = \nfalse\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= sum; i++) \n\n{ \n\nfor\n(\nint\nj = \n1\n; j <= n; j++) \n\n{ \n\nsubset[i][j] = subset[i][j-\n1\n]; \n\nif\n(i >= set[j-\n1\n]) \n\nsubset[i][j] = subset[i][j] || \n\nsubset[i - set[j-\n1\n]][j-\n1\n]; \n\n} \n\n} \n\n\n\n\n\nreturn\nsubset[sum][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\nset[] = {\n3\n, \n34\n, \n4\n, \n12\n, \n5\n, \n2\n}; \n\nint\nsum = \n9\n; \n\nint\nn = set.length; \n\nif\n(isSubsetSum(set, n, sum) == \ntrue\n) \n\nSystem.out.println(\n\"Found a subset\"\n\n+ \n\" with given sum\"\n); \n\nelse\n\nSystem.out.println(\n\"No subset with\"\n\n+ \n\" given sum\"\n); \n\n} \n}", "index": 440, "complexity": "3"}
{"forwhile": "class GFG { static boolean modularSum(int arr[], int n, int m) { if (n > m) return true; boolean DP[]=new boolean[m]; Arrays.fill(DP, false); int i = 0; while(i < n) { if (DP[0]) return true; boolean temp[] = new boolean[m]; Arrays.fill(temp, false); int j = 0; while(j < m) { if (DP[j] == true) { if(DP[(j + arr[i]) % m] == false) temp[(j + arr[i]) % m] = true; } j++; } j = 0; while(j < m) { if(temp[j]) DP[j] = true; j++; } DP[arr[i] % m] = true; i++; } return DP[0]; } public static void main(String arg[]) { int arr[] = {1, 7}; int n = arr.length; int m = 5; if(modularSum(arr, n, m)) System.out.print(\"YES\\n\"); else System.out.print(\"NO\\n\"); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nboolean\nmodularSum(\nint\narr[], \n\nint\nn, \nint\nm) \n\n{ \n\nif\n(n > m) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\nboolean\nDP[]=\nnew\nboolean\n[m]; \n\n\nArrays.fill(DP, \nfalse\n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\nif\n(DP[\n0\n]) \n\nreturn\ntrue\n; \n\n\n\n\n\n\n\n\n\n\n\n\nboolean\ntemp[] = \nnew\nboolean\n[m]; \n\nArrays.fill(temp, \nfalse\n); \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) \n\n{ \n\n\n\n\n\n\nif\n(DP[j] == \ntrue\n) \n\n{ \n\nif\n(DP[(j + arr[i]) % m] == \nfalse\n) \n\n\n\n\n\n\ntemp[(j + arr[i]) % m] = \ntrue\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < m; j++) \n\nif\n(temp[j]) \n\nDP[j] = \ntrue\n; \n\n\n\n\n\n\n\n\n\nDP[arr[i] % m] = \ntrue\n; \n\n} \n\n\nreturn\nDP[\n0\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = {\n1\n, \n7\n}; \n\nint\nn = arr.length; \n\nint\nm = \n5\n; \n\n\nif\n(modularSum(arr, n, m)) \n\nSystem.out.print(\n\"YES\\n\"\n); \n\nelse\n\nSystem.out.print(\n\"NO\\n\"\n); \n\n} \n}", "index": 441, "complexity": "3"}
{"forwhile": "class GFG { static int largestSubset(int[] a, int n) { Arrays.sort(a); int[] dp = new int[n]; dp[n - 1] = 1; int i = n - 2; while(i >= 0) { int mxm = 0; int j = i + 1; while(j < n) { if(a[j] % a[i] == 0) { mxm = Math.max(mxm, dp[j]); } j++; } dp[i] = 1 + mxm; i--; } return Arrays.stream(dp).max().getAsInt(); } public static void main(String[] args) { int[] a = { 1, 3, 6, 13, 17, 18 }; int n = a.length; System.out.println(largestSubset(a, n)); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nlargestSubset(\nint\n[] a, \nint\nn) \n\n{ \n\n\n\nArrays.sort(a); \n\n\n\n\n\n\nint\n[] dp = \nnew\nint\n[n]; \n\n\n\n\ndp[n - \n1\n] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) { \n\n\n\n\n\n\n\n\nint\nmxm = \n0\n; \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) { \n\nif\n(a[j] % a[i] == \n0\n) { \n\nmxm = Math.max(mxm, dp[j]); \n\n} \n\n} \n\n\ndp[i] = \n1\n+ mxm; \n\n} \n\n\n\n\nreturn\nArrays.stream(dp).max().getAsInt(); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\n[] a = { \n1\n, \n3\n, \n6\n, \n13\n, \n17\n, \n18\n}; \n\nint\nn = a.length; \n\nSystem.out.println(largestSubset(a, n)); \n\n} \n}", "index": 442, "complexity": "3"}
{"forwhile": "class\nRodCutting \n{ \n\n\n\nstatic\nint\ncutRod(\nint\nprice[],\nint\nn) \n\n{ \n\nint\nval[] = \nnew\nint\n[n+\n1\n]; \n\nval[\n0\n] = \n0\n; \n\n\n\n\n\n\nint\ni = \n1\n; \nwhile(i<=n) \n\n{ \n\nint\nmax_val = Integer.MIN_VALUE; \n\nint\nj = \n0\n; \nfor(; j < i; j++) \n\nmax_val = Math.max(max_val, \n\nprice[j] + val[i-j-\n1\n]); \n\nval[i] = max_val; \n\ni++; \n\n} \n\n\nreturn\nval[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[] {\n1\n, \n5\n, \n8\n, \n9\n, \n10\n, \n17\n, \n17\n, \n20\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Maximum Obtainable Value is \"\n+ \n\ncutRod(arr, size)); \n\n} \n}", "src": "class\nRodCutting \n{ \n\n\n\nstatic\nint\ncutRod(\nint\nprice[],\nint\nn) \n\n{ \n\nint\nval[] = \nnew\nint\n[n+\n1\n]; \n\nval[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i<=n; i++) \n\n{ \n\nint\nmax_val = Integer.MIN_VALUE; \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nmax_val = Math.max(max_val, \n\nprice[j] + val[i-j-\n1\n]); \n\nval[i] = max_val; \n\n} \n\n\nreturn\nval[n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[] {\n1\n, \n5\n, \n8\n, \n9\n, \n10\n, \n17\n, \n17\n, \n20\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Maximum Obtainable Value is \"\n+ \n\ncutRod(arr, size)); \n\n} \n}", "index": 443, "complexity": "3"}
{"forwhile": "class GFG { static int lookup[][] = new int[1000][1000]; static int countSeqUtil(int n, int dif) { if(Math.abs(dif) > n) return 0; if(n == 1 && dif == 0) return 2; if(n == 1 && Math.abs(dif) == 1) return 1; if(lookup[n][n+dif] != -1) return lookup[n][n+dif]; int res = countSeqUtil(n-1, dif+1) + 2*countSeqUtil(n-1, dif) + countSeqUtil(n-1, dif-1); return lookup[n][n+dif] = res; } static int countSeq(int n) { int k = 0; while(k < lookup.length) { int j = 0; while(j < lookup.length) { lookup[k][j] = -1; j++; } k++; } return countSeqUtil(n, 0); } public static void main(String[] args) { int n = 2; System.out.println(\"Count of sequences is \" + countSeq(2)); } }", "src": "class\nGFG { \n\n\n\nstatic\nint\nlookup[][] = \nnew\nint\n[\n1000\n][\n1000\n]; \n\n\n\n\nstatic\nint\ncountSeqUtil(\nint\nn, \nint\ndif) \n{ \n\n\n\n\n\nif\n(Math.abs(dif) > n) \n\nreturn\n0\n; \n\n\n\n\nif\n(n == \n1\n&& dif == \n0\n) \n\nreturn\n2\n; \n\nif\n(n == \n1\n&& Math.abs(dif) == \n1\n) \n\nreturn\n1\n; \n\n\n\n\n\n\n\n\nif\n(lookup[n][n+dif] != -\n1\n) \n\nreturn\nlookup[n][n+dif]; \n\n\nint\nres = \n\n\ncountSeqUtil(n-\n1\n, dif+\n1\n) + \n\n\n\n\n2\n*countSeqUtil(n-\n1\n, dif) + \n\n\n\n\ncountSeqUtil(n-\n1\n, dif-\n1\n); \n\n\n\n\n\n\nreturn\nlookup[n][n+dif] = res; \n} \n\n\n\n\nstatic\nint\ncountSeq(\nint\nn) \n{ \n\n\n\n\n\n\n\nfor\n(\nint\nk = \n0\n; k < lookup.length; k++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < lookup.length; j++) \n\n{ \n\nlookup[k][j] = -\n1\n; \n\n} \n\n} \n\n\n\n\nreturn\ncountSeqUtil(n, \n0\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\nn = \n2\n; \n\nSystem.out.println(\n\"Count of sequences is \"\n\n+ countSeq(\n2\n)); \n} \n}", "index": 444, "complexity": "3"}
{"forwhile": "class Sequences  { static int getTotalNumberOfSequences(int m, int n)  { int T[][]=new int[m+1][n+1]; int i=0; while(i<m+1)  { int j=0; while(j<n+1)  { if(i == 0 || j == 0)  T[i][j] = 0; else if(i < j)  T[i][j] = 0; else if(j == 1)  T[i][j] = i; else T[i][j] = T[i-1][j] + T[i/2][j-1]; j++;  } i++;  } return T[m][n];  } public static void main (String[] args)  { int m = 10; int n = 4; System.out.println(\"Total number of possible sequences \"+ getTotalNumberOfSequences(m, n));  } }", "src": "class\nSequences \n{ \n\n\n\n\n\nstatic\nint\ngetTotalNumberOfSequences(\nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\nT[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\nfor\n(\nint\ni=\n0\n; i<m+\n1\n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<n+\n1\n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(i == \n0\n|| j == \n0\n) \n\nT[i][j] = \n0\n; \n\n\n\n\n\n\n\n\nelse\nif\n(i < j) \n\nT[i][j] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\nif\n(j == \n1\n) \n\nT[i][j] = i; \n\n\n\n\nelse\n\nT[i][j] = T[i-\n1\n][j] + T[i/\n2\n][j-\n1\n]; \n\n} \n\n} \n\nreturn\nT[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\nm = \n10\n; \n\nint\nn = \n4\n; \n\nSystem.out.println(\n\"Total number of possible sequences \"\n+ \n\ngetTotalNumberOfSequences(m, n)); \n\n} \n}", "index": 445, "complexity": "3"}
{"forwhile": "class GFG { static int MaxSumBS(int arr[], int n) { int max_sum = Integer.MIN_VALUE; int MSIBS[] = new int[n]; int MSDBS[] = new int[n]; int i = 0; while(i < n) { MSDBS[i] = arr[i]; MSIBS[i] = arr[i]; i++; } i = 1; while(i < n) { int j = 0; while(j < i) { if(arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) MSIBS[i] = MSIBS[j] + arr[i]; j++; } i++; } i = n - 2; while(i >= 0) { int j = n - 1; while(j > i) { if(arr[i] > arr[j] && MSDBS[i] < MSDBS[j] + arr[i]) MSDBS[i] = MSDBS[j] + arr[i]; j--; } i--; } i = 0; while(i < n) { max_sum = Math.max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i])); i++; } return max_sum; } public static void main(String[] args) { int arr[] = { 1, 15, 51, 45, 33, 100, 12, 18, 9 }; int n = arr.length; System.out.println(", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nMaxSumBS(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmax_sum = Integer.MIN_VALUE; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nMSIBS[] = \nnew\nint\n[n]; \n\nint\nMSDBS[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nMSDBS[i] = arr[i]; \n\nMSIBS[i] = arr[i]; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && MSIBS[i] < MSIBS[j] + arr[i]) \n\nMSIBS[i] = MSIBS[j] + arr[i]; \n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\nfor\n(\nint\nj = n - \n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && MSDBS[i] < MSDBS[j] + arr[i]) \n\nMSDBS[i] = MSDBS[j] + arr[i]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmax_sum = Math.max(max_sum, (MSDBS[i] + MSIBS[i] - arr[i])); \n\n\n\n\n\n\nreturn\nmax_sum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n15\n, \n51\n, \n45\n, \n33\n, \n100\n, \n12\n, \n18\n, \n9\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum Sum : \"\n+ MaxSumBS(arr, n)); \n\n} \n}", "index": 446, "complexity": "3"}
{"forwhile": "class GFG { static int maxSumIS( int arr[], int n) { int i, j, max = 0 ; int msis[] = new int[n]; i = 0; while(i < n) msis[i++] = arr[i]; i = 1; while(i < n) { j = 0; while(j < i) { if(arr[i] > arr[j] && msis[i] < msis[j] + arr[i]) msis[i] = msis[j] + arr[i]; j++; } i++; } i = 0; while(i < n) { if(max < msis[i]) max = msis[i]; i++; } return max; } public static void main(String args[]) { int arr[] = new int[]{ 1 , 101 , 2 , 3 , 100 , 4 , 5 }; int n = arr.length; System.out.println( \"Sum of maximum sum \" + \"increasing subsequence is \" + maxSumIS(arr, n)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n}", "index": 447, "complexity": "3"}
{"forwhile": "class GFG { static int lis(int[] arr, int n) { int[] mpis = new int[n];int max = Integer.MIN_VALUE; int i = 0; while(i < n) { mpis[i] = arr[i]; i++; } i = 1; while(i < n) { int j = 0; while(j < i) { if(arr[i] > arr[j] && mpis[i] < (mpis[j] * arr[i])) mpis[i] = mpis[j] * arr[i]; j++; } i++; } int k = 0; while(k < mpis.length) { if(mpis[k] > max) { max = mpis[k]; } k++; } return max; } static public void main(String[] args) { int[] arr = { 3, 100, 4, 5, 150, 6 }; int n = arr.length; System.out.println(lis(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlis(\nint\n[] arr, \nint\nn) \n\n{ \n\nint\n[] mpis = \nnew\nint\n[n]; \n\nint\nmax = Integer.MIN_VALUE; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmpis[i] = arr[i]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && mpis[i] \n\n< (mpis[j] * arr[i])) \n\nmpis[i] = mpis[j] * arr[i]; \n\n\n\n\nfor\n(\nint\nk = \n0\n; k < mpis.length; k++) \n\n{ \n\nif\n(mpis[k] > max) { \n\nmax = mpis[k]; \n\n} \n\n} \n\n\nreturn\nmax; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] arr = { \n3\n, \n100\n, \n4\n, \n5\n, \n150\n, \n6\n}; \n\nint\nn = arr.length; \n\n\nSystem.out.println(lis(arr, n)); \n\n} \n}", "index": 448, "complexity": "3"}
{"forwhile": "class GFG { static int longestSubseqWithDiffOne(int arr[], int n) { int dp[] = new int[n]; int i = 0; while(i<n) { dp[i] = 1; i++; } i = 1; while(i < n) { int j = 0; while(j < i) { if((arr[i] == arr[j] + 1) || (arr[i] == arr[j] - 1)) dp[i] = Math.max(dp[i], dp[j]+1); j++; } i++; } int result = 1; i = 0; while(i < n) { if(result < dp[i]) result = dp[i]; i++; } return result; } public static void main(String[] args) { int arr[] = {1, 2, 3, 4, 5, 3, 2}; int n = arr.length; System.out.println(longestSubseqWithDiffOne(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlongestSubseqWithDiffOne(\nint\narr[], \n\nint\nn) \n\n{ \n\n\n\n\n\nint\ndp[] = \nnew\nint\n[n]; \n\nfor\n(\nint\ni = \n0\n; i< n; i++) \n\ndp[i] = \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n\n\n\n\n\n\nif\n((arr[i] == arr[j] + \n1\n) || \n\n(arr[i] == arr[j] - \n1\n)) \n\n\ndp[i] = Math.max(dp[i], dp[j]+\n1\n); \n\n} \n\n} \n\n\n\n\n\n\nint\nresult = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n ; i++) \n\nif\n(result < dp[i]) \n\nresult = dp[i]; \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\n\n\n\nint\narr[] = {\n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n3\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(longestSubseqWithDiffOne( \n\narr, n)); \n\n} \n}", "index": 449, "complexity": "3"}
{"forwhile": "class GFG { public static int maxLenSub(int arr[], int n) { int mls[] = new int[n], max = 0; int i = 0; while(i < n) { mls[i] = 1; i++; } i = 1; while(i < n) { int j = 0; while(j < i) { if(Math.abs(arr[i] - arr[j]) <= 1 && mls[i] < mls[j] + 1) mls[i] = mls[j] + 1; j++; } i++; } i = 0; while(i < n) { if(max < mls[i]) max = mls[i]; i++; } return max; } public static void main(String[] args) { int arr[] = { 2, 5, 6, 3, 7, 6, 5, 8 }; int n = arr.length; System.out.println(\"Maximum length subsequence = \" + maxLenSub(arr, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\npublic\nstatic\nint\nmaxLenSub(\nint\narr[], \nint\nn) \n\n{ \n\nint\nmls[] = \nnew\nint\n[n], max = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nmls[i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\nif\n(Math.abs(arr[i] - arr[j]) <= \n1\n\n&& mls[i] < mls[j] + \n1\n) \n\nmls[i] = mls[j] + \n1\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(max < mls[i]) \n\nmax = mls[i]; \n\n\n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n2\n, \n5\n, \n6\n, \n3\n, \n7\n, \n6\n, \n5\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Maximum length subsequence = \"\n+ \n\nmaxLenSub(arr, n)); \n\n\n} \n}", "index": 450, "complexity": "3"}
{"forwhile": "class GFG { static int pre_compute(int a[], int n, int index, int k) { int dp[][] = new int[n][n]; int i = 0; while(i < n) { if(a[i] > a[0]) dp[0][i] = a[i] + a[0]; else dp[0][i] = a[i]; i++; } i = 1; while(i < n) { int j = 0; while(j < n) { if(a[j] > a[i] && j > i) { if(dp[i - 1][i] + a[j] > dp[i - 1][j]) dp[i][j] = dp[i - 1][i] + a[j]; else dp[i][j] = dp[i - 1][j]; } else dp[i][j] = dp[i - 1][j]; j++; } i++; } return dp[index][k]; } public static void main(String[] args) { int a[] = { 1, 101, 2, 3, 100, 4, 5 }; int n = a.length; int index = 4, k = 6; System.out.println( pre_compute(a, n, index, k)); } }", "src": "class\nGFG { \n\n\nstatic\nint\npre_compute(\nint\na[], \nint\nn, \n\nint\nindex, \nint\nk) \n\n{ \n\nint\ndp[][] = \nnew\nint\n[n][n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\nif\n(a[i] > a[\n0\n]) \n\ndp[\n0\n][i] = a[i] + a[\n0\n]; \n\nelse\n\ndp[\n0\n][i] = a[i]; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nif\n(a[j] > a[i] && j > i) \n\n{ \n\nif\n(dp[i - \n1\n][i] + a[j] > \n\ndp[i - \n1\n][j]) \n\ndp[i][j] = dp[i - \n1\n][i] \n\n+ a[j]; \n\nelse\n\ndp[i][j] = dp[i - \n1\n][j]; \n\n} \n\nelse\n\ndp[i][j] = dp[i - \n1\n][j]; \n\n} \n\n} \n\n\n\n\nreturn\ndp[index][k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\na[] = { \n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = a.length; \n\nint\nindex = \n4\n, k = \n6\n; \n\nSystem.out.println( \n\npre_compute(a, n, index, k)); \n\n} \n}", "index": 451, "complexity": "3"}
{"forwhile": "class Pair{ int a; int b; public Pair(int a, int b) { this.a = a; this.b = b; } static int maxChainLength(Pair arr[], int n) { int i, j, max = 0; int mcl[] = new int[n]; i = 0; while(i < n) mcl[i++] = 1; i = 1; while(i < n) { j = 0; while(j < i) { if( arr[i].a > arr[j].b && mcl[i] < mcl[j] + 1) mcl[i] = mcl[j] + 1; j++; } i++; } i = 0; while(i < n) { if( max < mcl[i] ) max = mcl[i]; i++; } return max; } public static void main(String[] args) { Pair arr[] = new Pair[] {new Pair(5 , 24), new Pair(15, 25), new Pair (27, 40), new Pair(50, 60)}; System.out.println(\"Length of maximum size chain is \"+ maxChainLength(arr, arr.length)); } }", "src": "class\nPair{ \n\nint\na; \n\nint\nb; \n\n\npublic\nPair(\nint\na, \nint\nb) { \n\nthis\n.a = a; \n\nthis\n.b = b; \n\n} \n\n\n\n\n\n\nstatic\nint\nmaxChainLength(Pair arr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmcl[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nmcl[i] = \n1\n; \n\n\n\n\nfor\n( i = \n1\n; i < n; i++ ) \n\nfor\n( j = \n0\n; j < i; j++ ) \n\nif\n( arr[i].a > arr[j].b && mcl[i] < mcl[j] + \n1\n) \n\nmcl[i] = mcl[j] + \n1\n; \n\n\n\n\n\n\n\nfor\n( i = \n0\n; i < n; i++ ) \n\nif\n( max < mcl[i] ) \n\nmax = mcl[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nPair arr[] = \nnew\nPair[] {\nnew\nPair(\n5\n,\n24\n), \nnew\nPair(\n15\n, \n25\n), \n\nnew\nPair (\n27\n, \n40\n), \nnew\nPair(\n50\n, \n60\n)}; \n\nSystem.out.println(\n\"Length of maximum size chain is \"\n+ \n\nmaxChainLength(arr, arr.length)); \n\n} \n}", "index": 452, "complexity": "3"}
{"forwhile": "public\\nclass\\nGFG \\n{ \\n\\nstatic\\nvoid\\nprintMaxSubSquare(\\nint\\nM[][]) \\n\\n{ \\n\\nint\\ni, j; \\n\\nint\\nR = M.length; \\n\\nint\\nC = M[\\n0\\n].length; \\n\\n\\nint\\nS[][] = \\nnew\\nint\\n[R][C]; \\n\\n\\nint\\nmax_of_s, max_i, max_j; \\n\\n\\n\\ni = \\n0\\n; \\n\\nwhile(i < R) \\n{ \\nS[i][\\n0\\n] = M[i][\\n0\\n]; \\ni++; \\n} \\n\\n\\nj = \\n0\\n; \\nwhile(j < C) \\n{ \\nS[\\n0\\n][j] = M[\\n0\\n][j]; \\nj++; \\n} \\n\\n\\ni = \\n1\\n; \\nwhile(i < R) \\n{ \\n\\nj = \\n1\\n; \\nwhile(j < C) \\n{ \\n\\nif\\n(M[i][j] == \\n1\\n) \\nS[i][j] = Math.min(S[i][j-\\n1\\n], \\nMath.min(S[i-\\n1\\n][j], S[i-\\n1\\n][j-\\n1\\n])) + \\n1\\n; \\nelse\\nS[i][j] = \\n0\\n; \\n\\nj++; \\n} \\ni++; \\n} \\n\\n\\nmax_of_s = S[\\n0\\n][\\n0\\n]; max_i = \\n0\\n; max_j = \\n0\\n; \\n\\ni = \\n0\\n; \\nwhile(i < R) \\n{ \\n\\nj = \\n0\\n; \\nwhile(j < C) \\n{ \\n\\nif\\n(max_of_s < S[i][j]) \\n{ \\nmax_of_s = S[i][j]; \\nmax_i = i; \\nmax_j = j; \\n} \\nj++; \\n} \\ni++; \\n} \\n\\n\\nSystem.out.println(\\n\"Maximum size sub-matrix is: \"\\n); \\n\\ni = max_i; \\nwhile(i > max_i - max_of_s) \\n{ \\n\\nj = max_j; \\nwhile(j > max_j - max_of_s) \\n{ \\n\\nSystem.out.print(M[i][j] + \\n\" \"\\n); \\nj--; \\n} \\nSystem.out.println(); \\ni--; \\n} \\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n{ \\n\\nint\\nM[][] = {{\\n0\\n, \\n1\\n, \\n1\\n, \\n0\\n, \\n1\\n}, \\n{\\n1\\n, \\n1\\n, \\n0\\n, \\n1\\n, \\n0\\n}, \\n{\\n0\\n, \\n1\\n, \\n1\\n, \\n1\\n, \\n0\\n}, \\n{\\n1\\n, \\n1\\n, \\n1\\n, \\n1\\n, \\n0\\n}, \\n{\\n1\\n, \\n1\\n, \\n1\\n, \\n1\\n, \\n1\\n}, \\n{\\n0\\n, \\n0\\n, \\n0\\n, \\n0\\n, \\n0\\n}}; \\n\\n\\nprintMaxSubSquare(M); \\n} \\n} \\n", "src": "public\nclass\nGFG \n{ \n\n\n\nstatic\nvoid\nprintMaxSubSquare(\nint\nM[][]) \n\n{ \n\nint\ni,j; \n\nint\nR = M.length; \n\n\nint\nC = M[\n0\n].length; \n\n\nint\nS[][] = \nnew\nint\n[R][C]; \n\n\nint\nmax_of_s, max_i, max_j; \n\n\n\n\nfor\n(i = \n0\n; i < R; i++) \n\nS[i][\n0\n] = M[i][\n0\n]; \n\n\n\n\nfor\n(j = \n0\n; j < C; j++) \n\nS[\n0\n][j] = M[\n0\n][j]; \n\n\n\n\nfor\n(i = \n1\n; i < R; i++) \n\n{ \n\nfor\n(j = \n1\n; j < C; j++) \n\n{ \n\nif\n(M[i][j] == \n1\n) \n\nS[i][j] = Math.min(S[i][j-\n1\n], \n\nMath.min(S[i-\n1\n][j], S[i-\n1\n][j-\n1\n])) + \n1\n; \n\nelse\n\nS[i][j] = \n0\n; \n\n} \n\n} \n\n\n\n\nmax_of_s = S[\n0\n][\n0\n]; max_i = \n0\n; max_j = \n0\n; \n\nfor\n(i = \n0\n; i < R; i++) \n\n{ \n\nfor\n(j = \n0\n; j < C; j++) \n\n{ \n\nif\n(max_of_s < S[i][j]) \n\n{ \n\nmax_of_s = S[i][j]; \n\nmax_i = i; \n\nmax_j = j; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\"Maximum size sub-matrix is: \"\n); \n\nfor\n(i = max_i; i > max_i - max_of_s; i--) \n\n{ \n\nfor\n(j = max_j; j > max_j - max_of_s; j--) \n\n{ \n\nSystem.out.print(M[i][j] + \n\" \"\n); \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nM[][] = {{\n0\n, \n1\n, \n1\n, \n0\n, \n1\n}, \n\n{\n1\n, \n1\n, \n0\n, \n1\n, \n0\n}, \n\n{\n0\n, \n1\n, \n1\n, \n1\n, \n0\n}, \n\n{\n1\n, \n1\n, \n1\n, \n1\n, \n0\n}, \n\n{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n}, \n\n{\n0\n, \n0\n, \n0\n, \n0\n, \n0\n}}; \n\n\nprintMaxSubSquare(M); \n\n} \n\n}", "index": 453, "complexity": "3"}
{"forwhile": "class GFG { public static int maxCost(int mat[][], int N) { int dp[][]= new int[N][N]; dp[0][0] = mat[0][0]; int i = 1; while(i < N) { dp[i][0] = mat[i][0] + dp[i-1][0]; i++; } i = 1; while(i < N) { int j = 1; while(j < i + 1 && j < N) { dp[i][j] = mat[i][j] + Math.max(dp[i-1][j-1], dp[i-1][j]); j++; } i++; } int result = 0; i = 0; while(i < N) { if(result < dp[N-1][i]) result = dp[N-1][i]; i++; } return result; } public static void main(String[] args) { int mat[][] = { { 4, 1, 5, 6, 1}, { 2, 9, 2, 11, 10}, { 15, 1, 3, 15, 2}, { 16, 92, 41, 4, 3}, { 8, 142, 6, 4, 8} }; int N = 5; System.out.println(\"Maximum Path Sum : \"+ maxCost(mat, N)); } }", "src": "class\nGFG { \n\n\n\n\npublic\nstatic\nint\nmaxCost(\nint\nmat[][], \nint\nN) \n\n{ \n\n\n\n\n\nint\ndp[][]=\nnew\nint\n[N][N]; \n\n\ndp[\n0\n][\n0\n] = mat[\n0\n][\n0\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\ndp[i][\n0\n] = mat[i][\n0\n] + dp[i-\n1\n][\n0\n]; \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j < i + \n1\n&& j < N; j++) \n\ndp[i][j] = mat[i][j] + \n\nMath.max(dp[i-\n1\n][j-\n1\n], \n\ndp[i-\n1\n][j]); \n\n\n\n\n\n\nint\nresult = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\nif\n(result < dp[N-\n1\n][i]) \n\nresult = dp[N-\n1\n][i]; \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n4\n, \n1\n,\n5\n,\n6\n, \n1\n}, \n\n{ \n2\n,\n9\n,\n2\n,\n11\n,\n10\n}, \n\n{ \n15\n,\n1\n,\n3\n,\n15\n, \n2\n}, \n\n{ \n16\n, \n92\n, \n41\n,\n4\n,\n3\n}, \n\n{ \n8\n, \n142\n, \n6\n, \n4\n, \n8\n} \n\n}; \n\nint\nN = \n5\n; \n\nSystem.out.println(\n\"Maximum Path Sum : \"\n+ \n\nmaxCost(mat, N)); \n\n} \n}", "index": 454, "complexity": "3"}
{"forwhile": "class GFG { static int N = 4; static int MaximumPath(int Mat[][]) { int result = 0; int dp[][] = new int[N][N + 2]; int i = 0; while(i < N) { int[] rows = dp[i]; int j = 0; while(j < N + 2) { rows[j] = 0; j++; } i++; } i = 0; while(i < N) { dp[0][i + 1] = Mat[0][i]; i++; } i = 1; while(i < N) { int j = 1; while(j <= N) { dp[i][j] = Math.max(dp[i - 1][j - 1], Math.max(dp[i - 1][j], dp[i - 1][j + 1])) + Mat[i][j - 1]; j++; } i++; } i = 0; while(i <= N) { result = Math.max(result, dp[N - 1][i]); i++; } return result; } public static void main(String arg[]) { int Mat[][] = { { 4, 2, 3, 4}, { 2, 9, 1, 10}, { 15, 1, 3, 0}, { 16, 92, 41, 44} }; System.out.println(MaximumPath(Mat)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nN = \n4\n; \n\n\n\n\nstatic\nint\nMaximumPath(\nint\nMat[][]) \n\n{ \n\nint\nresult = \n0\n; \n\n\n\n\n\n\nint\ndp[][] = \nnew\nint\n[N][N + \n2\n]; \n\n\n\n\nfor\n(\nint\n[] rows : dp) \n\nArrays.fill(rows, \n0\n); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ndp[\n0\n][i + \n1\n] = Mat[\n0\n][i]; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nfor\n(\nint\nj = \n1\n; j <= N; j++) \n\ndp[i][j] = Math.max(dp[i - \n1\n][j - \n1\n], \n\nMath.max(dp[i - \n1\n][j], \n\ndp[i - \n1\n][j + \n1\n])) + \n\nMat[i][j - \n1\n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= N; i++) \n\nresult = Math.max(result, dp[N - \n1\n][i]); \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\nMat[][] = { { \n4\n, \n2\n, \n3\n, \n4\n}, \n\n{ \n2\n, \n9\n, \n1\n, \n10\n}, \n\n{ \n15\n, \n1\n, \n3\n, \n0\n}, \n\n{ \n16\n, \n92\n, \n41\n, \n44\n} }; \n\n\nSystem.out.println(MaximumPath(Mat)); \n\n} \n}", "index": 455, "complexity": "3"}
{"forwhile": "class MinimumCostPath  {\nprivate static int min( int x,  int y,  int z) {\nif (x < y) \nreturn (x < z)? x : z; \nelse\nreturn (y < z)? y : z; \n} \nprivate static int minCost( int cost[][],  int m,  int n) {\nint i, j; \nint tc[][]= new int [m+ 1 ][n+ 1 ]; \ntc[ 0 ][ 0 ] = cost[ 0 ][ 0 ]; \nint i = 1;\nwhile(i <= m) { \ntc[i][ 0 ] = tc[i- 1 ][ 0 ] + cost[i][ 0 ]; \ni++; \n} \nint j = 1;\nwhile(j <= n) { \ntc[ 0 ][j] = tc[ 0 ][j- 1 ] + cost[ 0 ][j]; \nj++; \n} \nint i = 1;\nwhile(i <= m) { \nint j = 1;\nwhile(j <= n) { \ntc[i][j] = min(tc[i- 1 ][j- 1 ], tc[i- 1 ][j], tc[i][j- 1 ]) + cost[i][j]; \nj++; \n} \ni++; \n} \nreturn tc[m][n]; \n} \npublic static void main(String args[]) {\nint cost[][]= {{ 1 , 2 , 3 }, { 4 , 8 , 2 }, { 1 , 5 , 3 }}; \nSystem.out.println(minCost(cost, 2 , 2 )); \n} \n}", "src": "class\nMinimumCostPath \n{ \n\n\n\nprivate\nstatic\nint\nmin(\nint\nx, \nint\ny, \nint\nz) \n\n{ \n\nif\n(x < y) \n\nreturn\n(x < z)? x : z; \n\nelse\n\nreturn\n(y < z)? y : z; \n\n} \n\n\nprivate\nstatic\nint\nminCost(\nint\ncost[][], \nint\nm, \nint\nn) \n\n{ \n\nint\ni, j; \n\nint\ntc[][]=\nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\ntc[\n0\n][\n0\n] = cost[\n0\n][\n0\n]; \n\n\n\n\nfor\n(i = \n1\n; i <= m; i++) \n\ntc[i][\n0\n] = tc[i-\n1\n][\n0\n] + cost[i][\n0\n]; \n\n\n\n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[\n0\n][j] = tc[\n0\n][j-\n1\n] + cost[\n0\n][j]; \n\n\n\n\nfor\n(i = \n1\n; i <= m; i++) \n\nfor\n(j = \n1\n; j <= n; j++) \n\ntc[i][j] = min(tc[i-\n1\n][j-\n1\n], \n\ntc[i-\n1\n][j], \n\ntc[i][j-\n1\n]) + cost[i][j]; \n\n\nreturn\ntc[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\ncost[][]= {{\n1\n, \n2\n, \n3\n}, \n\n{\n4\n, \n8\n, \n2\n}, \n\n{\n1\n, \n5\n, \n3\n}}; \n\nSystem.out.println(minCost(cost,\n2\n,\n2\n)); \n\n} \n}", "index": 456, "complexity": "3"}
{"forwhile": "class GFG{ private static int minJumps(int[] arr, int n) { int jumps[] = new int[n]; int i, j; if(n == 0 || arr[0] == 0) return Integer.MAX_VALUE; jumps[0] = 0; i = 1; while(i < n) { jumps[i] = Integer.MAX_VALUE; j = 0; while(j < i) { if(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) { jumps[i] = Math.min(jumps[i], jumps[j] + 1); break; } j++; } i++; } return jumps[n-1]; } public static void main(String[] args) { int arr[] = {1, 3, 6, 1, 0, 9}; System.out.println(\"Minimum number of jumps to reach end is : \"+ minJumps(arr,arr.length)); } }", "src": "class\nGFG{ \n\nprivate\nstatic\nint\nminJumps(\nint\n[] arr, \nint\nn) { \n\nint\njumps[] = \nnew\nint\n[n]; \n\n\n\n\nint\ni, j; \n\n\nif\n(n == \n0\n|| arr[\n0\n] == \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\n\n\n\n\njumps[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\njumps[i] = Integer.MAX_VALUE; \n\nfor\n(j = \n0\n; j < i; j++) \n\n{ \n\nif\n(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) \n\n{ \n\njumps[i] = Math.min(jumps[i], jumps[j] + \n1\n); \n\nbreak\n; \n\n} \n\n} \n\n} \n\nreturn\njumps[n-\n1\n]; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\n\nSystem.out.println(\n\"Minimum number of jumps to reach end is : \"\n+ \n\nminJumps(arr,arr.length)); \n\n} \n}", "index": 457, "complexity": "3"}
{"forwhile": "class GFG { static int MAX=100; static int dp[][]=new int[MAX][MAX]; static int countRemovals(int a[], int i, int j, int k) { if(i >= j) return 0; else if((a[j] - a[i]) <= k) return 0; else if(dp[i][j] != -1) return dp[i][j]; else if((a[j] - a[i]) > k) { dp[i][j] = 1 + Math.min(countRemovals(a, i + 1, j, k), countRemovals(a, i, j - 1, k)); } return dp[i][j]; } static int removals(int a[], int n, int k) { Arrays.sort(a); int x = 0; while(x < dp.length) { int[] rows = dp[x]; int y = 0; while(y < rows.length) { rows[y] = -1; y++; } x++; } if(n == 1) return 0; else return countRemovals(a, 0, n - 1, k); } public static void main (String[] args) { int a[] = { 1, 3, 4, 9, 10, 11, 12, 17, 20}; int n = a.length; int k = 4; System.out.print(removals(a, n, k)); } }", "src": "class\nGFG \n{ \n\nstatic\nint\nMAX=\n100\n; \n\nstatic\nint\ndp[][]=\nnew\nint\n[MAX][MAX]; \n\n\n\n\n\n\nstatic\nint\ncountRemovals(\nint\na[], \nint\ni, \nint\nj, \nint\nk) \n\n{ \n\n\n\nif\n(i >= j) \n\nreturn\n0\n; \n\n\n\n\n\n\nelse\nif\n((a[j] - a[i]) <= k) \n\nreturn\n0\n; \n\n\n\n\nelse\nif\n(dp[i][j] != -\n1\n) \n\nreturn\ndp[i][j]; \n\n\n\n\nelse\nif\n((a[j] - a[i]) > k) { \n\n\n\n\n\n\n\n\ndp[i][j] = \n1\n+ Math.min(countRemovals(a, i + \n1\n, j, k), \n\ncountRemovals(a, i, j - \n1\n, k)); \n\n} \n\nreturn\ndp[i][j]; \n\n} \n\n\n\n\nstatic\nint\nremovals(\nint\na[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nArrays.sort(a); \n\n\n\n\n\n\nfor\n(\nint\n[] rows:dp) \n\nArrays.fill(rows,-\n1\n); \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\nelse\n\nreturn\ncountRemovals(a, \n0\n, n - \n1\n, k); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\na[] = { \n1\n, \n3\n, \n4\n, \n9\n, \n10\n, \n11\n, \n12\n, \n17\n, \n20\n}; \n\nint\nn = a.length; \n\nint\nk = \n4\n; \n\nSystem.out.print(removals(a, n, k)); \n\n} \n}", "index": 458, "complexity": "3"}
{"forwhile": "class\nEDIST \n{ \n\nstatic\nint\nmin(\nint\nx,\nint\ny,\nint\nz) \n\n{ \n\nif\n(x <= y && x <= z) \nreturn\nx; \n\nif\n(y <= x && y <= z) \nreturn\ny; \n\nelse\nreturn\nz; \n\n} \n\n\nstatic\nint\neditDistDP(String str1, String str2, \nint\nm, \nint\nn) \n\n{ \n\n\n\nint\ndp[][] = \nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\n\n\nint\ni = \n0\n; \nwhile(i<=m) \n\n{ \n\nint\nj = \n0\n; \nwhile(j<=n) \n\n{ \n\n\n\n\n\nif\n(i==\n0\n) \n\ndp[i][j] = j; \n\n\n\n\n\n\n\nelse\nif\n(j==\n0\n) \n\ndp[i][j] = i; \n\n\n\n\n\n\n\nelse\nif\n(str1.charAt(i-\n1\n) == str2.charAt(j-\n1\n)) \n\ndp[i][j] = dp[i-\n1\n][j-\n1\n]; \n\n\n\n\n\n\nelse\n\ndp[i][j] = \n1\n+ min(dp[i][j-\n1\n], \n\n\ndp[i-\n1\n][j], \n\n\ndp[i-\n1\n][j-\n1\n]); \n\nj++; \n\n} \n\ni++; \n\n} \n\n\nreturn\ndp[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str1 = \n\"sunday\"\n; \n\nString str2 = \n\"saturday\"\n; \n\nSystem.out.println( editDistDP( str1 , str2 , str1.length(), str2.length()) ); \n\n} \n}", "src": "class\nEDIST \n{ \n\nstatic\nint\nmin(\nint\nx,\nint\ny,\nint\nz) \n\n{ \n\nif\n(x <= y && x <= z) \nreturn\nx; \n\nif\n(y <= x && y <= z) \nreturn\ny; \n\nelse\nreturn\nz; \n\n} \n\n\nstatic\nint\neditDistDP(String str1, String str2, \nint\nm, \nint\nn) \n\n{ \n\n\n\nint\ndp[][] = \nnew\nint\n[m+\n1\n][n+\n1\n]; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<=m; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<=n; j++) \n\n{ \n\n\n\n\n\nif\n(i==\n0\n) \n\ndp[i][j] = j; \n\n\n\n\n\n\n\nelse\nif\n(j==\n0\n) \n\ndp[i][j] = i; \n\n\n\n\n\n\n\nelse\nif\n(str1.charAt(i-\n1\n) == str2.charAt(j-\n1\n)) \n\ndp[i][j] = dp[i-\n1\n][j-\n1\n]; \n\n\n\n\n\n\nelse\n\ndp[i][j] = \n1\n+ min(dp[i][j-\n1\n], \n\n\ndp[i-\n1\n][j], \n\n\ndp[i-\n1\n][j-\n1\n]); \n\n\n} \n\n} \n\n\nreturn\ndp[m][n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str1 = \n\"sunday\"\n; \n\nString str2 = \n\"saturday\"\n; \n\nSystem.out.println( editDistDP( str1 , str2 , str1.length(), str2.length()) ); \n\n} \n}", "index": 459, "complexity": "3"}
{"forwhile": "public class LongestCommonSubSequence {\n\n\n\nstatic int LCSubStr(char X[], char Y[], int m, int n) \n\n{ \n\n\n\n\n\n\n\n\n\n\nint LCStuff[][] = new int[m + 1][n + 1]; \n\nint result = 0; \n\n\n\n\n\nint i = 0; \nwhile(i <= m) \n\n{ \n\nint j = 0; \nwhile(j <= n) \n\n{ \n\nif(i == 0 || j == 0) \n\nLCStuff[i][j] = 0; \n\nelse if(X[i - 1] == Y[j - 1]) \n\n{ \n\nLCStuff[i][j] = LCStuff[i - 1][j - 1] + 1; \n\nresult = Integer.max(result, LCStuff[i][j]); \n\n} \n\nelse\n\nLCStuff[i][j] = 0; \n\nj++; \n\n} \n\ni++; \n\n} \n\nreturn result; \n\n} \n\n\n\n\npublic static void main(String[] args) \n\n{ \n\nString X = \"OldSite:GeeksforGeeks.org\"; \n\nString Y = \"NewSite:GeeksQuiz.com\"; \n\n\nint m = X.length(); \n\nint n = Y.length(); \n\n\nSystem.out.println(\"Length of Longest Common Substring is \"\n\n+ LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); \n\n} \n}", "src": "public\nclass\nLongestCommonSubSequence \n{ \n\n\n\nstatic\nint\nLCSubStr(\nchar\nX[], \nchar\nY[], \nint\nm, \nint\nn) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\nint\nLCStuff[][] = \nnew\nint\n[m + \n1\n][n + \n1\n]; \n\nint\nresult = \n0\n; \n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= m; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j <= n; j++) \n\n{ \n\nif\n(i == \n0\n|| j == \n0\n) \n\nLCStuff[i][j] = \n0\n; \n\nelse\nif\n(X[i - \n1\n] == Y[j - \n1\n]) \n\n{ \n\nLCStuff[i][j] = LCStuff[i - \n1\n][j - \n1\n] + \n1\n; \n\nresult = Integer.max(result, LCStuff[i][j]); \n\n} \n\nelse\n\nLCStuff[i][j] = \n0\n; \n\n} \n\n} \n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString X = \n\"OldSite:GeeksforGeeks.org\"\n; \n\nString Y = \n\"NewSite:GeeksQuiz.com\"\n; \n\n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\nSystem.out.println(\n\"Length of Longest Common Substring is \"\n\n+ LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); \n\n} \n}", "index": 460, "complexity": "3"}
{"forwhile": "public\n\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\nLCSubStr(String X, String Y) \n\n{ \n\n\n\n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\n\n\n\n\nint\nresult = \n0\n; \n\n\n\n\n\n\nint\n[][]len = \nnew\nint\n[\n2\n][n]; \n\n\n\n\n\n\nint\ncurrRow = \n0\n; \n\n\n\n\nint\ni = \n0\n; \nwhile(i < m) { \n\nint\nj = \n0\n; \nwhile(j < n) { \n\nif(i == \n0\n|| j == \n0\n) { \n\nlen[currRow][j] = \n0\n; \n\n} \n\nelse\nif(X.charAt(i - \n1\n) == \n\nY.charAt(j - \n1\n)) \n\n{ \n\nlen[currRow][j] = \n\nlen[(\n1\n- currRow)][(j - \n1\n)] \n\n+ \n1\n; \n\nresult = Math.max(result, \n\nlen[currRow][j]); \n\n} \n\nelse\n\n{ \n\nlen[currRow][j] = \n0\n; \n\n} \n\nj++; \n\n} \n\n\n\n\n\n\n\n\ncurrRow = \n1\n- currRow; \n\ni++; \n} \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString X = \n\"GeeksforGeeks\"\n; \n\nString Y = \n\"GeeksQuiz\"\n; \n\n\nSystem.out.print(LCSubStr(X, Y)); \n\n} \n}", "src": "public\nclass\nGFG { \n\n\n\n\n\n\nstatic\nint\nLCSubStr(String X, String Y) \n\n{ \n\n\n\n\nint\nm = X.length(); \n\nint\nn = Y.length(); \n\n\n\n\n\n\nint\nresult = \n0\n; \n\n\n\n\n\n\nint\n[][]len = \nnew\nint\n[\n2\n][n]; \n\n\n\n\n\n\nint\ncurrRow = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < m; i++) { \n\nfor\n(\nint\nj = \n0\n; j < n; j++) { \n\nif\n(i == \n0\n|| j == \n0\n) { \n\nlen[currRow][j] = \n0\n; \n\n} \n\nelse\nif\n(X.charAt(i - \n1\n) == \n\nY.charAt(j - \n1\n)) \n\n{ \n\nlen[currRow][j] = \n\nlen[(\n1\n- currRow)][(j - \n1\n)] \n\n+ \n1\n; \n\nresult = Math.max(result, \n\nlen[currRow][j]); \n\n} \n\nelse\n\n{ \n\nlen[currRow][j] = \n0\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\ncurrRow = \n1\n- currRow; \n\n} \n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString X = \n\"GeeksforGeeks\"\n; \n\nString Y = \n\"GeeksQuiz\"\n; \n\n\nSystem.out.print(LCSubStr(X, Y)); \n\n} \n}", "index": 461, "complexity": "3"}
{"forwhile": "class GFG { static int offeringNumber(int n, int templeHeight[]) { int sum = 0; int i = 0; while(i < n) { int left = 0, right = 0; int j = i - 1; while(j >= 0) { if(templeHeight[j] < templeHeight[j + 1]) left++; else break; j--; } j = i + 1; while(j < n) { if(templeHeight[j] < templeHeight[j - 1]) right++; else break; j++; } sum += Math.max(right, left) + 1; i++; } return sum; } public static void main (String[] args) { int arr1[] = {1, 2, 2}; System.out.println(offeringNumber(3, arr1)); int arr2[] = {1, 4, 3, 6, 2, 1}; System.out.println(offeringNumber(6, arr2)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nofferingNumber(\nint\nn, \n\nint\ntempleHeight[]) \n{ \n\nint\nsum = \n0\n; \n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\n\n\n\n\nint\nleft = \n0\n, right = \n0\n; \n\nfor\n(\nint\nj = i - \n1\n; j >= \n0\n; --j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j + \n1\n]) \n\n++left; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\nif\n(templeHeight[j] < \n\ntempleHeight[j - \n1\n]) \n\n++right; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\n\n\n\n\nsum += Math.max(right, left) + \n1\n; \n\n} \n\n\nreturn\nsum; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \nint\narr1[] = {\n1\n, \n2\n, \n2\n}; \nSystem.out.println(offeringNumber(\n3\n, arr1)); \nint\narr2[] = {\n1\n, \n4\n, \n3\n, \n\n6\n, \n2\n, \n1\n}; \nSystem.out.println(offeringNumber(\n6\n, arr2)); \n} \n}", "index": 462, "complexity": "3"}
{"forwhile": "class GFG { static void printEqualSumSets(int []arr, int n) { int i, currSum, sum = 0; i = 0; while(i < arr.length) sum += arr[i++]; if((sum & 1) == 1) { System.out.print(\"-1\"); return; } int k = sum >> 1; boolean [][]dp = new boolean[n + 1][k + 1]; i = 1; while(i <= k) dp[0][i++] = false; i = 0; while(i <= n) dp[i++][0] = true; i = 1; while(i <= n) { currSum = 1; while(currSum <= k) { dp[i][currSum] = dp[i - 1][currSum]; if(arr[i - 1] <= currSum) dp[i][currSum] = dp[i][currSum] | dp[i - 1][currSum - arr[i - 1]]; currSum++; } i++; } List<Integer> set1 = new ArrayList<Integer>(); List<Integer> set2 = new ArrayList<Integer>(); if(!dp[n][k]) { System.out.print(\"-1\\n\"); return; } i = n; currSum = k; while(i > 0 && currSum >= 0) { if(dp[i - 1][currSum]) { i--; set2.add(arr[i]); } else if(dp[i - 1][currSum - arr[i - 1]]) { i--; currSum -= arr[i]; set1.add(arr[i]); } } System.out.print(\"Set 1 elements: \"); i = 0; while(i < set1.size()) System.out.print(set1.get(i++) + \" \"); System.out.print(\"\\nSet 2 elements: \"); i = 0; while(i < set2.size()) System.out.print(set2.get(i++) + \" \"); } public static void main(String args[]) { int []arr = new int[]{ 5, 5, 1, 11 }; int n = arr.length; printEqualSumSets(arr, n); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nvoid\nprintEqualSumSets(\nint\n[]arr, \n\nint\nn) \n\n{ \n\nint\ni, currSum, sum = \n0\n; \n\n\n\n\nfor\n(i = \n0\n; i < arr.length; i++) \n\nsum += arr[i]; \n\n\n\n\n\n\n\n\n\n\nif\n((sum & \n1\n) == \n1\n) \n\n{ \n\nSystem.out.print(\n\"-1\"\n); \n\nreturn\n; \n\n} \n\n\n\n\n\n\nint\nk = sum >> \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nboolean\n[][]dp = \nnew\nboolean\n[n + \n1\n][k + \n1\n]; \n\n\n\n\n\n\nfor\n(i = \n1\n; i <= k; i++) \n\ndp[\n0\n][i] = \nfalse\n; \n\n\n\n\n\n\nfor\n(i = \n0\n; i <= n; i++) \n\ndp[i][\n0\n] = \ntrue\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i <= n; i++) \n\n{ \n\nfor\n(currSum = \n1\n; \n\ncurrSum <= k; \n\ncurrSum++) \n\n{ \n\n\n\n\ndp[i][currSum] = dp[i - \n1\n][currSum]; \n\n\n\n\nif\n(arr[i - \n1\n] <= currSum) \n\ndp[i][currSum] = dp[i][currSum] | \n\ndp[i - \n1\n][currSum - arr[i - \n1\n]]; \n\n} \n\n} \n\n\n\n\nList<Integer> set1 = \nnew\nArrayList<Integer>(); \n\nList<Integer> set2 = \nnew\nArrayList<Integer>(); \n\n\n\n\n\n\nif\n(!dp[n][k]) \n\n{ \n\nSystem.out.print(\n\"-1\\n\"\n); \n\nreturn\n; \n\n} \n\n\n\n\n\n\ni = n; \n\ncurrSum = k; \n\n\nwhile\n(i > \n0\n&& currSum >= \n0\n) \n\n{ \n\n\n\n\n\n\n\n\nif\n(dp[i - \n1\n][currSum]) \n\n{ \n\ni--; \n\nset2.add(arr[i]); \n\n} \n\n\n\n\n\n\nelse\nif\n(dp[i - \n1\n][currSum - arr[i - \n1\n]]) \n\n{ \n\ni--; \n\ncurrSum -= arr[i]; \n\nset1.add(arr[i]); \n\n} \n\n} \n\n\n\n\nSystem.out.print(\n\"Set 1 elements: \"\n); \n\nfor\n(i = \n0\n; i < set1.size(); i++) \n\nSystem.out.print(set1.get(i) + \n\" \"\n); \n\n\nSystem.out.print(\n\"\\nSet 2 elements: \"\n); \n\n\nfor\n(i = \n0\n; i < set2.size(); i++) \n\nSystem.out.print(set2.get(i) + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = \nnew\nint\n[]{ \n5\n, \n5\n, \n1\n, \n11\n}; \n\nint\nn = arr.length; \n\nprintEqualSumSets(arr, n); \n\n} \n}", "index": 463, "complexity": "3"}
{"forwhile": "class\nLBS \n{ \n\n\n\nstatic\nint\nlbs( \nint\narr[], \nint\nn ) \n\n{ \n\nint\ni, j; \n\n\n\n\nint\n[] lis = \nnew\nint\n[n]; \n\ni = \n0\n;\nwhile(i < n) \n{\n\nlis[i] = \n1\n; \ni++;\n} \n\n\n\n\ni = \n1\n;\nwhile(i < n) \n{\n\nj = \n0\n;\nwhile(j < i) \n{\n\nif\n(arr[i] > arr[j] && lis[i] < lis[j] + \n1\n) \n{\n\nlis[i] = lis[j] + \n1\n; \n}\n\nj++;\n} \ni++;\n} \n\n\n\n\nint\n[] lds = \nnew\nint\n[n]; \n\ni = \n0\n;\nwhile(i < n) \n{\n\nlds[i] = \n1\n; \ni++;\n} \n\n\n\n\ni = n-\n2\n;\nwhile(i >= \n0\n) \n{\n\nj = n-\n1\n;\nwhile(j > i) \n{\n\nif\n(arr[i] > arr[j] && lds[i] < lds[j] + \n1\n) \n{\n\nlds[i] = lds[j] + \n1\n; \n}\n\nj--;\n} \ni--;\n} \n\n\n\n\n\nint\nmax = lis[\n0\n] + lds[\n0\n] - \n1\n; \n\ni = \n1\n;\nwhile(i < n) \n{\n\nif\n(lis[i] + lds[i] - \n1\n> max) \n{\n\nmax = lis[i] + lds[i] - \n1\n; \n}\n\ni++;\n} \n\n\nreturn\nmax; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n0\n, \n8\n, \n4\n, \n12\n, \n2\n, \n10\n, \n6\n, \n14\n, \n1\n, \n9\n, \n5\n, \n\n13\n, \n3\n, \n11\n, \n7\n, \n15\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of LBS is \"\n+ lbs( arr, n )); \n\n} \n}", "src": "class\nLBS \n{ \n\n\n\nstatic\nint\nlbs( \nint\narr[], \nint\nn ) \n\n{ \n\nint\ni, j; \n\n\n\n\nint\n[] lis = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlis[i] = \n1\n; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && lis[i] < lis[j] + \n1\n) \n\nlis[i] = lis[j] + \n1\n; \n\n\n\n\nint\n[] lds = \nnew\nint\n[n]; \n\nfor\n(i = \n0\n; i < n; i++) \n\nlds[i] = \n1\n; \n\n\n\n\nfor\n(i = n-\n2\n; i >= \n0\n; i--) \n\nfor\n(j = n-\n1\n; j > i; j--) \n\nif\n(arr[i] > arr[j] && lds[i] < lds[j] + \n1\n) \n\nlds[i] = lds[j] + \n1\n; \n\n\n\n\n\nint\nmax = lis[\n0\n] + lds[\n0\n] - \n1\n; \n\nfor\n(i = \n1\n; i < n; i++) \n\nif\n(lis[i] + lds[i] - \n1\n> max) \n\nmax = lis[i] + lds[i] - \n1\n; \n\n\nreturn\nmax; \n\n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n0\n, \n8\n, \n4\n, \n12\n, \n2\n, \n10\n, \n6\n, \n14\n, \n1\n, \n9\n, \n5\n, \n\n13\n, \n3\n, \n11\n, \n7\n, \n15\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of LBS is \"\n+ lbs( arr, n )); \n\n} \n}", "index": 464, "complexity": "3"}
{"forwhile": "class GFG { static int lps(String s) { int n = s.length(); int a[] = new int[n]; int i = n - 1; while(i >= 0) { int back_up = 0; int j = i; while(j < n) { if(j == i) a[j] = 1; else if(s.charAt(i) == s.charAt(j)) { int temp = a[j]; a[j] = back_up + 2; back_up = temp; } else { back_up = a[j]; a[j] = Math.max(a[j - 1], a[j]); } j++; } i--; } return a[n - 1]; } public static void main(String[] args) { String str = \"GEEKSFORGEEKS\"; System.out.println(lps(str)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nlps(String s) \n\n{ \n\nint\nn = s.length(); \n\n\n\n\n\n\n\n\nint\na[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(\nint\ni = n - \n1\n; i >= \n0\n; i--) \n\n{ \n\nint\nback_up = \n0\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i; j < n; j++) { \n\n\n\n\n\n\n\n\nif\n(j == i) \n\na[j] = \n1\n; \n\n\n\n\n\n\n\n\nelse\nif\n(s.charAt(i) == s.charAt(j)) \n\n{ \n\nint\ntemp = a[j]; \n\na[j] = back_up + \n2\n; \n\nback_up = temp; \n\n} \n\n\n\n\n\n\nelse\n\n{ \n\nback_up = a[j]; \n\na[j] = Math.max(a[j - \n1\n], a[j]); \n\n} \n\n} \n\n} \n\nreturn\na[n - \n1\n]; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"GEEKSFORGEEKS\"\n; \n\nSystem.out.println(lps(str)); \n\n} \n}", "index": 465, "complexity": "3"}
{"forwhile": "public class GFG { static int countPS(String str) { int N = str.length(); int [][] cps = new int [N+1][N+1]; int i = 0; while(i < N) { cps[i][i] = 1; i++; } int L = 2; while(L <= N) { i = 0; while(i < N) { int k = L + i - 1; if(k < N){ if(str.charAt(i) == str.charAt(k)) cps[i][k] = cps[i][k-1] + cps[i+1][k] + 1; else cps[i][k] = cps[i][k-1] + cps[i+1][k] - cps[i+1][k-1]; } i++; } L++; } return cps[0][N-1]; } public static void main(String args[]) { String str = \"abcb\"; System.out.println(\"Total palindromic \" + \"subsequence are : \" + countPS(str)); } }", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\nstatic\nint\ncountPS(String str) \n\n{ \n\nint\nN = str.length(); \n\n\n\n\n\n\nint\n[][] cps = \nnew\nint\n[N+\n1\n][N+\n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\ncps[i][i] = \n1\n; \n\n\n\n\n\n\nfor\n(\nint\nL=\n2\n; L<=N; L++) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\n{ \n\nint\nk = L + i - \n1\n; \n\nif\n(k < N){ \n\nif\n(str.charAt(i) == str.charAt(k)) \n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] + \n1\n; \n\nelse\n\ncps[i][k] = cps[i][k-\n1\n] + \n\ncps[i+\n1\n][k] - \n\ncps[i+\n1\n][k-\n1\n]; \n\n} \n\n} \n\n} \n\n\n\n\nreturn\ncps[\n0\n][N-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nString str = \n\"abcb\"\n; \n\nSystem.out.println(\n\"Total palindromic \"\n+ \n\n\"subsequence are : \"\n\n+ countPS(str)); \n\n} \n}", "index": 466, "complexity": "3"}
{"forwhile": "public\n\n\nclass\nLongestPalinSubstring \n{\n\n\nstatic\nvoid\nprintSubStr(String str, \nint\nlow, \nint\nhigh) \n{\n\nSystem.out.println(str.substring(low, high + \n1\n)); \n\n}\n\n\nstatic\nint\nlongestPalSubstr(String str)\n{\n\nint\nn = str.length(); \n\n\nboolean\ntable[][] = \nnew\nboolean\n[n][n]; \n\nint\nmaxLength = \n1\n; \n\nint\ni = \n0\n;\n\nwhile(i < n) {\n\ntable[i][i] = \ntrue\n; \n\ni++; \n\n}\n\nint\nstart = \n0\n;\n\ni = \n0\n;\n\nwhile(i < n - \n1\n) {\n\nif\n(str.charAt(i) == str.charAt(i + \n1\n)) {\n\ntable[i][i + \n1\n] = \ntrue\n; \n\nstart = i; \n\nmaxLength = \n2\n; \n\n}\n\ni++;\n\n}\n\nint\nk = \n3\n;\n\nwhile(k <= n) {\n\ni = \n0\n;\n\nwhile(i < n - k + \n1\n) {\n\nint\nj = i + k - \n1\n; \n\nif\n(table[i + \n1\n][j - \n1\n] && str.charAt(i) == str.charAt(j)) {\n\ntable[i][j] = \ntrue\n; \n\nif\n(k > maxLength) {\n\nstart = i; \n\nmaxLength = k; \n\n}\n\n}\n\ni++;\n\n}\n\nk++;\n\n}\n\nSystem.out.print(\n\"Longest palindrome substring is: \"\n); \n\nprintSubStr(str, start, start + maxLength - \n1\n); \n\nreturn\nmaxLength; \n\n}\n\npublic\nstatic\nvoid\nmain(String[] args)\n{\n\nString str = \n\"forgeeksskeegfor\"\n; \n\nSystem.out.println(\n\"Length is: \"\n+ \nlongestPalSubstr(str)); \n\n}\n}", "src": "public\nclass\nLongestPalinSubstring \n{ \n\n\n\nstatic\nvoid\nprintSubStr(String str, \nint\nlow, \nint\nhigh) { \n\nSystem.out.println(str.substring(low, high + \n1\n)); \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nlongestPalSubstr(String str) { \n\nint\nn = str.length(); \n\n\n\n\n\n\n\n\n\nboolean\ntable[][] = \nnew\nboolean\n[n][n]; \n\n\n\n\nint\nmaxLength = \n1\n; \n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\ntable[i][i] = \ntrue\n; \n\n\n\n\nint\nstart = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nif\n(str.charAt(i) == str.charAt(i + \n1\n)) { \n\ntable[i][i + \n1\n] = \ntrue\n; \n\nstart = i; \n\nmaxLength = \n2\n; \n\n} \n\n} \n\n\n\n\n\n\nfor\n(\nint\nk = \n3\n; k <= n; ++k) { \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n - k + \n1\n; ++i) \n\n{ \n\n\n\n\n\nint\nj = i + k - \n1\n; \n\n\n\n\n\n\n\n\nif\n(table[i + \n1\n][j - \n1\n] && str.charAt(i) == \n\nstr.charAt(j)) { \n\ntable[i][j] = \ntrue\n; \n\n\nif\n(k > maxLength) { \n\nstart = i; \n\nmaxLength = k; \n\n} \n\n} \n\n} \n\n} \n\nSystem.out.print(\n\"Longest palindrome substring is; \"\n); \n\nprintSubStr(str, start, start + maxLength - \n1\n); \n\n\nreturn\nmaxLength; \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nString str = \n\"forgeeksskeegfor\"\n; \n\nSystem.out.println(\n\"Length is: \"\n+ \n\nlongestPalSubstr(str)); \n\n} \n}", "index": 467, "complexity": "3"}
{"forwhile": "public\\nclass\\nGFG \\n{ \\n\\n\\n\\n\\nstatic\\nint\\nCountPS(\\nchar\\nstr[], \\nint\\nn) \\n\\n{ \\n\\n\\n\\n\\n\\nint\\ndp[][] = \\nnew\\nint\\n[n][n]; \\n\\n\\n\\n\\nboolean\\nP[][] = \\nnew\\nboolean\\n[n][n]; \\n\\n\\n\\nint\\ni = 0; \\nwhile(i< n) \\n{ \\n\\nP[i][i] = \\ntrue\\n; \\ni++; \\n} \\n\\n\\nint\\ni = 0; \\nwhile(i<n-1) \\n{ \\n\\nif\\n(str[i] == str[i+1]) \\n{ \\nP[i][i+1] = \\ntrue\\n; \\ndp[i][i+1] = \\n1\\n; \\n} \\ni++; \\n} \\n\\n\\n\\n\\nint\\ngap=2; \\nwhile(gap<n) \\n{ \\n\\n\\nint\\ni = 0; \\nwhile(i<n-gap) \\n{ \\n\\n\\nint\\nj = gap + i; \\n\\n\\nif\\n(str[i] == str[j] && P[i+1][j-1] ) \\nP[i][j] = \\ntrue\\n; \\n\\n\\nif\\n(P[i][j] == \\ntrue\\n) \\ndp[i][j] = dp[i][j-1] + dp[i+1][j] + \\n1\\n- dp[i+1][j-1]; \\nelse\\ndp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]; \\ni++; \\n} \\ngap++; \\n} \\n\\n\\n\\nreturn\\ndp[0][n-1]; \\n\\n} \\n\\n\\n\\npublic\\nstatic\\nvoid\\nmain(String[] args) \\n\\n{ \\n\\nString str = \\n\"abaab\"\\n; \\n\\nSystem.out.println(CountPS(str.toCharArray(), str.length())); \\n\\n} \\n}", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\nstatic\nint\nCountPS(\nchar\nstr[], \nint\nn) \n\n{ \n\n\n\n\n\n\n\nint\ndp[][] = \nnew\nint\n[n][n]; \n\n\n\n\n\n\nboolean\nP[][] = \nnew\nboolean\n[n][n]; \n\n\n\n\nfor\n(\nint\ni= \n0\n; i< n; i++) \n\nP[i][i] = \ntrue\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\nif\n(str[i] == str[i+\n1\n]) \n\n{ \n\nP[i][i+\n1\n] = \ntrue\n; \n\ndp[i][i+\n1\n] = \n1\n; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ngap=\n2\n; gap<n; gap++) \n\n{ \n\n\n\nfor\n(\nint\ni=\n0\n; i<n-gap; i++) \n\n{ \n\n\n\nint\nj = gap + i; \n\n\n\n\nif\n(str[i] == str[j] && P[i+\n1\n][j-\n1\n] ) \n\nP[i][j] = \ntrue\n; \n\n\n\n\n\n\n\n\nif\n(P[i][j] == \ntrue\n) \n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] + \n1\n- dp[i+\n1\n][j-\n1\n]; \n\nelse\n\ndp[i][j] = dp[i][j-\n1\n] + dp[i+\n1\n][j] - dp[i+\n1\n][j-\n1\n]; \n\n} \n\n} \n\n\n\n\nreturn\ndp[\n0\n][n-\n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nString str = \n\"abaab\"\n; \n\nSystem.out.println(CountPS(str.toCharArray(), str.length())); \n\n} \n}", "index": 468, "complexity": "3"}
{"forwhile": "class GFG { static void constructDp(int dp[][], String str) { int l = str.length(); int[][] isPalin = new int[l + 1][l + 1]; int i = 0; while(i <= l) { int j = 0; while(j <= l) { isPalin[i][j] = dp[i][j] = 0; j++; } i++; } i = l - 1; while(i >= 0) { isPalin[i][i] = 1; dp[i][i] = 1; int j = i + 1; while(j < l) { isPalin[i][j] = (str.charAt(i) == str.charAt(j) && (i + 1 > j - 1 || isPalin[i + 1][j - 1] != 0)) ? 1 : 0; dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1] + isPalin[i][j]; j++; } i--; } } static int countOfPalindromeInRange(int dp[][], int l, int r) { return dp[l][r]; } public static void main(String args[]) { int MAX = 50; String str = \"xyaabax\"; int[][] dp = new int[MAX][MAX]; constructDp(dp, str); int l = 3; int r = 5; System.out.println(countOfPalindromeInRange(dp, l, r)); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nconstructDp(\nint\ndp[][], String str) \n\n{ \n\nint\nl = str.length(); \n\n\n\n\n\n\nint\n[][] isPalin = \nnew\nint\n[l + \n1\n][l + \n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= l; i++) { \n\nfor\n(\nint\nj = \n0\n; j <= l; j++) { \n\nisPalin[i][j] = dp[i][j] = \n0\n; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = l - \n1\n; i >= \n0\n; i--) { \n\n\n\nisPalin[i][i] = \n1\n; \n\ndp[i][i] = \n1\n; \n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < l; j++) { \n\n\n\nisPalin[i][j] = (str.charAt(i) == str.charAt(j) && (i + \n1\n> j - \n1\n|| (isPalin[i + \n1\n][j - \n1\n]) != \n0\n)) ? \n1\n: \n0\n; \n\n\n\n\ndp[i][j] = dp[i][j - \n1\n] + dp[i + \n1\n][j] - dp[i + \n1\n][j - \n1\n] + isPalin[i][j]; \n\n} \n\n} \n\n} \n\n\n\n\nstatic\nint\ncountOfPalindromeInRange(\nint\ndp[][], \nint\nl, \nint\nr) \n\n{ \n\nreturn\ndp[l][r]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nMAX = \n50\n; \n\nString str = \n\"xyaabax\"\n; \n\nint\n[][] dp = \nnew\nint\n[MAX][MAX]; \n\nconstructDp(dp, str); \n\n\nint\nl = \n3\n; \n\nint\nr = \n5\n; \n\nSystem.out.println(countOfPalindromeInRange(dp, l, r)); \n\n} \n}", "index": 469, "complexity": "3"}
{"forwhile": "public class GFG { static int maxAlternateSum(int arr[], int n) { if (n == 1) return arr[0]; int dec[] = new int[n]; int inc[] = new int[n]; dec[0] = inc[0] = arr[0]; int flag = 0; int i = 1; while(i < n) { int j = 0; while(j < i) { if (arr[j] > arr[i]) { dec[i] = Math.max(dec[i], inc[j]+arr[i]); flag = 1; } else if (arr[j] < arr[i] && flag == 1) inc[i] = Math.max(inc[i], dec[j]+arr[i]); j++; } i++; } int result = Integer.MIN_VALUE; int i = 0; while(i < n) { if (result < inc[i]) result = inc[i]; if (result < dec[i]) result = dec[i]; i++; } return result; } public static void main(String[] args) { int arr[]= { 8 , 2 , 3 , 5 , 7 , 9 , 10 }; System.out.println(\"Maximum sum = \"+ maxAlternateSum(arr , arr.length)); } }", "src": "public\nclass\nGFG \n{ \n\n\n\n\n\n\n\nstatic\nint\nmaxAlternateSum(\nint\narr[], \nint\nn) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\narr[\n0\n]; \n\n\n\n\n\n\n\n\n\n\n\nint\ndec[] = \nnew\nint\n[n]; \n\n\n\n\n\nint\ninc[] = \nnew\nint\n[n]; \n\n\n\n\n\n\ndec[\n0\n] = inc[\n0\n] = arr[\n0\n]; \n\n\nint\nflag = \n0\n; \n\n\n\n\nfor\n(\nint\ni=\n1\n; i<n; i++) \n\n{ \n\nfor\n(\nint\nj=\n0\n; j<i; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(arr[j] > arr[i]) \n\n{ \n\ndec[i] = Math.max(dec[i], inc[j]+arr[i]); \n\n\n\n\n\n\nflag = \n1\n; \n\n} \n\n\n\n\n\n\n\n\nelse\nif\n(arr[j] < arr[i] && flag == \n1\n) \n\n\n\n\n\n\ninc[i] = Math.max(inc[i], dec[j]+arr[i]); \n\n} \n\n} \n\n\n\n\nint\nresult = Integer.MIN_VALUE; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(result < inc[i]) \n\nresult = inc[i]; \n\nif\n(result < dec[i]) \n\nresult = dec[i]; \n\n} \n\n\n\n\nreturn\nresult; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[]= {\n8\n, \n2\n, \n3\n, \n5\n, \n7\n, \n9\n, \n10\n}; \n\nSystem.out.println(\n\"Maximum sum = \"\n+ \n\nmaxAlternateSum(arr , arr.length)); \n\n} \n}", "index": 470, "complexity": "3"}
{"forwhile": "class GFG { static int zzis(int arr[], int n) { int las[][] = new int[n][2]; int i = 0; while(i < n) { las[i][0] = las[i][1] = 1; i++; } int res = 1; i = 1; while(i < n) { int j = 0; while(j < i) { if (arr[j] < arr[i] && las[i][0] < las[j][1] + 1) las[i][0] = las[j][1] + 1; if (arr[j] > arr[i] && las[i][1] < las[j][0] + 1) las[i][1] = las[j][0] + 1; j++; } if (res < Math.max(las[i][0], las[i][1])) res = Math.max(las[i][0], las[i][1]); i++; } return res; } public static void main(String[] args) { int arr[] = { 10, 22, 9, 33, 49, 50, 31, 60 }; int n = arr.length; System.out.println(\"Length of Longest \" + \"alternating subsequence is \" + zzis(arr, n)); } }", "src": "class\nGFG { \n\n\n\nstatic\nint\nzzis(\nint\narr[], \nint\nn) \n{ \n\n\n\nint\nlas[][] = \nnew\nint\n[n][\n2\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nlas[i][\n0\n] = las[i][\n1\n] = \n1\n; \n\n\nint\nres = \n1\n; \n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < i; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] < arr[i] && \n\nlas[i][\n0\n] < las[j][\n1\n] + \n1\n) \n\nlas[i][\n0\n] = las[j][\n1\n] + \n1\n; \n\n\n\n\n\n\nif\n( arr[j] > arr[i] && \n\nlas[i][\n1\n] < las[j][\n0\n] + \n1\n) \n\nlas[i][\n1\n] = las[j][\n0\n] + \n1\n; \n\n} \n\n\n\n\nif\n(res < Math.max(las[i][\n0\n], las[i][\n1\n])) \n\nres = Math.max(las[i][\n0\n], las[i][\n1\n]); \n\n} \n\n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = { \n10\n, \n22\n, \n9\n, \n33\n, \n49\n, \n\n50\n, \n31\n, \n60\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Length of Longest \"\n+ \n\n\"alternating subsequence is \"\n+ \n\nzzis(arr, n)); \n} \n}", "index": 471, "complexity": "3"}
{"forwhile": "class GFG { static int search(int arr[], int x, int n) { int i = 0; while(i < n) if(arr[i] == x) return i; return -1; } static void printPostOrder(int in1[], int pre[], int n) { int root = 0; for(; root != 0;) printPostOrder(in1, Arrays.copyOfRange(pre, 1, n), root); for(; root != n - 1;) printPostOrder(Arrays.copyOfRange(in1, root+1, n), Arrays.copyOfRange(pre, 1+root, n), n - root - 1); System.out.print( pre[0] + \" \"); } public static void main(String args[]) { int in1[] = { 4, 2, 5, 1, 3, 6 }; int pre[] = { 1, 2, 4, 5, 3, 6 }; int n = in1.length; System.out.println(\"Postorder traversal \"); printPostOrder(in1, pre, n); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nsearch(\nint\narr[], \nint\nx, \nint\nn) \n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nif\n(arr[i] == x) \n\nreturn\ni; \n\nreturn\n-\n1\n; \n} \n\n\n\nstatic\nvoid\nprintPostOrder(\nint\nin1[], \n\nint\npre[], \nint\nn) \n{ \n\n\n\n\n\n\n\nint\nroot = search(in1, pre[\n0\n], n); \n\n\n\n\n\n\nif\n(root != \n0\n) \n\nprintPostOrder(in1, Arrays.copyOfRange(pre, \n1\n, n), root); \n\n\n\n\n\n\nif\n(root != n - \n1\n) \n\nprintPostOrder(Arrays.copyOfRange(in1, root+\n1\n, n), \n\nArrays.copyOfRange(pre, \n1\n+root, n), n - root - \n1\n); \n\n\n\n\nSystem.out.print( pre[\n0\n] + \n\" \"\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\nin1[] = { \n4\n, \n2\n, \n5\n, \n1\n, \n3\n, \n6\n}; \n\nint\npre[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n3\n, \n6\n}; \n\nint\nn = in1.length; \n\nSystem.out.println(\n\"Postorder traversal \"\n); \n\nprintPostOrder(in1, pre, n); \n} \n}", "index": 472, "complexity": "3"}
{"forwhile": "public class PrintPost { static int preIndex = 0; void printPost(int[] in, int[] pre, int inStrt, int inEnd) { if(inStrt > inEnd) return; int inIndex = search(in, inStrt, inEnd, pre[preIndex++]); printPost(in, pre, inStrt, inIndex - 1); printPost(in, pre, inIndex + 1, inEnd); System.out.print(in[inIndex] + \" \"); } int search(int[] in, int startIn, int endIn, int data) { int i = 0; while(i < endIn) { if(in[i] == data) return i; i++; } return i; } public static void main(String ars[]) { int in[] = { 4, 2, 5, 1, 3, 6 }; int pre[] = { 1, 2, 4, 5, 3, 6 }; int len = in.length; PrintPost tree = new PrintPost(); tree.printPost(in, pre, 0, len - 1); } }", "src": "public\nclass\nPrintPost { \n\nstatic\nint\npreIndex = \n0\n; \n\nvoid\nprintPost(\nint\n[] in, \nint\n[] pre, \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\n; \n\n\n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, pre[preIndex++]); \n\n\n\n\nprintPost(in, pre, inStrt, inIndex - \n1\n); \n\n\n\n\nprintPost(in, pre, inIndex + \n1\n, inEnd); \n\n\n\n\nSystem.out.print(in[inIndex] + \n\" \"\n); \n\n} \n\n\nint\nsearch(\nint\n[] in, \nint\nstartIn, \nint\nendIn, \nint\ndata) \n\n{ \n\nint\ni = \n0\n; \n\nfor\n(i = startIn; i < endIn; i++) \n\nif\n(in[i] == data) \n\nreturn\ni; \n\nreturn\ni; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String ars[]) \n\n{ \n\nint\nin[] = { \n4\n, \n2\n, \n5\n, \n1\n, \n3\n, \n6\n}; \n\nint\npre[] = { \n1\n, \n2\n, \n4\n, \n5\n, \n3\n, \n6\n}; \n\nint\nlen = in.length; \n\nPrintPost tree = \nnew\nPrintPost(); \n\ntree.printPost(in, pre, \n0\n, len - \n1\n); \n\n} \n}", "index": 473, "complexity": "3"}
{"forwhile": "class Node { int data; Node left, right; public Node(int d) { data = d; left = right = null; } } class BinaryTree { Node root; void printSpiral(Node node) { int h = height(node); int i; boolean ltr = false; i = 1; while(i <= h) { printGivenLevel(node, i, ltr); ltr = !ltr; i++; } } int height(Node node) { if(node == null) return 0; else { int lheight = height(node.left); int rheight = height(node.right); if(lheight > rheight) return (lheight + 1); else return (rheight + 1); } } void printGivenLevel(Node node, int level, boolean ltr) { if(node == null) return; if(level == 1) System.out.print(node.data + \" \"); else if(level > 1) { if(ltr != false) { printGivenLevel(node.left, level - 1, ltr); printGivenLevel(node.right, level - 1, ltr); } else { printGivenLevel(node.right, level - 1, ltr); printGivenLevel(node.left, level - 1, ltr); } } } public static void main(String[] args) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(7); tree.root.left.right = new Node(6); tree.root.right.left = new Node(5); tree.root.right.right = new Node(4); System.out.println(\"Spiral order traversal of Binary Tree is \"); tree.printSpiral(tree.root); } }", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\nd) \n\n{ \n\ndata = d; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\n\n\n\nvoid\nprintSpiral(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\n\n\n\nboolean\nltr = \nfalse\n; \n\nfor\n(i = \n1\n; i <= h; i++) { \n\nprintGivenLevel(node, i, ltr); \n\n\n\n\nltr = !ltr; \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n{ \n\n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel, \nboolean\nltr) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) { \n\nif\n(ltr != \nfalse\n) { \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\n} \n\nelse\n{ \n\nprintGivenLevel(node.right, level - \n1\n, ltr); \n\nprintGivenLevel(node.left, level - \n1\n, ltr); \n\n} \n\n} \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n7\n); \n\ntree.root.left.right = \nnew\nNode(\n6\n); \n\ntree.root.right.left = \nnew\nNode(\n5\n); \n\ntree.root.right.right = \nnew\nNode(\n4\n); \n\nSystem.out.println(\n\"Spiral order traversal of Binary Tree is \"\n); \n\ntree.printSpiral(tree.root); \n\n} \n}", "index": 474, "complexity": "3"}
{"forwhile": "class Node { int data; Node left, right; Node(int item) { data = item; left = right; } } class BinaryTree { Node root; void reverseLevelOrder(Node node) { int h = height(node); int i = h; while (i >= 1) { printGivenLevel(node, i); i--; } } void printGivenLevel(Node node, int level) { if (node == null) return; if (level == 1) System.out.print(node.data + \" \"); else if (level > 1) { printGivenLevel(node.left, level - 1); printGivenLevel(node.right, level - 1); } } int height(Node node) { if (node == null) return 0; else { int lheight = height(node.left); int rheight = height(node.right); if (lheight > rheight) return lheight + 1; else return rheight + 1; } } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); tree.root = new Node(1); tree.root.left = new Node(2); tree.root.right = new Node(3); tree.root.left.left = new Node(4); tree.root.left.right = new Node(5); System.out.println(\"Level Order traversal of binary tree is : \"); tree.reverseLevelOrder(tree.root); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nvoid\nreverseLevelOrder(Node node) \n\n{ \n\nint\nh = height(node); \n\nint\ni; \n\nfor\n(i = h; i >= \n1\n; i--) \n\n\n\n{ \n\nprintGivenLevel(node, i); \n\n} \n\n} \n\n\n\n\nvoid\nprintGivenLevel(Node node, \nint\nlevel) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nif\n(level == \n1\n) \n\nSystem.out.print(node.data + \n\" \"\n); \n\nelse\nif\n(level > \n1\n) \n\n{ \n\nprintGivenLevel(node.left, level - \n1\n); \n\nprintGivenLevel(node.right, level - \n1\n); \n\n} \n\n} \n\n\n\n\nint\nheight(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n0\n; \n\nelse\n\n{ \n\n\n\nint\nlheight = height(node.left); \n\nint\nrheight = height(node.right); \n\n\n\n\nif\n(lheight > rheight) \n\nreturn\n(lheight + \n1\n); \n\nelse\n\nreturn\n(rheight + \n1\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\ntree.root = \nnew\nNode(\n1\n); \n\ntree.root.left = \nnew\nNode(\n2\n); \n\ntree.root.right = \nnew\nNode(\n3\n); \n\ntree.root.left.left = \nnew\nNode(\n4\n); \n\ntree.root.left.right = \nnew\nNode(\n5\n); \n\n\nSystem.out.println(\n\"Level Order traversal of binary tree is : \"\n); \n\ntree.reverseLevelOrder(tree.root); \n\n} \n}", "index": 475, "complexity": "3"}
{"forwhile": "class\nNode { \n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\nstatic\nint\npreIndex = \n0\n; \n\n\n\n\nNode buildTree(\nchar\nin[], \nchar\npre[], \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode tNode = \nnew\nNode(pre[preIndex++]); \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n\n\nint\ni = inStrt; \nwhile(i <= inEnd) { \n\nif\n(arr[i] == tNode.data) \n\nbreak\n; \n\ni++; \n\n} \n\n\n\n\ntNode.left = buildTree(in, pre, inStrt, i - \n1\n); \n\ntNode.right = buildTree(in, pre, i + \n1\n, inEnd); \n\n\nreturn\ntNode; \n\n} \n\n\n\n\n\n\n\nint\nsearch(\nchar\narr[], \nint\nstrt, \nint\nend, \nchar\nvalue) \n\n{ \n\nint\ni = strt; \nfor(; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\ni; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nchar\nin[] = \nnew\nchar\n[] { \n'D'\n, \n'B'\n, \n'E'\n, \n'A'\n, \n'F'\n, \n'C'\n}; \n\nchar\npre[] = \nnew\nchar\n[] { \n'A'\n, \n'B'\n, \n'D'\n, \n'E'\n, \n'C'\n, \n'F'\n}; \n\nint\nlen = in.length; \n\nNode root = tree.buildTree(in, pre, \n0\n, len - \n1\n); \n\n\n\n\nSystem.out.println(\n\"Inorder traversal of constructed tree is : \"\n); \n\n\ntree.printInorder(root); \n\n} \n}", "src": "class\nNode { \n\nchar\ndata; \n\nNode left, right; \n\n\nNode(\nchar\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree { \n\nNode root; \n\nstatic\nint\npreIndex = \n0\n; \n\n\n\n\nNode buildTree(\nchar\nin[], \nchar\npre[], \nint\ninStrt, \nint\ninEnd) \n\n{ \n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode tNode = \nnew\nNode(pre[preIndex++]); \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n\n\ntNode.left = buildTree(in, pre, inStrt, inIndex - \n1\n); \n\ntNode.right = buildTree(in, pre, inIndex + \n1\n, inEnd); \n\n\nreturn\ntNode; \n\n} \n\n\n\n\n\n\n\nint\nsearch(\nchar\narr[], \nint\nstrt, \nint\nend, \nchar\nvalue) \n\n{ \n\nint\ni; \n\nfor\n(i = strt; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\ni; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nchar\nin[] = \nnew\nchar\n[] { \n'D'\n, \n'B'\n, \n'E'\n, \n'A'\n, \n'F'\n, \n'C'\n}; \n\nchar\npre[] = \nnew\nchar\n[] { \n'A'\n, \n'B'\n, \n'D'\n, \n'E'\n, \n'C'\n, \n'F'\n}; \n\nint\nlen = in.length; \n\nNode root = tree.buildTree(in, pre, \n0\n, len - \n1\n); \n\n\n\n\nSystem.out.println(\n\"Inorder traversal of constructed tree is : \"\n); \n\ntree.printInorder(root); \n\n} \n}", "index": 476, "complexity": "3"}
{"forwhile": "class GFG { public static void ancestorMatrix(Node root , int[][] matrix, int size) { if(root==null) return; ancestorMatrix(root.left, matrix, size); ancestorMatrix(root.right, matrix, size); if(root.left != null) { matrix[root.data][root.left.data] = 1; int i = 0; while(i < size) { if(matrix[root.left.data][i] == 1) matrix[root.data][i] = 1; i++; } } if(root.right != null) { matrix[root.data][root.right.data] = 1; int i = 0; while(i < size) { if(matrix[root.right.data][i] == 1) matrix[root.data][i] = 1; i++; } } } public static void main(String[] args) { Node tree_root = new Node(5); tree_root.left = new Node (1); tree_root.right = new Node(2); tree_root.left.left = new Node(0); tree_root.left.right = new Node(4); tree_root.right.left = new Node(3); int size = 6; int matrix [][] = new int[size][size]; ancestorMatrix(tree_root, matrix, size); int i = 0; while(i < size) { int j = 0; while(j < size) { System.out.print(matrix[i][j]+ \" \"); j++; } System.out.println(); i++; } } static class Node { public int data ; public Node left ,right; public Node (int data) { this.data = data; this.left = this.right = null; } } }", "src": "class\nGFG \n{ \n\n\n\npublic\nstatic\nvoid\nancestorMatrix(Node root , \n\nint\nmatrix[][],\nint\nsize) \n\n{ \n\n\n\n\nif\n(root==\nnull\n) \n\nreturn\n; \n\n\n\n\nancestorMatrix(root.left, matrix, size); \n\n\n\n\nancestorMatrix(root.right, matrix, size); \n\n\n\n\n\n\n\nif\n(root.left != \nnull\n) \n\n{ \n\n\n\nmatrix[root.data][root.left.data] = \n1\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\n\n\n\n\n\n\nif\n(matrix[root.left.data][i] == \n1\n) \n\nmatrix[root.data][i] = \n1\n; \n\n} \n\n} \n\n\n\n\nif\n(root.right != \nnull\n) \n\n{ \n\nmatrix[root.data][root.right.data] = \n1\n; \n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nif\n(matrix[root.right.data][i]==\n1\n) \n\nmatrix[root.data][i] = \n1\n; \n\n} \n\n} \n\n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\n\nNode tree_root = \nnew\nNode(\n5\n); \n\ntree_root.left = \nnew\nNode (\n1\n); \n\ntree_root.right = \nnew\nNode(\n2\n); \n\ntree_root.left.left = \nnew\nNode(\n0\n); \n\ntree_root.left.right = \nnew\nNode(\n4\n); \n\ntree_root.right.left = \nnew\nNode(\n3\n); \n\n\n\n\nint\nsize = \n6\n; \n\nint\nmatrix [][] = \nnew\nint\n[size][size]; \n\n\nancestorMatrix(tree_root, matrix, size); \n\n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\n{ \n\nfor\n(\nint\nj = \n0\n; j < size; j++) \n\n{ \n\nSystem.out.print(matrix[i][j]+\n\" \"\n); \n\n} \n\nSystem.out.println(); \n\n} \n\n} \n\n\n\n\nstatic\nclass\nNode \n\n{ \n\npublic\nint\ndata ; \n\npublic\nNode left ,right; \n\npublic\nNode (\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nthis\n.left = \nthis\n.right = \nnull\n; \n\n} \n\n} \n}", "index": 477, "complexity": "3"}
{"forwhile": "class Node { int data; Node left, right; Node(int item) { data = item; left = right = null; } } class BinaryTree { Node root; Node buildTree(int inorder[], int start, int end, Node node) { if (start > end) return null; int i = max(inorder, start, end); node = new Node(inorder[i]); if (start == end) return node; node.left = buildTree(inorder, start, i - 1, node.left); node.right = buildTree(inorder, i + 1, end, node.right); return node; } int max(int arr[], int strt, int end) { int i, max = arr[strt], maxind = strt; while (i <= end) { if (arr[i] > max) { max = arr[i]; maxind = i; } i++; } return maxind; } void printInorder(Node node) { if (node == null) return; printInorder(node.left); System.out.print(node.data + \" \"); printInorder(node.right); } public static void main(String args[]) { BinaryTree tree = new BinaryTree(); int inorder[] = new int[]{5, 10, 40, 30, 28}; int len = inorder.length; Node mynode = tree.buildTree(inorder, 0, len - 1, tree.root); System.out.println(\"Inorder traversal of the constructed tree is \"); tree.printInorder(mynode); } }", "src": "class\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n\n\nNode(\nint\nitem) \n\n{ \n\ndata = item; \n\nleft = right = \nnull\n; \n\n} \n} \n\nclass\nBinaryTree \n{ \n\nNode root; \n\n\n\n\nNode buildTree(\nint\ninorder[], \nint\nstart, \nint\nend, Node node) \n\n{ \n\nif\n(start > end) \n\nreturn\nnull\n; \n\n\n\n\nint\ni = max(inorder, start, end); \n\n\n\n\nnode = \nnew\nNode(inorder[i]); \n\n\n\n\nif\n(start == end) \n\nreturn\nnode; \n\n\n\n\nnode.left = buildTree(inorder, start, i - \n1\n, node.left); \n\nnode.right = buildTree(inorder, i + \n1\n, end, node.right); \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\n\nint\nmax(\nint\narr[], \nint\nstrt, \nint\nend) \n\n{ \n\nint\ni, max = arr[strt], maxind = strt; \n\nfor\n(i = strt + \n1\n; i <= end; i++) \n\n{ \n\nif\n(arr[i] > max) \n\n{ \n\nmax = arr[i]; \n\nmaxind = i; \n\n} \n\n} \n\nreturn\nmaxind; \n\n} \n\n\n\n\nvoid\nprintInorder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\n\n\n\nprintInorder(node.left); \n\n\n\n\nSystem.out.print(node.data + \n\" \"\n); \n\n\n\n\nprintInorder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\n\n\n\nint\ninorder[] = \nnew\nint\n[]{\n5\n, \n10\n, \n40\n, \n30\n, \n28\n}; \n\nint\nlen = inorder.length; \n\nNode mynode = tree.buildTree(inorder, \n0\n, len - \n1\n, tree.root); \n\n\n\n\nSystem.out.println(\n\"Inorder traversal of the constructed tree is \"\n); \n\ntree.printInorder(mynode); \n\n} \n}", "index": 478, "complexity": "3"}
{"forwhile": "class Node { int data; Node left, right; public Node(int data) { this .data = data; left = right = null; } } class Index { int index; } class BinaryTree { Node buildUtil(int in[], int post[], int inStrt, int inEnd, Index pIndex) { if (inStrt > inEnd) return null; Node node = new Node(post[pIndex.index]); (pIndex.index)--; if (inStrt == inEnd) return node; int iIndex = search(in, inStrt, inEnd, node.data); node.right = buildUtil(in, post, iIndex + 1, inEnd, pIndex); node.left = buildUtil(in, post, inStrt, iIndex - 1, pIndex); return node; } Node buildTree(int in[], int post[], int n) { Index pIndex = new Index(); pIndex.index = n - 1; return buildUtil(in, post, 0, n - 1, pIndex); } int search(int arr[], int strt, int end, int value) { int i = strt; while(i <= end) { if (arr[i] == value) break; i++; } return i; } void preOrder(Node node) { if (node == null) return; System.out.print(node.data + ", "src": "class\nNode { \n\nint\ndata; \n\nNode left, right; \n\n\npublic\nNode(\nint\ndata) \n\n{ \n\nthis\n.data = data; \n\nleft = right = \nnull\n; \n\n} \n} \n\n\nclass\nIndex { \n\nint\nindex; \n} \n\nclass\nBinaryTree { \n\n\n\nNode buildUtil(\nint\nin[], \nint\npost[], \nint\ninStrt, \n\nint\ninEnd, Index pIndex) \n\n{ \n\n\n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode node = \nnew\nNode(post[pIndex.index]); \n\n(pIndex.index)--; \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\nnode; \n\n\n\n\nint\niIndex = search(in, inStrt, inEnd, node.data); \n\n\n\n\nnode.right = buildUtil(in, post, iIndex + \n1\n, inEnd, pIndex); \n\nnode.left = buildUtil(in, post, inStrt, iIndex - \n1\n, pIndex); \n\n\nreturn\nnode; \n\n} \n\n\n\n\n\n\nNode buildTree(\nint\nin[], \nint\npost[], \nint\nn) \n\n{ \n\nIndex pIndex = \nnew\nIndex(); \n\npIndex.index = n - \n1\n; \n\nreturn\nbuildUtil(in, post, \n0\n, n - \n1\n, pIndex); \n\n} \n\n\n\n\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n\n{ \n\nint\ni; \n\nfor\n(i = strt; i <= end; i++) { \n\nif\n(arr[i] == value) \n\nbreak\n; \n\n} \n\nreturn\ni; \n\n} \n\n\n\n\nvoid\npreOrder(Node node) \n\n{ \n\nif\n(node == \nnull\n) \n\nreturn\n; \n\nSystem.out.print(node.data + \n\" \"\n); \n\npreOrder(node.left); \n\npreOrder(node.right); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nBinaryTree tree = \nnew\nBinaryTree(); \n\nint\nin[] = \nnew\nint\n[] { \n4\n, \n8\n, \n2\n, \n5\n, \n1\n, \n6\n, \n3\n, \n7\n}; \n\nint\npost[] = \nnew\nint\n[] { \n8\n, \n4\n, \n5\n, \n2\n, \n6\n, \n7\n, \n3\n, \n1\n}; \n\nint\nn = in.length; \n\nNode root = tree.buildTree(in, post, n); \n\nSystem.out.println(\n\"Preorder of the constructed tree : \"\n); \n\ntree.preOrder(root); \n\n} \n}", "index": 479, "complexity": "3"}
{"forwhile": "class GfG { static int preIndex = 0; static class Node { int data; Node left, right; } static Node newNode(int data) { Node temp = new Node(); temp.data = data; temp.left = null; temp.right = null; return temp; } static int search(int arr[], int strt, int end, int value) { int i = strt; while(i <= end) { if(arr[i] == value) return i; i++; } return -1; } static Node buildTree(int in[], int pre[], int inStrt, int inEnd) { if(inStrt > inEnd) return null; Node tNode = newNode(pre[preIndex++]); if(inStrt == inEnd) return tNode; int inIndex = search(in, inStrt, inEnd, tNode.data); tNode.left = buildTree(in, pre, inStrt, inIndex - 1); tNode.right = buildTree(in, pre, inIndex + 1, inEnd); return tNode; } static int checkPostorder(Node node, int postOrder[], int index) { if(node == null) return index; index = checkPostorder(node.left,postOrder,index); index = checkPostorder(node.right,postOrder,index); if(node.data == postOrder[index]) index++; else return -1; return index; } public static void main(String[] args) { int inOrder[] = {4, 2, 5, 1, 3}; int preOrder[] = {1, 2, 4, 5, 3}; int postOrder[] = {4, 5, 2, 3, 1}; int len = inOrder.length; Node root = buildTree(inOrder, preOrder, 0, len - 1); int index = 0; for(; index != len; index = checkPostorder(root,postOrder,index)) { } if(index == len) System.out.println(\"Yes\"); else System.out.println(\"No\"); } }", "src": "class\nGfG { \n\nstatic\nint\npreIndex = \n0\n; \n\n\nstatic\nclass\nNode \n{ \n\nint\ndata; \n\nNode left, right; \n} \n\n\nstatic\nNode newNode(\nint\ndata) \n{ \n\nNode temp = \nnew\nNode(); \n\ntemp.data = data; \n\ntemp.left = \nnull\n; \n\ntemp.right = \nnull\n; \n\nreturn\ntemp; \n} \n\n\nstatic\nint\nsearch(\nint\narr[], \nint\nstrt, \nint\nend, \nint\nvalue) \n{ \n\nfor\n(\nint\ni = strt; i <= end; i++) \n\n{ \n\nif\n(arr[i] == value) \n\nreturn\ni; \n\n} \n\nreturn\n-\n1\n; \n} \n\n\nstatic\nNode buildTree(\nint\nin[], \nint\npre[], \nint\ninStrt, \nint\ninEnd) \n{ \n\n\nif\n(inStrt > inEnd) \n\nreturn\nnull\n; \n\n\n\n\nNode tNode = newNode(pre[preIndex++]); \n\n\n\n\nif\n(inStrt == inEnd) \n\nreturn\ntNode; \n\n\n\n\nint\ninIndex = search(in, inStrt, inEnd, tNode.data); \n\n\n\n\ntNode.left = buildTree(in, pre, inStrt, inIndex-\n1\n); \n\ntNode.right = buildTree(in, pre, inIndex+\n1\n, inEnd); \n\n\nreturn\ntNode; \n} \n\n\nstatic\nint\ncheckPostorder(Node node, \nint\npostOrder[], \nint\nindex) \n{ \n\nif\n(node == \nnull\n) \n\nreturn\nindex; \n\n\n\n\nindex = checkPostorder(node.left,postOrder,index); \n\n\n\n\nindex = checkPostorder(node.right,postOrder,index); \n\n\n\n\nif\n(node.data == postOrder[index]) \n\nindex++; \n\nelse\n\nreturn\n-\n1\n; \n\n\nreturn\nindex; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\ninOrder[] = {\n4\n, \n2\n, \n5\n, \n1\n, \n3\n}; \n\nint\npreOrder[] = {\n1\n, \n2\n, \n4\n, \n5\n, \n3\n}; \n\nint\npostOrder[] = {\n4\n, \n5\n, \n2\n, \n3\n, \n1\n}; \n\n\nint\nlen = inOrder.length; \n\n\n\n\n\n\nNode root = buildTree(inOrder, preOrder, \n0\n, len - \n1\n); \n\n\n\n\n\n\nint\nindex = checkPostorder(root,postOrder,\n0\n); \n\n\n\n\nif\n(index == len) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 483, "complexity": "3"}
{"forwhile": "class MST { private static final int V = 5; int minKey(int key[], Boolean mstSet[]) { int min = Integer.MAX_VALUE, min_index = -1; int v = 0; while(v < V) { if(mstSet[v] == false && key[v] < min) { min = key[v]; min_index = v; } v++; } return min_index; } void printMST(int parent[], int graph[][]) { System.out.println(\"Edge \\tWeight\"); int i = 1; while(i < V) { System.out.println(parent[i] + \" - \" + i + \"\\t\" + graph[i][parent[i]]); i++; } } void primMST(int graph[][]) { int parent[] = new int[V]; int key[] = new int[V]; Boolean mstSet[] = new Boolean[V]; int i = 0; while(i < V) { key[i] = Integer.MAX_VALUE; mstSet[i] = false; i++; } key[0] = 0; parent[0] = -1; int count = 0; while(count < V - 1) { int u = minKey(key, mstSet); mstSet[u] = true; int v = 0; while(v < V) { if(graph[u][v] != 0 && mstSet[v] == false && graph[u][v] < key[v]) { parent[v] = u; key[v] = graph[u][v]; } v++; } count++; } printMST(parent, graph); } public static void main(String[] args) { MST t = new MST(); int graph[][] = new int[][] { { 0, 2, 0, 6, 0}, { 2, 0, 3, 8, 5}, { 0, 3, 0, 0, 7}, { 6, 8, 0, 0, 9}, { 0, 5, 7, 9, 0 } }; t.primMST(graph); } }", "src": "class\nMST { \n\n\n\nprivate\nstatic\nfinal\nint\nV = \n5\n; \n\n\n\n\n\n\nint\nminKey(\nint\nkey[], Boolean mstSet[]) \n\n{ \n\n\n\nint\nmin = Integer.MAX_VALUE, min_index = -\n1\n; \n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\nif\n(mstSet[v] == \nfalse\n&& key[v] < min) { \n\nmin = key[v]; \n\nmin_index = v; \n\n} \n\n\nreturn\nmin_index; \n\n} \n\n\n\n\n\n\nvoid\nprintMST(\nint\nparent[], \nint\ngraph[][]) \n\n{ \n\nSystem.out.println(\n\"Edge \\tWeight\"\n); \n\nfor\n(\nint\ni = \n1\n; i < V; i++) \n\nSystem.out.println(parent[i] + \n\" - \"\n+ i + \n\"\\t\"\n+ graph[i][parent[i]]); \n\n} \n\n\n\n\n\n\nvoid\nprimMST(\nint\ngraph[][]) \n\n{ \n\n\n\nint\nparent[] = \nnew\nint\n[V]; \n\n\n\n\nint\nkey[] = \nnew\nint\n[V]; \n\n\n\n\nBoolean mstSet[] = \nnew\nBoolean[V]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < V; i++) { \n\nkey[i] = Integer.MAX_VALUE; \n\nmstSet[i] = \nfalse\n; \n\n} \n\n\n\n\nkey[\n0\n] = \n0\n; \n\n\n\n\nparent[\n0\n] = -\n1\n; \n\n\n\n\n\nfor\n(\nint\ncount = \n0\n; count < V - \n1\n; count++) { \n\n\n\n\n\nint\nu = minKey(key, mstSet); \n\n\n\n\nmstSet[u] = \ntrue\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\n\n\n\n\n\n\n\nif\n(graph[u][v] != \n0\n&& mstSet[v] == \nfalse\n&& graph[u][v] < key[v]) { \n\nparent[v] = u; \n\nkey[v] = graph[u][v]; \n\n} \n\n} \n\n\n\n\nprintMST(parent, graph); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nMST t = \nnew\nMST(); \n\nint\ngraph[][] = \nnew\nint\n[][] { { \n0\n, \n2\n, \n0\n, \n6\n, \n0\n}, \n\n{ \n2\n, \n0\n, \n3\n, \n8\n, \n5\n}, \n\n{ \n0\n, \n3\n, \n0\n, \n0\n, \n7\n}, \n\n{ \n6\n, \n8\n, \n0\n, \n0\n, \n9\n}, \n\n{ \n0\n, \n5\n, \n7\n, \n9\n, \n0\n} }; \n\n\n\n\nt.primMST(graph); \n\n} \n}", "index": 484, "complexity": "3"}
{"forwhile": "class ShortestPath  {\n\n\n\n\n\nstatic final int V= 9 ; \n\nint minDistance( int dist[], Boolean sptSet[]) {\n\n\nint min = Integer.MAX_VALUE, min_index=- 1 ; \n\nint v = 0 ; \nwhile(v < V) \n\nif (sptSet[v] == false && dist[v] <= min) {\n\nmin = dist[v]; \n\nmin_index = v; \n\n} \n\n\nreturn min_index; \n\n} \n\n\n\n\nvoid printSolution( int dist[], int n) {\n\nSystem.out.println( \"Vertex Distance \"); \n\nint i = 0 ; \nwhile(i < V) \n\nSystem.out.println(i+ \" tt \"+dist[i]); \n\n} \n\n\n\n\n\n\n\n\nvoid dijkstra( int graph[][], int src) {\n\nint dist[] = new int[V]; \n\nBoolean sptSet[] = new Boolean[V]; \n\nint i = 0 ; \nwhile(i < V) \n\n{\n\ndist[i] = Integer.MAX_VALUE; \n\nsptSet[i] = false ; \n\n} \n\n\n\ndist[src] = 0 ; \n\nint count = 0 ; \nwhile(count < V- 1) \n\n{\n\nint u = minDistance(dist, sptSet); \n\nsptSet[u] = true ; \n\nint v = 0 ; \nwhile(v < V) \n\n\n\n\n\n\n\n\nif (!sptSet[v] && graph[u][v]!= 0 && \n\ndist[u] != Integer.MAX_VALUE && \n\ndist[u]+graph[u][v] < dist[v]) \n\ndist[v] = dist[u] + graph[u][v]; \n\nv++ ; \n\n\n\n\n}\n\n\n\n\nprintSolution(dist, V); \n\n} \n\n\n\n\npublic static void main (String[] args) {\n\n\n\nint graph[][] = new int [][]{{ 0 , 4 , 0 , 0 , 0 , 0 , 0 , 8 , 0 }, \n\n{ 4 , 0 , 8 , 0 , 0 , 0 , 0 , 11 , 0 }, \n\n{ 0 , 8 , 0 , 7 , 0 , 4 , 0 , 0 , 2 }, \n\n{ 0 , 0 , 7 , 0 , 9 , 14 , 0 , 0 , 0 }, \n\n{ 0 , 0 , 0 , 9 , 0 , 10 , 0 , 0 , 0 }, \n\n{ 0 , 0 , 4 , 14 , 10 , 0 , 2 , 0 , 0 }, \n\n{ 0 , 0 , 0 , 0 , 0 , 2 , 0 , 1 , 6 }, \n\n{ 8 , 11 , 0 , 0 , 0 , 0 , 1 , 0 , 7 }, \n\n{ 0 , 0 , 2 , 0 , 0 , 0 , 6 , 7 , 0} \n\n}; \n\nShortestPath t = new ShortestPath(); \n\nt.dijkstra(graph, 0); \n\n} \n}", "src": "class\nShortestPath \n{ \n\n\n\n\n\nstatic\nfinal\nint\nV=\n9\n; \n\nint\nminDistance(\nint\ndist[], Boolean sptSet[]) \n\n{ \n\n\n\nint\nmin = Integer.MAX_VALUE, min_index=-\n1\n; \n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\nif\n(sptSet[v] == \nfalse\n&& dist[v] <= min) \n\n{ \n\nmin = dist[v]; \n\nmin_index = v; \n\n} \n\n\nreturn\nmin_index; \n\n} \n\n\n\n\nvoid\nprintSolution(\nint\ndist[], \nint\nn) \n\n{ \n\nSystem.out.println(\n\"Vertex Distance \"\n); \n\nfor\n(\nint\ni = \n0\n; i < V; i++) \n\nSystem.out.println(i+\n\" tt \"\n+dist[i]); \n\n} \n\n\n\n\n\n\n\n\nvoid\ndijkstra(\nint\ngraph[][], \nint\nsrc) \n\n{ \n\nint\ndist[] = \nnew\nint\n[V]; \n\n\n\n\n\n\n\n\n\nBoolean sptSet[] = \nnew\nBoolean[V]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < V; i++) \n\n{ \n\ndist[i] = Integer.MAX_VALUE; \n\nsptSet[i] = \nfalse\n; \n\n} \n\n\n\n\ndist[src] = \n0\n; \n\n\n\n\nfor\n(\nint\ncount = \n0\n; count < V-\n1\n; count++) \n\n{ \n\n\n\n\n\n\n\nint\nu = minDistance(dist, sptSet); \n\n\n\n\nsptSet[u] = \ntrue\n; \n\n\n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; v++) \n\n\n\n\n\n\n\n\nif\n(!sptSet[v] && graph[u][v]!=\n0\n&& \n\ndist[u] != Integer.MAX_VALUE && \n\ndist[u]+graph[u][v] < dist[v]) \n\ndist[v] = dist[u] + graph[u][v]; \n\n} \n\n\n\n\nprintSolution(dist, V); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\nint\ngraph[][] = \nnew\nint\n[][]{{\n0\n, \n4\n, \n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n8\n, \n0\n}, \n\n{\n4\n, \n0\n, \n8\n, \n0\n, \n0\n, \n0\n, \n0\n, \n11\n, \n0\n}, \n\n{\n0\n, \n8\n, \n0\n, \n7\n, \n0\n, \n4\n, \n0\n, \n0\n, \n2\n}, \n\n{\n0\n, \n0\n, \n7\n, \n0\n, \n9\n, \n14\n, \n0\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n0\n, \n9\n, \n0\n, \n10\n, \n0\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n4\n, \n14\n, \n10\n, \n0\n, \n2\n, \n0\n, \n0\n}, \n\n{\n0\n, \n0\n, \n0\n, \n0\n, \n0\n, \n2\n, \n0\n, \n1\n, \n6\n}, \n\n{\n8\n, \n11\n, \n0\n, \n0\n, \n0\n, \n0\n, \n1\n, \n0\n, \n7\n}, \n\n{\n0\n, \n0\n, \n2\n, \n0\n, \n0\n, \n0\n, \n6\n, \n7\n, \n0\n} \n\n}; \n\nShortestPath t = \nnew\nShortestPath(); \n\nt.dijkstra(graph, \n0\n); \n\n} \n}", "index": 485, "complexity": "3"}
{"forwhile": "class GFG { static int maximumSum(int arr[], int n, int k) { int i = 1; while(i <= k) { int min = +2147483647; int index = -1; int j = 0; while(j < n) { if(arr[j] < min) { min = arr[j]; index = j; } j++; } if(min == 0) break; arr[index] = -arr[index]; i++; } int sum = 0; int i = 0; for(; i < n; i++) sum += arr[i]; return sum; } public static void main(String arg[]) { int arr[] = {-2, 0, 5, -1, 2}; int k = 4; int n = arr.length; System.out.print(maximumSum(arr, n, k)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nmaximumSum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nfor\n(\nint\ni = \n1\n; i <= k; i++) \n\n{ \n\nint\nmin = +\n2147483647\n; \n\nint\nindex = -\n1\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj=\n0\n; j<n; j++) \n\n{ \n\nif\n(arr[j] < min) \n\n{ \n\nmin = arr[j]; \n\nindex = j; \n\n} \n\n} \n\n\n\n\n\n\n\n\nif\n(min == \n0\n) \n\nbreak\n; \n\n\n\n\narr[index] = -arr[index]; \n\n} \n\n\n\n\nint\nsum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nsum += arr[i]; \n\nreturn\nsum; \n\n} \n\n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\narr[] = {-\n2\n, \n0\n, \n5\n, -\n1\n, \n2\n}; \n\nint\nk = \n4\n; \n\nint\nn = arr.length; \n\nSystem.out.print(maximumSum(arr, n, k)); \n\n} \n}", "index": 486, "complexity": "3"}
{"forwhile": "class GFG { static void minimizeWithKSwaps(int arr[], int n, int k) { int i = 0; while(i < n-1 && k > 0) { int pos = i; int j = i+1; while(j < n) { if(j - i > k) break; if(arr[j] < arr[pos]) pos = j; j++; } int temp; for(int j = pos; j > i; j--) { temp=arr[j]; arr[j]=arr[j-1]; arr[j-1]=temp; } k -= pos-i; i++; } } public static void main(String[] args) { int arr[] = {7, 6, 9, 2, 1}; int n = arr.length; int k = 3; minimizeWithKSwaps(arr, n, k); for(int i=0; i<n; i++) System.out.print(arr[i] + \" \"); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nvoid\nminimizeWithKSwaps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n-\n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n\n\n\n\nint\npos = i; \n\nfor\n(\nint\nj = i+\n1\n; j < n ; ++j) \n\n{ \n\n\n\n\n\n\nif\n(j - i > k) \n\nbreak\n; \n\n\n\n\n\n\nif\n(arr[j] < arr[pos]) \n\npos = j; \n\n} \n\n\n\n\n\n\nint\ntemp; \n\n\nfor\n(\nint\nj = pos; j>i; --j) \n\n{ \n\ntemp=arr[j]; \n\narr[j]=arr[j-\n1\n]; \n\narr[j-\n1\n]=temp; \n\n} \n\n\n\n\n\n\nk -= pos-i; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\narr[] = {\n7\n, \n6\n, \n9\n, \n2\n, \n1\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nminimizeWithKSwaps(arr, n, k); \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; ++i) \n\nSystem.out.print(arr[i] +\n\" \"\n); \n\n} \n}", "index": 487, "complexity": "3"}
{"forwhile": "class GFG  { static void SwapInts( int array[],  int position1,  int position2) {  int temp = array[position1];  array[position1] = array[position2];  array[position2] = temp; } static void KSwapMaximum( int[]arr,  int n,  int k) {  int i = 0;  while(i < n - 1 && k > 0) {  int indexPosition = i;  int j = i + 1;  while(j < n) {  if(k <= j - i) break;  if(arr[j] > arr[indexPosition]) indexPosition = j; j++; }  int j = indexPosition; while(j > i) { SwapInts(arr, j, j - 1); j--; }  k -= indexPosition - i; i++; } } public static void main(String args[]) {  int[]arr = { 3 , 5 , 4 , 1 , 2 };  int n = arr.length;  int k = 3;  KSwapMaximum(arr, n, k);  int i = 0; for(; i < n; i++) System.out.print(arr[i] + \" \"); } }", "src": "class\nGFG \n{ \n\nstatic\nvoid\nSwapInts(\nint\narray[], \n\nint\nposition1, \n\nint\nposition2) \n\n{ \n\n\n\n\n\n\n\n\n\n\nint\ntemp = array[position1]; \n\n\n\n\n\n\narray[position1] = array[position2]; \n\n\n\n\n\n\narray[position2] = temp; \n\n} \n\n\n\n\n\n\nstatic\nvoid\nKSwapMaximum(\nint\n[]arr, \n\nint\nn, \nint\nk) \n\n{ \n\nfor\n(\nint\ni = \n0\n; \n\ni < n - \n1\n&& k > \n0\n; ++i) \n\n{ \n\n\n\n\n\n\n\n\n\n\nint\nindexPosition = i; \n\nfor\n(\nint\nj = i + \n1\n; j < n; ++j) \n\n{ \n\n\n\n\n\n\n\n\nif\n(k <= j - i) \n\nbreak\n; \n\n\n\n\n\n\n\n\n\n\nif\n(arr[j] > arr[indexPosition]) \n\nindexPosition = j; \n\n} \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = indexPosition; j > i; --j) \n\nSwapInts(arr, j, j - \n1\n); \n\n\n\n\n\n\nk -= indexPosition - i; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[]arr = { \n3\n, \n5\n, \n4\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nint\nk = \n3\n; \n\n\nKSwapMaximum(arr, n, k); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n}", "index": 488, "complexity": "3"}
{"forwhile": "class Graph { private int V; private LinkedList<Integer> adj[]; Graph(int v) { V = v; adj = new LinkedList[v]; int i = 0; while (i < v) { adj[i] = new LinkedList(); i++; } } void addEdge(int v, int w) { adj[v].add(w); adj[w].add(v); } void greedyColoring() { int result[] = new int[V]; Arrays.fill(result, -1); result[0] = 0; boolean available[] = new boolean[V]; Arrays.fill(available, true); int u = 1; while (u < V) { Iterator<Integer> it = adj[u].iterator(); while (it.hasNext()) { int i = it.next(); if (result[i] != -1) available[result[i]] = false; } int cr; for (cr = 0; cr < V; cr++) { if (available[cr]) break; } result[u] = cr; Arrays.fill(available, true); u++; } u = 0; while (u < V) { System.out.println(\"Vertex \" + u + \" ---> Color \" + result[u]); u++; } } public static void main(String args[]) { Graph g1 = new Graph(5); g1.addEdge(0, 1); g1.addEdge(0, 2); g1.addEdge(1, 2); g1.addEdge(1, 3); g1.addEdge(2, 3); g1.addEdge(3, 4); System.out.println(\"Coloring of graph 1\"); g1.greedyColoring(); System.out.println(); Graph g2 = new Graph(5); g2.addEdge(0, 1); g2.addEdge(0, 2); g2.addEdge(1, 2); g2.addEdge(1, 4); g2.addEdge(2, 4); g2.addEdge(4, 3); System.out.println(\"Coloring of graph 2 \"); g2.greedyColoring(); } }", "src": "class\nGraph \n{ \n\nprivate\nint\nV; \n\n\nprivate\nLinkedList<Integer> adj[]; \n\n\n\n\n\nGraph(\nint\nv) \n\n{ \n\nV = v; \n\nadj = \nnew\nLinkedList[v]; \n\nfor\n(\nint\ni=\n0\n; i<v; ++i) \n\nadj[i] = \nnew\nLinkedList(); \n\n} \n\n\n\n\nvoid\naddEdge(\nint\nv,\nint\nw) \n\n{ \n\nadj[v].add(w); \n\nadj[w].add(v); \n\n\n} \n\n\n\n\n\n\nvoid\ngreedyColoring() \n\n{ \n\nint\nresult[] = \nnew\nint\n[V]; \n\n\n\n\nArrays.fill(result, -\n1\n); \n\n\n\n\nresult[\n0\n] = \n0\n; \n\n\n\n\n\n\n\n\nboolean\navailable[] = \nnew\nboolean\n[V]; \n\n\n\n\nArrays.fill(available, \ntrue\n); \n\n\n\n\nfor\n(\nint\nu = \n1\n; u < V; u++) \n\n{ \n\n\n\n\n\nIterator<Integer> it = adj[u].iterator() ; \n\nwhile\n(it.hasNext()) \n\n{ \n\nint\ni = it.next(); \n\nif\n(result[i] != -\n1\n) \n\navailable[result[i]] = \nfalse\n; \n\n} \n\n\n\n\nint\ncr; \n\nfor\n(cr = \n0\n; cr < V; cr++){ \n\nif\n(available[cr]) \n\nbreak\n; \n\n} \n\n\nresult[u] = cr; \n\n\n\n\n\nArrays.fill(available, \ntrue\n); \n\n} \n\n\n\n\nfor\n(\nint\nu = \n0\n; u < V; u++) \n\nSystem.out.println(\n\"Vertex \"\n+ u + \n\" ---> Color \"\n\n+ result[u]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nGraph g1 = \nnew\nGraph(\n5\n); \n\ng1.addEdge(\n0\n, \n1\n); \n\ng1.addEdge(\n0\n, \n2\n); \n\ng1.addEdge(\n1\n, \n2\n); \n\ng1.addEdge(\n1\n, \n3\n); \n\ng1.addEdge(\n2\n, \n3\n); \n\ng1.addEdge(\n3\n, \n4\n); \n\nSystem.out.println(\n\"Coloring of graph 1\"\n); \n\ng1.greedyColoring(); \n\n\nSystem.out.println(); \n\nGraph g2 = \nnew\nGraph(\n5\n); \n\ng2.addEdge(\n0\n, \n1\n); \n\ng2.addEdge(\n0\n, \n2\n); \n\ng2.addEdge(\n1\n, \n2\n); \n\ng2.addEdge(\n1\n, \n4\n); \n\ng2.addEdge(\n2\n, \n4\n); \n\ng2.addEdge(\n4\n, \n3\n); \n\nSystem.out.println(\n\"Coloring of graph 2 \"\n); \n\ng2.greedyColoring(); \n\n} \n}", "index": 489, "complexity": "3"}
{"forwhile": "class GFG { static final int N = 3; static int getMin(int arr[]) { int minInd = 0; int i = 1; while(i < N) { if(arr[i] < arr[minInd]) minInd = i; i++; } return minInd; } static int getMax(int arr[]) { int maxInd = 0; int i = 1; while(i < N) { if(arr[i] > arr[maxInd]) maxInd = i; i++; } return maxInd; } static int minOf2(int x, int y) { return (x < y) ? x : y; } static void minCashFlowRec(int amount[]) { int mxCredit = getMax(amount), mxDebit = getMin(amount); if(amount[mxCredit] == 0 && amount[mxDebit] == 0) return; int min = minOf2(-amount[mxDebit], amount[mxCredit]); amount[mxCredit] -= min; amount[mxDebit] += min; System.out.println(\"Person \" + mxDebit + \" pays \" + min + \" to \" + \"Person \" + mxCredit); minCashFlowRec(amount); } static void minCashFlow(int graph[][]) { int amount[] = new int[N]; for(int p = 0; p < N; p++) for(int i = 0; i < N; i++) { amount[p] += (graph[i][p] - graph[p][i]); } minCashFlowRec(amount); } public static void main(String[] args) { int graph[][] = { {0, 1000, 2000}, {0, 0, 5000}, {0, 0, 0}, }; minCashFlow(graph); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nfinal\nint\nN = \n3\n; \n\n\n\n\n\n\nstatic\nint\ngetMin(\nint\narr[]) \n\n{ \n\nint\nminInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] < arr[minInd]) \n\nminInd = i; \n\nreturn\nminInd; \n\n} \n\n\n\n\n\n\nstatic\nint\ngetMax(\nint\narr[]) \n\n{ \n\nint\nmaxInd = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\nif\n(arr[i] > arr[maxInd]) \n\nmaxInd = i; \n\nreturn\nmaxInd; \n\n} \n\n\n\n\nstatic\nint\nminOf2(\nint\nx, \nint\ny) \n\n{ \n\nreturn\n(x < y) ? x: y; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nminCashFlowRec(\nint\namount[]) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint\nmxCredit = getMax(amount), mxDebit = getMin(amount); \n\n\n\n\n\n\nif\n(amount[mxCredit] == \n0\n&& amount[mxDebit] == \n0\n) \n\nreturn\n; \n\n\n\n\nint\nmin = minOf2(-amount[mxDebit], amount[mxCredit]); \n\namount[mxCredit] -= min; \n\namount[mxDebit] += min; \n\n\n\n\nSystem.out.println(\n\"Person \"\n+ mxDebit + \n\" pays \"\n+ min \n\n+ \n\" to \"\n+ \n\"Person \"\n+ mxCredit); \n\n\n\n\n\n\n\n\n\n\n\n\nminCashFlowRec(amount); \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nvoid\nminCashFlow(\nint\ngraph[][]) \n\n{ \n\n\n\n\n\nint\namount[]=\nnew\nint\n[N]; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\np = \n0\n; p < N; p++) \n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\namount[p] += (graph[i][p] - graph[p][i]); \n\n\nminCashFlowRec(amount); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\n\n\nint\ngraph[][] = { {\n0\n, \n1000\n, \n2000\n}, \n\n{\n0\n, \n0\n, \n5000\n}, \n\n{\n0\n, \n0\n, \n0\n},}; \n\n\n\n\nminCashFlow(graph); \n\n} \n}", "index": 490, "complexity": "3"}
{"forwhile": "class Main  {  static void minAbsSumPair( int arr[], int arr_size)  {  int inv_count = 0 ;  int l, r, min_sum, sum, min_l, min_r;  if (arr_size < 2 )  {  System.out.println( \"Invalid Input\" );  return ;  }  min_l = 0 ;  min_r = 1 ;  min_sum = arr[ 0 ] + arr[ 1 ];  l = 0 ;  while (l < arr_size - 1 )  {  r = l+ 1 ;  while (r < arr_size)  {  sum = arr[l] + arr[r];  if (Math.abs(min_sum) > Math.abs(sum))  {  min_sum = sum;  min_l = l;  min_r = r;  }  r++; }  l++; }  System.out.println( \" The two elements whose \"+ \"sum is minimum are \"+ arr[min_l]+ \" and \"+arr[min_r]);  }  public static void main (String[] args)  {  int arr[] = { 1 , 60 , - 10 , 70 , - 80 , 85 };  minAbsSumPair(arr, 6 );  } } ", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n}", "index": 491, "complexity": "3"}
{"forwhile": "class GFG { static void printPrevSmaller(int []arr, int n) { System.out.print( \", \"); int i = 1; while(i < n) { int j; j = i - 1; while(j >= 0) { if(arr[j] < arr[i]) { System.out.print(arr[j] + \", \"); break; } j--; } if(j == -1) System.out.print( \", \") ; i++; } } public static void main (String[] args) { int []arr = {1, 3, 0, 2, 5}; int n = arr.length; printPrevSmaller(arr, n); } }", "src": "class\nGFG { \n\n\n\nstatic\nvoid\nprintPrevSmaller(\nint\n[]arr, \nint\nn) \n{ \n\n\n\n\n\n\nSystem.out.print( \n\"_, \"\n); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\nint\nj; \n\nfor\n(j = i - \n1\n; j >= \n0\n; j--) \n\n{ \n\nif\n(arr[j] < arr[i]) \n\n{ \n\nSystem.out.print(arr[j] + \n\", \"\n); \n\nbreak\n; \n\n} \n\n} \n\n\n\n\n\n\nif\n(j == -\n1\n) \n\nSystem.out.print( \n\"_, \"\n) ; \n\n} \n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]arr = {\n1\n, \n3\n, \n0\n, \n2\n, \n5\n}; \n\nint\nn = arr.length; \n\nprintPrevSmaller(arr, n); \n\n} \n}", "index": 492, "complexity": "3"}
{"forwhile": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint[] arr = new int [n];\n\t\tint maxindex=0;\n\t\tint minindex=0;\n\t\tint max;\n\t\tint min;\n\t\tint i=0;\n\t\twhile(i<arr.length) {\n\t\t\tarr[i]=sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tint k=Integer.MAX_VALUE;\n\t\tint i=0;\n\t\twhile(i<arr.length) {\n\t\t\tint j=i;\n\t\t\twhile(j<arr.length) {\n\t\t\t\tif(i!=j) {\n\t\t\t\t\tint k1=Math.min(arr[i], arr[j])/Math.abs(i-j);\n\t\t\t\t\tif(k1<k) {\n\t\t\t\t\t\tk = k1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(k);\n\t}\n\n}", "src": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint[] arr = new int [n];\n\t\tint maxindex=0;\n\t\tint minindex=0;\n\t\tint max;\n\t\tint min;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tarr[i]=sc.nextInt();\n\t\t}\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor(int i=0;i<arr.length;i++) {\n\t\t\tfor(int j=i;j<arr.length;j++) {\n\t\t\t\tif(i!=j) {\n\t\t\t\t\tint k1=Math.min(arr[i], arr[j])/Math.abs(i-j);\n\t\t\t\t\tif(k1<k) {\n\t\t\t\t\t\tk = k1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(k);\n\t}\n\n}", "index": 493, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class hi {\n    public static void main(String[] args) throws IOException{\n        Reader in=new Reader();\n\t\tPrintWriter w = new PrintWriter(System.out);\n\t\tint n=in.nextInt();\n\t\tint[] arr=in.nextIntArray(n);\n\t\tint k=Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tint a=(int)Math.floor((Math.min(arr[i],arr[j])/Math.abs(i-j)));\n\t\t\t\tif(a < k)\n\t\t\t\t\tk=a;\n\t\t\t}\n\t\t}\n\t\tw.println(k);\n        w.close();\n        return;\n\t}\n\t\n}\n\n\nclass Reader \n\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\t\tpublic String nextLine() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n        public String next() throws IOException{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\t\tpublic int nextInt() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} while ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n        } \n        public int[] nextIntArray(int n) throws IOException{\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n            }\n\n\t\t\treturn a;\n\t\t}\n\t\tpublic long nextLong() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic double nextDouble() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n\n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n\n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n        } \n        public boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n    }", "index": 494, "complexity": "3"}
{"forwhile": "public class PartySweet {\n    static BufferedReader br;\n    static StringTokenizer tokenizer;\n\n    public static void main(String[] args) throws Exception {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int n = nextInt(), m = nextInt();\n        int[] b = new int[n];\n        int[] g = new int[m];\n        int i = 0;\n        while(i < n) {\n            b[i] = nextInt();\n            i++;\n        }\n        int j = 0;\n        while(j < m) {\n            g[j] = nextInt();\n            j++;\n        }\n        int total = 0;\n        int max = 0, max2 = 0;\n        i = 0;\n        while(i < n) {\n            if(b[i] > b[max]) {\n                max2 = max;\n                max = i;\n            }\n            else if(b[max2] < b[i])\n                max2 = i;\n            i++;\n        }\n        total += b[max] - b[max2];\n        i = 0;\n        while(i < n) {\n            j = 0;\n            while(j < m) {\n                if(b[i] > g[j]) {\n                    System.out.println(-1);\n                    return;\n                }\n                if(i != max)\n                    total += b[i];\n                else\n                    total += g[j];\n                j++;\n            }\n            i++;\n        }\n        System.out.println(total);\n    }\n\n    public static String next() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            String line = br.readLine();\n            if (line == null)\n                throw new IOException();\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n}", "src": "public class PartySweet {\n\tstatic BufferedReader br;\n\tstatic StringTokenizer tokenizer;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = nextInt(), m = nextInt();\n\t\tint[] b = new int[n];\n\t\tint[] g = new int[m];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tb[i] = nextInt();\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tg[i] = nextInt();\n\t\tint total = 0;\n\t\tint max = 0, max2 = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(b[i] > b[max]) {\n\t\t\t\tmax2 = max;\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t\telse if(b[max2] < b[i])\n\t\t\t\tmax2 = i;\n\t\t}\n\t\ttotal += b[max] - b[max2];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(b[i] > g[j]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(i != max)\n\t\t\t\t\ttotal += b[i];\n\t\t\t\telse\n\t\t\t\t\ttotal += g[j];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(total);\n\t}\n\n\tpublic static String next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tthrow new IOException();\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "index": 495, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "index": 496, "complexity": "3"}
{"forwhile": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        int i=0;\n        while(i<s.length()){\n            wtArray[i]=s.charAt(i)-96;\n            i++;\n        }\n        int i=1;\n        while(i<n){\n            int j=0;\n            while(j<n-i){\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n                j++;\n            }\n            i++;\n        }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "src": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "index": 497, "complexity": "3"}
{"forwhile": "public class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}\n            catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        int i = 0;\n        while(i < m) {\n            a[sc.nextInt()]++;\n            i++;\n        }\n\n        int i1 = 1;\n        while(i1 <= 100) {\n            int y = 0;\n            int[] x = a;\n            for(int j = 0; j < x.length; j++) {\n                y += x[j] / i1;\n            }\n            if(y >= n) {\n                ans = i1;\n            }\n            i1++;\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "src": "public class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "index": 498, "complexity": "3"}
{"forwhile": "public class G {\n\npublic static void main(String[] args) {\nScanner in = new Scanner(System.in);\nint n, m;\nn = in.nextInt();\nm = in.nextInt();\nint[] a = new int[m];\nint i = 0;\nwhile (i < m) {\na[i] = in.nextInt();\ni++;\n}\n\nArrays.sort(a);\nHashMap<Integer, Integer> map = new HashMap<>(200);\nfor(Integer i : a) {\nInteger t = map.get(i);\nwhile (t == null) {\nmap.put(i, 1);\nt = 1;\n}\nwhile (t != null) {\nmap.put(i, t + 1);\nt += 1;\n}\n}\n\nArrayList<Food> list = new ArrayList<>(100);\nfor(Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator(); it.hasNext();) {\nMap.Entry<Integer, Integer> en = it.next();\nlist.add(new Food(en.getKey(), en.getValue()));\n}\n\nlist.sort(Comparator.comparingInt(o -> o.num));\nint min, max;\nmin = 1;\nmax = list.get(list.size() - 1).num;\nint res = 0;\nfor(int i = min; i <= max; i++) {\nint t = 0;\nfor(Food food : list) {\nint gaven = food.num / i;\nwhile (gaven >= 1) {\nt += gaven;\nif (t >= n) {\nres = Math.max(res, i);\nbreak;\n}\ngaven--;\n}\n}\n}\nSystem.out.println(res);\n}\n}\n\nclass Food {\nint id;\nint num;\n\npublic Food(int id, int num) {\nthis.id = id;\nthis.num = num;\n}\n\n@Override\npublic String toString() {\nreturn \"Food{\" +\n\"id=\" + id +\n\", num=\" + num +\n'}';\n}\n}", "src": "public class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n\n\n\n\n\n\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "index": 499, "complexity": "3"}
{"forwhile": "public class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tint i = 0;\n\t\twhile (i < b.length) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tint j = 0;\n\t\twhile (j < b.length) {\n\t\t\tb[j] = sc.nextInt();\n\t\t\tj++;\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\tfor( ; ia < LEN && a[ia] == 0; ia++ );\n\t\tfor( ; ib < LEN && b[ib] == 0; ib++ );\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\tfor( ; ia < LEN && ib < LEN; ){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\tfor( ; ib < LEN && b[ib] != a[ia]; ib++ );\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}", "src": "public class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\twhile(ia<LEN && a[ia]==0) ia++;\n\t\twhile(ib<LEN && b[ib]==0) ib++;\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\twhile(ia<LEN && ib<LEN){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\twhile(ib<LEN && b[ib]!=a[ia]){\n\t\t\t\t\t\tib++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}", "index": 500, "complexity": "3"}
{"forwhile": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        for(;i<N;){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            int i=0;\n            while(i<N){\n                a[i] = Integer.parseInt(tb.nextToken());\n                i++;\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        for(;num++<4;){\n            int i=0;\n            while(i<N){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    int j=0;\n                    while(j<N){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                        j++;\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n                i++;\n            }\n            int i=0;\n            while(i<N){\n                a[i] = b[i];\n                i++;\n            }\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "src": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "index": 501, "complexity": "3"}
{"forwhile": "public class Cr500 {\npublic static void main(String args[]) {\nScanner scanner = new Scanner(System.in);\nint n, x, status = -1;\nSet<Integer> a = new HashSet<>(), bitA = new HashSet<>();\nArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\nn = scanner.nextInt();\nx = scanner.nextInt();\n\nint i = 0;\nwhile(i < n) {\nint v;\nif(!a.add(v = scanner.nextInt())) {\nSystem.out.println(0);\nreturn;\n}\n\nif(!bitA.add(v & x)) {\nstatus = 2;\n}\nal.add(v);\nbl.add(v & x);\ni++;\n}\n\nif(contains(al, bl)) {\nSystem.out.println(1);\nreturn;\n}\n\nSystem.out.println(status);\n}\n\nprivate static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\nfor(int i = 0; i < a.size(); i++) {\nint v1 = a.get(i);\nfor(int j = 0; j < b.size(); j++) {\nint v2 = b.get(j);\nif(i != j && v1 == v2) {\nreturn true;\n}\n}\n}\nreturn false;\n}\n}", "src": "public class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "index": 502, "complexity": "3"}
{"forwhile": "public class B {\npublic static void main(String[] args) {\nScanner scanner = new Scanner(System.in);\nint n = scanner.nextInt();\nint x = scanner.nextInt();\nint[] a = new int[n];\nint i = 0;\nwhile(i < n) {\na[i] = scanner.nextInt();\ni++;\n}\nArrays.sort(a);\nList<Integer> list = new ArrayList<>();\ni = 0;\nwhile(i < n) {\nlist.add(a[i]);\ni++;\n}\ni = 0;\nwhile(i < n - 1) {\nif (a[i] == a[i + 1]) {\nSystem.out.println(0);\nreturn;\n}\ni++;\n}\ni = n - 1;\nfor(; i > 0; i--) {\nif ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\nSystem.out.println(2);\nreturn;\n} else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\nSystem.out.println(1);\nreturn;\n}\n}\nSystem.out.println(-1);\n}\n}", "src": "public class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "index": 503, "complexity": "3"}
{"forwhile": "public class Main {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] v = new int[n];\n        int[] ans = new int[n];\n        long s = 0;\n        int t;\n        int i = 0;\n        while(i < n) {\n            v[i] = in.nextInt();\n            s+=v[i];\n            i++;\n        }\n\n        i = 0;\n        while(i < n-1) {\n            int j = i + 1;\n            while(j < n) {\n                if (v[j] > v[i]) {\n                    t = v[i];\n                    v[i] = v[j];\n                    v[j] = t;\n                }\n                j++;\n            }\n            i++;\n        }\n\n        i = 0;\n        while(i < n-1){\n            if(v[i] > v[i+1]){\n                    ans[i] = v[i]-v[i+1];\n            }\n\n            if(v[i] == v[i+1] && v[i]!=1){\n                ans[i]=1;\n                v[i+1]--;\n            }\n\n            if(v[i] < v[i+1]){\n                ans[i]=1;\n                v[i+1] = v[i]-1;\n                if(v[i+1] == 0){\n                    v[i+1] = 1;\n                }\n            }\n            if(v[i] == 0 || v[i] == 1){\n                ans[i] = 1;\n                v[i] = 1;\n            }\n            i++;\n        }\n        if (v[n-1] > 1){\n            ans[n-1] = v[n-1];\n        }\n        else{\n            ans[n-1] = 1;\n        }\n\n        for (int i=0; i<n; i++){\n                s-=ans[i];\n\n        }\n        System.out.print(s);\n\n\n    }\n}", "src": "public class Main {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] v = new int[n];\n        int[] ans = new int[n];\n        long s = 0;\n        int t;\n        for(int i=0; i<n;i++) {\n            v[i] = in.nextInt();\n            s+=v[i];\n        }\n\n        for(int i=0; i<n-1;i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (v[j] > v[i]) {\n                    t = v[i];\n                    v[i] = v[j];\n                    v[j] = t;\n                }\n            }\n        }\n\n        for(int i=0; i<n-1; i++){\n            if(v[i] > v[i+1]){\n                    ans[i] = v[i]-v[i+1];\n            }\n\n            if(v[i] == v[i+1] && v[i]!=1){\n                ans[i]=1;\n                v[i+1]--;\n            }\n\n            if(v[i] < v[i+1]){\n                ans[i]=1;\n                v[i+1] = v[i]-1;\n                if(v[i+1] == 0){\n                    v[i+1] = 1;\n                }\n            }\n            if(v[i] == 0 || v[i] == 1){\n                ans[i] = 1;\n                v[i] = 1;\n            }\n        }\n        if (v[n-1] > 1){\n            ans[n-1] = v[n-1];\n        }\n        else{\n            ans[n-1] = 1;\n        }\n\n        for (int i=0; i<n; i++){\n                s-=ans[i];\n\n        }\n        System.out.print(s);\n\n\n    }\n}", "index": 504, "complexity": "3"}
{"forwhile": "public class Main {\n\n    public static void main(String[] args) {\n       Scanner s = new Scanner(System.in);\n       int n = s.nextInt();\n       int m = s.nextInt();\n       m = 0;\n       long sum = 0;\n       int[] expon = new int[n];\n        int i = 0;\n        while(i < n) {\n            expon[i] = s.nextInt();\n            m = Math.max(expon[i], m);\n            sum += expon[i];\n            i++;\n        }\n        HashSet<Integer> levels = new HashSet<>();\n\n\n        int amount = 0;\n        int i = 0;\n        while(i < n) {\n            int currentHigh = expon[i];\n            for(int j = currentHigh; j >= 1; j--) {\n                if(!levels.contains(j)) {\n                    levels.add(j);\n                    amount++;\n                    break;\n                }\n                if(j == 1){\n                    amount++;\n                }\n            }\n            i++;\n        }\n        System.out.println((sum - amount) - (m - levels.size()));\n    }\n}", "src": "public class Main {\n\n    public static void main(String[] args) {\n       Scanner s = new Scanner(System.in);\n       int n = s.nextInt();\n       int m = s.nextInt();\n       m = 0;\n       long sum = 0;\n       int[] expon = new int[n];\n        for (int i = 0; i < n; i++) {\n            expon[i] = s.nextInt();\n            m = Math.max(expon[i], m);\n            sum += expon[i];\n        }\n        HashSet<Integer> levels = new HashSet<>();\n\n\n        int amount = 0;\n        for (int i = 0; i < n; i++) {\n            int currentHigh = expon[i];\n            for (int j = currentHigh; j >= 1; j--) {\n                if(!levels.contains(j)) {\n                    levels.add(j);\n                    amount++;\n                    break;\n                }\n                if(j == 1){\n                    amount++;\n                }\n            }\n        }\n        System.out.println((sum - amount) - (m - levels.size()));\n    }\n}", "index": 505, "complexity": "3"}
{"forwhile": "class GFG  { static int answerQuery( int a[], int n, int l, int r) { int count = 0; l = l - 1; int i = l; while(i < r) { int element = a[i]; int divisors = 0; int j = l; while(j < r) { if(a[j] % a[i] == 0) divisors++; else break; j++; } if(divisors == (r - l)) count++; i++; } return count; } public static void main (String[] args) { int a[] = { 1 , 2 , 3 , 5 }; int n = a.length; int l = 1, r = 4; System.out.println( answerQuery(a, n, l, r)); l = 2; r = 4; System.out.println( answerQuery(a, n, l, r)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nanswerQuery(\nint\na[], \nint\nn, \n\nint\nl, \nint\nr) \n{ \n\n\n\nint\ncount = \n0\n; \n\n\n\n\nl = l - \n1\n; \n\n\n\n\nfor\n(\nint\ni = l; i < r; i++) \n\n{ \n\nint\nelement = a[i]; \n\nint\ndivisors = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\nj = l; j < r; j++) \n\n{ \n\n\n\nif\n(a[j] % a[i] == \n0\n) \n\ndivisors++; \n\nelse\n\nbreak\n; \n\n} \n\n\n\n\nif\n(divisors == (r - l)) \n\ncount++; \n\n} \n\n\n\n\nreturn\ncount; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = { \n1\n, \n2\n, \n3\n, \n5\n}; \n\nint\nn = a.length; \n\n\nint\nl = \n1\n, r = \n4\n; \n\nSystem.out.println( answerQuery(a, n, l, r)); \n\n\nl = \n2\n; r = \n4\n; \n\nSystem.out.println( answerQuery(a, n, l, r)); \n} \n}", "index": 506, "complexity": "3"}
{"forwhile": "public class main {\nstatic\tclass Interval{\n\t\tint start;\n\t\tint end;\n\t\tpublic Interval(int start,int end) {\n\t\t\tthis.start=start;\n\t\t\tthis.end=end;\n\t\t}\n\t}\nstatic class FastReader \n{ \n    BufferedReader br; \n    StringTokenizer st; \n\n    public FastReader() \n    { \n        br = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    } \n\n    String next() \n    { \n        for(; st == null || !st.hasMoreElements(); ) \n        { \n            try\n            { \n                st = new StringTokenizer(br.readLine()); \n            } \n            catch (IOException  e) \n            { \n                e.printStackTrace(); \n            } \n        } \n        return st.nextToken(); \n    } \n\n    int nextInt() \n    { \n        return Integer.parseInt(next()); \n    } \n\n    long nextLong() \n    { \n        return Long.parseLong(next()); \n    } \n\n    double nextDouble() \n    { \n        return Double.parseDouble(next()); \n    } \n\n    String nextLine() \n    { \n        String str = \"\"; \n        try\n        { \n            str = br.readLine(); \n        } \n        catch (IOException e) \n        { \n            e.printStackTrace(); \n        } \n        return str; \n    } \n} \n\tstatic long mod = 1000000007;\n\tpublic static void main(String[] args) {\n\t\t\n\t\tFastReader in = new FastReader();\n\t\tlong intervals = in.nextInt();\n\t\tlong x = in.nextInt();\n\t\t long y = in.nextInt();\n\t\tInterval []ints = new Interval[(int)(int) intervals];\n\t\tint i = 0;\n\t\twhile(i<intervals) {\n\t\t\tints[i] = new Interval(in.nextInt(),in.nextInt());\n\t\t\ti++;\n\t\t}\n\t\tArrays.sort(ints, (a,b)->a.start-b.start);\n\t\tlong count = 0;\n\t\tint i = 0;\n\t\twhile(i<ints.length) {\n\t\t\tif(i>=0&&ints[i]!=null) {\n\t\t\tInterval cur1 = ints[i];\n\t\t\tint j = i+1;\n\t\t\twhile(j<ints.length) {\n\t\t\tif(ints[j]!=null) {\n\t\t\tInterval cur2 = ints[j];\n\t\t\tif(y*(cur2.start-cur1.end)<x) {\n\t\t\tif(cur1.start!=cur2.start&&cur1.end<cur2.start) {\n\t\t\t\tcur1.end=cur2.end;\n\t\t\t\t\n\t\t\t\tints[j]=null;\n\t\t\t\n\t\t\t}}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tcount = (count + x) % mod;\n\t\t\tcount += (y*(cur1.end-cur1.start)%mod);\n\t\t\tcount%=mod;\n\t\t\t}\n\t\t\t\n\t\t\ti++;\n\t\t}\n\t\t\n\n\n\n\n\n\n\n\n\t\tSystem.out.println(count);\n\t}\n\n}", "src": "public class main {\nstatic\tclass Interval{\n\t\tint start;\n\t\tint end;\n\t\tpublic Interval(int start,int end) {\n\t\t\tthis.start=start;\n\t\t\tthis.end=end;\n\t\t}\n\t}\nstatic class FastReader \n{ \n    BufferedReader br; \n    StringTokenizer st; \n\n    public FastReader() \n    { \n        br = new BufferedReader(new\n                 InputStreamReader(System.in)); \n    } \n\n    String next() \n    { \n        while (st == null || !st.hasMoreElements()) \n        { \n            try\n            { \n                st = new StringTokenizer(br.readLine()); \n            } \n            catch (IOException  e) \n            { \n                e.printStackTrace(); \n            } \n        } \n        return st.nextToken(); \n    } \n\n    int nextInt() \n    { \n        return Integer.parseInt(next()); \n    } \n\n    long nextLong() \n    { \n        return Long.parseLong(next()); \n    } \n\n    double nextDouble() \n    { \n        return Double.parseDouble(next()); \n    } \n\n    String nextLine() \n    { \n        String str = \"\"; \n        try\n        { \n            str = br.readLine(); \n        } \n        catch (IOException e) \n        { \n            e.printStackTrace(); \n        } \n        return str; \n    } \n} \n\tstatic long mod = 1000000007;\n\tpublic static void main(String[] args) {\n\t\t\n\t\tFastReader in = new FastReader();\n\t\tlong intervals = in.nextInt();\n\t\tlong x = in.nextInt();\n\t\t long y = in.nextInt();\n\t\tInterval []ints = new Interval[(int)(int) intervals];\n\t\tfor(int i = 0;i<intervals;i++) {\n\t\t\tints[i] = new Interval(in.nextInt(),in.nextInt());\n\t\t}\n\t\tArrays.sort(ints, (a,b)->a.start-b.start);\n\t\tlong count = 0;\n\t\tfor(int i = 0;i<ints.length;i++) {\n\t\t\tif(i>=0&&ints[i]!=null) {\n\t\t\tInterval cur1 = ints[i];\n\t\t\tfor(int j = i+1;j<ints.length;j++) {\n\t\t\tif(ints[j]!=null) {\n\t\t\tInterval cur2 = ints[j];\n\t\t\tif(y*(cur2.start-cur1.end)<x) {\n\t\t\tif(cur1.start!=cur2.start&&cur1.end<cur2.start) {\n\t\t\t\tcur1.end=cur2.end;\n\t\t\t\t\n\t\t\t\tints[j]=null;\n\t\t\t\n\t\t\t}}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\tcount = (count + x) % mod;\n\t\t\tcount += (y*(cur1.end-cur1.start)%mod);\n\t\t\tcount%=mod;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\n\n\n\n\n\n\n\n\t\tSystem.out.println(count);\n\t}\n\n}", "index": 507, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class TaxiDriversAndLyft {\n\t\n\tstatic class Resident{\n\t\tInteger index;\t\t\t\n\t\tInteger type;\t\t\t\n\t\tInteger requests;\t\t\n\t\t\n\t\tpublic Resident(int index, int type) {\n\t\t\tthis.index = index;\n\t\t\tthis.type = type;\n\t\t\tthis.requests = 0;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif(type == 0) {\n\t\t\t\treturn \"Rider at index : \" + index;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"Driver at index : \" + index + \", Requests: \" + requests;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic ArrayList<Resident> residents;\n\tstatic ArrayList<Integer> drivers_indexes = new ArrayList<>();\n\n\tpublic static void main(String[] args) {\n\t\tScanner reader = new Scanner(System.in);\n\t\tint n = reader.nextInt();\n\t\tint m = reader.nextInt();\n\t\tint length = n + m;\n\t\t\n\t\tint [] coordinates = new int[length];\n\t\tint [] types = new int[length];\n\t\tresidents = new ArrayList<>();\n\t\tdrivers_indexes = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tcoordinates[i] = reader.nextInt();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\ttypes[i] = reader.nextInt();\n\t\t\t\n\t\t\tif(types[i] == 1)\n\t\t\t\tdrivers_indexes.add(i);\n\t\t\t\t\n\t\t\tresidents.add(new Resident(i, types[i]));\n\t\t}\n\t\treader.close();\t\n\t\t\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tResident current = residents.get(i);\n\t\t\tif(current.type == 0) {\n\t\t\t\tint left = i-1, right = i+1;\n\t\t\t\t\t\t\t\t\n\t\t\t\twhile(left >= 0 || right < length) {\n\t\t\t\t\tif(left >= 0 && residents.get(left).type == 1) {\n\t\t\t\t\t\tresidents.get(left).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(right < length && residents.get(right).type == 1) {\n\t\t\t\t\t\tresidents.get(right).requests++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tleft--;\n\t\t\t\t\tright++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int index : drivers_indexes) {\n\t\t\tSystem.out.print(residents.get(index).requests + \" \");\n\t\t}\n\t}\n\n}", "index": 508, "complexity": "3"}
{"forwhile": "public class Lyft {\n    private static FastScanner scan = new FastScanner(System.in);\n    private static PrintWriter pr = new PrintWriter(System.out);\n    private static int n, m, taxistNumber, noTaxistNumber = 0;\n    static people[] peoples, taxist, noTaxist;\n    public static void main(String[] args) throws IOException {\n        n = scan.nextInt();\n        m = scan.nextInt();\n        peoples = new people[n + m];\n        noTaxist = new people[n];\n        taxist = new people[m];\n        int i = 0;\n        while(i < peoples.length){\n            peoples[i] = new people(scan.nextInt());\n            i++;\n        }\n        i = 0;\n        while(i < peoples.length){\n            people ip = peoples[i];\n            if(scan.nextInt() == 1){\n                ip.taxi = true;\n                ip.passangers = 0;\n                taxist[taxistNumber] = ip;\n                taxistNumber++;\n            }else{\n                noTaxist[noTaxistNumber] = ip;\n                noTaxistNumber++;\n            }\n            i++;\n        }\n        int j = 0;\n        while(j < noTaxist.length){\n            people ip = noTaxist[j];\n            int k = 0;\n            while(k < taxist.length){\n                people ii = taxist[k];\n                if(ii.taxi){\n                   if(ip.nearestTaxist == null){\n                       ip.nearestTaxist = ii;\n                       ii.passangers++;\n                   }else if(ip.coord - ip.nearestTaxist.coord > ii.coord - ip.coord){\n                       ip.nearestTaxist.passangers--;\n                       ip.nearestTaxist = ii;\n                       ip.nearestTaxist.passangers++;\n                   }\n                }\n                k++;\n            }\n            j++;\n        }\n        int l = 0;\n        while(l < taxist.length){\n            people ip = taxist[l];\n            pr.print(ip.passangers + \" \");\n            l++;\n        }\n        pr.close();\n    }\n}\nclass FastScanner\n{\n    private static final int bufferSize = 64 * 1024;\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    FastScanner(InputStream inputStream)\n    {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream), bufferSize);\n    }\n\n    String nextToken() throws IOException\n    {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n        {\n            String line = reader.readLine();\n            if (line == null)\n            {\n                tokenizer = null;\n                return null;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    int[] readIntArray(int n) throws IOException\n    {\n        int[] a = new int[n];\n        int i = 0;\n        while(i < n){\n            a[i] = nextInt();\n            i++;\n        }\n        return a;\n    }\n\n    long[] readLongArray(int n) throws IOException\n    {\n        long[] a = new long[n];\n        int i = 0;\n        while(i < n){\n            a[i] = nextLong();\n            i++;\n        }\n        return a;\n    }\n\n    int nextInt() throws NumberFormatException, IOException\n    {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws NumberFormatException, IOException\n    {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws NumberFormatException, IOException\n    {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextLine() throws IOException\n    {\n        tokenizer = null;\n        return reader.readLine();\n    }\n}\nclass people{\n    int coord = 0;\n    boolean taxi = false;\n    people nearestTaxist = null;\n    int passangers = -1;\n    people(int coord){\n        this.coord = coord;\n    }\n}", "src": "public class Lyft {\n    private static FastScanner scan = new FastScanner(System.in);\n    private static PrintWriter pr = new PrintWriter(System.out);\n    private static int n, m, taxistNumber, noTaxistNumber = 0;\n    static people peoples[], taxist[], noTaxist[];\n    public static void main(String[] args) throws IOException {\n        n = scan.nextInt();\n        m = scan.nextInt();\n        peoples = new people[n + m];\n        noTaxist = new people[n];\n        taxist = new people[m];\n        for(int i = 0; i < peoples.length; i++){\n            peoples[i] = new people(scan.nextInt());\n        }\n        for (people i : peoples){\n            if(scan.nextInt() == 1){\n                i.taxi = true;\n                i.passangers = 0;\n                taxist[taxistNumber] = i;\n                taxistNumber++;\n            }else{\n                noTaxist[noTaxistNumber] = i;\n                noTaxistNumber++;\n            }\n        }\n        for (people i : noTaxist){\n                for (people ii: taxist){\n                    if(ii.taxi){\n                       if(i.nearestTaxist == null){\n                           i.nearestTaxist = ii;\n                           ii.passangers++;\n                       }else if(i.coord - i.nearestTaxist.coord > ii.coord - i.coord){\n                           i.nearestTaxist.passangers--;\n                           i.nearestTaxist = ii;\n                           i.nearestTaxist.passangers++;\n                       }\n                    }\n                }\n        }\n        for (people i : taxist){\n                pr.print(i.passangers + \" \");\n        }\n        pr.close();\n    }\n}\nclass FastScanner\n{\n    private static final int bufferSize = 64 * 1024;\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    FastScanner(InputStream inputStream)\n    {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream), bufferSize);\n    }\n\n    String nextToken() throws IOException\n    {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n        {\n            String line = reader.readLine();\n            if (line == null)\n            {\n                tokenizer = null;\n                return null;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    int[] readIntArray(int n) throws IOException\n    {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    long[] readLongArray(int n) throws IOException\n    {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = nextLong();\n        }\n        return a;\n    }\n\n    int nextInt() throws NumberFormatException, IOException\n    {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws NumberFormatException, IOException\n    {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws NumberFormatException, IOException\n    {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextLine() throws IOException\n    {\n        tokenizer = null;\n        return reader.readLine();\n    }\n}\nclass people{\n    int coord = 0;\n    boolean taxi = false;\n    people nearestTaxist = null;\n    int passangers = -1;\n    people(int coord){\n        this.coord = coord;\n    }\n}", "index": 509, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class TaxistsnLyft {\n\tpublic static void main (String[] args){\n\t\tScanner scan = new Scanner (System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint k = n+m;\n\t\tlong[] arr1 = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tarr1[i]=scan.nextLong();\n\t\t}\n\t\tlong[] tax = new long[k];\n\t\tlong[] taxcount = new long[k];\n\t\tfor(int i = 0; i<k; i++){\n\t\t\ttax[i]=scan.nextInt();\n\t\t}\n\t\tint c;\n\t\tint b;\n\t\tfor(int i = 0; i<k; i++){\n\t\t\tif(tax[i]==0){\n\t\t\t\tc=i;\n\t\t\t\twhile(tax[c]!=1){\n\t\t\t\t\tif(c==0){\n\t\t\t\t\t\tc=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tc--;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tb=i;\n\t\t\t\twhile(tax[b]!=1){\n\t\t\t\t\tif(b>=k-1){\n\t\t\t\t\t\tb=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} \n\t\t\t\t\tb++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(c==-1&&b>=0){\n\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t} else if(b==-1&&c>=0) {\n\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t} else if(b>=0&&c>=0) {\n\t\t\t\t\tif(arr1[i]-arr1[c]>arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[b]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]<arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(arr1[i]-arr1[c]==arr1[b]-arr1[i]){\n\t\t\t\t\t\ttaxcount[c]++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\tfor(int j = 0; j<k; j++){\n\t\t\tif(tax[j]==1){\n\t\t\t\tSystem.out.print(taxcount[j]+\" \");\n\t\t\t}\n\t\tscan.close();\n\t\t}\n\t}\n}", "index": 510, "complexity": "3"}
{"forwhile": "public class RookHome {\n\tstatic long MAX = 1_000_000_000;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(new BufferedInputStream(System.in));\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tlong[] vert = new long[n + 2];\n\t\tvert[0] = 1;\n\t\tint i = 1;\n\t\twhile(i <= n) {\n\t\t\tvert[i] = s.nextLong();\n\t\t\ti++;\n\t\t}\n\t\tvert[n + 1] = MAX;\n\t\tlong[][] hor = new long[m][2];\n\t\tint i = 0;\n\t\twhile(i < m) {\n\t\t\thor[i][0] = s.nextLong();\n\t\t\thor[i][1] = s.nextLong();\n\t\t\ts.nextLong();\n\t\t\ti++;\n\t\t}\n\t\tlong min = Long.MAX_VALUE;\n\t\tint count;\n\t\tfor(int i = 0; i < vert.length - 1; i++) {\n\t\t\tcount = 0;\n\t\t\tint j = 0;\n\t\t\tfor(; j < m; j++) {\n\t\t\t\tif(hor[j][0] <= vert[i] && hor[j][1] >= vert[i + 1]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = Math.min(min, i + count);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "src": "public class RookHome {\n\tstatic long MAX = 1_000_000_000;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(new BufferedInputStream(System.in));\n\t\tint n = s.nextInt();\n\t\tint m = s.nextInt();\n\t\tlong[] vert = new long[n + 2];\n\t\tvert[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tvert[i] = s.nextLong();\n\t\t}\n\t\tvert[n + 1] = MAX;\n\t\tlong[][] hor = new long[m][2];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\thor[i][0] = s.nextLong();\n\t\t\thor[i][1] = s.nextLong();\n\t\t\ts.nextLong();\n\t\t}\n\t\tlong min = Long.MAX_VALUE;\n\t\tint count;\n\t\tfor(int i = 0; i < vert.length - 1; i++) {\n\t\t\tcount = 0;\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tif(hor[j][0] <= vert[i] && hor[j][1] >= vert[i + 1]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = Math.min(min, i + count);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}", "index": 511, "complexity": "3"}
{"forwhile": "public class Main {\n    public static int n, m;\n    public static int[] vert, group;\n    public static int[][] horiz;\n    public static boolean ok(int a, int b, int g) {\n        int start, end;\n        if (g == 0) {\n            start = 1;\n            end = vert.length > 0 ? vert[0] : (int)Math.pow(10, 9);\n        } else if (g == group.length - 1) {\n            start = vert[g - 1];\n            end = (int)Math.pow(10, 9);\n        } else {\n            start = vert[g - 1];\n            end = vert[g];\n        }\n        return a <= start && b >= end;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        vert = new int[n];\n        int i = 0;\n        while (i < n) {\n            vert[i] = in.nextInt();\n            i++;\n        }\n        horiz = new int[m][3];\n        int i = 0;\n        while (i < m) {\n            horiz[i] = new int[]{in.nextInt(), in.nextInt(), in.nextInt()};\n            i++;\n        }\n        group = new int[n + 1];\n        Arrays.fill(group, 0);\n        int i = 0;\n        while (i < m) {\n            int a = horiz[i][0];\n            int b = horiz[i][1];\n            int j = 0;\n            while (j < group.length) {\n                if (ok(a, b, j)) {\n                    group[j]++;\n                }\n                j++;\n            }\n            i++;\n        }\n        int min = Integer.MAX_VALUE;\n        int i = 0;\n        while (i < group.length) {\n            min = Math.min(min, group[i] + i);\n            i++;\n        }\n        System.out.println(min);\n    }\n}", "src": "public class Main {\n    public static int n, m;\n    public static int[] vert, group;\n    public static int[][] horiz;\n    public static boolean ok(int a, int b, int g) {\n        int start, end;\n        if (g == 0) {\n            start = 1;\n            end = vert.length > 0 ? vert[0] : (int)Math.pow(10, 9);\n        } else if (g == group.length - 1) {\n            start = vert[g - 1];\n            end = (int)Math.pow(10, 9);\n        } else {\n            start = vert[g - 1];\n            end = vert[g];\n        }\n        return a <= start && b >= end;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        m = in.nextInt();\n        vert = new int[n];\n        for (int i = 0; i < n; i++) {\n            vert[i] = in.nextInt();\n        }\n        horiz = new int[m][3];\n        for (int i = 0; i < m; i++) {\n            horiz[i] = new int[]{in.nextInt(), in.nextInt(), in.nextInt()};\n        }\n        group = new int[n + 1];\n        Arrays.fill(group, 0);\n        for (int i = 0; i < m; i++) {\n            int a = horiz[i][0];\n            int b = horiz[i][1];\n            for (int j = 0; j < group.length; j++) {\n                if (ok(a, b, j)) {\n                    group[j]++;\n                }\n            }\n        }\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < group.length; i++) {\n            min = Math.min(min, group[i] + i);\n        }\n        System.out.println(min);\n    }\n}", "index": 512, "complexity": "3"}
{"forwhile": "public class Tokitsukaze {\n\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        long k =sc.nextLong();\n        double[]p=new double[m];\n        int i = 0;\n        while(i < m){\n            p[i]=sc.nextDouble();\n            i++;\n        }\n        int c=0;\n        int used=0;\n        int i = 0;\n        while(i < m){\n            long low=(long)((Math.floor(p[i]/k)*k)-i)+1;\n            long high=low+k;\n            for(int j=i;j<m;j++){\n                if(p[j]>=low&&p[i]<=high){\n                    i++;\n                }\n            }\n            c++;\n        }\n        System.out.println(c);\n\n    }\n    \n}", "src": "public class Tokitsukaze {\n\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        long k =sc.nextLong();\n        double[]p=new double[m];\n        for(int i = 0;i<m;i++){\n            p[i]=sc.nextDouble();\n        }\n        int c=0;\n        int used=0;\n        for(int i = 0;i<m;){\n            long low=(long)((Math.floor(p[i]/k)*k)-i)+1;\n            long high=low+k;\n            for(int j=i;j<m;j++){\n                if(p[j]>=low&&p[i]<=high){\n                    i++;\n                }\n            }\n            c++;\n        }\n        System.out.println(c);\n\n    }\n    \n}", "index": 513, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public final class CF_573_D1_A {\n\n\n\tstatic boolean verb=true;\n\tstatic void log(Object X){if (verb) System.err.println(X);}\n\tstatic void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+\" \");System.err.println(\"\");}}\n\tstatic void log(long[] X){if (verb) {for (long U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\n\tstatic void logWln(Object X){if (verb) System.err.print(X);}\n\tstatic void info(Object o){\tSystem.out.println(o);}\n\tstatic void output(Object o){outputWln(\"\"+o+\"\\n\");\t}\n\tstatic void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n\n\t\n\tstatic long mod=998244353 ; \n\tstatic int CX=64;\n\n\n\t\n\tstatic BufferedWriter out;\n\tstatic InputReader reader;\n\n\n\t\n\n\tstatic void process() throws Exception {\n\n\t\tLocale.setDefault(Locale.US);\n\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\treader = new InputReader(System.in);\n\n\t\tlong n=reader.readLong();\n\t\tint m=reader.readInt();\n\t\t\n\t\tlong k=reader.readLong();\n\t\tlong[] p=new long[m];\n\t\tfor (int i=0;i<m;i++)\n\t\t\tp[i]=reader.readLong()-1;\n\t\t\n\t\tint pid=-1;\n\t\tint rem=m;\n\t\tint win=0; \n\t\tlong mx=k-1; \n\t\tint res=0;\n\t\tint idx=0;\n\t\t\n\t\twhile (rem>0) {\n\t\t\t\n\t\t\twhile (p[idx]>mx) {\n\t\t\t\tmx+=k;\n\t\t\t\tif (mx>=n-1)\n\t\t\t\t\tmx=n-1;\n\t\t\t\t\n\t\t\t}\n\t\t\n\t\t\tint nxt=idx;\n\t\t\twhile (nxt+1<m && p[nxt+1]<=mx)\n\t\t\t\tnxt++;\n\t\t\tint nb=nxt-idx+1;\n\t\t\trem-=nb;\n\t\t\tmx+=nb;\n\t\t\tidx=nxt+1;\n\t\t\tres++;\n\t\t}\n\t\toutput(res);\n\n\t\n\t\ttry {\n\t\t\tout.close();\n\t\t} catch (Exception E) {\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tprocess();\n\n\t}\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n}", "index": 514, "complexity": "3"}
{"forwhile": "class MinimumDistance  {\nint minDist(int arr[], int n, int x, int y) \n\n{ \nint i, j; \n\nint min_dist = Integer.MAX_VALUE; \n\ni = 0;\nwhile(i < n) \n\n{ \n\nj = i + 1;\nwhile(j < n) \n\n{ \n\nif((x == arr[i] && y == arr[j] \n\n|| y == arr[i] && x == arr[j]) \n\n&& min_dist > Math.abs(i - j)) \n\nmin_dist = Math.abs(i - j); \n\nj++; \n\n} \n\ni++; \n} \n\nreturn min_dist; \n\n} \n\n\npublic static void main(String[] args) \n\n{ \n\nMinimumDistance min = new MinimumDistance(); \n\nint arr[] = {3 , 5 , 4 , 2 , 6 , 5 , 6 , 6 , 5 , 4 , 8 , 3}; \n\nint n = arr.length; \n\nint x = 3; \n\nint y = 6; \n\nfor(int i = 0; i < n; i++) \n\n{ \n\nSystem.out.println(\"Minimum distance between \"+ x + \" and \"+ y + \" is \"+ min.minDist(arr, n, x, y));\n}\n} \n}", "src": "class\nMinimumDistance \n{ \n\nint\nminDist(\nint\narr[], \nint\nn, \nint\nx, \nint\ny) \n\n{ \n\nint\ni, j; \n\nint\nmin_dist = Integer.MAX_VALUE; \n\nfor\n(i = \n0\n; i < n; i++) \n\n{ \n\nfor\n(j = i + \n1\n; j < n; j++) \n\n{ \n\nif\n((x == arr[i] && y == arr[j] \n\n|| y == arr[i] && x == arr[j]) \n\n&& min_dist > Math.abs(i - j)) \n\nmin_dist = Math.abs(i - j); \n\n} \n\n} \n\nreturn\nmin_dist; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nMinimumDistance min = \nnew\nMinimumDistance(); \n\nint\narr[] = {\n3\n, \n5\n, \n4\n, \n2\n, \n6\n, \n5\n, \n6\n, \n6\n, \n5\n, \n4\n, \n8\n, \n3\n}; \n\nint\nn = arr.length; \n\nint\nx = \n3\n; \n\nint\ny = \n6\n; \n\n\nSystem.out.println(\n\"Minimum distance between \"\n+ x + \n\" and \"\n+ y \n\n+ \n\" is \"\n+ min.minDist(arr, n, x, y)); \n\n} \n}", "index": 515, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\t\n\t\tint n = Integer.valueOf(st.nextToken());\n\t\tint k = Integer.valueOf(st.nextToken());\n\t\t\n\t\tString str = br.readLine().trim();\n\t\tint [] arr = new int[n];\n\t\t\n\t\tLL[] adjlist = new LL[n];\n\t\t\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tint x = str.charAt(i) - 'a' + 1;\n\t\t\tarr[i] = x;\n\t\t\tadjlist[i] = new LL();\n\t\t}\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i =0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tint a = arr[i];\n\t\t\t\tint b = arr[j];\n\t\t\t\t\n\t\t\t\tif((b - a) >= 2){\n\t\t\t\t\tadjlist[i].add(new Pair(j, arr[j], 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<Pair> list = new LinkedList<Pair>();\n\t\tLinkedList<Pair> tmpList = new LinkedList<Pair>();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tlist.clear();\n\t\t\tlist.add(new Pair(i,arr[i],0));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\ttmpList.clear();\n\t\t\t\twhile(!list.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tPair cur = list.removeFirst();\n\t\t\t\t\tif(j == k-1){\n\t\t\t\t\t\tans = Math.min(cur.val, ans);\n\t\t\t\t\t}\n\t\t\t\t\tfor(Pair adj : adjlist[cur.idx]){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\ttmpList.add(new Pair(adj.idx, adj.val + cur.val, cur.val+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(tmpList.size() == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.addAll(tmpList);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tif(ans == Integer.MAX_VALUE) out.println(-1);\n\t\telse out.println(ans);\n\t\t\n\t\t\n\t}\n\tpublic static class LL extends LinkedList<Pair>{}\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint val;\n\t\tint idx;\n\t\tint ctr;\n\t\tpublic Pair(int a, int b, int c){\n\t\t\tidx = a;\n\t\t\tval = b;\n\t\t\tctr = c;\n\t\t}\n\t\tpublic int compareTo(Pair p){\n\t\t\t\n\t\t\tif(ctr == p.ctr){\n\t\t\t\tif(val == p.val) return idx - p.idx;\n\t\t\t\t\t\n\t\t\t\treturn val - p.val;\n\t\t\t}\n\t\t\treturn p.ctr - ctr;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn val+\", \";\n\t\t}\n\t}\n}", "index": 516, "complexity": "3"}
{"forwhile": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        int i=0;\n        while(i<s.length()){\n            wtArray[i]=s.charAt(i)-96;\n            i++;\n        }\n        int j=0;\n        while(j<n){\n            int i=1;\n            while(i<n-j){\n                if(wtArray[i-1]>wtArray[i]){\n                    int temp=wtArray[i];\n                    wtArray[i]=wtArray[i-1];\n                    wtArray[i-1]=temp;\n                }\n                i++;\n            }\n            j++;\n        }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        int i=1;\n        for(; k!=0 && i<n; i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "src": "public class Codeforces {\n    public static Scanner input = new Scanner(System.in);\n    public static void main(String[] args){\n        int n,k;\n        n=input.nextInt();\n        k=input.nextInt();\n        String s=input.next();\n        int[] wtArray=new int[n];\n        for(int i=0;i<s.length();i++)\n            wtArray[i]=s.charAt(i)-96;\n        for(int i=1;i<n;i++)\n            for(int j=0;j<n-i;j++)\n                if(wtArray[j]>wtArray[j+1]){\n                    int temp=wtArray[j+1];\n                    wtArray[j+1]=wtArray[j];\n                    wtArray[j]=temp;\n                }\n\n        int sum=wtArray[0];\n        k--;\n        int temp=sum;\n        for(int i=1;k!=0 &&i <n;i++){\n            if((wtArray[i]-temp)>1){\n                sum+=wtArray[i];\n                k--;\n                temp=wtArray[i];\n            }\n        }\n        if(k!=0)\n            sum=-1;\n        System.out.println(sum);\n    }\n\n}", "index": 517, "complexity": "3"}
{"forwhile": "public class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        int i=0;\n        while(i < m) {\n            a[sc.nextInt()]++;\n            i++;\n        }\n        i = 1;\n        while(i<=100) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n            i++;\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "src": "public class Main {\n\n\tstatic class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int ans = 0;\n\n        int[] a = new int[101];\n        for(int i=0;i<m;i++) a[sc.nextInt()]++;\n\n        for(int i=1;i<=100;i++) {\n            int y = 0;\n            for(int x : a) {\n                y += x / i;\n            }\n            if(y >= n) {\n                ans = i;\n            }\n        }\n\n        pw.println(ans);\n        pw.close();\n    }\n}", "index": 518, "complexity": "3"}
{"forwhile": "public class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        int i = 0;\n        while (i < m) {\n            a[i] = in.nextInt();\n            i++;\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i = 0; i < a.length; i++) {\n            Integer t = map.get(a[i]);\n            if (t == null) {\n                map.put(a[i], 1);\n            } else {\n                map.put(a[i], t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        for (; it.hasNext(); ) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "src": "public class G {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        int[] a = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = in.nextInt();\n        }\n\n        Arrays.sort(a);\n        HashMap<Integer, Integer> map = new HashMap<>(200);\n        for (int i : a) {\n            Integer t = map.get(i);\n            if (t == null) {\n                map.put(i, 1);\n            } else {\n                map.put(i, t + 1);\n            }\n        }\n\n        ArrayList<Food> list = new ArrayList<>(100);\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Integer, Integer> en = it.next();\n            list.add(new Food(en.getKey(), en.getValue()));\n        }\n\n        list.sort(Comparator.comparingInt(o -> o.num));\n        int min, max;\n        min = 1;\n        max = list.get(list.size() - 1).num;\n        int res = 0;\n        for (int i = min; i <= max; i++) {\n            int t = 0;\n            for (Food food : list) {\n                int gaven = food.num / i;\n                if (gaven >= 1) {\n                    t += gaven;\n                    if (t >= n) {\n                        res = Math.max(res, i);\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(res);\n\n\n\n\n\n\n    }\n}\n\nclass Food {\n    int id;\n    int num;\n\n    public Food(int id, int num) {\n        this.id = id;\n        this.num = num;\n    }\n\n    @Override\n    public String toString() {\n        return \"Food{\" +\n                \"id=\" + id +\n                \", num=\" + num +\n                '}';\n    }\n}", "index": 519, "complexity": "3"}
{"forwhile": "public class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tint i = 0;\n\t\twhile(i < b.length) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\ti = 0;\n\t\twhile(i < b.length) {\n\t\t\tb[i] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\tfor(; ia<LEN && a[ia]==0; ia++) {\n\t\t}\n\t\tfor(; ib<LEN && b[ib]==0; ib++) {\n\t\t}\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\tfor(; ia<LEN && ib<LEN;) {\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\tfor(; ib<LEN && b[ib]!=a[ia]; ib++) {\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}", "src": "public class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tSolution ss = new Solution();\n\t\tss.test(sc);\n\t}\n\t\n\tvoid test(Scanner sc){\n\t\tint LEN = sc.nextInt();\n\t\tint[] a = new int[LEN];\n\t\tint[] b = new int[LEN];\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\t\n\t\tint ia=0, ib=0;\n\t\twhile(ia<LEN && a[ia]==0) ia++;\n\t\twhile(ib<LEN && b[ib]==0) ib++;\n\t\tif(ib==LEN){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t\tif(ia==LEN){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\t\t\n\t\tboolean out = true;\n\t\twhile(ia<LEN && ib<LEN){\n\t\t\tif(a[ia]==b[ib]){\n\t\t\t\tia++;\n\t\t\t\tib++;\n\t\t\t}else{\n\t\t\t\tif(a[ia]>b[ib]){\n\t\t\t\t\twhile(ib<LEN && b[ib]!=a[ia]){\n\t\t\t\t\t\tib++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ib==LEN){\n\t\t\t\t\t\tout=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(out){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n}", "index": 520, "complexity": "3"}
{"forwhile": "class GFG { static int maxSum(int arr[], int n) { int res = Integer.MIN_VALUE; int i = 0; while(i < n) { int curr_sum = 0; int j = 0; while(j < n) { int index = (i + j) % n; curr_sum += j * arr[index]; j++; } res = Math.max(res, curr_sum); i++; } return res; } public static void main(String args[]) { int arr[] = { 8, 3, 1, 2 }; int n = arr.length; System.out.println(maxSum(arr, n)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n{ \n\nint\nres = Integer.MIN_VALUE; \n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n{ \n\n\n\n\nint\ncurr_sum = \n0\n; \n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\nj = \n0\n; j < n; j++) \n\n{ \n\nint\nindex = (i + j) % n; \n\ncurr_sum += j * arr[index]; \n\n} \n\n\n\n\nres = Math.max(res, curr_sum); \n} \n\nreturn\nres; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = {\n8\n, \n3\n, \n1\n, \n2\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n} \n\n\n}", "index": 521, "complexity": "3"}
{"forwhile": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        for(; i<N;){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            int i=0;\n            while(i<N){\n                a[i] = Integer.parseInt(tb.nextToken());\n                i++;\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        for(; num++<4;){\n            int i=0;\n            while(i<N){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    int j=0;\n                    while(j<N){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                        j++;\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n                i++;\n            }\n            i=0;\n            while(i<N){\n                a[i] = b[i];\n                i++;\n            }\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "src": "public class TestClass {\n    \n    public static int set_size(int[] a, int N){\n        HashSet <Integer> newset = new HashSet <Integer>();\n        int i=0;\n        while(i<N){\n            newset.add(a[i++]);\n        }\n        int v = newset.size();\n        return v;\n    }\n    public static void main(String args[] ) throws Exception {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       StringTokenizer tk = new StringTokenizer(br.readLine());\n            int N = Integer.parseInt(tk.nextToken());\n            int x = Integer.parseInt(tk.nextToken());\n            \n            int[] a = new int[N];\n            int[] b = new int[N];\n            StringTokenizer tb = new StringTokenizer(br.readLine());\n            for(int i=0; i<N; i++){\n                a[i] = Integer.parseInt(tb.nextToken());\n            }\n            if(set_size(a, N) < N){\n                System.out.print(\"0\");\n                System.exit(0);\n            }\n            int num=0;\n        while(num++<4){\n            for(int i=0; i<N; i++){\n                if((a[i]&x) == a[i])\n                    continue;\n                else{\n                    for(int j=0; j<N; j++){\n                        if(i==j){\n                            b[i] = (a[i]&x);\n                        }\n                        else{\n                            b[j] = a[j];\n                        }\n                    }\n                    int s = set_size(b, N);\n                    if(s<N){\n                        System.out.print(num);\n                        System.exit(0);\n                    }\n                }\n            }\n            for(int i=0; i<N; i++)\n                a[i] = b[i];\n        }\n        System.out.print(\"-1\");\n        System.exit(0);\n    }\n}", "index": 522, "complexity": "3"}
{"forwhile": "public class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        int i = 0;\n        while(i < n) {\n            int v;\n            int j = 0;\n            int aSize = a.size(), bitASize = bitA.size();\n            while(j < aSize) {\n                if(!a.add(v = scanner.nextInt())) {\n                    System.out.println(0);\n                    return;\n                }\n\n                if(!bitA.add(v & x)) {\n                    status = 2;\n                }\n                al.add(v);\n                bl.add(v & x);\n                j++;\n            }\n            i++;\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            int j = 0;\n            while(j < b.size()) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n                j++;\n            }\n        }\n        return false;\n    }\n}", "src": "public class Cr500 {\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n, x, status = -1;\n        Set<Integer> a = new HashSet<>(), bitA = new HashSet<>();\n        ArrayList<Integer> al = new ArrayList<>(), bl = new ArrayList<>();\n        n = scanner.nextInt();\n        x = scanner.nextInt();\n\n        for(int i = 0; i < n; i++) {\n            int v;\n            if(!a.add(v = scanner.nextInt())) {\n                System.out.println(0);\n                return;\n            }\n\n            if(!bitA.add(v & x)) {\n                status = 2;\n            }\n            al.add(v);\n            bl.add(v & x);\n        }\n\n        if(contains(al, bl)) {\n            System.out.println(1);\n            return;\n        }\n\n        System.out.println(status);\n    }\n\n    private static boolean contains(ArrayList<Integer> a, ArrayList<Integer> b) {\n        for(int i = 0; i < a.size(); i++) {\n            int v1 = a.get(i);\n            for(int j = 0; j < b.size(); j++) {\n                int v2 = b.get(j);\n                if(i != j && v1 == v2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "index": 523, "complexity": "3"}
{"forwhile": "public class B {\npublic static void main(String[] args) {\nScanner scanner = new Scanner(System.in);\nint n = scanner.nextInt();\nint x = scanner.nextInt();\nint[] a = new int[n];\nint i = 0;\nwhile (i < n) {\na[i] = scanner.nextInt();\ni++;\n}\nArrays.sort(a);\nList<Integer> list = new ArrayList<>();\ni = 0;\nwhile (i < n) {\nlist.add(a[i]);\ni++;\n}\ni = 0;\nwhile (i < n - 1) {\nif (a[i] == a[i + 1]) {\nSystem.out.println(0);\nreturn;\n}\ni++;\n}\ni = n - 1;\nfor (; i > 0; i--) {\nif ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\nSystem.out.println(2);\nreturn;\n} else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\nSystem.out.println(1);\nreturn;\n}\n}\nSystem.out.println(-1);\n}\n}", "src": "public class B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(a[i]);\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (a[i] == a[i + 1]) {\n                System.out.println(0);\n                return;\n            }\n        }\n        for (int i = n - 1; i > 0; i--) {\n            if ((a[i] & x) == (a[i - 1] & x) && !list.contains(x)) {\n                System.out.println(2);\n                return;\n            } else if (list.contains(x) && a[i] > x && (a[i] & x) == x) {\n                System.out.println(1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}", "index": 524, "complexity": "3"}
{"forwhile": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        int a[]=new int[m+1];\n        int i,j;\n        int c=0;\n        i=0;\n        while(i<n)\n        {\n            int l=scan.nextInt();\n            int r=scan.nextInt();\n            j=l;\n            while(j<=r)\n            {\n                if(a[j]!=1)\n                {\n                    a[j]=1;\n                    c++;\n                }\n                j++;\n            }\n            i++;\n        }\n        System.out.println(m-c);\n        i=1;\n        for(;i<=m;)\n        {\n            if(a[i]==0)\n            {\n                System.out.print(i+\" \");\n            }\n            i++;\n        }\n    }\n}", "src": "public class Main{\n    public static void main(String [] args)\n    {\n        Scanner scan=new Scanner(System.in);\n        int n=scan.nextInt();\n        int m=scan.nextInt();\n        int a[]=new int[m+1];\n        int i,j;\n        int c=0;\n        for(i=0;i<n;i++)\n        {\n            int l=scan.nextInt();\n            int r=scan.nextInt();\n            for(j=l;j<=r;j++)\n            {\n                if(a[j]!=1)\n                {\n                    a[j]=1;\n                    c++;\n                }\n            }\n        }\n        System.out.println(m-c);\n        for(i=1;i<=m;i++)\n        {\n            if(a[i]==0)\n            {\n                System.out.print(i+\" \");\n            }\n        }\n    }\n}", "index": 525, "complexity": "3"}
{"forwhile": "class GFG{ private static int minJumps(int[] arr, int n) { int jumps[] = new int[n]; int i, j; if(n == 0 || arr[0] == 0) return Integer.MAX_VALUE; jumps[0] = 0; i = 1; while(i < n) { jumps[i] = Integer.MAX_VALUE; j = 0; while(j < i) { if(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) { jumps[i] = Math.min(jumps[i], jumps[j] + 1); break; } j++; } i++; } return jumps[n-1]; } public static void main(String[] args) { int arr[] = {1, 3, 6, 1, 0, 9}; System.out.println(\"Minimum number of jumps to reach end is : \"+ minJumps(arr,arr.length)); } }", "src": "class\nGFG{ \n\nprivate\nstatic\nint\nminJumps(\nint\n[] arr, \nint\nn) { \n\nint\njumps[] = \nnew\nint\n[n]; \n\n\n\n\nint\ni, j; \n\n\nif\n(n == \n0\n|| arr[\n0\n] == \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\n\n\n\n\njumps[\n0\n] = \n0\n; \n\n\n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\n{ \n\njumps[i] = Integer.MAX_VALUE; \n\nfor\n(j = \n0\n; j < i; j++) \n\n{ \n\nif\n(i <= j + arr[j] && jumps[j] != Integer.MAX_VALUE) \n\n{ \n\njumps[i] = Math.min(jumps[i], jumps[j] + \n1\n); \n\nbreak\n; \n\n} \n\n} \n\n} \n\nreturn\njumps[n-\n1\n]; \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\nint\narr[] = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\n\nSystem.out.println(\n\"Minimum number of jumps to reach end is : \"\n+ \n\nminJumps(arr,arr.length)); \n\n} \n}", "index": 526, "complexity": "3"}
{"forwhile": "public class DoggoRecoloring {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tString s = nextString();\n\t\tboolean b = false;\n\t\t\n\t\tif (n == 1 || n > 26)\n\t\t\tb = true;\n\t\telse {\n\t\t\tint i = 0;\n\t\t\twhile(i < n) {\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile(j < n) {\n\t\t\t\t\tif (s.charAt(i) == s.charAt(j))\n\t\t\t\t\t\tb = true;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(b ? \"Yes\" : \"No\");\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\tfor(; st == null || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class DoggoRecoloring {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tString s = nextString();\n\t\tboolean b = false;\n\t\t\n\t\tif (n == 1 || n > 26)\n\t\t\tb = true;\n\t\telse \n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = i+1; j < n; j++)\n\t\t\t\t\tif (s.charAt(i) == s.charAt(j))\n\t\t\t\t\t\t b = true;\n\t\t\n\t\tSystem.out.println(b ? \"Yes\" : \"No\");\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 527, "complexity": "3"}
{"forwhile": "class GFG { static int maxSumIS(int arr[], int n) { int i, j, max = 0; int msis[] = new int[n]; i = 0; while(i < n) { msis[i] = arr[i]; i++; } i = 1; while(i < n) { j = 0; while(j < i) { if(arr[i] > arr[j] && msis[i] < msis[j] + arr[i]) { msis[i] = msis[j] + arr[i]; } j++; } i++; } i = 0; while(i < n) { if(max < msis[i]) max = msis[i]; i++; } return max; } public static void main(String args[]) { int arr[] = new int[]{1, 101, 2, 3, 100, 4, 5}; int n = arr.length; System.out.println(\"Sum of maximum sum \" + \"increasing subsequence is \" + maxSumIS(arr, n)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nmaxSumIS(\nint\narr[], \nint\nn) \n\n{ \n\nint\ni, j, max = \n0\n; \n\nint\nmsis[] = \nnew\nint\n[n]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nmsis[i] = arr[i]; \n\n\n\n\nfor\n(i = \n1\n; i < n; i++) \n\nfor\n(j = \n0\n; j < i; j++) \n\nif\n(arr[i] > arr[j] && \n\nmsis[i] < msis[j] + arr[i]) \n\nmsis[i] = msis[j] + arr[i]; \n\n\n\n\nfor\n(i = \n0\n; i < n; i++) \n\nif\n(max < msis[i]) \n\nmax = msis[i]; \n\n\nreturn\nmax; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n101\n, \n2\n, \n3\n, \n100\n, \n4\n, \n5\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Sum of maximum sum \"\n+ \n\n\"increasing subsequence is \"\n+ \n\nmaxSumIS(arr, n)); \n\n} \n}", "index": 528, "complexity": "3"}
{"forwhile": "class SmallestSubArraySum { static int smallestSubWithSum(int arr[], int n, int x) { int min_len = n + 1; int start = 0; while(start < n) { int curr_sum = arr[start]; if(curr_sum > x) return 1; int end = start + 1; while(end < n) { curr_sum += arr[end]; if(curr_sum > x && (end - start + 1) < min_len) min_len = (end - start + 1); end++; } start++; } return min_len; } public static void main(String[] args) { int arr1[] = { 1, 4, 45, 6, 10, 19 }; int x = 51; int n1 = arr1.length; int res1 = smallestSubWithSum(arr1, n1, x); if(res1 == n1 + 1) System.out.println(\"Not Possible\"); else System.out.println(res1); int arr2[] = { 1, 10, 5, 2, 7 }; int n2 = arr2.length; x = 9; int res2 = smallestSubWithSum(arr2, n2, x); if(res2 == n2 + 1) System.out.println(\"Not Possible\"); else System.out.println(res2); int arr3[] = { 1, 11, 100, 1, 0, 200, 3, 2, 1, 250 }; int n3 = arr3.length; x = 280; int res3 = smallestSubWithSum(arr3, n3, x); if(res3 == n3 + 1) System.out.println(\"Not Possible\"); else System.out.println(res3); } }", "src": "class\nSmallestSubArraySum \n{ \n\n\n\n\n\nstatic\nint\nsmallestSubWithSum(\nint\narr[], \nint\nn, \nint\nx) \n\n{ \n\n\n\nint\nmin_len = n + \n1\n; \n\n\n\n\nfor\n(\nint\nstart = \n0\n; start < n; start++) \n\n{ \n\n\n\nint\ncurr_sum = arr[start]; \n\n\n\n\nif\n(curr_sum > x) \n\nreturn\n1\n; \n\n\n\n\nfor\n(\nint\nend = start + \n1\n; end < n; end++) \n\n{ \n\n\n\ncurr_sum += arr[end]; \n\n\n\n\n\n\n\n\nif\n(curr_sum > x && (end - start + \n1\n) < min_len) \n\nmin_len = (end - start + \n1\n); \n\n} \n\n} \n\nreturn\nmin_len; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr1[] = {\n1\n, \n4\n, \n45\n, \n6\n, \n10\n, \n19\n}; \n\nint\nx = \n51\n; \n\nint\nn1 = arr1.length; \n\nint\nres1 = smallestSubWithSum(arr1, n1, x); \n\nif\n(res1 == n1+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res1); \n\n\n\nint\narr2[] = {\n1\n, \n10\n, \n5\n, \n2\n, \n7\n}; \n\nint\nn2 = arr2.length; \n\nx = \n9\n; \n\nint\nres2 = smallestSubWithSum(arr2, n2, x); \n\nif\n(res2 == n2+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res2); \n\n\nint\narr3[] = {\n1\n, \n11\n, \n100\n, \n1\n, \n0\n, \n200\n, \n3\n, \n2\n, \n1\n, \n250\n}; \n\nint\nn3 = arr3.length; \n\nx = \n280\n; \n\nint\nres3 = smallestSubWithSum(arr3, n3, x); \n\nif\n(res3 == n3+\n1\n) \n\nSystem.out.println(\n\"Not Possible\"\n); \n\nelse\n\nSystem.out.println(res3); \n\n} \n}", "index": 529, "complexity": "3"}
{"forwhile": "public class DivideCandies {\n\tpublic static void main(String[] args){\n\t\tScanner input = new Scanner(System.in);\n\t\tlong n = input.nextLong();\n\t\tint m = input.nextInt();\n\t\tlong[] a = new long[m];\n\t\tint i = 0;\n\t\twhile(i < m)\n\t\t{\n\t\t\tif(i <= (n%m) && i != 0)\n\t\t\t{\n\t\t\t\ta[i] = n/m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[i] = n/m;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tlong result = 0L;\n\t\tint j = 0;\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tj = 0;\n\t\t\tfor(; j < m; j++)\n\t\t\t{\n\t\t\t\tif((i * i + j * j) % m == 0)\n\t\t\t\t{\n\t\t\t\t\tresult += a[i] * a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}", "src": "public class DivideCandies {\n\tpublic static void main(String[] args){\n\t\tScanner input = new Scanner(System.in);\n\t\tlong n = input.nextLong();\n\t\tint m = input.nextInt();\n\t\tlong[] a = new long[m];\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tif(i <= (n%m) && i != 0)\n\t\t\t{\n\t\t\t\ta[i] = n/m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[i] = n/m;\n\t\t\t}\n\t\t}\n\t\tlong result = 0L;\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif((i * i + j * j) % m == 0)\n\t\t\t\t{\n\t\t\t\t\tresult += a[i] * a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}", "index": 530, "complexity": "3"}
{"forwhile": "import java.util.Scanner;\npublic class JavaApplication2 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int li[] = new int[n];\n        int i = 0;\n        while (i < n) {\n            li[i] = sc.nextInt();\n            i++;\n        }\n        int max = 0;\n        int c = 0;\n        i = 0;\n        while (i < n) {\n            c = 0;\n            int j = i;\n            while (j < n) {\n                if (j != n - 1 && j != 0 && li[j] - li[j - 1] == 1 && li[j + 1] - li[j] == 1) {\n                    c++;\n                    i++;\n                } else if (j != n - 1 && j == 0 && li[j + 1] - li[j] == 1 && li[j] == 1) {\n                    c++;\n                    i++;\n                } else if (j == n - 1 && j != 0 && li[j] - li[j - 1] == 1 && li[j] == 1000) {\n                    c++;\n                    i++;\n                } else {\n                    break;\n                }\n                j++;\n            }\n            if (c > max) {\n                max = c;\n            }\n            i++;\n        }\n        if (c > max) {\n            max = c;\n        }\n        System.out.println(max);\n    }\n}", "src": ";\npublic class JavaApplication2 {\n\n    public static void main(String[] args) {\n        Scanner sc =new Scanner(System.in);\n        int n= sc.nextInt();\n        int li[]=new int[n];\n        for(int i = 0 ;i<n;i++){\n            li[i]=sc.nextInt();\n        }\n        int max=0;\n         int c=0;\n        for(int i = 0;i<n;i++){\n           c=0;\n            for(int j=i;j<n;j++){\n                if(j!=n-1&&j!=0&&li[j]-li[j-1]==1&&li[j+1]-li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j!=n-1&&j==0&&li[j+1]-li[j]==1&&li[j]==1){\n                    c++;\n                    i++;\n                }\n                else if(j==n-1&&j!=0&&li[j]-li[j-1]==1&&li[j]==1000){\n                    c++;\n                    i++;\n                }\n                else{ break;}\n            }\n            if(c>max){\n                max=c;\n            }\n        }\n        if(c>max){\n                max=c;\n            }\n        System.out.println(max);\n        \n       \n    }\n    \n}", "index": 531, "complexity": "3"}
{"forwhile": "public class Amain {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[] = new int[100005];\n\t\tint vis[] = new int[100005];\n\t\tint maxx = -1;\n\t\tint n , k ;\n\t\tint e = 0  , s = 0 ;\n\t\tint ans = 0  ;\n\t\t\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\n\t\tint i = 1;\n\t\twhile(i<=n) {\n\t\t\ta[i]=sc.nextInt() ;\n\t\t\tif(a[i]== 1 )\n\t\t\t{\n\t\t\t\te++ ; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts++ ;\n\t\t\t}\n\t\t    i++;\n\t\t}\n\t    \n\t\tint i = 1;\n\t\twhile(i<=k) {\n\t\t\tint e1 = 0 ; \n\t\t\tint s1 = 0 ;  \n\t\t\tint j = i;\n\t\t\twhile(j<=n) {\n\t\t\t\tif(a[j]==1 )\n\t\t\t\t{\n\t\t\t\t\te1++ ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1++ ;\n\t\t\t\t}\n\t\t\t    j+=k;\n\t\t\t}\n\t \n\t\t\tans = Math.abs(  (s-s1)-(e-e1)) ; \n\t\t\tmaxx = Math.max(maxx,ans) ; \n\t\t    i++;\n\t\t}\n       System.out.print(maxx);\n\t}\n\n}", "src": "public class Amain {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[] = new int[100005];\n\t\tint vis[] = new int[100005];\n\t\tint maxx = -1;\n\t\tint n , k ;\n\t\tint e = 0  , s = 0 ;\n\t\tint ans = 0  ;\n\t\t\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\n\t\tfor(int i = 1 ; i<=n ; i++ )\n\t\t{\n\t\t\ta[i]=sc.nextInt() ;\n\t\t\tif(a[i]== 1 )\n\t\t\t{\n\t\t\t\te++ ; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts++ ;\n\t\t\t}\n\t\t}\n\t    \n\t\tfor(int i = 1 ; i<=k  ;i++ )\n\t\t{\n\t\t\tint e1 = 0 ; \n\t\t\tint s1 = 0 ;  \n\t\t\tfor(int j = i ; j<=n ;j+=k )\n\t\t\t{\n\t\t\t\tif(a[j]==1 )\n\t\t\t\t{\n\t\t\t\t\te1++ ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1++ ;\n\t\t\t\t}\n\t\t\t}\n\t        \n\t        \n\t \n\t\t\tans = Math.abs(  (s-s1)-(e-e1)) ; \n\t\t\tmaxx = Math.max(maxx,ans) ; \n\t\t}\n       System.out.print(maxx);\n\t}\n\n}", "index": 532, "complexity": "3"}
{"forwhile": "public class Main {\\n\\tstatic class en implements Comparable<en>{\\n\\t\\tint w,h,dex;\\n\\t\\ten(int a,int b,int c){\\n\\t\\t\\tw=a;\\n\\t\\t\\th=b;\\n\\t\\t\\tdex=c;\\n\\t\\t}\\n\\t\\tpublic int compareTo(en o) {\\n\\t\\t\\treturn w-o.w;\\n\\t\\t}\\n\\t}\\n\\tpublic static void main(String args[]) {\\n\\t\\tScanner cin=new Scanner(System.in);\\n\\t\\tint n=cin.nextInt(),ww=cin.nextInt(),hh=cin.nextInt(),num=0;\\n\\t\\tQueue<en> que=new PriorityQueue();\\n\\t\\tint i=1;\\n\\t\\twhile(i<=n) {\\n\\t\\t\\tint a=cin.nextInt(),b=cin.nextInt();\\n\\t\\t\\tif(a>ww&&b>hh) {\\n\\t\\t\\t\\tque.add(new en(a,b,i));\\n\\t\\t\\t\\tnum++;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tint dp[][]=new int[num+5][2],ans=0,ad=0,arr[][]=new int[num+5][3];\\n\\t\\ti=1;\\n\\t\\twhile(i<=num) {\\n\\t\\t\\tarr[i][0]=que.peek().w;\\n\\t\\t\\tarr[i][1]=que.peek().h;\\n\\t\\t\\tarr[i][2]=que.remove().dex;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\ti=1;\\n\\t\\twhile(i<=num) {\\n\\t\\t\\tint te=0,td=0;\\n\\t\\t\\tint j=1;\\n\\t\\t\\twhile(j<i) {\\n\\t\\t\\t\\tif(arr[j][0]<arr[i][0]&&arr[j][1]<arr[i][1]&&dp[j][0]>te) {\\n\\t\\t\\t\\t\\tte=dp[j][0];\\n\\t\\t\\t\\t\\td=td=j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][0]=te+1;\\n\\t\\t\\tdp[i][1]=td;\\n\\t\\t\\tif(dp[i][0]>ans) {\\n\\t\\t\\t\\tans=dp[i][0];\\n\\t\\t\\t\\tad=i;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tSystem.out.println(ans);\\n\\t\\tArrayList<Integer> an=new ArrayList();\\n\\t\\tint u=ad;\\n\\t\\twhile(u>0) {\\n\\t\\t\\tan.add(arr[u][2]);\\n\\t\\t\\tu=dp[u][1];\\n\\t\\t}\\n\\t\\ti=an.size()-1;\\n\\t\\tfor(;i>=0;i--) System.out.print(an.get(i)+\" \");\\n\\t}\\n}", "src": "public class Main {\n\tstatic class en implements Comparable<en>{\n\t\tint w,h,dex;\n\t\ten(int a,int b,int c){\n\t\t\tw=a;\n\t\t\th=b;\n\t\t\tdex=c;\n\t\t}\n\t\tpublic int compareTo(en o) {\n\t\t\treturn w-o.w;\n\t\t}\n\t}\n\tpublic static void main(String args[]) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tint n=cin.nextInt(),ww=cin.nextInt(),hh=cin.nextInt(),num=0;\n\t\tQueue<en> que=new PriorityQueue();\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tint a=cin.nextInt(),b=cin.nextInt();\n\t\t\tif(a>ww&&b>hh) {\n\t\t\t\tque.add(new en(a,b,i));\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tint dp[][]=new int[num+5][2],ans=0,ad=0,arr[][]=new int[num+5][3];\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tarr[i][0]=que.peek().w;\n\t\t\tarr[i][1]=que.peek().h;\n\t\t\tarr[i][2]=que.remove().dex;\n\t\t}\n\t\tfor(int i=1;i<=num;i++) {\n\t\t\tint te=0,td=0;\n\t\t\tfor(int j=1;j<i;j++) {\n\t\t\t\tif(arr[j][0]<arr[i][0]&&arr[j][1]<arr[i][1]&&dp[j][0]>te) {\n\t\t\t\t\tte=dp[j][0];\n\t\t\t\t\ttd=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][0]=te+1;\n\t\t\tdp[i][1]=td;\n\t\t\tif(dp[i][0]>ans) {\n\t\t\t\tans=dp[i][0];\n\t\t\t\tad=i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tArrayList<Integer> an=new ArrayList();\n\t\tint u=ad;\n\t\twhile(u>0) {\n\t\t\tan.add(arr[u][2]);\n\t\t\tu=dp[u][1];\n\t\t\t\n\t\t}\n\t\tfor(int i=an.size()-1;i>=0;i--) System.out.print(an.get(i)+\" \");\n\t}\n}", "index": 533, "complexity": "3"}
{"forwhile": "class GFG { static int findMinDiff(int[] arr, int n) { int diff = Integer.MAX_VALUE; int i = 0; while(i < n - 1) { int j = i + 1; while(j < n) { if (Math.abs((arr[i] - arr[j]) ) < diff) diff = Math.abs((arr[i] - arr[j])); j++; } i++; } return diff; } public static void main(String[] args) { int arr[] = new int[]{ 1, 5, 3, 19, 18, 25 }; System.out.println(\"Minimum difference is \" + findMinDiff(arr, arr.length)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nfindMinDiff(\nint\n[] arr, \nint\nn) \n\n{ \n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\nfor\n(\nint\nj=i+\n1\n; j<n; j++) \n\nif\n(Math.abs((arr[i] - arr[j]) )< diff) \n\ndiff = Math.abs((arr[i] - arr[j])); \n\n\n\n\nreturn\ndiff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n5\n, \n3\n, \n19\n, \n18\n, \n25\n}; \n\nSystem.out.println(\n\"Minimum difference is \"\n+ \n\nfindMinDiff(arr, arr.length)); \n\n\n} \n}", "index": 534, "complexity": "3"}
{"forwhile": "class Test { static int arr1[] = new int[]{ 0 , 1 , 0 , 1 , 1 , 1 , 1}; static int arr2[] = new int[]{ 1 , 1 , 1 , 1 , 1 , 0 , 1}; static int longestCommonSum(int n) { int maxLen = 0; int i=0; while(i<n) { int sum1 = 0, sum2 = 0; int j=i; while(j<n) { sum1 += arr1[j]; sum2 += arr2[j]; if(sum1 == sum2) { int len = j-i+1; if(len > maxLen) maxLen = len; } j++; } i++; } return maxLen; } public static void main(String[] args) { System.out.print(\"Length of the longest common span with same sum is \"); System.out.println(longestCommonSum(arr1.length)); } }", "src": "class\nTest \n{ \n\nstatic\nint\narr1[] = \nnew\nint\n[]{\n0\n, \n1\n, \n0\n, \n1\n, \n1\n, \n1\n, \n1\n}; \n\nstatic\nint\narr2[] = \nnew\nint\n[]{\n1\n, \n1\n, \n1\n, \n1\n, \n1\n, \n0\n, \n1\n}; \n\n\n\n\n\n\nstatic\nint\nlongestCommonSum(\nint\nn) \n\n{ \n\n\n\nint\nmaxLen = \n0\n; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\n{ \n\n\n\nint\nsum1 = \n0\n, sum2 = \n0\n; \n\n\n\n\nfor\n(\nint\nj=i; j<n; j++) \n\n{ \n\n\n\nsum1 += arr1[j]; \n\nsum2 += arr2[j]; \n\n\n\n\n\n\nif\n(sum1 == sum2) \n\n{ \n\nint\nlen = j-i+\n1\n; \n\nif\n(len > maxLen) \n\nmaxLen = len; \n\n} \n\n} \n\n} \n\nreturn\nmaxLen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.print(\n\"Length of the longest common span with same sum is \"\n); \n\nSystem.out.println(longestCommonSum(arr1.length)); \n\n} \n}", "index": 535, "complexity": "3"}
{"forwhile": "public class Codechef{\n      \n\n    public static void main(String []args){\n       Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n\t\tSet<HashSet> s3 = new HashSet<>();\n\n      \n        int j=0;\n        while(j<n){\n         \tString a=sc.next();\n         HashSet<Character> t = new HashSet<Character>();\n\t\t\tchar[] charArray = a.toCharArray();\n\t\t\tint i=0;\n\t\t\twhile(i<charArray.length){\n\t\t\tt.add(charArray[i]);\n\t\t\ti++;\n\t\t\t}\n\n        s3.add(t);\n    \n          \n\n         j++;\n\n         }\n         System.out.println(s3.size());\n    }\n}", "src": "public class Codechef{\n      \n\n    public static void main(String []args){\n       Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n\t\tSet<HashSet> s3 = new HashSet<>();\n\n      \n         for(int j=0;j<n;j++){\n         \tString a=sc.next();\n         HashSet<Character> t = new HashSet<Character>();\n\t\t\tfor(char c:a.toCharArray()){\n\t\t\tt.add(c);\n\t\t\t}\n\n        s3.add(t);\n    \n          \n\n         }\n         System.out.println(s3.size());\n    }\n}", "index": 536, "complexity": "3"}
{"forwhile": "public class Main {\n\tstatic int mod = (int) (1e9+7);\n\tstatic InputReader in;\n    static PrintWriter out;\n    \n    \t\tpublic static int n;\n    \t\tpublic static int m;\n    \n    \t\tpublic static boolean valid(int i , int j) {\n    \t\t\t\n    \t\t\treturn ( i<n && j<m && i>=0 && j>=0);\n    \t\t}\n    \t\t\n   \n\t\tpublic static void main(String args[] )  {\n\t\t\t\n\t\t  in = new InputReader(System.in);\n\t      out = new PrintWriter(System.out);\n\t     \n\t     n = in.nextInt();\n\t    \t m = in.nextInt();\n\t    \n\t    \tString[] s = new String[n];\n\t    \tint i=0;\n\t    \twhile(i<n) {\n\t    \t\ts[i]= in.readString();\n\t    \t\ti++;\n\t    \t}\n\t    \tint f=0;\n\t    \tint i=0;\n\t    \twhile(i<n) {\n\t    \t\tint j=0;\n\t    \t\twhile(j<s[i].length()) {\n\t    \t\t\tint val=-1;\n\t    \t\t\tif(s[i].charAt(j)==\".\") {\n\t    \t\t\t\tval=0;\n\t    \t\t\t}\n\t    \t\t\telse if(s[i].charAt(j)=='*') {\n\t    \t\t\t\tcontinue;\n\t    \t\t\t}\n\t    \t\t\telse {\n\t    \t\t\t\tval = s[i].charAt(j)-'0';\n\t    \t\t\t}\n\t    \t\t\tint c=0;\n\t    \t\t\tif(valid(i-1,j) && s[i-1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j-1) && s[i-1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j+1) && s[i-1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j-1) && s[i].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j+1) && s[i].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j) && s[i+1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j+1) && s[i+1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j-1) && s[i+1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(c!=val) {\n\t    \t\t\t\tf=1;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t\tj++;\n\t    \t\t}\n\t    \t\ti++;\n\t    \t}\n\t    \tif(f==0) {\n\t    \t\tout.println(\"YES\");\n\t    \t}\n\t    \telse {\n\t    \t\tout.println(\"NO\");\n\t    \t}\n\t     \n\t     \n\t     out.close();\n\t\t}\n\t\t\n\n\t\t\n\t\tstatic class InputReader\n\t    {\n\n\t        private final InputStream stream;\n\t        private final byte[] buf = new byte[8192];\n\t        private int curChar, snumChars;\n\t        private SpaceCharFilter filter;\n\n\t        public InputReader(InputStream stream)\n\t        {\n\t                this.stream = stream;\n\t        }\n\n\t        public int snext()\n\t        {\n\t                if (snumChars == -1)\n\t                        throw new InputMismatchException();\n\t                if (curChar >= snumChars)\n\t                {\n\t                        curChar = 0;\n\t                        try\n\t                        {\n\t                                snumChars = stream.read(buf);\n\t                        } catch (IOException e)\n\t                        {\n\t                                throw new InputMismatchException();\n\t                        }\n\t                        if (snumChars <= 0)\n\t                                return -1;\n\t                }\n\t                return buf[curChar++];\n\t        }\n\n\t        public int nextInt()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                int res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public long nextLong()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                long res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public int[] nextIntArray(int n)\n\t        {\n\t                int a[] = new int[n];\n\t                int i = 0;\n\t                for (i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextInt();\n\t                }\n\t                return a;\n\t        }\n\n\t        public long[] nextLongArray(int n)\n\t        {\n\t                long a[] = new long[n];\n\t                int i = 0;\n\t                for (i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextLong();\n\t                }\n\t                return a;\n\t        }\n\n\t        public String readString()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res.toString();\n\t        }\n\n\t        public String nextLine()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                        c = snext();\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isEndOfLine(c));\n\t                return res.toString();\n\t        }\n\n\t        public boolean isSpaceChar(int c)\n\t        {\n\t                if (filter != null)\n\t                        return filter.isSpaceChar(c);\n\t                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t        }\n\n\t        private boolean isEndOfLine(int c)\n\t        {\n\t                return c == '\\n' || c == '\\r' || c == -1;\n\t        }\n\n\t        public interface SpaceCharFilter\n\t        {\n\t                public boolean isSpaceChar(int ch);\n\t        }\n\n\t    }\n\t\t\n}\n\n\n\n\n\n\n\nclass Pair { \n    int x; \n    int y; \n  \n    \npublic Pair(int x, int y) \n    { \n        this.x = x; \n        this.y = y; \n    } \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass couple implements Comparable<couple>\n{ int x,y;\n  public couple(int m,int f) {\n \t x=m;\n \t y=f;\n  }\n\tpublic int compareTo(couple o) {\n\t\t\n\t\t \n\t\treturn x-o.x;\n\t}  \n}", "src": "public class Main {\n\tstatic int mod = (int) (1e9+7);\n\tstatic InputReader in;\n    static PrintWriter out;\n    \n    \t\tpublic static int n;\n    \t\tpublic static int m;\n    \n    \t\tpublic static boolean valid(int i , int j) {\n    \t\t\t\n    \t\t\treturn ( i<n && j<m && i>=0 && j>=0);\n    \t\t}\n    \t\t\n   \n\t\tpublic static void main(String args[] )  {\n\t\t\t\n\t\t  in = new InputReader(System.in);\n\t      out = new PrintWriter(System.out);\n\t     \n\t     n = in.nextInt();\n\t    \t m = in.nextInt();\n\t    \n\t    \tString[] s = new String[n];\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\ts[i]= in.readString();\n\t    \t}\n\t    \tint f=0;\n\t    \tfor(int i=0;i<n;i++) {\n\t    \t\tfor(int j=0;j<s[i].length();j++) {\n\t    \t\t\tint val=-1;\n\t    \t\t\tif(s[i].charAt(j)=='.') {\n\t    \t\t\t\tval=0;\n\t    \t\t\t}\n\t    \t\t\telse if(s[i].charAt(j)=='*') {\n\t    \t\t\t\tcontinue;\n\t    \t\t\t}\n\t    \t\t\telse {\n\t    \t\t\t\tval = s[i].charAt(j)-'0';\n\t    \t\t\t}\n\t    \t\t\tint c=0;\n\t    \t\t\tif(valid(i-1,j) && s[i-1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j-1) && s[i-1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i-1,j+1) && s[i-1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j-1) && s[i].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i,j+1) && s[i].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j) && s[i+1].charAt(j)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j+1) && s[i+1].charAt(j+1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(valid(i+1,j-1) && s[i+1].charAt(j-1)=='*'){\n\t    \t\t\t\tc++;\n\t    \t\t\t}\n\t    \t\t\tif(c!=val) {\n\t    \t\t\t\tf=1;\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    \tif(f==0) {\n\t    \t\tout.println(\"YES\");\n\t    \t}\n\t    \telse {\n\t    \t\tout.println(\"NO\");\n\t    \t}\n\t     \n\t     \n\t     out.close();\n\t\t}\n\t\t\n\n\t\t\n\t\tstatic class InputReader\n\t    {\n\n\t        private final InputStream stream;\n\t        private final byte[] buf = new byte[8192];\n\t        private int curChar, snumChars;\n\t        private SpaceCharFilter filter;\n\n\t        public InputReader(InputStream stream)\n\t        {\n\t                this.stream = stream;\n\t        }\n\n\t        public int snext()\n\t        {\n\t                if (snumChars == -1)\n\t                        throw new InputMismatchException();\n\t                if (curChar >= snumChars)\n\t                {\n\t                        curChar = 0;\n\t                        try\n\t                        {\n\t                                snumChars = stream.read(buf);\n\t                        } catch (IOException e)\n\t                        {\n\t                                throw new InputMismatchException();\n\t                        }\n\t                        if (snumChars <= 0)\n\t                                return -1;\n\t                }\n\t                return buf[curChar++];\n\t        }\n\n\t        public int nextInt()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                int res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public long nextLong()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                int sgn = 1;\n\t                if (c == '-')\n\t                {\n\t                        sgn = -1;\n\t                        c = snext();\n\t                }\n\t                long res = 0;\n\t                do\n\t                {\n\t                        if (c < '0' || c > '9')\n\t                                throw new InputMismatchException();\n\t                        res *= 10;\n\t                        res += c - '0';\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res * sgn;\n\t        }\n\n\t        public int[] nextIntArray(int n)\n\t        {\n\t                int a[] = new int[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextInt();\n\t                }\n\t                return a;\n\t        }\n\n\t        public long[] nextLongArray(int n)\n\t        {\n\t                long a[] = new long[n];\n\t                for (int i = 0; i < n; i++)\n\t                {\n\t                        a[i] = nextLong();\n\t                }\n\t                return a;\n\t        }\n\n\t        public String readString()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                {\n\t                        c = snext();\n\t                }\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isSpaceChar(c));\n\t                return res.toString();\n\t        }\n\n\t        public String nextLine()\n\t        {\n\t                int c = snext();\n\t                while (isSpaceChar(c))\n\t                        c = snext();\n\t                StringBuilder res = new StringBuilder();\n\t                do\n\t                {\n\t                        res.appendCodePoint(c);\n\t                        c = snext();\n\t                } while (!isEndOfLine(c));\n\t                return res.toString();\n\t        }\n\n\t        public boolean isSpaceChar(int c)\n\t        {\n\t                if (filter != null)\n\t                        return filter.isSpaceChar(c);\n\t                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t        }\n\n\t        private boolean isEndOfLine(int c)\n\t        {\n\t                return c == '\\n' || c == '\\r' || c == -1;\n\t        }\n\n\t        public interface SpaceCharFilter\n\t        {\n\t                public boolean isSpaceChar(int ch);\n\t        }\n\n\t    }\n\t\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Pair { \n    int x; \n    int y; \n  \n    \npublic Pair(int x, int y) \n    { \n        this.x = x; \n        this.y = y; \n    } \n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass couple implements Comparable<couple>\n{ int x,y;\n  public couple(int m,int f) {\n \t x=m;\n \t y=f;\n  }\n\tpublic int compareTo(couple o) {\n\t\t\n\t\t \n\t\treturn x-o.x;\n\t}  \n}", "index": 537, "complexity": "3"}
{"forwhile": "class Test { static int arr[] = new int[] { 1 , 20 , 6 , 4 , 5}; static int getInvCount(int n) { int inv_count = 0; int i = 0; while(i < n - 1) { int j = i + 1; while(j < n) { if(arr[i] > arr[j]) inv_count++; j++; } i++; } return inv_count; } public static void main(String[] args) { System.out.println(\"Number of inversions are \" + getInvCount(arr.length)); } }", "src": "class\nTest { \n\nstatic\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\n\nstatic\nint\ngetInvCount(\nint\nn) \n\n{ \n\nint\ninv_count = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; i++) \n\nfor\n(\nint\nj = i + \n1\n; j < n; j++) \n\nif\n(arr[i] > arr[j]) \n\ninv_count++; \n\n\nreturn\ninv_count; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nSystem.out.println(\n\"Number of inversions are \"\n\n+ getInvCount(arr.length)); \n\n} \n}", "index": 538, "complexity": "3"}
{"forwhile": "class Main { static void minAbsSumPair(int arr[], int arr_size) { int inv_count = 0; int l, r, min_sum, sum, min_l, min_r; if(arr_size < 2) { System.out.println(\"Invalid Input\"); return; } min_l = 0; min_r = 1; min_sum = arr[0] + arr[1]; l = 0; while(l < arr_size - 1) { r = l+1; while(r < arr_size) { sum = arr[l] + arr[r]; if(Math.abs(min_sum) > Math.abs(sum)) { min_sum = sum; min_l = l; min_r = r; } r++; } l++; } System.out.println(\" The two elements whose \"+ \"sum is minimum are \"+ arr[min_l]+ \" and \"+arr[min_r]); } public static void main (String[] args) { int arr[] = {1, 60, -10, 70, -80, 85}; minAbsSumPair(arr, 6); } }", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\narr_size) \n\n{ \n\nint\ninv_count = \n0\n; \n\nint\nl, r, min_sum, sum, min_l, min_r; \n\n\n\n\nif\n(arr_size < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nmin_l = \n0\n; \n\nmin_r = \n1\n; \n\nmin_sum = arr[\n0\n] + arr[\n1\n]; \n\n\nfor\n(l = \n0\n; l < arr_size - \n1\n; l++) \n\n{ \n\nfor\n(r = l+\n1\n; r < arr_size; r++) \n\n{ \n\nsum = arr[l] + arr[r]; \n\nif\n(Math.abs(min_sum) > Math.abs(sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\n} \n\n} \n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nminAbsSumPair(arr, \n6\n); \n\n} \n\n}", "index": 539, "complexity": "3"}
{"forwhile": "public class Main {\n\tpublic static void main(String args[]) {\n\t\tnew Main().run();\n\t}\n\t\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tvoid run(){\n\t    int q=in.nextInt();\n\t    int i=0;\n\t    while(i<q){\n\t        out.println(work());\n\t        i++;\n\t    }\n\t    out.flush();\n\t}\n\tint work() {\t\t\n\t\tint n=in.nextInt();\n\t    int k=in.nextInt();\n\t    String str=in.next();\n\t    char[] chs=new char[]{'R','G','B'};\n\t    int c1=0,c2=0,c3=0;\n\t    int ret=99999999;\n\t    int i=0,p1=0,p2=1,p3=2;\n\t    while(i<n){\n\t        char ch=str.charAt(i);\n\t        \n\t        if(ch!=chs[p1]){\n\t            c1++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p1-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c1--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c1);\n\t        }\n\t        \n\t        if(ch!=chs[p2]){\n\t            c2++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p2-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c2--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c2);\n\t        }\n\t        \n\t        if(ch!=chs[p3]){\n\t            c3++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p3-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c3--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c3);\n\t        }\n\t        i++;\n\t        p1=(p1+1)%3;\n\t        p2=(p2+1)%3;\n\t        p3=(p3+1)%3;\n\t    }\n\t    return ret;\n\t   \n\t}\n}", "src": "public class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\t\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tvoid run(){\n\t    int q=in.nextInt();\n\t    for(int i=0;i<q;i++){\n\t        out.println(work());\n\t    }\n\t    out.flush();\n\t}\n\tint work() {\t\t\n\t\tint n=in.nextInt();\n\t    int k=in.nextInt();\n\t    String str=in.next();\n\t    char[] chs=new char[]{'R','G','B'};\n\t    int c1=0,c2=0,c3=0;\n\t    int ret=99999999;\n\t    for(int i=0,p1=0,p2=1,p3=2;i<n;i++,p1=(p1+1)%3,p2=(p2+1)%3,p3=(p3+1)%3){\n\t        char ch=str.charAt(i);\n\t        \n\t        if(ch!=chs[p1]){\n\t            c1++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p1-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c1--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c1);\n\t        }\n\t        \n\t        \n\t        if(ch!=chs[p2]){\n\t            c2++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p2-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c2--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c2);\n\t        }\n\t        \n\t        \n\t        if(ch!=chs[p3]){\n\t            c3++;\n\t        }\n\t        if(i>=k){\n\t            char pre1=str.charAt(i-k);\n\t            char pre2=chs[((p3-(k%3))+3)%3];\n\t            if(pre1!=pre2){\n\t                c3--;\n\t            }\n\t        }\n\t        if(i+1>=k){\n\t            ret=Math.min(ret,c3);\n\t        }\n\t    } \n\t    return ret;\n\t   \n\t}\n}", "index": 540, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class CodeForces\n{\n\tpublic static void main(String[] args)throws IOException\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\t\n\t\t\n\t\tint t,i,j,n,k,x,y,z,min1,min2,min3,arr1[],arr2[],arr3[];\n\t\tString s;\n\t\tchar[] s1,s2,s3;\n\n\t\tt=sc.nextInt();\n\t\t\n\t\twhile(t-->0)\n\t\t{\n\t\t\tn=sc.nextInt();\n\t\t\tk=sc.nextInt();\n\t\t\ts=sc.next();\n\t\t\ts1=new char[n];\n\t\t\ts2=new char[n];\n\t\t\ts3=new char[n];\n\t\t\t\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(i%3==0)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='R';\n\t\t\t\t\ts2[i]='G';\n\t\t\t\t\ts3[i]='B';\n\t\t\t\t}\n\t\t\t\tif(i%3==1)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='G';\n\t\t\t\t\ts2[i]='B';\n\t\t\t\t\ts3[i]='R';\n\t\t\t\t}\n\t\t\t\tif(i%3==2)\n\t\t\t\t{\n\t\t\t\t\ts1[i]='B';\n\t\t\t\t\ts2[i]='R';\n\t\t\t\t\ts3[i]='G';\n\t\t\t\t}\n\t\t\t}\n\t\t\tarr1=new int[n];\n\t\t\tarr2=new int[n];\n\t\t\tarr3=new int[n];\n\n\t\t\tfor(i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)!=s1[i])\n\t\t\t\t\tarr1[i]=1;\n\t\t\t\tif(s.charAt(i)!=s2[i])\n\t\t\t\t\tarr2[i]=1;\n\t\t\t\tif(s.charAt(i)!=s3[i])\n\t\t\t\t\tarr3[i]=1;\n\t\t\t}\n\t\t\tfor(i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tarr1[i]=arr1[i]+arr1[i-1];\n\t\t\t\tarr2[i]=arr2[i]+arr2[i-1];\n\t\t\t\tarr3[i]=arr3[i]+arr3[i-1];\n\t\t\t}\n\t\t\t\n\t\t\tmin1=arr1[k-1];\n\t\t\tmin2=arr2[k-1];\n\t\t\tmin3=arr3[k-1];\n\n\t\t\tfor(i=k;i<n;i++)\n\t\t\t{\n\t\t\t\tif(min1>(arr1[i]-arr1[i-k]))\n\t\t\t\t\tmin1=(arr1[i]-arr1[i-k]);\n\t\t\t\tif(min2>(arr2[i]-arr2[i-k]))\n\t\t\t\t\tmin2=(arr2[i]-arr2[i-k]);\n\t\t\t\tif(min3>(arr3[i]-arr3[i-k]))\n\t\t\t\t\tmin3=(arr3[i]-arr3[i-k]);\n\t\t\t}\n\t\t\tSystem.out.println(Math.min(min1,Math.min(min2,min3)));\n\t\t}\n\t}\n}", "index": 541, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class D {\n\n\tpublic static int[][] dp = new int[200005][3];\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tPrintWriter cout = new PrintWriter(System.out);\n\t\t\n\t\tint q = cin.nextInt();\n\t\tint[] a = new int[200005];\n\t\tint n, k;\n\t\twhile (q-- > 0) {\n\t\t\tn = cin.nextInt();\n\t\t\tk = cin.nextInt();\n\t\t\tString chuoi = cin.nextLine();\n\t\t\tchuoi = cin.nextLine();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tchar ch = chuoi.charAt(i-1);\n\t\t\t\tif (ch == 'R') a[i] = 1;\n\t\t\t\tif (ch == 'G') a[i] = 2;\n\t\t\t\tif (ch == 'B') a[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tfor (int x = 0; x < 3; x++) {\n\t\t\t\t\tdp[i][x] = dp[i-1][x];\n\t\t\t\t\tif (a[i] != (x + i)%3) dp[i][x]++;\n\t\t\t\t}\n\t\t\t\n\t\t\tint res = 1000000007;\n\t\t\tfor (int i = k; i <= n; i++) \n\t\t\t\tfor (int x = 0; x < 3; x++)\n\t\t\t\t\tres = Math.min(res, dp[i][x] - dp[i-k][x]);\n\t\t\t\t\t\n\t\t\tcout.println(res);\n\t\t}\n\t\tcout.close();\n\t}\n}", "index": 542, "complexity": "3"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class CodeForces {\n\n\tpublic static int difference(String s, String b, int n, int k) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] pre = new int[n];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (i == 1) {\n\t\t\t\tpre[i - 1] = (s.charAt(i-1) == b.charAt(i-1) ? 0 : 1);\n\t\t\t}\n\t\t\tpre[i] = pre[i - 1] + (s.charAt(i) == b.charAt(i) ? 0 : 1);\n\t\t}\n\t\tint v = -1;\n\t\tfor (int i = k - 1; i < n; i++) {\n\t\t\tmin = Math.min(min, pre[i] - (v == -1 ? 0 : pre[v]));\n\t\t\tv++;\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint t = sc.nextInt();\n\t\tO: while (t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tString s = sc.nextLine();\n\t\t\tint c = 1;\n\t\t\tStringBuilder R = new StringBuilder();\n\t\t\tStringBuilder G = new StringBuilder();\n\t\t\tStringBuilder B = new StringBuilder();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (c % 3 == 1) {\n\t\t\t\t\tR.append(\"R\") ;\n\t\t\t\t\tG.append(\"G\");\n\t\t\t\t\tB.append(\"B\");\n\t\t\t\t} else if (c % 3 == 2) {\n\t\t\t\t\tR.append(\"G\");\n\t\t\t\t\tG.append(\"B\");\n\t\t\t\t\tB.append(\"R\");\n\t\t\t\t} else {\n\t\t\t\t\tR.append(\"B\");\n\t\t\t\t\tG.append(\"R\");\n\t\t\t\t\tB.append(\"G\");\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tString RR = R.toString(),BB = B.toString() , GG = G.toString();\n\t\t\tString[] arr = new String[] { RR, BB, GG };\n\t\t\tint i = 0;\n\t\t\tint j = k;\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\twhile (i < 3) {\n\t\t\t\tmin = Math.min(min, difference(s, arr[i], n, k));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tpw.println(min);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic class SegmentTree {\n\t\tstatic int[] S, in;\n\t\tstatic int N;\n\n\t\tpublic SegmentTree(int[] arr) {\n\t\t\tin = arr;\n\t\t\tN = in.length - 1;\n\t\t\tS = new int[N << 1];\n\t\t\tbuild(1, 1, N);\n\t\t}\n\n\t\tstatic int stat;\n\n\t\tvoid build(int node, int b, int e) {\n\t\t\tif (b == e) {\n\t\t\t\tS[node] = in[b];\n\t\t\t\tstat = 1;\n\t\t\t} else {\n\t\t\t\tint mid = (b + e) / 2;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[node] = S[node << 1] | S[node << 1 | 1];\n\n\t\t\t\t} else {\n\t\t\t\t\tS[node] = S[node << 1] ^ S[node << 1 | 1];\n\t\t\t\t}\n\t\t\t\tstat = 1 - stat;\n\t\t\t}\n\t\t}\n\n\t\tint update(int idx, int val) {\n\t\t\tidx += (N - 1);\n\n\t\t\tS[idx] = val;\n\t\t\tint stat = 1;\n\t\t\twhile (idx > 1) {\n\t\t\t\tidx >>= 1;\n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tS[idx] = S[idx << 1] | S[idx << 1 | 1];\n\t\t\t\t\tstat = 0;\n\t\t\t\t} else {\n\t\t\t\t\tS[idx] = S[idx << 1] ^ S[idx << 1 | 1];\n\t\t\t\t\tstat = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn S[1];\n\t\t}\n\n\t}\n\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint a, b;\n\n\t\tpublic Pair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic int compareTo(Pair A) {\n\t\t\tif (a != A.a)\n\t\t\t\treturn A.a - a;\n\t\t\treturn A.b - b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader r) {\n\t\t\tbr = new BufferedReader(r);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "index": 543, "complexity": "3"}
{"forwhile": "class GFG { static void findTriplets(int arr[], int n) { boolean found = false; Arrays.sort(arr); int i = 0; while(i < n - 1) { int l = i + 1; int r = n - 1; int x = arr[i]; for(; l < r; l++, r--) { if(x + arr[l] + arr[r] == 0) { System.out.print(x + \" \"); System.out.print(arr[l]+ \" \"); System.out.println(arr[r]+ \" \"); found = true; } else if(x + arr[l] + arr[r] < 0) l++; else r--; } i++; } if(found == false) System.out.println(\" No Triplet Found\"); } public static void main (String[] args) { int arr[] = { 0, -1, 2, -3, 1}; int n =arr.length; findTriplets(arr, n); } }", "src": "class\nGFG { \n\n\nstatic\nvoid\nfindTriplets(\nint\narr[], \nint\nn) \n{ \n\nboolean\nfound = \nfalse\n; \n\n\n\n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\n{ \n\n\n\nint\nl = i + \n1\n; \n\nint\nr = n - \n1\n; \n\nint\nx = arr[i]; \n\nwhile\n(l < r) \n\n{ \n\nif\n(x + arr[l] + arr[r] == \n0\n) \n\n{ \n\n\n\nSystem.out.print(x + \n\" \"\n); \n\nSystem.out.print(arr[l]+ \n\" \"\n); \n\nSystem.out.println(arr[r]+ \n\" \"\n); \n\n\nl++; \n\nr--; \n\nfound = \ntrue\n; \n\n} \n\n\n\n\n\n\nelse\nif\n(x + arr[l] + arr[r] < \n0\n) \n\nl++; \n\n\n\n\n\n\nelse\n\nr--; \n\n} \n\n} \n\n\nif\n(found == \nfalse\n) \n\nSystem.out.println(\n\" No Triplet Found\"\n); \n} \n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n0\n, -\n1\n, \n2\n, -\n3\n, \n1\n}; \n\nint\nn =arr.length; \n\nfindTriplets(arr, n); \n\n} \n\n}", "index": 544, "complexity": "3"}
{"forwhile": "class GFG { static int binomialCoeff(int n, int k) { int C[] = new int[k + 1]; C[0] = 1; int i = 1; while(i <= n) { int j = Math.min(i, k); while(j > 0) { C[j] = C[j] + C[j-1]; j--; } i++; } return C[k]; } public static void main(String[] args) { int n = 5, k = 2; System.out.printf(\"Value of C(%d, %d) is %d \", n, k, binomialCoeff(n, k)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nbinomialCoeff(\nint\nn, \nint\nk) \n\n{ \n\nint\nC[] = \nnew\nint\n[k + \n1\n]; \n\n\n\n\nC[\n0\n] = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++) \n\n{ \n\n\n\n\n\nfor\n(\nint\nj = Math.min(i, k); j > \n0\n; j--) \n\nC[j] = C[j] + C[j-\n1\n]; \n\n} \n\nreturn\nC[k]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn = \n5\n, k = \n2\n; \n\nSystem.out.printf(\n\"Value of C(%d, %d) is %d \"\n\n, n, k, binomialCoeff(n, k)); \n\n} \n}", "index": 545, "complexity": "3"}
{"forwhile": "class GFG { static void printArray(int A[], int size) { int i = 0; while(i < size) System.out.print(A[i] + \" \"); System.out.println(\"\"); ; } static void reverse(int arr[], int l, int r) { if (l < r) { arr = swap(arr, l, r); for(; l < r; l++, r--) reverse(arr, l, r); } } static void merge(int arr[], int l, int m, int r) { int i = l; int j = m + 1; for(; i <= m && arr[i] < 0; i++); for(; j <= r && arr[j] < 0; j++); reverse(arr, i, m); reverse(arr, m + 1, j - 1); reverse(arr, i, j - 1); } static void RearrangePosNeg(int arr[], int l, int r) { if (l < r) { int m = l + (r - l) / 2; RearrangePosNeg(arr, l, m); RearrangePosNeg(arr, m + 1, r); merge(arr, l, m, r); } } static int[] swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } public static void main(String[] args) { int arr[] = { -12, 11, -13, -5, 6, -7, 5, -3, -6}; int arr_size = arr.length; RearrangePosNeg(arr, 0, arr_size - 1); printArray(arr, arr_size); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nvoid\nprintArray(\nint\nA[], \nint\nsize) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < size; i++) \n\nSystem.out.print(A[i] + \n\" \"\n); \n\nSystem.out.println(\n\"\"\n); \n\n; \n\n} \n\n\n\n\nstatic\nvoid\nreverse(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\narr = swap(arr, l, r); \n\nreverse(arr, ++l, --r); \n\n} \n\n} \n\n\n\n\n\n\n\n\nstatic\nvoid\nmerge(\nint\narr[], \nint\nl, \nint\nm, \nint\nr) \n\n{ \n\nint\ni = l; \n\n\nint\nj = m + \n1\n; \n\n\n\nwhile\n(i <= m && arr[i] < \n0\n) \n\ni++; \n\n\n\n\n\nwhile\n(j <= r && arr[j] < \n0\n) \n\nj++; \n\n\n\n\n\n\n\n\n\nreverse(arr, i, m); \n\n\n\n\n\n\nreverse(arr, m + \n1\n, j - \n1\n); \n\n\n\n\nreverse(arr, i, j - \n1\n); \n\n} \n\n\n\n\n\n\nstatic\nvoid\nRearrangePosNeg(\nint\narr[], \nint\nl, \nint\nr) \n\n{ \n\nif\n(l < r) { \n\n\n\n\n\nint\nm = l + (r - l) / \n2\n; \n\n\n\n\nRearrangePosNeg(arr, l, m); \n\nRearrangePosNeg(arr, m + \n1\n, r); \n\n\nmerge(arr, l, m, r); \n\n} \n\n} \n\nstatic\nint\n[] swap(\nint\n[] arr, \nint\ni, \nint\nj) \n\n{ \n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\nreturn\narr; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { -\n12\n, \n11\n, -\n13\n, -\n5\n, \n6\n, -\n7\n, \n5\n, -\n3\n, -\n6\n}; \n\nint\narr_size = arr.length; \n\n\nRearrangePosNeg(arr, \n0\n, arr_size - \n1\n); \n\n\nprintArray(arr, arr_size); \n\n} \n}", "index": 546, "complexity": "3"}
{"forwhile": "class GFG { static int minJumps(int arr[], int n) { int[] jumps = new int[n]; int min; jumps[n - 1] = 0; int i = n - 2; while(i >= 0) { if(arr[i] == 0) jumps[i] = Integer.MAX_VALUE; else if(arr[i] >= n - i - 1) jumps[i] = 1; else { min = Integer.MAX_VALUE; int j = i + 1; while(j < n && j <= arr[i] + i) { if(min > jumps[j]) min = jumps[j]; j++; } if(min != Integer.MAX_VALUE) jumps[i] = min + 1; else jumps[i] = min; } i--; } return jumps[0]; } public static void main(String[] args) { int[] arr = {1, 3, 6, 1, 0, 9}; int size = arr.length; System.out.println(\"Minimum number of jumps to reach end is \" + minJumps(arr, size)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nminJumps(\nint\narr[], \n\nint\nn) \n{ \n\n\n\n\n\nint\n[] jumps = \nnew\nint\n[n]; \n\nint\nmin; \n\n\n\n\n\n\n\n\n\n\njumps[n - \n1\n] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(arr[i] == \n0\n) \n\njumps[i] = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nelse\nif\n(arr[i] >= n - i - \n1\n) \n\njumps[i] = \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\nmin = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n && \n\nj <= arr[i] + i; j++) \n\n{ \n\nif\n(min > jumps[j]) \n\nmin = jumps[j]; \n\n} \n\n\n\n\nif\n(min != Integer.MAX_VALUE) \n\njumps[i] = min + \n1\n; \n\nelse\n\njumps[i] = min; \n\n\n} \n\n} \n\n\nreturn\njumps[\n0\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\n[] arr = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Minimum number of\"\n+ \n\n\" jumps to reach end is \"\n+ \n\nminJumps(arr, size)); \n\n} \n}", "index": 547, "complexity": "3"}
{"forwhile": "class GFG { static int minJumps(int arr[], int n) { int[] jumps = new int[n]; int min; jumps[n - 1] = 0; int i = n - 2; while (i >= 0) { if (arr[i] == 0) jumps[i] = Integer.MAX_VALUE; else if (arr[i] >= n - i - 1) jumps[i] = 1; else { min = Integer.MAX_VALUE; int j = i + 1; while (j < n && j <= arr[i] + i) { if (min > jumps[j]) min = jumps[j]; j++; } if (min != Integer.MAX_VALUE) jumps[i] = min + 1; else jumps[i] = min; } i--; } return jumps[0]; } public static void main(String[] args) { int[] arr = {1, 3, 6, 1, 0, 9}; int size = arr.length; System.out.println(\"Minimum number of\"+ \" jumps to reach end is \"+ minJumps(arr, size)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nminJumps(\nint\narr[], \n\nint\nn) \n{ \n\n\n\n\n\nint\n[] jumps = \nnew\nint\n[n]; \n\nint\nmin; \n\n\n\n\n\n\n\n\n\n\njumps[n - \n1\n] = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = n - \n2\n; i >= \n0\n; i--) \n\n{ \n\n\n\n\n\nif\n(arr[i] == \n0\n) \n\njumps[i] = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nelse\nif\n(arr[i] >= n - i - \n1\n) \n\njumps[i] = \n1\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nelse\n\n{ \n\n\n\nmin = Integer.MAX_VALUE; \n\n\n\n\n\n\n\n\nfor\n(\nint\nj = i + \n1\n; j < n && \n\nj <= arr[i] + i; j++) \n\n{ \n\nif\n(min > jumps[j]) \n\nmin = jumps[j]; \n\n} \n\n\n\n\nif\n(min != Integer.MAX_VALUE) \n\njumps[i] = min + \n1\n; \n\nelse\n\njumps[i] = min; \n\n\n} \n\n} \n\n\nreturn\njumps[\n0\n]; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\n[] arr = {\n1\n, \n3\n, \n6\n, \n1\n, \n0\n, \n9\n}; \n\nint\nsize = arr.length; \n\nSystem.out.println(\n\"Minimum number of\"\n+ \n\n\" jumps to reach end is \"\n+ \n\nminJumps(arr, size)); \n\n} \n}", "index": 548, "complexity": "3"}
{"forwhile": "public class GfG {\n\n    public static void rearrangeArr(int arr[], int n) {\n\n        int evenPos = n / 2;\n\n        int oddPos = n - evenPos;\n\n        int[] tempArr = new int[n];\n\n        int i = 0;\n        while (i < n) \n            tempArr[i] = arr[i];\n\n        Arrays.sort(tempArr);\n\n        int j = oddPos - 1;\n\n        i = 0;\n        while (i < n) {\n            arr[i] = tempArr[j];\n            j--;\n            i += 2;\n        }\n\n        j = oddPos;\n\n        i = 1;\n        while (i < n) {\n            arr[i] = tempArr[j];\n            j++;\n            i += 2;\n        }\n\n        i = 0;\n        while (i < n)\n            System.out.print(arr[i] + \" \");\n    }\n\n    public static void main(String argc[]) {\n\n        int[] arr = new int[]{1, 2, 3, 4, 5, 6, 7};\n        int size = 7;\n        rearrangeArr(arr, size);\n\n    }\n}", "src": "public\nclass\nGfG{ \n\n\n\npublic\nstatic\nvoid\nrearrangeArr(\nint\narr[], \n\nint\nn) \n\n{ \n\n\n\nint\nevenPos = n / \n2\n; \n\n\n\n\nint\noddPos = n - evenPos; \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ntempArr[i] = arr[i]; \n\n\n\n\nArrays.sort(tempArr); \n\n\nint\nj = oddPos - \n1\n; \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj--; \n\n} \n\n\nj = oddPos; \n\n\n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n; i += \n2\n) { \n\narr[i] = tempArr[j]; \n\nj++; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String argc[]){ \n\nint\n[] arr = \nnew\nint\n[]{ \n1\n, \n2\n, \n3\n, \n4\n, \n5\n, \n\n6\n, \n7\n}; \n\nint\nsize = \n7\n; \n\nrearrangeArr(arr, size); \n\n\n} \n}", "index": 549, "complexity": "5"}
{"forwhile": "public class ladder {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int problems = sc.nextInt();\n        int i = 0;\n        while(i < problems) {\n            int numPlanks = sc.nextInt();\n            solve(numPlanks, sc);\n            i++;\n        }\n\n\n\n\n\n    }\n    public static void solve(int numPlanks, Scanner sc) {\n        int answer;\n        ArrayList<Integer> planks  = new ArrayList<>();\n        int j = 0;\n        while(j < numPlanks) {\n            planks.add(sc.nextInt());\n            j++;\n        }\n\n        Collections.sort(planks);\n\n        planks.remove(numPlanks - 1);\n        planks.add(planks.get(numPlanks - 2));\n        int base = planks.get(numPlanks - 1) - 1;\n        if ((numPlanks - 2) > base) {\n            answer = base;\n        }\n        else {\n            answer = numPlanks - 2;\n        }\n        if (base == 0) {\n            answer = 0;\n        }\n        System.out.println(answer);\n    }\n}", "src": "public class ladder {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int problems = sc.nextInt();\n        for (int i = 0; i < problems; i++) {\n            int numPlanks = sc.nextInt();\n            solve(numPlanks, sc);\n        }\n\n\n\n\n\n    }\n    public static void solve(int numPlanks, Scanner sc) {\n        int answer;\n        ArrayList<Integer> planks  = new ArrayList<>();\n        for (int i = 0; i < numPlanks; i++) {\n            planks.add(sc.nextInt());\n        }\n\n        Collections.sort(planks);\n\n        planks.remove(numPlanks - 1);\n        planks.add(planks.get(numPlanks - 2));\n        int base = planks.get(numPlanks - 1) - 1;\n        if ((numPlanks - 2) > base) {\n            answer = base;\n        }\n        else {\n            answer = numPlanks - 2;\n        }\n        if (base == 0) {\n            answer = 0;\n        }\n        System.out.println(answer);\n    }\n}", "index": 550, "complexity": "5"}
{"forwhile": "public class Main\n{\n    \n     static void merge(int arr[], int l, int m, int r) \n    { \n        \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        \n        int i = 0; \n        while (i < n1) \n        { \n            L[i] = arr[l + i]; \n            i++; \n        } \n        int j = 0; \n        while (j < n2) \n        { \n            R[j] = arr[m + 1+ j]; \n            j++; \n        } \n  \n        \n  \n        \n        i = 0; \n        j = 0; \n        int k = l; \n        for(; i < n1 && j < n2;) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        \n        for(; i < n1;) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        \n        for(; j < n2;) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    \n    \n    static void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            \n            int m = (l+r)/2; \n  \n            \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            \n            merge(arr, l, m, r); \n        } \n    } \n  \n    public static void main(String args[]) throws Exception\n    {\n        Scanner sc=new Scanner(System.in);\n        int q=sc.nextInt();\n        for(; q > 0;) \n        {\n            \n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int i=0;\n            while(i < n)\n            {\n                a[i]=sc.nextInt();\n                i++;\n            }\n            sort(a,0,n-1);\n            int p=a[n-2]-1;\n            if(n-2>=p)\n                System.out.println(p);\n            else if (n-2==0)\n                System.out.println(0);\n            else \n                System.out.println(n-2);\n            q--;\n        }\n        \n    }\n        \n}", "src": "public class Main\n{\n    \n     static void merge(int arr[], int l, int m, int r) \n    { \n        \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        \n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        \n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        \n  \n        \n        int i = 0, j = 0; \n  \n        \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        \n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        \n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    \n    \n    static void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            \n            int m = (l+r)/2; \n  \n            \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            \n            merge(arr, l, m, r); \n        } \n    } \n  \n    public static void main(String args[]) throws Exception\n    {\n        Scanner sc=new Scanner(System.in);\n        int q=sc.nextInt();\n        while(q>0)\n        {\n            \n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int i=0;\n            for(i=0;i<n;i++)\n                a[i]=sc.nextInt();\n           sort(a,0,n-1);\n           int p=a[n-2]-1;\n            if(n-2>=p)\n                System.out.println(p);\n            else if (n-2==0)\n            System.out.println(0);\n            else \n                System.out.println(n-2);\n            q--;\n        }\n        \n    }\n        \n    }", "index": 551, "complexity": "5"}
{"forwhile": "public class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        long[] a = new long[n];\n        int i = 0;\n        while(i < n){\n            a[i] = Long.parseLong(st.nextToken());\n            i++;\n        }\n        Queue<Long> ts = new PriorityQueue<Long>();\n        i = 1;\n        while(i < n){\n            ts.add(a[i] - a[i - 1]);\n            i++;\n        }\n        long sum = 0;\n        i = 0;\n        while(i < n - k){\n            sum += ts.poll();\n            i++;\n        }\n        System.out.println(sum);\n    }\n}", "src": "public class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        long[] a = new long[n];\n        for(int i=0;i<n;i++) a[i] = Long.parseLong(st.nextToken());\n        Queue<Long> ts = new PriorityQueue<Long>();\n        for(int i=1;i<n;i++) ts.add(a[i]-a[i-1]);\n        long sum = 0;\n        for(int i=0;i<n-k;i++){\n            sum += ts.poll();\n        }\n        System.out.println(sum);\n    }\n}", "index": 552, "complexity": "5"}
{"forwhile": "public final class Cf\n{\n    public static void main(String[]args)\n    {\n        FastReader ob=new FastReader();\n        \n        \n        {\n            int n=ob.nextInt();\n            int k=ob.nextInt();\n            int a[]=new int[n];\n            int i=0;\n            while(i<n)\n            {\n                a[i]=ob.nextInt();\n                i++;\n            }\n            int x=a[n-1]-a[0];\n            ArrayList<Integer> b=new ArrayList<>();\n            i=0;\n            while(i<n-1)\n            {\n                b.add(-a[i+1]+a[i]);\n                i++;\n            }\n            Collections.sort(b);\n            i=0;\n            while(i<k-1)\n            {\n                x+=b.get(i);\n                i++;\n            }\n            System.out.println(x);\n        }\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n        for(; st == null || !st.hasMoreElements(); ) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextLine()\n    {\n        String s=\"\";\n        try {\n            s=br.readLine();\n        } catch (IOException e)  {\n            e.printStackTrace();\n        }\n        return s;\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}", "src": "public final class Cf\n{\n    public static void main(String[]args)\n    {\n        FastReader ob=new FastReader();\n        \n        \n        {\n            int n=ob.nextInt();\n            int k=ob.nextInt();\n            int a[]=new int[n];\n            for(int i=0;i<n;i++)\n            a[i]=ob.nextInt();\n            int x=a[n-1]-a[0];\n            ArrayList<Integer> b=new ArrayList<>();\n            for(int i=0;i<n-1;i++)\n            b.add(-a[i+1]+a[i]);\n            Collections.sort(b);\n            for(int i=0;i<k-1;i++)\n            x+=b.get(i);\n            System.out.println(x);\n        }\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextLine()\n    {\n        String s=\"\";\n        try {\n        s=br.readLine();\n        } catch (IOException e)  {\n                e.printStackTrace();\n            }\n        return s;\n    }\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}", "index": 553, "complexity": "5"}
{"forwhile": "class GFG { static int findMaxSubarraySumUtil(int A[], int B[], int n, int m) { int max_so_far = Integer.MIN_VALUE, curr_max = 0; int i = 0; while(i < n) { if(Arrays.binarySearch(B, A[i]) >= 0) { curr_max = 0; i++; continue; } curr_max = Math.max(A[i], curr_max + A[i]); max_so_far = Math.max(max_so_far, curr_max); i++; } return max_so_far; } static void findMaxSubarraySum(int A[], int B[], int n, int m) { Arrays.sort(B); int maxSubarraySum = findMaxSubarraySumUtil(A, B, n, m); if(maxSubarraySum == Integer.MIN_VALUE) { System.out.println(\"Maximum subarray sum cant be found\"); } else { System.out.println(\"The Maximum subarray sum = \" + maxSubarraySum); } } public static void main(String[] args) { int A[] = { 3, 4, 5, -4, 6 }; int B[] = { 1, 8, 5 }; int n = A.length; int m = B.length; findMaxSubarraySum(A, B, n, m); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic\nint\nfindMaxSubarraySumUtil(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\n\nint\nmax_so_far = Integer.MIN_VALUE, curr_max = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\n\nif\n(Arrays.binarySearch(B, A[i]) >= \n0\n) \n\n{ \n\ncurr_max = \n0\n; \n\ncontinue\n; \n\n} \n\n\n\n\ncurr_max = Math.max(A[i], curr_max + A[i]); \n\nmax_so_far = Math.max(max_so_far, curr_max); \n\n} \n\nreturn\nmax_so_far; \n\n} \n\n\n\n\nstatic\nvoid\nfindMaxSubarraySum(\nint\nA[], \nint\nB[], \n\nint\nn, \nint\nm) \n\n{ \n\n\n\nArrays.sort(B); \n\n\nint\nmaxSubarraySum = findMaxSubarraySumUtil(A, B, \n\nn, m); \n\n\n\n\n\n\n\n\nif\n(maxSubarraySum == Integer.MIN_VALUE) \n\n{ \n\nSystem.out.println(\n\"Maximum subarray sum cant be found\"\n); \n\n} \n\nelse\n\n{ \n\nSystem.out.println(\n\"The Maximum subarray sum = \"\n\n+ maxSubarraySum); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = {\n3\n, \n4\n, \n5\n, -\n4\n, \n6\n}; \n\nint\nB[] = {\n1\n, \n8\n, \n5\n}; \n\n\nint\nn = A.length; \n\nint\nm = B.length; \n\n\n\n\nfindMaxSubarraySum(A, B, n, m); \n\n} \n}", "index": 555, "complexity": "5"}
{"forwhile": "class GFG { \n\n\n\n\nstatic int maximum( int a,  int b,  int c) \n\n{ \n\nreturn Math.max(Math.max(a, b), c); \n\n} \n\n\n\n\nstatic int minimum( int a,  int b,  int c) \n\n{ \n\nreturn Math.min(Math.min(a, b), c); \n\n} \n\n\n\n\n\n\nstatic void smallestDifferenceTriplet( int arr1[],  int arr2[],  int arr3[],  int n) \n\n{ \n\n\n\n\nArrays.sort(arr1); \n\nArrays.sort(arr2); \n\nArrays.sort(arr3); \n\n\n\n\nint res_min= 0 , res_max= 0 , res_mid= 0 ; \n\n\n\n\n\n\nint i = 0 , j = 0 , k = 0 ; \n\n\nfor(; (i < n && j < n && k < n); ) \n\n{ \n\nint sum = arr1[i] + arr2[j] + arr3[k]; \n\n\n\n\nint max = maximum(arr1[i], arr2[j], arr3[k]); \n\n\n\n\nint min = minimum(arr1[i], arr2[j], arr3[k]); \n\nif(min == arr1[i]) \n\ni++; \n\nelse if(min == arr2[j]) \n\nj++; \n\nelse \n\nk++; \n\n\n\n\n\n\nif(diff > (max - min)) \n\n{ \n\ndiff = max - min; \n\nres_max = max; \n\nres_mid = sum - (max + min); \n\nres_min = min; \n\n} \n\n} \n\n\n\nSystem.out.print(res_max + \", \" + res_mid + \", \" + res_min); \n\n} \n\n\n\npublic static void main (String[] args) \n\n{ \n\n\nint arr1[] = { 5 , 2 , 8 }; \n\nint arr2[] = { 10 , 7 , 12 }; \n\nint arr3[] = { 9 , 14 , 6 }; \n\n\nint n = arr1.length; \n\n\nsmallestDifferenceTriplet(arr1, arr2, arr3, n); \n\n} \n}", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nmaximum(\nint\na, \nint\nb, \nint\nc) \n\n{ \n\nreturn\nMath.max(Math.max(a, b), c); \n\n} \n\n\n\n\nstatic\nint\nminimum(\nint\na, \nint\nb, \nint\nc) \n\n{ \n\nreturn\nMath.min(Math.min(a, b), c); \n\n} \n\n\n\n\n\n\nstatic\nvoid\nsmallestDifferenceTriplet(\nint\narr1[], \n\nint\narr2[], \nint\narr3[], \nint\nn) \n\n{ \n\n\n\n\nArrays.sort(arr1); \n\nArrays.sort(arr2); \n\nArrays.sort(arr3); \n\n\n\n\nint\nres_min=\n0\n, res_max=\n0\n, res_mid=\n0\n; \n\n\n\n\n\n\nint\ni = \n0\n, j = \n0\n, k = \n0\n; \n\n\n\n\n\n\nint\ndiff = \n2147483647\n; \n\n\nwhile\n(i < n && j < n && k < n) \n\n{ \n\nint\nsum = arr1[i] + arr2[j] + arr3[k]; \n\n\n\n\nint\nmax = maximum(arr1[i], arr2[j], arr3[k]); \n\n\n\n\nint\nmin = minimum(arr1[i], arr2[j], arr3[k]); \n\nif\n(min == arr1[i]) \n\ni++; \n\nelse\nif\n(min == arr2[j]) \n\nj++; \n\nelse\n\nk++; \n\n\n\n\n\n\nif\n(diff > (max - min)) \n\n{ \n\ndiff = max - min; \n\nres_max = max; \n\nres_mid = sum - (max + min); \n\nres_min = min; \n\n} \n\n} \n\n\n\n\nSystem.out.print(res_max + \n\", \"\n+ res_mid \n\n+ \n\", \"\n+ res_min); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\nint\narr1[] = {\n5\n, \n2\n, \n8\n}; \n\nint\narr2[] = {\n10\n, \n7\n, \n12\n}; \n\nint\narr3[] = {\n9\n, \n14\n, \n6\n}; \n\n\nint\nn = arr1.length; \n\n\nsmallestDifferenceTriplet(arr1, arr2, arr3, n); \n\n} \n}", "index": 557, "complexity": "5"}
{"forwhile": "class GFG { static int R = 4, C = 4; static int first(int arr[], int low, int high) { if (high >= low) { int mid = low + (high - low) / 2; if ((mid == 0 || (arr[mid - 1] == 0)) && arr[mid] == 1) return mid; else if (arr[mid] == 0) return first(arr, (mid + 1), high); else return first(arr, low, (mid - 1)); } return -1; } static int rowWithMax1s(int mat[][]) { int max_row_index = 0, max = -1; int i = 0, index; while (i < R) { index = first(mat[i], 0, C - 1); if (index != -1 && C - index > max) { max = C - index; max_row_index = i; } i++; } return max_row_index; } public static void main(String[] args) { int mat[][] = { { 0, 0, 0, 1}, { 0, 1, 1, 1}, { 1, 1, 1, 1}, { 0, 0, 0, 0} }; System.out.println(\"Index of row with maximum 1s is \" + rowWithMax1s(mat)); } }", "src": "class\nGFG { \n\nstatic\nint\nR = \n4\n, C = \n4\n; \n\n\n\n\n\nstatic\nint\nfirst(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(high >= low) { \n\n\n\nint\nmid = low + (high - low) / \n2\n; \n\n\n\n\nif\n((mid == \n0\n|| (arr[mid - \n1\n] == \n0\n)) && arr[mid] == \n1\n) \n\nreturn\nmid; \n\n\n\n\nelse\nif\n(arr[mid] == \n0\n) \n\nreturn\nfirst(arr, (mid + \n1\n), high); \n\n\n\n\nelse\n\nreturn\nfirst(arr, low, (mid - \n1\n)); \n\n} \n\nreturn\n-\n1\n; \n\n} \n\n\n\n\n\n\nstatic\nint\nrowWithMax1s(\nint\nmat[][]) \n\n{ \n\n\n\nint\nmax_row_index = \n0\n, max = -\n1\n; \n\n\n\n\n\n\nint\ni, index; \n\nfor\n(i = \n0\n; i < R; i++) { \n\nindex = first(mat[i], \n0\n, C - \n1\n); \n\nif\n(index != -\n1\n&& C - index > max) { \n\nmax = C - index; \n\nmax_row_index = i; \n\n} \n\n} \n\n\nreturn\nmax_row_index; \n\n} \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nmat[][] = { { \n0\n, \n0\n, \n0\n, \n1\n}, \n\n{ \n0\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n1\n, \n1\n, \n1\n, \n1\n}, \n\n{ \n0\n, \n0\n, \n0\n, \n0\n} }; \n\nSystem.out.println(\n\"Index of row with maximum 1s is \"\n\n+ rowWithMax1s(mat)); \n\n} \n}", "index": 558, "complexity": "5"}
{"forwhile": "public class GFG { static void rearrangeArray(int arr[], int n) { Arrays.sort(arr); int [] tempArr = new int[n]; int ArrIndex = 0; int i = 0, j = n-1; while(i <= n / 2 || j > n / 2) { if(ArrIndex < n) { tempArr[ArrIndex] = arr[i]; ArrIndex++; } if(ArrIndex < n) { tempArr[ArrIndex] = arr[j]; ArrIndex++; } i++; j--; } int k = 0; for(; k < n; k++) arr[k] = tempArr[k]; } public static void main(String args[]) { int arr[] = { 5, 8, 1, 4, 2, 9, 3, 7, 6}; int n = arr.length; rearrangeArray(arr, n); int i = 0; for(; i < n; i++) System.out.print(arr[i]+ \" \"); } }", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nvoid\nrearrangeArray(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\nint\n[] tempArr = \nnew\nint\n[n]; \n\n\n\n\n\n\n\nint\nArrIndex = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n, j = n-\n1\n; i <= n / \n2\n|| j > n / \n2\n; \n\ni++, j--) { \n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[i]; \n\nArrIndex++; \n\n} \n\n\nif\n(ArrIndex < n) \n\n{ \n\ntempArr[ArrIndex] = arr[j]; \n\nArrIndex++; \n\n} \n\n} \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\narr[i] = tempArr[i]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\narr[] = { \n5\n, \n8\n, \n1\n, \n4\n, \n2\n, \n9\n, \n3\n, \n7\n, \n6\n}; \n\nint\nn = arr.length; \n\nrearrangeArray(arr, n); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i]+\n\" \"\n); \n\n} \n}", "index": 559, "complexity": "5"}
{"forwhile": "class LinkedList { static Node head; static class Node { int data; Node next, prev; Node(int d) { data = d; next = prev = null; } } void print(Node node) { Node temp = node; System.out.println(\"Forward Traversal using next pointer\"); while(node != null) { System.out.print(node.data + \" \"); temp = node; node = node.next; } System.out.println(\"\\nBackward Traversal using prev pointer\"); for(; temp != null; temp = temp.prev) { System.out.print(temp.data + \" \"); } } Node split(Node head) { Node fast = head, slow = head; for(; fast.next != null && fast.next.next != null; fast = fast.next.next, slow = slow.next) { } Node temp = slow.next; slow.next = null; return temp; } Node mergeSort(Node node) { if(node == null || node.next == null) { return node; } Node second = split(node); node = mergeSort(node); second = mergeSort(second); return merge(node, second); } Node merge(Node first, Node second) { if(first == null) { return second; } if(second == null) { return first; } if(first.data < second.data) { first.next = merge(first.next, second); first.next.prev = first; first.prev = null; return first; } else { second.next = merge(first, second.next); second.next.prev = second; second.prev = null; return second; } } public static void main(String[] args) { LinkedList list = new LinkedList(); list.head = new Node(10); list.head.next = new Node(30); list.head.next.next = new Node(3); list.head.next.next.next = new Node(4); list.head.next.next.next.next = new Node(20); list.head.next.next.next.next.next = new Node(5); Node node = null; node = list.mergeSort(head); System.out.println(\"Linked list after sorting :\"); list.print(node); } }", "src": "class\nLinkedList { \n\n\nstatic\nNode head; \n\n\n\n\n\nstatic\nclass\nNode { \n\n\nint\ndata; \n\nNode next, prev; \n\n\n\n\nNode(\nint\nd) { \n\ndata = d; \n\nnext = prev = \nnull\n; \n\n} \n\n} \n\n\nvoid\nprint(Node node) { \n\nNode temp = node; \n\nSystem.out.println(\n\"Forward Traversal using next pointer\"\n); \n\nwhile\n(node != \nnull\n) { \n\nSystem.out.print(node.data + \n\" \"\n); \n\ntemp = node; \n\nnode = node.next; \n\n} \n\nSystem.out.println(\n\"\\nBackward Traversal using prev pointer\"\n); \n\nwhile\n(temp != \nnull\n) { \n\nSystem.out.print(temp.data + \n\" \"\n); \n\ntemp = temp.prev; \n\n} \n\n} \n\n\n\n\n\n\nNode split(Node head) { \n\nNode fast = head, slow = head; \n\nwhile\n(fast.next != \nnull\n&& fast.next.next != \nnull\n) { \n\nfast = fast.next.next; \n\nslow = slow.next; \n\n} \n\nNode temp = slow.next; \n\nslow.next = \nnull\n; \n\nreturn\ntemp; \n\n} \n\n\nNode mergeSort(Node node) { \n\nif\n(node == \nnull\n|| node.next == \nnull\n) { \n\nreturn\nnode; \n\n} \n\nNode second = split(node); \n\n\n\n\nnode = mergeSort(node); \n\nsecond = mergeSort(second); \n\n\n\n\nreturn\nmerge(node, second); \n\n} \n\n\n\n\nNode merge(Node first, Node second) { \n\n\n\nif\n(first == \nnull\n) { \n\nreturn\nsecond; \n\n} \n\n\n\n\nif\n(second == \nnull\n) { \n\nreturn\nfirst; \n\n} \n\n\n\n\nif\n(first.data < second.data) { \n\nfirst.next = merge(first.next, second); \n\nfirst.next.prev = first; \n\nfirst.prev = \nnull\n; \n\nreturn\nfirst; \n\n} \nelse\n{ \n\nsecond.next = merge(first, second.next); \n\nsecond.next.prev = second; \n\nsecond.prev = \nnull\n; \n\nreturn\nsecond; \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) { \n\n\nLinkedList list = \nnew\nLinkedList(); \n\nlist.head = \nnew\nNode(\n10\n); \n\nlist.head.next = \nnew\nNode(\n30\n); \n\nlist.head.next.next = \nnew\nNode(\n3\n); \n\nlist.head.next.next.next = \nnew\nNode(\n4\n); \n\nlist.head.next.next.next.next = \nnew\nNode(\n20\n); \n\nlist.head.next.next.next.next.next = \nnew\nNode(\n5\n); \n\n\n\nNode node = \nnull\n; \n\nnode = list.mergeSort(head); \n\nSystem.out.println(\n\"Linked list after sorting :\"\n); \n\nlist.print(node); \n\n\n} \n}", "index": 560, "complexity": "5"}
{"forwhile": "public class GenerateBNo  { static void generatePrintBinary(int n)  { Queue<String> q = new LinkedList<String>(); q.add(\"1\"); int i = n; while(i-- > 0) { String s1 = q.peek(); q.remove(); System.out.println(s1); String s2 = s1; q.add(s1 + \"0\"); q.add(s2 + \"1\"); } } public static void main(String[] args)  { int n=10; generatePrintBinary(n); } }", "src": "public\nclass\nGenerateBNo \n{ \n\n\n\nstatic\nvoid\ngeneratePrintBinary(\nint\nn) \n\n{ \n\n\n\nQueue<String> q = \nnew\nLinkedList<String>(); \n\n\n\n\nq.add(\n\"1\"\n); \n\n\n\n\n\n\nwhile\n(n-- > \n0\n) \n\n{ \n\n\n\nString s1 = q.peek(); \n\nq.remove(); \n\nSystem.out.println(s1); \n\n\n\n\nString s2 = s1; \n\n\n\n\nq.add(s1 + \n\"0\"\n); \n\n\n\n\n\n\nq.add(s2 + \n\"1\"\n); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nn=\n10\n; \n\ngeneratePrintBinary(n); \n\n} \n}", "index": 561, "complexity": "5"}
{"forwhile": "class LIS { static int CeilIndex(int A[], int l, int r, int key) { for (int m = l + (r - l) / 2; r - l > 1; m = l + (r - l) / 2) { if (A[m] >= key) r = m; else l = m; } return r; } static int LongestIncreasingSubsequenceLength(int A[], int size) { int[] tailTable = new int[size]; int len; tailTable[0] = A[0]; len = 1; for (int i = 1; i < size; i++) { if (A[i] < tailTable[0]) tailTable[0] = A[i]; else if (A[i] > tailTable[len - 1]) tailTable[len++] = A[i]; else tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]; } return len; } public static void main(String[] args) { int A[] = { 2, 5, 3, 7, 11, 8, 10, 13, 6 }; int n = A.length; System.out.println(\"Length of Longest Increasing Subsequence is \" + LongestIncreasingSubsequenceLength(A, n)); } }", "src": "class\nLIS { \n\n\n\n\n\nstatic\nint\nCeilIndex(\nint\nA[], \nint\nl, \nint\nr, \nint\nkey) \n\n{ \n\nwhile\n(r - l > \n1\n) { \n\nint\nm = l + (r - l) / \n2\n; \n\nif\n(A[m] >= key) \n\nr = m; \n\nelse\n\nl = m; \n\n} \n\n\nreturn\nr; \n\n} \n\n\nstatic\nint\nLongestIncreasingSubsequenceLength(\nint\nA[], \nint\nsize) \n\n{ \n\n\n\n\nint\n[] tailTable = \nnew\nint\n[size]; \n\nint\nlen; \n\n\n\ntailTable[\n0\n] = A[\n0\n]; \n\nlen = \n1\n; \n\nfor\n(\nint\ni = \n1\n; i < size; i++) { \n\nif\n(A[i] < tailTable[\n0\n]) \n\n\n\ntailTable[\n0\n] = A[i]; \n\n\nelse\nif\n(A[i] > tailTable[len - \n1\n]) \n\n\n\ntailTable[len++] = A[i]; \n\n\nelse\n\n\n\n\n\ntailTable[CeilIndex(tailTable, -\n1\n, len - \n1\n, A[i])] = A[i]; \n\n} \n\n\nreturn\nlen; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nA[] = { \n2\n, \n5\n, \n3\n, \n7\n, \n11\n, \n8\n, \n10\n, \n13\n, \n6\n}; \n\nint\nn = A.length; \n\nSystem.out.println(\n\"Length of Longest Increasing Subsequence is \"\n+ LongestIncreasingSubsequenceLength(A, n)); \n\n} \n}", "index": 562, "complexity": "5"}
{"forwhile": "class GFG { static int maxSumPairWithDifferenceLessThanK(int arr[], int N, int K) { Arrays.sort(arr); int dp[] = new int[N]; dp[0] = 0; int i = 1; while (i < N) { dp[i] = dp[i - 1]; if (arr[i] - arr[i - 1] < K) { if (i >= 2) dp[i] = Math.max(dp[i], dp[i - 2] + arr[i] + arr[i - 1]); else dp[i] = Math.max(dp[i], arr[i] + arr[i - 1]); } i++; } return dp[N - 1]; } public static void main (String[] args) { int arr[] = {3, 5, 10, 15, 17, 12, 9}; int N = arr.length; int K = 4; System.out.println ( maxSumPairWithDifferenceLessThanK( arr, N, K)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumPairWithDifferenceLessThanK(\nint\narr[], \n\nint\nN, \nint\nK) \n\n{ \n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\nint\ndp[] = \nnew\nint\n[N]; \n\n\n\n\ndp[\n0\n] = \n0\n; \n\n\nfor\n(\nint\ni = \n1\n; i < N; i++) \n\n{ \n\n\n\n\n\ndp[i] = dp[i-\n1\n]; \n\n\n\n\nif\n(arr[i] - arr[i-\n1\n] < K) \n\n{ \n\n\n\n\n\n\nif\n(i >= \n2\n) \n\ndp[i] = Math.max(dp[i], dp[i-\n2\n] + arr[i] + \n\narr[i-\n1\n]); \n\nelse\n\ndp[i] = Math.max(dp[i], arr[i] + arr[i-\n1\n]); \n\n} \n\n} \n\n\n\n\nreturn\ndp[N - \n1\n]; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n3\n, \n5\n, \n10\n, \n15\n, \n17\n, \n12\n, \n9\n}; \n\nint\nN = arr.length; \n\nint\nK = \n4\n; \n\n\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \n\narr, N, K)); \n\n\n} \n}", "index": 563, "complexity": "5"}
{"forwhile": "class GFG { static int maxSumPairWithDifferenceLessThanK(int arr[], int N, int k) { int maxSum = 0; Arrays.sort(arr); int i = N-1; while(i > 0) { if(arr[i] - arr[i-1] < k) { maxSum += arr[i]; maxSum += arr[i-1]; i--; } i--; } return maxSum; } public static void main (String[] args) { int arr[] = {3, 5, 10, 15, 17, 12, 9}; int N = arr.length; int K = 4; System.out.println ( maxSumPairWithDifferenceLessThanK( arr, N, K)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxSumPairWithDifferenceLessThanK(\nint\narr[], \n\nint\nN, \nint\nk) \n\n{ \n\nint\nmaxSum = \n0\n; \n\n\n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = N-\n1\n; i > \n0\n; --i) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(arr[i] - arr[i-\n1\n] < k) \n\n{ \n\n\n\nmaxSum += arr[i]; \n\nmaxSum += arr[i-\n1\n]; \n\n\n\n\n--i; \n\n} \n\n} \n\n\nreturn\nmaxSum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\n\nint\narr[] = {\n3\n, \n5\n, \n10\n, \n15\n, \n17\n, \n12\n, \n9\n}; \n\nint\nN = arr.length; \n\nint\nK = \n4\n; \n\n\nSystem.out.println ( maxSumPairWithDifferenceLessThanK( \n\narr, N, K)); \n\n} \n}", "index": 564, "complexity": "5"}
{"forwhile": "class GFG { static void find_max(int[] A, int N, int K) { HashMap<Integer, Integer> Count = new HashMap<>(); int i = 0; while(i < K - 1) { if (Count.containsKey(A[i])) Count.put(A[i], 1 + Count.get(A[i])); else Count.put(A[i], 1); i++; } TreeSet<Integer> Myset = new TreeSet<Integer>(); for (Map.Entry x : Count.entrySet()) { if (Integer.parseInt(String.valueOf(x.getValue())) == 1) Myset.add(Integer.parseInt(String.valueOf(x.getKey())); } i = K - 1; while(i < N) { if (Count.containsKey(A[i])) Count.put(A[i], 1 + Count.get(A[i])); else Count.put(A[i], 1); if (Integer.parseInt(String.valueOf(Count.get(A[i]))) == 1) Myset.add(A[i]); else Myset.remove(A[i]); if (Myset.size() == 0) System.out.println(\"Nothing\"); else System.out.println(Myset.last()); int x = A[i - K + 1]; Count.put(x, Count.get(x) - 1); if (Integer.parseInt(String.valueOf(Count.get(x))) == 1) Myset.add(x); if (Integer.parseInt(String.valueOf(Count.get(x))) == 0) Myset.remove(x); i++; } } public static void main(String args[]) { int[] a = { 1, 2, 2, 3, 3 }; int n = a.length; int k = 3; find_max(a, n, k); } }", "src": "class\nGFG { \n\n\nstatic\nvoid\nfind_max(\nint\n[] A, \nint\nN, \nint\nK) \n\n{ \n\n\n\n\n\nHashMap<Integer, Integer> Count = \nnew\nHashMap<>(); \n\nfor\n(\nint\ni = \n0\n; i < K - \n1\n; i++) \n\nif\n(Count.containsKey(A[i])) \n\nCount.put(A[i], \n1\n+ Count.get(A[i])); \n\nelse\n\nCount.put(A[i], \n1\n); \n\n\nTreeSet<Integer> Myset = \nnew\nTreeSet<Integer>(); \n\nfor\n(Map.Entry x : Count.entrySet()) { \n\nif\n(Integer.parseInt(String.valueOf(x.getValue())) == \n1\n) \n\nMyset.add(Integer.parseInt(String.valueOf(x.getKey()))); \n\n} \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = K - \n1\n; i < N; i++) { \n\n\n\n\nif\n(Count.containsKey(A[i])) \n\nCount.put(A[i], \n1\n+ Count.get(A[i])); \n\nelse\n\nCount.put(A[i], \n1\n); \n\n\nif\n(Integer.parseInt(String.valueOf(Count.get(A[i]))) == \n1\n) \n\nMyset.add(A[i]); \n\nelse\n\nMyset.remove(A[i]); \n\n\n\n\n\n\nif\n(Myset.size() == \n0\n) \n\nSystem.out.println(\n\"Nothing\"\n); \n\n\n\n\n\n\nelse\n\nSystem.out.println(Myset.last()); \n\n\n\n\n\n\nint\nx = A[i - K + \n1\n]; \n\nCount.put(x, Count.get(x) - \n1\n); \n\n\nif\n(Integer.parseInt(String.valueOf(Count.get(x))) == \n1\n) \n\nMyset.add(x); \n\nif\n(Integer.parseInt(String.valueOf(Count.get(x))) == \n0\n) \n\nMyset.remove(x); \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[] a = { \n1\n, \n2\n, \n2\n, \n3\n, \n3\n}; \n\nint\nn = a.length; \n\nint\nk = \n3\n; \n\nfind_max(a, n, k); \n\n} \n}", "index": 566, "complexity": "5"}
{"forwhile": "class GFG { static void pairs(int arr[], int n, int k) { int smallest = Integer.MAX_VALUE; int count= 0; int i=0; while(i<n) { int j=i+1; while(j<n) { if( Math.abs(arr[i] + arr[j] - k) < smallest ) { smallest = Math.abs(arr[i] + arr[j] - k); count = 1; } else if(Math.abs(arr[i] + arr[j] - k) == smallest) count++; j++; } i++; } System.out.println(\"Minimal Value = \"+ smallest); System.out.println(\"Total Pairs = \"+ count); } public static void main(String[] args) { int arr[] = {3, 5, 7, 5, 1, 9, 9}; int k = 12; int n = arr.length; pairs(arr, n, k); } }", "src": "class\nGFG { \n\n\n\n\nstatic\nvoid\npairs(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nint\nsmallest = Integer.MAX_VALUE; \n\nint\ncount=\n0\n; \n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n; i++) \n\nfor\n(\nint\nj=i+\n1\n; j<n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n( Math.abs(arr[i] + arr[j] - k) < \n\nsmallest ) \n\n{ \n\nsmallest = Math.abs(arr[i] + arr[j] \n\n- k); \n\ncount = \n1\n; \n\n} \n\n\n\n\n\n\nelse\nif\n(Math.abs(arr[i] + arr[j] - k) \n\n== smallest) \n\ncount++; \n\n} \n\n\n\n\nSystem.out.println(\n\"Minimal Value = \"\n+ \n\nsmallest); \n\nSystem.out.println(\n\"Total Pairs = \"\n+ \n\ncount); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n3\n, \n5\n, \n7\n, \n5\n, \n1\n, \n9\n, \n9\n}; \n\nint\nk = \n12\n; \n\nint\nn = arr.length; \n\npairs(arr, n, k); \n\n} \n}", "index": 567, "complexity": "5"}
{"forwhile": "class ActivitySelection { public static void printMaxActivities(int s[], int f[], int n) { int i, j; System.out.print(\"Following activities are selected : n\"); i = 0; System.out.print(i+\" \"); j = 1; while(j < n) { if(s[j] >= f[i]) { System.out.print(j+\" \"); i = j; } j++; } } public static void main(String[] args) { int s[] = { 1, 3, 0, 5, 8, 5 }; int f[] = { 2, 4, 6, 7, 9, 9 }; int n = s.length; printMaxActivities(s, f, n); } }", "src": "class\nActivitySelection \n{ \n\n\n\n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nprintMaxActivities(\nint\ns[], \nint\nf[], \nint\nn) \n\n{ \n\nint\ni, j; \n\n\nSystem.out.print(\n\"Following activities are selected : n\"\n); \n\n\n\n\ni = \n0\n; \n\nSystem.out.print(i+\n\" \"\n); \n\n\n\n\nfor\n(j = \n1\n; j < n; j++) \n\n{ \n\n\n\n\n\n\n\nif\n(s[j] >= f[i]) \n\n{ \n\nSystem.out.print(j+\n\" \"\n); \n\ni = j; \n\n} \n\n} \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\ns[] = {\n1\n, \n3\n, \n0\n, \n5\n, \n8\n, \n5\n}; \n\nint\nf[] = {\n2\n, \n4\n, \n6\n, \n7\n, \n9\n, \n9\n}; \n\nint\nn = s.length; \n\n\nprintMaxActivities(s, f, n); \n\n} \n\n}", "index": 568, "complexity": "5"}
{"forwhile": "class DisjointSet { int parent[]; DisjointSet(int n) { parent = new int[n + 1]; int i = 0; while(i <= n) { parent[i] = i; i++; } } int find(int s) { if(s == parent[s]) return s; return parent[s] = find(parent[s]); } void merge(int u, int v) { parent[v] = u; } } class Job implements Comparator<Job> { char id; int deadline, profit; public Job() { } public Job(char id, int deadline, int profit) { this.id = id; this.deadline = deadline; this.profit = profit; } public static int findMaxDeadline(ArrayList<Job> arr) { int ans = Integer.MIN_VALUE; for(Job temp : arr) ans = Math.max(temp.deadline, ans); return ans; } public static void printJobScheduling(ArrayList<Job> arr) { Collections.sort(arr, new Job()); int maxDeadline = findMaxDeadline(arr); DisjointSet dsu = new DisjointSet(maxDeadline); for(int i = 0; i < arr.size(); i++) { Job temp = arr.get(i); int availableSlot = dsu.find(temp.deadline); if(availableSlot > 0) { dsu.merge(dsu.find(availableSlot - 1), availableSlot); System.out.print(temp.id + \" \"); } } System.out.println(); } public int compare(Job j1, Job j2) { return j1.profit > j2.profit ? -1 : 1; } } class Main { public static void main(String args[]) { ArrayList<Job> arr = new ArrayList<Job>(); arr.add(new Job('a', 2, 100)); arr.add(new Job('b', 1, 19)); arr.add(new Job('c', 2, 27)); arr.add(new Job('d', 1, 25)); arr.add(new Job('e', 3, 15)); System.out.println(\"Following jobs need to be executed for maximum profit\"); Job.printJobScheduling(arr); } }", "src": "class\nDisjointSet \n{ \n\nint\nparent[]; \n\n\n\n\nDisjointSet(\nint\nn) \n\n{ \n\nparent = \nnew\nint\n[n + \n1\n]; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i <= n; i++) \n\nparent[i] = i; \n\n} \n\n\n\n\nint\nfind(\nint\ns) \n\n{ \n\n\n\nif\n(s == parent[s]) \n\nreturn\ns; \n\nreturn\nparent[s] = find(parent[s]); \n\n} \n\n\n\n\nvoid\nmerge(\nint\nu, \nint\nv) \n\n{ \n\n\n\n\n\nparent[v] = u; \n\n} \n} \n\nclass\nJob \nimplements\nComparator<Job> \n{ \n\n\n\nchar\nid; \n\nint\ndeadline, profit; \n\n\n\n\npublic\nJob() { } \n\npublic\nJob(\nchar\nid,\nint\ndeadline,\nint\nprofit) \n\n{ \n\nthis\n.id = id; \n\nthis\n.deadline = deadline; \n\nthis\n.profit = profit; \n\n} \n\n\n\n\npublic\nstatic\nint\nfindMaxDeadline(ArrayList<Job> arr) \n\n{ \n\nint\nans = Integer.MIN_VALUE; \n\nfor\n(Job temp : arr) \n\nans = Math.max(temp.deadline, ans); \n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nprintJobScheduling(ArrayList<Job> arr) \n\n{ \n\n\n\n\n\nCollections.sort(arr, \nnew\nJob()); \n\n\n\n\n\n\n\n\nint\nmaxDeadline = findMaxDeadline(arr); \n\nDisjointSet dsu = \nnew\nDisjointSet(maxDeadline); \n\n\n\n\nfor\n(Job temp : arr) \n\n{ \n\n\n\n\n\nint\navailableSlot = dsu.find(temp.deadline); \n\n\n\n\n\n\n\nif\n(availableSlot > \n0\n) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndsu.merge(dsu.find(availableSlot - \n1\n), \n\navailableSlot); \n\nSystem.out.print(temp.id + \n\" \"\n); \n\n} \n\n} \n\nSystem.out.println(); \n\n} \n\n\n\n\n\n\npublic\nint\ncompare(Job j1, Job j2) \n\n{ \n\nreturn\nj1.profit > j2.profit? -\n1\n: \n1\n; \n\n} \n} \n\n\nclass\nMain \n{ \n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nArrayList<Job> arr=\nnew\nArrayList<Job>(); \n\narr.add(\nnew\nJob(\n'a'\n,\n2\n,\n100\n)); \n\narr.add(\nnew\nJob(\n'b'\n,\n1\n,\n19\n)); \n\narr.add(\nnew\nJob(\n'c'\n,\n2\n,\n27\n)); \n\narr.add(\nnew\nJob(\n'd'\n,\n1\n,\n25\n)); \n\narr.add(\nnew\nJob(\n'e'\n,\n3\n,\n15\n)); \n\nSystem.out.println(\n\"Following jobs need to be \"\n+ \n\n\"executed for maximum profit\"\n); \n\nJob.printJobScheduling(arr); \n\n} \n}", "index": 569, "complexity": "5"}
{"forwhile": "class GFG { void find3largest(int[] arr) { Arrays.sort(arr); int n = arr.length; int check = 0, count = 1; int i = 1; while(i <= n) { if(count<4) { if(check!=arr[n-i]) { System.out.print(arr[n-i]+\" \"); check = arr[n-i]; count++; } } else break; i++; } } public static void main(String[] args) { GFG obj = new GFG(); int[] arr={12,45,1,-1,45,54,23,5,0,-10}; obj.find3largest(arr); } }", "src": "class\nGFG { \n\nvoid\nfind3largest(\nint\n[] arr) \n\n{ \n\nArrays.sort(arr); \n\n\n\n\nint\nn = arr.length; \n\nint\ncheck = \n0\n, count = \n1\n; \n\n\nfor\n(\nint\ni = \n1\n; i <= n; i++){ \n\n\nif\n(count<\n4\n){ \n\nif\n(check!=arr[n-i]) \n\n{ \n\n\n\nSystem.out.print(arr[n-i]+\n\" \"\n); \n\ncheck = arr[n-i]; \n\ncount++; \n\n} \n\n} \n\nelse\n\nbreak\n; \n\n} \n\n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nGFG obj = \nnew\nGFG(); \n\nint\n[] arr={\n12\n,\n45\n,\n1\n,-\n1\n,\n45\n,\n54\n,\n23\n,\n5\n,\n0\n,-\n10\n}; \n\nobj.find3largest(arr); \n\n} \n\n}", "index": 570, "complexity": "5"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "class\nHuffmanNode { \n\n\nint\ndata; \n\nchar\nc; \n\n\nHuffmanNode left; \n\nHuffmanNode right; \n} \n\n\n\n\n\nclass\nMyComparator \nimplements\nComparator<HuffmanNode> { \n\npublic\nint\ncompare(HuffmanNode x, HuffmanNode y) \n\n{ \n\n\nreturn\nx.data - y.data; \n\n} \n} \n\npublic\nclass\nHuffman { \n\n\n\n\n\n\n\n\npublic\nstatic\nvoid\nprintCode(HuffmanNode root, String s) \n\n{ \n\n\n\n\n\n\n\n\nif\n(root.left \n\n== \nnull\n\n&& root.right \n\n== \nnull\n\n&& Character.isLetter(root.c)) { \n\n\n\n\nSystem.out.println(root.c + \n\":\"\n+ s); \n\n\nreturn\n; \n\n} \n\n\n\n\n\n\n\n\n\n\n\nprintCode(root.left, s + \n\"0\"\n); \n\nprintCode(root.right, s + \n\"1\"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nScanner s = \nnew\nScanner(System.in); \n\n\n\n\nint\nn = \n6\n; \n\nchar\n[] charArray = { \n'a'\n, \n'b'\n, \n'c'\n, \n'd'\n, \n'e'\n, \n'f'\n}; \n\nint\n[] charfreq = { \n5\n, \n9\n, \n12\n, \n13\n, \n16\n, \n45\n}; \n\n\n\n\n\n\nPriorityQueue<HuffmanNode> q \n\n= \nnew\nPriorityQueue<HuffmanNode>(n, \nnew\nMyComparator()); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nHuffmanNode hn = \nnew\nHuffmanNode(); \n\n\nhn.c = charArray[i]; \n\nhn.data = charfreq[i]; \n\n\nhn.left = \nnull\n; \n\nhn.right = \nnull\n; \n\n\n\n\n\n\nq.add(hn); \n\n} \n\n\n\n\nHuffmanNode root = \nnull\n; \n\n\n\n\n\n\n\n\n\n\nwhile\n(q.size() > \n1\n) { \n\n\n\n\nHuffmanNode x = q.peek(); \n\nq.poll(); \n\n\n\n\nHuffmanNode y = q.peek(); \n\nq.poll(); \n\n\n\n\nHuffmanNode f = \nnew\nHuffmanNode(); \n\n\n\n\n\n\nf.data = x.data + y.data; \n\nf.c = \n'-'\n; \n\n\n\n\nf.left = x; \n\n\n\n\nf.right = y; \n\n\n\n\nroot = f; \n\n\n\n\nq.add(f); \n\n} \n\n\n\n\nprintCode(root, \n\"\"\n); \n\n} \n}", "index": 571, "complexity": "5"}
{"forwhile": "class Graph { static class Edge implements Comparable<Edge> { int src, dest, weight; public int compareTo(Edge compareEdge) { return this.weight-compareEdge.weight; } }; static class subset { int parent, rank; }; int V, E; Edge edge[]; Graph(int v, int e) { V = v; E = e; edge = new Edge[E]; int i=0; while(i<e) { edge[i] = new Edge(); i++; } } int find(subset subsets[], int i) { if(subsets[i].parent != i) subsets[i].parent = find(subsets, subsets[i].parent); return subsets[i].parent; } void Union(subset subsets[], int x, int y) { int xroot = find(subsets, x); int yroot = find(subsets, y); if(subsets[xroot].rank < subsets[yroot].rank) subsets[xroot].parent = yroot; else if(subsets[xroot].rank > subsets[yroot].rank) subsets[yroot].parent = xroot; else { subsets[yroot].parent = xroot; subsets[xroot].rank++; } } void KruskalMST() { Edge result[] = new Edge[V]; int e = 0; int i = 0; while(i<V) { result[i] = new Edge(); i++; } Arrays.sort(edge); subset subsets[] = new subset[V]; i = 0; while(i<V) { subsets[i]=new subset(); i++; } i = 0; for(; e < V - 1; ) { Edge next_edge = new Edge(); next_edge = edge[i++]; int x = find(subsets, next_edge.src); int y = find(subsets, next_edge.dest); if(x != y) { result[e++] = next_edge; Union(subsets, x, y); } } System.out.println(\"Following are the edges in \" + \"the constructed MST\"); for(i = 0; i < e; ) { System.out.println(result[i].src+\" -- \"+ result[i].dest+\" == \"+ result[i].weight); i++; } } public static void main (String[] args) { int V = 4; int E = 5; Graph graph = new Graph(V, E); graph.edge[0].src = 0; graph.edge[0].dest = 1; graph.edge[0].weight = 10; graph.edge[1].src = 0; graph.edge[1].dest = 2; graph.edge[1].weight = 6; graph.edge[2].src = 0; graph.edge[2].dest = 3; graph.edge[2].weight = 5; graph.edge[3].src = 1; graph.edge[3].dest = 3; graph.edge[3].weight = 15; graph.edge[4].src = 2; graph.edge[4].dest = 3; graph.edge[4].weight = 4; graph.KruskalMST(); } }", "src": "class\nGraph \n{ \n\n\n\nclass\nEdge \nimplements\nComparable<Edge> \n\n{ \n\nint\nsrc, dest, weight; \n\n\n\n\n\n\npublic\nint\ncompareTo(Edge compareEdge) \n\n{ \n\nreturn\nthis\n.weight-compareEdge.weight; \n\n} \n\n}; \n\n\n\n\nclass\nsubset \n\n{ \n\nint\nparent, rank; \n\n}; \n\n\nint\nV, E; \n\n\nEdge edge[]; \n\n\n\n\n\nGraph(\nint\nv, \nint\ne) \n\n{ \n\nV = v; \n\nE = e; \n\nedge = \nnew\nEdge[E]; \n\nfor\n(\nint\ni=\n0\n; i<e; ++i) \n\nedge[i] = \nnew\nEdge(); \n\n} \n\n\n\n\n\n\nint\nfind(subset subsets[], \nint\ni) \n\n{ \n\n\n\nif\n(subsets[i].parent != i) \n\nsubsets[i].parent = find(subsets, subsets[i].parent); \n\n\nreturn\nsubsets[i].parent; \n\n} \n\n\n\n\n\n\nvoid\nUnion(subset subsets[], \nint\nx, \nint\ny) \n\n{ \n\nint\nxroot = find(subsets, x); \n\nint\nyroot = find(subsets, y); \n\n\n\n\n\n\nif\n(subsets[xroot].rank < subsets[yroot].rank) \n\nsubsets[xroot].parent = yroot; \n\nelse\nif\n(subsets[xroot].rank > subsets[yroot].rank) \n\nsubsets[yroot].parent = xroot; \n\n\n\n\n\n\nelse\n\n{ \n\nsubsets[yroot].parent = xroot; \n\nsubsets[xroot].rank++; \n\n} \n\n} \n\n\n\n\nvoid\nKruskalMST() \n\n{ \n\nEdge result[] = \nnew\nEdge[V]; \n\n\nint\ne = \n0\n; \n\n\nint\ni = \n0\n; \n\n\nfor\n(i=\n0\n; i<V; ++i) \n\nresult[i] = \nnew\nEdge(); \n\n\n\n\n\n\n\n\nArrays.sort(edge); \n\n\n\n\nsubset subsets[] = \nnew\nsubset[V]; \n\nfor\n(i=\n0\n; i<V; ++i) \n\nsubsets[i]=\nnew\nsubset(); \n\n\n\n\nfor\n(\nint\nv = \n0\n; v < V; ++v) \n\n{ \n\nsubsets[v].parent = v; \n\nsubsets[v].rank = \n0\n; \n\n} \n\n\ni = \n0\n; \n\n\n\n\n\nwhile\n(e < V - \n1\n) \n\n{ \n\n\n\n\n\nEdge next_edge = \nnew\nEdge(); \n\nnext_edge = edge[i++]; \n\n\nint\nx = find(subsets, next_edge.src); \n\nint\ny = find(subsets, next_edge.dest); \n\n\n\n\n\n\n\n\nif\n(x != y) \n\n{ \n\nresult[e++] = next_edge; \n\nUnion(subsets, x, y); \n\n} \n\n\n\n} \n\n\n\n\n\n\nSystem.out.println(\n\"Following are the edges in \"\n+ \n\n\"the constructed MST\"\n); \n\nfor\n(i = \n0\n; i < e; ++i) \n\nSystem.out.println(result[i].src+\n\" -- \"\n+ \n\nresult[i].dest+\n\" == \"\n+ result[i].weight); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\n\n\n\nint\nV = \n4\n; \n\n\nint\nE = \n5\n; \n\n\nGraph graph = \nnew\nGraph(V, E); \n\n\n\n\ngraph.edge[\n0\n].src = \n0\n; \n\ngraph.edge[\n0\n].dest = \n1\n; \n\ngraph.edge[\n0\n].weight = \n10\n; \n\n\n\n\ngraph.edge[\n1\n].src = \n0\n; \n\ngraph.edge[\n1\n].dest = \n2\n; \n\ngraph.edge[\n1\n].weight = \n6\n; \n\n\n\n\ngraph.edge[\n2\n].src = \n0\n; \n\ngraph.edge[\n2\n].dest = \n3\n; \n\ngraph.edge[\n2\n].weight = \n5\n; \n\n\n\n\ngraph.edge[\n3\n].src = \n1\n; \n\ngraph.edge[\n3\n].dest = \n3\n; \n\ngraph.edge[\n3\n].weight = \n15\n; \n\n\n\n\ngraph.edge[\n4\n].src = \n2\n; \n\ngraph.edge[\n4\n].dest = \n3\n; \n\ngraph.edge[\n4\n].weight = \n4\n; \n\n\ngraph.KruskalMST(); \n\n} \n}", "index": 572, "complexity": "5"}
{"forwhile": "public class prims { class node1 { int dest; int weight; node1(int a, int b) { dest = a; weight = b; } } static class Graph { int V; LinkedList<node1>[] adj; Graph(int e) { V = e; adj = new LinkedList[V]; int o = 0; while (o < V) { adj[o] = new LinkedList<>(); o++; } } } class node { int vertex; int key; } class comparator implements Comparator<node> { @Override public int compare(node node0, node node1) { return node0.key - node1.key; } } void addEdge(Graph graph, int src, int dest, int weight) { node1 node0 = new node1(dest, weight); node1 node = new node1(src, weight); graph.adj[src].addLast(node0); graph.adj[dest].addLast(node); } void prims_mst(Graph graph) { Boolean[] mstset = new Boolean[graph.V]; node[] e = new node[graph.V]; int[] parent = new int[graph.V]; int o = 0; while (o < graph.V) { e[o] = new node(); o++; } o = 0; while (o < graph.V) { mstset[o] = false; e[o].key = Integer.MAX_VALUE; e[o].vertex = o; parent[o] = -1; o++; } mstset[0] = true; e[0].key = 0; TreeSet<node> queue = new TreeSet<node>(new comparator()); o = 0; while (o < graph.V) { queue.add(e[o]); o++; } while (!queue.isEmpty()) { node node0 = queue.pollFirst(); mstset[node0.vertex] = true; for (node1 iterator : graph.adj[node0.vertex]) { if (mstset[iterator.dest] == false) { if (e[iterator.dest].key > iterator.weight) { queue.remove(e[iterator.dest]); e[iterator.dest].key = iterator.weight; queue.add(e[iterator.dest]); parent[iterator.dest] = node0.vertex; } } } } o = 1; while (o < graph.V) { System.out.println(parent[o] + \"-\" + \" \" + o); o++; } } public static void main(String[] args) { int V = 9; Graph graph = new Graph(V); prims e = new prims(); e.addEdge(graph, 0, 1, 4); e.addEdge(graph, 0, 7, 8); e.addEdge(graph, 1, 2, 8); e.addEdge(graph, 1, 7, 11); e.addEdge(graph, 2, 3, 7); e.addEdge(graph, 2, 8, 2); e.addEdge(graph, 2, 5, 4); e.addEdge(graph, 3, 4, 9); e.addEdge(graph, 3, 5, 14); e.addEdge(graph, 4, 5, 10); e.addEdge(graph, 5, 6, 2); e.addEdge(graph, 6, 7, 1); e.addEdge(graph, 6, 8, 6); e.addEdge(graph, 7, 8, 7); e.prims_mst(graph); } }", "src": "public\nclass\nprims { \n\nclass\nnode1 { \n\n\n\n\nint\ndest; \n\n\n\n\nint\nweight; \n\n\n\n\nnode1(\nint\na, \nint\nb) \n\n{ \n\ndest = a; \n\nweight = b; \n\n} \n\n} \n\nstatic\nclass\nGraph { \n\n\n\n\nint\nV; \n\n\n\n\nLinkedList<node1>[] adj; \n\n\n\n\nGraph(\nint\ne) \n\n{ \n\nV = e; \n\nadj = \nnew\nLinkedList[V]; \n\nfor\n(\nint\no = \n0\n; o < V; o++) \n\nadj[o] = \nnew\nLinkedList<>(); \n\n} \n\n} \n\n\n\n\n\n\n\n\nclass\nnode { \n\nint\nvertex; \n\nint\nkey; \n\n} \n\n\n\n\n\n\n\n\n\n\nclass\ncomparator \nimplements\nComparator<node> { \n\n\n@Override\n\npublic\nint\ncompare(node node0, node node1) \n\n{ \n\nreturn\nnode0.key - node1.key; \n\n} \n\n} \n\n\n\n\n\n\nvoid\naddEdge(Graph graph, \nint\nsrc, \nint\ndest, \nint\nweight) \n\n{ \n\n\nnode1 node0 = \nnew\nnode1(dest, weight); \n\nnode1 node = \nnew\nnode1(src, weight); \n\ngraph.adj[src].addLast(node0); \n\ngraph.adj[dest].addLast(node); \n\n} \n\n\n\n\nvoid\nprims_mst(Graph graph) \n\n{ \n\n\n\n\nBoolean[] mstset = \nnew\nBoolean[graph.V]; \n\nnode[] e = \nnew\nnode[graph.V]; \n\n\n\n\nint\n[] parent = \nnew\nint\n[graph.V]; \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) \n\ne[o] = \nnew\nnode(); \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) { \n\n\n\n\nmstset[o] = \nfalse\n; \n\n\n\n\ne[o].key = Integer.MAX_VALUE; \n\ne[o].vertex = o; \n\nparent[o] = -\n1\n; \n\n} \n\n\n\n\nmstset[\n0\n] = \ntrue\n; \n\n\n\n\n\n\n\n\ne[\n0\n].key = \n0\n; \n\n\n\n\nTreeSet<node> queue = \nnew\nTreeSet<node>(\nnew\ncomparator()); \n\n\nfor\n(\nint\no = \n0\n; o < graph.V; o++) \n\nqueue.add(e[o]); \n\n\n\n\nwhile\n(!queue.isEmpty()) { \n\n\n\n\nnode node0 = queue.pollFirst(); \n\n\n\n\nmstset[node0.vertex] = \ntrue\n; \n\n\n\n\nfor\n(node1 iterator : graph.adj[node0.vertex]) { \n\n\n\n\nif\n(mstset[iterator.dest] == \nfalse\n) { \n\n\n\n\n\n\n\n\n\nif\n(e[iterator.dest].key > iterator.weight) { \n\nqueue.remove(e[iterator.dest]); \n\ne[iterator.dest].key = iterator.weight; \n\nqueue.add(e[iterator.dest]); \n\nparent[iterator.dest] = node0.vertex; \n\n} \n\n} \n\n} \n\n} \n\n\n\n\nfor\n(\nint\no = \n1\n; o < graph.V; o++) \n\nSystem.out.println(parent[o] + \n\" \"\n\n+ \n\"-\"\n\n+ \n\" \"\n+ o); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\nV = \n9\n; \n\n\nGraph graph = \nnew\nGraph(V); \n\n\nprims e = \nnew\nprims(); \n\n\ne.addEdge(graph, \n0\n, \n1\n, \n4\n); \n\ne.addEdge(graph, \n0\n, \n7\n, \n8\n); \n\ne.addEdge(graph, \n1\n, \n2\n, \n8\n); \n\ne.addEdge(graph, \n1\n, \n7\n, \n11\n); \n\ne.addEdge(graph, \n2\n, \n3\n, \n7\n); \n\ne.addEdge(graph, \n2\n, \n8\n, \n2\n); \n\ne.addEdge(graph, \n2\n, \n5\n, \n4\n); \n\ne.addEdge(graph, \n3\n, \n4\n, \n9\n); \n\ne.addEdge(graph, \n3\n, \n5\n, \n14\n); \n\ne.addEdge(graph, \n4\n, \n5\n, \n10\n); \n\ne.addEdge(graph, \n5\n, \n6\n, \n2\n); \n\ne.addEdge(graph, \n6\n, \n7\n, \n1\n); \n\ne.addEdge(graph, \n6\n, \n8\n, \n6\n); \n\ne.addEdge(graph, \n7\n, \n8\n, \n7\n); \n\n\n\n\ne.prims_mst(graph); \n\n} \n}", "index": 573, "complexity": "5"}
{"forwhile": "public class GFG { static int MaxSumDifference(Integer[] a, int n) { List<Integer> finalSequence = new ArrayList<Integer>(); Arrays.sort(a); int i = 0; while(i < n / 2) { finalSequence.add(a[i]); finalSequence.add(a[n - i - 1]); i++; } int MaximumSum = 0; i = 0; while(i < n - 1) { MaximumSum = MaximumSum + Math.abs(finalSequence.get(i) - finalSequence.get(i + 1)); i++; } MaximumSum = MaximumSum + Math.abs(finalSequence.get(n - 1) - finalSequence.get(0)); return MaximumSum; } public static void main(String args[]) { Integer[] a = { 1, 2, 4, 8 }; int n = a.length; System.out.print(MaxSumDifference(a, n)); } }", "src": "public\nclass\nGFG { \n\n\nstatic\nint\nMaxSumDifference(Integer []a, \nint\nn) \n\n{ \n\n\n\n\nList<Integer> finalSequence = \n\nnew\nArrayList<Integer>(); \n\n\n\n\n\n\n\n\n\n\nArrays.sort(a); \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n / \n2\n; ++i) { \n\nfinalSequence.add(a[i]); \n\nfinalSequence.add(a[n - i - \n1\n]); \n\n} \n\n\n\n\n\n\n\n\nint\nMaximumSum = \n0\n; \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n - \n1\n; ++i) { \n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(i) \n\n- finalSequence.get(i + \n1\n)); \n\n} \n\n\n\n\n\n\nMaximumSum = MaximumSum + \n\nMath.abs(finalSequence.get(n - \n1\n) \n\n- finalSequence.get(\n0\n)); \n\n\n\n\nreturn\nMaximumSum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nInteger []a = { \n1\n, \n2\n, \n4\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxSumDifference(a, n)); \n\n} \n}", "index": 574, "complexity": "5"}
{"forwhile": "class MaxSum { static int maxSum(int arr[], int n) { int sum = 0; Arrays.sort(arr); int i = 0; while(i < n/2) { sum -= (2 * arr[i]); sum += (2 * arr[n - i - 1]); i++; } return sum; } public static void main (String[] args) { int arr[] = { 4, 2, 1, 8 }; int n = arr.length; System.out.println(maxSum(arr, n)); } }", "src": "class\nMaxSum \n{ \n\n\n\n\n\nstatic\nint\nmaxSum(\nint\narr[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n/\n2\n; i++) \n\n{ \n\nsum -= (\n2\n* arr[i]); \n\nsum += (\n2\n* arr[n - i - \n1\n]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = { \n4\n, \n2\n, \n1\n, \n8\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(maxSum(arr, n)); \n\n} \n}", "index": 575, "complexity": "5"}
{"forwhile": "class GFG { static int maxLevel(int []boxes, int n) { Arrays.sort(boxes); int ans = 1; int prev_width = boxes[0]; int prev_count = 1; int curr_count = 0; int curr_width = 0; int i = 1; while(i < n) { curr_width += boxes[i]; curr_count += 1; if(curr_width > prev_width && curr_count > prev_count) { prev_width = curr_width; prev_count = curr_count; curr_count = 0; curr_width = 0; ans++; } i++; } return ans; } static public void main (String[] args) { int []boxes = {10, 20, 30, 50, 60, 70}; int n = boxes.length; System.out.println(maxLevel(boxes, n)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nmaxLevel(\nint\n[]boxes, \nint\nn) \n\n{ \n\n\n\n\n\n\nArrays.sort(boxes); \n\n\nint\nans = \n1\n; \n\n\n\n\n\n\n\n\n\nint\nprev_width = boxes[\n0\n]; \n\nint\nprev_count = \n1\n; \n\n\n\n\n\n\nint\ncurr_count = \n0\n; \n\n\n\n\nint\ncurr_width = \n0\n; \n\nfor\n(\nint\ni = \n1\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\ncurr_width += boxes[i]; \n\ncurr_count += \n1\n; \n\n\n\n\n\n\n\n\nif\n(curr_width > prev_width && \n\ncurr_count > prev_count) \n\n{ \n\n\n\n\n\n\n\n\nprev_width = curr_width; \n\nprev_count = curr_count; \n\n\n\n\n\n\n\n\ncurr_count = \n0\n; \n\ncurr_width = \n0\n; \n\n\n\n\n\n\nans++; \n\n} \n\n} \n\n\nreturn\nans; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]boxes = {\n10\n, \n20\n, \n30\n, \n50\n, \n60\n, \n70\n}; \n\nint\nn = boxes.length; \n\nSystem.out.println(maxLevel(boxes, n)); \n\n} \n}", "index": 576, "complexity": "5"}
{"forwhile": "class GFG  { static int maxDifference( int arr[], int N, int k) { int M, S = 0 , S1 = 0 , max_difference = 0; int i = 0; while(i < N)  S += arr[i++]; int temp; i = 0; while(i < N)  { int j = i + 1; while(j < N)  { if(arr[i] < arr[j])  { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }  j++; }  i++; }  M = Math.max(k, N - k); for(int i = 0; i < M; i++)  S1 += arr[i]; max_difference = S1 - (S - S1); return max_difference; } public static void main(String args[]) { int arr[] = { 8 , 4 , 5 , 2 , 10 }; int N = arr.length; int k = 2; System.out.println(maxDifference(arr, N, k)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nmaxDifference(\nint\narr[], \nint\nN, \nint\nk) \n{ \n\nint\nM, S = \n0\n, S1 = \n0\n, max_difference = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\nS += arr[i]; \n\nint\ntemp; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < N; i++) \n\n{ \n\nfor\n(\nint\nj = i + \n1\n; j < N; j++) \n\n{ \n\nif\n(arr[i] < arr[j]) \n\n{ \n\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n} \n\n\nM = Math.max(k, N - k); \n\nfor\n(\nint\ni = \n0\n; i < M; i++) \n\nS1 += arr[i]; \n\n\n\n\nmax_difference = S1 - (S - S1); \n\nreturn\nmax_difference; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n8\n, \n4\n, \n5\n, \n2\n, \n10\n}; \n\nint\nN = arr.length; \n\nint\nk = \n2\n; \n\nSystem.out.println(maxDifference(arr, N, k)); \n} \n}", "index": 577, "complexity": "5"}
{"forwhile": "class GFG { static void findElements(int arr[], int n) { Arrays.sort(arr); int i = 0; while (i < n - 2) System.out.print(arr[i] + \" \"); i++; } public static void main(String args[]) { int arr[] = { 2, -6, 3, 5, 1 }; int n = arr.length; findElements(arr, n); } }", "src": "class\nGFG \n{ \n\nstatic\nvoid\nfindElements(\nint\narr[], \nint\nn) \n{ \n\nArrays.sort(arr); \n\n\nfor\n(\nint\ni = \n0\n; i < n - \n2\n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n2\n, -\n6\n,\n3\n, \n5\n, \n1\n}; \n\nint\nn = arr.length; \n\nfindElements(arr, n); \n\n} \n}", "index": 578, "complexity": "5"}
{"forwhile": "class\nMinSum \n{ \n\n\n\n\n\nstatic\nlong\nfindMinSum(\nlong\na[], \nlong\nb[], \nlong\nn) \n\n{ \n\n\n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n\nlong\nsum = \n0\n; \n\nint\ni = \n0\n; \nwhile(i < n) \n\n{\nsum = sum + Math.abs(a[i] - b[i]); \n\ni++; \n}\n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nlong\na[] = {\n4\n, \n1\n, \n8\n, \n7\n}; \n\nlong\nb[] = {\n2\n, \n3\n, \n6\n, \n5\n}; \n\nint\nn = a.length; \n\nSystem.out.println(findMinSum(a, b, n)); \n\n} \n}", "src": "class\nMinSum \n{ \n\n\n\n\n\nstatic\nlong\nfindMinSum(\nlong\na[], \nlong\nb[], \nlong\nn) \n\n{ \n\n\n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n\nlong\nsum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nsum = sum + Math.abs(a[i] - b[i]); \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\n\nlong\na[] = {\n4\n, \n1\n, \n8\n, \n7\n}; \n\nlong\nb[] = {\n2\n, \n3\n, \n6\n, \n5\n}; \n\nint\nn = a.length; \n\nSystem.out.println(findMinSum(a, b, n)); \n\n} \n}", "index": 579, "complexity": "5"}
{"forwhile": "class MinSum { public static long solve(int[] a) { PriorityQueue<Integer> pq = new PriorityQueue<Integer>(); StringBuilder num1 = new StringBuilder(); StringBuilder num2 = new StringBuilder(); int i = 0; while (i < a.length) { pq.add(a[i]); i++; } for (; !pq.isEmpty(); ) { num1.append(pq.poll() + \"\"); if (!pq.isEmpty()) num2.append(pq.poll() + \"\"); } long sum = Long.parseLong(num1.toString()) + Long.parseLong(num2.toString()); return sum; } public static void main (String[] args) { int arr[] = { 6, 8, 4, 5, 2, 3 }; System.out.println(\"The required sum is \" + solve(arr)); } }", "src": "class\nMinSum \n{ \n\n\n\n\n\npublic\nstatic\nlong\nsolve(\nint\n[] a) \n\n{ \n\n\n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<Integer>(); \n\n\n\n\n\n\nStringBuilder num1 = \nnew\nStringBuilder(); \n\nStringBuilder num2 = \nnew\nStringBuilder(); \n\n\n\n\nfor\n(\nint\nx : a) \n\npq.add(x); \n\n\n\n\nwhile\n(!pq.isEmpty()) \n\n{ \n\nnum1.append(pq.poll()+ \n\"\"\n); \n\nif\n(!pq.isEmpty()) \n\nnum2.append(pq.poll()+ \n\"\"\n); \n\n} \n\n\n\n\nlong\nsum = Long.parseLong(num1.toString()) + \n\nLong.parseLong(num2.toString()); \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n6\n, \n8\n, \n4\n, \n5\n, \n2\n, \n3\n}; \n\nSystem.out.println(\n\"The required sum is \"\n+ solve(arr)); \n\n} \n}", "index": 580, "complexity": "5"}
{"forwhile": "class GFG  { public static int DecreasingArray( int a[],  int n)  {  int sum = 0 , dif = 0 ;  PriorityQueue<Integer> pq = new PriorityQueue<>();  int i = 0;  while(i < n)  {  if(!pq.isEmpty() && pq.element() < a[i])  { dif = a[i] - pq.element(); sum += dif; pq.remove(); pq.add(a[i]); } pq.add(a[i]); i++; } return sum; } public static void main(String[] args)  { int [] a = {3 , 1 , 2 , 1};  int n = a.length;  System.out.println(DecreasingArray(a, n)); }}", "src": "class\nGFG \n{ \n\npublic\nstatic\nint\nDecreasingArray(\nint\na[], \nint\nn) \n\n{ \n\nint\nsum = \n0\n, dif = \n0\n; \n\n\nPriorityQueue<Integer> pq = \nnew\nPriorityQueue<>(); \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nif\n(!pq.isEmpty() && pq.element() < a[i]) \n\n{ \n\ndif = a[i] - pq.element(); \n\nsum += dif; \n\npq.remove(); \n\npq.add(a[i]); \n\n} \n\npq.add(a[i]); \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\n\nint\n[] a = {\n3\n, \n1\n, \n2\n, \n1\n}; \n\n\nint\nn = a.length; \n\n\nSystem.out.println(DecreasingArray(a, n)); \n\n} \n}", "index": 581, "complexity": "5"}
{"forwhile": "class GFG  { static int MinOperation(int a[], int b[], int n) { Arrays.sort(a); Arrays.sort(b); int result = 0; int i = 0; while(i < n) { if(a[i] > b[i]) result = result + Math.abs(a[i] - b[i]); else if(a[i] < b[i]) result = result + Math.abs(a[i] - b[i]); i++; } return result; } public static void main (String[] args) { int a[] = {3, 1, 1}; int b[] = {1, 2, 2}; int n = a.length; System.out.println(MinOperation(a, b, n)); } }", "src": "class\nGFG \n{ \nstatic\nint\nMinOperation(\nint\na[], \n\nint\nb[], \n\nint\nn) \n{ \n\n\n\n\n\nArrays.sort(a); \n\nArrays.sort(b); \n\n\n\n\n\n\n\nint\nresult = \n0\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; ++i) \n\n{ \n\nif\n(a[i] > b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n\nelse\nif\n(a[i] < b[i]) \n\nresult = result + \n\nMath.abs(a[i] - b[i]); \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain (String[] args) \n{ \n\nint\na[] = {\n3\n, \n1\n, \n1\n}; \n\nint\nb[] = {\n1\n, \n2\n, \n2\n}; \n\nint\nn = a.length; \n\nSystem.out.println(MinOperation(a, b, n)); \n} \n}", "index": 582, "complexity": "5"}
{"forwhile": "class GFG { static boolean ifPossible(int arr[], int n) { int copy[] = Arrays.copyOf(arr, arr.length); Arrays.sort(copy); int i = 0; while(i < n) { if (!(arr[i] == copy[i]) && !(arr[n - 1 - i] == copy[i])) return false; i++; } return true; } public static void main(String[] args) { int arr[] = { 1, 7, 6, 4, 5, 3, 2, 8 }; int n = arr.length; if (ifPossible(arr, n)) System.out.println(\"Yes\"); else System.out.println(\"No\"); } }", "src": "class\nGFG { \n\n\nstatic\nboolean\nifPossible(\nint\narr[], \nint\nn) \n\n{ \n\n\n\n\nint\ncopy[] = Arrays.copyOf(arr, arr.length); \n\n\n\n\nArrays.sort(copy); \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\n\n\nif\n(!(arr[i] == copy[i]) && !(arr[n - \n1\n- i] == copy[i])) \n\nreturn\nfalse\n; \n\n} \n\n\nreturn\ntrue\n; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n1\n, \n7\n, \n6\n, \n4\n, \n5\n, \n3\n, \n2\n, \n8\n}; \n\nint\nn = arr.length; \n\nif\n(ifPossible(arr, n)) \n\nSystem.out.println(\n\"Yes\"\n); \n\nelse\n\nSystem.out.println(\n\"No\"\n); \n\n} \n}", "index": 583, "complexity": "5"}
{"forwhile": "class GFG  { static int MaxTotalRectangleArea( int []a, int n)  { Arrays.sort(a); int sum = 0; boolean flag = false; int len = 0; int i = 0; while(i < n)  { if((a[i] == a[i + 1] || a[i] - a[i + 1] == 1) && !flag)  { flag = true; len = a[i + 1]; i++; } else if((a[i] == a[i + 1] || a[i] - a[i + 1] == 1) && (flag))  { sum = sum + a[i + 1] * len; flag = false; i++; } i++; } return sum; } public static void main (String args[])  { int []a = { 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 }; int n = a.length; System.out.print(MaxTotalRectangleArea(a, n)); } }", "src": "class\nGFG \n{ \n\n\n\n\n\nstatic\nint\nMaxTotalRectangleArea(\nint\n[]a, \n\nint\nn) \n\n{ \n\n\n\n\n\n\nArrays.sort(a); \n\n\n\n\n\n\n\n\nint\nsum = \n0\n; \n\nboolean\nflag = \nfalse\n; \n\n\n\n\n\n\nint\nlen = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\n\n\n\n\n\n\n\n\n\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n!flag) \n\n{ \n\n\n\n\n\n\n\nflag = \ntrue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlen = a[i + \n1\n]; \n\n\n\n\n\n\n\n\n\n\ni++; \n\n} \n\n\n\n\n\n\n\n\n\n\n\n\nelse\nif\n((a[i] == a[i + \n1\n] || \n\na[i] - a[i + \n1\n] == \n1\n) && \n\n(flag)) \n\n{ \n\n\n\n\n\nsum = sum + a[i + \n1\n] * len; \n\n\n\n\n\n\n\n\n\n\nflag = \nfalse\n; \n\n\n\n\n\n\n\n\n\n\ni++; \n\n} \n\n} \n\n\nreturn\nsum; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String args[]) \n\n{ \n\nint\n[]a = { \n10\n, \n10\n, \n10\n, \n10\n, \n\n11\n, \n10\n, \n11\n, \n10\n, \n\n9\n, \n9\n, \n8\n, \n8\n}; \n\nint\nn = a.length; \n\n\nSystem.out.print(MaxTotalRectangleArea(a, n)); \n\n} \n}", "index": 584, "complexity": "5"}
{"forwhile": "public class FractionalKnapSack  {  public static void main(String[] args)  {  int [] wt = { 10 , 40 , 20 , 30};  int [] val = { 60 , 40 , 100 , 120};  int capacity = 50;  double maxValue = getMaxValue(wt, val, capacity);  System.out.println( \"Maximum value we can obtain = \"+  maxValue);  }  private static double getMaxValue( int [] wt,  int [] val,  int capacity)  {  ItemValue[] iVal = new ItemValue[wt.length];  int i = 0;  while(i < wt.length)  {  iVal[i] = new ItemValue(wt[i], val[i], i);  i++;  }  Arrays.sort(iVal, new Comparator<ItemValue>()  {  public int compare(ItemValue o1, ItemValue o2)  {  return o2.cost.compareTo(o1.cost) ;  }  });  double totalValue = 0d;  for( i = 0; i < iVal.length; i++)  {  ItemValue item = iVal[i];  int curWt = (int) item.wt;  int curVal = (int) item.val;  if(capacity - curWt >= 0)  {  capacity = capacity-curWt;  totalValue += curVal;  }  else  {  double fraction = ((double)capacity/(double)curWt);  totalValue += (curVal*fraction);  capacity = (int)(capacity - (curWt*fraction));  break;  }  }  return totalValue;  }  static class ItemValue  {  Double cost; double wt, val, ind;  public ItemValue(int wt, int val, int ind)  {  this .wt = wt;  this .val = val;  this .ind = ind; cost = new Double(val/wt );  }  } }", "src": "public\nclass\nFractionalKnapSack \n{ \n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\n[] wt = {\n10\n, \n40\n, \n20\n, \n30\n}; \n\nint\n[] val = {\n60\n, \n40\n, \n100\n, \n120\n}; \n\nint\ncapacity = \n50\n; \n\n\ndouble\nmaxValue = getMaxValue(wt, val, capacity); \n\nSystem.out.println(\n\"Maximum value we can obtain = \"\n+ \n\nmaxValue); \n\n\n} \n\n\n\n\nprivate\nstatic\ndouble\ngetMaxValue(\nint\n[] wt, \n\nint\n[] val, \nint\ncapacity) \n\n{ \n\nItemValue[] iVal = \nnew\nItemValue[wt.length]; \n\n\nfor\n(\nint\ni = \n0\n; i < wt.length; i++) \n\n{ \n\niVal[i] = \nnew\nItemValue(wt[i], val[i], i); \n\n} \n\n\n\n\nArrays.sort(iVal, \nnew\nComparator<ItemValue>() \n\n{ \n\n@Override\n\npublic\nint\ncompare(ItemValue o1, ItemValue o2) \n\n{ \n\nreturn\no2.cost.compareTo(o1.cost) ; \n\n} \n\n}); \n\n\n\ndouble\ntotalValue = 0d; \n\n\nfor\n(ItemValue i: iVal) \n\n{ \n\n\nint\ncurWt = (\nint\n) i.wt; \n\nint\ncurVal = (\nint\n) i.val; \n\n\nif\n(capacity - curWt >= \n0\n) \n\n{ \n\n\n\ncapacity = capacity-curWt; \n\ntotalValue += curVal; \n\n\n} \n\nelse\n\n{ \n\n\n\ndouble\nfraction = ((\ndouble\n)capacity/(\ndouble\n)curWt); \n\ntotalValue += (curVal*fraction); \n\ncapacity = (\nint\n)(capacity - (curWt*fraction)); \n\nbreak\n; \n\n} \n\n\n\n} \n\n\nreturn\ntotalValue; \n\n} \n\n\n\n\nstatic\nclass\nItemValue \n\n{ \n\nDouble cost; \n\ndouble\nwt, val, ind; \n\n\n\n\npublic\nItemValue(\nint\nwt, \nint\nval, \nint\nind) \n\n{ \n\nthis\n.wt = wt; \n\nthis\n.val = val; \n\nthis\n.ind = ind; \n\ncost = \nnew\nDouble(val/wt ); \n\n} \n\n} \n}", "index": 585, "complexity": "5"}
{"forwhile": "class GFG { static int findMinimum(int arr[], int n, int k) { int res = 0; int i = 0; while(i < n) { res += arr[i]; n = n - k; i++; } return res; } static int findMaximum(int arr[], int n, int k) { int res = 0, index = 0; int i = n - 1; for(; i >= index; i--) { res += arr[i]; index += k; } return res; } public static void main(String[] args) { int arr[] = { 3, 2, 1, 4 }; int n = arr.length; int k = 2; Arrays.sort(arr); System.out.println(findMinimum(arr, n, k) + \" \" + findMaximum(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\nstatic\nint\nfindMinimum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\n\n\nres += arr[i]; \n\n\n\n\n\n\nn = n - k; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\n\n\nstatic\nint\nfindMaximum(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nint\nres = \n0\n, index = \n0\n; \n\n\nfor\n(\nint\ni = n - \n1\n; i >= index; i--) \n\n{ \n\n\n\nres += arr[i]; \n\n\n\n\n\n\nindex += k; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n3\n, \n2\n, \n1\n, \n4\n}; \n\nint\nn = arr.length; \n\nint\nk = \n2\n; \n\nArrays.sort(arr); \n\n\nSystem.out.println(findMinimum(arr, n, k) + \n\n\" \"\n+ findMaximum(arr, n, k)); \n\n} \n}", "index": 586, "complexity": "5"}
{"forwhile": "class GFG { static long calculate( long a[], int n) { Arrays.sort(a); int i,j; Vector<Long> s = new Vector<>(); i = 0; j = n - 1; while(i < j) s.add((a[i] + a[j])); long mini = Collections.min(s); long maxi = Collections.max(s); return Math.abs(maxi - mini); } public static void main(String[] args) { long a[] = { 2 , 6 , 4 , 3 }; int n = a.length; System.out.println(calculate(a, n)); } }", "src": "class\nGFG { \n\nstatic\nlong\ncalculate(\nlong\na[], \nint\nn) \n{ \n\n\n\nArrays.sort(a); \n\nint\ni,j; \n\n\n\n\nVector<Long> s = \nnew\nVector<>(); \n\nfor\n(i = \n0\n, j = n - \n1\n; i < j; i++, j--) \n\ns.add((a[i] + a[j])); \n\n\nlong\nmini = Collections.min(s); \n\nlong\nmaxi = Collections.max(s); \n\nreturn\nMath.abs(maxi - mini); \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nlong\na[] = { \n2\n, \n6\n, \n4\n, \n3\n}; \n\nint\nn = a.length; \n\nSystem.out.println(calculate(a, n)); \n\n} \n}", "index": 587, "complexity": "5"}
{"forwhile": "class\nMinHeap { \n\nint\n[] harr; \n\n\nint\nheap_size; \n\n\nint\ncapacity; \n\n\n\n\n\n\n\npublic\nMinHeap(\nint\na[], \nint\nsize) \n\n{ \n\nheap_size = size; \n\ncapacity = size; \n\nharr = a; \n\nint\ni = (heap_size - \n1\n) / \n2\n; \n\nwhile(i >= \n0\n) { \n\nMinHeapify(i); \n\ni--; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\n\nvoid\nMinHeapify(\nint\ni) \n\n{ \n\nint\nl = left(i); \n\nint\nr = right(i); \n\nint\nsmallest = i; \n\nif\n(l < heap_size && harr[l] < harr[i]) \n\nsmallest = l; \n\nif\n(r < heap_size && harr[r] < harr[smallest]) \n\nsmallest = r; \n\nif\n(smallest != i) { \n\nswap(i, smallest); \n\nMinHeapify(smallest); \n\n} \n\n} \n\n\nint\nparent(\nint\ni) { \nreturn\n(i - \n1\n) / \n2\n; } \n\n\n\n\nint\nleft(\nint\ni) { \nreturn\n(\n2\n* i + \n1\n); } \n\n\n\n\nint\nright(\nint\ni) { \nreturn\n(\n2\n* i + \n2\n); } \n\n\n\n\nint\nextractMin() \n\n{ \n\nif\n(heap_size <= \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\nif\n(heap_size == \n1\n) { \n\nheap_size--; \n\nreturn\nharr[\n0\n]; \n\n} \n\n\n\n\nint\nroot = harr[\n0\n]; \n\nharr[\n0\n] = harr[heap_size - \n1\n]; \n\nheap_size--; \n\nMinHeapify(\n0\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\nvoid\ninsertKey(\nint\nk) \n\n{ \n\nif\n(heap_size == capacity) { \n\nSystem.out.println(\n\"Overflow: Could not insertKey\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nheap_size++; \n\nint\ni = heap_size - \n1\n; \n\nharr[i] = k; \n\n\n\n\nwhile(i != \n0\n&& harr[parent(i)] > harr[i]) { \n\nswap(i, parent(i)); \n\ni = parent(i); \n\n} \n\n} \n\n\n\n\n\n\nboolean\nisSizeOne() \n\n{ \n\nreturn\n(heap_size == \n1\n); \n\n} \n\n\n\n\nvoid\nswap(\nint\nx, \nint\ny) \n\n{ \n\nint\ntemp = harr[x]; \n\nharr[x] = harr[y]; \n\nharr[y] = temp; \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nminCost(\nint\nlen[], \nint\nn) \n\n{ \n\nint\ncost = \n0\n; \n\n\n\n\n\n\n\nMinHeap minHeap = \nnew\nMinHeap(len, n); \n\n\n\n\nfor(; !minHeap.isSizeOne(); ) { \n\n\n\nint\nmin = minHeap.extractMin(); \n\nint\nsec_min = minHeap.extractMin(); \n\n\ncost += (min + sec_min); \n\n\n\n\n\n\n\nminHeap.insertKey(min + sec_min); \n\n} \n\n\n\n\n\n\nreturn\ncost; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nlen[] = { \n4\n, \n3\n, \n2\n, \n6\n}; \n\nint\nsize = len.length; \n\n\nSystem.out.println(\n\"Total cost for connecting ropes is \"\n+ minCost(len, size)); \n\n} \n};", "src": "class\nMinHeap { \n\nint\n[] harr; \n\n\nint\nheap_size; \n\n\nint\ncapacity; \n\n\n\n\n\n\n\npublic\nMinHeap(\nint\na[], \nint\nsize) \n\n{ \n\nheap_size = size; \n\ncapacity = size; \n\nharr = a; \n\nint\ni = (heap_size - \n1\n) / \n2\n; \n\nwhile\n(i >= \n0\n) { \n\nMinHeapify(i); \n\ni--; \n\n} \n\n} \n\n\n\n\n\n\n\n\n\n\nvoid\nMinHeapify(\nint\ni) \n\n{ \n\nint\nl = left(i); \n\nint\nr = right(i); \n\nint\nsmallest = i; \n\nif\n(l < heap_size && harr[l] < harr[i]) \n\nsmallest = l; \n\nif\n(r < heap_size && harr[r] < harr[smallest]) \n\nsmallest = r; \n\nif\n(smallest != i) { \n\nswap(i, smallest); \n\nMinHeapify(smallest); \n\n} \n\n} \n\n\nint\nparent(\nint\ni) { \nreturn\n(i - \n1\n) / \n2\n; } \n\n\n\n\nint\nleft(\nint\ni) { \nreturn\n(\n2\n* i + \n1\n); } \n\n\n\n\nint\nright(\nint\ni) { \nreturn\n(\n2\n* i + \n2\n); } \n\n\n\n\nint\nextractMin() \n\n{ \n\nif\n(heap_size <= \n0\n) \n\nreturn\nInteger.MAX_VALUE; \n\nif\n(heap_size == \n1\n) { \n\nheap_size--; \n\nreturn\nharr[\n0\n]; \n\n} \n\n\n\n\nint\nroot = harr[\n0\n]; \n\nharr[\n0\n] = harr[heap_size - \n1\n]; \n\nheap_size--; \n\nMinHeapify(\n0\n); \n\n\nreturn\nroot; \n\n} \n\n\n\n\nvoid\ninsertKey(\nint\nk) \n\n{ \n\nif\n(heap_size == capacity) { \n\nSystem.out.println(\n\"Overflow: Could not insertKey\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nheap_size++; \n\nint\ni = heap_size - \n1\n; \n\nharr[i] = k; \n\n\n\n\nwhile\n(i != \n0\n&& harr[parent(i)] > harr[i]) { \n\nswap(i, parent(i)); \n\ni = parent(i); \n\n} \n\n} \n\n\n\n\n\n\nboolean\nisSizeOne() \n\n{ \n\nreturn\n(heap_size == \n1\n); \n\n} \n\n\n\n\nvoid\nswap(\nint\nx, \nint\ny) \n\n{ \n\nint\ntemp = harr[x]; \n\nharr[x] = harr[y]; \n\nharr[y] = temp; \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nminCost(\nint\nlen[], \nint\nn) \n\n{ \n\nint\ncost = \n0\n; \n\n\n\n\n\n\n\nMinHeap minHeap = \nnew\nMinHeap(len, n); \n\n\n\n\nwhile\n(!minHeap.isSizeOne()) { \n\n\n\nint\nmin = minHeap.extractMin(); \n\nint\nsec_min = minHeap.extractMin(); \n\n\ncost += (min + sec_min); \n\n\n\n\n\n\n\nminHeap.insertKey(min + sec_min); \n\n} \n\n\n\n\n\n\nreturn\ncost; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\nlen[] = { \n4\n, \n3\n, \n2\n, \n6\n}; \n\nint\nsize = len.length; \n\n\nSystem.out.println(\n\"Total cost for connecting ropes is \"\n+ minCost(len, size)); \n\n} \n};", "index": 588, "complexity": "5"}
{"forwhile": "class GFG { static int minCost(int coin[], int n, int k) { Arrays.sort(coin); int coins_needed = (int)Math.ceil(1.0 * n / (k + 1)); int ans = 0; int i = 0; while(i <= coins_needed - 1) { ans += coin[i]; i++; } return ans; } public static void main(String arg[]) { int coin[] = { 8, 5, 3, 10, 2, 1, 15, 25 }; int n = coin.length; int k = 3; System.out.print(minCost(coin, n, k)); } }", "src": "class\nGFG \n{ \n\n\n\n\nstatic\nint\nminCost(\nint\ncoin[], \n\nint\nn, \nint\nk) \n\n{ \n\n\n\n\nArrays.sort(coin); \n\n\n\n\n\n\nint\ncoins_needed = (\nint\n)Math.ceil(\n1.0\n* \n\nn / (k + \n1\n)); \n\n\n\n\n\n\nint\nans = \n0\n; \n\n\nfor\n(\nint\ni = \n0\n; i <= coins_needed - \n1\n; \n\ni++) \n\nans += coin[i]; \n\n\nreturn\nans; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String arg[]) \n\n{ \n\nint\ncoin[] = { \n8\n, \n5\n, \n3\n, \n10\n, \n\n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\nint\nk = \n3\n; \n\n\nSystem.out.print(minCost(coin, n, k)); \n\n} \n}", "index": 589, "complexity": "5"}
{"forwhile": "public class GFG { static void preprocess(int[] coin, int n) { Arrays.sort(coin); int i = 1; while(i <= n - 1) coin[i] += coin[i - 1]; i++; } static int minCost(int[] coin, int n, int k) { int coins_needed = (int) Math.ceil(1.0 * n / (k + 1)); return coin[coins_needed - 1]; } static public void main (String[] args) { int[] coin = {8, 5, 3, 10, 2, 1, 15, 25}; int n = coin.length; preprocess(coin, n); int k = 3; System.out.println(minCost(coin, n, k)); k = 7; System.out.println(minCost(coin, n, k)); } }", "src": "public\nclass\nGFG { \n\n\n\n\nstatic\nvoid\npreprocess(\nint\n[]coin, \nint\nn) \n\n{ \n\n\n\n\nArrays.sort(coin); \n\n\n\n\nfor\n(\nint\ni = \n1\n; i <= n - \n1\n; i++) \n\ncoin[i] += coin[i - \n1\n]; \n\n} \n\n\n\n\n\n\n\n\nstatic\nint\nminCost(\nint\n[]coin, \nint\nn, \nint\nk) \n\n{ \n\n\n\n\nint\ncoins_needed =(\nint\n) Math.ceil(\n1.0\n\n* n / (k + \n1\n)); \n\n\n\n\nreturn\ncoin[coins_needed - \n1\n]; \n\n} \n\n\n\n\nstatic\npublic\nvoid\nmain (String[] args) \n\n{ \n\nint\n[]coin = {\n8\n, \n5\n, \n3\n, \n10\n, \n2\n, \n1\n, \n15\n, \n25\n}; \n\nint\nn = coin.length; \n\n\npreprocess(coin, n); \n\n\nint\nk = \n3\n; \n\nSystem.out.println(minCost(coin, n, k)); \n\n\nk = \n7\n; \n\nSystem.out.println( minCost(coin, n, k)); \n\n} \n}", "index": 590, "complexity": "5"}
{"forwhile": "class GFG { static int findPlatform(int arr[], int dep[], int n) { Arrays.sort(arr); Arrays.sort(dep); int plat_needed = 1, result = 1; int i = 1, j = 0; for(; i < n && j < n;) { if(arr[i] <= dep[j]) { plat_needed++; i++; if(plat_needed > result) result = plat_needed; } else { plat_needed--; j++; } } return result; } public static void main(String[] args) { int arr[] = {900, 940, 950, 1100, 1500, 1800}; int dep[] = {910, 1200, 1120, 1130, 1900, 2000}; int n = arr.length; System.out.println(\"Minimum Number of Platforms Required = \" + findPlatform(arr, dep, n)); } }", "src": "class\nGFG { \n\n\nstatic\nint\nfindPlatform(\nint\narr[], \nint\ndep[], \nint\nn) \n{ \n\n\n\nArrays.sort(arr); \n\nArrays.sort(dep); \n\n\n\n\n\n\nint\nplat_needed = \n1\n, result = \n1\n; \n\nint\ni = \n1\n, j = \n0\n; \n\n\n\n\n\n\nwhile\n(i < n && j < n) \n\n{ \n\n\n\n\n\nif\n(arr[i] <= dep[j]) \n\n{ \n\nplat_needed++; \n\ni++; \n\n\n\n\nif\n(plat_needed > result) \n\nresult = plat_needed; \n\n} \n\n\n\n\nelse\n\n{ \n\nplat_needed--; \n\nj++; \n\n} \n\n} \n\n\nreturn\nresult; \n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n{ \n\nint\narr[] = {\n900\n, \n940\n, \n950\n, \n1100\n, \n1500\n, \n1800\n}; \n\nint\ndep[] = {\n910\n, \n1200\n, \n1120\n, \n1130\n, \n1900\n, \n2000\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(\n\"Minimum Number of Platforms Required = \"\n\n+ findPlatform(arr, dep, n)); \n} \n}", "index": 591, "complexity": "5"}
{"forwhile": "class GFG { static int getMinDiff(int arr[], int n, int k) { if (n == 1) return 0; Arrays.sort(arr); int ans = arr[n-1] - arr[0]; int small = arr[0] + k; int big = arr[n-1] - k; int temp = 0; if (small > big) { temp = small; small = big; big = temp; } int i = 1; while ( i < n-1 ) { int subtract = arr[i] - k; int add = arr[i] + k; if (subtract >= small || add <= big) { i++; continue; } if (big - subtract <= add - small) small = subtract; else big = add; i++; } return Math.min(ans, big - small); } public static void main(String[] args) { int arr[] = { 4 , 6 }; int n = arr.length; int k = 10; System.out.println(\"Maximum difference is \"+ getMinDiff(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n\n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n\n\n\n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n}", "index": 592, "complexity": "5"}
{"forwhile": "class GFG { static int minOps(int arr[], int n, int k) { Arrays.sort(arr); int max = arr[arr.length - 1]; int res = 0; int i = 0; while(i < n) { if((max - arr[i]) % k != 0) return -1; else res += (max - arr[i]) / k; i++; } return res; } public static void main(String[] args) { int arr[] = { 21, 33, 9, 45, 63 }; int n = arr.length; int k = 6; System.out.println(minOps(arr, n, k)); } }", "src": "class\nGFG { \n\n\n\nstatic\nint\nminOps(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\n\n\nArrays.sort(arr); \n\nint\nmax = arr[arr.length - \n1\n]; \n\nint\nres = \n0\n; \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) { \n\n\n\n\n\n\nif\n((max - arr[i]) % k != \n0\n) \n\nreturn\n-\n1\n; \n\n\n\n\nelse\n\nres += (max - arr[i]) / k; \n\n} \n\n\n\n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = { \n21\n, \n33\n, \n9\n, \n45\n, \n63\n}; \n\nint\nn = arr.length; \n\nint\nk = \n6\n; \n\nSystem.out.println(minOps(arr, n, k)); \n\n} \n}", "index": 593, "complexity": "5"}
{"forwhile": "class\nGFG { \n\n\n\n\nstatic\nint\nminElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nhalfSum = \n0\n; \n\nint i = 0; \n\nwhile (i < n) { \n\nhalfSum = halfSum + arr[i]; \n\ni++; \n} \n\nhalfSum = halfSum / \n2\n; \n\n\n\n\n\n\n\n\n\nArrays.sort(arr); \n\n\nint\nres = \n0\n, curr_sum = \n0\n; \n\nint i = n-\n1\n; \n\nfor (; i >= \n0\n; i--) { \n\n\ncurr_sum += arr[i]; \n\nres++; \n\n\n\n\nif\n(curr_sum > halfSum) \n\nreturn\nres; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n3\n, \n1\n, \n7\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(minElements(arr, n)); \n\n} \n\n}", "src": "class\nGFG { \n\n\n\n\nstatic\nint\nminElements(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nhalfSum = \n0\n; \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nhalfSum = halfSum + arr[i]; \n\nhalfSum = halfSum / \n2\n; \n\n\n\n\n\n\n\n\n\nArrays.sort(arr); \n\n\nint\nres = \n0\n, curr_sum = \n0\n; \n\nfor\n(\nint\ni = n-\n1\n; i >= \n0\n; i--) { \n\n\ncurr_sum += arr[i]; \n\nres++; \n\n\n\n\nif\n(curr_sum > halfSum) \n\nreturn\nres; \n\n} \n\nreturn\nres; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) { \n\nint\narr[] = {\n3\n, \n1\n, \n7\n, \n1\n}; \n\nint\nn = arr.length; \n\nSystem.out.println(minElements(arr, n)); \n\n} \n\n}", "index": 594, "complexity": "5"}
{"forwhile": "class Main { static void minAbsSumPair(int arr[], int n) { int sum, min_sum = 999999; int l = 0, r = n-1; int min_l = l, min_r = n-1; if(n < 2) { System.out.println(\\", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nsum, min_sum = \n999999\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n\n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n\n\n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n\n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n\n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n\n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n\n\nint\npi = partition(arr, low, high); \n\n\n\n\n\n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n}", "index": 595, "complexity": "5"}
{"forwhile": "class GFG { public static void kLargest(Integer[] arr, int k) { Arrays.sort(arr, Collections.reverseOrder()); int i = 0; while(i < k) { System.out.print(arr[i] + \" \"); i++; } } public static void main(String[] args) { Integer arr[] = new Integer[] { 1, 23, 12, 9, 30, 2, 50 }; int k = 3; kLargest(arr, k); } }", "src": "class\nGFG { \n\npublic\nstatic\nvoid\nkLargest(Integer[] arr, \nint\nk) \n\n{ \n\n\n\n\n\n\n\n\n\nArrays.sort(arr, Collections.reverseOrder()); \n\n\n\n\nfor\n(\nint\ni = \n0\n; i < k; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nInteger arr[] = \nnew\nInteger[] { \n1\n, \n23\n, \n12\n, \n9\n, \n\n30\n, \n2\n, \n50\n}; \n\nint\nk = \n3\n; \n\nkLargest(arr, k); \n\n} \n}", "index": 596, "complexity": "5"}
{"forwhile": "public class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        int i = 0;\n        while(i < n) {\n            a[i] = scanner.nextInt();\n            i++;\n        }\n\n        i = 0;\n        while(i < n) {\n            b[i] = scanner.nextInt();\n            i++;\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        for(; max >= min;) {\n            double mid = max + min;\n            mid /= 2;\n            boolean v = isValid(a, b, m, n, mid);\n            \n            if (v) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n            if (max - min <= ERROR && v) {\n                \n                found = true;\n                break;\n            }\n            if (max ==  min) {\n                break;\n            }\n        }\n        \n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        int i = 0;\n        while(i < n) {\n            double lost = total;\n            lost /= a[i];\n            total -= lost;\n\n            lost = total;\n            lost /= b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n            i++;\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}", "src": "public class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        for(int i =0; i< n; i++ ) {\n            a[i] = scanner.nextInt();\n        }\n\n        for(int i =0; i< n; i++ ) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             \n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 \n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        \n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;i++) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}", "index": 598, "complexity": "5"}
{"forwhile": "public class BigInteger7 {\n    public static void main(String[] args) {\n        \n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        int i = 0;\n        while (BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n            i++;\n        }\n        for(; number.subtract(k).compareTo(BigInteger.ZERO) < 0; ) {\n            System.out.println(-1);\n            return;\n        }\n        System.out.println(ans);\n    }\n}", "src": "public class BigInteger7 {\n    public static void main(String[] args) {\n        \n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}", "index": 599, "complexity": "5"}
{"forwhile": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tint i = 0;\n\t\twhile(i < str.length()) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 600, "complexity": "5"}
{"forwhile": "class GFG { static int k = 16; static int N = 100000; static long table[][] = new long[N][k + 1]; static void buildSparseTable(int arr[], int n) { int i = 0; while(i < n) { table[i][0] = arr[i]; i++; } int j = 1; while(j <= k) { i = 0; while(i <= n - (1 << j)) { table[i][j] = table[i][j - 1] + table[i + (1 << (j - 1))][j - 1]; i++; } j++; } } static long query(int L, int R) { long answer = 0; for(int j = k; j >= 0; j--) { while(L + (1 << j) - 1 <= R) { answer = answer + table[L][j]; L += 1 << j; } } return answer; } public static void main(String args[]) { int arr[] = { 3, 7, 2, 5, 8, 9 }; int n = arr.length; buildSparseTable(arr, n); System.out.println(query(0, 5)); System.out.println(query(3, 5)); System.out.println(query(2, 4)); } }", "src": "class\nGFG \n{ \n\n\nstatic\nint\nk = \n16\n; \n\n\nstatic\nint\nN = \n100000\n; \n\n\n\nstatic\nlong\ntable[][] = \nnew\nlong\n[N][k + \n1\n]; \n\n\nstatic\nvoid\nbuildSparseTable(\nint\narr[], \n\nint\nn) \n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\ntable[i][\n0\n] = arr[i]; \n\n\nfor\n(\nint\nj = \n1\n; j <= k; j++) \n\nfor\n(\nint\ni = \n0\n; i <= n - (\n1\n<< j); i++) \n\ntable[i][j] = table[i][j - \n1\n] + \n\ntable[i + (\n1\n<< (j - \n1\n))][j - \n1\n]; \n} \n\n\n\nstatic\nlong\nquery(\nint\nL, \nint\nR) \n{ \n\n\n\n\n\nlong\nanswer = \n0\n; \n\nfor\n(\nint\nj = k; j >= \n0\n; j--) \n\n{ \n\nif\n(L + (\n1\n<< j) - \n1\n<= R) \n\n{ \n\nanswer = answer + table[L][j]; \n\n\n\n\n\n\nL += \n1\n<< j; \n\n} \n\n} \n\nreturn\nanswer; \n} \n\n\npublic\nstatic\nvoid\nmain(String args[]) \n{ \n\nint\narr[] = { \n3\n, \n7\n, \n2\n, \n5\n, \n8\n, \n9\n}; \n\nint\nn = arr.length; \n\n\nbuildSparseTable(arr, n); \n\n\nSystem.out.println(query(\n0\n, \n5\n)); \n\nSystem.out.println(query(\n3\n, \n5\n)); \n\nSystem.out.println(query(\n2\n, \n4\n)); \n} \n}", "index": 601, "complexity": "5"}
{"forwhile": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            do\n            {\n                if(token==null || !token.hasMoreTokens())\n                {\n                    try\n                    {\n                        token=new StringTokenizer(br.readLine());\n                    }\n                    catch(IOException e)\n                    {\n                        throw new RuntimeException(e);\n                    }\n                }\n            } while(true);\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            int __tmp__t;\n            do\n            {\n                __tmp__t=Integer.parseInt(next());\n            } while(true);\n            return __tmp__t;\n        }\n\n        public long nextLong()\n        {\n            long __tmp__t;\n            do\n            {\n                __tmp__t=Long.parseLong(next());\n            } while(true);\n            return __tmp__t;\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            do\n            {\n                if(o1.l!=o2.l)\n                    return (o1.l-o2.l);\n                else\n                    return o1.s.compareTo(o2.s);\n            } while(true);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        int i=0;\n        do\n        {\n            l.add(a[i]);\n            i++;\n        } while(i<a.length);\n        Collections.shuffle(l);\n        i=0;\n        do\n        {\n            a[i]=l.get(i);\n            i++;\n        } while(i<a.length);\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n;\n        do\n        {\n            n=sc.nextInt();\n        } while(true);\n        HashMap<String ,Integer> m=new HashMap<>();\n        int i=0;\n        do\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n                m.put(t,m.get(t)+1);\n            else\n                m.put(t,1);\n            i++;\n        } while(i<n);\n        int ans=0;\n        i=0;\n        do\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n            i++;\n        } while(i<n);\n        System.out.println(n-ans);\n    }\n}", "src": "public class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    \n    static class Pair\n    {\n        int a;int b;\n        public Pair(int a,int b)\n        {\n            this.a =a;\n            this.b =b;\n        }\n    }\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int n=sc.nextInt();\n        HashMap<String ,Integer> m=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t))\n            m.put(t,m.get(t)+1);\n            else\n            m.put(t,1);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++)\n        {\n            String t=sc.next();\n            if(m.containsKey(t) && m.get(t)>0)\n            {\n                m.put(t,m.get(t)-1);\n                ans++;\n            }\n        }\n        System.out.println(n-ans);\n    }\n}", "index": 602, "complexity": "5"}
{"forwhile": "public class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        int i = 0;\n        while(i < n) {\n            a[i] = scanner.nextInt();\n            i++;\n        }\n\n        i = 0;\n        while(i < n) {\n            b[i] = scanner.nextInt();\n            i++;\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        for(; max >= min;) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             \n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 \n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        \n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n            i++;\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}", "src": "public class Fly {\n\n    static double ERROR = 0.0000001;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n =  scanner.nextInt();\n        int m = scanner.nextInt();\n        int [] a = new int[n + 1];\n        int [] b = new int[n + 1];\n        for(int i =0; i< n; i++ ) {\n            a[i] = scanner.nextInt();\n        }\n\n        for(int i =0; i< n; i++ ) {\n            b[i] = scanner.nextInt();\n        }\n        b[n] = b[0];\n\n        double max =  1000000000;\n        double min = 0;\n        boolean found = false;\n        while (max >= min) {\n            double mid = max + min;\n             mid /= 2;\n             boolean v = isValid(a, b, m, n, mid);\n             \n             if (v) {\n                 max = mid;\n             }\n             else {\n                 min = mid;\n             }\n             if (max - min <= ERROR && v) {\n                 \n                 found = true;\n                 break;\n             }\n             if (max ==  min) {\n                 break;\n             }\n        }\n        \n        if (found) {\n            System.out.println(max);\n        }\n        else System.out.println(-1);\n    }\n\n\n    static boolean isValid(int [] a, int [] b, int m, int n, double fuel) {\n        double total =  m + fuel;\n        for (int i=0; i<n;i++) {\n            double lost = total;\n            lost/= a[i];\n            total -= lost;\n\n            lost = total;\n            lost/=b[i+1];\n            total -= lost;\n            if ((total-m) < 0) {\n                return false;\n            }\n        }\n        if ((total-m) < 0) return false;\n        return  true;\n    }\n}", "index": 603, "complexity": "5"}
{"forwhile": "public class BigInteger7 {\n    public static void main(String[] args) {\n        \n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        int i = 0;\n        while(BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n            i++;\n        }\n        for(; number.subtract(k).compareTo(BigInteger.ZERO) < 0;) {\n            System.out.println(-1);\n            break;\n        }\n        System.out.println(ans);\n    }\n}", "src": "public class BigInteger7 {\n    public static void main(String[] args) {\n        \n        Scanner scanner = new Scanner(System.in);\n        BigInteger n = scanner.nextBigInteger();\n        BigInteger k = scanner.nextBigInteger();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        char ch[] = string.toCharArray();\n        BigInteger ans = BigInteger.ZERO;\n        BigInteger number = BigInteger.ZERO;\n        Arrays.sort(ch);\n        int prev = 0;\n        for (int i = 0; BigInteger.valueOf(i).subtract(n).compareTo(BigInteger.ZERO) < 0; i++) {\n            if (i == 0) {\n                ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                prev = i;\n                number = number.add(BigInteger.ONE);\n            } else {\n                if (ch[i] - ch[prev] > 1) {\n                    ans = ans.add(BigInteger.valueOf(ch[i] - 'a' + 1));\n                    prev = i;\n                    number = number.add(BigInteger.ONE);\n                }\n            }\n            if (number.equals(k)) {\n                break;\n            }\n        }\n        if (number.subtract(k).compareTo(BigInteger.ZERO) < 0) {\n            System.out.println(-1);\n        } else {\n            System.out.println(ans);\n        }\n    }\n}", "index": 604, "complexity": "5"}
{"forwhile": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tint i = 0;\n\t\twhile(i < str.length()) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0) continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif(k > 0) ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "src": "public class HelloWorld {\n\tstatic long SQR(long a) {\n\t\treturn a * a;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString str = sc.next();\n\t\tchar s[] = str.toCharArray();\n\t\tArrays.parallelSort(s);\n\t\tstr = new String(s);\n\t\tint d = 0;\n\t\tint ans = 0;\n\n\t\tfor(int i = 0;i < str.length();i++) {\n\t\t\tint x = str.charAt(i) - 'a';\n\t\t\tif(k == 0)continue;\n\t\t\tif(x >= d) {\n\t\t\t\tans = ans + x + 1;\n\t\t\t\td = x + 2;\n\t\t\t\tk = k - 1;\n\t\t\t}\n\t\t}\n\t\tif(k > 0)ans = -1;\n\t\tSystem.out.println(ans);\n\t}\n}", "index": 605, "complexity": "5"}
{"forwhile": "class GFG { static int getMinDiff(int arr[], int n, int k) { if(n == 1) return 0; Arrays.sort(arr); int ans = arr[n-1] - arr[0]; int small = arr[0] + k; int big = arr[n-1] - k; int temp = 0; if(small > big) { temp = small; small = big; big = temp; } int i = 1; while(i < n-1) { int subtract = arr[i] - k; int add = arr[i] + k; if(subtract >= small || add <= big) { i++; continue; } if(big - subtract <= add - small) small = subtract; else big = add; i++; } return Math.min(ans, big - small); } public static void main(String[] args) { int arr[] = { 4 , 6 }; int n = arr.length; int k = 10; System.out.println(\\", "src": "class\nGFG { \n\n\n\n\n\n\n\n\nstatic\nint\ngetMinDiff(\nint\narr[], \nint\nn, \nint\nk) \n\n{ \n\nif\n(n == \n1\n) \n\nreturn\n0\n; \n\n\n\n\nArrays.sort(arr); \n\n\n\n\nint\nans = arr[n-\n1\n] - arr[\n0\n]; \n\n\n\n\nint\nsmall = arr[\n0\n] + k; \n\nint\nbig = arr[n-\n1\n] - k; \n\nint\ntemp = \n0\n; \n\n\nif\n(small > big) \n\n{ \n\ntemp = small; \n\nsmall = big; \n\nbig = temp; \n\n} \n\n\n\n\nfor\n(\nint\ni = \n1\n; i < n-\n1\n; i ++) \n\n{ \n\nint\nsubtract = arr[i] - k; \n\nint\nadd = arr[i] + k; \n\n\n\n\n\n\nif\n(subtract >= small || add <= big) \n\ncontinue\n; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif\n(big - subtract <= add - small) \n\nsmall = subtract; \n\nelse\n\nbig = add; \n\n} \n\n\nreturn\nMath.min(ans, big - small); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = {\n4\n, \n6\n}; \n\nint\nn = arr.length; \n\nint\nk = \n10\n; \n\nSystem.out.println(\n\"Maximum difference is \"\n+ \n\ngetMinDiff(arr, n, k)); \n\n} \n}", "index": 606, "complexity": "5"}
{"forwhile": "public class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public int nextInt() {\n            int c = read();\n\n            for (; isSpaceChar(c); c = read()) {\n            }\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n\n            while (!isSpaceChar(c)) {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n\n            for (; isSpaceChar(c); c = read()) {\n            }\n\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n\n            for (; isSpaceChar(c); c = read()) {\n            }\n\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n\n            for (; !isSpaceChar(c) && c != '.'; c = read()) {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                for (; !isSpaceChar(c); c = read()) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n\n            for (; isSpaceChar(c); c = read()) {\n            }\n\n            StringBuilder res = new StringBuilder();\n\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(), \"Main\", 1 << 26).start();\n    }\n\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        long s = sc.nextLong();\n        long arr[] = new long[n];\n        int i = 0;\n        while (i < n) {\n            arr[i] = sc.nextLong();\n            i++;\n        }\n        Arrays.sort(arr);\n\n        long count = 0;\n        if (arr[n / 2] == s) {\n\n            w.print(0);\n        } else {\n            int temp = n / 2;\n\n            if (arr[temp] > s) {\n                do {\n                    count = count + (arr[temp] - s);\n                    temp--;\n                    if (temp < 0) {\n                        break;\n                    }\n                } while (arr[temp] > s);\n            } else {\n                do {\n                    count = count + (s - arr[temp]);\n                    temp++;\n                    if (temp >= n) {\n                        break;\n                    }\n                } while (arr[temp] < s);\n            }\n            w.print(count);\n        }\n\n        w.close();\n    }\n}", "src": "public class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n             \n            int n=sc.nextInt();\n            long s=sc.nextLong();\n            long arr[]=new long[n];\n            int i=0;\n            for(i=0;i<n;i++)\n            {\n                              arr[i]=sc.nextLong();\n            }\n            Arrays.sort(arr);\n            \n            \n            long count=0;\n            if(arr[n/2]==s)\n            {\n                              \n                              w.print(0);\n            }\n            else\n            {\n                              int temp=n/2;\n                              \n                              if(arr[temp]>s)\n                              {\n                                                while(arr[temp]>s)\n                                                {\n                                                                  count=count+(arr[temp]-s);\n                                                                  temp--;\n                                                                  if(temp<0)\n                                                                  {\n                                                                                    break;\n                                                                  }\n                                                }\n                              }\n                              else\n                              {\n                                               \n                                               while(arr[temp]<s)\n                                               {\n                                                                 \n                                                                 count=count+(s-arr[temp]);\n                                                                 temp++;\n                                                                 if(temp>=n)\n                                                                 {\n                                                                                   break;\n                                                                 }\n                                               }\n                              }\n                              w.print(count);\n            }\n            \n               \n               \n\n        w.close();\n    }\n}", "index": 607, "complexity": "5"}
{"forwhile": "public class gambling {\n    public static void main(String[] args) throws IOException{\n        Reader rd = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = rd.nextInt();\n        Integer[] a = new Integer[n];\n        Integer[] b = new Integer[n];\n        int i = 0;\n        while (i < n) {\n            a[i] = rd.nextInt();\n            i++;\n        }\n        i = 0;\n        while (i < n) {\n            b[i] = rd.nextInt();\n            i++;\n        }\n        solve(n, a, b, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, Integer[] a, Integer[] b, PrintWriter out) {\n        Arrays.sort(a, Collections.reverseOrder());\n        Arrays.sort(b, Collections.reverseOrder());\n        int aP = 0, bP = 0;\n        long aScore = 0, bScore = 0;\n        int i = 0;\n        for (; i < n * 2; i++) {\n            if(i % 2 == 0) {\n                if(bP ==  n || (aP < n && a[aP] > b[bP])){\n                    aScore += a[aP];\n                    aP++;\n                }\n                else bP++;\n            }\n            else{\n                if(aP == n || (bP < n && b[bP] > a[aP])) {\n                    bScore += b[bP];\n                    bP++;\n                }\n                else aP++;\n            }\n        }\n        out.println(aScore-bScore);\n    }\n\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; \n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}", "src": "public class gambling {\n    public static void main(String[] args) throws IOException{\n        Reader rd = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = rd.nextInt();\n        Integer[] a = new Integer[n];\n        Integer[] b = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = rd.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = rd.nextInt();\n        }\n        solve(n, a, b, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, Integer[] a, Integer[] b, PrintWriter out) {\n        Arrays.sort(a, Collections.reverseOrder());\n        Arrays.sort(b, Collections.reverseOrder());\n        int aP = 0, bP = 0;\n        long aScore = 0, bScore = 0;\n        for (int i = 0; i < n * 2; i++) {\n                if(i % 2 == 0) {\n                    if(bP ==  n || (aP < n && a[aP] > b[bP])){\n                        aScore += a[aP];\n                        aP++;\n                    }\n                    else bP++;\n                }\n                else{\n                    if(aP == n || (bP < n && b[bP] > a[aP])) {\n                        bScore += b[bP];\n                        bP++;\n                    }\n                    else aP++;\n                }\n        }\n        out.println(aScore-bScore);\n    }\n\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; \n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}", "index": 608, "complexity": "5"}
{"forwhile": "public class cf {\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            for (; st == null || !st.hasMoreElements(); ) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            int idx = 0;\n            while (idx < n) {\n                a[idx] = nextInt();\n                idx++;\n            }\n            return a;\n        }\n    }\n\n    static int mod = 1000000007;\n    \n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out); \n\n        int n = sc.nextInt(), k = sc.nextInt();\n        int[] a = new int[n+1];\n\n        int i = 0;\n        while (i < n) {\n            a[i] = sc.nextInt();\n            i++;\n        }\n        a[n] = 0;\n        Arrays.sort(a);\n\n        for (int j = 1; j <= n; j++) {\n            if (k == 0) {\n                break;\n            }\n            if (a[j] != a[j-1]) {\n                k--;\n                pw.println(a[j] - a[j-1]);\n            }\n        }\n        for (int m = 0; m < k; m++) {\n            pw.println(0);\n        }\n        pw.close();\n    }\n}", "src": "public class cf {\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n    }\n\n    static int mod = 1000000007;\n    \n\tpublic static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out); \n\n        int n=sc.nextInt(), k = sc.nextInt();\n        int[] a = new int[n+1];\n\n        for(int i=0;i<n;i++) {\n            a[i] = sc.nextInt();\n        }\n        a[n] = 0;\n        Arrays.sort(a);\n\n        for(int i=1;i<=n;i++) {\n            if(k == 0) {\n                break;\n            }\n            if(a[i] != a[i-1]) {\n                k--;\n                pw.println(a[i] - a[i-1]);\n            }\n        }\n        for(int i=0;i<k;i++) pw.println(0);\n        pw.close();\n    }\n}", "index": 609, "complexity": "5"}
{"forwhile": "public class bOX {\n\n    public static void main(String ars[]){\n\n        Scanner  s = new Scanner(System.in);\n        int n = s.nextInt();\n        int max = 0;\n\n        Map<Integer,Integer> map = new HashMap<>();\n\n        int i = 0;\n        while(i < n){\n            int x = s.nextInt();\n            if(!map.containsKey(x)){\n                map.put(x,1);\n                max = Math.max(max,1);\n            }\n            else{\n                map.put(x,map.get(x)+1);\n                max = Math.max(max,map.get(x));\n            }\n            i++;\n        }\n\n        System.out.println(max);\n    }\n\n}", "src": "public class bOX {\n\n    public static void main(String ars[]){\n\n        Scanner  s = new Scanner(System.in);\n        int n = s.nextInt();\n        int max = 0;\n\n        Map<Integer,Integer> map = new HashMap<>();\n\n        for(int i=0;i<n;i++){\n            int x = s.nextInt();\n            if(!map.containsKey(x)){\n                map.put(x,1);\n                max = Math.max(max,1);\n            }\n            else{\n                map.put(x,map.get(x)+1);\n                max = Math.max(max,map.get(x));\n            }\n        }\n\n        System.out.println(max);\n    }\n\n}", "index": 610, "complexity": "5"}
{"forwhile": "class GFG { static int findMinDiff(int[] arr, int n) { Arrays.sort(arr); int diff = Integer.MAX_VALUE; int i = 0; while(i<n-1) { if(arr[i+1] - arr[i] < diff) diff = arr[i+1] - arr[i]; i++; } return diff; } public static void main(String[] args) { int arr[] = new int[]{1, 5, 3, 19, 18, 25}; System.out.println(\"Minimum difference is \"+ findMinDiff(arr, arr.length)); } }", "src": "class\nGFG \n{ \n\n\n\nstatic\nint\nfindMinDiff(\nint\n[] arr, \nint\nn) \n\n{ \n\n\n\nArrays.sort(arr); \n\n\n\n\nint\ndiff = Integer.MAX_VALUE; \n\n\n\n\n\n\nfor\n(\nint\ni=\n0\n; i<n-\n1\n; i++) \n\nif\n(arr[i+\n1\n] - arr[i] < diff) \n\ndiff = arr[i+\n1\n] - arr[i]; \n\n\n\n\nreturn\ndiff; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[]{\n1\n, \n5\n, \n3\n, \n19\n, \n18\n, \n25\n}; \n\nSystem.out.println(\n\"Minimum difference is \"\n+ \n\nfindMinDiff(arr, arr.length)); \n\n\n} \n}", "index": 611, "complexity": "5"}
{"forwhile": "public class RadioStation {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tmap.put(t, s);\n\t\t\ti++;\n\t\t}\n\t\tint i = 0;\n\t\twhile(i < m) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tSystem.out.println(s + \" \" + t + \" #\" + map.get(t.substring(0, t.length()-1)));\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\tfor(; st == null || !st.hasMoreTokens(); st = new StringTokenizer(in.readLine())) {\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tint i = 0;\n\t\tfor(; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\tint j = 0;\n\t\t\twhile(j < m) {\n\t\t\t\ta[i][j] = nextInt();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tint i = 0;\n\t\twhile(i < n) {\n\t\t\ta[i] = nextLong();\n\t\t\ti++;\n\t\t}\n\t\treturn a;\n\t}\n}", "src": "public class RadioStation {\n\tpublic static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tmap.put(t, s);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString s = nextString();\n\t\t\tString t = nextString();\n\t\t\tSystem.out.println(s + \" \" + t + \" #\" + map.get(t.substring(0, t.length()-1)));\n\t\t}\n\t}\n\t\n\tpublic static String nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tpublic static String nextString() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tpublic static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextString());\n\t}\n\n\tpublic static long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextString());\n\t}\n\n\tpublic static int[] intArray(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static int[][] intArray(int n, int m) throws IOException {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic static long[] longArray(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}", "index": 612, "complexity": "5"}
{"forwhile": "class AlternativeString  {\n\n\n\nstatic void alternateSort(\nint arr[], \nint n) \n\n{ \n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\nint i = \n0\n, j = n-\n1\n; \n\nfor(; i < j; j--) { \n\nSystem.out.print(arr[j] + \n\" \"\n); \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\ni++; \n\n} \n\n\n\n\n\n\nif\n(n % \n2\n!= \n0\n) \n\nSystem.out.print(arr[i]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, \n4\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nalternateSort(arr, n); \n\n} \n}", "src": "class\nAlternativeString \n{ \n\n\n\nstatic\nvoid\nalternateSort(\nint\narr[], \nint\nn) \n\n{ \n\nArrays.sort(arr); \n\n\n\n\n\n\n\n\n\n\nint\ni = \n0\n, j = n-\n1\n; \n\nwhile\n(i < j) { \n\nSystem.out.print(arr[j--] + \n\" \"\n); \n\nSystem.out.print(arr[i++] + \n\" \"\n); \n\n} \n\n\n\n\n\n\nif\n(n % \n2\n!= \n0\n) \n\nSystem.out.print(arr[i]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n12\n, \n4\n, \n6\n, \n7\n, \n10\n}; \n\nint\nn = arr.length; \n\nalternateSort(arr, n); \n\n} \n}", "index": 613, "complexity": "5"}
{"forwhile": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int height = in.nextInt();\n            int width = in.nextInt();\n            int n1 = in.nextInt();\n            int n2 = in.nextInt();\n            int v = in.nextInt();\n            int[] p1 = new int[n1];\n            int i = 0;\n            while (i < n1) {\n                p1[i] = in.nextInt();\n                i++;\n            }\n            int[] p2 = new int[n2];\n            i = 0;\n            while (i < n2) {\n                p2[i] = in.nextInt();\n                i++;\n            }\n            int nq = in.nextInt();\n            for (int iq = 0; iq < nq; iq++) {\n                int r1 = in.nextInt();\n                int c1 = in.nextInt();\n                int r2 = in.nextInt();\n                int c2 = in.nextInt();\n                if (r1 == r2) {\n                    out.println(Math.abs(c1 - c2));\n                } else {\n                    long res = Long.MAX_VALUE;\n                    int pos;\n                    pos = Arrays.binarySearch(p1, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    pos--;\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    pos = Arrays.binarySearch(p2, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    pos--;\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    out.println(res);\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int height = in.nextInt();\n            int width = in.nextInt();\n            int n1 = in.nextInt();\n            int n2 = in.nextInt();\n            int v = in.nextInt();\n            int[] p1 = new int[n1];\n            for (int i = 0; i < n1; ++i) p1[i] = in.nextInt();\n            int[] p2 = new int[n2];\n            for (int i = 0; i < n2; ++i) p2[i] = in.nextInt();\n            int nq = in.nextInt();\n            for (int iq = 0; iq < nq; ++iq) {\n                int r1 = in.nextInt();\n                int c1 = in.nextInt();\n                int r2 = in.nextInt();\n                int c2 = in.nextInt();\n                if (r1 == r2) {\n                    out.println(Math.abs(c1 - c2));\n                } else {\n                    long res = Long.MAX_VALUE;\n                    int pos = Arrays.binarySearch(p1, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p1.length) {\n                        res = Math.min(res, Math.abs(p1[pos] - c1) + Math.abs(p1[pos] - c2) + Math.abs(r1 - r2));\n                    }\n                    pos = Arrays.binarySearch(p2, c1);\n                    if (pos < 0) pos = -(pos + 1);\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    --pos;\n                    if (pos >= 0 && pos < p2.length) {\n                        res = Math.min(res, Math.abs(p2[pos] - c1) + Math.abs(p2[pos] - c2) + (Math.abs(r1 - r2) + v - 1) / v);\n                    }\n                    out.println(res);\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}", "index": 614, "complexity": "5"}
{"forwhile": "class GFG { static void rearrange(int[] arr, int n, int x) { TreeMap<Integer, ArrayList<Integer>> m = new TreeMap<>(); int i = 0; while(i < n) { int diff = Math.abs(x - arr[i]); if(m.containsKey(diff)) { ArrayList<Integer> al = m.get(diff); al.add(arr[i]); m.put(diff, al); } else { ArrayList<Integer> al = new ArrayList<>(); al.add(arr[i]); m.put(diff, al); } i++; } int index = 0; for (Map.Entry entry : m.entrySet()) { ArrayList<Integer> al = m.get(entry.getKey()); int j = 0; while(j < al.size()) { arr[index++] = al.get(j); j++; } } } static void printArray(int[] arr, int n) { int i = 0; while(i < n) { System.out.print(arr[i] + \" \"); i++; } } public static void main(String args[]) { int[] arr = { 10, 5, 3, 9, 2 }; int n = arr.length; int x = 7; rearrange(arr, n, x); printArray(arr, n); } }", "src": "class\nGFG \n{ \n\n\n\n\n\n\nstatic\nvoid\nrearrange(\nint\n[] arr, \nint\nn, \nint\nx) \n\n{ \n\nTreeMap<Integer, ArrayList<Integer>> m = \nnew\nTreeMap<>(); \n\n\n\n\n\n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\n{ \n\nint\ndiff = Math.abs(x - arr[i]); \n\nif\n(m.containsKey(diff)) \n\n{ \n\nArrayList<Integer> al = m.get(diff); \n\nal.add(arr[i]); \n\nm.put(diff, al); \n\n} \n\nelse\n\n{ \n\nArrayList<Integer> al = \nnew\nArrayList<>(); \n\nal.add(arr[i]); \n\nm.put(diff,al); \n\n} \n\n} \n\n\n\n\nint\nindex = \n0\n; \n\nfor\n(Map.Entry entry : m.entrySet()) \n\n{ \n\nArrayList<Integer> al = m.get(entry.getKey()); \n\nfor\n(\nint\ni = \n0\n; i < al.size(); i++) \n\narr[index++] = al.get(i); \n\n} \n\n} \n\n\n\n\nstatic\nvoid\nprintArray(\nint\n[] arr, \nint\nn) \n\n{ \n\nfor\n(\nint\ni = \n0\n; i < n; i++) \n\nSystem.out.print(arr[i] + \n\" \"\n); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String args[]) \n\n{ \n\nint\n[] arr = {\n10\n, \n5\n, \n3\n, \n9\n,\n2\n}; \n\nint\nn = arr.length; \n\nint\nx = \n7\n; \n\nrearrange(arr, n, x); \n\nprintArray(arr, n); \n\n} \n}", "index": 615, "complexity": "5"}
{"forwhile": "public class LessorEqual_CodeForces {\n\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString temp[]=br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(temp[0]);\n\t\tint k = Integer.parseInt(temp[1]);\n\t\ttemp=br.readLine().split(\" \");\n\t\tint [] num = new int[n];\n\n\t\tPriorityQueue<Integer>pq = new PriorityQueue<Integer>();  \n\t\tint i = 0;\n\t\twhile(i < n){\n\t\t\tnum[i]=Integer.parseInt(temp[i]);\n\t\t\tpq.add(num[i]);\n\t\t\n\t\t\t\t\t\t\n\t\t    i++;\n\t\t}\n\t\tif(k==0){\n\t\t\tint y= pq.poll();\n\t\t\tif(y==1){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\tSystem.out.println(y-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\tint count=0;\n\t\tint max=0;\n\t\tfor(; !pq.isEmpty();){\n\t\t\tint x = pq.poll();\n\t\t\tfor(; count<=k&&!pq.isEmpty()&& pq.peek()==x;){\n\t\t\t\tpq.poll();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\n\t\t\tcount++;\n\t\t\tmax=x;\n\t\t\tif(count==k)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\tif(count==k){\n\t\t\tif(!pq.contains(max+1)&& max<1e9)\n\t\t\t\tSystem.out.println(max+1);\n\t\t\telse \n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\telse \n\t\t\tSystem.out.println(-1);\n \n\t\t\n\t}\n\n}", "src": "public class LessorEqual_CodeForces {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString temp[]=br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(temp[0]);\n\t\tint k = Integer.parseInt(temp[1]);\n\t\ttemp=br.readLine().split(\" \");\n\t\tint [] num = new int[n];\n\n\t\tPriorityQueue<Integer>pq = new PriorityQueue<Integer>();  \n\t\tfor(int i=0;i<n;i++){\n\t\t\tnum[i]=Integer.parseInt(temp[i]);\n\t\t\tpq.add(num[i]);\n\t\t\n\t\t\t\t\t\t\n\t\t}\n\t\tif(k==0){\n\t\t\tint y= pq.poll();\n\t\t\tif(y==1){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\tSystem.out.println(y-1);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tint count=0;\n\t\tint max=0;\n\t\twhile (!pq.isEmpty()){\n\t\t\tint x = pq.poll();\n\t\t\twhile(count<=k&&!pq.isEmpty()&& pq.peek()==x){\n\t\t\t\tpq.poll();\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\n\t\t\tcount++;\n\t\t\tmax=x;\n\t\t\tif(count==k)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\tif(count==k){\n\t\t\tif(!pq.contains(max+1)&& max<1e9)\n\t\t\t\tSystem.out.println(max+1);\n\t\t\telse \n\t\t\t\tSystem.out.println(max);\n\t\t\t}\n\t\telse \n\t\t\tSystem.out.println(-1);\n \n\t\t\n\t}\n\n}", "index": 616, "complexity": "5"}
{"forwhile": "public class JavaApplication7 {\n\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n= sc.nextInt();\n        int m=sc.nextInt();\n        long sum=0;\n        long []d=new long[n];\n        long[]ds=new long[n];\n        int i = 0;\n        while(i<n){\n            d[i]=sc.nextLong();\n            sum+=d[i];\n            ds[i]=sum;\n            i++;\n        }\n        long[]le=new long[m];\n        int j = 0;\n        while(j<m){\n            le[j]=sc.nextLong();\n            j++;\n        }\n        int l=0;\n        int h=n;\n        int k=(h-l)/2;\n        k+=l;\n        int p = 0;\n        while(p<m){\n        l=0;\n        h=n;\n        k=(h-l)/2;\n        k+=l;\n            for(;l<=h;){\n                k=(h-l)/2;\n                k+=l;\n                if(ds[k]<le[p]){\n                    l=k+1;\n                }\n                else if(ds[k]==le[p]){break;}\n                else{\n                    h=k-1;\n                }\n            }\n            \n            if(ds[k]<le[p]){\n                    k++;\n                }\n          if(k==0){\n              System.out.println((int)(k+1)+\" \"+le[p]);\n           }\n            else{\n                System.out.println((int)(k+1)+\" \"+(long)(le[p]-ds[k-1]));\n           }\n           p++;\n        }\n        \n    }\n    \n}", "src": "public class JavaApplication7 {\n\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n= sc.nextInt();\n        int m=sc.nextInt();\n        long sum=0;\n        long []d=new long[n];\n        long[]ds=new long[n];\n        for(int i =0;i<n;i++){\n            d[i]=sc.nextLong();\n            sum+=d[i];\n            ds[i]=sum;\n        }\n        long[]le=new long[m];\n        for(int i =0;i<m;i++){\n            le[i]=sc.nextLong();\n        }\n        int l=0;\n        int h=n;\n        int k=(h-l)/2;\n        k+=l;\n        for(int i=0;i<m;i++){\n        l=0;\n        h=n;\n        k=(h-l)/2;\n        k+=l;\n            for(;l<=h;){\n                k=(h-l)/2;\n                k+=l;\n                if(ds[k]<le[i]){\n                    l=k+1;\n                }\n                else if(ds[k]==le[i]){break;}\n                else{\n                    h=k-1;\n                }\n            }\n            \n            if(ds[k]<le[i]){\n                    k++;\n                }\n          if(k==0){\n              System.out.println((int)(k+1)+\" \"+le[i]);\n           }\n            else{\n                System.out.println((int)(k+1)+\" \"+(long)(le[i]-ds[k-1]));\n           }\n        }\n        \n    }\n    \n}", "index": 617, "complexity": "5"}
{"forwhile": "public final class Codeforces\n{\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    Scanner sc=new Scanner(System.in);\n\t\t\tint n=sc.nextInt();\n\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\tint i=0;\n\t\t\twhile(i<n){\n\t\t\t\tint temp=sc.nextInt();\n\t\t\t\tlist.add(temp);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\tif(n%2==0)\n\t\t\tSystem.out.println(list.get((n/2)-1));\n\t\t\telse\n\t\t\tSystem.out.println(list.get(n/2));\n\t}\n}", "src": "public final class Codeforces\n{\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    Scanner sc=new Scanner(System.in);\n\t\t\tint n=sc.nextInt();\n\t\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint temp=sc.nextInt();\n\t\t\t\tlist.add(temp);\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\tif(n%2==0)\n\t\t\tSystem.out.println(list.get((n/2)-1));\n\t\t\telse\n\t\t\tSystem.out.println(list.get(n/2));\n\t}\n}", "index": 618, "complexity": "5"}
{"forwhile": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n / 2];\n\t\tint i = 0;\n\t\twhile(i < p.length) {\n\t\t\tp[i] = sc.nextInt();\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(solve(p));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] p) {\n\t\treturn Math.min(computeMoveNum(p, 1), computeMoveNum(p, 2));\n\t}\n\n\tstatic int computeMoveNum(int[] p, int offset) {\n\t\tArrays.sort(p);\n\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < p.length; i++) {\n\t\t\tsum += Math.abs(p[i] - (i * 2 + offset));\n\t\t}\n\t\treturn sum;\n\t}\n}", "src": "public class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n / 2];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(solve(p));\n\n\t\tsc.close();\n\t}\n\n\tstatic int solve(int[] p) {\n\t\treturn Math.min(computeMoveNum(p, 1), computeMoveNum(p, 2));\n\t}\n\n\tstatic int computeMoveNum(int[] p, int offset) {\n\t\tArrays.sort(p);\n\n\t\treturn IntStream.range(0, p.length).map(i -> Math.abs(p[i] - (i * 2 + offset))).sum();\n\t}\n}", "index": 619, "complexity": "5"}
{"forwhile": "ERROR:Unterminated string starting at: line 2 column 17 (char 18)", "src": "public class Sol {\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tInteger[] a = new Integer[n*k];\n\t\tfor(int i = 0; i < n*k; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tArrays.sort(a);\n\t\tif (a[n - 1] - a[0] > l) {\n\t\t\tout.println(0);\n\t\t} else {\n\t\t\tint maxPos = n*k - 1;\n\t\t\tfor (int i = 0; i < n*k; i++) {\n\t\t\t\tif (a[i] - a[0] > l) {\n\t\t\t\t\tmaxPos = i-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong o = a[0];\n\t\t\tint s = 0;\n\t\t\tint t = 1;\n\t\t\tfor (int i = 1; i <= maxPos; i++) {\n\t\t\t\t\n\t\t\t\tif (s < k - 1 && maxPos-i+1 > n-t) {\n\t\t\t\t\t\n\t\t\t\t\ts++;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\ts = 0;\n\t\t\t\t\tt++;\n\t\t\t\t\to += a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(o);\n\t\t}\n\t\tout.close();\n\t}\n\n\t\n\tpublic static PrintWriter out;\n\n\t\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t}\n\t\n}", "index": 620, "complexity": "5"}
{"forwhile": "public class MicroWorld {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        Integer[] a = new Integer[n];\n        st = new StringTokenizer(br.readLine());\n        int i = 0;\n        while(i < n){\n            a[i] = Integer.parseInt(st.nextToken());\n            i++;\n        }\n        Arrays.sort(a);\n        int count = 1;\n        int remaining = n;\n        int j = 0;\n        while(j < n-1){\n            if((int)a[j] == (int)a[j+1]){\n                count++;\n                j++;\n                continue;\n            }\n            if((a[j] + k) >= a[j+1]){\n                remaining -= count;\n            }\n            count = 1;\n            j++;\n        }\n        System.out.println(remaining);\n    }\n}", "src": "public class MicroWorld {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        Integer[] a = new Integer[n];\n\n        st = new StringTokenizer(br.readLine());\n        for(int i=0; i<n; i++){\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n\n        Arrays.sort(a);\n\n        int count = 1;\n        int remaining = n;\n        for(int i=0; i<n-1; i++){\n            if((int)a[i] == (int)a[i+1]){\n                count++;\n                continue;\n            }\n            if((a[i] + k) >= a[i+1]){\n                remaining -= count;\n            }\n            count = 1;\n        }\n        System.out.println(remaining);\n    }\n}", "index": 621, "complexity": "5"}
{"forwhile": "public class gr1 {\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class card{\n        long a;\n        int cnt;\n        int i;\n        public card(long a,int cnt,int i)\n        {\n            this.a=a;\n            this.cnt=cnt;\n            this.i=i;\n        }\n    }\n\n    static class ascend implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.b!=o2.b)\n                return (int)(o1.b-o2.b);\n            else \n                return (int)(o1.a-o2.a);\n        }\n    }\n\n    \n\n    static class extra\n    {\n\n        static void shuffle(long a[])\n        {\n            List<Long> l=new ArrayList<>();\n            int i=0;\n            while(i<a.length)\n            {\n                l.add(a[i]);\n                i++;\n            }\n            Collections.shuffle(l);\n            i=0;\n            while(i<a.length)\n            {\n                a[i]=l.get(i);\n                i++;\n            }\n        }\n\n        static long gcd(long a,long b)\n        {\n            while(b!=0)\n            {\n                long temp=a;\n                a=b;\n                b=temp%b;\n            }\n            return a;\n        }\n\n        static boolean valid(int i,int j,int r,int c)\n        {\n            for(;i>=0 && i<r && j>=0 && j<c;) {\n                return true;\n            }\n            return false;\n        }\n\n        static boolean v[]=new boolean[100001];\n        static List<Integer> l=new ArrayList<>();\n        static int t;\n        static void seive()\n        {\n            for(int i=2;i<100001;i++)\n            {\n                if(!v[i])\n                {\n                    t++;\n                    l.add(i);\n                    for(int j=2*i;j<100001;j+=i)\n                        v[j]=true;\n                }\n            }\n        }\n\n        static int binary(pair a[],int val,int n)\n        {\n            int mid=0,l=0,r=n-1,ans=0;\n            for(;l<=r;)\n            {\n                mid=(l+r)>>1;\n                if(a[mid].a==val)\n                {\n                    r=mid-1;\n                    ans=mid;\n                }\n                else if(a[mid].a>val)\n                    r=mid-1;\n                else\n                {\n                    l=mid+1;\n                    ans=l;\n                }\n            }\n            return (ans);\n        }\n    }\n\n    static class pair{\n        long a;\n        int b;\n        public pair(long a,int n)\n        {\n            this.a=a;\n            this.b=n;\n        }\n    }\n    static InputReader sc=new InputReader(System.in);\n    static PrintWriter out=new PrintWriter(System.out);\n    public static void main(String[] args) {\n        solver s=new solver();\n        int t=1;\n        do {\n            s.solve();\n            t--;\n        } while(t>0);\n    }\n    static class solver\n    {\n        void solve()\n        {\n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int sum=0;\n            int i=0;\n            while(i<n)\n            {\n                a[i]=sc.nextInt();\n                sum+=a[i];\n                i++;\n            }\n            Arrays.sort(a);\n            int k=(int)Math.round(4.5*n)-sum;\n           \n            if(k<=0)\n            {\n                System.out.println(0);\n            }\n            else\n            {\n                int p=0,ans=0;\n                i=0;\n                while(i<n)\n                {\n                    if(a[i]!=5)\n                    {\n                        p+=5-a[i];\n                        if(p>=k){\n                            ans++;\n                            System.out.println(ans);\n                            break;\n                        }\n                        ans++;\n                    }\n                    i++;\n                }\n            }\n        }\n    }\n}", "src": "public class gr1 {\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class card{\n        long a;\n        int cnt;\n        int i;\n        public card(long a,int cnt,int i)\n        {\n            this.a=a;\n            this.cnt=cnt;\n            this.i=i;\n        }\n    }\n\n    static class ascend implements Comparator<pair>\n    {\n        public int compare(pair o1,pair o2)\n        {\n            if(o1.b!=o2.b)\n                return (int)(o1.b-o2.b);\n            else \n                return (int)(o1.a-o2.a);\n        }\n    }\n\n    \n\n    static class extra\n    {\n\n        static void shuffle(long a[])\n        {\n            List<Long> l=new ArrayList<>();\n            for(int i=0;i<a.length;i++)\n                l.add(a[i]);\n            Collections.shuffle(l);\n            for(int i=0;i<a.length;i++)\n                a[i]=l.get(i);\n        }\n\n        static long gcd(long a,long b)\n        {\n            if(b==0)\n                return a;\n            else\n                return gcd(b,a%b);\n        }\n\n        static boolean valid(int i,int j,int r,int c)\n        {\n            if(i>=0 && i<r && j>=0 && j<c)\n                return true;\n            else\n                return false;\n        }\n\n        static boolean v[]=new boolean[100001];\n        static List<Integer> l=new ArrayList<>();\n        static int t;\n        static void seive()\n        {\n            for(int i=2;i<100001;i++)\n            {\n                if(!v[i])\n                {\n                    t++;\n                    l.add(i);\n                    for(int j=2*i;j<100001;j+=i)\n                        v[j]=true;\n                }\n            }\n        }\n\n        static int binary(pair a[],int val,int n)\n        {\n            int mid=0,l=0,r=n-1,ans=0;\n            while(l<=r)\n            {\n                mid=(l+r)>>1;\n                if(a[mid].a==val)\n                {\n                    r=mid-1;\n                    ans=mid;\n                }\n                else if(a[mid].a>val)\n                    r=mid-1;\n                else\n                {\n                    l=mid+1;\n                    ans=l;\n                }\n            }\n            return (ans);\n        }\n    }\n\n    static class pair{\n        long a;\n        int b;\n        public pair(long a,int n)\n        {\n            this.a=a;\n            this.b=n;\n        }\n    }\n    static InputReader sc=new InputReader(System.in);\n    static PrintWriter out=new PrintWriter(System.out);\n    public static void main(String[] args) {\n        solver s=new solver();\n        int t=1;\n        while(t>0)\n        {\n            s.solve();\n            t--;\n        }\n    }\n    static class solver\n    {\n        void solve()\n        {\n            int n=sc.nextInt();\n            int a[]=new int[n];\n            int sum=0;\n            for(int i=0;i<n;i++)\n            {\n                a[i]=sc.nextInt();\n                sum+=a[i];\n            }\n            Arrays.sort(a);\n            int k=(int)Math.round(4.5*n)-sum;\n           \n            if(k<=0)\n            {\n                System.out.println(0);\n            }\n            else\n            {\n                int p=0,ans=0;\n                for(int i=0;i<n;i++)\n                {\n                    if(a[i]!=5)\n                    {\n                        p+=5-a[i];\n                        if(p>=k){\n                            ans++;\n                            System.out.println(ans);\n                            break;\n                        }\n                        ans++;\n                    }\n                }\n            }\n        }\n    }\n}", "index": 622, "complexity": "5"}
{"forwhile": "class Test { static int mergeSort(int arr[], int array_size) { int temp[] = new int[array_size]; return _mergeSort(arr, temp, 0, array_size - 1); } static int _mergeSort(int arr[], int temp[], int left, int right) { int mid, inv_count = 0; if (right > left) { mid = (right + left) / 2; inv_count = _mergeSort(arr, temp, left, mid); inv_count += _mergeSort(arr, temp, mid + 1, right); inv_count += merge(arr, temp, left, mid + 1, right); } return inv_count; } static int merge(int arr[], int temp[], int left, int mid, int right) { int i, j, k; int inv_count = 0; i = left; j = mid; k = left; for (; i <= mid - 1 && j <= right;) { if (arr[i] <= arr[j]) { temp[k++] = arr[i++]; } else { temp[k++] = arr[j++]; inv_count = inv_count + (mid - i); } } for (; i <= mid - 1;) temp[k++] = arr[i++]; for (; j <= right;) temp[k++] = arr[j++]; for (i = left; i <= right; i++) arr[i] = temp[i]; return inv_count; } public static void main(String[] args) { int arr[] = new int[] { 1, 20, 6, 4, 5 }; System.out.println(\"Number of inversions are \" + mergeSort(arr, 5)); } }", "src": "class\nTest { \n\n\n\n\nstatic\nint\nmergeSort(\nint\narr[], \nint\narray_size) \n\n{ \n\nint\ntemp[] = \nnew\nint\n[array_size]; \n\nreturn\n_mergeSort(arr, temp, \n0\n, array_size - \n1\n); \n\n} \n\n\n\n\nstatic\nint\n_mergeSort(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nright) \n\n{ \n\nint\nmid, inv_count = \n0\n; \n\nif\n(right > left) { \n\n\n\nmid = (right + left) / \n2\n; \n\n\n\n\ninv_count = _mergeSort(arr, temp, left, mid); \n\ninv_count += _mergeSort(arr, temp, mid + \n1\n, right); \n\n\n\n\ninv_count += merge(arr, temp, left, mid + \n1\n, right); \n\n} \n\nreturn\ninv_count; \n\n} \n\n\n\n\nstatic\nint\nmerge(\nint\narr[], \nint\ntemp[], \nint\nleft, \nint\nmid, \nint\nright) \n\n{ \n\nint\ni, j, k; \n\nint\ninv_count = \n0\n; \n\n\ni = left; \n\n\nj = mid; \n\n\nk = left; \n\n\nwhile\n((i <= mid - \n1\n) && (j <= right)) { \n\nif\n(arr[i] <= arr[j]) { \n\ntemp[k++] = arr[i++]; \n\n} \n\nelse\n{ \n\ntemp[k++] = arr[j++]; \n\n\n\n\ninv_count = inv_count + (mid - i); \n\n} \n\n} \n\n\n\n\nwhile\n(i <= mid - \n1\n) \n\ntemp[k++] = arr[i++]; \n\n\n\n\nwhile\n(j <= right) \n\ntemp[k++] = arr[j++]; \n\n\n\n\nfor\n(i = left; i <= right; i++) \n\narr[i] = temp[i]; \n\n\nreturn\ninv_count; \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain(String[] args) \n\n{ \n\nint\narr[] = \nnew\nint\n[] { \n1\n, \n20\n, \n6\n, \n4\n, \n5\n}; \n\nSystem.out.println(\n\"Number of inversions are \"\n+ mergeSort(arr, \n5\n)); \n\n} \n}", "index": 623, "complexity": "5"}
{"forwhile": "class Main { static void minAbsSumPair(int arr[], int n) { int sum, min_sum = 999999; int l = 0, r = n-1; int min_l = l, min_r = n-1; if(n < 2) { System.out.println(\"Invalid Input\"); return; } sort(arr, l, r); for(; l < r; ) { sum = arr[l] + arr[r]; if(Math.abs(sum) < Math.abs(min_sum)) { min_sum = sum; min_l = l; min_r = r; } if(sum < 0) l++; else r--; } System.out.println(\" The two elements whose \"+\"sum is minimum are \"+arr[min_l]+\" and \"+arr[min_r]); } public static void main (String[] args) { int arr[] = {1, 60, -10, 70, -80, 85}; int n = arr.length; minAbsSumPair(arr, n); } static int partition(int arr[], int low, int high) { int pivot = arr[high]; int i = (low-1); int j = low; while(j < high) { if(arr[j] <= pivot) { i++; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } j++; } int temp = arr[i+1]; arr[i+1] = arr[high]; arr[high] = temp; return i+1; } static void sort(int arr[], int low, int high) { if(low < high) { int pi = partition(arr, low, high); sort(arr, low, pi-1); sort(arr, pi+1, high); } } }", "src": "class\nMain \n{ \n\nstatic\nvoid\nminAbsSumPair(\nint\narr[], \nint\nn) \n\n{ \n\n\n\nint\nsum, min_sum = \n999999\n; \n\n\n\n\nint\nl = \n0\n, r = n-\n1\n; \n\n\n\n\nint\nmin_l = l, min_r = n-\n1\n; \n\n\n\n\nif\n(n < \n2\n) \n\n{ \n\nSystem.out.println(\n\"Invalid Input\"\n); \n\nreturn\n; \n\n} \n\n\n\n\nsort(arr, l, r); \n\n\nwhile\n(l < r) \n\n{ \n\nsum = arr[l] + arr[r]; \n\n\n\n\nif\n(Math.abs(sum) < Math.abs(min_sum)) \n\n{ \n\nmin_sum = sum; \n\nmin_l = l; \n\nmin_r = r; \n\n} \n\nif\n(sum < \n0\n) \n\nl++; \n\nelse\n\nr--; \n\n} \n\n\n\nSystem.out.println(\n\" The two elements whose \"\n+ \n\n\"sum is minimum are \"\n+ \n\narr[min_l]+ \n\" and \"\n+arr[min_r]); \n\n} \n\n\n\n\npublic\nstatic\nvoid\nmain (String[] args) \n\n{ \n\nint\narr[] = {\n1\n, \n60\n, -\n10\n, \n70\n, -\n80\n, \n85\n}; \n\nint\nn = arr.length; \n\nminAbsSumPair(arr, n); \n\n} \n\n\n\n\n\n\n\nstatic\nint\npartition(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nint\npivot = arr[high]; \n\nint\ni = (low-\n1\n); \n\n\nfor\n(\nint\nj=low; j<high; j++) \n\n{ \n\n\n\n\n\nif\n(arr[j] <= pivot) \n\n{ \n\ni++; \n\n\n\n\nint\ntemp = arr[i]; \n\narr[i] = arr[j]; \n\narr[j] = temp; \n\n} \n\n} \n\n\n\n\nint\ntemp = arr[i+\n1\n]; \n\narr[i+\n1\n] = arr[high]; \n\narr[high] = temp; \n\n\nreturn\ni+\n1\n; \n\n} \n\n\n\n\n\nstatic\nvoid\nsort(\nint\narr[], \nint\nlow, \nint\nhigh) \n\n{ \n\nif\n(low < high) \n\n{ \n\n\n\nint\npi = partition(arr, low, high); \n\n\n\n\n\n\nsort(arr, low, pi-\n1\n); \n\nsort(arr, pi+\n1\n, high); \n\n} \n\n} \n}", "index": 624, "complexity": "5"}
{"forwhile": "public class Test {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = reader.readLine().split(\" \");\n        int w = Integer.valueOf(line[0]);\n        int h = Integer.valueOf(line[1]);\n        int n = Integer.valueOf(line[2]);\n\n        Request[] requests = new Request[n];\n\n        int i = 0;\n        while (i < n) {\n            line = reader.readLine().split(\" \");\n            requests[i] = new Request(line[0], Integer.valueOf(line[1]));\n            i++;\n        }\n\n        for (int e : solve(h, w, requests)) {\n            System.out.println(e);\n        }\n\n\n\n\n\n\n\n\n\n    }\n\n    private static Request[] generate(int w, int h, int n) {\n        Request[] requests = new Request[n];\n        Random rnd = new Random();\n\n        int i = 0;\n        while (i < n) {\n            requests[i] = rnd.nextBoolean() ? new Request(\"V\", rnd.nextInt(w)) : new Request(\"H\", rnd.nextInt(h));\n            i++;\n        }\n\n        return requests;\n    }\n\n    private static long[] solve(int h, int w, Request[] requests) {\n        TreeSet<Integer> hTree = new TreeSet<>();\n        TreeSet<Integer> wTree = new TreeSet<>();\n\n        Queue<CoordinateWithSize> hHeap = new PriorityQueue<>();\n        Queue<CoordinateWithSize> wHeap = new PriorityQueue<>();\n\n        hTree.add(0);\n        hTree.add(h);\n        wTree.add(0);\n        wTree.add(w);\n\n        hHeap.add(new CoordinateWithSize(0, h));\n        wHeap.add(new CoordinateWithSize(0, w));\n\n        long[] res = new long[requests.length];\n        int i = 0;\n        while (i < requests.length) {\n            Request request = requests[i];\n\n            switch (request.type) {\n                case \"H\": {\n                    if (!hTree.contains(request.coordinate)) {\n                        int higher = hTree.higher(request.coordinate);\n                        int lower = hTree.lower(request.coordinate);\n\n                        hHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        hHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        hTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                case \"V\": {\n                    if (!wTree.contains(request.coordinate)) {\n                        int higher = wTree.higher(request.coordinate);\n                        int lower = wTree.lower(request.coordinate);\n\n                        wHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        wHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        wTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                default:\n                    throw new IllegalStateException(\"Unknown type [type=\" + request.type + \"]\");\n            }\n\n            for (;;) {\n                CoordinateWithSize c = hHeap.peek();\n                if (hTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                hHeap.remove();\n            }\n\n            for (;;) {\n                CoordinateWithSize c = wHeap.peek();\n                if (wTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                wHeap.remove();\n            }\n\n            res[i] = 1L * hHeap.peek().size * wHeap.peek().size;\n            i++;\n        }\n\n        return res;\n    }\n\n    private static class CoordinateWithSize implements Comparable<CoordinateWithSize> {\n\n        private final int coordinate;\n\n        private final int size;\n\n        public CoordinateWithSize(int coordinate, int size) {\n            this.coordinate = coordinate;\n            this.size = size;\n        }\n\n        @Override\n        public int compareTo(CoordinateWithSize o) {\n            return Integer.compare(o.size, size);\n        }\n    }\n\n    private static class Request {\n\n        private final String type;\n\n        private final int coordinate;\n\n        public Request(String type, int coordinate) {\n            this.type = type;\n            this.coordinate = coordinate;\n        }\n    }\n}", "src": "public class Test {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = reader.readLine().split(\" \");\n        int w = Integer.valueOf(line[0]);\n        int h = Integer.valueOf(line[1]);\n        int n = Integer.valueOf(line[2]);\n\n        Request[] requests = new Request[n];\n\n        for (int i = 0; i < n; i++) {\n            line = reader.readLine().split(\" \");\n            requests[i] = new Request(line[0], Integer.valueOf(line[1]));\n        }\n\n        for (long e : solve(h, w, requests))\n            System.out.println(e);\n\n\n\n\n\n\n\n\n\n    }\n\n    private static Request[] generate(int w, int h, int n) {\n        Request[] requests = new Request[n];\n        Random rnd = new Random();\n\n        for (int i = 0; i < n; i++) {\n            requests[i] = rnd.nextBoolean() ? new Request(\"V\", rnd.nextInt(w)) : new Request(\"H\", rnd.nextInt(h));\n        }\n\n        return requests;\n    }\n\n    private static long[] solve(int h, int w, Request[] requests) {\n        TreeSet<Integer> hTree = new TreeSet<>();\n        TreeSet<Integer> wTree = new TreeSet<>();\n\n        Queue<CoordinateWithSize> hHeap = new PriorityQueue<>();\n        Queue<CoordinateWithSize> wHeap = new PriorityQueue<>();\n\n        hTree.add(0);\n        hTree.add(h);\n        wTree.add(0);\n        wTree.add(w);\n\n        hHeap.add(new CoordinateWithSize(0, h));\n        wHeap.add(new CoordinateWithSize(0, w));\n\n        long[] res = new long[requests.length];\n        for (int i = 0; i < requests.length; i++) {\n            Request request = requests[i];\n\n            switch (request.type) {\n                case \"H\": {\n                    if (!hTree.contains(request.coordinate)) {\n                        int higher = hTree.higher(request.coordinate);\n                        int lower = hTree.lower(request.coordinate);\n\n                        hHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        hHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        hTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                case \"V\": {\n                    if (!wTree.contains(request.coordinate)) {\n                        int higher = wTree.higher(request.coordinate);\n                        int lower = wTree.lower(request.coordinate);\n\n                        wHeap.add(new CoordinateWithSize(lower, request.coordinate - lower));\n                        wHeap.add(new CoordinateWithSize(request.coordinate, higher - request.coordinate));\n\n                        wTree.add(request.coordinate);\n                    }\n\n                    break;\n                }\n                default:\n                    throw new IllegalStateException(\"Unknown type [type=\" + request.type + \"]\");\n            }\n\n            while (true) {\n                CoordinateWithSize c = hHeap.peek();\n                if (hTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                hHeap.remove();\n            }\n\n            while (true) {\n                CoordinateWithSize c = wHeap.peek();\n                if (wTree.higher(c.coordinate) - c.coordinate == c.size)\n                    break;\n                wHeap.remove();\n            }\n\n            res[i] = 1L * hHeap.peek().size * wHeap.peek().size;\n        }\n\n        return res;\n    }\n\n    private static class CoordinateWithSize implements Comparable<CoordinateWithSize> {\n\n        private final int coordinate;\n\n        private final int size;\n\n        public CoordinateWithSize(int coordinate, int size) {\n            this.coordinate = coordinate;\n            this.size = size;\n        }\n\n        @Override public int compareTo(CoordinateWithSize o) {\n            return Integer.compare(o.size, size);\n        }\n    }\n\n    private static class Request {\n\n        private final String type;\n\n        private final int coordinate;\n\n        public Request(String type, int coordinate) {\n            this.type = type;\n            this.coordinate = coordinate;\n        }\n    }\n}", "index": 625, "complexity": "5"}
{"forwhile": "public class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        InputReader.OutputWriter out = new InputReader.OutputWriter(outputStream);\n\n\n        int n = in.nextInt();\n        int s = in.nextInt();\n        Lift [] lifts = new Lift[n];\n        int i = 0;\n        while(i < n) {\n            lifts[i] = new Lift(in.nextInt(),in.nextInt());\n            i++;\n        }\n        Arrays.sort(lifts,(x,y)->y.getLevel() - x.getLevel());\n        \n        int ans = 0;\n        i = 0;\n        while(i < lifts.length) {\n            Lift current = lifts[i];\n            ans+=s-current.getLevel();\n            if(current.getTime()>ans) {\n                ans+=current.getTime() - ans;\n            }\n            s = current.getLevel();\n            i++;\n        }\n        ans+=s;\n        out.println(ans);\n        out.flush();\n    }\n}\n\nclass Lift {\n\n    int level;\n    int time;\n\n    public int getLevel() {\n        return level;\n    }\n\n    public int getTime() {\n        return time;\n    }\n\n    public Lift(int level, int time) {\n        this.level = level;\n        this.time = time;\n    }\n}\n\nclass InputReader extends BufferedReader {\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputStream) {\n        super(new InputStreamReader(inputStream), 32768);\n    }\n\n    public InputReader(String filename) {\n        super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(readLine());\n            } catch (IOException e) {\n                throw new RuntimeException();\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public Integer nextInt() {\n        return Integer.valueOf(next());\n    }\n    public Long nextLong() {return  Long.valueOf(next());}\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n    }\n}", "src": "public class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        InputReader.OutputWriter out = new InputReader.OutputWriter(outputStream);\n\n\n        int n = in.nextInt();\n        int s = in.nextInt();\n        Lift [] lifts = new Lift[n];\n        for (int i = 0; i < n; i++) {\n            lifts[i] = new Lift(in.nextInt(),in.nextInt());\n        }\n        Arrays.sort(lifts,(x,y)->y.getLevel() - x.getLevel());\n        \n        int ans = 0;\n        for (int i = 0; i < lifts.length; i++) {\n            Lift current = lifts[i];\n            ans+=s-current.getLevel();\n            if(current.getTime()>ans) {\n                ans+=current.getTime() - ans;\n            }\n            s = current.getLevel();\n        }\n        ans+=s;\n        out.println(ans);\n        out.flush();\n    }\n}\n\nclass Lift {\n\n    int level;\n    int time;\n\n    public int getLevel() {\n        return level;\n    }\n\n    public int getTime() {\n        return time;\n    }\n\n    public Lift(int level, int time) {\n        this.level = level;\n        this.time = time;\n    }\n}\n\nclass InputReader extends BufferedReader {\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputStream) {\n        super(new InputStreamReader(inputStream), 32768);\n    }\n\n    public InputReader(String filename) {\n        super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(readLine());\n            } catch (IOException e) {\n                throw new RuntimeException();\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public Integer nextInt() {\n        return Integer.valueOf(next());\n    }\n    public Long nextLong() {return  Long.valueOf(next());}\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n    }\n}", "index": 626, "complexity": "5"}
{"forwhile": "public class Main {\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n    static class Pair {\n        int a;\n        int b;\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int floor = sc.nextInt();\n        int time = 0;\n\n        Pair[] arr = new Pair[n];\n        int i = 0;\n        while(i < n) {\n            arr[i] = new Pair(sc.nextInt(), sc.nextInt());\n            i++;\n        }\n\n        Arrays.sort(arr, (Pair cur, Pair other) -> (other.a - cur.a));\n\n        i = 0;\n        while(i < n) {\n            time += floor - arr[i].a;\n            floor = arr[i].a;\n            time = Math.max(time, arr[i].b);\n            i++;\n        }\n\n        time += arr[n-1].a;\n\n        pw.println(time);\n        pw.close();\n    }\n}", "src": "public class Main {\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e){e.printStackTrace();}\n        }\n\n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {st = new StringTokenizer(br.readLine());}\n            catch (Exception e) {e.printStackTrace();}\n            return st.nextToken();\n        }\n\n        public int nextInt() {return Integer.parseInt(next());}\n\n        public long nextLong() {return Long.parseLong(next());}\n\n        public double nextDouble() {return Double.parseDouble(next());}\n\n        public String nextLine() {\n            String line = \"\";\n            if(st.hasMoreTokens()) line = st.nextToken();\n            else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n            while(st.hasMoreTokens()) line += \" \"+st.nextToken();\n            return line;\n        }\n    }\n\n    static class Pair {\n        int a;\n        int b;\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int floor = sc.nextInt();\n        int time = 0;\n\n        Pair[] arr = new Pair[n];\n        for(int i=0;i<n;i++) arr[i] = new Pair(sc.nextInt(), sc.nextInt());\n\n        Arrays.sort(arr, (Pair cur, Pair other) -> (other.a - cur.a));\n\n        for(int i=0;i<n;i++) {\n            time += floor - arr[i].a;\n            floor = arr[i].a;\n            time = Math.max(time, arr[i].b);\n            \n        }\n\n        time += arr[n-1].a;\n\n        pw.println(time);\n        pw.close();\n    }\n}", "index": 627, "complexity": "5"}
